[
  {
    "owner": "e2niee",
    "repo": "pandapower",
    "content": "TITLE: Multi-Timestep Optimization using PandaPower\nDESCRIPTION: This code demonstrates multi-timestep optimization using `pandapower.control.ConstControl` and `pandapower.timeseries.DFData`. It adds time series data for loads and sgens as controllers to the network, and then performs the optimization using `pp.runpm_multi_vstab`.  It handles reactive power constraints by defining and adding controllers for Qmax and Qmin.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n########################################################################\n####################### multi-timestep optimization ####################\n########################################################################\n\nfrom pandapower.control import ConstControl\nfrom pandapower.timeseries import DFData\n\n# For this method, we need to add the time series data into the pandapower.controller.\nnet_opt.controller.drop(net.controller.index, inplace=True) # remove the existing controllers\n\n# Add time series for load and sgen.\nConstControl(net_opt, element=\"load\", variable=\"p_mw\",\n             element_index=net.load.index.tolist(), profile_name=net.load.index.tolist(),\n             data_source=DFData(load_ts))\nConstControl(net_opt, element=\"sgen\", variable=\"p_mw\",\n             element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n             data_source=DFData(sgen_ts))\n\n# If required, we also need to creat a time series for the constraints, e.g., Qmax- and Qmin-value, for each time step. \ndf_qmax, df_qmin = sgen_ts.copy(), sgen_ts.copy()\ndf_qmax[df_qmax.columns] = net_opt.sgen.max_q_mvar\ndf_qmin[df_qmin.columns] = net_opt.sgen.min_q_mvar\n\n# Then create controllers for them.\nConstControl(net_opt, element=\"sgen\", variable=\"max_p_mw\",\n              element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n              data_source=DFData(sgen_ts))\nConstControl(net_opt, element=\"sgen\", variable=\"min_p_mw\",\n              element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n              data_source=DFData(sgen_ts))\nConstControl(net_opt, element=\"sgen\", variable=\"max_q_mvar\",\n              element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n              data_source=DFData(df_qmax))\nConstControl(net_opt, element=\"sgen\", variable=\"min_q_mvar\",\n              element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n              data_source=DFData(df_qmin))\n\n# For the multi-timestep optimization, we need to call another PandaModels-function.\ntry:\n    pp.runpm_multi_vstab(net_opt, from_time_step=0, to_time_step=96)\nexcept:\n    print(\"[WinError 3] The system cannot find the path specified to the python39.dll\")\n```\n\n----------------------------------------\n\nTITLE: Basic State Estimation Examples in Python\nDESCRIPTION: Examples of using different state estimation algorithms including SHGM, LAV, and QL estimators. Each example shows how to call the estimate() function with different parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Using shgm \nsuccess = estimate(net, algorithm=\"irwls\", estimator='shgm', a=5)\n\n# Using lav\nsuccess = estimate(net, algorithm=\"lp\")\n\n# Using ql\nsuccess = estimate(net, algorithm=\"opt\", estimator=\"ql\", a=3)\n```\n\n----------------------------------------\n\nTITLE: Changing Power Flow Algorithms in pandapower\nDESCRIPTION: This snippet demonstrates how to change the power flow algorithm in pandapower, including options for Newton-Raphson, Backward/Forward Sweep, Gauss-Seidel, and Fast-Decoupled methods.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, algorithm=\"bfsw\")\n\npp.runpp(net, algorithm=\"gs\")\n\npp.runpp(net)\n\npp.runpp(net, algorithm=\"gs\", max_iteration=10)\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis in Python with PandaPower\nDESCRIPTION: Executes a power flow calculation on the complete network using DC initialization and calculates voltage angles. The result is the updated network model with power flow results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, calculate_voltage_angles=True, init=\"dc\")\nnet\n```\n\n----------------------------------------\n\nTITLE: Creating a 3-Bus Power System with pandapower in Python\nDESCRIPTION: This snippet demonstrates how to create a simple 3-bus power system using pandapower. It includes creating buses, external grid, load, transformer, and line elements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n\n#create empty net\nnet = pp.create_empty_network()\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=20., name=\"Bus 1\")\nbus2 = pp.create_bus(net, vn_kv=0.4, name=\"Bus 2\")\nbus3 = pp.create_bus(net, vn_kv=0.4, name=\"Bus 3\")\n\n#create bus elements\npp.create_ext_grid(net, bus=bus1, vm_pu=1.02, name=\"Grid Connection\")\npp.create_load(net, bus=bus3, p_mw=0.100, q_mvar=0.05, name=\"Load\")\n\n#create branch elements\ntrafo = pp.create_transformer(net, hv_bus=bus1, lv_bus=bus2, std_type=\"0.4 MVA 20/0.4 kV\", name=\"Trafo\")\nline = pp.create_line(net, from_bus=bus2, to_bus=bus3, length_km=0.1, std_type=\"NAYY 4x50 SE\", name=\"Line\")\n```\n\n----------------------------------------\n\nTITLE: Loading Network and Running Power Flow in pandapower\nDESCRIPTION: This snippet demonstrates how to load a simple example network from pandapower.networks and run a power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks\n\nnet = pandapower.networks.example_simple()\nnet\n\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Running Time-Series Simulation with Contingency Analysis in pandapower\nDESCRIPTION: This code snippet executes a time-series simulation with contingency analysis for 24 time steps using the run_timeseries function from pandapower.timeseries.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.timeseries.run_timeseries(net, time_steps=range(24), \n                             run_control_fct=pp.contingency.run_contingency, nminus1_cases=nminus1_cases)\n```\n\n----------------------------------------\n\nTITLE: Accessing Power Flow Results in pandapower\nDESCRIPTION: This snippet shows how to access power flow results, specifically bus voltages and power injections, using pandas functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus\n\nnet.res_bus[net.bus.vn_kv==20.].vm_pu.min()\n\nload_or_generation_buses = set(net.load.bus.values) | set(net.sgen.bus.values) | set(net.gen.bus.values)\nnet.res_bus.vm_pu.loc[list(load_or_generation_buses)].max()\n```\n\n----------------------------------------\n\nTITLE: Setting User Options for Power Flow in pandapower\nDESCRIPTION: This snippet shows how to set user options that override default parameters for power flow calculations in a specific network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.set_user_pf_options(net, calculate_voltage_angles=True, init=\"dc\")\n\npp.runpp(net)\nnet.res_bus\n\npp.runpp(net, calculate_voltage_angles=False)\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Creating a Sample Network in pandapower\nDESCRIPTION: This snippet creates a four-bus example network in pandapower, including buses, transformers, lines, loads, and generators. It sets up the basic structure for the OPF examples.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport numpy as np\nnet = pp.create_empty_network()\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=220.)\nbus2 = pp.create_bus(net, vn_kv=110.)\nbus3 = pp.create_bus(net, vn_kv=110.)\nbus4 = pp.create_bus(net, vn_kv=110.)\n\n#create 220/110 kV transformer\npp.create_transformer(net, bus1, bus2, std_type=\"100 MVA 220/110 kV\")\n\n#create 110 kV lines\npp.create_line(net, bus2, bus3, length_km=70., std_type='149-AL1/24-ST1A 110.0')\npp.create_line(net, bus3, bus4, length_km=50., std_type='149-AL1/24-ST1A 110.0')\npp.create_line(net, bus4, bus2, length_km=40., std_type='149-AL1/24-ST1A 110.0')\n\n#create loads\npp.create_load(net, bus2, p_mw=60, controllable=False)\npp.create_load(net, bus3, p_mw=70, controllable=False)\npp.create_load(net, bus4, p_mw=10, controllable=False)\n\n#create generators\neg = pp.create_ext_grid(net, bus1, min_p_mw=-1000, max_p_mw=1000)\ng0 = pp.create_gen(net, bus3, p_mw=80, min_p_mw=0, max_p_mw=80,  vm_pu=1.01, controllable=True)\ng1 = pp.create_gen(net, bus4, p_mw=100, min_p_mw=0, max_p_mw=100, vm_pu=1.01, controllable=True)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running Power Flow in pandapower\nDESCRIPTION: Creates a simple example network using pandapower, prints the network structure, and runs a power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\n\nnet = nw.example_simple()\nprint(net)\n\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Setting Transformer Loading Constraint\nDESCRIPTION: This snippet demonstrates how to set a maximum loading constraint on a transformer and run the OPF with this constraint.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo[\"max_loading_percent\"] = 50\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Configuring Time-Series Simulation with Contingency Analysis in pandapower\nDESCRIPTION: This snippet sets up a time-series simulation with contingency analysis. It creates load and generation profiles, sets up constant controls, and configures an output writer to log relevant variables.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nload_profiles = pd.DataFrame(net.load.p_mw.values * (np.random.random((24, len(net.load))) * 0.4 + 0.8), \n                             index=np.arange(24), columns=net.load.index.values)\ndsl = pp.timeseries.DFData(load_profiles)\npp.control.ConstControl(net, element=\"load\", variable=\"p_mw\", element_index=net.load.index.values, \n                        profile_name=net.load.index.values, data_source=dsl)\n\n\ngen_profiles = pd.DataFrame(net.gen.p_mw.values * (np.random.random((24, len(net.gen))) * 0.4 + 0.8), \n                             index=np.arange(24), columns=net.gen.index.values)\ndsg = pp.timeseries.DFData(gen_profiles)\npp.control.ConstControl(net, element=\"gen\", variable=\"p_mw\", element_index=net.gen.index.values, \n                        profile_name=net.gen.index.values, data_source=dsg)\n\now = pp.timeseries.OutputWriter(net)\now.log_variable(\"res_line\", \"max_loading_percent\")\now.log_variable(\"res_line\", \"min_loading_percent\")\now.log_variable(\"res_bus\", \"max_vm_pu\")\now.log_variable(\"res_bus\", \"min_vm_pu\")\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis with pandapower in Python\nDESCRIPTION: This snippet demonstrates how to run a power flow analysis using pandapower and access the results for buses, lines, and transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_trafo\n```\n\n----------------------------------------\n\nTITLE: Setting Up Controllers for pandapower Time Series Simulation\nDESCRIPTION: Creates ConstControl objects to update the active power values of the load and static generator (sgen) during the simulation. Maps network elements to their corresponding profiles in the data source.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef create_controllers(net, ds):\n    ConstControl(net, element='load', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"load1_p\"])\n    ConstControl(net, element='sgen', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"sgen1_p\"])\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty Pandapower Network\nDESCRIPTION: Creates an empty network structure using Pandapower framework.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nnet = pp.create_empty_network()\n```\n\n----------------------------------------\n\nTITLE: Adding Line Measurements at a Bus\nDESCRIPTION: This snippet shows how to add active and reactive power measurements for two lines at a designated bus, with specified values and associated parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\npp.create_measurement(net, \"p\", \"line\", 0.888, 0.008, element=l1, side=b1)  # Pline (bus 1 -> bus 2) at bus 1\npp.create_measurement(net, \"p\", \"line\", 1.173, 0.008, element=l2, side=b1)  # Pline (bus 1 -> bus 3) at bus 1\npp.create_measurement(net, \"q\", \"line\", 0.568, 0.008, element=l1, side=b1)  # Qline (bus 1 -> bus 2) at bus 1\npp.create_measurement(net, \"q\", \"line\", 0.663, 0.008, element=l2, side=b1)  # Qline (bus 1 -> bus 3) at bus 1\nnet.measurement\n```\n\n----------------------------------------\n\nTITLE: Running Optimal Power Flow in pandapower\nDESCRIPTION: This snippet runs the Optimal Power Flow using the PYPOWER OPF. It sets a low delta value to ensure convergence and minimize tolerance for exceeding power limits.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Adding Power Transformer\nDESCRIPTION: Creates a transformer connection between high-voltage and medium-voltage buses using standard type specifications.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntrafo1 = pp.create_transformer(net, bus3, bus4, name=\"110kV/20kV transformer\", std_type=\"25 MVA 110/20 kV\")\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for pandapower Time Series Simulation\nDESCRIPTION: Imports necessary modules for running a time series simulation in pandapower, including ConstControl for updating P and Q values, DFData for handling time series data, OutputWriter for saving results, and run_timeseries for executing the simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport numpy as np\nimport pandas as pd\nimport tempfile\nimport random\nimport pandapower as pp\nfrom pandapower.timeseries import DFData\nfrom pandapower.timeseries import OutputWriter\nfrom pandapower.timeseries.run_time_series import run_timeseries\nfrom pandapower.control import ConstControl\n\nrandom.seed(10)\n```\n\n----------------------------------------\n\nTITLE: Adjusting Q-Limits and Re-Optimizing Reactive Power\nDESCRIPTION: Modifies the maximum and minimum reactive power limits for static generators and re-runs the optimization to achieve the desired reactive power setpoint.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nnet_opt.sgen[\"max_q_mvar\"] = net_opt.sgen.p_mw.values * 0.628\nnet_opt.sgen[\"min_q_mvar\"] = -net_opt.sgen.p_mw.values * 0.628\ntry:\n    pp.runpm_qflex(net_opt)\nexcept:\n    print(\"[WinError 3] The system cannot find the path specified to the python39.dll\")\ndisplay(net_opt.res_trafo.q_lv_mvar[0])  # show Q-injection at the interface after optimization\ndisplay(net_opt.res_sgen)\n```\n\n----------------------------------------\n\nTITLE: Running DC Power Flow with pandapower\nDESCRIPTION: Function reference for running DC power flow calculations using the pandapower.run.rundcpp function. The results are stored in the pandapower network format, abstracting away the underlying PYPOWER implementation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/dc.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.run.rundcpp\n```\n\n----------------------------------------\n\nTITLE: Creating External Grid Connection in PandaPower Network\nDESCRIPTION: Adds an external grid connection to the high voltage side of the transformer with specified parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.create_ext_grid(net, pp.get_element_index(net, \"bus\", 'Double Busbar 1'), vm_pu=1.03, va_degree=0, name='External grid',\n                   s_sc_max_mva=10000, rx_max=0.1, rx_min=0.1)\n\nnet.ext_grid # show external grid table\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cost Functions for Loss Minimization\nDESCRIPTION: This snippet sets up polynomial cost functions for the external grid and generators to minimize overall power feed-in, which is equivalent to loss minimization in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncosteg = pp.create_poly_cost(net, 0, 'ext_grid', cp1_eur_per_mw=10)\ncostgen1 = pp.create_poly_cost(net, 0, 'gen', cp1_eur_per_mw=10)\ncostgen2 = pp.create_poly_cost(net, 1, 'gen', cp1_eur_per_mw=10)\n```\n\n----------------------------------------\n\nTITLE: Running State Estimation in pandapower\nDESCRIPTION: This snippet shows how to run the state estimation process using the estimate function, initializing with a flat start condition, and accessing the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsuccess = estimate(net, init=\"flat\")\nV, delta = net.res_bus_est.vm_pu, net.res_bus_est.va_degree\n```\n\n----------------------------------------\n\nTITLE: Creating Power Lines\nDESCRIPTION: Adds power lines with different specifications and lengths connecting various buses in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nline1 = pp.create_line(net, bus1, bus2, length_km=10, std_type=\"N2XS(FL)2Y 1x300 RM/35 64/110 kV\",  name=\"Line 1\")\nline2 = pp.create_line(net, bus5, bus6, length_km=2.0, std_type=\"NA2XS2Y 1x240 RM/25 12/20 kV\", name=\"Line 2\")\nline3 = pp.create_line(net, bus6, bus7, length_km=3.5, std_type=\"48-AL1/8-ST1A 20.0\", name=\"Line 3\")\nline4 = pp.create_line(net, bus7, bus5, length_km=2.5, std_type=\"NA2XS2Y 1x240 RM/25 12/20 kV\", name=\"Line 4\")\n```\n\n----------------------------------------\n\nTITLE: Executing Time Series Analysis\nDESCRIPTION: Creates output directory and executes the time series analysis with the configured parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\noutput_dir = os.path.join(tempfile.gettempdir(), \"time_series_example\")\nprint(\"Results can be found in your local temp folder: {}\".format(output_dir))\nif not os.path.exists(output_dir):\n    os.mkdir(output_dir)\ntimeseries_example(output_dir)\n```\n\n----------------------------------------\n\nTITLE: Comparing Optimization Results for Loss and Loading\nDESCRIPTION: Compares the power losses and line loading percentages before and after optimization, showing the improvements achieved through reactive power control.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nprint(\"loss without optimization:\", net.res_line.pl_mw.values.sum())\nprint(\"loss with optimization:\", net_loss.res_line.pl_mw.values.sum())\nprint(\"++++++++++++++++++++++++++++++++++++++++++++++\")\nprint(\"loading without optimization:\", net.res_line.loading_percent.values.sum())\nprint(\"loading with optimization:\", net_loading.res_line.loading_percent.values.sum())\n```\n\n----------------------------------------\n\nTITLE: Adjusting Transformer Tap Position in pandapower\nDESCRIPTION: This snippet shows how to adjust the tap position of a transformer and run a power flow analysis to observe the effects on bus voltages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo.tap_pos.at[trafo] = -1\npp.runpp(net)\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Running AC Optimal Power Flow in pandapower with PYPOWER\nDESCRIPTION: This function runs an AC Optimal Power Flow using the PYPOWER OPF solver. It uses the interior point method and initializes with the center of operational constraints by default.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pypower_run.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.runopp\n```\n\n----------------------------------------\n\nTITLE: Displaying Result Tables for Different Elements in pandapower\nDESCRIPTION: This snippet displays result tables for various network elements after running a power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus\n\nnet.res_ext_grid\n\nnet.res_line\n\nnet.res_trafo\n\nnet.res_load\n\nnet.res_sgen\n\nnet.res_gen\n\nnet.res_shunt\n```\n\n----------------------------------------\n\nTITLE: Creating Three-Winding Transformer in PandaPower Network\nDESCRIPTION: Creates a three-winding transformer that transforms from 110 kV to 20 kV and 10 kV. Specifies detailed parameters for the transformer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nhv_bus = pp.get_element_index(net, \"bus\", \"Bus HV2\")\nmv_bus = pp.get_element_index(net, \"bus\", \"Bus MV0 20kV\")\nlv_bus = pp.get_element_index(net, \"bus\", \"Bus MV0\")\npp.create_transformer3w_from_parameters(net, hv_bus, mv_bus, lv_bus, vn_hv_kv=110, vn_mv_kv=20, vn_lv_kv=10, \n                                        sn_hv_mva=40, sn_mv_mva=15, sn_lv_mva=25, vk_hv_percent=10.1, \n                                        vk_mv_percent=10.1, vk_lv_percent=10.1, vkr_hv_percent=0.266667, \n                                        vkr_mv_percent=0.033333, vkr_lv_percent=0.04, pfe_kw=0, i0_percent=0, \n                                        shift_mv_degree=30, shift_lv_degree=30, tap_side=\"hv\", tap_neutral=0, tap_min=-8, \n                                        tap_max=8, tap_step_percent=1.25, tap_pos=0, name='HV-MV-MV-Trafo', \n                                        tap_changer_type=\"Ratio\")\n\n# show transformer3w table\nnet.trafo3w\n```\n\n----------------------------------------\n\nTITLE: Evaluating PV Hosting Capacity in pandapower Network\nDESCRIPTION: This code snippet evaluates the PV hosting capacity by iteratively adding PV plants until a constraint violation occurs. It performs multiple iterations to get a distribution of hosting capacity values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\niterations = 50\nresults = pd.DataFrame(columns=[\"installed\", \"violation\"])\n\nfor i in range(iterations):\n    net = load_network()\n    installed_mw = 0\n    while 1:\n        violated, violation_type = violations(net)\n        if violated:\n            results.loc[i] = [installed_mw, violation_type]\n            break\n        else:\n            plant_size = get_plant_size_mw()\n            pp.create_sgen(net, chose_bus(net), p_mw=plant_size, q_mvar=0)\n            installed_mw += plant_size\n```\n\n----------------------------------------\n\nTITLE: Handling Voltage Angles and Initialization in pandapower Power Flow\nDESCRIPTION: This snippet demonstrates how to calculate voltage angles correctly and initialize the power flow with DC loadflow or previous results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, calculate_voltage_angles=True, init=\"dc\")\n\nnet.res_bus.va_degree\n\npp.runpp(net, calculate_voltage_angles=True, init=\"results\")\nnet.res_bus.va_degree\n```\n\n----------------------------------------\n\nTITLE: Executing Time Series Simulation with Optimal Power Flow\nDESCRIPTION: This snippet sets up and runs the time series simulation using the pandapower run_timeseries function. It defines the network, data source, controllers, output writer, and time steps for the simulation. The network evolution over the defined timesteps is computed, implementing optimal power flow at each step.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\noutput_dir = os.path.join(tempfile.gettempdir(), \"time_series_example\")\nprint(\"Results can be found in your local temp folder: {}\".format(output_dir))\nif not os.path.exists(output_dir):\n    os.mkdir(output_dir)\n    \n# create the network\nnet = simple_test_net()\n\n# create (random) data source\nn_timesteps = 24\nprofiles, ds = create_data_source(n_timesteps)\n\n# create controllers (to control P values of the load and the sgen)\ncreate_controllers(net, ds)\n\n# time steps to be calculated. Could also be a list with non-consecutive time steps\ntime_steps = range(0, n_timesteps)\n\n# the output writer with the desired results to be stored to files.\now = create_output_writer(net, time_steps, output_dir=output_dir)\n\n# the main time series function with optimal power flow\nrun_timeseries(net, time_steps, run=pp.runopp, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Time Series Load Flow Analysis\nDESCRIPTION: Main function to execute time series load flow analysis, including network creation, data source setup, and controller configuration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef timeseries_example(output_dir):\n    # 1. create test net\n    net = ieee_european_lv_asymmetric('on_peak_566')\n    pp.runpp_3ph(net)\n    # 2. create data source for loads\n    profiles, ds = create_data_source()\n    # 3. create controllers (to control P values of the load and the sgen)\n    net = create_controllers(net, ds)\n\n    # time steps to be calculated. Could also be a list with non-consecutive time steps\n    time_steps = range(0, 672)\n    print(time_steps)\n\n    # 4. the output writer with the desired results to be stored to files.\n    ow = create_output_writer(net, time_steps, output_dir)\n\n    # 5. the main time series function\n    run_timeseries(net, time_steps, output_writer=ow, run=pp.runpp_3ph, continue_on_divergence=True)\n```\n\n----------------------------------------\n\nTITLE: Extracting Results from Multi-Timestep Optimization\nDESCRIPTION: This snippet extracts the results from the multi-timestep optimization. The results for each time step are saved in `net.res_ts_opt`. The code iterates through each time step and appends the mean voltage value to a list.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ny_multi = []\nfor t in range(96):\n    y_multi.append(net_opt.res_ts_opt[str(t)].res_bus.vm_pu[net_opt.sgen.bus].values.mean())\n```\n\n----------------------------------------\n\nTITLE: Running Unbalanced Power Flow Calculation in Pandapower\nDESCRIPTION: Executes an unbalanced power flow calculation on the defined network and stores results. The function uses Pandapower's built-in method to perform the simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.runpp_3ph(net)\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring CIGRE Medium Voltage Grid for Optimization\nDESCRIPTION: Sets up a CIGRE medium voltage grid with distributed energy resources, defines control constraints, and prepares copies of the network for different optimization scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\nfrom copy import deepcopy\n\nnet = nw.create_cigre_network_mv(with_der=\"pv_wind\")\nnet.load['controllable'] = False\nnet.sgen['controllable'] = True\nnet.sgen[\"max_p_mw\"] = net.sgen.p_mw.values\nnet.sgen[\"min_p_mw\"] = net.sgen.p_mw.values\nnet.sgen[\"max_q_mvar\"] = net.sgen.p_mw.values * 0.328\nnet.sgen[\"min_q_mvar\"] = -net.sgen.p_mw.values * 0.328\nnet.bus[\"max_vm_pu\"] = 1.1\nnet.bus[\"min_vm_pu\"] = 0.9\nnet.ext_grid[\"max_q_mvar\"] = 10000.0\nnet.ext_grid[\"min_q_mvar\"] = -10000.0\nnet.ext_grid[\"max_p_mw\"] = 10000.0\nnet.ext_grid[\"min_p_mw\"] = -10000.0\nnet.trafo[\"max_loading_percent\"] = 100.0\nnet.line[\"max_loading_percent\"] = 100.0\n\n# add an additional column named \"pm_param/target_branch\" to let PandaModels know the observed branches.\nnet.line[\"pm_param/target_branch\"] = True  \nnet.switch.loc[:, \"closed\"] = True\n\n# run power flow calculation\npp.runpp(net)\nnet_loss = deepcopy(net)\nnet_loading = deepcopy(net)\n```\n\n----------------------------------------\n\nTITLE: Defining Time Series Simulation Function in pandapower\nDESCRIPTION: Creates a function that demonstrates the steps for running a time series simulation in pandapower, including network creation, data source setup, controller configuration, output writer definition, and simulation execution.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef timeseries_example(output_dir):\n    # 1. create test net\n    net = simple_test_net()\n\n    # 2. create (random) data source\n    n_timesteps = 10\n    profiles, ds = create_data_source(n_timesteps)\n    # 3. create controllers (to control P values of the load and the sgen)\n    create_controllers(net, ds)\n\n    # time steps to be calculated. Could also be a list with non-consecutive time steps\n    time_steps = range(0, n_timesteps)\n\n    # 4. the output writer with the desired results to be stored to files.\n    ow = create_output_writer(net, time_steps, output_dir=output_dir)\n\n    # 5. the main time series function\n    run_timeseries(net, time_steps)\n    print(net.res_line.loading_percent)\n```\n\n----------------------------------------\n\nTITLE: Adding Synchronous Generator Configuration\nDESCRIPTION: Shows configuration of synchronous generator with rated parameters including power factor, voltage, apparent power, and impedance values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet = ring_network()\npp.create_gen(net, 2, p_mw=0, vm_pu=1.0, cos_phi=0.8, vn_kv=22, sn_mva=5, xdss_pu=0.2, rdss_ohm=0.005)\nnet\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis on the Network in Python\nDESCRIPTION: This line executes the power flow analysis on the created network using the runpp function from Pandapower, allowing for the evaluation of the network's operating conditions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit Current for Wind Power Station with Doubly Fed Asynchronous Generator\nDESCRIPTION: This snippet calculates the initial symmetrical short-circuit current and peak short-circuit current for a wind power station with a doubly fed asynchronous generator.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nikss_ka = 1.1 * 20 / (np.sqrt(3) * Z_WD)\nikss_ka\n```\n\nLANGUAGE: python\nCODE:\n```\n# skss\nikss_ka * 20 * np.sqrt(3)\n```\n\nLANGUAGE: python\nCODE:\n```\n# ip_ka = ikss_ka * kappa * sqrt(2)\nikss_ka * k_WD * np.sqrt(2)\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage CIGRE Network\nDESCRIPTION: Creates a high voltage transmission network with configurable connection line length between buses 6a and 6b. The network includes shunts, transformers, buses, lines, loads, external grid, generators, and bus geodata.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/cigre.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_cigre_network_hv\n\n# You may specify a length for the connection line between buses 6a and 6b\nnet = create_cigre_network_hv(length_km_6a_6b=0.1)\n```\n\n----------------------------------------\n\nTITLE: Running the time series simulation\nDESCRIPTION: This code snippet instantiates the network and output writer, and subsequently executes the time series simulation using the run_time_series function.  It runs the simulation for a specified range of time steps.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet = simple_test_net()\n\now = timeseries_example(net, None)\npp.timeseries.run_time_series.run_timeseries(net, time_steps=range(24))\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring Controllers\nDESCRIPTION: This function creates and configures the controllers for the time series simulation. It includes a ContinuousTapControl for the transformer tap changer and ConstControl objects for setting the voltage setpoint of the tap changer controller, as well as controlling the active power of the generator and load. The ConstControl objects link the controllers to the DataFrame data source.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef create_controllers(net, ds):\n    c = control.ContinuousTapControl(net=net, element_index=0, vm_set_pu=0.98, tol=1e-6)\n    ConstControl(net, element='controller', variable='object.vm_set_pu', element_index=c.index, data_source=ds, \n                 profile_name='c')\n    ConstControl(net, element='sgen', variable='p_mw', element_index=0, data_source=ds, profile_name='sgen1_p')\n    ConstControl(net, element='load', variable='p_mw', element_index=0, data_source=ds, profile_name='load1_p')\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis on Converted pandapower Network\nDESCRIPTION: This snippet demonstrates how to run a power flow analysis on the converted pandapower network using the 'runpp' function. It also prints the first few bus results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/cim2pp.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nprint(net.res_bus.iloc[0:5]) # print first few bus results\n```\n\n----------------------------------------\n\nTITLE: Evaluating Constraint Violations in Power Grid with pandapower\nDESCRIPTION: This function runs a power flow analysis and checks for line loading, transformer loading, and voltage violations in a pandapower network. It returns a boolean flag indicating violation and a string describing the type of violation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n\ndef violations(net):\n    pp.runpp(net)\n    if net.res_line.loading_percent.max() > 50:\n        return (True, \"Line \\n Overloading\")\n    elif net.res_trafo.loading_percent.max() > 50:\n        return (True, \"Transformer \\n Overloading\")\n    elif net.res_bus.vm_pu.max() > 1.04:\n        return (True, \"Voltage \\n Violation\")\n    else:\n        return (False, None)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Network with External Grid\nDESCRIPTION: Creates an empty network with two buses and an external grid connection including sequence network parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.create_empty_network(sn_mva = 100 )\nbus_eg  =  pp.create_bus(net, vn_kv = 110, name = \"Ext. Grid\")\nbus_load  =  pp.create_bus(net, vn_kv = 110, name = \"Load\")\n\npp.create_ext_grid(net, bus=bus_eg, vm_pu= 1.0, name=\"Grid Connection\",\n                   s_sc_max_mva=5000,rx_max=0.1,r0x0_max= 0.1,x0x_max=1.0)\n```\n\n----------------------------------------\n\nTITLE: Performing Short-Circuit Calculation with pandapower for Asynchronous Generator\nDESCRIPTION: This snippet uses pandapower to perform short-circuit calculations for a wind power station with an asynchronous generator and displays the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%capture\n# now with pandapower:\nnet = create_net(\"async\", step_up_trafo=True)\nsc.calc_sc(net, ip=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.sgen)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: Creating Data Source for pandapower Time Series Simulation\nDESCRIPTION: Generates a pandas DataFrame with random values for load and static generator (sgen) active power profiles. Converts the DataFrame to a DFData object for use in the simulation controllers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_source(n_timesteps=24):\n    profiles = pd.DataFrame()\n    \n    profiles['load1_p'] = np.random.random(n_timesteps) * 15.\n    profiles['sgen1_p'] = np.random.random(n_timesteps) * 20.\n\n    ds = DFData(profiles)\n\n    return profiles, ds\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit Current for Wind Power Station with Full Size Converter\nDESCRIPTION: This snippet calculates the short-circuit current contribution for a wind power station with a full size converter, which is considered as a current source.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nS_rWF = 2.5 # MVA\nU_rWF = 20 # kV\n```\n\nLANGUAGE: python\nCODE:\n```\nI_rWF = S_rWF / (np.sqrt(3) * U_rWF)\nI_rWF # kA\n```\n\nLANGUAGE: python\nCODE:\n```\nI_skWF = I_kWFmax = 1.3 * I_rWF\nI_skWF # kA\n```\n\nLANGUAGE: python\nCODE:\n```\nkappa = 1.02 + 0.98 * np.exp(-3*0.1)\nI_skWF * np.sqrt(2) # because single power station unit with full size converter\n```\n\nLANGUAGE: python\nCODE:\n```\n# skss\nI_skWF * 20 * np.sqrt(3)\n```\n\n----------------------------------------\n\nTITLE: Running Voltage Setpoint Optimization with Pandapower in Python\nDESCRIPTION: Runs optimization function to maintain voltage setpoints using pandapower, which interfaces with PandaModels.jl in the background. This snippet prepares and executes the optimization using predefined parameters, throwing detailed exceptions if any issues occur.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_vstab(net_opt)\nexcept Exception as err:\n    print(err)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic PandaPower Network Structure\nDESCRIPTION: Creates a basic electrical network with buses, lines, transformer, loads, and switches. Demonstrates the fundamental network creation functions in PandaPower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/examples.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.create import create_empty_network, create_bus, create_ext_grid, create_line, \\\n         create_transformer_from_parameters, create_load, create_switch\n\nnet = create_empty_network()\n\ncreate_bus(net, name = \"110 kV bar\", vn_kv = 110, type = 'b')\ncreate_bus(net, name = \"20 kV bar\", vn_kv = 20, type = 'b')\ncreate_bus(net, name = \"bus 2\", vn_kv = 20, type = 'b')\ncreate_bus(net, name = \"bus 3\", vn_kv = 20, type = 'b')\ncreate_bus(net, name = \"bus 4\", vn_kv = 20, type = 'b')\ncreate_bus(net, name = \"bus 5\", vn_kv = 20, type = 'b')\ncreate_bus(net, name = \"bus 6\", vn_kv = 20, type = 'b')\n\ncreate_ext_grid(net, 0, vm_pu = 1)\n\ncreate_line(net, name = \"line 0\", from_bus = 1, to_bus = 2, length_km = 1, std_type = \"NAYY 4x150 SE\")\ncreate_line(net, name = \"line 1\", from_bus = 2, to_bus = 3, length_km = 1, std_type = \"NAYY 4x150 SE\")\ncreate_line(net, name = \"line 2\", from_bus = 3, to_bus = 4, length_km = 1, std_type = \"NAYY 4x150 SE\")\ncreate_line(net, name = \"line 3\", from_bus = 4, to_bus = 5, length_km = 1, std_type = \"NAYY 4x150 SE\")\ncreate_line(net, name = \"line 4\", from_bus = 5, to_bus = 6, length_km = 1, std_type = \"NAYY 4x150 SE\")\ncreate_line(net, name = \"line 5\", from_bus = 6, to_bus = 1, length_km = 1, std_type = \"NAYY 4x150 SE\")\n\ncreate_transformer_from_parameters(net, hv_bus=0, lv_bus=1, i0_percent=0.038, pfe_kw=11.6,\n\tvkr_percent=0.322, sn_mva=40, vn_lv_kv=22.0, vn_hv_kv=110.0, vk_percent=17.8)\n\ncreate_load(net, 2, p_mw = 1, q_mvar = 0.2, name = \"load 0\")\ncreate_load(net, 3, p_mw = 1, q_mvar = 0.2, name = \"load 1\")\ncreate_load(net, 4, p_mw = 1, q_mvar = 0.2, name = \"load 2\")\ncreate_load(net, 5, p_mw = 1, q_mvar = 0.2, name = \"load 3\")\ncreate_load(net, 6, p_mw = 1, q_mvar = 0.2, name = \"load 4\")\n\ncreate_switch(net, bus = 1, element = 0, et = 'l')\ncreate_switch(net, bus = 2, element = 0, et = 'l')\ncreate_switch(net, bus = 2, element = 1, et = 'l')\ncreate_switch(net, bus = 3, element = 1, et = 'l')\ncreate_switch(net, bus = 3, element = 2, et = 'l')\ncreate_switch(net, bus = 4, element = 2, et = 'l')\ncreate_switch(net, bus = 4, element = 3, et = 'l', closed = 0)\ncreate_switch(net, bus = 5, element = 3, et = 'l')\ncreate_switch(net, bus = 5, element = 4, et = 'l')\ncreate_switch(net, bus = 6, element = 4, et = 'l')\ncreate_switch(net, bus = 6, element = 5, et = 'l')\ncreate_switch(net, bus = 1, element = 5, et = 'l')\n```\n\n----------------------------------------\n\nTITLE: Running Final Three Phase Load Flow\nDESCRIPTION: Performs the final three phase load flow calculation and displays results for the complete network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.add_zero_impedance_parameters(net)\npp.runpp_3ph(net)\nnet.res_bus_3ph\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Test Network with Pandapower\nDESCRIPTION: This function creates a simple power network with three buses, one external grid, lines connecting the buses, a load, and a static generator (sgen). The network is set with specific constraints, costs, and load parameters. The external grid and sgen are assigned costs, while sgen is allowed to be controlled through optimal power flow (OPF).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef simple_test_net():\n    net = pp.create_empty_network()\n\n    b0 = pp.create_bus(net, 110, min_vm_pu=0.98, max_vm_pu=1.05)\n    b1 = pp.create_bus(net, 20, min_vm_pu=0.98, max_vm_pu=1.05)\n    b2 = pp.create_bus(net, 20, min_vm_pu=0.98, max_vm_pu=1.05)\n    b3 = pp.create_bus(net, 20, min_vm_pu=0.9, max_vm_pu=1.05)\n    \n    e=pp.create_ext_grid(net, b0, min_p_mw=-200, max_p_mw=200)\n    costeg = pp.create_poly_cost(net, e, 'ext_grid', cp1_eur_per_mw=10)\n    \n    pp.create_line(net, b0, b1, 10, \"149-AL1/24-ST1A 110.0\", max_loading_percent=80)\n    pp.create_line(net, b1, b2, 10, \"149-AL1/24-ST1A 110.0\", max_loading_percent=80)\n    pp.create_line(net, b1, b3, 10, \"149-AL1/24-ST1A 110.0\", max_loading_percent=80)\n\n    pp.create_load(net, b3, p_mw=10., q_mvar=-5., name='load1', controllable=False)\n    g1=pp.create_sgen(net, b2, p_mw=0., q_mvar=-2, min_p_mw=0, max_p_mw=30, min_q_mvar=-3, max_q_mvar=3, name='sgen1', controllable=True)\n    pp.create_poly_cost(net, g1, 'sgen1', cp1_eur_per_mw=-1)\n    \n    return net\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow with ContinuousTapControl in Python\nDESCRIPTION: This code runs a power flow calculation with the implemented ContinuousTapControl and checks the resulting transformer voltages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, run_control=True)\nnet.res_trafo.vm_lv_pu\n```\n\n----------------------------------------\n\nTITLE: Fixing Network Issues Based on Diagnostic Results\nDESCRIPTION: These snippets demonstrate how to fix various issues identified by the diagnostic function, such as disconnected elements, inconsistent voltages, and wrong reference systems.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfaulty_net.switch.closed.loc[8, 9] = True\nfaulty_net.bus.vn_kv.loc[2, 5] = 20\nfaulty_net.line.length_km.at[0] = 1\nfaulty_net.trafo.hv_bus.at[0] = 0\nfaulty_net.trafo.lv_bus.at[0] = 1\nfaulty_net.load.p_mw.at[0] = 1\n```\n\n----------------------------------------\n\nTITLE: Creating Medium-to-Low Voltage Transformer in Python\nDESCRIPTION: Creates a transformer connecting medium voltage (10 kV) and low voltage (0.4 kV) networks. The transformer is defined with detailed parameters including nominal power, voltage ratio, impedance values, and tap changer settings.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nhv_bus = pp.get_element_index(net, \"bus\", \"Bus MV4\")\nlv_bus = pp.get_element_index(net, \"bus\",\"Bus LV0\")\npp.create_transformer_from_parameters(net, hv_bus, lv_bus, sn_mva=.4, vn_hv_kv=10, vn_lv_kv=0.4, vkr_percent=1.325, vk_percent=4, pfe_kw=0.95, i0_percent=0.2375, tap_side=\"hv\", tap_neutral=0, tap_min=-2, tap_max=2, tap_step_percent=2.5, tap_changer_type=\"Ratio\", tp_pos=0, shift_degree=150, name='MV-LV-Trafo')\n\n#show only low voltage transformer\nnet.trafo[net.trafo.lv_bus.isin(lv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Creating CIGRE Medium Voltage Grid with Voltage and Loading Limits in Python\nDESCRIPTION: This function creates a CIGRE medium voltage grid using pandapower.networks and sets voltage magnitude and line loading limits. It returns a pandapower network object with predefined constraints.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_tnep.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.networks as nw\nfrom pandapower.converter.pandamodels.to_pm import init_ne_line\n\ndef cigre_grid():\n    net = nw.create_cigre_network_mv()\n\n    net[\"bus\"].loc[:, \"min_vm_pu\"] = 0.95\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = 1.05\n\n    net[\"line\"].loc[:, \"max_loading_percent\"] = 60.\n    return net\n```\n\n----------------------------------------\n\nTITLE: Plotting Network Topology in pandapower\nDESCRIPTION: Defines a function to plot the power system topology, including bus labels and various network elements using pandapower's plotting functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef plot_net(net, ax=None):\n    import geojson\n    if ax is None:\n        fig, ax = mpl.subplots(1, 1, figsize=(10, 8))\n\n    sizes = get_collection_sizes(net)\n\n    # create collections for elements\n    collections = list()\n    collections.append(plt.create_bus_collection(net, size=sizes[\"bus\"]))\n    collections.append(plt.create_line_collection(net, use_bus_geodata=True))\n    collections.append(plt.create_trafo_collection(net, size=sizes[\"trafo\"]))\n    collections.append(plt.create_ext_grid_collection(net, size=sizes[\"ext_grid\"], orientation=1.5))\n    collections.append(plt.create_bus_bus_switch_collection(net, size=sizes[\"switch\"]))\n    collections.append(\n        plt.create_line_switch_collection(net, distance_to_bus=sizes[\"switch_distance\"], size=sizes[\"switch\"]))\n    collections.append(plt.create_load_collection(net, size=sizes[\"load\"]))\n\n    # add labels for each bus\n    for idx in net.bus.geo.index:\n        x, y = geojson.loads(net.bus.loc[idx, 'geo']).coordinates \n        y += sizes[\"bus\"] * 1.\n        ax.text(x, y, str(idx), fontsize=12, color=\"r\")\n\n    plt.draw_collections(collections, ax=ax)\n    mpl.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage Transformer in PandaPower Network\nDESCRIPTION: Creates a 380/110 kV transformer connecting two buses. Uses get_element_index to find bus indices and creates the transformer with specified parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nhv_bus = pp.get_element_index(net, \"bus\", \"Bus DB 2\")\nlv_bus = pp.get_element_index(net, \"bus\", \"Bus SB 1\")\npp.create_transformer_from_parameters(net, hv_bus, lv_bus, sn_mva=300, vn_hv_kv=380, vn_lv_kv=110, vkr_percent=0.06,\n                                      vk_percent=8, pfe_kw=0, i0_percent=0, tp_pos=0, shift_degree=0, name='EHV-HV-Trafo')\n\nnet.trafo # show trafo table\n```\n\n----------------------------------------\n\nTITLE: Adding Network Switches\nDESCRIPTION: Creates circuit breakers and load break switches for bus-bus and bus-line connections.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsw1 = pp.create_switch(net, bus2, bus3, et=\"b\", type=\"CB\", closed=True)\nsw2 = pp.create_switch(net, bus4, bus5, et=\"b\", type=\"CB\", closed=True)\nsw3 = pp.create_switch(net, bus5, line2, et=\"l\", type=\"LBS\", closed=True)\nsw4 = pp.create_switch(net, bus6, line2, et=\"l\", type=\"LBS\", closed=True)\nsw5 = pp.create_switch(net, bus6, line3, et=\"l\", type=\"LBS\", closed=True)\nsw6 = pp.create_switch(net, bus7, line3, et=\"l\", type=\"LBS\", closed=False)\nsw7 = pp.create_switch(net, bus7, line4, et=\"l\", type=\"LBS\", closed=True)\nsw8 = pp.create_switch(net, bus5, line4, et=\"l\", type=\"LBS\", closed=True)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Random Distribution for Grid Elements using Pandapower\nDESCRIPTION: This code snippet sets up a CIGRE medium voltage grid using Pandapower and initializes random distributions for grid elements at specific buses. It uses a triangular distribution for loads and a beta distribution for PV generation. The random data simulates uncertainty in loads and generation at designated buses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#  CIGRE grid\nnet = pp.networks.create_cigre_network_mv(with_der=\"pv_wind\")\n\n# grid elements with uncertainty\nload_r4 = net.load.index[net.load.bus == 4][0]\nload_ci9 = net.load.index[net.load.bus == 9][0]\nsgen_pv10 = net.sgen.index[net.sgen.bus == 10][0]\n\n# amount of random values\nn_random_values = 1000\n\n# random values as timeseries data\nload_r4_distr = np.random.triangular(0, 0.6, 1, n_random_values)\nload_ci9_distr = np.random.triangular(0.3, 0.7, 1.2, n_random_values)\nsgen_pv10_distr = np.random.beta(2, 2, n_random_values)\n```\n\n----------------------------------------\n\nTITLE: Creating Medium Voltage CIGRE Network with All DER Types\nDESCRIPTION: Creates a medium voltage network with all 15 distributed energy resources including PV, wind, batteries, fuel cells, and CHP units. Provides the most comprehensive DER integration scenario.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/cigre.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_cigre_network_mv\n\nnet = create_cigre_network_mv(with_der=\"all\")\n```\n\n----------------------------------------\n\nTITLE: Conducting Short Circuit Analysis with pandapower in Python\nDESCRIPTION: These snippets demonstrate how to set up and perform a short circuit analysis using pandapower's shortcircuit module, including defining short circuit parameters and calculating fault currents.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet.ext_grid[\"s_sc_max_mva\"] = 100\nnet.ext_grid[\"rx_max\"] = 0.1\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.shortcircuit as sc\nsc.calc_sc(net, case=\"max\", ip=True, r_fault_ohm=2.)\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_sc\n```\n\n----------------------------------------\n\nTITLE: Running Time Series Simulation\nDESCRIPTION: Shows how to run a time series simulation with the storage controller and track results using OutputWriter.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/building_a_controller.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# defining an OutputWriter to track certain variables\now = ts.OutputWriter(net)\n\now.log_variable(\"res_storage\", \"p_mw\")\now.log_variable(\"storage\", \"soc_percent\")\n\n# starting time series simulation\nts.run_timeseries(net, time_steps=range(0, 6))\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Calculation with power-grid-model\nDESCRIPTION: This snippet demonstrates how to run a power flow calculation using the power-grid-model library via the `pp.runpp_pgm` function. It then accesses and displays the results stored in the `net.res_bus` attribute. Note that `pp.runpp_pgm` has different arguments than `pp.runpp()`.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/power-grid-model_powerflow.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.runpp_pgm(net)\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Test Grid\nDESCRIPTION: This snippet creates a 5-bus power system using the `simple_test_grid` function from `pandapower.test.loadflow.test_tdpf`. The load and sgen scaling factors are set to 0.25 and 0.5, respectively, and a generator is included in the grid. The distributed slack option is disabled.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = simple_test_grid(load_scaling=0.25, sgen_scaling=0.5, with_gen=True, distributed_slack=False)\n```\n\n----------------------------------------\n\nTITLE: Implementing IDMT Relays in Pandapower Network\nDESCRIPTION: This code snippet shows how to create Inverse Definite Minimum Time (IDMT) relays for each switch in a Pandapower network, including changing switch types and configuring the relays.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Change the switch type in the network\n\nnet=oc_relay_net()\nnet.switch.type='CB_IDMT'\n\n# create IDMT OC Relays\nfor k in range(6):\n    OCRelay(net, switch_index=k, oc_relay_type='IDMT', time_settings=[1, 0.5])\n    \n# create short circuit\nnet_sc = create_sc_bus(net, sc_line_id=4, sc_fraction=0.5)\nsc.calc_sc(net_sc, bus=max(net_sc.bus.index), branch_results=True)\n\n# find protection results\nprotection_results = calculate_protection_times(net_sc, scenario='sc')\n\n# show protection_results\nprotection_results\n```\n\n----------------------------------------\n\nTITLE: Adding Static Generator\nDESCRIPTION: Creates a static generator with specified active and reactive power generation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npp.create_sgen(net, bus7, p_mw=2, q_mvar=-0.5, name=\"static generator\")\n```\n\n----------------------------------------\n\nTITLE: Checking Load Flow Convergence\nDESCRIPTION: Verifies if the load flow calculation converged successfully.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet['converged']\n```\n\n----------------------------------------\n\nTITLE: Running Controlled Power Flow in Python\nDESCRIPTION: This code runs a controlled power flow with the implemented DiscreteTapControl and checks the resulting transformer voltages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# running a control-loop\npp.runpp(net, run_control=True)\nnet.res_trafo.vm_lv_pu\n```\n\n----------------------------------------\n\nTITLE: Creating Buses and Initializing Network in Pandapower\nDESCRIPTION: This snippet illustrates how to import Pandapower, create an empty network, and initiate three buses with specified voltage levels for the network. Pandapower must be installed to create and manage power networks.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n\nnet = pp.create_empty_network()\nb1  = pp.create_bus(net, 20.0)\nb2  = pp.create_bus(net, 0.4)\nb3  = pp.create_bus(net, 0.4)\n```\n\n----------------------------------------\n\nTITLE: Comparing Load Flow Results with Different Q Limits in Python\nDESCRIPTION: This snippet compares the load flow results for three scenarios: no reactive power limit, general reactive power limits, and limits derived from the characteristic table. It prints out the Qmin, Qmax, generator results, and bus results for each case.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(\"\\n --------No reactive power limit applied-----------------\\n\")\nprint(f\"Qmin={net1.gen.min_q_mvar.loc[0]}\")\nprint(f\"QMax={net1.gen.max_q_mvar.loc[0]}\\n\")\nprint(net1.res_gen)\nprint(net1.res_bus)\nprint(\"\\n --------General reactive power limits enforced-------------\\n\")\nprint(f\"Qmin={net2.gen.min_q_mvar.loc[0]}\")\nprint(f\"QMax={net2.gen.max_q_mvar.loc[0]}\\n\")\nprint(net2.res_gen)\nprint(net2.res_bus)\nprint(\"\\n --------Limits derived from the characteristic table---------\\n\")\nprint(f\"Qmin={net3.gen.min_q_mvar.loc[0]}\")\nprint(f\"QMax={net3.gen.max_q_mvar.loc[0]}\\n\")\nprint(net3.res_gen)\nprint(net3.res_bus)\n```\n\n----------------------------------------\n\nTITLE: Adding Network Loads\nDESCRIPTION: Creates network loads with specified active and reactive power consumption, including ZIP load model example.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npp.create_load(net, bus7, p_mw=2, q_mvar=4, scaling=0.6, name=\"load\")\npp.create_load(net, bus7, p_mw=2, q_mvar=4, const_z_percent=30, const_i_percent=20, name=\"zip_load\")\n```\n\n----------------------------------------\n\nTITLE: Running DC Optimal Power Flow\nDESCRIPTION: This snippet shows how to run a DC Optimal Power Flow, which is a linearized version of the OPF problem that doesn't consider voltage magnitudes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npp.rundcopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Implementing DTOC Relays in Pandapower Network\nDESCRIPTION: This code snippet demonstrates how to create Definite Time Over Current (DTOC) relays for each switch in the network using the OCRelay class from Pandapower's protection module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = oc_relay_net()\nfrom pandapower.protection.protection_devices.ocrelay import OCRelay\n\nfor k in range(6):\n    OCRelay(net, switch_index=k, oc_relay_type='DTOC', time_settings=[0.07, 0.5, 0.3])\n```\n\n----------------------------------------\n\nTITLE: Running Contingency Analysis in pandapower\nDESCRIPTION: This code snippet demonstrates how to run a basic contingency analysis on a pandapower network. It creates a case9 network, defines N-1 cases for lines, and runs the contingency analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.networks.case9()\n\nnminus1_cases = {\"line\": {\"index\": net.line.index.values}}\nres = pp.contingency.run_contingency(net, nminus1_cases)\n```\n\n----------------------------------------\n\nTITLE: Creating Ring Network for Short-Circuit Analysis in Python\nDESCRIPTION: Creates a sample ring network with 4 buses connected by transformer and lines with one open sectioning point. Includes external grid connection and basic network components.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.shortcircuit as sc\n\ndef ring_network():\n    net = pp.create_empty_network()\n    b1 = pp.create_bus(net, 220)\n    b2 = pp.create_bus(net, 110)\n    b3 = pp.create_bus(net, 110)\n    b4 = pp.create_bus(net, 110)\n    pp.create_ext_grid(net, b1, s_sc_max_mva=100., s_sc_min_mva=80., rx_min=0.20, rx_max=0.35)\n    pp.create_transformer(net, b1, b2, \"100 MVA 220/110 kV\")\n    pp.create_line(net, b2, b3, std_type=\"N2XS(FL)2Y 1x120 RM/35 64/110 kV\" , length_km=15.)\n    l2 = pp.create_line(net, b3, b4, std_type=\"N2XS(FL)2Y 1x120 RM/35 64/110 kV\" , length_km=12.)\n    pp.create_line(net, b4, b2, std_type=\"N2XS(FL)2Y 1x120 RM/35 64/110 kV\" , length_km=10.)\n    pp.create_switch(net, b4, l2, closed=False, et=\"l\")\n    return net\n```\n\n----------------------------------------\n\nTITLE: Creating Cost Functions for Maximizing Generation in pandapower OPF\nDESCRIPTION: Creates cost functions to maximize renewable generation (minimize curtailment) by assigning a negative linear cost coefficient, making higher power output less expensive.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/formulation.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 0, 'sgen', cp1_eur_per_mw=-1)\npp.create_poly_cost(net, 0, 'gen', cp1_eur_per_mw=-1)\npp.create_pwl_cost(net, 0, \"sgen\", [[net.sgen.min_p_mw.at[0], net.sgen.max_p_mw.at[0], -1]])\npp.create_pwl_cost(net, 0, \"gen\", [[net.gen.min_p_mw.at[0], net.gen.max_p_mw.at[0], -1]])\n```\n\n----------------------------------------\n\nTITLE: Running Voltage Stability Optimization\nDESCRIPTION: Executes the voltage stability optimization using PandaModels.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_vstab(net)\nexcept Exception as err:\n    print(err)\n```\n\n----------------------------------------\n\nTITLE: Plotting the Power Grid using Pandapower - Python\nDESCRIPTION: This snippet utilizes the plotting module from pandapower to visualize the created power grid.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plot\n%matplotlib inline\nplot.set_line_geodata_from_bus_geodata(net)\nplot.simple_plot(net)\n```\n\n----------------------------------------\n\nTITLE: Accessing pandapower Network Data Structures in Python\nDESCRIPTION: These snippets show how to access various dataframes in a pandapower network object, including bus, line, transformer, and load information.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.bus\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.line\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.load\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Piecewise Linear Costs\nDESCRIPTION: This snippet shows how to define more complex piecewise linear costs for a generator, with different costs for different power ranges.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnet.pwl_cost.points.loc[1] = [[0, 70, 12], [70, 100, 20]]\n```\n\n----------------------------------------\n\nTITLE: Initializing a pandapower network\nDESCRIPTION: This snippet initializes a basic pandapower network using the example_simple function and removes the generator component as it is not yet supported by power-grid-model. This prepares the network for subsequent power flow calculations using power-grid-model.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/power-grid-model_powerflow.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nfrom pandapower.networks import example_simple\n\nnet = example_simple()\n# Remove Generator since its not supported yet\nnet[\"gen\"] = net[\"gen\"].iloc[:0]\n```\n\n----------------------------------------\n\nTITLE: Creating Voltage Controlled Generator in PandaPower Network\nDESCRIPTION: Adds a voltage controlled generator with specified active power and voltage set point.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npp.create_gen(net, pp.get_element_index(net, \"bus\", 'Bus HV4'), vm_pu=1.03, p_mw=100, name='Gas turbine')\n\n# show generator table\nnet.gen\n```\n\n----------------------------------------\n\nTITLE: Checking Available Standard Types in Pandapower\nDESCRIPTION: Shows how to create an empty network and check available standard types for lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nnet = pp.create_empty_network()\npp.available_std_types(net, element=\"line\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Timeseries Data Source and Controllers in Pandapower\nDESCRIPTION: Sets up a timeseries simulation by creating data sources for static generators and loads, and initializing ConstControl controllers to update P values. Uses random normal distributions for demonstration, but can be adapted to use CSV data sources.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/timeseries_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\n\nfrom pandapower.control import ConstControl\nfrom pandapower.networks import mv_oberrhein\nfrom pandapower.timeseries import run_timeseries, OutputWriter\nfrom pandapower.timeseries.data_sources.frame_data import DFData\n\n# load a pandapower network\nnet = mv_oberrhein(scenario='generation')\n# number of time steps\nn_ts = 95\n# load your timeseries from a file (here csv file)\n# df = pd.read_csv(\"sgen_timeseries.csv\")\n# or create a DataFrame with some random time series as an example\ndf = pd.DataFrame(np.random.normal(1., 0.1, size=(n_ts, len(net.sgen.index))),\n                  index=list(range(n_ts)), columns=net.sgen.index) * net.sgen.p_mw.values\n# create the data source from it\nds = DFData(df)\n\n# initialising ConstControl controller to update values of the regenerative generators (\"sgen\" elements)\n# the element_index specifies which elements to update (here all sgens in the net since net.sgen.index is passed)\n# the controlled variable is \"p_mw\"\n# the profile_name are the columns in the csv file (here this is also equal to the sgen indices 0-N )\nconst_sgen = ConstControl(net, element='sgen', element_index=net.sgen.index,\n                          variable='p_mw', data_source=ds, profile_name=net.sgen.index)\n\n# do the same for loads\n# df = pd.read_csv(\"load_timeseries.csv\")\n# create a DataFrame with some random time series as an example\ndf = pd.DataFrame(np.random.normal(1., 0.1, size=(n_ts, len(net.load.index))),\n                  index=list(range(n_ts)), columns=net.load.index) * net.load.p_mw.values\nds = DFData(df)\nconst_load = ConstControl(net, element='load', element_index=net.load.index,\n                          variable='p_mw', data_source=ds, profile_name=net.load.index)\n\n# starting the timeseries simulation for one day -> 96 15 min values.\nrun_timeseries(net)\n```\n\n----------------------------------------\n\nTITLE: Configuring Optimization Parameters for Reactive Power Control\nDESCRIPTION: This code configures the optimization parameters for controlling reactive power in the CIGRE network. It sets controllable flags for loads and sgens, defines voltage limits for buses, sets limits for external grids, configures DER constraints, and sets line loading limits.  It adds a custom column to the transformer for setting the reactive power target.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nnet_opt = deepcopy(net) # copy of the grid for further comparison \nnet_opt.load['controllable'] = False\nnet_opt.sgen['controllable'] = True\n\n# lower and upper bounds for buses\nnet_opt.bus[\"max_vm_pu\"] = 1.1\nnet_opt.bus[\"min_vm_pu\"] = 0.9\n\n# lower and upper bounds for external grid\nnet_opt.ext_grid[\"max_q_mvar\"] = 10000.0\nnet_opt.ext_grid[\"min_q_mvar\"] = -10000.0\nnet_opt.ext_grid[\"max_p_mw\"] = 10000.0\nnet_opt.ext_grid[\"min_p_mw\"] = -10000.0\n\n# lower and upper bounds for DERs\nnet_opt.sgen[\"max_p_mw\"] = net_opt.sgen.p_mw.values\nnet_opt.sgen[\"min_p_mw\"] = net_opt.sgen.p_mw.values\nnet_opt.sgen[\"max_q_mvar\"] = net_opt.sgen.p_mw.values * 0.328\nnet_opt.sgen[\"min_q_mvar\"] = -net_opt.sgen.p_mw.values * 0.328\ndisplay(net_opt.sgen)\n\n# lower and upper bounds for lines\nnet_opt.trafo[\"max_loading_percent\"] = 100.0\nnet_opt.line[\"max_loading_percent\"] = 100.0\n\n######################################################\n####################### Attention ####################\n######################################################\n\n# We need to let PandaModels know which interface is of interest and what is user-defined setpoint. \n# So, we need to add extra column called **\"pm_param/setpoint_q\"** in net.trafo and set target value. \n\nnet_opt.trafo[\"pm_param/setpoint_q\"] = None # add extra column\nnet_opt.trafo[\"pm_param/setpoint_q\"][0] = -5 #  reactive power setpoint for trafo 0 is -5 MVAR\n```\n\n----------------------------------------\n\nTITLE: Visualizing PV Hosting Capacity Results with matplotlib and seaborn\nDESCRIPTION: This code snippet sets up matplotlib and seaborn for visualization, then creates two plots: a boxplot of installed capacity and a pie chart of violation types. It customizes various plot settings for better readability.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n%matplotlib inline\nplt.rc('xtick', labelsize=18)    # fontsize of the tick labels\nplt.rc('ytick', labelsize=18)    # fontsize of the tick labels\nplt.rc('legend', fontsize=18)    # fontsize of the tick labels\nplt.rc('axes', labelsize=20)    # fontsize of the tick labels\nplt.rcParams['font.size'] = 20\n\nimport seaborn as sns\nsns.set_style(\"whitegrid\", {'axes.grid' : False})\nfig, axes = plt.subplots(nrows=1, ncols=2, figsize=(10,5))\nax = axes[0]\nsns.boxplot(results.installed, width=.1, ax=ax, orient=\"v\")\nax.set_ylabel(\"Installed Capacity [MW]\")\n\nax = axes[1]\nax.axis(\"equal\")\nresults.violation.value_counts().plot(kind=\"pie\", ax=ax,  autopct=lambda x:\"%.0f %%\"%x)\nax.set_ylabel(\"\")\nax.set_xlabel(\"\")\nsns.despine()\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Line Type\nDESCRIPTION: Defines a custom line type with sequence impedance parameters for use in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.create_std_type(net, {\"r0_ohm_per_km\": 0.0848, \"x0_ohm_per_km\": 0.4649556, \"c0_nf_per_km\":\\\n    230.6,\"max_i_ka\": 0.963, \"r_ohm_per_km\": 0.0212, \"x_ohm_per_km\": 0.1162389,\n             \"c_nf_per_km\":  230}, name=\"example_type\")\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage Lines from CSV Data in PandaPower\nDESCRIPTION: Loads high voltage line data from a CSV file and creates lines in the network based on the data. Uses pandas to read the CSV and iterates through rows to create each line.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nhv_lines = pd.read_csv('example_advanced/hv_lines.csv', sep=';', header=0, decimal=',')\nhv_lines\n```\n\nLANGUAGE: python\nCODE:\n```\n# create lines\nfor _, hv_line in hv_lines.iterrows():\n        from_bus = pp.get_element_index(net, \"bus\", hv_line.from_bus)\n        to_bus = pp.get_element_index(net, \"bus\", hv_line.to_bus)\n        pp.create_line(net, from_bus, to_bus, length_km=hv_line.length,std_type=hv_line.std_type, name=hv_line.line_name, parallel=hv_line.parallel)\n\n# show line table\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Creating a PyQt Slider Widget with Pandapower\nDESCRIPTION: This snippet implements a PyQt widget, `SliderWidget`, which allows users to interactively scale loads and generation on an electrical grid network using sliders. The widget visualizes the grid with plotted buses and lines and updates them in real-time based on slider input. Dependencies include PyQt5, matplotlib, and pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_pyqt.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport sys\\nfrom PyQt5.QtCore import *\\nfrom PyQt5.QtGui import *\\nfrom PyQt5.QtWidgets import *\\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\\n\\nimport pandapower.plotting as plot\\nimport pandapower as pp\\nimport matplotlib.pyplot as plt\\n\\nclass SliderWidget(QWidget):\\n    def __init__(self, net):\\n        super().__init__()\\n        self.net = net\\n        self.layout = QVBoxLayout()\\n        self.initialize_netplot()\\n        self.initialize_slider()\\n        self.setWindowTitle(\"PyQt with pandapower Demo\")\\n        self.setLayout(self.layout)\\n\\n    def initialize_netplot(self):\\n        self.net.line_geodata.drop(set(net.line_geodata.index) - set(net.line.index), inplace=True)\\n        cmap, norm = plot.cmap_continuous([(0.97, \"blue\"), (1.0, \"green\"), (1.03, \"red\")])\\n        self.bc = plot.create_bus_collection(net, size=90, zorder=2, cmap=cmap, norm=norm, picker=True,\\n                                             infofunc=lambda x: \"This is bus %s\"%net.bus.name.at[x])\\n        cmap, norm = plot.cmap_continuous([(20, \"green\"), (50, \"yellow\"), (60, \"red\")])\\n        self.lc = plot.create_line_collection(net, zorder=1, cmap=cmap, norm=norm, linewidths=2,\\n                                              infofunc=lambda x: \"This is line %s\"%net.line.name.at[x])\\n        self.fig, self.ax = plt.subplots()\\n        plot.draw_collections([self.bc, self.lc], ax=self.ax)\\n        plt.close()\\n        self.canvas = FigureCanvas(self.fig)\\n        self.canvas.mpl_connect('pick_event', self.pick_event)\\n        self.canvas.draw()\\n        self.canvas.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)\\n        self.layout.addWidget(self.canvas)\\n        \\n    def initialize_slider(self):\\n        self.sliders = {}\\n        for element in [\"load\", \"sgen\"]:\\n            frame = QWidget()\\n            layout = QHBoxLayout()\\n            layout.addWidget(QLabel(\"scaling %s\"%element))\\n            self.sliders[element] = QSlider(Qt.Horizontal, value=50)\\n            self.sliders[element].valueChanged.connect(self.slider_changed)\\n            layout.addWidget(self.sliders[element])\\n            frame.setLayout(layout)\\n            self.layout.addWidget(frame)\\n        \\n    def slider_changed(self):\\n        for element, slider in self.sliders.items():\\n            self.net[element].scaling = slider.value() / 100.\\n        pp.runpp(self.net)\\n        self.ax.collections[0].set_array(self.net.res_bus.vm_pu.values)\\n        self.ax.collections[1].set_array(self.net.res_line.loading_percent.values)\\n        self.canvas.draw()\\n\\n    def pick_event(self, event):\\n        idx = event.ind[0]\\n        collection = event.artist\\n        self.info = QLabel()\\n        self.info.setText(collection.info[idx])\\n        self.info.show()\n```\n\n----------------------------------------\n\nTITLE: Creating Dickert LV Network in Python using pandapower\nDESCRIPTION: This function creates a Dickert low voltage network model in pandapower. It allows for the generation of various network configurations based on parameters such as the number of delivery points and the distance between them.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/dickert_lv_networks.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npandapower.networks.create_dickert_lv_network\n```\n\n----------------------------------------\n\nTITLE: Time Series Optimization in a Loop using PandaPower\nDESCRIPTION: This snippet performs time series optimization by iterating through each time step. It updates the operating points of loads and sgens based on the loaded time series data, and runs a voltage stability analysis using `pp.runpm_vstab`. The mean voltage value for each time step is then saved for further analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n########################################################################\n####################### Optimization in a loop #########################\n########################################################################\n\ny_loop = []\nfor t in range(96):\n    \n    # Update operating points for each time step\n    net_opt.load.p_mw = load_ts.loc[t]\n    net_opt.sgen.p_mw = sgen_ts.loc[t]\n    \n    # If required, we also need to update the constraints, e.g., Qmax- and Qmin-value, for each time step. \n    net_opt.sgen.max_p_mw = sgen_ts.loc[t]   # for load: max_p_mw == min_p_mw, because they are not controllable.\n    net_opt.sgen.min_p_mw = sgen_ts.loc[t]\n    net_opt.sgen.max_q_mvar = net_opt.sgen.max_q_mvar\n    net_opt.sgen.min_q_mvar = net_opt.sgen.min_q_mvar\n    \n    # run optimization for time step t\n    try:\n        pp.runpm_vstab(net_opt)\n    except:\n        print(\"[WinError 3] The system cannot find the path specified to the python39.dll\")\n    \n    # save the mean voltage value for each time step\n    y_loop.append(net_opt.res_bus.vm_pu[net_opt.sgen.bus].values.mean())\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Network Structure with PandaPower\nDESCRIPTION: Creates a 4-bus power network with transformer, lines, loads and generators. Sets up voltage levels, bus parameters, and creates network components with specific constraints.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_curtail.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport pandapower as pp\nnet = pp.create_empty_network()\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=220., min_vm_pu=1.0, max_vm_pu=1.02)\nbus2 = pp.create_bus(net, vn_kv=110., min_vm_pu=1.0, max_vm_pu=1.02)\nbus3 = pp.create_bus(net, vn_kv=110., min_vm_pu=1.0, max_vm_pu=1.02)\nbus4 = pp.create_bus(net, vn_kv=110., min_vm_pu=1.0, max_vm_pu=1.02)\n\n#create 220/110 kV transformer\npp.create_transformer(net, bus1, bus2, std_type=\"100 MVA 220/110 kV\", max_loading_percent=100)\n\n#create 110 kV lines\npp.create_line(net, bus2, bus3, length_km=70., std_type='149-AL1/24-ST1A 110.0', max_loading_percent=100)\npp.create_line(net, bus3, bus4, length_km=50., std_type='149-AL1/24-ST1A 110.0', max_loading_percent=100)\npp.create_line(net, bus4, bus2, length_km=40., std_type='149-AL1/24-ST1A 110.0', max_loading_percent=100)\n\n#create loads\npp.create_load(net, bus2, p_mw=60, controllable=False)\npp.create_load(net, bus3, p_mw=70, controllable=False)\npp.create_load(net, bus4, p_mw=10, controllable=False)\n\n#create generators\neg = pp.create_ext_grid(net, bus1)\ng0 = pp.create_gen(net, bus3, p_mw=80, min_p_mw=0, max_p_mw=80,  vm_pu=1.01, controllable=True)\ng1 = pp.create_gen(net, bus4, p_mw=100, min_p_mw=0, max_p_mw=100, vm_pu=1.01, controllable=True)\n```\n\n----------------------------------------\n\nTITLE: Defining Possible New Lines for TNEP in Python\nDESCRIPTION: This function defines new line measures to choose from by duplicating existing lines and setting them out of service. It creates an 'ne_line' DataFrame specifying possible lines to be built with associated construction costs.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_tnep.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport numpy as np\n\ndef define_possible_new_lines(net):\n    max_idx = max(net[\"line\"].index)\n    net[\"line\"] = pd.concat([net[\"line\"]] * 2, ignore_index=True) # duplicate\n    net[\"line\"].loc[max_idx + 1:, \"in_service\"] = False\n    new_lines = net[\"line\"].loc[max_idx + 1:].index\n\n    init_ne_line(net, new_lines, construction_costs=np.ones(len(new_lines)))\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Creating Network and Running Load Flow Calculation\nDESCRIPTION: This snippet creates the faulty example network and attempts to run a load flow calculation, which fails due to errors in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# creates the example network\nfaulty_net = faulty_example_network()\npp.runpp(faulty_net)\n```\n\n----------------------------------------\n\nTITLE: Setting Individual Generator Costs\nDESCRIPTION: This snippet assigns different costs to each generator and the external grid, demonstrating how to set up individual cost functions for power sources.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.poly_cost.cp1_eur_per_mw.at[costeg] = 10\nnet.poly_cost.cp1_eur_per_mw.at[costgen1] = 15\nnet.poly_cost.cp1_eur_per_mw.at[costgen2] = 12\n```\n\n----------------------------------------\n\nTITLE: Creating Network Infrastructure in pandapower\nDESCRIPTION: Creates a basic power network with two buses connected by a line, including a static generator, external grid, and load components.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/reference_system_convention.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet=pp.create_empty_network()\nbus0 = pp.create_bus(net, name=\"Bus 0\", vn_kv=110, type=\"b\")\nbus1 = pp.create_bus(net, name=\"Bus 1\", vn_kv=110, type=\"b\")\nline0 = pp.create_line(net, bus0, bus1, length_km=50, std_type=\"70-AL1/11-ST1A 110.0\",  name=\"Line 1\")\npp.create_sgen(net, bus1, p_mw=0, q_mvar=0, name=\"static generator\")\npp.create_ext_grid(net, bus0, vm_pu=1.02, va_degree=50)\npp.create_load(net, bus1, p_mw=0, q_mvar=0, name=\"load i\")\nnet\n```\n\n----------------------------------------\n\nTITLE: Implementing Storage Controller Class in Python\nDESCRIPTION: Defines a Storage controller class that inherits from pandapower's Controller class. Implements methods for tracking state of charge, controlling power values, and handling time series data for battery simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/building_a_controller.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nfrom pandapower import control\nimport pandas as pd\nfrom pandapower import timeseries as ts\n\n# importing a grid from the library\nfrom pandapower.networks import mv_oberrhein\n\n\nclass Storage(control.basic_controller.Controller):\n    \"\"\"\n        Example class of a Storage-Controller. Models an abstract energy storage.\n    \"\"\"\n    def __init__(self, net, element_index, data_source=None, p_profile=None, in_service=True,\n                 recycle=False, order=0, level=0, **kwargs):\n        super().__init__(net, in_service=in_service, recycle=recycle, order=order, level=level,\n                    initial_powerflow = True, **kwargs)\n        \n        # read generator attributes from net\n        self.element_index = element_index  # index of the controlled storage\n        self.bus = net.storage.at[element_index, \"bus\"]\n        self.p_mw = net.storage.at[element_index, \"p_mw\"]\n        self.q_mvar = net.storage.at[element_index, \"q_mvar\"]\n        self.sn_mva = net.storage.at[element_index, \"sn_mva\"]\n        self.name = net.storage.at[element_index, \"name\"]\n        self.gen_type = net.storage.at[element_index, \"type\"]\n        self.in_service = net.storage.at[element_index, \"in_service\"]\n        self.applied = False\n\n        # specific attributes\n        self.max_e_mwh = net.storage.at[element_index, \"max_e_mwh\"]\n        self.soc_percent = net.storage.at[element_index, \"soc_percent\"] = 0\n        \n        # profile attributes\n        self.data_source = data_source\n        self.p_profile = p_profile\n        self.last_time_step = None\n        \n    def get_stored_ernergy(self):\n        # calculating the stored energy\n        return self.max_e_mwh * self.soc_percent / 100        \n    \n    def is_converged(self, net):\n        # check if controller already was applied\n        return self.applied\n    \n    def write_to_net(self, net):\n        # write p, q and soc_percent to bus within the net\n        net.storage.at[self.element_index, \"p_mw\"] = self.p_mw\n        net.storage.at[self.element_index, \"q_mvar\"] = self.q_mvar\n        net.storage.at[self.element_index, \"soc_percent\"]= self.soc_percent\n        \n    def control_step(self, net):\n        # Call write_to_net and set the applied variable True\n        self.write_to_net(net)\n        self.applied = True\n        \n    def time_step(self, net, time):\n        # keep track of the soc (assuming time is given in 15min values)\n        if self.last_time_step is not None:\n            self.soc_percent += (self.p_mw * (time-self.last_time_step) * 15 / 60) / self.max_e_mwh * 100\n        self.last_time_step = time\n\n        # read new values from a profile\n        if self.data_source:\n            if self.p_profile is not None:\n                self.p_mw = self.data_source.get_time_step_value(time_step=time,\n                                                                profile_name=self.p_profile)\n                \n        self.applied = False # reset applied variable\n```\n\n----------------------------------------\n\nTITLE: Configuring Output Writer for pandapower Time Series Simulation\nDESCRIPTION: Sets up an OutputWriter to save specific simulation results to Excel files. Defines which variables from different network components (load, bus, line) should be logged and saved during the simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef create_output_writer(net, time_steps, output_dir):\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".xlsx\", log_variables=list())\n    # these variables are saved to the harddisk after / during the time series loop\n    ow.log_variable('res_load', 'p_mw')\n    ow.log_variable('res_bus', 'vm_pu')\n    ow.log_variable('res_line', 'loading_percent')\n    ow.log_variable('res_line', 'i_ka')\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature (Ngoko et al.)\nDESCRIPTION: This snippet calculates the overhead line temperature based on the approach of Ngoko et al. It first calculates the parameters a0, a1, a2, and tau, and then uses these parameters along with the line current to calculate the line temperature.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nt_air_pu = 35\nalpha_pu = 4.03e-3\nr_ref = net.line.r_ohm_per_km.values / 1e3\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air_pu, 80, 20, r_ref, 30.6e-3,\n                                    1490, 0.6, 45, 900, alpha_pu, 0.5, 0.5)\ncalc_T_ngoko(np.square(net.res_line.i_ka.values * 1e3), a0, a1, a2, None, None, None)\n```\n\n----------------------------------------\n\nTITLE: Plotting Pandapower Network with Closed Lines Only in Python\nDESCRIPTION: This code demonstrates how to plot a Pandapower network showing only the lines without open switches, creating a clearer arrangement of the network structure.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclosed_lines = set(net.line.index) - set(net.switch[(net.switch.et==\"l\") & (net.switch.closed==False)].element.values)\nlcd = plot.create_line_collection(net, closed_lines, color=\"grey\", linewidths=0.5, use_bus_geodata=True)\nplot.draw_collections([lcd, bc, tlc, tpc, sc], figsize=(8,6))\n```\n\n----------------------------------------\n\nTITLE: Running Standard Power Flow and Recalculating Temperature\nDESCRIPTION: This code runs a standard power flow calculation (without TDPF) and then recalculates the line temperature using the Ngoko et al. method. This demonstrates the difference in results when the temperature dependence of line parameters is not considered in the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\ncalc_T_ngoko(np.square(net.res_line.i_ka.values * 1e3), a0, a1, a2, None, None, None)\n```\n\n----------------------------------------\n\nTITLE: Comparing Performance of Controllers vs Direct Calculation in Python\nDESCRIPTION: This snippet creates a reference network configuration and evaluates the computational time as well as the results obtained by controllers versus direct calculation methods for transformer behaviors.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnet3 = create_net()\nnet3.trafo.loc[1,\"id_characteristic_table\"] = np.nan\nnet3.trafo.loc[1,\"tap_dependency_table\"] = False\npp.control.SplineCharacteristic(net3, [-2, -1, 0, 1, 2], [5, 5.2, 6, 6.8, 7])\npp.control.SplineCharacteristic(net3, [-2, -1, 0, 1, 2], [1.3, 1.4, 1.44, 1.5, 1.6])\npp.control.TapDependentImpedance(net3, [0], 0, output_variable=\"vk_percent\")\npp.control.TapDependentImpedance(net3, [0], 1, output_variable=\"vkr_percent\")\n```\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net3, run_control=True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit Current Using PandaPower in Python\nDESCRIPTION: Example showing how to perform a minimum short-circuit calculation using the mv_oberrhein test network. Sets external grid parameters including minimum short-circuit power and R/X ratio, and configures line end temperature before running the calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/run.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.shortcircuit import calc_sc\nfrom pandapower.networks import mv_oberrhein\n\nnet = mv_oberrhein()\nnet.ext_grid[\"s_sc_min_mva\"] = 100\nnet.ext_grid[\"rx_min\"] = 0.1\n\nnet.line[\"endtemp_degree\"] = 20\ncalc_sc(net, case=\"min\")\nprint(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: Running OTS Optimization with pandapower in Python\nDESCRIPTION: This code snippet illustrates how to load a pandapower grid, perform Optimal Transmission Switching (OTS) optimization using PowerModels.jl, and output the updated line status after optimization. It captures the line status before and after running the optimization to demonstrate the changes made.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_ost.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.networks as nw\nimport pandapower as pp\n\n# here we use the simple case5 grid\nnet = nw.case5()\n\nline_status = net[\"line\"].loc[:,\"in_service\"]\nprint(\"Line status prior to optimization is:\")\nprint(line_status.astype(bool))\n\n# runs the powermodels.jl switch optimization\ntry:\n    pp.runpm_ots(net, delta=1e-6)\nexcept Exception as err:\n    print(err)\n# note that the result is taken from the res_line instead of the line table. The input DataFrame is not changed \nline_status = net[\"line\"].loc[:,\"in_service\"]\nprint(\"Line status after the optimization is:\")\nprint(line_status.astype(bool))\n\n```\n\n----------------------------------------\n\nTITLE: Chained State Estimation with Warm Start\nDESCRIPTION: Implementation of chained estimation process using WLS and optimization algorithms. Shows initialization of estimation parameters, running multiple estimators in sequence, and updating the network with results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Initialize eppci for the algorithm which contains pypower-grid,\n# measurements and estimated grid state (initial value)\nnet, ppc, eppci = pp2eppci(net)\n\n# Initialize algorithm\nestimation_wls = WLSAlgorithm(1e-3, 5)\nestimation_opt = OptAlgorithm(1e-6, 1000)\n\n# Start Estimation with specified estimator\neppci = estimation_wls.estimate(eppci)\n# for some estimators extra parameters must be specified\neppci = estimation_opt.estimate(eppci, estimator=\"ql\", a=3) \n\n# Update the pandapower network with estimated results\nnet = eppci2pp(net, ppc, eppci)\n```\n\n----------------------------------------\n\nTITLE: Creating a data source from pandas DataFrame\nDESCRIPTION: This function generates a pandas DataFrame containing random values for load and generator active power (P) profiles, as well as a random setpoint voltage between 0.95 and 1.05 pu. It then converts the DataFrame into a DFData object, which serves as the data source for the time series simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_source(n_timesteps=24):\n    profiles = pd.DataFrame()\n    profiles['load1_p'] = np.random.random(n_timesteps) * 20.\n    profiles['sgen1_p'] = np.random.random(n_timesteps) * 20.\n    profiles['c'] = 0.95 + np.random.random(n_timesteps) * (1.05-0.95)\n\n    ds = DFData(profiles)\n    \n    # a + r*k\n    # k = b-a\n    # range between a and b within k\n\n    return profiles, ds\n```\n\n----------------------------------------\n\nTITLE: Adding Voltage Controlled Generator\nDESCRIPTION: Creates a voltage-controlled generator with active power generation and voltage setpoint.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.create_gen(net, bus6, p_mw=6, max_q_mvar=3, min_q_mvar=-3, vm_pu=1.03, name=\"generator\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Estimated Line Power Flows\nDESCRIPTION: This snippet shows how to access the estimated power flows from lines within the pandapower network after state estimation, enabling comparison with the initial measurements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nnet.res_line_est.p_from_mw\n\nnet.res_line_est.q_from_mvar\n```\n\n----------------------------------------\n\nTITLE: Removing Bad Data from Estimation\nDESCRIPTION: This snippet shows how to remove bad data from the state estimation by utilizing the remove_bad_data function, which also reports the success of the estimation process after executing.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nfrom pandapower.estimation import remove_bad_data\nimport numpy as np\n\nsuccess_rn_max = remove_bad_data(net, init='flat', rn_max_threshold=3.0)\nprint(success_rn_max)\n```\n\n----------------------------------------\n\nTITLE: Running AC Power Flow with PowerModels\nDESCRIPTION: Executes AC power flow calculation using PowerModels integration with error handling.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_pf(net, pm_model=\"ACPPowerModel\", calculate_voltage_angles=True)\nexcept Exception as err:\n    print(err)\n```\n\n----------------------------------------\n\nTITLE: Accessing Internal Power Flow Case File in pandapower\nDESCRIPTION: Shows how to access the internal power flow case file (ppc) after running a power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet._ppc\n```\n\n----------------------------------------\n\nTITLE: Initializing ContinuousTapControl Controller in Pandapower\nDESCRIPTION: This snippet initializes a ContinuousTapControl instance in Pandapower for adjusting transformer tap positions based on a specified voltage setpoint. The controller dynamically alters the tap to maintain the set voltage.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ntrafo_controller = control.ContinuousTapControl(net, 0, 0.98, tol=1e-6)\n```\n\n----------------------------------------\n\nTITLE: Creating Network Model with Wind Parks in pandapower\nDESCRIPTION: Creates a test network with buses, external grid, transmission lines, and static generators representing wind parks. The network parameters are based on an example from a research paper demonstrating IEC 60909 calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit_renewables.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.shortcircuit as sc\nimport numpy as np\n\nnet = pp.create_empty_network()\nfor i in range(4):\n    pp.create_bus(net, vn_kv=110., index=i+1)\n    \npp.create_ext_grid(net, 1, s_sc_max_mva=20*110*np.sqrt(3), rx_max=0.1)\npp.create_std_type(net, {\"r_ohm_per_km\": 0.120, \"x_ohm_per_km\": 0.393, \"c_nf_per_km\": 0.19,\n                         \"max_i_ka\": 0.6}, \"example_type\")\n\nfor fb, tb, length in [(1, 2, 100), (1, 3, 50), (2, 3, 50), (3, 4, 25)]:\n    pp.create_line(net, from_bus=fb, to_bus=tb, length_km=length, std_type=\"example_type\")\n\nfor b, p in [(2, 100), (3, 50), (4, 50)]:\n    pp.create_sgen(net, b, p_mw=p, sn_mva=p, k=1.2)\n```\n\n----------------------------------------\n\nTITLE: Creating a Sample Network for OC Relay Demonstration in Python\nDESCRIPTION: This function creates a sample network with 7 buses, 5 switches, and 2 loads for demonstrating OC relay functionality in Pandapower. It sets up the network topology, including buses, external grids, lines, switches, and loads.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef oc_relay_net():\n    import pandapower as pp\n    \n    # create an empty network\n    net = pp.create_empty_network()  \n    \n    #create buses\n    pp.create_buses(net, nr_buses=7, vn_kv=20, index=[0,1,2,3,4,5,6], name=None, type=\"n\", \n                    geodata=[(0,0), (0, -1), (-2, -2), (-2, -4), (2, -2), (2, -3), (2, -4)])\n\n    # create external grids\n    pp.create_ext_grid(net, 0, vm_pu=1.0, va_degree=0, s_sc_max_mva=100, s_sc_min_mva=50, rx_max=0.1, rx_min=0.1)\n    \n    pp.create_lines(net, from_buses=[0,1,2,1,4,5], to_buses=[1,2,3,4,5,6], length_km=[2,5,4,4,0.5,0.5],std_type=\"NAYY 4x50 SE\",\n                 name=None, index=[0,1,2,3,4,5], df=1., parallel=1)\n\n    net.line[\"endtemp_degree\"] = 250\n    \n    # Define switches\n    pp.create_switches(net, buses =  [0,1,1,2,4,5], elements =\n                       [0,1,3,2,4,5], et = 'l', type =\"CB_DTOC\")\n    #define load\n    pp.create_loads(net, buses=[3,6], p_mw=[5,2], q_mvar=[1,1], const_z_percent=0, const_i_percent=0, sn_mva=None,\n                     name=None, scaling=1., index=[0,1])\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Creating Static Generator (Wind Park) in PandaPower Network\nDESCRIPTION: Adds a static generator representing a wind park with specified active and reactive power outputs.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.create_sgen(net, pp.get_element_index(net, \"bus\", 'Bus SB 5'), p_mw=20, q_mvar=4, sn_mva=45, \n               type='WP', name='Wind Park')\n\n# show static generator table\nnet.sgen\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Voltage at Loaded Buses\nDESCRIPTION: This snippet demonstrates how to compute the maximum voltage at buses connected with loads. It merges the bus and load dataframes, allowing for efficient voltage retrieval using the max function on the resulting dataframe. The output is a single value representing maximum voltage. This requires the Pandas library.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmax_load_voltage = pd.merge(net.res_bus, net.load, left_index=True, right_on=\"bus\").vm_pu.max()\n\n#Output\nmax_load_voltage\n```\n\n----------------------------------------\n\nTITLE: Creating Test Network with Q Capability Curve in Python\nDESCRIPTION: This function creates a test network with optional Q capability curve characteristics. It sets up buses, lines, loads, transformers, and generators with specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_net_for_q_capability_curve(characteristics_data=False):\n    net = pp.create_empty_network()\n    bus1 = pp.create_bus(net, name=\"bus1\", vn_kv=20., type=\"b\", min_vm_pu=0., max_vm_pu=1.05)\n    bus2 = pp.create_bus(net, name=\"bus2\", vn_kv=110., type=\"b\", min_vm_pu=0., max_vm_pu=1.05)\n    bus3 = pp.create_bus(net, name=\"bus3\", vn_kv=110., type=\"b\", min_vm_pu=0., max_vm_pu=1.05)\n\n    pp.create_ext_grid(net, bus3, name=\"External Grid\", vm_pu=1.0, va_degree=0.0,max_p_mw=100000, min_p_mw=0, min_q_mvar=-300, max_q_mvar=300,\n                       s_sc_max_mva=10000, s_sc_min_mva=8000, rx_max=0.1, rx_min=0.1)\n    # create lines\n    pp.create_line_from_parameters(net, bus2, bus3, length_km=10,df=1,max_loading_percent=100,vn_kv=110,max_i_ka=0.74,type=\"ol\",\n                   r_ohm_per_km=0.0949, x_ohm_per_km =0.38, c_nf_per_km=0.0092, name=\"Line\")\n    # create load\n    pp.create_load(net, bus3, p_mw=200, q_mvar=180, name=\"Load\", vm_pu=1.0 )\n\n    # create transformer\n    pp.create_transformer_from_parameters(net, bus2, bus1, name=\"110kV/20kV transformer\", parallel=1,max_loading_percent=100,sn_mva=210,\n    vn_hv_kv=110, vn_lv_kv=20, vk_percent=12.5, vkr_percent=0.01904762, vk0_percent=10, vkr0_percent=0,\n                          shift_degree=330, vector_group=\"YNd11\", i0_percent= 0.26, pfe_kw=0,si0_hv_partial=0.5)\n\n    pp.create_gen(net, bus1, p_mw=100, sn_mva=255.0, scaling=1.0, type=\"Hydro\",\n                 cos_phi=0.8, pg_percent=0.0, vn_kv=19.0, vm_pu=1.0)\n    if characteristics_data:\n        net[\"q_capability_curve_table\"] = pd.DataFrame(\n        {'id_q_capability_curve': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        'p_mw':      [-331.01001, -298.0,    -198.0,     -66.2000,   -0.1,        0,           0.1,        66.200, 100,     198.00,     298.00,     331.01001],\n        'q_min_mvar':[-0.0100,    -134.0099, -265.01001, -323.01001, -323.01001,  -323.01001, -323.01001, -323.01001, 0, -265.01001, -134.00999, -0.01000 ],\n        'q_max_mvar':[0.01000,    134.00999,  228.00999,  257.01001,  261.01001,  261.01001,   261.01001,  257.01001, 30,  40,  134.0099,   0.01]})\n\n        net.gen.loc[0,\"id_q_capability_curve_characteristic\"] = 0\n        net.gen['curve_style'] = \"straightLineYValues\"\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Importing Packages and Loading Network in Python\nDESCRIPTION: This snippet imports the necessary packages and loads the MV oberrhein network, which contains two 110/20 kV transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Importing necessary packages\nimport pandapower as pp\nfrom pandapower.networks import mv_oberrhein\n\nnet = mv_oberrhein()\nnet.trafo\n```\n\n----------------------------------------\n\nTITLE: Converting CIM CGMES Files to pandapower Network\nDESCRIPTION: This code snippet defines the path to CGMES zip files, validates their existence, and converts them to a pandapower network object. It uses the 'from_cim' function from the pandapower converter module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/cim2pp.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# folder_path points to the directory where the CIM .zip-Files are stored:\nfolder_path = os.path.join(os.getcwd(), 'example_cim')\n\n# cgmes_files is a list containing paths to both files needed for the CIM converter:\ncgmes_files = [os.path.join(folder_path, 'CGMES_v2.4.15_SmallGridTestConfiguration_Boundary_v3.0.0.zip'),\n               os.path.join(folder_path, 'CGMES_v2.4.15_SmallGridTestConfiguration_BaseCase_Complete_v3.0.0.zip')]\n\nfor f in cgmes_files:\n    if not os.path.exists(f):\n        raise UserWarning(f\"Wrong path specified for the CGMES file {f}\")\n\nnet = cim2pp.from_cim(file_list=cgmes_files, use_GL_or_DL_profile='DL')\n\nprint('Conversion successful')\n```\n\n----------------------------------------\n\nTITLE: Creating Example Grid with Load and Static Generator in Pandapower\nDESCRIPTION: This snippet demonstrates the creation of a basic power network using Pandapower, comprising of buses, lines, a transformer, a load, and a static generator. It forms the foundation for implementing transformer tap control strategies.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nnet = pp.create_empty_network() \nfor i in range(4):\n    if i < 2:\n        vn=110\n    else:\n        vn=20\n    pp.create_bus(net, name='Bus %s' % i, vn_kv=vn, type=\"n\")\npp.create_line(net, 0, 1, length_km=10, std_type=\"149-AL1/24-ST1A 110.0\",name=\"Line 1\")\npp.create_line(net, 2, 3, length_km=10, std_type=\"184-AL1/30-ST1A 20.0\",name=\"Line 2\")\npp.create_ext_grid(net, 0, vm_pu=1.02, va_degree=50)   \ntrafo = pp.create_transformer(net, 1, 2, name=\"110kV/20kV transformer\", std_type=\"25 MVA 110/20 kV\")\npp.create_load(net, 3, p_mw=35, q_mvar=4, scaling=1, name=\"load\")\npp.create_sgen(net, 3, p_mw=10, q_mvar=3,  name=\"generator\") \nnet.bus\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Simulation in Pandapower\nDESCRIPTION: This code executes a power flow simulation in Pandapower with control mechanisms enabled to check how the load and generation affect power flow and voltage setpoints, providing insight into system behavior under different conditions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\npp.runpp(net, run_control=True)\nprint(f\"The load has active power of {net.load.at[0, 'p_mw']} MW, sgen has active power of {net.sgen.at[0, 'p_mw']} MW\")\nprint(f\"Power flowing through the transformer is {net.res_trafo.at[0, 'p_hv_mw']:.2f} MW\")\nprint(f\"Voltage setpoint from Characteristic is {c(x=net.res_trafo.at[0, 'p_hv_mw']):.3f} p. u.\")\nprint(f\"Voltage at the controlled bus is {net.res_bus.at[2, 'vm_pu']:.3f} p. u.\")\nprint(f\"Transformer tap position is {net.trafo.at[0, 'tap_pos']:.2f}\")\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Verifying Power Flow After Fuse Operation in pandapower\nDESCRIPTION: Runs a power flow calculation after fuse operation to verify the impact on load supply. The results show the power status of loads in the network, confirming that they are no longer powered after the protective action.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# run power flow one more time\npp.runpp(net)\n\n# loads are no longer powered\nnet.res_load\n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series Simulation Results from pandapower\nDESCRIPTION: Reads the simulation results from Excel files and creates plots for voltage magnitude, line loading, and load profiles. Uses matplotlib to visualize the time series data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n%matplotlib inline  \n\n# voltage results\nvm_pu_file = os.path.join(output_dir, \"res_bus\", \"vm_pu.xlsx\")\nvm_pu = pd.read_excel(vm_pu_file, index_col=0)\nvm_pu.plot(label=\"vm_pu\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"voltage mag. [p.u.]\")\nplt.title(\"Voltage Magnitude\")\nplt.grid()\nplt.show()\n\n# line loading results\nll_file = os.path.join(output_dir, \"res_line\", \"loading_percent.xlsx\")\nline_loading = pd.read_excel(ll_file, index_col=0)\nline_loading.plot(label=\"line_loading\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"line loading [%]\")\nplt.title(\"Line Loading\")\nplt.grid()\nplt.show()\n\n# load results\nload_file = os.path.join(output_dir, \"res_load\", \"p_mw.xlsx\")\nload = pd.read_excel(load_file, index_col=0)\nload.plot(label=\"load\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"P [MW]\")\nplt.grid()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Accessing Unbalanced Power Flow Results in Pandapower\nDESCRIPTION: Fetches and displays the results from the unbalanced power flow calculation, including voltage and unbalance percentage. The results are stored with a '_3ph' suffix in the network object.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_3ph\n```\n\n----------------------------------------\n\nTITLE: Power Flow Results Visualization with Pandapower and Plotly\nDESCRIPTION: Shows how to use pf_res_plotly() to create a plot visualizing power flow results. The plot uses a colormap to represent line loading and voltage magnitudes. This example uses the mv_oberrhein network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/built-in_plots.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.plotting.plotly import pf_res_plotly\nfrom pandapower.networks import mv_oberrhein\nnet = mv_oberrhein()\npf_res_plotly(net)\n```\n\n----------------------------------------\n\nTITLE: Parametrization for Optimization with Pandapower in Python\nDESCRIPTION: Copies and modifies grid parameters to set up for optimization. It marks loads as uncontrollable and DERs as controllable, sets voltage and power bounds for bus, external grid, and DERs. These settings are prerequisites for optimization with PandaModels.jl, affecting allowable states for operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet_opt = deepcopy(net) # copy of the grid for further comparison \nnet_opt.load['controllable'] = False\nnet_opt.sgen['controllable'] = True\n```\n\nLANGUAGE: python\nCODE:\n```\n# lower and upper bounds for buses\nnet_opt.bus[\"max_vm_pu\"] = 1.1\nnet_opt.bus[\"min_vm_pu\"] = 0.9\n\n# lower and upper bounds for external grid\nnet_opt.ext_grid[\"max_q_mvar\"] = 10000.0\nnet_opt.ext_grid[\"min_q_mvar\"] = -10000.0\nnet_opt.ext_grid[\"max_p_mw\"] = 10000.0\nnet_opt.ext_grid[\"min_p_mw\"] = -10000.0\n```\n\nLANGUAGE: python\nCODE:\n```\n# lower and upper bounds for DERs\nnet_opt.sgen[\"max_p_mw\"] = net_opt.sgen.p_mw.values\nnet_opt.sgen[\"min_p_mw\"] = net_opt.sgen.p_mw.values\nnet_opt.sgen[\"max_q_mvar\"] = net_opt.sgen.p_mw.values * 0.328\nnet_opt.sgen[\"min_q_mvar\"] = -net_opt.sgen.p_mw.values * 0.328\ndisplay(net_opt.sgen)\n```\n\nLANGUAGE: python\nCODE:\n```\n# lower and upper bounds for lines\nnet_opt.trafo[\"max_loading_percent\"] = 100.0\nnet_opt.line[\"max_loading_percent\"] = 100.0\n```\n\nLANGUAGE: python\nCODE:\n```\nnet_opt.bus[\"pm_param/setpoint_v\"] = None # add extra column\nnet_opt.bus[\"pm_param/setpoint_v\"].loc[net_opt.sgen.bus] = 0.96 # voltage setpoints for theses buses are 0.96\n```\n\n----------------------------------------\n\nTITLE: Creating an Output Writer\nDESCRIPTION: This function creates an OutputWriter object to handle the storage of simulation results. It specifies the output directory, file type, and the variables to be logged during the time series simulation. The logged variables include active power for loads and generators, bus voltage magnitudes, and line loading percentages and current magnitudes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef create_output_writer(net, time_steps, output_dir):\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".xls\", log_variables=list())\n    # these variables are saved to the harddisk after / during the time series loop\n    ow.log_variable('res_load', 'p_mw')\n    ow.log_variable('res_sgen', 'p_mw')\n    ow.log_variable('res_bus', 'vm_pu')\n    ow.log_variable('res_line', 'loading_percent')\n    ow.log_variable('res_line', 'i_ka')\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Initializing CIGRE Network with Dependencies\nDESCRIPTION: Imports required libraries and creates a CIGRE MV network with distributed energy resources (DER). Sets all switches to closed state.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandapower as pp\nfrom pandapower.networks import create_cigre_network_mv\nfrom pandapower.create import create_group\nnet = create_cigre_network_mv(with_der=\"all\")\nnet.switch[\"closed\"] = True\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow with Control in pandapower\nDESCRIPTION: This snippet shows how to run a power flow simulation with control enabled in pandapower. The 'run_control=True' parameter activates the control loop mechanism.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/control/control_loop.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nrunpp(net, run_control=True)\n```\n\n----------------------------------------\n\nTITLE: Implementing IDTOC Relays in Pandapower Network\nDESCRIPTION: This code demonstrates the implementation of Inverse Definite Time Minimum over current (IDTOC) relays in a Pandapower network. It includes changing switch types, creating IDTOC relays, and calculating protection results for a short circuit scenario.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Change the switch type in the network\nnet=oc_relay_net()\nnet.switch.type='CB_IDTOC'\n\n# create IDTOC relays in the network\nfor k in range(6):\n    OCRelay(net, switch_index=k, oc_relay_type='IDTOC', time_settings=[0.07, 0.5, 0.3, 1, 0.5])\n\n# create short circuit\nnet_sc = create_sc_bus(net, sc_line_id=4, sc_fraction=0.5)\nsc.calc_sc(net_sc, bus=max(net_sc.bus.index), branch_results=True)\nprotection_results = calculate_protection_times(net_sc, scenario='sc')\n                                                \n# find protection results\nprotection_results = calculate_protection_times(net_sc, scenario='sc')\n\n# show protection_results\nprotection_results\n```\n\n----------------------------------------\n\nTITLE: Fusing Geodata in Pandapower Network for Simplified Plotting in Python\nDESCRIPTION: This code demonstrates how to use the fuse_geodata function to combine geographically close buses, simplifying the network representation for plotting.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport geojson\nnet.bus.geo.loc\n\nplot.fuse_geodata(net)\nsizes = plot.get_collection_sizes(net)\nbc = plot.create_bus_collection(net, net.bus.index, size=sizes['bus'], color=colors[0], zorder=10)\ntlc, tpc = plot.create_trafo_collection(net, net.trafo.index, color=\"g\", size=sizes['trafo'])\nlcd = plot.create_line_collection(net, net.line.index, color=\"grey\", linewidths=0.5, use_bus_geodata=True)\nsc = plot.create_bus_collection(net, net.ext_grid.bus.values, patch_type=\"rect\", size=sizes['bus'], color=\"y\", zorder=11)\nplot.draw_collections([lcd, bc, tlc, tpc, sc], figsize=(8,6))\n```\n\n----------------------------------------\n\nTITLE: Adding a Bad Measurement\nDESCRIPTION: This snippet demonstrates how to add a potentially erroneous measurement to a line in the network, allowing for testing of the bad data handling functionality of the pandapower library.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\npp.create_measurement(net, \"p\", \"line\", 1.0, 0.008, element=l1, side=b3)  # Pline (bus 1 -> bus 2) at bus 3\nnet.measurement\n```\n\n----------------------------------------\n\nTITLE: Running Optimal Power Flow\nDESCRIPTION: Executes the Optimal Power Flow calculation with specified tolerance parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_dcline.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Updating Controller to Use SplineCharacteristic in Pandapower\nDESCRIPTION: This snippet updates the VmSetTapControl controller to utilize the SplineCharacteristic instead of the linear characteristic, enabling non-linear tap adjustment based on transformer loads.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ntc1.characteristic_index = c2.index\n```\n\n----------------------------------------\n\nTITLE: Enforcing Generator Reactive Power Limits in pandapower Power Flow\nDESCRIPTION: This snippet shows how to enforce generator reactive power limits in pandapower power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nnet.res_gen\n\npp.runpp(net, enforce_q_lims=True)\nnet.res_gen\n```\n\n----------------------------------------\n\nTITLE: Running DC Optimal Power Flow in pandapower with PYPOWER\nDESCRIPTION: This function runs a DC Optimal Power Flow, which is a linearized optimization of the grid state. It offers two cost function options and is suitable for specific use cases.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pypower_run.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.rundcopp\n```\n\n----------------------------------------\n\nTITLE: Accessing State Estimation Results\nDESCRIPTION: This snippet accesses the estimated voltage magnitudes and angles results directly from the pandapower data structure after the state estimation process has been completed.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nnet.res_bus_est.vm_pu\n\nnet.res_bus_est.va_degree\n```\n\n----------------------------------------\n\nTITLE: Creating Data Source for Time Series P Values\nDESCRIPTION: This function generates random profiles for a defined number of timesteps, creating a dataset for load and sgen power values using pandas. The data is encapsulated in a DFData object, providing time series data for use in simulation steps.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef create_data_source(n_timesteps=24):\n    profiles = pd.DataFrame()\n    profiles['load1_p'] = np.random.random(n_timesteps) * 10.\n    profiles['sgen1_p'] = np.random.random(n_timesteps) * 20.\n\n    ds = DFData(profiles)\n\n    return profiles, ds\n```\n\n----------------------------------------\n\nTITLE: Creating Boxplot Function for Time-Series Contingency Analysis Results in pandapower\nDESCRIPTION: This function creates a more detailed visualization of the time-series contingency analysis results using boxplots. It shows the distribution of line loadings and bus voltages for each time step.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef plot_results_boxplots():\n    fig, ((ax11, ax12), (ax21, ax22)) = plt.subplots(ncols=2, nrows=2, sharey=\"row\", sharex=\"col\", figsize=(10,6))\n\n    ow.output[\"res_line.max_loading_percent\"].T.boxplot(ax=ax11, whis=[0,100], grid=False)\n    ax11.set_title(\"max. Loading of lines per time step, N-1 (%)\")\n    ax11.set_ylabel(\"Line loading (%)\")\n\n    ow.output[\"res_line.min_loading_percent\"].T.boxplot(ax=ax12, whis=[0,100], grid=False)\n    ax12.set_title(\"min. Loading of lines per time step, N-1 (%)\")\n\n    ow.output[\"res_bus.max_vm_pu\"].T.boxplot(ax=ax21, whis=[0,100], grid=False)\n    ax21.set_title(\"max. $V_m$ of buses per time step, N-1 (p.u.)\")\n    ax21.set_ylabel(\"Bus voltage magnitude (p.u.)\")\n    ax21.set_xlabel(\"Time step\")\n\n    ow.output[\"res_bus.min_vm_pu\"].T.boxplot(ax=ax22, whis=[0,100], grid=False)\n    ax22.set_title(\"min. $V_m$ of buses per time step, N-1 (p.u.)\")\n    ax22.set_xlabel(\"Time step\")\n\n    plt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Implementing DiscreteTapControl in Python\nDESCRIPTION: This code implements a DiscreteTapControl for the first transformer with a voltage deadband of 0.99 to 1.01 pu.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.control as control\ntrafo_controller = control.DiscreteTapControl(net=net, element_index=114, vm_lower_pu=0.99, vm_upper_pu=1.01)\n```\n\n----------------------------------------\n\nTITLE: Running State Estimation\nDESCRIPTION: This snippet performs state estimation for the pandapower network using the WLS method, initialized with flat starting conditions for voltage magnitude and angles. The success of the operation is printed afterward.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfrom pandapower.estimation import estimate\n\nsuccess = estimate(net, init='flat')\nprint(success)\n```\n\n----------------------------------------\n\nTITLE: Comparing Power Flow Results\nDESCRIPTION: Displays and compares power flow results between original and reduced grids\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(\"--- power flow (original grid) ---\")\ndisplay(net.res_bus)\nprint(\"--- power flow (reduced grid) ---\")\ndisplay(net_eq.res_bus)\n```\n\n----------------------------------------\n\nTITLE: Creating a Power Grid in Pandapower - Python\nDESCRIPTION: This snippet sets up a meshed 110kV power grid in pandapower, including buses, a transformer, lines, loads, and generators, with optimization constraints defined for voltage parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport numpy as np\n\nnet = pp.create_empty_network()\n\nmin_vm_pu = 0.95\nmax_vm_pu = 1.05\n\n#create buses\nbus1 = pp.create_bus(net, vn_kv=220., geodata=(5,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus2 = pp.create_bus(net, vn_kv=110., geodata=(6,10), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus3 = pp.create_bus(net, vn_kv=110., geodata=(10,9), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus4 = pp.create_bus(net, vn_kv=110., geodata=(8,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\nbus5 = pp.create_bus(net, vn_kv=110., geodata=(6,8), min_vm_pu=min_vm_pu, max_vm_pu=max_vm_pu)\n\n#create 220/110/110 kV 3W-transformer\npp.create_transformer3w_from_parameters(net, bus1, bus2, bus5, vn_hv_kv=220, vn_mv_kv=110,\n                                        vn_lv_kv=110, vk_hv_percent=10., vk_mv_percent=10.,\n                                        vk_lv_percent=10., vkr_hv_percent=0.5,\n                                        vkr_mv_percent=0.5, vkr_lv_percent=0.5, pfe_kw=10,\n                                        i0_percent=0.1, shift_mv_degree=0, shift_lv_degree=0,\n                                        sn_hv_mva=100, sn_mv_mva=50, sn_lv_mva=50)\n\n#create 110 kV lines\nl1 = pp.create_line(net, bus2, bus3, length_km=70., std_type='149-AL1/24-ST1A 110.0')\nl2 = pp.create_line(net, bus3, bus4, length_km=50., std_type='149-AL1/24-ST1A 110.0')\nl3 = pp.create_line(net, bus4, bus2, length_km=40., std_type='149-AL1/24-ST1A 110.0')\nl4 = pp.create_line(net, bus4, bus5, length_km=30., std_type='149-AL1/24-ST1A 110.0')\n\n#create loads\npp.create_load(net, bus2, p_mw=60)\npp.create_load(net, bus3, p_mw=70)\npp.create_load(net, bus4, p_mw=10)\n\n#create generators\ng1 = pp.create_gen(net, bus1, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01, slack=True)\npp.create_poly_cost(net, g1, 'gen', cp1_eur_per_mw=1)\n\ng2 = pp.create_gen(net, bus3, p_mw=40, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g2, 'gen', cp1_eur_per_mw=3)\n\ng3 = pp.create_gen(net, bus4, p_mw=50, min_p_mw=0, max_p_mw=200, vm_pu=1.01)\npp.create_poly_cost(net, g3, 'gen', cp1_eur_per_mw=3)\nnet\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage Buses in PandaPower Network\nDESCRIPTION: Creates multiple high voltage buses including double busbar, single busbar, and additional buses. Uses loops to create numbered buses efficiently.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Double busbar\npp.create_bus(net, name='Double Busbar 1', vn_kv=380, type='b')\npp.create_bus(net, name='Double Busbar 2', vn_kv=380, type='b')\nfor i in range(10):\n    pp.create_bus(net, name='Bus DB T%s' % i, vn_kv=380, type='n')\nfor i in range(1, 5):\n    pp.create_bus(net, name='Bus DB %s' % i, vn_kv=380, type='n')\n\n# Single busbar\npp.create_bus(net, name='Single Busbar', vn_kv=110, type='b')\nfor i in range(1, 6):\n    pp.create_bus(net, name='Bus SB %s' % i, vn_kv=110, type='n')\nfor i in range(1, 6):\n    for j in [1, 2]:\n        pp.create_bus(net, name='Bus SB T%s.%s' % (i, j), vn_kv=110, type='n')\n\n# Remaining buses\nfor i in range(1, 5):\n    pp.create_bus(net, name='Bus HV%s' % i, vn_kv=110, type='n')\n\n# show bustable\nnet.bus\n```\n\n----------------------------------------\n\nTITLE: Accessing Nodal Admittance Matrix (Ybus) in pandapower\nDESCRIPTION: Shows how to access and display the nodal admittance matrix (Ybus) after running an AC power flow.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nnet._ppc[\"internal\"][\"Ybus\"].todense()\n```\n\n----------------------------------------\n\nTITLE: Using VmSetTapControl with Characteristic for Voltage Adjustment\nDESCRIPTION: This snippet establishes a VmSetTapControl instance that uses a predefined Characteristic to dynamically adjust the voltage setpoints of a transformer in response to power flow changes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ntc = control.VmSetTapControl(net, 0, characteristic_index=c.index, tol=0.0005)\n```\n\n----------------------------------------\n\nTITLE: Calculating correction factor for power system unit without OLTC\nDESCRIPTION: This snippet calculates the correction factor KSO for a power system unit without On-Load Tap Changer, considering additional parameters such as generator and transformer percentages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\np_g = net.gen.pg_percent / 100\np_t = net.trafo['pt_percent'] / 100\nkso = (v_q / (v_g * (1 + p_g))) * (vn_trafo_lv / vn_trafo_hv) * (1 - p_t) * ps_cmax / (1 + xdss_pu * sin_phi_gen)\n```\n\n----------------------------------------\n\nTITLE: Importing necessary libraries\nDESCRIPTION: This code snippet imports the required libraries for the pandapower time series simulation, including pandapower itself, pandas for data handling, numpy for numerical operations, and specific modules for time series processing, controller management, and output writing. Matplotlib is also imported for plotting the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nimport tempfile\nimport pandapower as pp\nfrom pandapower.timeseries import DFData\nfrom pandapower.timeseries import OutputWriter\nfrom pandapower.timeseries.run_time_series import run_timeseries\nfrom pandapower.control import ConstControl\nimport pandapower.control as control\nimport matplotlib.pyplot as plt\n%matplotlib inline \n```\n\n----------------------------------------\n\nTITLE: Running TNEP Optimization with PowerModels and pandapower in Python\nDESCRIPTION: This function runs the TNEP optimization using PowerModels and pandapower. It initializes the grid, adds possible new lines, runs the optimization, and verifies the results by checking line loading limits after optimization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_tnep.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n\ndef pm_tnep_cigre():\n    net = cigre_grid()\n    define_possible_new_lines(net)\n    pp.runpp(net)\n    print(\"Max line loading prior to optimization:\")\n    print(net.res_line.loading_percent.max())\n    assert np.any(net[\"res_line\"].loc[:, \"loading_percent\"] > net[\"line\"].loc[:, \"max_loading_percent\"])\n\n    pp.runpm_tnep(net)\n    print(\"These lines are to be built:\")\n    print(net[\"res_ne_line\"])\n    \n    lines_to_built = net[\"res_ne_line\"].loc[net[\"res_ne_line\"].loc[:, \"built\"], \"built\"].index\n    net[\"line\"].loc[lines_to_built, \"in_service\"] = True\n    \n    pp.runpp(net)\n    \n    assert not np.any(net[\"res_line\"].loc[:, \"loading_percent\"] > net[\"line\"].loc[:, \"max_loading_percent\"])\n    \n    print(\"Max line loading after the optimization:\")\n    print(net.res_line.loading_percent.max())\n```\n\n----------------------------------------\n\nTITLE: Calculating Transformer Loading in pandapower Power Flow\nDESCRIPTION: This snippet demonstrates how to calculate transformer loading in relation to rated current or rated power.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, trafo_loading=\"current\")\nnet.res_trafo\n\npp.runpp(net, trafo_loading=\"power\")\nnet.res_trafo\n```\n\n----------------------------------------\n\nTITLE: Reporting Contingency Analysis Results in pandapower\nDESCRIPTION: This code snippet demonstrates how to report the results of a contingency analysis, including any limit violations, using the report_contingency_results function from pandapower.contingency.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.contingency.report_contingency_results(element_limits, res)\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Calculation\nDESCRIPTION: This snippet performs a power flow calculation on the created power system using `pp.runpp(net)`. The `net.res_line` command then displays the results for the lines in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nnet.res_line\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow with TDPF\nDESCRIPTION: This code snippet runs the power flow calculation with the temperature-dependent power flow (TDPF) option enabled.  The maximum number of iterations is set to 30.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, tdpf=True, max_iteration=30)\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature (Frank et al.)\nDESCRIPTION: This code calculates the overhead line temperature using the approach of Frank et al. It involves calculating the thermal resistance and active power losses and then using these values to determine the line temperature.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nbranch = net._ppc[\"branch\"]\ntdpf_lines = np.ones(len(branch)).astype(bool)\nr = branch[tdpf_lines, BR_R].real\n#r = r * (1 + alpha_pu * (T - 20))\nx = branch[tdpf_lines, BR_X].real\ng, b = calc_g_b(r, x)\nVm = abs(net._ppc[\"internal\"][\"V\"])\nVa = np.angle(net._ppc[\"internal\"][\"V\"])\ni_square_pu, p_loss_pu = calc_i_square_p_loss(branch, tdpf_lines, g, b, Vm, Va)\n#i_square_pu = np.square(net.res_line.i_ka.values*1e3)\nr_theta_pu = calc_r_theta(t_air_pu, a0, a1, a2, np.square(net.res_line.i_ka.values*1e3), p_loss_pu)\ncalc_T_frank(p_loss_pu, t_air_pu, r_theta_pu, None, None, None)\n```\n\n----------------------------------------\n\nTITLE: Power Results Printing Utility Function\nDESCRIPTION: Defines a utility function to print power consumption, generation, and loss results from the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/distributed_slack.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef print_powers(net):\n    print(f\"Consumption of loads:\\t\\t\\t {net.load.at[0, 'p_mw']:>6.2f} MW\\t {net.load.at[1, 'p_mw']:>6.2f} MW\\t {net.load.at[2, 'p_mw']:>6.2f} MW\\t ({net.load.p_mw.sum():>6.2f} MW total)\")\n    print(f\"Injection of generators (input):\\t {net.gen.at[0, 'p_mw']:>6.2f} MW\\t {net.gen.at[1, 'p_mw']:>6.2f} MW\\t\\t\\t ({net.gen.p_mw.sum():>6.2f} MW total)\")\n    print(f\"Injection of generators (results):\\t {net.res_gen.at[0, 'p_mw']:>6.2f} MW\\t {net.res_gen.at[1, 'p_mw']:>6.2f} MW\\t\\t\\t ({net.res_gen.p_mw.sum():>6.2f} MW total)\")\n    print(f\"Injection of generators (difference):\\t {net.res_gen.at[0, 'p_mw']-net.gen.at[0, 'p_mw']:>6.2f} MW\\t {net.res_gen.at[1, 'p_mw']-net.gen.at[1, 'p_mw']:>6.2f} MW\\t\\t\\t ({net.res_gen.p_mw.sum()-net.gen.p_mw.sum():>6.2f} MW total)\")\n    print(f\"Slack power at ext_grid (results):\\t {net.res_ext_grid.at[0, 'p_mw']:>6.2f} MW\")\n    print(f\"Line losses (results):\\t\\t\\t {net.res_line.pl_mw.sum():>6.2f} MW\")\n```\n\n----------------------------------------\n\nTITLE: Setting Control Parameters\nDESCRIPTION: Configures controllability settings for loads and generators.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.load['controllable'] = False\nnet.sgen['controllable'] = True\n```\n\n----------------------------------------\n\nTITLE: Plotting Resulting Distributions of Grid Parameters\nDESCRIPTION: This snippet uses Matplotlib to generate histograms of resulting voltage and loading distributions for buses, lines, and transformers. It visually represents how uncertainties in input parameters affect grid performance, identifying grid elements unaffected by randomness.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# voltages at buses 4, 7 and 9\nfig, ax = hist_plot(50, {\n    \"Bus 4\" : results_dict[\"res_bus.vm_pu\"][4],\n    \"Bus 9\" : results_dict[\"res_bus.vm_pu\"][9],\n    \"Bus 10\": results_dict[\"res_bus.vm_pu\"][10]})\nax.set_xlabel(\"Vm in pu\")\nplt.tight_layout()\n\n# loadings of lines 2, 8, 6 and 10\nfig, ax = hist_plot(50, {\n    \"Line 2\" : results_dict[\"res_line.loading_percent\"][2],\n    \"Line 8\" : results_dict[\"res_line.loading_percent\"][8],\n    \"Line 6\" : results_dict[\"res_line.loading_percent\"][6],\n    \"Line 10\": results_dict[\"res_line.loading_percent\"][10]})\nax.set_xlabel(\"Loading in percent\")\nplt.tight_layout()\n\n# loadings of both transformers\nfig, ax = hist_plot(50, {\n    \"Trafo 0\" : results_dict[\"res_trafo.loading_percent\"][0],\n    \"Trafo 1\" : results_dict[\"res_trafo.loading_percent\"][1]})\nax.set_xlabel(\"Loading in percent\")\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Creating Static Generators for Medium Voltage Network in Python\nDESCRIPTION: Imports static generator data from a CSV file and creates static generator objects connected to medium voltage buses. Each generator is assigned a name, active power, reactive power, nominal apparent power, and type.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmv_sgens = pd.read_csv('example_advanced/mv_sgens.csv', sep=';', header=0, decimal=',')\nfor _, sgen in mv_sgens.iterrows():\n    bus_idx = pp.get_element_index(net, \"bus\", sgen.bus)\n    pp.create_sgen(net, bus_idx, p_mw=sgen.p, q_mvar=sgen.q, sn_mva=sgen.sn, type=sgen.type, name=sgen.sgen_name)\n\n# show only medium voltage static generators\nnet.sgen[net.sgen.bus.isin(mv_buses)]\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis and Checking Fuse Melting in pandapower\nDESCRIPTION: Performs power flow calculation after fault clearance and checks if any fuses melt due to potential overload conditions. This utilizes the pandapower runpp function and a custom calculate_protection_times function to assess protection device response.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# perform power flow calculation\npp.runpp(net)\n\n# check if any fuses melt during regular power flow after fault has been cleared\noverload_results = calculate_protection_times(net, scenario=\"pp\")\noverload_results\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Power Plant and Feeder Groups\nDESCRIPTION: Demonstrates two methods of creating groups: one for a virtual power plant combining storage, generators and loads, and another for elements in the second feeder using connected elements dictionary.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# define a Group as virtual power plant\ngr1_name = \"virtual power plant\"\nvpp_element_types = [\"storage\", \"sgen\", \"load\"]\nvpp_elements = [[1], [6, 8, 9, 10, 11, 12], [5, 6]]\ngr1_idx = create_group(net, vpp_element_types, vpp_elements, name=gr1_name)\n\n# define a Group of a Feeder 2\ngr2_name = \"Feeder2\"\nfeeder2buses = [12, 13, 14]\nfeeder2_elements_dict = pp.get_connected_elements_dict(net, feeder2buses)\nfeeder2_elements_dict[\"bus\"] = feeder2buses\ngr2_idx = pp.create_group_from_dict(net, feeder2_elements_dict, name=gr2_name)\n```\n\n----------------------------------------\n\nTITLE: Creating Shunt Elements in Pandapower\nDESCRIPTION: Functions for creating shunt elements and capacitors in a Pandapower network. These functions allow users to add shunt components to their power system model.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/shunt.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.create.create_shunt\n```\n\nLANGUAGE: python\nCODE:\n```\npandapower.create.create_shunt_as_capacitor\n```\n\n----------------------------------------\n\nTITLE: Controller Setup for Three-Phase System\nDESCRIPTION: Sets up controllers for managing active and reactive power for each phase of the three-phase system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef create_controllers(net, ds):\n    ConstControl(net, element='asymmetric_load', variable='p_a_mw', element_index=loads[loads['phases']=='A'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='A'].Yearly)\n    ConstControl(net, element='asymmetric_load', variable='q_a_mvar', element_index=loads[loads['phases']=='A'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='A'].Yearly+'_Q')\n    \n    ConstControl(net, element='asymmetric_load', variable='p_b_mw', element_index=loads[loads['phases']=='B'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='B'].Yearly)\n    ConstControl(net, element='asymmetric_load', variable='q_b_mvar', element_index=loads[loads['phases']=='B'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='B'].Yearly+'_Q')\n    \n    ConstControl(net, element='asymmetric_load', variable='p_c_mw', element_index=loads[loads['phases']=='C'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='C'].Yearly)\n    ConstControl(net, element='asymmetric_load', variable='q_c_mvar', element_index=loads[loads['phases']=='C'].index,\n                 data_source=ds, profile_name=loads[loads['phases']=='C'].Yearly+'_Q')   \n    return net\n```\n\n----------------------------------------\n\nTITLE: Executing Power Flow Calculations Using Time Series\nDESCRIPTION: This snippet runs the time series simulations over the grid with prepared random time series data. It uses Pandapower's run_timeseries function to simulate the power grid's behavior across defined time steps, storing the results in an output writer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# run time series\npp.timeseries.run_timeseries(net, time_steps=range(n_random_values))\nresults_dict = ow.output\n```\n\n----------------------------------------\n\nTITLE: Plotting Time-Current Characteristic Curve for OC Relay in Pandapower\nDESCRIPTION: This code demonstrates how to plot the time-current characteristic curve of an over-current relay using the plot_protection_characteristic method of the OCRelay object in Pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.protection.object.at[4].plot_protection_characteristic(net=net, xmin=10, xmax=10000, ymin=0.01, ymax=10000)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Tripped Grid for OC Relay Protection in Pandapower\nDESCRIPTION: This code snippet plots the tripped grid after a short circuit event, showing tripped switches, short circuit currents, and the short circuit location with annotations using Pandapower's plot_tripped_grid_protection_device function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.protection.utility_functions import plot_tripped_grid_protection_device\nplot_tripped_grid_protection_device(net_sc, protection_results, sc_bus=max(net_sc.bus.index), sc_location=0.5)\n```\n\n----------------------------------------\n\nTITLE: Creating a Three-Winding Transformer Grid Function in Pandapower\nDESCRIPTION: This function creates a simple grid with a three-winding transformer, external grid, and buses. It allows specifying the vector group and nominal power of the system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_1ph_vector_group_trafo3w.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.create import create_empty_network, create_bus, create_ext_grid, create_transformer3w_from_parameters\ndef single_3w_trafo_grid(vector_group, sn_mva=123):\n    net = create_empty_network(sn_mva=sn_mva)\n    b1 = create_bus(net, vn_kv=380., geodata=(1, 1))\n    b2 = create_bus(net, vn_kv=110., geodata=(0, 1))\n    b3 = create_bus(net, vn_kv=30., geodata=(1, 0))\n    create_ext_grid(net, b1, s_sc_max_mva=1000, s_sc_min_mva=800, rx_max=0.1, x0x_max=1, r0x0_max=0.1, rx_min=0.1,\n                    x0x_min=1, r0x0_min=0.1)\n\n    create_transformer3w_from_parameters(net, hv_bus=b1, mv_bus=b2, lv_bus=b3, vn_hv_kv=400, vn_mv_kv=120, vn_lv_kv=30,\n                                         sn_hv_mva=350, sn_mv_mva=350, sn_lv_mva=50, pfe_kw=0, i0_percent=0,\n                                         vk_hv_percent=21, vkr_hv_percent=.26, vk_mv_percent=7, vkr_mv_percent=.16,\n                                         vk_lv_percent=10., vkr_lv_percent=.16, vk0_hv_percent=44.1,\n                                         vkr0_hv_percent=0.26, vk0_mv_percent=6.2996, vkr0_mv_percent=0.03714,\n                                         vk0_lv_percent=6.2996, vkr0_lv_percent=0.03714, vector_group=vector_group)\n    return net\n```\n\n----------------------------------------\n\nTITLE: Defining the Time Series Example Function\nDESCRIPTION: This function outlines the general steps involved in running a time series simulation within pandapower. It involves creating a data source with time series data, creating controllers to update network elements based on the data source, defining an output writer to store the simulation results to files.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef timeseries_example(net, output_dir):\n    # 1. create (random) data source\n    n_timesteps = 24\n    profiles, ds = create_data_source(n_timesteps)\n    # 2. create controllers \n    create_controllers(net, ds)\n    # time steps to be calculated. Could also be a list with non-consecutive time steps\n    time_steps = range(0, n_timesteps)\n    # 3. the output writer with the desired results to be stored to files.\n    ow = create_output_writer(net, time_steps, output_dir=output_dir)\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Running Three Phase Load Flow\nDESCRIPTION: Performs three phase load flow calculation and displays results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.add_zero_impedance_parameters(net)\npp.runpp_3ph(net)\nprint(net.trafo)\nprint(\"----------------\")\nnet.res_bus_3ph\n```\n\n----------------------------------------\n\nTITLE: Defining Grid Equivalent Parameters\nDESCRIPTION: Sets up parameters for grid equivalent calculation including equivalent type, boundary buses, and internal buses\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# equivalent type\neq_type = \"rei\"\n\n# boundary buses\nboundary_buses = [4, 8]\n\n# internal buses \ninternal_buses = [0]\n```\n\n----------------------------------------\n\nTITLE: Performing Short-Circuit Calculation with pandapower for Full Size Converter\nDESCRIPTION: This code uses pandapower to perform short-circuit calculations for a wind power station with a full size converter and displays the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n%%capture\n# now with pandapower:\nnet = create_net(\"current_source\")\nsc.calc_sc(net, ip=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.sgen)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: Accessing Geographical Data from Pandapower Grid - Python\nDESCRIPTION: This snippet retrieves geographical coordinates of the first bus in the pandapower grid using geojson.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport geojson\ngeojson.loads(net.bus.geo.iloc[0])[\"coordinates\"]\n```\n\n----------------------------------------\n\nTITLE: Adding Custom and Standard Fuses to Network\nDESCRIPTION: Creates a new fuse type and adds it to the standard library, then assigns various fuse types to network switches including both custom and standard fuses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.protection.protection_devices.fuse import Fuse\nfrom pandapower import create_std_type\n\n# create dictionary that will be used to add new fuse to standard library\n# this data is the same as the HV 63A found in the standard library\nnew_fuse_data = {'fuse_type': 'New Fuse',\n                'i_rated_a': 63.0,\n                't_avg': 0,\n                't_min': [10.0, 2.84, 0.368, 0.164, 0.1, 0.0621, 0.0378, 0.0195, 0.01],\n                't_total': [10.0, 1.82, 0.344, 0.1, 0.0467, 0.0269, 0.01],\n                'x_avg': 0,\n                'x_min': [189.0, 220.0, 300.0, 350.0, 393.0, 450.0, 530.0, 700.0, 961.0],\n                'x_total': [378.0, 500.0, 700.0, 934.0, 1200.0, 1500.0, 2366.0]}\n\n# create new standard fuse type\ncreate_std_type(net, data=new_fuse_data, name='New Fuse', element=\"fuse\")\n\n# create list with the fuse types to be added to the network\nfuse_type_list = [\"New Fuse\", \"Siemens NH-2-630\", \"Siemens NH-2-425\", \"Siemens NH-2-315\", \"Siemens NH-2-224\"]\n\n# add fuses to network\nfor k in range(5):\n    Fuse(net=net, switch_index=k, fuse_type=fuse_type_list[k])\n```\n\n----------------------------------------\n\nTITLE: Creating Data Source with Random Profiles\nDESCRIPTION: Generates random load and generation profiles using pandas DataFrame for time series simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_source(n_timesteps=10):\n    profiles = pd.DataFrame()\n    profiles['load1_p'] = np.random.random(n_timesteps) * 15.\n    profiles['sgen1_p'] = np.random.random(n_timesteps) * 20.\n\n    ds = DFData(profiles)\n\n    return profiles, ds\n```\n\n----------------------------------------\n\nTITLE: Plotting Multiple Fuse Characteristic Curves with Overload Current in pandapower\nDESCRIPTION: Creates a comprehensive visualization showing multiple fuse characteristic curves and the overload current at a specific fuse. This visualization helps analyze protection coordination by showing the response times of different protective devices.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nplt.figure(2)\n\n# plot characteristic curve for each fuse in net\nprotection_devices = net.protection.object\nfor p in protection_devices:\n    p.plot_protection_characteristic(net)\n\n# reset plot limits manually\nplt.xlim(10, 100000)\nplt.ylim(0.001, 10000)\n\n# add overload current at Fuse 6\nplt.axvline(overload_results.activation_parameter_value.at[6]*1000)\n\n# show plot\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Running DC Optimal Power Flow with PowerModels - Python\nDESCRIPTION: This snippet demonstrates how to run the DC optimal power flow optimization using pandapower and PowerModels.jl.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_dc_opf(net)\nexcept:\n    print(\"Cannot be performed due to [WinError 3] - Can't find file python39.dll\")\n# or: pp.runpm(net, pm_model=\"DCPPowerModel\")\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Creating Lines with Zero Sequence Impedances in Pandapower\nDESCRIPTION: Shows how to define line parameters with zero-sequence impedances in the network. It requires information about line parameters found in Pandapower's documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.create_line_from_parameters(net, b2, b3, length_km=0.1, r0_ohm_per_km=0.0848,\n                               x0_ohm_per_km=0.4649556, c0_nf_per_km=230.6,\n                               max_i_ka=0.963, r_ohm_per_km=0.0212,\n                               x_ohm_per_km=0.1162389, c_nf_per_km= 230)\n```\n\n----------------------------------------\n\nTITLE: Switching Transformer Models in pandapower Power Flow\nDESCRIPTION: This snippet shows how to switch between 'pi' and 't' transformer models in pandapower power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/powerflow.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, trafo_model=\"t\")\nnet.res_trafo\n\npp.runpp(net, trafo_model=\"pi\")\nnet.res_trafo\n```\n\n----------------------------------------\n\nTITLE: Creating Pandapower Controllers for Load and Sgen\nDESCRIPTION: This function sets up controllers using ConstControl to link the random profiles generated in the data source to the load and sgen elements in the network. This allows the power values (P) to be updated at each time step during the simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef create_controllers(net, ds):\n    ConstControl(net, element='load', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"load1_p\"])\n    ConstControl(net, element='sgen', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"sgen1_p\"])\n```\n\n----------------------------------------\n\nTITLE: Configuring and Testing Fuses in Meshed Network\nDESCRIPTION: Assigns different fuse types to switches and performs short circuit analysis with protection time calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# assign fuses to switches\nfuse_list = ['HV 25A', 'Siemens NH-2-400', 'Siemens NH-2-250', 'Siemens NH-2-224', 'Siemens NH-2-200',\n             'Siemens NH-1-160', 'Siemens NH-1-125', 'Siemens NH-1-100', 'Siemens NH-1-80']\nfor k in range(9):\n    Fuse(net=net, switch_index=k, fuse_type=fuse_list[k])\n\n# perform short circuit calculation at bus 3\nsc.calc_sc(net, bus=3, branch_results=True)\n\n# calculate protection times\nprotection_results = calculate_protection_times(net, scenario='sc')\nprotection_results\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Generator Q Capability Analysis in Python\nDESCRIPTION: This snippet imports necessary libraries including pandas, numpy, and pandapower modules for creating and analyzing generator reactive power capability curves.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport numpy as np\nimport pandapower as pp\nfrom pandapower.control.util.auxiliary import create_q_capability_curve_characteristics_object\nfrom pandapower.control.util.diagnostic import q_capability_curve_table_diagnostic\n```\n\n----------------------------------------\n\nTITLE: Creating Loads for Medium Voltage Network in Python\nDESCRIPTION: Imports load data from a CSV file and creates load objects connected to medium voltage buses. Each load is assigned a name, active power (p_mw), and reactive power (q_mvar).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmv_loads = pd.read_csv('example_advanced/mv_loads.csv', sep=';', header=0, decimal=',')\nfor _, load in mv_loads.iterrows():\n    bus_idx = pp.get_element_index(net, \"bus\", load.bus)\n    pp.create_load(net, bus_idx, p_mw=load.p, q_mvar=load.q, name=load.load_name)\n\n# show only medium voltage loads\nnet.load[net.load.bus.isin(mv_buses)]\n```\n\n----------------------------------------\n\nTITLE: Plotting Transformer Characteristics in Python\nDESCRIPTION: This code plots the transformer characteristics for both vk_percent and vkr_percent based on the defined spline characteristics in the network, allowing for visual analysis of transformer performance across tap positions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.control.plot_characteristic(net[\"trafo_characteristic_spline\"][\"vk_percent_characteristic\"].loc[0], -2, 2,\n                               xlabel='Tap position \"tap_pos\"', ylabel='Value of \"vk_percent\"')\n```\n\nLANGUAGE: python\nCODE:\n```\npp.control.plot_characteristic(net[\"trafo_characteristic_spline\"][\"vkr_percent_characteristic\"].loc[0], -2, 2,\n                               xlabel='Tap position \"tap_pos\"', ylabel='Value of \"vkr_percent\"')\n```\n\n----------------------------------------\n\nTITLE: Checking Voltage and Unbalance Percentage Results in Pandapower\nDESCRIPTION: Accesses the voltage per phase and unbalance percentage from the power flow results, adhering to IEC 62749 standards for evaluating unbalanced conditions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_3ph[[\"vm_a_pu\", \"vm_b_pu\", \"vm_c_pu\", \"unbalance_percent\"]]\n```\n\n----------------------------------------\n\nTITLE: Creating a Generator in pandapower\nDESCRIPTION: Function to create a generator in a pandapower network. It takes various parameters to define the generator's properties and behavior.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/gen.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.create.create_gen\n```\n\n----------------------------------------\n\nTITLE: TDPF Timeseries Controller Implementation\nDESCRIPTION: Defines a custom controller class that updates line temperatures between timesteps by copying results from the previous calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass TDPF_timeseries_control(Controller):\n    def is_converged(self, net):\n        return True\n    \n    def finalize_step(self, net, time_step):\n        net.line.loc[net.line.tdpf, \"temperature_degree_celsius\"] = \\\n            net.res_line.loc[net.line.tdpf, \"temperature_degree_celsius\"]\n```\n\n----------------------------------------\n\nTITLE: Merging Bus and Load Dataframes for Voltage Analysis\nDESCRIPTION: This snippet merges the bus results dataframe with the load dataframe using the bus column of the load table, which refers to the bus index. This requires the Pandas library and outputs the combined results of buses and their corresponding loads. This enables analysis of bus voltages for all loads connected.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nload_bus_results = pd.merge(net.res_bus, net.load, left_index=True, right_on=\"bus\")\n\n#Output\nload_bus_results.head(n=8)\n```\n\n----------------------------------------\n\nTITLE: Executing the CIM to pandapower Conversion\nDESCRIPTION: Example of calling the from_cim function with the file list and CGMES version parameters to convert CGMES data to a pandapower network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet = cim2pp.from_cim(file_list=cgmes_files, cgmes_version='2.4.15')\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Parameters to Standard Types\nDESCRIPTION: Shows how to add additional custom parameters to standard types and create lines with them.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nnet = pp.create_empty_network()\ntest_type = {\"r_ohm_per_km\": 0.01, \"x_ohm_per_km\": 0.02, \"c_nf_per_km\": 10, \"max_i_ka\": 0.4, \"type\": \"cs\", \"h_per_km\": 0.01}\npp.create_std_type(net, name=\"test_type\", data=test_type, element=\"line\")\npp.available_std_types(net, element=\"line\")\n```\n\n----------------------------------------\n\nTITLE: Generating Random PV Plant Size using Normal Distribution\nDESCRIPTION: This function returns a random PV plant size in MW using a normal distribution. The mean is set to 0.5 MW with a standard deviation of 0.05 MW.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy.random import normal\n\ndef get_plant_size_mw():\n    return normal(loc=0.5, scale=0.05)\n```\n\n----------------------------------------\n\nTITLE: Creating Weighted Marker Traces for Load and Generation in pandapower\nDESCRIPTION: Example of how to create weighted marker traces for load (red) and generation (green) elements in a pandapower network and visualize them with simple_plotly. The marker_scaling parameter determines the size of the markers based on their values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/create_traces.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnet = mv_oberrhein()\nnet.load.scaling, net.sgen.scaling = 1, 1\nmarkers_load = create_weighted_marker_trace(net, elm_type=\"load\", color=\"red\",\n                                            marker_scaling=100)\nmarkers_sgen = create_weighted_marker_trace(net, elm_type=\"sgen\", color=\"green\",\n                                            marker_scaling=100)\nsimple_plotly(net, bus_size=1, additional_traces=[markers_load, markers_sgen])\n```\n\n----------------------------------------\n\nTITLE: Setting Voltage Constraints\nDESCRIPTION: This snippet demonstrates how to set voltage constraints on buses and run the OPF with these constraints.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet.bus[\"min_vm_pu\"] = 1.0\nnet.bus[\"max_vm_pu\"] = 1.02\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Running TDPF with Time Delay\nDESCRIPTION: This code runs the power flow calculation with TDPF enabled and a time delay of 5 minutes (300 seconds). The maximum number of iterations is set to 30.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, tdpf=True, tdpf_delay_s=5 * 60, max_iteration=30)\n```\n\n----------------------------------------\n\nTITLE: Performing Short-Circuit Calculation with pandapower for Doubly Fed Asynchronous Generator\nDESCRIPTION: This code uses pandapower to perform short-circuit calculations for a wind power station with a doubly fed asynchronous generator and displays the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n%%capture\n# now with pandapower:\nnet = create_net(\"async_doubly_fed\")\nsc.calc_sc(net, ip=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.sgen)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: Main Execution Function\nDESCRIPTION: Creates output directory and executes the time series analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\noutput_dir = os.path.join(tempfile.gettempdir(), \"time_series_example\")\nprint(\"Results can be found in your local temp folder: {}\".format(output_dir))\nif not os.path.exists(output_dir):\n    os.mkdir(output_dir)\ntimeseries_example(output_dir)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Line Loading from Simulation Results\nDESCRIPTION: This snippet reads and plots the loading percent of power lines from the simulation results stored in Excel files. By visualizing the loading over time, it ensures that constraints like maximum loading percentage are not violated, maintaining operational safety.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# line loading results\nll_file = os.path.join(output_dir, \"res_line\", \"loading_percent.xlsx\")\nline_loading = pd.read_excel(ll_file, index_col=0)\nline_loading.plot()\nplt.xlabel(\"time step\")\nplt.ylabel(\"line loading [%]\")\nplt.title(\"Line Loading\")\nplt.grid()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Plotting the Power System\nDESCRIPTION: This code generates a simple plot of the created power system using `pp.plotting.simple_plot`. It visualizes loads, shunt generators (sgens), and generators with specified sizes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.plotting.simple_plot(net, plot_loads=True, plot_sgens=True, plot_gens=True, load_size=3, sgen_size=3, gen_size=3)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Definition of Three-Phase Power Flow Bus Results\nDESCRIPTION: Mathematical formulas defining the per-phase bus voltage magnitude, angle, active power, and reactive power results from three-phase power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/bus.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\nvm\\_pu_{phase} &= \\lvert \\underline{V_{phase}}_{bus} \\rvert \\\\\nva\\_degree_{phase} &= \\angle \\underline{V_{phase}}_{bus} \\\\\np\\_mw_{phase} &= Re(\\sum_{n=1}^N  \\underline{S_{phase}}_{bus, n}) \\\\\nq\\_mvar_{phase} &= Im(\\sum_{n=1}^N  \\underline{S_{phase}}_{bus, n}) \n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Bus Voltage Results from Simulation\nDESCRIPTION: This snippet reads the simulation results for bus voltages from an Excel file, plotting them to illustrate the voltage profile over time. The voltage magnitudes are visualized to ensure compliance with predefined constraints, displaying in per unit (p.u.) values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n# voltage results\nvm_pu_file = os.path.join(output_dir, \"res_bus\", \"vm_pu.xlsx\")\nvm_pu = pd.read_excel(vm_pu_file, index_col=0)\nvm_pu.plot(label=\"vm_pu\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"voltage mag. [p.u.]\")\nplt.title(\"Voltage Magnitude\")\nplt.grid()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Calculating Complex Ratio for Ideal Phase Shifter in pandapower\nDESCRIPTION: Mathematical formula showing how the complex ratio is calculated for an ideal phase shifter with angle shift controlled by tap position.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n\\underline{n} &= n \\cdot e^{j \\cdot (\\theta + \\theta_{tp}) \\cdot \\frac{\\pi}{180}} \\\\\n\\theta &= shift\\_degree\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature for Different Wind Speeds in Python\nDESCRIPTION: This set of code snippets calculates the overhead line temperature for three different wind speed scenarios (0.5 m/s, 2 m/s, and 5 m/s) using the calc_a0_a1_a2_tau and calc_T_ngoko functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 0.5\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_05 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 2\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_2 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 5\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_5 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\n----------------------------------------\n\nTITLE: Creating a Pandapower Network\nDESCRIPTION: This snippet shows how to initialize a pandapower network, add buses, and create electrical lines connecting them. The network is set up with three buses and connections as specified.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport pandapower as pp\n\nnet = pp.create_empty_network()\n\nb1 = pp.create_bus(net, name=\"bus 1\", vn_kv=1., index=1)\nb2 = pp.create_bus(net, name=\"bus 2\", vn_kv=1., index=2)\nb3 = pp.create_bus(net, name=\"bus 3\", vn_kv=1., index=3)\n\npp.create_ext_grid(net, 1)  # set the slack bus to bus 1\n\nl1 = pp.create_line_from_parameters(net, 1, 2, 1, r_ohm_per_km=.01, x_ohm_per_km=.03, c_nf_per_km=0., max_i_ka=1)\nl2 = pp.create_line_from_parameters(net, 1, 3, 1, r_ohm_per_km=.02, x_ohm_per_km=.05, c_nf_per_km=0., max_i_ka=1)\nl3 = pp.create_line_from_parameters(net, 2, 3, 1, r_ohm_per_km=.03, x_ohm_per_km=.08, c_nf_per_km=0., max_i_ka=1)\n\nnet\n```\n\n----------------------------------------\n\nTITLE: Simulating Fuse Operation in Distribution Grid with pandapower\nDESCRIPTION: Simulates the operation of the fastest-melting fuse by applying its status change to the network model. The code identifies which fuse trips first and updates the network topology accordingly.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# fastest-melting fuse opens switch\nnet.protection.object.at[overload_results.trip_melt_time_s.idxmin()].status_to_net(net)\n\nnet.switch\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage Loads from CSV Data in PandaPower\nDESCRIPTION: Loads high voltage load data from a CSV file and creates loads in the network based on the data. Uses pandas to read the CSV and iterates through rows to create each load.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nhv_loads = pd.read_csv('example_advanced/hv_loads.csv', sep=';', header=0, decimal=',')\nhv_loads\n```\n\nLANGUAGE: python\nCODE:\n```\nfor _, load in hv_loads.iterrows():\n    bus_idx = pp.get_element_index(net, \"bus\", load.bus)\n    pp.create_load(net, bus_idx, p_mw=load.p, q_mvar=load.q, name=load.load_name)\n\n# show load table\nnet.load\n```\n\n----------------------------------------\n\nTITLE: Creating Lines with Custom Parameters\nDESCRIPTION: Demonstrates creating lines using both custom and standard types with additional parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nb1 = pp.create_bus(net, vn_kv=.4)\nb2 = pp.create_bus(net, vn_kv=.4)\nl1 = pp.create_line(net, from_bus=b1, to_bus=b2, length_km=0.1, std_type=\"test_type\", name=\"test_line1\")\nl2 = pp.create_line(net, from_bus=b1, to_bus=b2, length_km=0.1, std_type=\"NAYY 4x50 SE\", name=\"test_line2\")\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Saving Reactive Power with Multi-Objectives in Pandapower\nDESCRIPTION: Modifies the objective function to account for reactive power savings in addition to maintaining voltage setpoints. It provides an example using coefficients to balance reactive power usage with voltage accuracy, showcasing capability to set thresholds for optimization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet_optlim = deepcopy(net_opt)\nnet_optlim[\"obj_factors\"] = [0.99, 0.01] # set coefficients for the multi-objective function\ntry:\n    pp.runpm_vstab(net_optlim)\nexcept:\n    print(\"[WinError 3] The system cannot find the path specified to the python39.dll\")\n```\n\nLANGUAGE: python\nCODE:\n```\nprint (\"--- optimized reactive power without limitation Cv = 1.0, Cq = 0. ----\")\ndisplay(net_opt.res_sgen) # show optimized reactive power without limitation\nprint (\"--- optimized reactive power with limitation Cv = 0.99, Cq = 0.01 ----\")\ndisplay(net_optlim.res_sgen) # show optimized reactive power with limitation\n\nprint (\"--- deviation from setpoints without limitation Cv = 1.0, Cq = 0. ----\")\ndisplay(sum((v_opt - 0.96) ** 2)) # show optimized reactive power without limitation\nprint (\"--- deviation from setpoints with limitation Cv = 0.99, Cq = 0.01 ----\")\nv_optlim = net_optlim.res_bus.vm_pu[net_optlim.sgen.bus].values\ndisplay(sum((v_optlim - 0.96) ** 2)) # show optimized bus voltages\n```\n\n----------------------------------------\n\nTITLE: Checking Optimization Results for Q-Injection\nDESCRIPTION: Displays the optimization results showing the reactive power injection at the transformer's low-voltage side and the optimized reactive power from distributed energy resources.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net_opt.res_trafo.q_lv_mvar[0])  # show Q-injection at the interface after optimization\ndisplay(net_opt.res_sgen) # show optimized reactiv power provision of DER\n```\n\n----------------------------------------\n\nTITLE: Adding Power Injection Measurements to a Bus\nDESCRIPTION: This snippet adds active and reactive power injection measurements to the specified bus within the pandapower network, including their values and standard deviations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\npp.create_measurement(net, \"p\", \"bus\", 0.501, 0.01, element=b2)         # P at bus 2\npp.create_measurement(net, \"q\", \"bus\", 0.286, 0.01, element=b2)         # Q at bus 2\nnet.measurement\n```\n\n----------------------------------------\n\nTITLE: Calculating Ward Equivalent\nDESCRIPTION: Performs Ward equivalent calculation and verifies results\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# equivalent type\neq_type = \"ward\"   # for xward-equivalent: eq_type = \"xward\"\n\n# run equivalent calculation\nnet_eq_ward = pp.grid_equivalents.get_equivalent(net, eq_type, boundary_buses, \n                                                 internal_buses)\n```\n\n----------------------------------------\n\nTITLE: Running Initial Power Flow\nDESCRIPTION: Executes power flow calculation after scaling generator power values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.sgen.p_mw = net.sgen.p_mw * 8\nnet.sgen.sn_mva = net.sgen.sn_mva * 8\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for TDPF Analysis in Python\nDESCRIPTION: This snippet imports necessary Python libraries including pandas for data manipulation, matplotlib for plotting, numpy for numerical operations, and custom TDPF calculation functions from pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom pandapower.pf.create_jacobian_tdpf import calc_a0_a1_a2_tau, calc_T_ngoko\n```\n\n----------------------------------------\n\nTITLE: Updating Grid Costs and Re-running OPF\nDESCRIPTION: Modifies the cost parameters for external grids and executes OPF again to observe changes in power flow.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_dcline.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.poly_cost.cp1_eur_per_mw.at[costeg0] = 8\nnet.poly_cost.cp1_eur_per_mw.at[costeg1] = 10\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Visualizing TDPF Results\nDESCRIPTION: Creates comparison plots of line temperatures for different simulation scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfig, (ax1, ax2) = plt.subplots(nrows=1, ncols=2, sharey=True, figsize=(10, 5))\noutput_ss[0].plot(ax=ax1, label=\"Line 0 (steady-state)\")\noutput_ss_20[0].plot(ax=ax1, linestyle=\"--\", label=\"Line 0 (time resolution 15 min)\")\noutput_ss_20_5[0].plot(ax=ax1, linestyle=\"--\", label=\"Line 0 (time resolution 5 min)\")\nax1.legend(title=\"Results for line:\", loc=\"upper center\", bbox_to_anchor=[0.5,-0.2])\n\noutput_ss[0].plot(ax=ax2, label=\"Line 0 (steady-state)\")\noutput_15[0].plot(ax=ax2, linestyle=\"--\", label=\"Line 0 (time resolution 15 min)\")\noutput_5[0].plot(ax=ax2, linestyle=\"--\", label=\"Line 0 (time resolution 5 min)\")\nax2.legend(title=\"Results for line:\", loc=\"upper center\", bbox_to_anchor=[0.5,-0.2])\n\nax1.set_ylabel(\"Line temperature (°C)\")\nax1.set_xlabel(\"Time step\")\nax2.set_xlabel(\"Time step\")\n\nax1.set_title(\"Same starting temperature of 20 °C\")\nax2.set_title(\"Starting temperature from previous time step\")\nplt.tight_layout(pad=0)\n```\n\n----------------------------------------\n\nTITLE: Calculating Tap Factor for Cross Regulator in pandapower\nDESCRIPTION: Mathematical formula showing how the tap factor is calculated for a cross regulator that affects both magnitude and angle of the output voltage.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\nn_{tap} = 1 + (tap\\_pos - tap\\_neutral) \\cdot \\frac{tap\\_st\\_percent}{100} \\exp(\\mathrm j \\phi)\n```\n\n----------------------------------------\n\nTITLE: Creating Fuse Objects in pandapower\nDESCRIPTION: Implementation reference for the pandapower Fuse class that allows creation and configuration of fuse protection devices. The class is used to model fuses with rated currents from 16A to 1000A for low-voltage network protection.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/protection/fuse.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.protection.protection_devices.fuse.Fuse\n```\n\n----------------------------------------\n\nTITLE: Comparing voltage setpoint and resulting voltage\nDESCRIPTION: This code snippet plots the voltage setpoint of the transformer tap changer controller alongside the actual voltage at the controlled bus. It extracts the voltage setpoint from the DataFrame used by the ConstControl and the resulting voltage from the output writer, then overlays them on the same plot for comparison.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nax=net.controller.at[1,'object'].data_source.df['c'].plot(zorder=1, linestyle='--', label='Voltage setpoint (p.u.)')\now.output['res_bus.vm_pu'][net.trafo.at[0, 'lv_bus']].plot(ax=ax, zorder=0, label='Voltage at the controlled bus (p.u.)')\nax.legend(loc='upper center')\n```\n\n----------------------------------------\n\nTITLE: Calculating Voltage Setpoints Using Characteristic\nDESCRIPTION: This snippet demonstrates how to calculate the voltage setpoint for a given active power input using the Characteristic object. It finds the voltage level that corresponds to the specified power flow across the transformer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nc(x=0)\n```\n\n----------------------------------------\n\nTITLE: Creating Overview Plot for pandapower Network\nDESCRIPTION: Defines a function to create an overview plot with three subplots: network topology, Ybus matrix without fused switches, and Ybus matrix with fused switches.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef plot_overview(net):\n    fig, axes = mpl.subplots(1, 3, figsize=(16, 8))\n    pp.runpp(net)\n    plot_net(net, ax=axes[0])\n    # plot y bus with max. const shape (no fused switches)\n    pp.runpp(net, check_connectivity=False, r_switch=0.1, init=\"flat\", neglect_open_switch_branches=True)\n    plot_ybus(net, ax=axes[1])\n    # plot ybus for power flow (with fused switches)\n    pp.runpp(net)\n    plot_ybus(net, ax=axes[2])\n    mpl.show()\n```\n\n----------------------------------------\n\nTITLE: Using SplineCharacteristic for Non-Linear Tap Control\nDESCRIPTION: This code snippet demonstrates the use of a SplineCharacteristic, a non-linear function, to define voltage setpoints for transformer tap control, replacing the piecewise linear characteristic used previously.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\nc2 = SplineCharacteristic(net, [0, 0.3, 0.7, 1], [0.92, 0.95, 1.05, 1.08])\nplot_characteristic(c2,0,1)\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage Switches in Python\nDESCRIPTION: Creates switches for the low voltage network, including bus-line switches and transformer-line switches. Each switch is assigned a name based on the connected elements and a type (load break switch 'LBS').\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nlv_buses\n# Bus-line switches\nlv_ls = net.line[(net.line.from_bus.isin(lv_buses.index)) & (net.line.to_bus.isin(lv_buses.index))]\nfor _, line in lv_ls.iterrows():\n        pp.create_switch(net, line.from_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.from_bus], line['name']))\n        pp.create_switch(net, line.to_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.to_bus], line['name']))\n\n# Trafo-line switches\npp.create_switch(net, pp.get_element_index(net, \"bus\", 'Bus MV4'), pp.get_element_index(net, \"trafo\", 'MV-LV-Trafo'), et='t', closed=True, type='LBS', name='Switch MV4 - MV-LV-Trafo')\npp.create_switch(net, pp.get_element_index(net, \"bus\", 'Bus LV0'), pp.get_element_index(net, \"trafo\", 'MV-LV-Trafo'), et='t', closed=True, type='LBS', name='Switch LV0 - MV-LV-Trafo')\n\n# show only low vvoltage switches\nnet.switch[net.switch.bus.isin(lv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Identifying Connected Components in pandapower (Python)\nDESCRIPTION: Function to find all connected components in an electrical network graph. It is part of the pandapower.topology module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/searches.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\npandapower.topology.connected_components\n```\n\n----------------------------------------\n\nTITLE: Line Power Flow Result Calculations\nDESCRIPTION: Mathematical formulas defining how power flow results are calculated for transmission lines, including power flows, currents and loading percentages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/line.rst#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\np\\_from\\_mw = Re(\\underline{v}_{from} \\cdot \\underline{i}^*_{from})\nq\\_from\\_mvar = Im(\\underline{v}_{from} \\cdot \\underline{i}^*_{from})\np\\_to\\_mw = Re(\\underline{v}_{to} \\cdot \\underline{i}^*_{to})\nq\\_to\\_mvar = Im(\\underline{v}_{to} \\cdot \\underline{i}^*_{to})\npl\\_mw = p\\_from\\_mw + p\\_to\\_mw\nql\\_mvar = q\\_from\\_mvar + q\\_to\\_mvar\ni\\_from\\_ka = i_{from}\ni\\_to\\_ka = i_{to}\ni\\_ka = max(i_{from}, i_{to})\nloading\\_percent = \\frac{i\\_ka}{imax\\_ka \\cdot df \\cdot parallel} \\cdot 100\n```\n\n----------------------------------------\n\nTITLE: Configuring OutputWriter for Pandapower Timeseries Results\nDESCRIPTION: Sets up an OutputWriter to save simulation results to Excel files. Logs bus voltage magnitudes and line loading percentages for each time step. Results are stored in separate files in the current working directory.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/timeseries_example.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# initialising the outputwriter to save data to excel files in the current folder. You can change this to .json, .csv, or .pickle as well\now = OutputWriter(net, output_path=\"./\", output_file_type=\".xlsx\")\n# adding vm_pu of all buses and line_loading in percent of all lines as outputs to be stored\now.log_variable('res_bus', 'vm_pu')\now.log_variable('res_line', 'loading_percent')\n\n# starting the timeseries simulation for one day -> 96 15 min values.\nrun_timeseries(net)\n# now checkout the folders res_bus and res_line in your current working dir\n```\n\n----------------------------------------\n\nTITLE: Implementing DiscreteTapControl with Tap Step Percent in Python\nDESCRIPTION: This snippet implements a DiscreteTapControl using the tap step percent method for the first transformer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ntrafo_controller2 = control.DiscreteTapControl.from_tap_step_percent(\n    net=net, element_index=114, vm_set_pu=1.05, side=\"lv\", tol=1e-3, in_service=True, order=0,\n    drop_same_existing_ctrl=False, matching_params=None)\n```\n\n----------------------------------------\n\nTITLE: Power Mismatch Calculation\nDESCRIPTION: Calculates and verifies the power mismatch distribution among slack elements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/distributed_slack.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\np_dist_slack = (net.res_ext_grid.p_mw.sum() - 0) + (net.res_gen.p_mw.sum() - net.gen.p_mw.sum())\nDelta_p = p_dist_slack * 1/3\nprint(f\"Power mismatch (results):\\t{p_dist_slack:6.2f}\" + \"\\n\" +\n      f\"Adjustment per element:\\t\\t{Delta_p:6.2f}\" + \"\\n\" +\n      f\"Line losses:\\t\\t\\t{net.res_line.pl_mw.sum():6.2f}\")\n```\n\n----------------------------------------\n\nTITLE: Creating Transformer Characteristics Objects in Python\nDESCRIPTION: This snippet uses the Pandapower control module to create a characteristic object for the transformer in the network. It ensures to set parameters such as tap dependency and fills relevant tables based on the transformer configuration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.control.create_trafo_characteristic_object(net)\nnet.trafo.loc[1,\"id_characteristic_table\"] = np.nan\nnet.trafo.loc[1,\"tap_dependency_table\"] = False\nnet.trafo\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage Static Generators in Python\nDESCRIPTION: Imports static generator data from a CSV file and creates static generator objects connected to low voltage buses. Each generator is assigned a name, active power, reactive power, nominal apparent power, and type.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nlv_sgens = pd.read_csv('example_advanced/lv_sgens.csv', sep=';', header=0, decimal=',')\nfor _, sgen in lv_sgens.iterrows():\n    bus_idx = pp.get_element_index(net, \"bus\", sgen.bus)\n    pp.create_sgen(net, bus_idx, p_mw=sgen.p, q_mvar=sgen.q, sn_mva=sgen.sn, type=sgen.type, name=sgen.sgen_name)\n\n# show only low voltage static generators\nnet.sgen[net.sgen.bus.isin(lv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Creating Kerber Suburban Network Type 2 in Python\nDESCRIPTION: Creates another variation of suburban Kerber network (Vorstadtnetz) with slightly different configuration, featuring 144 loads instead of 146 but with similar transformer specifications.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_vorstadtnetz_kabel_2\n\nnet2 = create_kerber_vorstadtnetz_kabel_2()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (144 elements) p_load_in_mw=2,  q_load_in_mw=0\n  - bus (290 elements)\n  - line (288 elements) std_type=\"NAYY 150\", std_type_branchout_line_1=\"NAYY 50\", std_type_branchout_line_2=\"NYY 35\"\n  - trafo (1 elements) \"std_type=0.63 MVA 20/0.4 kV Yyn6 wnr ASEA\"\n  - ext_grid (1 elements)\n'''\n```\n\n----------------------------------------\n\nTITLE: Mathematical Definition of Power Flow Bus Results\nDESCRIPTION: Mathematical formulas defining the bus voltage magnitude, angle, active power, and reactive power results from power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/bus.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\n vm\\_pu &= \\lvert \\underline{V}_{bus} \\rvert \\\\\n va\\_degree &= \\angle \\underline{V}_{bus} \\\\\n p\\_mw &= Re(\\sum_{n=1}^N  \\underline{S}_{bus, n}) \\\\\n q\\_mvar &= Im(\\sum_{n=1}^N  \\underline{S}_{bus, n}) \n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Implementing ContinuousTapControl in Python\nDESCRIPTION: This snippet implements a ContinuousTapControl for the second transformer to achieve an exact output voltage of 0.98 pu.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ntrafo_controller = control.ContinuousTapControl(net=net, element_index=142, vm_set_pu=0.98, tol=1e-6)\n```\n\n----------------------------------------\n\nTITLE: Creating Measurements for State Estimation in pandapower\nDESCRIPTION: This snippet demonstrates how to create various types of measurements for a pandapower network, including voltage, active power, and reactive power measurements for buses and lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npp.create_measurement(net, \"v\", \"bus\", 1.006, .004, bus1)  # V at bus 1\npp.create_measurement(net, \"v\", \"bus\", 0.968, .004, bus2)  # V at bus 2\n\npp.create_measurement(net, \"p\", \"bus\", 501, 10, bus2)     # P at bus 2\npp.create_measurement(net, \"q\", \"bus\", 286, 10, bus2)     # Q at bus 2\n\npp.create_measurement(net, \"p\", \"line\", 888, 8, element=line1, side=\"from\")   # P_line (bus 1 -> bus 2) at bus 1\npp.create_measurement(net, \"p\", \"line\", 1173, 8, element=line2, side=\"from\")  # P_line (bus 1 -> bus 3) at bus 1\n# you can either define the side with a string (\"from\" / \"to\") or\n# using the bus index where the line ends and the measurement is located\npp.create_measurement(net, \"q\", \"line\", 568, 8, element=line1, side=bus1)     # Q_line (bus 1 -> bus 2) at bus 1\npp.create_measurement(net, \"q\", \"line\", 663, 8, element=line2, side=bus1)     # Q_line (bus 1 -> bus 3) at bus 1\n```\n\n----------------------------------------\n\nTITLE: Performing Chi-squared Analysis for Bad Data Detection in pandapower\nDESCRIPTION: This snippet shows how to perform a Chi-squared test to detect the possibility of faulty measurements in the state estimation process.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsuccess_chi2 = chi2_analysis(net, init=\"flat\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Thermal Inertia Effect for Overhead Line in Python\nDESCRIPTION: This code snippet demonstrates the thermal inertia effect by calculating the temperature change over time when the current increases from 250 A to 450 A, starting from a steady-state temperature.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nt_air = 40\nt_max = 90\nt_ref = 20\nr_ref_ohm_per_m = 0.1824e-3\nconductor_outer_diameter_m = 18.2e-3\nv_m_per_s = 0.5\nwind_angle_degree = 45\ns_w_per_square_meter = 1000\nalpha = 0.004\nsolar_absorptivity = emissivity = 0.5\nmc_joule_per_m_k = 525\n\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n```\n\nLANGUAGE: python\nCODE:\n```\nt_start = calc_T_ngoko(250**2, a0, a1, a2, None, None, None)\nt = [calc_T_ngoko(450**2, a0, a1, a2, t_min * 60, t_start, tau) for t_min in range(41)]\n```\n\n----------------------------------------\n\nTITLE: Creating Storage Controller Instance\nDESCRIPTION: Demonstrates how to create and initialize a storage controller instance with a sample network and time series data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/building_a_controller.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# importing a grid from the library\nfrom pandapower.networks import mv_oberrhein\n\n# loading the network with the usecase 'generation'\nnet = mv_oberrhein()\npp.runpp(net)\n\n# creating a simple time series\nframedata = pd.DataFrame([0.1, .05, 0.1, .005, -0.2, 0], columns=['P'])\ndatasource = ts.DFData(framedata)\n\n# creating storage unit in the grid, which will be controlled by our controller\nstore_el = pp.create_storage(net, 30, p_mw = .1, q_mvar = 0, max_e_mwh = 0.1, )\n\n# creating an Object of our new build storage controller, controlling the storage unit\nctrl = Storage(net=net, element_index=store_el, data_source=datasource,p_profile='P')\n```\n\n----------------------------------------\n\nTITLE: Running Asymmetric Power Flow using power-grid-model in Python with pandapower\nDESCRIPTION: This code snippet demonstrates how to use the runpp_pgm() function from pandapower for asymmetric power flow calculations. The symmetric parameter is set to False to enable asymmetric analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/ac_3ph.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.run.runpp_pgm(symmetric=False)\n```\n\n----------------------------------------\n\nTITLE: Performing Topological Analysis with pandapower in Python\nDESCRIPTION: These snippets show how to use pandapower's topology package to analyze network structure, including searching for unsupplied buses and creating a NetworkX graph for custom searches.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.topology as top\ntop.unsupplied_buses(net)\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.switch.closed.at[0] = True\ntop.unsupplied_buses(net)\n```\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, include_trafos=False)\n```\n\nLANGUAGE: python\nCODE:\n```\nlist(top.connected_component(mg, 2))\n```\n\n----------------------------------------\n\nTITLE: Three-Phase Transformer Equations\nDESCRIPTION: Mathematical equations for three-phase transformer calculations, including phase-specific power, current, and reactive power measurements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\np_hv_mw_{phase} &= Re(\\underline{v}_{hv_{phase}} \\cdot \\underline{i}^*_{hv_{phase}}) \\\\\nq_hv_mvar_{phase} &= Im(\\underline{v}_{hv_{phase}} \\cdot \\underline{i}^*_{hv_{phase}}) \\\\\np_lv_mw_{phase} &= Re(\\underline{v}_{lv_{phase}} \\cdot \\underline{i}^*_{lv_{phase}}) \\\\\nq_lv_mvar_{phase} &= Im(\\underline{v}_{lv_{phase}} \\cdot \\underline{i}^*_{lv_{phase}}) \\\\\npl_mw_{phase} &= p_hv_mw_{phase} + p_lv_mw_{phase} \\\\\nql_mvar_{phase} &= q_hv_mvar_{phase} + q_lv_mvar_{phase} \\\\\ni_hv_ka_{phase} &= i_{hv_{phase}} \\\\\ni_lv_ka_{phase}&= i_{lv_{phase}}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Finding Unsupplied Buses in pandapower (Python)\nDESCRIPTION: Function to identify buses in an electrical network that are not supplied with power. It is part of the pandapower.topology module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/searches.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\npandapower.topology.unsupplied_buses\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Path with Weight Parameter\nDESCRIPTION: This example extends the previous search by considering the weight of edges, effectively finding the shortest path based on line length rather than the number of nodes visited.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npath = nx.shortest_path(mg, 0, 5, weight=\"weight\")\npath\n```\n\n----------------------------------------\n\nTITLE: Setting Bus Zones by Boundary Branches\nDESCRIPTION: Defines grid zones based on boundary branches and retrieves boundary information\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nboundary_branches = {\"line\": [2, 7]}\npp.grid_equivalents.set_bus_zone_by_boundary_branches(net, boundary_branches)\nbuses, branches = pp.grid_equivalents.get_boundaries_by_bus_zone_with_boundary_branches(net)\n```\n\n----------------------------------------\n\nTITLE: Checking Controller Registration in Python\nDESCRIPTION: This snippet shows how to check if the controller has been registered in the network's controller table.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.controller\n```\n\n----------------------------------------\n\nTITLE: Converting pandapower Network to NetworkX MultiGraph\nDESCRIPTION: The following code converts a pandapower network into a NetworkX MultiGraph, allowing for the use of NetworkX algorithms on the network structure.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.topology as top\nmg = top.create_nxgraph(net) # converts example network into a MultiGraph\n```\n\n----------------------------------------\n\nTITLE: Creating Bus-Line Switches for Medium Voltage Network in Python\nDESCRIPTION: Creates switches connecting buses to lines in the medium voltage network. Switches are created at both ends of each line, with one specific switch set to open state.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n# Bus-line switches\nmv_buses = net.bus[(net.bus.vn_kv == 10) | (net.bus.vn_kv == 20)].index\nmv_ls = net.line[(net.line.from_bus.isin(mv_buses)) & (net.line.to_bus.isin(mv_buses))]\nfor _, line in mv_ls.iterrows():\n        pp.create_switch(net, line.from_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.from_bus], line['name']))\n        pp.create_switch(net, line.to_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.to_bus], line['name']))\n\n# open switch\nopen_switch_id = net.switch[(net.switch.name == 'Switch Bus MV5 - MV Line5')].index\nnet.switch.closed.loc[open_switch_id] = False\n\n#show only medium voltage switch table\nnet.switch[net.switch.bus.isin(mv_buses)]\n```\n\n----------------------------------------\n\nTITLE: Adding Transformer Connections to the Network in Python\nDESCRIPTION: This function adds transformer connections to the specified network. It takes parameters such as the network object, high voltage bus, and element type, allowing for both standard and three-winding transformers to be created with specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef add_trafo_connection(net, hv_bus, element_type=\"trafo\"):\n    cb = pp.create_bus(net, vn_kv=0.4)\n    pp.create_load(net, cb, 0.2, 0.05)\n    \n    if element_type==\"trafo3w\":\n        cbm = pp.create_bus(net, vn_kv=0.9)\n        pp.create_load(net, cbm, 0.1, 0.03)\n        pp.create_transformer3w_from_parameters(net, hv_bus=hv_bus, mv_bus=cbm, lv_bus=cb, \n                                                vn_hv_kv=20., vn_mv_kv=0.9, vn_lv_kv=0.45, sn_hv_mva=0.6, \n                                                sn_mv_mva=0.5, sn_lv_mva=0.4, vk_hv_percent=1., \n                                                vk_mv_percent=1., vk_lv_percent=1., vkr_hv_percent=0.3, \n                                                vkr_mv_percent=0.3, vkr_lv_percent=0.3, pfe_kw=0.2, \n                                                i0_percent=0.3, tap_neutral=0., tap_pos=2, tap_changer_type=\"Ratio\",\n                                                tap_step_percent=1., tap_min=-2, tap_max=2)\n    else:\n        pp.create_transformer(net, hv_bus=hv_bus, lv_bus=cb, std_type=\"0.25 MVA 20/0.4 kV\", tap_pos=2)\n```\n\n----------------------------------------\n\nTITLE: Importing Required PandaPower Libraries\nDESCRIPTION: Sets up necessary imports for time series analysis including controllers, data sources and output writers. Includes random seed initialization for reproducibility.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport numpy as np\nimport pandas as pd\nimport tempfile\nimport random\nimport pandapower as pp\nfrom pandapower.control import ConstControl\nfrom pandapower.timeseries import DFData\nfrom pandapower.timeseries import OutputWriter\nfrom pandapower.timeseries.run_time_series import run_timeseries\nrandom.seed(10)\n```\n\n----------------------------------------\n\nTITLE: Creating Three Phase Wye Load\nDESCRIPTION: Creates an asymmetric wye-connected three phase load with specified power values for each phase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npp.create_asymmetric_load(net, bus_load, p_a_mw=0.0300, q_a_mvar=0.0048, p_b_mw=0.0280, q_b_mvar=0.0036,\n                               p_c_mw=0.027, q_c_mvar=0.0043,type='wye')\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage Loads in Python\nDESCRIPTION: Imports load data from a CSV file and creates load objects connected to low voltage buses. Each load is assigned a name, active power (p_mw), and reactive power (q_mvar).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nlv_loads = pd.read_csv('example_advanced/lv_loads.csv', sep=';', header=0, decimal=',')\nfor _, load in lv_loads.iterrows():\n    bus_idx = pp.get_element_index(net, \"bus\", load.bus)\n    pp.create_load(net, bus_idx, p_mw=load.p, q_mvar=load.q, name=load.load_name)\n    \n# show only low voltage loads\nnet.load[net.load.bus.isin(lv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Creating Meshed Network with Fuses for Overload Protection\nDESCRIPTION: Creates a more complex meshed network with multiple buses, lines and fuses to demonstrate overload protection scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef fuse_example_net2():\n    net = pp.create_empty_network()\n\n    # create buses\n    pp.create_buses(net, nr_buses=9, vn_kv=[20, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4, 0.4],\n                    index=[0, 1, 2, 3, 4, 5, 6, 7, 8], name=None, type=\"n\",\n                    geodata=[(0, 0), (0, -2), (-2, -4), (-2, -6), (-2, -8), (2, -4), (2, -6), (2, -8), (2, -10)])\n\n    # create external grid\n    pp.create_ext_grid(net, 0, vm_pu=1.0, va_degree=0, s_sc_max_mva=500, s_sc_min_mva=80, rx_max=0.1, rx_min=0.1)\n\n    # create lines\n    pp.create_lines(net, from_buses=[1, 2, 3, 1, 5, 6, 7, 6], to_buses=[2, 3, 4, 5, 6, 7, 8, 4],\n                    length_km=[0.2, 0.2, 0.2, 0.1, 0.1, 0.1, 0.1, 0.1], std_type=\"94-AL1/15-ST1A 0.4\")\n\n    net.line[\"endtemp_degree\"] = 250\n\n    # create transformer\n    pp.create_transformer(net, hv_bus=0, lv_bus=1, std_type=\"0.25 MVA 20/0.4 kV\")\n\n    # define trafo fuses\n    pp.create_switches(net, buses=[0, 1], elements=[0, 0], et='t', type=\"fuse\")\n\n    # define line fuses\n    pp.create_switches(net, buses=[1, 2, 3, 1, 5, 6, 7], elements=[0, 1, 2, 3, 4, 5, 6], et='l', type=\"fuse\")\n\n    # define disconnecting switch\n    pp.create_switch(net, bus=6, element=7, et='l', type=\"DS\", closed=False)\n\n    # define load\n    pp.create_loads(net, buses=[3, 4], p_mw=[0.1, 0.05], q_mvar=0, const_z_percent=0, const_i_percent=0, name=None,\n                    index=[0, 1])\n\n    return net\n\nnet = fuse_example_net2()\nnet\n```\n\n----------------------------------------\n\nTITLE: Calculating Distance to Bus in pandapower (Python)\nDESCRIPTION: Function to calculate the distance between buses in an electrical network. It is part of the pandapower.topology module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/searches.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npandapower.topology.calc_distance_to_bus\n```\n\n----------------------------------------\n\nTITLE: Calculating Voltage Limits for Tap Step Percent Control in Python\nDESCRIPTION: This code calculates the voltage limits for the tap step percent control method.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nvm_delta_pu = net.trafo.at[142, \"tap_step_percent\"] / 100. * .5\nvm_lower_pu = 1.05 - vm_delta_pu\nvm_upper_pu = 1.05 + vm_delta_pu\nprint(vm_delta_pu,vm_lower_pu,vm_upper_pu)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Representation of External Grid Result Parameters\nDESCRIPTION: Mathematical formulation of the active and reactive power feed-in or consumption at the slack node, which are key results of the power flow calculation for external grids.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ext_grid.rst#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\n    p\\_mw &= P_{eg} \\\\\n    q\\_mvar &= Q_{eg}\n    \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Plotting Converted pandapower Network with Result Visualization\nDESCRIPTION: This snippet demonstrates how to plot the converted pandapower network and visualize the results. It creates collections for buses, lines, and transformers, and draws them using pandapower's plotting functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/cim2pp.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plt\nimport pandapower.plotting.colormaps as cmaps\n\ncmap_list = [(0.9, \"blue\"), (1.0, \"green\"), (1.1, \"red\")]\ncmap, norm = cmaps.cmap_continuous(cmap_list)\n\nsizes = plt.get_collection_sizes(net)\n\nbc = plt.create_bus_collection(net,net.bus.index.values,cmap=cmap, size=sizes['bus'])\nlc = plt.create_line_collection(net,net.line.index.values, use_bus_geodata=True)\ntc = plt.create_trafo_collection(net,net.trafo.index.values, size=sizes[\"trafo\"])\nplt.draw_collections([bc,lc,tc])\n```\n\n----------------------------------------\n\nTITLE: Defining Transformer Parameters for Unbalanced Calculations in Pandapower\nDESCRIPTION: Creates a transformer with specific parameters essential for performing unbalanced power flow calculations. Dependencies include transformer parameter documentation from Pandapower for parameter details.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.create_transformer_from_parameters(net, b1, b2, sn_mva=0.63,\n                                      vn_hv_kv=20., vn_lv_kv=0.4,\n                                      vkr_percent=0.1, vk_percent=6,\n                                      vk0_percent=6, vkr0_percent=0.78125,\n                                      mag0_percent=100, mag0_rx=0.,\n                                      pfe_kw=0.1, i0_percent=0.1,\n                                      vector_group=\"Dyn\", shift_degree=150,\n                                      si0_hv_partial=0.9)\n```\n\n----------------------------------------\n\nTITLE: Importing Necessary Libraries for Pandapower Functions in Python\nDESCRIPTION: This snippet imports essential libraries such as NumPy, Pandas, and Pandapower to facilitate the creation and manipulation of networks and data structures relevant to electrical power systems.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nimport pandapower as pp\nimport pandapower.control\nimport json\n```\n\n----------------------------------------\n\nTITLE: Customizing Graph Conversion with respect_switches Parameter\nDESCRIPTION: This snippet illustrates how to create a MultiGraph without considering switches, which is useful for finding paths that include open switches in the pandapower network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, respect_switches=False)\n```\n\n----------------------------------------\n\nTITLE: Setting Line Loading Constraints\nDESCRIPTION: This snippet shows how to set maximum loading constraints on lines and run the OPF with these constraints.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet.line[\"max_loading_percent\"] = 50\npp.runopp(net, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Plotting IEEE European LV Network Components\nDESCRIPTION: Creates a comprehensive visualization of the network including buses, transformers, lines, external grid, and loads with different phase configurations. Highlights maximum loaded line and maximum unbalanced node.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_asymmetric.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plot\nimport numpy as np\ntry:\n    import seaborn\n    colors = seaborn.color_palette()\nexcept:\n    colors = [\"b\", \"g\", \"r\", \"c\", \"y\"]\n%matplotlib inline\n\nsizes = plot.get_collection_sizes(net)\n\n# Plot all the buses\nbc = plot.create_bus_collection(net, net.bus.index, size=sizes['bus'], color=colors[0], zorder=10)\n\n#Plot Transformers\ntlc, tpc = plot.create_trafo_collection(net, net.trafo.index, color=\"g\", size=sizes['trafo'])\n\n# Plot all the lines\nlcd = plot.create_line_collection(net, net.line.index, color=\"grey\", linewidths=0.1, use_bus_geodata=True)\n\n# Plot the external grid\nsc = plot.create_ext_grid_collection(net, ext_grid_buses=net.ext_grid.bus.values, size=sizes['ext_grid'], color=\"c\", zorder=11)\n\n#Plot all the loads\nldA = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_a_mw >0)], patch_type=\"poly3\", size=sizes['bus'], color=\"r\", zorder=11)\nldB = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_b_mw >0)], patch_type=\"rect\", size=sizes['bus'], color=\"y\", zorder=11)\nldC = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_c_mw >0)], patch_type=\"circle\", size=sizes['bus'], color=\"b\", zorder=11)\n\n# Plot the max. loaded line and max. unbalanced node\nmax_load = plot.create_line_collection(net, np.array([net.res_line_3ph.loading_percent.idxmax()]), color=\"black\", linewidths=15, use_bus_geodata=True)\nmax_unbal = plot.create_bus_collection(net, np.array([net.res_bus_3ph.unbalance_percent.idxmax()]), patch_type=\"rect\", size=sizes['bus'], color=\"black\", zorder=11)\n\n# Draw all the collected plots\nplot.draw_collections([lcd, bc, tlc, tpc, sc,ldA,ldB,ldC,max_load,max_unbal], figsize=(20,20))\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Connected Components\nDESCRIPTION: This snippet shows how to find all connected components in the graph, optionally utilizing nogobuses and notravbuses to control the traversal behavior.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, nogobuses={0, 1})\nfor area in top.connected_components(mg):\n    print(area)\n```\n\n----------------------------------------\n\nTITLE: Configuring Network Controllers\nDESCRIPTION: Sets up constant controllers for load and generation elements, mapping them to their respective profiles.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef create_controllers(net, ds):\n    ConstControl(net, element='load', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"load1_p\"])\n    ConstControl(net, element='sgen', variable='p_mw', element_index=[0],\n                 data_source=ds, profile_name=[\"sgen1_p\"])\n    return net\n```\n\n----------------------------------------\n\nTITLE: Merging Bus Name and Voltage Data in Pandas\nDESCRIPTION: This code snippet runs a load flow calculation on a network and merges the bus name with its corresponding voltage into a single dataframe. It requires the Pandapower library and assumes that a network object, 'net', has been previously defined. The output displays the first 8 entries of the merged dataframe showing bus names and voltages.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnet = nw.mv_oberrhein()\npp.runpp(net) #Run a load flow calculation to get result tables\n\n#Store bus name with bus voltage result of loadflow calculation in bus_results\n#axis={horizontal=0, vertical=1}: axis to concatenate along\nbus_results = pd.concat([net.bus.name, net.res_bus.vm_pu], axis=1)\n\n#Output\nbus_results.head(n=8)\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature for Different Solar Radiation Levels in Python\nDESCRIPTION: This set of code snippets calculates the overhead line temperature for three different solar radiation scenarios (0 W/m², 500 W/m², and 1000 W/m²) using the calc_a0_a1_a2_tau and calc_T_ngoko functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 0.5\nwind_angle_degree = 45\ns_w_per_square_meter = 0\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_0 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\ns_w_per_square_meter = 500\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_500 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\ns_w_per_square_meter = 1000\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_1000 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\n----------------------------------------\n\nTITLE: Plotting Thermal Inertia Effect for Overhead Line in Python\nDESCRIPTION: This code snippet creates a plot using matplotlib to visualize the thermal inertia effect, showing how the line temperature changes over time after a current increase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nax=plt.subplot()\nax.plot(t)\nax.grid(True)\nax.set_ylim([55, 85])\nax.set_ylabel('Line temperature (C)')\nax.set_xlabel('Time delay (min)');\n```\n\n----------------------------------------\n\nTITLE: Plotting Results of lightsim2grid-based Contingency Analysis in pandapower\nDESCRIPTION: This code snippet calls the previously defined plot_results_boxplots function to visualize the results of the lightsim2grid-based contingency analysis, showing the differences in results compared to the standard pandapower implementation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nplot_results_boxplots()\n```\n\n----------------------------------------\n\nTITLE: Example pandapower function implementation\nDESCRIPTION: An example of a new function that doubles the rated power of a grid. This demonstrates how to write a simple utility function for pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef double_rated_power(net):\n   net.sn_kva *= 2\n```\n\n----------------------------------------\n\nTITLE: Mathematical Representation of External Grid for Balanced Load Flow\nDESCRIPTION: Mathematical formulas representing the voltage source model of the external grid in balanced load flow calculations. The external grid acts as a slack node with voltage magnitude and angle parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ext_grid.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\n    \\underline{v}_{bus} &= vm\\_pu \\cdot e^{j \\cdot \\theta} \\\\\n   \\theta &= shift\\_degree \\cdot \\frac{\\pi}{180}\n   \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Configuring Output Writer for Pandapower Time Series\nDESCRIPTION: This function configures an OutputWriter to save predefined simulation results to the filesystem in Excel format. It logs various network variables such as sgen power, bus voltages, and line loadings, ensuring that only essential data is saved, minimizing storage load.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef create_output_writer(net, time_steps, output_dir):\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".xlsx\", log_variables=list())\n    ow.log_variable('res_sgen', 'p_mw')\n    ow.log_variable('res_bus', 'vm_pu')\n    ow.log_variable('res_line', 'loading_percent')\n    ow.log_variable('res_line', 'i_ka')\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Importing Essential Libraries for Pandapower Simulation\nDESCRIPTION: This code snippet imports the necessary libraries and modules for running a time series simulation with pandapower. Dependencies include pandapower for network analysis, numpy and pandas for data manipulation, and matplotlib for visualization. Pandapower modules such as DFData, OutputWriter, and run_timeseries are specifically included for time series analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport pandapower as pp\nimport numpy as np\nimport os\nimport pandas as pd\nimport tempfile\nfrom pandapower.timeseries import DFData\nfrom pandapower.timeseries import OutputWriter\nfrom pandapower.timeseries.run_time_series import run_timeseries\nfrom pandapower.control import ConstControl\nimport matplotlib.pyplot as plt\n%matplotlib inline\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature for Different Wind Angles in Python\nDESCRIPTION: This set of code snippets calculates the overhead line temperature for three different wind angle scenarios (0°, 45°, and 90°) using the calc_a0_a1_a2_tau and calc_T_ngoko functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 0.5\nwind_angle_degree = 0\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_0 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nwind_angle_degree = 45\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_45 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nwind_angle_degree = 90\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_90 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\n----------------------------------------\n\nTITLE: Visualizing Storage Controller Results\nDESCRIPTION: Code for plotting the state of charge results from the time series simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/building_a_controller.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# plotting the state of charge\now.output['storage.soc_percent'].columns = ['Battery']\nax = ow.output['storage.soc_percent'].plot()\nax.set_xlabel('Time in 15min Steps')\nax.set_ylabel('State of Charge in %')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Creating Polynomial Cost Functions for Minimizing Generation in pandapower OPF\nDESCRIPTION: Creates polynomial cost functions to minimize generator and static generator feed-in by assigning a positive linear cost coefficient, making higher power output more expensive.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/formulation.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 0, 'sgen', cp1_eur_per_mw=1)\npp.create_poly_cost(net, 0, 'gen', cp1_eur_per_mw=1)\npp.create_pwl_cost(net, 0, \"sgen\", [[net.sgen.min_p_mw.at[0], net.sgen.max_p_mw.at[0], 1]])\npp.create_pwl_cost(net, 0, \"gen\", [[net.gen.min_p_mw.at[0], net.gen.max_p_mw.at[0], 1]])\n```\n\n----------------------------------------\n\nTITLE: Creating and Running IEEE Case9 Grid Model\nDESCRIPTION: Instantiates the IEEE case9 grid model and runs power flow calculation\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.networks.case9()\nnet.sn_mva = 1.0\npp.runpp(net)\nnet\n```\n\n----------------------------------------\n\nTITLE: Creating High Voltage Switches in PandaPower Network\nDESCRIPTION: Creates switches to connect buses in the transformer station. Loads switch configuration from a CSV file and creates bus-bus, bus-line, and trafo-line switches.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nhv_bus_sw = pd.read_csv('example_advanced/hv_bus_sw.csv', sep=';', header=0, decimal=',')\nhv_bus_sw\n```\n\nLANGUAGE: python\nCODE:\n```\n# Bus-bus switches\nfor _, switch in hv_bus_sw.iterrows():\n    from_bus = pp.get_element_index(net, \"bus\", switch.from_bus)\n    to_bus = pp.get_element_index(net, \"bus\", switch.to_bus)\n    pp.create_switch(net, from_bus, to_bus, et=switch.et, closed=switch.closed, type=switch.type, name=switch.bus_name)\n\n# Bus-line switches\nhv_buses = net.bus[(net.bus.vn_kv == 380) | (net.bus.vn_kv == 110)].index\nhv_ls = net.line[(net.line.from_bus.isin(hv_buses)) & (net.line.to_bus.isin(hv_buses))]\nfor _, line in hv_ls.iterrows():\n        pp.create_switch(net, line.from_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.from_bus], line['name']))\n        pp.create_switch(net, line.to_bus, line.name, et='l', closed=True, type='LBS', name='Switch %s - %s' % (net.bus.name.at[line.to_bus], line['name']))\n\n# Trafo-line switches\npp.create_switch(net, pp.get_element_index(net, \"bus\", 'Bus DB 2'), pp.get_element_index(net, \"trafo\", 'EHV-HV-Trafo'), et='t', closed=True, type='LBS', name='Switch DB2 - EHV-HV-Trafo')\npp.create_switch(net, pp.get_element_index(net, \"bus\", 'Bus SB 1'), pp.get_element_index(net, \"trafo\", 'EHV-HV-Trafo'), et='t', closed=True, type='LBS', name='Switch SB1 - EHV-HV-Trafo')\n\n# show switch table\nnet.switch\n```\n\n----------------------------------------\n\nTITLE: Using Custom Standard Type\nDESCRIPTION: Demonstrates how to use a newly created custom standard type to create a line.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nb1 = pp.create_bus(net, vn_kv=.4)\nb2 = pp.create_bus(net, vn_kv=.4)\nlid = pp.create_line(net, from_bus=b1, to_bus=b2, length_km=0.1, std_type=\"test_type\", name=\"test_line\")\nprint(net.line.loc[lid])\n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series Results\nDESCRIPTION: Visualizes the results of the time series analysis by plotting voltage magnitudes and real power values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n%matplotlib inline  \n\n# voltage results\nvm_pu_file = os.path.join(output_dir, \"res_bus\", \"vm_pu.xlsx\")\nvm_pu = pd.read_excel(vm_pu_file, index_col=0)\nvm_pu.plot(label=\"vm_pu\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"voltage mag. [p.u.]\")\nplt.title(\"Voltage Magnitude\")\nplt.grid()\nplt.show()\n\n\n# p_mw results\np_mw_file = os.path.join(output_dir, \"res_bus\", \"p_mw.xlsx\")\np_mw = pd.read_excel(p_mw_file, index_col=0)\np_mw.plot(label=\"p_mw\")\nplt.xlabel(\"time step\")\nplt.ylabel(\"P [MW]\")\nplt.title(\"Real Power at Buses\")\nplt.grid()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Re-running Diagnostic and Load Flow After Fixes\nDESCRIPTION: These snippets show how to re-run the diagnostic function and load flow calculation after applying fixes to verify that all issues have been resolved.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# new diagnosis to check, whether we fixed all errors\npp.diagnostic(faulty_net)\n```\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(faulty_net)\nfaulty_net\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple Medium Voltage Open Ring Network in pandapower\nDESCRIPTION: This snippet shows how to import the pandapower networks module and create a simple medium voltage open ring network. This network is used as the basis for topological analyses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.networks as nw\nnet = nw.simple_mv_open_ring_net()\n```\n\n----------------------------------------\n\nTITLE: Calculating Short Circuit and Protection Times\nDESCRIPTION: Performs short circuit calculations at a specific bus and calculates protection device activation times for the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.shortcircuit as sc\nsc.calc_sc(net, bus=3, branch_results=True)\n\nfrom pandapower.protection.run_protection import calculate_protection_times\nprotection_results = calculate_protection_times(net)\nprotection_results\n```\n\n----------------------------------------\n\nTITLE: Example test function for pandapower\nDESCRIPTION: An example test function that verifies the behavior of the double_rated_power function. This demonstrates how to write tests for new pandapower functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef test_double_rated_power():\n   init_sn_kva = 100\n   net = pp.create_empty_network(sn_kva=init_sn_kva)\n   assert net.sn_kva == init_sn_kva\n   pp.double_rated_power(net)\n   assert net.sn_kva == init_sn_kva*2\n```\n\n----------------------------------------\n\nTITLE: Mathematical Model for Motor Power Calculations in pandapower\nDESCRIPTION: Mathematical equations describing how motor power values are calculated in pandapower. The equations define the relationship between nominal motor power, efficiency, loading percentage, scaling factor, power factor, apparent power, and reactive power.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/motor.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nP_{motor, n} =& pn\\_mech\\_mw / (efficiency\\_percent/100) \\\\\nP_{motor} =& P_{motor, n} * (loading\\_percent / 100) * scaling \\\\\nS_{motor} =& P_{motor} / cos\\_phi \\\\\nQ_{motor} =& \\sqrt{S_{motor}^2 - P_{motor}^2} \n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Verifying Results of the Power Flow Analysis in Python\nDESCRIPTION: This snippet retrieves the results for specific buses post power flow computation to verify the adjusted voltage values, facilitating the assessment of the network's performance after configuration changes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus.loc[[2,3]]\n```\n\n----------------------------------------\n\nTITLE: Loading Time Series Data using Pandas\nDESCRIPTION: This code snippet loads time series data from a JSON file using the pandas library. It reads the data, sorts it by index, and prepares it for use in subsequent time series optimizations. It also sets load and sgen types.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\n\n# load time series data for 96 time steps\ntime_series = pd.read_json(\"cigre_timeseries_15min.json\")\ntime_series.sort_index(inplace=True)\n\n# show time series\ndisplay(time_series) \n\n# set load type and sgen type in the cigre grid\nnet[\"load\"].loc[:, \"type\"] = \"residential\"\nnet.sgen.loc[:, \"type\"] = \"pv\"\nnet.sgen.loc[8, \"type\"] = \"wind\"\n\n# get rated power\nload_p = net[\"load\"].loc[:, \"p_mw\"].values\nsgen_p = net[\"sgen\"].loc[:7, \"p_mw\"].values\nwind_p = net[\"sgen\"].loc[8, \"p_mw\"]\n\n# create dataframe for loads and sgens\nload_ts = pd.DataFrame(index=time_series.index.tolist(), columns=net.load.index.tolist())\nsgen_ts = pd.DataFrame(index=time_series.index.tolist(), columns=net.sgen.index.tolist())\nfor t in range(96):\n    load_ts.loc[t] = load_p * time_series.at[t, \"residential\"]\n    sgen_ts.loc[t][:8] = sgen_p * time_series.at[t, \"pv\"]\n    sgen_ts.loc[t][8] = wind_p * time_series.at[t, \"wind\"]\n```\n\n----------------------------------------\n\nTITLE: Power Flow Results Visualization on Map with Pandapower and Plotly\nDESCRIPTION: Demonstrates how to plot power flow results on a map using pf_res_plotly(). This example uses the mv_oberrhein network, specifies a projection, and sets a dark map style.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/built-in_plots.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet = mv_oberrhein()\npf_res_plotly(net, on_map=True, projection='epsg:31467', map_style='dark')\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Pandapower Short Circuit Analysis\nDESCRIPTION: This snippet imports necessary libraries for data manipulation, plotting, and short circuit calculations in pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_1ph_vector_group_trafo3w.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\npd.options.display.float_format = '{:,.5f}'.format\nimport igraph\nfrom pandapower.plotting import simple_plot\nfrom pandapower.shortcircuit.calc_sc import calc_sc\n```\n\n----------------------------------------\n\nTITLE: Zero Sequence Parameters Configuration\nDESCRIPTION: Sets up zero sequence parameters for single phase short-circuit calculation, including ground fault parameters for external grid, lines, and transformer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet = ring_network()\n\n#r/x ratio in zero sequence parameters\nnet.ext_grid[\"r0x0_max\"] = 0.4\nnet.ext_grid[\"x0x_max\"] = 1.0\n\n#zero sequence line parameters\nnet.line[\"r0_ohm_per_km\"] = 0.244\nnet.line[\"x0_ohm_per_km\"] = 0.336\nnet.line[\"c0_nf_per_km\"] = 2000\n\n#transformer vector group, zero sequence short circuit voltage\n#and zero sequence magnetizing impedance\nnet.trafo[\"vector_group\"] = \"Dyn\"\nnet.trafo[\"vk0_percent\"] = 5.\nnet.trafo[\"vkr0_percent\"] = 0.4\nnet.trafo[\"mag0_percent\"] = 10\nnet.trafo[\"mag0_rx\"] = 0.4\nnet.trafo[\"si0_hv_partial\"] = 0.9\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Kerber Village Network Type II in Python\nDESCRIPTION: Creates an extreme village Kerber network (Dorfnetz) with both extreme line parameters and high loaded transformer. This Type II network represents a challenging edge case for testing network functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_dorfnetz_trafo\n\n'''Extrem Dorfnetz Kabel Typ II'''\nnet = kb_extrem_dorfnetz_trafo()\n```\n\n----------------------------------------\n\nTITLE: Plotting Three-Phase Voltage Magnitude Time-Series in Python using matplotlib\nDESCRIPTION: Creates a line plot to visualize three-phase voltage magnitudes (VA, VB, VC) over time from pandapower simulation results. The plot is configured with appropriate axis labels, a title, and visualization parameters including color coding for each phase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nfig,ax1 = plt.subplots(1,1)\ndf_pp_v.plot(kind='line', y=['VA','VB','VC'], ax=ax1, color=['blue','orange','green'],figsize=(10,5),legend = True)\nax1.set_ylim((235,255))\nax1.xaxis.set_label_text(\"time step\")\nax1.yaxis.set_label_text(\"voltage mag. [Volts]\")\nax1.set_title(\"Load Voltages (pandapower) / V\")\n```\n\n----------------------------------------\n\nTITLE: Single Slack Bus Power Flow Example\nDESCRIPTION: Demonstrates power flow calculation with distributed slack using only the external grid as slack bus.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/distributed_slack.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndisplay(Markdown(\"#### Without distributed slack\"))\npp.runpp(net)\n\nprint_powers(net)\n\ndisplay(Markdown(\"#### With distributed slack\"))\n# set slack_weight of the relevant elements\nnet.ext_grid['slack_weight'] = 1\nnet.gen['slack_weight'] = 0\n\npp.runpp(net, distributed_slack=True)\n\nprint_powers(net)\n```\n\n----------------------------------------\n\nTITLE: Creating Three Bus System with External Grid\nDESCRIPTION: Initializes a three-bus system with external grid connection.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.create_empty_network(sn_mva=100)\n\nbus_eg = pp.create_bus(net, 10)\nbus_lv = pp.create_bus(net, 0.4)\nbus_load = pp.create_bus(net, 0.4 )\n\npp.create_ext_grid(net, bus_eg, s_sc_max_mva=10000, rx_max=0.1)\nnet.ext_grid[\"r0x0_max\"] = 0.1\nnet.ext_grid[\"x0x_max\"] = 1.0\nprint(net.trafo)\nprint('-----------------------------------')\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit Current for Wind Power Station with Asynchronous Generator\nDESCRIPTION: This code calculates the initial symmetrical short-circuit current and peak short-circuit current for a wind power station with an asynchronous generator.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nikss_ka = 1.1 * 0.4 / (np.sqrt(3) * Z_G)\nikss_ka\n```\n\nLANGUAGE: python\nCODE:\n```\n# skss\nikss_ka * 0.4 * np.sqrt(3)\n```\n\nLANGUAGE: python\nCODE:\n```\nikss_block_ka = 1.1 * 20 / (np.sqrt(3) * abs(Z_WA_complex))\nikss_block_ka\n```\n\nLANGUAGE: python\nCODE:\n```\n# skss\nikss_block_ka * 20 * np.sqrt(3)\n```\n\nLANGUAGE: python\nCODE:\n```\n# ip_ka = ikss_ka * kappa * sqrt(2)\nkappa = 1.02 + 0.98 * np.exp(-3*0.1)\nikss_ka * kappa * np.sqrt(2)\n```\n\nLANGUAGE: python\nCODE:\n```\nkappa_block = 1.02 + 0.98 * np.exp(-3 * Z_WA_complex.real / Z_WA_complex.imag)\nikss_block_ka * kappa_block * np.sqrt(2)\n```\n\n----------------------------------------\n\nTITLE: Transformer Loss Optimization\nDESCRIPTION: Reconfigures the optimization target to focus on transformer losses instead of line losses, demonstrating how to switch optimization objectives.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nnet_loss.line.drop(columns=[\"pm_param/target_branch\"], inplace=True)\nnet_loss.trafo[\"pm_param/target_branch\"] = True\npp.runpm_ploss(net_loss)\nprint(\"loss without optimization:\", net.res_trafo.pl_mw.values.sum())\nprint(\"loss with optimization:\", net_loss.res_trafo.pl_mw.values.sum())\n```\n\n----------------------------------------\n\nTITLE: Converting Time Series to pandapower Controllers in Python\nDESCRIPTION: This snippet loads an input time series from a JSON file, scales it for power distributions, and creates controllers for both load and generation components in the pandapower model. It assumes a specific structure of the input time series and adjusts controller settings accordingly.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_storage.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandas as pd\nfrom pandapower.control import ConstControl\nfrom pandapower.timeseries import DFData\n\ndef convert_timeseries_to_controller(net, input_file):\n    \n    # set the load type in the cigre grid, since it is not specified\n    net[\"load\"].loc[:, \"type\"] = \"residential\"\n    \n    # set the sgen type in the cigre grid\n    net.sgen.loc[:, \"type\"] = \"pv\"\n    net.sgen.loc[8, \"type\"] = \"wind\"\n\n    # read the example time series\n    time_series = pd.read_json(input_file)\n    time_series.sort_index(inplace=True)\n\n    # this example time series has a 15min resolution with 96 time steps for one day\n    n_timesteps = time_series.shape[0]\n    \n    # get rated power\n    load_p = net[\"load\"].loc[:, \"p_mw\"].values\n    sgen_p = net[\"sgen\"].loc[:7, \"p_mw\"].values\n    wind_p = net[\"sgen\"].loc[8, \"p_mw\"]\n\n    load_ts = pd.DataFrame(index=time_series.index.tolist(), columns=net.load.index.tolist())\n    sgen_ts = pd.DataFrame(index=time_series.index.tolist(), columns=net.sgen.index.tolist())\n    for t in range(n_timesteps):\n        load_ts.loc[t] = load_p * time_series.at[t, \"residential\"]\n        sgen_ts.loc[t][:8] = sgen_p * time_series.at[t, \"pv\"]\n        sgen_ts.loc[t][8] = wind_p * time_series.at[t, \"wind\"]\n\n    # create time series controller for load and sgen \n    ConstControl(net, element=\"load\", variable=\"p_mw\",\n                 element_index=net.load.index.tolist(), profile_name=net.load.index.tolist(),\n                 data_source=DFData(load_ts))\n    ConstControl(net, element=\"sgen\", variable=\"p_mw\",\n                 element_index=net.sgen.index.tolist(), profile_name=net.sgen.index.tolist(),\n                 data_source=DFData(sgen_ts))\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Short Circuit and Protection Times for DTOC Relays in Python\nDESCRIPTION: This code creates a short circuit scenario, calculates the short circuit, and determines the protection times for DTOC relays in a Pandapower network. It uses the create_sc_bus, calc_sc, and calculate_protection_times functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/oc_relay.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.protection.utility_functions import create_sc_bus\nimport pandapower.shortcircuit as sc\nfrom pandapower.protection.run_protection import calculate_protection_times\n\n# calculate the short circuit\nnet_sc = create_sc_bus(net, sc_line_id=4, sc_fraction=0.5)\nsc.calc_sc(net_sc, bus=max(net_sc.bus.index), branch_results=True)\n\n# calculate the protection times\nprotection_results = calculate_protection_times(net_sc, scenario='sc')\n\n# show protection_results\nprotection_results\n```\n\n----------------------------------------\n\nTITLE: Implementing DataFrame Data Source (DFData) in Python for pandapower\nDESCRIPTION: The DFData class inherits from DataSource and uses a DataFrame to store time series values. It extends the functionality of DataSource for handling structured data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/data_source.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass DFData(DataSource):\n    # Implementation details not shown\n```\n\n----------------------------------------\n\nTITLE: Impedance Per Unit Transformation Equations\nDESCRIPTION: Mathematical formulas showing how impedance values are transformed into the network per unit system based on reference power and nominal values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/impedance.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{z}_{ft} &= (rft\\_pu + j \\cdot xft\\_pu) \\cdot \\frac{S_{N}}{sn\\_mva} \\\\\n\\underline{z}_{tf} &= (rft\\_pu + j \\cdot xtf\\_pu) \\cdot \\frac{S_{N}}{sn\\_mva} \\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Configuring External Grid with Short-Circuit Parameters in Pandapower\nDESCRIPTION: Defines an external grid connection with short-circuit parameters and zero-sequence impedances in the network. It requires grid parameters found in Pandapower's ext_grid documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.create_ext_grid(net, b1, s_sc_max_mva=1000, rx_max=0.1, x0x_max=1.0,\n                   r0x0_max=0.1)\n```\n\n----------------------------------------\n\nTITLE: Adding Zero Impedance Parameters in PandaPower\nDESCRIPTION: Function reference for adding zero sequence impedance parameters to the network using pandapower.add_zero_impedance_parameters\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npandapower.add_zero_impedance_parameters\n```\n\n----------------------------------------\n\nTITLE: Performing Short Circuit Calculations for Various Vector Groups\nDESCRIPTION: This set of snippets performs short circuit calculations for different vector groups of three-winding transformers and displays the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_1ph_vector_group_trafo3w.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n%%capture\nnet = single_3w_trafo_grid(\"Yyy\")\ncalc_sc(net, fault=\"1ph\", case=\"max\")\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: Two-Winding Transformer Impedance Calculation in LaTeX\nDESCRIPTION: Calculates the impedance components (zk, rk, xk) for a two-winding transformer using voltage and power ratings with correction factor KT.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/branch_elements.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nz_k &= \\frac{vk\\_percent}{100} \\cdot \\frac{1000}{sn\\_kva} \\cdot K_T \\\\\nr_k &= \\frac{vkr\\_percent}{100} \\cdot \\frac{1000}{sn\\_kva} \\cdot K_T \\\\\nx_k &= \\sqrt{z^2 - r^2} \\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Closing Circuit Breaker After Fault Clearance in pandapower\nDESCRIPTION: Closes the circuit breaker (switch) at bus 6 after a fault has been cleared to restore power to Load 0. This operation is performed by modifying the 'closed' status of switch 9 in the network model.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# after fault is cleared, close the CB at bus 6 so that Load 0 continues to get power\nnet.switch.closed.at[9] = True\n\nnet.switch\n```\n\n----------------------------------------\n\nTITLE: Running Power Loss and Loading Optimization\nDESCRIPTION: Executes optimizations to reduce both power losses and line loading using the specialized PandaPower optimization functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\npp.runpm_ploss(net_loss)\npp.runpm_loading(net_loading)\n```\n\n----------------------------------------\n\nTITLE: Visualization of Power Reference System Analysis\nDESCRIPTION: Creates a detailed visualization comparing load and generator behavior using seaborn and matplotlib, showing voltage variations across different power combinations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/reference_system_convention.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.patches as mpatches\nimport matplotlib.pyplot as plt\ng=sn.relplot(x=\"p_mw\", \n        y=\"q_mvar\",\n        size=\"vm_pu\",\n        col=\"element\",\n        sizes=(500,500),\n        palette=\"viridis\",\n        hue=\"vm_pu\",\n        data=df, alpha=1, zorder=10)\ng.set(xlim=(-60,60),ylim=(-60,60))\n\ntexts =[['Under-excited (consumes reactive power, decreases voltage)', 'Over-excited (injects reactive power, increases voltage)'],\n        ['Over-excited (injects reactive power, increases voltage)', 'Under-excited (consumes reactive power, decreases voltage)']]\n        \nfor i,(ax, text) in enumerate(zip(g.axes[0], texts)):\n    ax.spines['left'].set_position('center')\n    ax.spines['bottom'].set_position('center')\n    \n    ax.xaxis.labelpad = 160\n    ax.yaxis.labelpad = 160\n    ax.grid()\n    ax.text(0,50, text[0], bbox={'facecolor': 'lightgrey', 'pad': 10}, horizontalalignment='center', zorder=10)\n    ax.text(0,-50, text[1], bbox={'facecolor': 'lightgrey', 'pad': 10}, horizontalalignment='center', zorder=10)\n    \n    rect=mpatches.Rectangle((0,-25),50,50, alpha=0.1,facecolor=\"blue\")\n    ax.add_patch(rect)\n    \n    ax.text(10, 10,['P consumption','P generation'][i],fontsize=12)\n```\n\n----------------------------------------\n\nTITLE: Running Different TDPF Timeseries Scenarios\nDESCRIPTION: Executes multiple timeseries simulations with different thermal inertia configurations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.timeseries.run_timeseries(net, time_steps=range(25), tdpf=True, max_iteration=50)\noutput_ss = ow.output[\"res_line.temperature_degree_celsius\"].copy()\npp.timeseries.run_timeseries(net, time_steps=range(25), tdpf=True, tdpf_delay_s=15*60, max_iteration=50)\noutput_ss_20 = ow.output[\"res_line.temperature_degree_celsius\"].copy()\npp.timeseries.run_timeseries(net, time_steps=range(25), tdpf=True, tdpf_delay_s=5*60, max_iteration=50)\noutput_ss_20_5 = ow.output[\"res_line.temperature_degree_celsius\"].copy()\n```\n\n----------------------------------------\n\nTITLE: Converting DC Lines to Generator Representation\nDESCRIPTION: Creates a copy of the network and converts DC lines to equivalent generators for grid equivalent calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents_workarounds.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.auxiliary import _add_dcline_gens\nnet2 = deepcopy(net)\n_add_dcline_gens(net2)\nnet2.dcline.in_service=False\npp.runpp(net2)\n```\n\n----------------------------------------\n\nTITLE: Plotting Optimization Results for Storage in Python\nDESCRIPTION: This snippet defines a function to visualize the results of the storage optimization, plotting power and state of charge changes for multiple storage devices across time steps. It also provides a method to display results using matplotlib.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_storage.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.opf.pm_storage import read_pm_storage_results\nimport matplotlib.pyplot as plt\n\ndef plot_storage_results(storage_results):\n    n_res = len(storage_results.keys())\n    fig, axes = plt.subplots(n_res, 2)\n    if n_res == 1:\n        axes = [axes]\n    for i, (key, val) in enumerate(storage_results.items()):\n        res = val\n        axes[i][0].set_title(\"Storage {}\".format(key))\n        el = res.loc[:, [\"p_mw\", \"q_mvar\", \"soc_mwh\"]]\n        el.plot(ax=axes[i][0])\n        axes[i][0].set_xlabel(\"time step\")\n        axes[i][0].legend(loc=4)\n        axes[i][0].grid()\n        ax2 = axes[i][1]\n        patch = plt.plot([], [], ms=8, ls=\"--\", mec=None, color=\"grey\", label=\"{:s}\".format(\"soc_percent\"))\n        ax2.legend(handles=patch)\n        ax2.set_label(\"SOC percent\")\n        res.loc[:, \"soc_percent\"].plot(ax=ax2, linestyle=\"--\", color=\"grey\")\n        ax2.grid()\n    plt.show()\n\n# get the results\n#storage_results = read_pm_storage_results(net)    \n    \n# plot the results\n#plot_storage_results(storage_results)\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Analyzing Switches in pandapower\nDESCRIPTION: These snippets demonstrate how to create an open switch, run a power flow analysis, and inspect the results to verify the effects of the switch on the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/minimal_example.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.create_switch(net, bus=bus3, element=line, et=\"l\", closed=False)\n```\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nnet.res_bus\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_load\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line\n```\n\n----------------------------------------\n\nTITLE: DC Line Result Parameters in LaTeX\nDESCRIPTION: Mathematical formulas defining the calculation of result parameters including power flows, voltages, and angles for DC lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/dcline.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n    p\\_from\\_mw &= P_{from} \\\\\n    p\\_to\\_mw &= P_{to} \\\\\n    pl\\_mw &= p\\_from\\_mw + p\\_to\\_mw \\\\\n    q\\_from\\_mvar &= Q_{from} \\\\\n    q\\_to\\_mvar &= Q_{to} \\\\\n    va\\_from\\_degree &= \\angle \\underline{v}_{from} \\\\\n    va\\_to\\_degree &= \\angle \\underline{v}_{to} \\\\\n    vm\\_from\\_degree &= |\\underline{v}_{from}| \\\\\n    vm\\_to\\_degree &= |\\underline{v}_{to}| \\\\\n   \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Creating an Asymmetric Load for Unbalanced Power Flow in Pandapower\nDESCRIPTION: Demonstrates how to set up an asymmetric load to simulate unbalanced power flow conditions. It uses input parameters from Pandapower's asymmetric load documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.create_asymmetric_load(net, b3, p_a_mw=0.25, p_b_mw=0.18, p_c_mw=0.20, type=\"wye\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Total Impedance for Wind Power Station with Asynchronous Generator\nDESCRIPTION: This snippet calculates the total positive-sequence short-circuit impedance for a wind power station unit with an asynchronous generator, including the transformer impedance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nt_r = 20/0.4\n# transformer impedance is taken from the pandapower grid\n# transformer from the example (see below)\nZ_THV_complex = 2.3263781460713675+9.409936797295378j\nZ_WA_complex = t_r ** 2 * Z_G_complex + Z_THV_complex\nZ_WA_complex\n```\n\n----------------------------------------\n\nTITLE: Querying dataframes using boolean masks and string operations\nDESCRIPTION: Demonstrates how to query network elements using boolean masks, string operations, and logical operators for complex filtering.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmask = net.line.length_km > 2.5\nlong_lines = net.line[mask]\nlong_lines[[\"name\", \"length_km\", \"std_type\"]]\n\nnet.line[net.line.length_km > 2.5][[\"name\", \"length_km\", \"std_type\"]]\n\nnet.bus[net.bus.vn_kv == 110]\n\nnet.load[net.load.name.str.startswith(\"MV\")]\n\nnet.load[net.load.name.str.contains(\"Load 0\")]\n\nlines = net.line[net.line.from_bus.isin([39,72])]\nlines[[\"name\", \"from_bus\", \"to_bus\"]]\n\nlines = net.line[(net.line.from_bus.isin([39,72])) | (net.line.to_bus.isin([39,72]))]\nlines[[\"name\", \"from_bus\", \"to_bus\"]]\n```\n\n----------------------------------------\n\nTITLE: Three-Winding Transformer Impedance Calculation in LaTeX\nDESCRIPTION: Calculates the equivalent impedances for a three-winding transformer converted to three two-winding transformers with correction factors.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/branch_elements.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nv'_{k, t1} &= \\frac{1}{2} (v'_{k, h} \\cdot K_{T, h} + v'_{k, l} \\cdot K_{T, l} - v'_{k, m} \\cdot K_{T, m}) \\\\\nv'_{k, t2} &= \\frac{1}{2} (v'_{k, m} \\cdot K_{T, m} + v'_{k, h} \\cdot K_{T, h} - v'_{k, l} \\cdot K_{T, l}) \\\\\nv'_{k, t3} &= \\frac{1}{2} (v'_{k, m} \\cdot K_{T, m} + v'_{k, l} \\cdot K_{T, l} - v'_{k, h} \\cdot K_{T, h})\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower and Creating a Faulty Example Network\nDESCRIPTION: This snippet imports the pandapower module and defines a function to create a faulty example network with various issues for demonstration purposes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n\n# imports the pandapower module\nimport pandapower as pp\n\n# defines a function that creates an example network, which will be used a lot in this tutorial\n# run this code first in order for the examples to work\n\ndef faulty_example_network():\n\n    net = pp.create_empty_network()\n\n    pp.create_bus(net, name = \"110 kV bar\", vn_kv = 110, type = 'b', in_service = 'True')\n    pp.create_bus(net, name = \"20 kV bar\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 2\", vn_kv = 30, type = 'b')\n    pp.create_bus(net, name = \"bus 3\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 4\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 5\", vn_kv = -20, type = 'b')\n    pp.create_bus(net, name = \"bus 6\", vn_kv = 20, type = 'b')\n    \n    pp.create_ext_grid(net, 0, vm_pu = 1)\n\n    pp.create_line(net, name = \"line 0\", from_bus = 1, to_bus = 2, length_km = 0, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 1\", from_bus = 2, to_bus = 3, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 2\", from_bus = 3, to_bus = 4, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 3\", from_bus = 4, to_bus = 5, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 4\", from_bus = 5, to_bus = 6, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 5\", from_bus = 6, to_bus = 1, length_km = 1, std_type = \"NAYY 4x150 SE\")\n\n    pp.create_transformer_from_parameters(net, hv_bus = 1, lv_bus = 0, i0_percent= 0.038, pfe_kw = 11.6,\n                                          vkr_percent = 0.322, sn_mva = 40.0, vn_lv_kv = 22.0,\n                                          vn_hv_kv = 110.0, vk_percent = 17.8)\n\n    pp.create_load(net, 2, p_mw = -1, q_mvar = 0.200, name = \"load 0\")\n    pp.create_load(net, 3, p_mw = 1, q_mvar = 0.200, name = \"load 1\")\n    pp.create_load(net, 4, p_mw = 1, q_mvar = 0.200, name = \"load 2\")\n    pp.create_load(net, 5, p_mw = 1, q_mvar = 0.200, name = \"load 3\")\n    pp.create_load(net, 6, p_mw = 1, q_mvar = 0.200, name = \"load 4\")\n\n    pp.create_switch(net, bus = 1, element = 0, et = 'l')\n    pp.create_switch(net, bus = 2, element = 0, et = 'l')\n    pp.create_switch(net, bus = 2, element = 1, et = 'l')\n    pp.create_switch(net, bus = 3, element = 1, et = 'l')\n    pp.create_switch(net, bus = 3, element = 2, et = 'l')\n    pp.create_switch(net, bus = 4, element = 2, et = 'l')\n    pp.create_switch(net, bus = 4, element = 3, et = 'l', closed = False)\n    pp.create_switch(net, bus = 5, element = 3, et = 'l')\n    pp.create_switch(net, bus = 5, element = 4, et = 'l', closed = False)\n    pp.create_switch(net, bus = 6, element = 4, et = 'l', closed = False)\n    pp.create_switch(net, bus = 6, element = 5, et = 'l')\n    pp.create_switch(net, bus = 1, element = 5, et = 'l')\n    \n    return net\n```\n\n----------------------------------------\n\nTITLE: Results Comparison in Pandapower Optimization Outcomes\nDESCRIPTION: Fetches and compares grid results before and after optimization in terms of voltages and reactive power at DER-connected buses. This analysis helps to observe changes prompted by optimization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# results from power flow\ndisplay(net_org.res_bus.vm_pu[net_org.sgen.bus])\nv_org = net_org.res_bus.vm_pu[net_org.sgen.bus].values\nprint(\"--- deviation from setpionts v=0.96 ---\")\ndisplay(sum((v_org-0.96)**2)) \n```\n\nLANGUAGE: python\nCODE:\n```\n# results from optimization\ndisplay(net_opt.res_bus.vm_pu[net.sgen.bus])\nv_opt = net_opt.res_bus.vm_pu[net_opt.sgen.bus].values\nprint(\"--- deviation from setpionts v=0.96 ---\")\ndisplay(sum((v_opt-0.96)**2)) # devition from setpoints v=0.96 p.u.\n```\n\nLANGUAGE: python\nCODE:\n```\n# results from power flow\ndisplay(net_org.res_sgen)\n```\n\nLANGUAGE: python\nCODE:\n```\n# results from optimization\ndisplay(net_opt.res_sgen)\n```\n\n----------------------------------------\n\nTITLE: Calculating Impedance for Wind Power Station with Doubly Fed Asynchronous Generator\nDESCRIPTION: This code calculates the total positive-sequence short-circuit impedance for a wind power station with a doubly fed asynchronous generator.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nS_rWd = 2.5 # MVA\nU_rWD = U_rTWDHV = 20 # kV\ni_WDmax = 0.388 # kA\n# I_rWD is provided by the manufacturer\n# i_kWDmax = 1.2 * I_rWD\nk_WD = 1.7\nRX_WD = 0.1\n```\n\nLANGUAGE: python\nCODE:\n```\nZ_WD = np.sqrt(2) * k_WD * U_rTWDHV / (np.sqrt(3) * i_WDmax)\nZ_WD # Ohm\n```\n\nLANGUAGE: python\nCODE:\n```\nZ_WD_complex = (RX_WD + 1j) * Z_WD / np.sqrt(1 + RX_WD**2)\nZ_WD_complex # Ohm\n```\n\n----------------------------------------\n\nTITLE: Loading Time Series Data and Dependencies\nDESCRIPTION: Imports required libraries and loads time series data from CSV files. Handles file reading and comment removal for load profiles and shapes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport numpy as np\nimport pandas as pd\nimport tempfile\nimport pandapower as pp\nfrom pandapower.control import ConstControl\nfrom pandapower.timeseries import DFData\nfrom pandapower.timeseries import OutputWriter\nfrom pandapower.timeseries.run_time_series import run_timeseries\nfrom pandapower.networks import ieee_european_lv_asymmetric\nfrom pandapower import pp_dir\nparent = os.path.join(pp_dir,'test','test_files')\npath = os.path.join(parent, \"European_LV_CSV\")\nload_path = os.path.join(path, \"Load_Profiles\")\ndef remove_comments(f):\n    '''Pass comments'''\n    start=f.seek(0)\n    for index in range(5):\n        start=f.tell()\n        if f.readline().startswith('#'):\n            continue\n        else:\n            break      \n    f.seek(start)\n    return f\n\nload_csv = os.path.join(path, \"Loads.csv\")\n\nwith open (load_csv,'r') as f:\n    f = remove_comments(f)\n    loads = pd.read_csv(f)\n    f.close()\n\nload_shapes = os.path.join(path, \"LoadShapes.csv\")    \n    \nwith open (load_shapes,'r') as f:\n    f = remove_comments(f)\n    loadshapes = pd.read_csv(f)\n    f.close()\n```\n\n----------------------------------------\n\nTITLE: Plotting Simulation Results\nDESCRIPTION: This function takes the output writer object, a variable name, and a title as input and generates a plot of the specified variable over time. It uses matplotlib to create the plot, labels the axes, adds a title and grid, and displays the plot.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef plot_results(ow, variable, title):\n    p= ow.output[variable]\n    p.plot(label=variable)\n    plt.xlabel(\"time step\")\n    plt.ylabel(variable)\n    plt.title(title)\n    plt.grid()\n    plt.show()\n```\n\n----------------------------------------\n\nTITLE: Executing pandapower Time Series Simulation\nDESCRIPTION: Runs the time series simulation by setting up the output directory and calling the timeseries_example function. Prints the location of the output files.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\noutput_dir = os.path.join(tempfile.gettempdir(), \"time_series_example\")\nprint(\"Results can be found in your local temp folder: {}\".format(output_dir))\nif not os.path.exists(output_dir):\n    os.mkdir(output_dir)\ntimeseries_example(output_dir)\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Voltage Using Boolean Mask\nDESCRIPTION: This alternative method to find the maximum voltage at buses connected to loads uses a boolean mask instead of merging dataframes. It checks which buses have loads connected and retrieves the maximum voltage amongst those. The output is the maximum voltage value, and this method is noted to be faster than merging.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nmax_load_voltage = net.res_bus[net.bus.index.isin(net.load.bus.values)].vm_pu.max()\n\n#Output\nmax_load_voltage\n```\n\n----------------------------------------\n\nTITLE: Selecting Random Connection Bus for PV Plant in pandapower Network\nDESCRIPTION: This function chooses a random bus from the buses that have a load connection in a pandapower network. It uses numpy's random choice function to make the selection.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom numpy.random import choice\n\ndef chose_bus(net):\n    return choice(net.load.bus.values)\n```\n\n----------------------------------------\n\nTITLE: Iterating over network elements using iterrows and groupby\nDESCRIPTION: Shows how to iterate over network elements using pandas iterrows and groupby functions for analysis and aggregation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfor lidx, linerow in net.line.loc[[4,5,6]].iterrows():\n        print(\"the line with index %s is %f kilometers long and has a resistance of %f ohm per kilometers\" %(lidx, linerow.length_km, linerow.r_ohm_per_km))\n\nfor std_type, linetable in net.line.groupby(net.line.std_type):\n        print(\"there are %u lines with standard type %s with an overall length of %f kilometers\"%(len(linetable), std_type, linetable.length_km.sum()))\n\nnet.line.groupby(net.line.std_type).sum().length_km\n```\n\n----------------------------------------\n\nTITLE: Creating Load with MVA-based Units in pandapower 2.0\nDESCRIPTION: Shows how to create a load using the new MVA-based units in pandapower 2.0, compared to the previous kVA-based units.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.create_load(net, bus=3, p_mw=0.2, q_mvar=0.1, sn_mva=0.5)\n```\n\n----------------------------------------\n\nTITLE: Plotting Q Capability Curve Characteristics in Python\nDESCRIPTION: These snippets plot the maximum and minimum Q capability curve characteristics for the generator. They use pandapower's plot_characteristic function to visualize the relationship between P and Q.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.control.plot_characteristic(net3.q_capability_curve_characteristic.q_max_characteristic.at[0], -331, 331,\n                               xlabel='Values of \"P_mw\"', ylabel='Value of \"Q_max_Mvar\"')\n```\n\nLANGUAGE: python\nCODE:\n```\npp.control.plot_characteristic(net3.q_capability_curve_characteristic.q_min_characteristic.at[0], -331, 331,\n                               xlabel='Values of \"P_mw\"', ylabel='Value of \"Q_min_Mvar\"')\n```\n\n----------------------------------------\n\nTITLE: Retrieving Line and Transformer Currents and Loadings in Pandapower\nDESCRIPTION: Extracts current values and loadings from line and transformer results across different phases, including the highest phase loading percentage.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/unbalanced_minimal.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line_3ph[[\"i_a_from_ka\", \"i_b_to_ka\", \"loading_b_percent\", \"loading_percent\"]]\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.res_trafo_3ph[[\"i_a_hv_ka\", \"i_b_lv_ka\", \"loading_b_percent\", \"loading_percent\"]]\n```\n\n----------------------------------------\n\nTITLE: Running Pypower Flow Calculation\nDESCRIPTION: Executes power flow calculation using pypower method.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Calculating corrected zero-sequence impedance with OLTC\nDESCRIPTION: This code calculates the corrected zero-sequence impedance for the power system unit with OLTC, applying the previously calculated correction factor KS.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nzn = 1j * net.trafo.xn_ohm\nz_0SK = ks * z_0THV + 3*zn\nz_0SK.at[0]\n```\n\n----------------------------------------\n\nTITLE: Defining Grid Equivalent Input Variables\nDESCRIPTION: This snippet defines the input variables for the Ward-equivalent calculation, including the equivalent type, internal buses, and boundary buses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/gridequivalent_example.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# equivalent type\neq_type = \"ward\"\n\n# internal buses: we don't need to give all internal buses to the function. Just one of them is enough.\ninternal_buses = [0]\n\n# boundary buses\nboundary_buses = [4, 8]\n```\n\n----------------------------------------\n\nTITLE: Simple Four Bus System Documentation\nDESCRIPTION: Documentation for pandapower's simple four bus system test network configuration with visual diagram reference\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/test.rst#2025-04-22_snippet_2\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: pandapower.networks.simple_four_bus_system\n\n.. image:: /pics/networks/simple_nw_simple_four_bus_system.png\n\t:width: 15em\n\t:alt: alternate Text\n\t:align: center\n```\n\n----------------------------------------\n\nTITLE: Calculating Protection Times in pandapower\nDESCRIPTION: Function reference for calculating protection timing in pandapower networks. Used to analyze how fuses respond to short-circuit and power flow conditions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/protection/fuse.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.protection.run_protection.calculate_protection_times\n```\n\n----------------------------------------\n\nTITLE: Creating Kerber Rural Networks with Overhead Lines in Python\nDESCRIPTION: Creates rural Kerber networks (Landnetze) with overhead lines using two different configurations. These networks feature relatively low number of loads per transformer station.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_landnetz_freileitung_1, create_kerber_landnetz_freileitung_2\n\nnet1 = create_kerber_landnetz_freileitung_1()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (13 elements) p_load_in_mw=8,  q_load_in_mw=0\n  - bus (15 elements)\n  - line (13 elements) std_type=\"Al 120\", l_lines_in_km=0.021\n  - trafo (1 elements)  std_type=\"0.125 MVA 10/0.4 kV Dyn5 ASEA\"\n  - ext_grid (1 elements)\n'''\n\nnet2 = create_kerber_landnetz_freileitung_2()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (8 elements) p_load_in_mw=8,  q_load_in_mw=0\n  - bus (10 elements)\n  - line (8 elements)  std_type=\"AL 50\", l_lines_1_in_km=0.038, l_lines_2_in_km=0.081\n  - trafo (1 elements)  std_type=\"0.125 MVA 10/0.4 kV Dyn5 ASEA\"\n  - ext_grid (1 elements)\n'''\n```\n\n----------------------------------------\n\nTITLE: Plotting Time-Series Contingency Analysis Results in pandapower\nDESCRIPTION: This snippet creates a plot of the maximum and minimum line loadings and bus voltages for both N-0 and N-1 situations across all time steps using matplotlib.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfig, (ax1, ax2) = plt.subplots(ncols=2, nrows=1, figsize=(10,4))\n\now.output[\"res_line.max_loading_percent\"].max(axis=1).plot(label=\"max. Loading, N-1 (%)\", ax=ax1, linestyle=\"--\")\now.output[\"res_line.loading_percent\"].max(axis=1).plot(label=\"max. Loading, N-0 (%)\", ax=ax1)\now.output[\"res_line.min_loading_percent\"].min(axis=1).plot(label=\"min. Loading, N-1 (%)\", ax=ax1, linestyle=\"--\")\now.output[\"res_line.loading_percent\"].min(axis=1).plot(label=\"min. Loading, N-0 (%)\", ax=ax1)\n\nax1.legend(ncol=2, loc=\"upper center\", bbox_to_anchor=[0.5, -0.15])\nax1.set_ylabel(\"Line loading (%)\")\nax1.set_xlabel(\"Time step\")\n\now.output[\"res_bus.max_vm_pu\"].max(axis=1).plot(label=\"max. $V_m$, N-1 (p.u.)\", ax=ax2, linestyle=\"--\")\now.output[\"res_bus.vm_pu\"].max(axis=1).plot(label=\"max. $V_m$, N-0 (p.u.)\", ax=ax2)\now.output[\"res_bus.min_vm_pu\"].min(axis=1).plot(label=\"min. $V_m$, N-1 (p.u.)\", ax=ax2, linestyle=\"--\")\now.output[\"res_bus.vm_pu\"].min(axis=1).plot(label=\"min. $V_m$, N-0 (p.u.)\", ax=ax2)\n\nax2.legend(ncol=2, loc=\"upper center\", bbox_to_anchor=[0.5, -0.15])\nax2.set_ylabel(\"Bus voltage magnitude (p.u.)\")\nax2.set_xlabel(\"Time step\")\n\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Plotting various simulation results\nDESCRIPTION: This code calls the previously defined `plot_results` function to visualize various simulation results, including bus voltage magnitudes, line loading percentages, and real power at the load and generator.  This provides a comprehensive overview of the system's behavior during the time series simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nplot_results(ow, 'res_bus.vm_pu', 'Voltage (p.u.)')\nplot_results(ow, 'res_line.loading_percent', 'Line Loading')\nplot_results(ow, 'res_load.p_mw', 'Real Power at load')\nplot_results(ow, 'res_sgen.p_mw', 'Real Power at sgen')\n```\n\n----------------------------------------\n\nTITLE: Creating DataFrame for Power Analysis Results\nDESCRIPTION: Initializes an empty pandas DataFrame to store analysis results including element type, power values, and voltage measurements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/reference_system_convention.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndf=pd.DataFrame(columns=['element', 'p_mw', 'q_mvar', 'vm_pu', 'p_from_mw', 'p_to_mw'])\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Path in a MultiGraph with NetworkX\nDESCRIPTION: This snippet demonstrates how to find the shortest path between two nodes (bus0 and bus5) in the MultiGraph. It utilizes NetworkX's shortest_path function and returns the path as a list of bus indices.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport networkx as nx\npath = nx.shortest_path(mg, 0, 5)\npath\n```\n\n----------------------------------------\n\nTITLE: Plotting Histogram of Randomly Distributed Parameters\nDESCRIPTION: This snippet defines a function to plot histograms of data distributions using Matplotlib. It generates histograms for random parameters such as loads and generation, providing insights into their distribution characteristics. It assumes that 10 distinct colors are available for plotting.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef hist_plot(\n        bins: int,\n        data: dict[str, Any],\n    ) -> None:\n\n    colors = [\"blue\", \"orange\", \"green\", \"red\", \"purple\", \"brown\", \"pink\", \"gray\", \"olive\", \"cyan\"]\n    if len(data.keys()) > len(colors):\n        raise NotImplementedError(\n            f\"hist_plot() defines not enough colors internally. {len(colors)} colors are available \"\n            f\"but the data requires {len(data.keys())}.\")\n    fig, ax = plt.subplots()\n    for i, (key, values) in enumerate(data.items()):\n        _ = ax.hist(values, bins=bins, edgecolor=colors[i], histtype=\"step\", label=key)\n        _ = ax.hist(values  , bins=bins, color=colors[i], alpha=0.4)\n    ax.set_ylabel(\"Frequency\")\n    plt.legend()\n    plt.tight_layout()\n    return fig, ax\n\n\nfig, ax = hist_plot(50, {\"Load 4\": load_r4_distr, \"Load 9\": load_ci9_distr, \"PV 10\": sgen_pv10_distr})\n```\n\n----------------------------------------\n\nTITLE: Summing Bus Power in MW in pandapower 2.0\nDESCRIPTION: Demonstrates how to sum bus power in MW using the new units, with an option to convert to kW if needed.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nbus_sum_kw = net.bus.p_mw.sum()*1e3\n# or\nbus_sum_mw = net.bus.p_mw.sum()\n```\n\n----------------------------------------\n\nTITLE: Applying General Reactive Power Limits to Generator in Python\nDESCRIPTION: This snippet demonstrates how to apply general reactive power limits to a generator in the network and run a power flow analysis with enforced Q limits.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet2 = test_net_for_q_capability_curve()\nnet2.gen.loc[0,\"max_q_mvar\"] = 50.0\nnet2.gen.loc[0, \"min_q_mvar\"] =  -3\n```\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net2, enforce_q_lims=True)\nassert net2.res_gen.q_mvar.loc[0] == -3\nassert net2.res_gen.p_mw.loc[0] == 100\n```\n\n----------------------------------------\n\nTITLE: Equal Slack Weights Power Flow Example\nDESCRIPTION: Shows power flow calculation with equal slack weights distributed among external grid and generators.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/distributed_slack.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndisplay(Markdown(\"#### Without distributed slack\"))\npp.runpp(net)\n\nprint_powers(net)\n\ndisplay(Markdown(\"#### With distributed slack\"))\nnet.ext_grid['slack_weight'] = 1\nnet.gen['slack_weight'] = 1\n\npp.runpp(net, distributed_slack=True)\n\nprint_powers(net)\n```\n\n----------------------------------------\n\nTITLE: Output Writer Configuration\nDESCRIPTION: Configures output writer to log various network parameters including voltage magnitudes and power values for each phase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef create_output_writer(net, time_steps, output_dir):\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".json\")\n    ow.log_variable('res_trafo_3ph', 'p_a_lv_mw', index=net.trafo.index)\n    ow.log_variable('res_trafo_3ph', 'p_b_lv_mw', index=net.trafo.index)\n    ow.log_variable('res_trafo_3ph', 'p_c_lv_mw', index=net.trafo.index)\n    ow.log_variable('res_trafo_3ph', 'q_a_lv_mvar', index=net.trafo.index)\n    ow.log_variable('res_trafo_3ph', 'q_b_lv_mvar', index=net.trafo.index)\n    ow.log_variable('res_trafo_3ph', 'q_c_lv_mvar', index=net.trafo.index)\n    ow.log_variable('res_bus_3ph', 'vm_a_pu', index=[34])   # Load 1 Phase A \n    ow.log_variable('res_bus_3ph', 'vm_b_pu', index=[899])  # Load 53 Phase B\n    ow.log_variable('res_bus_3ph', 'vm_c_pu', index=[614])  # Load 32 Phase C\n    ow.log_variable('res_bus_3ph', 'va_a_degree', index=[34])   # Load 1 Phase A \n    ow.log_variable('res_bus_3ph', 'va_b_degree', index=[899])  # Load 53 Phase B\n    ow.log_variable('res_bus_3ph', 'va_c_degree', index=[614])  # Load 32 Phase C\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Executing Grid Equivalent Calculation\nDESCRIPTION: Calls the get_equivalent function to perform grid reduction\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet_eq = pp.grid_equivalents.get_equivalent(net, eq_type, boundary_buses, internal_buses)\n```\n\n----------------------------------------\n\nTITLE: Calculating Transformer Ratio in pandapower\nDESCRIPTION: Mathematical formula showing how the magnitude of transformer ratio is calculated based on reference voltages of buses and transformer parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\nn &= \\frac{V_{ref, HV, transformer}}{V_{ref, LV, transformer}} \\cdot \\frac{V_{ref, LV bus}}{V_{ref, HV bus}}\n```\n\n----------------------------------------\n\nTITLE: Calculating Shunt Result Parameters\nDESCRIPTION: Formulas for calculating result parameters of shunt elements, including active and reactive power, and voltage magnitude. These calculations are performed after power flow analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/shunt.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n p\\_mw &= Re(\\underline{v}_{bus} \\cdot \\underline{i}_{shunt}) \\\\    \n q\\_mvar &= Im(\\underline{v}_{bus} \\cdot \\underline{i}_{shunt}) \\\\    \n vm\\_pu &= v_{bus}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Calculating zero-sequence impedance of transformer (HV side)\nDESCRIPTION: This code calculates the zero-sequence impedance of the power station unit transformer related to the high voltage side, without applying the correction factor KT.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nvkx0_percent = np.sqrt(np.square(vk0_percent) - np.square(vkr0_percent))\nz_0THV = (vkr0_percent / 100 + 1j * vkx0_percent / 100) * (np.square(vn_trafo_hv) / sn_mva)\nz_0THV.at[0]\n```\n\n----------------------------------------\n\nTITLE: Creating Structural Plan for Pandapower Network in Python\nDESCRIPTION: This snippet shows how to create a structural plan of a Pandapower network by using generic coordinates with respect to switches, separating buses connected by open switches.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet = nw.mv_oberrhein()\nnet.bus.geo = np.nan\nnet.line.geo = np.nan\nplot.create_generic_coordinates(net, respect_switches=True) #create artificial coordinates with the igraph package\n\nplot.fuse_geodata(net)\nbc = plot.create_bus_collection(net, net.bus.index, size=.2, color=colors[0], zorder=10)\ntlc, tpc = plot.create_trafo_collection(net, net.trafo.index, color=\"g\")\nlcd = plot.create_line_collection(net, net.line.index, color=\"grey\", linewidths=0.5, use_bus_geodata=True)\nsc = plot.create_bus_collection(net, net.ext_grid.bus.values, patch_type=\"rect\", size=.5, color=\"y\", zorder=11)\nplot.draw_collections([lcd, bc, tlc, tpc, sc], figsize=(8,6))\n```\n\n----------------------------------------\n\nTITLE: Creating Line Using Standard Type\nDESCRIPTION: Demonstrates creating a line using a predefined standard type with specified parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nb1 = pp.create_bus(net, vn_kv=.4)\nb2 = pp.create_bus(net, vn_kv=.4)\nlid = pp.create_line(net, from_bus=b1, to_bus=b2, length_km=0.1, std_type=\"NAYY 4x50 SE\", name=\"test_line\")\nnet.line.loc[lid]\n```\n\n----------------------------------------\n\nTITLE: Defining Conductor Data for TDPF Calculations in Python\nDESCRIPTION: This code snippet sets up the initial conductor data parameters used in the TDPF calculations, including air temperature, maximum temperature, reference temperature, and various physical properties of the conductor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# conductor data\nt_air = 40\nt_max = 90\nt_ref = 25\nr_ref_ohm_per_m = 0.1824e-3\nconductor_outer_diameter_m = 18.2e-3\nv_m_per_s = 0.5\nwind_angle_degree = 45\ns_w_per_square_meter = 1000\nalpha = 0.004\nsolar_absorptivity = emissivity = 0.5\nmc_joule_per_m_k = 525\n```\n\n----------------------------------------\n\nTITLE: Analyzing Temperature vs. Time Delay\nDESCRIPTION: This code snippet analyzes the impact of varying time delays on overhead line temperature. It iterates through a range of delay values (from 0 to 60 minutes in 5-minute increments), runs the TDPF calculation for each delay, and stores the resulting line temperatures in a pandas DataFrame for plotting.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndelays = np.arange(0, 65, 5)\ndelay_tab = pd.DataFrame(index=delays, columns=net.line.index.values)\n\nfor d in delays:\n    pp.runpp(net, tdpf=True, tdpf_delay_s=d * 60, max_iteration=30)\n    delay_tab.loc[d, :] = net.res_line.temperature_degree_celsius.values\n    \ndelay_tab.plot(ylabel=\"Temperature (°C)\", xlabel=\"Time delay (min)\", \n               title=\"Time delay and overhead line temperature\");\n```\n\n----------------------------------------\n\nTITLE: Creating Test Grid with Pandapower in Python\nDESCRIPTION: Creates a cigre medium voltage grid with distribution energy resources (DERs) using pandapower. It runs a power flow calculation and displays the results for DER. Dependencies include pandapower and its network module, and a deep copy from the copy module. Displays initial reactive power state of the DER after power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\nfrom copy import deepcopy\n\nnet = nw.create_cigre_network_mv(with_der=\"pv_wind\")\npp.runpp(net) # run power flow calculation\nnet_org = deepcopy(net) # copy of the grid for further comparison\ndisplay(net.res_sgen) # show power flow results for DER\n```\n\n----------------------------------------\n\nTITLE: Handling Slack Buses in External Area\nDESCRIPTION: Demonstrates handling of slack buses in the external area by treating them as boundary buses during equivalent calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents_workarounds.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.networks.case9()\nnet.gen.slack = True\npp.runpp(net)\nboundary_buses = [4, 8, 1, 2]\nnet_eq = get_equivalent(net, \"rei\", [4,8], [0])\nprint(\"original net\", net.res_bus)\nprint(\"equivalent net\", net_eq.res_bus)\n```\n\n----------------------------------------\n\nTITLE: Running Diagnostic Function on Faulty Network\nDESCRIPTION: This snippet demonstrates the use of pandapower's diagnostic function to identify issues in the faulty network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# diagnoses the faulty network\npp.diagnostic(faulty_net)\n```\n\n----------------------------------------\n\nTITLE: Summing Generator Power Output in pandapower 2.0\nDESCRIPTION: Shows how to sum generator power output using the new generator-based signing system and MW units, with an option to convert to kW.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngen_power_kw = net.res_gen.p_mw.sum()*1e3\n# or\ngen_power_mw = net.res_gen.p_mw.sum()\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Characteristic in Pandapower for Voltage Setpoints\nDESCRIPTION: This code snippet defines a Characteristic object to model a piecewise linear function for voltage setpoints as a function of power flowing through a transformer. It represents varying setpoints based on power levels.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nc = Characteristic(net, x_values=[-20, -15, -5, 5,15, 20], y_values=[0.92, 0.97, 0.98, 1.02, 1.03, 1.08])\n```\n\n----------------------------------------\n\nTITLE: Plotting Pandapower Network with Generic Coordinates in Python\nDESCRIPTION: This snippet shows how to plot a Pandapower network using generic coordinates. It creates collections for buses, transformers, lines, and external grids, then draws them on a figure.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsizes = plot.get_collection_sizes(net)\nbc = plot.create_bus_collection(net, net.bus.index, size=sizes['bus'], color='b', zorder=10)\ntlc, tpc = plot.create_trafo_collection(net, net.trafo.index, color=\"g\", size=sizes['trafo'])\nlcd = plot.create_line_collection(net, net.line.index, color=\"grey\", linewidths=0.5, use_bus_geodata=True)\nsc = plot.create_bus_collection(net, net.ext_grid.bus.values, patch_type=\"rect\", size=sizes['ext_grid'], color=\"y\", zorder=11)\nplot.draw_collections([lcd, bc, tlc, tpc, sc], figsize=(8,6))\n```\n\n----------------------------------------\n\nTITLE: Voltage Level-based Network Plotting with Pandapower and Plotly\nDESCRIPTION: Demonstrates the use of vlevel_plotly() function to create a plot where the network is colored and labeled according to voltage levels. This example uses the mv_oberrhein network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/built-in_plots.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.plotting.plotly import vlevel_plotly\nfrom pandapower.networks import mv_oberrhein\nnet = mv_oberrhein()\nvlevel_plotly(net)\n```\n\n----------------------------------------\n\nTITLE: Viewing Short-Circuit Results\nDESCRIPTION: Displays the short-circuit calculation results from the network simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit_renewables.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_sc\n```\n\n----------------------------------------\n\nTITLE: Calculating Transformer Magnetising Admittance in pandapower\nDESCRIPTION: Mathematical formula showing how the magnetising admittance for a transformer is calculated based on the no-load current and iron losses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\ny_m &= \\frac{i0\\_percent}{100} \\\\\ng_m &= \\frac{pfe\\_kw}{sn\\_mva \\cdot 1000} \\cdot \\frac{net.sn\\_mva}{sn\\_mva} \\\\\nb_m &= \\sqrt{y_m^2 - g_m^2} \\\\\n\\underline{y_m} &= g_m - j \\cdot b_m\n```\n\n----------------------------------------\n\nTITLE: Per Unit System Conversions for Line Parameters\nDESCRIPTION: Mathematical formulas for converting line parameters to per unit system using base impedance and power values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/line.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\nZ_{N} = \\frac{V_{N}^2}{S_{N}}\n\\underline{z} = \\frac{\\underline{Z}}{Z_{N}}\n\\underline{y} = \\underline{Y} \\cdot Z_{N}\n```\n\n----------------------------------------\n\nTITLE: Defining External Grid Limits and Costs for PowerModels OPF in Python\nDESCRIPTION: This function sets limits and costs for external grids in a pandapower network. It's necessary for the PowerModels OPF formulation to avoid errors related to undefined generator limits.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_tnep.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef define_ext_grid_limits(net):\n    net[\"ext_grid\"].loc[:, \"min_p_mw\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_p_mw\"] = 9999.\n    net[\"ext_grid\"].loc[:, \"min_q_mvar\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_q_mvar\"] = 9999.\n    for i in net.ext_grid.index:\n        pp.create_poly_cost(net, i, 'ext_grid', cp1_eur_per_mw=1)\n```\n\n----------------------------------------\n\nTITLE: Loading MV Oberrhein Network from pandapower\nDESCRIPTION: This function loads the MV Oberrhein network from pandapower's network package. It uses the 'generation' scenario for the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/hosting_capacity.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.networks as nw\ndef load_network():\n    return nw.mv_oberrhein(scenario=\"generation\")\n```\n\n----------------------------------------\n\nTITLE: Finding Cycles in a Network\nDESCRIPTION: This snippet retrieves cycles from an undirected MultiGraph. It first attempts to find cycles while not respecting switches, then finds any cycles present in the Network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, multi=False)\nnx.cycle_basis(mg)\nmg = top.create_nxgraph(net, respect_switches=False, multi=False)\nnx.cycle_basis(mg)\n```\n\n----------------------------------------\n\nTITLE: Displaying Line Results with Time Delay\nDESCRIPTION: This code displays the line results after running the TDPF calculation with a time delay, allowing for observation of the impact of thermal inertia on the line parameters, especially temperature.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line\n```\n\n----------------------------------------\n\nTITLE: Creating Cost Functions for Minimizing Load in pandapower OPF\nDESCRIPTION: Creates cost functions to minimize load consumption and storage by assigning a positive linear cost coefficient, making higher power consumption more expensive.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/formulation.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 0, 'load', cp1_eur_per_mw=1)\npp.create_poly_cost(net, 0, 'storage', cp1_eur_per_mw=1)\npp.create_pwl_cost(net, 0, \"load\", [[net.load.min_p_mw.at[0], net.load.max_p_mw.at[0], 1]])\npp.create_pwl_cost(net, 0, \"storage\", [[net.storage.min_p_mw.at[0], net.storage.max_p_mw.at[0], 1]])\n```\n\n----------------------------------------\n\nTITLE: Comparing Voltage Angles\nDESCRIPTION: Compares voltage angle results between PowerModels and pypower calculations using numpy.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnp.allclose(va_pm, va_pp)\n```\n\n----------------------------------------\n\nTITLE: Generator Power Calculation in Pandapower\nDESCRIPTION: Calculates total generator power output in megawatts by summing the p_from_mw column from the generator results table.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ngen_power_mw = net.res_gen.p_from_mw.sum()\n```\n\n----------------------------------------\n\nTITLE: Running Storage Optimization with pandapower in Python\nDESCRIPTION: This snippet executes the previously defined functions to load the cigre grid, convert the time series to pandapower controllers, and initiates the optimization process for specified time steps, capturing any errors during execution.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_storage.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# open the cigre mv grid\nnet = cigre_grid()\n\n# convert the time series to pandapower controller\ninput_file = \"cigre_timeseries_15min.json\"\nconvert_timeseries_to_controller(net, input_file)\n\n# print controller\nprint(\"--- time series controller:\", net.controller)\n\n# print time series data in controller\nprint(\"--- considered element of controller 0:\", net.controller.object[0].__dict__[\"matching_params\"][\"element\"])\nprint(\"--- considered element index of controller 0:\",net.controller.object[0].__dict__[\"matching_params\"][\"element_index\"])\nprint(\"--- time series data:\",net.controller.object[0].data_source.df)\n\n# run the optimization for the first ten timesteps (the first run can be slow.\ntry:\n    pp.runpm_storage_opf(net, from_time_step=0, to_time_step=10)\nexcept Exception as err:\n    print(err)\n\n```\n\n----------------------------------------\n\nTITLE: Creating Q Capability Curve Characteristics in Python\nDESCRIPTION: This code creates a Q capability curve characteristic for a generator based on the q_capability_curve_table. It uses the create_q_capability_curve_characteristics_object function from pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet3 = test_net_for_q_capability_curve(characteristics_data=True)\n```\n\nLANGUAGE: python\nCODE:\n```\n# Add q_capability_curve_characteristic for one gen based on q_capability_curve_table\ncreate_q_capability_curve_characteristics_object(net3)\n```\n\n----------------------------------------\n\nTITLE: Plotting Pandapower Network on a Map with Plotly\nDESCRIPTION: Shows how to use simple_plotly() to plot a pandapower network on a map. This example uses the mv_oberrhein network and specifies a projection for the map.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/built-in_plots.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = mv_oberrhein()\nsimple_plotly(net, on_map=True, projection='epsg:31467')\n```\n\n----------------------------------------\n\nTITLE: Calculating Transformer Short-Circuit Impedance in pandapower\nDESCRIPTION: Mathematical formula showing how the short-circuit impedance for a transformer is calculated based on the rated values and the short-circuit voltage in percent.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nz_k &= \\frac{vk\\_percent}{100} \\cdot \\frac{net.sn\\_mva}{sn\\_mva} \\\\\nr_k &= \\frac{vkr\\_percent}{100} \\cdot \\frac{net.sn\\_mva}{sn\\_mva} \\\\\nx_k &= \\sqrt{z^2 - r^2} \\\\\n\\underline{z}_k &= r_k + j \\cdot x_k\n```\n\n----------------------------------------\n\nTITLE: Mathematical Representation of External Grid Three-Phase Result Parameters\nDESCRIPTION: Mathematical formulation of the active and reactive power feed-in or consumption at the slack node for each phase in three-phase power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ext_grid.rst#2025-04-22_snippet_3\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\n    p\\_mw_{phase} &= P_{eg_{phase}} \\\\\n    q\\_mvar_{phase} &= Q_{eg_{phase}}\n    \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Impedance Result Parameter Calculations\nDESCRIPTION: Mathematical formulas defining how various result parameters like current, power, and losses are calculated for the impedance component.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/impedance.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\ni\\_from\\_ka &= i_{from}\\\\\ni\\_to\\_ka &= i_{to}\\\\\np\\_from\\_mw &= Re(\\underline{v}_{from} \\cdot \\underline{i}^*_{from}) \\\\\nq\\_from\\_mvar &= Im(\\underline{v}_{from} \\cdot \\underline{i}^*_{from}) \\\\\np\\_to\\_mw &= Re(\\underline{v}_{to} \\cdot \\underline{i}^*_{to}) \\\\\nq\\_to\\_mvar &= Im(\\underline{v}_{to} \\cdot \\underline{i}^*_{to}) \\\\\npl\\_mw &= p\\_from\\_mw + p\\_to\\_mw \\\\\nql\\_mvar &= q\\_from\\_mvar + q\\_to\\_mvar \\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Running PyQt Application with Pandapower\nDESCRIPTION: This snippet provides the main function to initialize and run a PyQt application with an instantiated `SliderWidget`. It requires a pandapower network object as an input and sets up the application loop using `sys.argv`. It demonstrates usage of the `SliderWidget` class for interactive visualization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_pyqt.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef main(net):\\n   app = QApplication(sys.argv)\\n   ex = SliderWidget(net)\\n   ex.showMaximized()\\n   sys.exit(app.exec_())\n```\n\n----------------------------------------\n\nTITLE: Creating Shunt in PandaPower Network\nDESCRIPTION: Adds a shunt element to the network with specified active and reactive power values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npp.create_shunt(net, pp.get_element_index(net, \"bus\", 'Bus HV1'), p_mw=0, q_mvar=0.960, name='Shunt')\n\n# show shunt table\nnet.shunt\n```\n\n----------------------------------------\n\nTITLE: Accessing parameters using .loc and .at\nDESCRIPTION: Demonstrates how to access single and multiple parameters of network elements using .loc and .at methods.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.line.loc[4]\n\nnet.line.length_km.loc[[5,6]]\n\nnet.line.length_km.loc[[5,6]].values\n\nnet.line.loc[[5,6], [\"length_km\", \"r_ohm_per_km\", \"x_ohm_per_km\", \"c_nf_per_km\"]]\n\nnet.line.loc[[5,6], [\"length_km\", \"r_ohm_per_km\", \"x_ohm_per_km\", \"c_nf_per_km\"]].values\n\nnet.line.length_km.at[6]\n```\n\n----------------------------------------\n\nTITLE: Comparing Power Flow Results\nDESCRIPTION: This snippet compares the power flow results between the original grid and the reduced grid by printing the bus results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/gridequivalent_example.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"--- power flow (original grid) ---\")\nnet.res_bus\nprint(\"--- power flow (reduced grid) ---\")\nnet_eq.res_bus\n```\n\n----------------------------------------\n\nTITLE: Creating and Configuring 3-Winding Transformers in Python\nDESCRIPTION: This set of codes creates instances of networks with transformer connections, indicative of how to set up multiple 3-winding transformers and their respective configurations in an electrical network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nnet4 = create_net()\nnet5 = create_net()\nfor i in range(2):\n    add_trafo_connection(net4, net4.trafo.at[0, 'hv_bus'], \"trafo3w\")\n    add_trafo_connection(net5, net5.trafo.at[0, 'hv_bus'], \"trafo3w\")\n```\n\nLANGUAGE: python\nCODE:\n```\nnet4.trafo3w.loc[0,\"id_characteristic_table\"] = 2\nnet4.trafo3w.loc[0,\"tap_dependency_table\"] = True\npp.control.create_trafo_characteristic_object(net4)\n```\n\nLANGUAGE: python\nCODE:\n```\npp.control.SplineCharacteristic(net5, [-2, -1, 0, 1, 2], [0.85, 0.9, 1, 1.1, 1.15])\npp.control.SplineCharacteristic(net5, [-2, -1, 0, 1, 2], [0.27, 0.28, 0.3, 0.32, 0.33])\n```\n\nLANGUAGE: python\nCODE:\n```\npp.control.TapDependentImpedance(net5, [0], 0, output_variable=\"vk_hv_percent\",  element=\"trafo3w\")\npp.control.TapDependentImpedance(net5, [0], 1, output_variable=\"vkr_hv_percent\", element=\"trafo3w\")\npp.control.TapDependentImpedance(net5, [0], 0, output_variable=\"vk_mv_percent\",  element=\"trafo3w\")\npp.control.TapDependentImpedance(net5, [0], 1, output_variable=\"vkr_mv_percent\", element=\"trafo3w\")\npp.control.TapDependentImpedance(net5, [0], 0, output_variable=\"vk_lv_percent\",  element=\"trafo3w\")\npp.control.TapDependentImpedance(net5, [0], 1, output_variable=\"vkr_lv_percent\", element=\"trafo3w\")\n```\n\n----------------------------------------\n\nTITLE: Power Flow Analysis Loop Implementation\nDESCRIPTION: Executes power flow calculations for different combinations of active and reactive power values for both load and generator elements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/reference_system_convention.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ni=0\nfor element in ('load', 'sgen'):\n    for x in [0, 50, -50]:\n        for y in [0, 25, -25]:\n            net[element].loc[0,['p_mw', 'q_mvar']] = x, y\n            pp.runpp(net)\n            df.loc[i, 'element'] = element\n            df.loc[i, ['p_mw', 'q_mvar']] = x,y\n            df.loc[i, 'vm_pu'] = net.res_bus.vm_pu.at[bus1]\n            df.loc[i, 'p_from_mw'] = net.res_line.p_from_mw.at[line0]\n            df.loc[i, 'p_to_mw'] = net.res_line.p_to_mw.at[line0]\n            i += 1\n    net[element].loc[0, ['p_mw', 'q_mvar']] = 0, 0\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow and Checking Transformer Voltages in Python\nDESCRIPTION: This code runs a power flow calculation and displays the voltage at the low voltage side of the transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\nnet.res_trafo.vm_lv_pu\n```\n\n----------------------------------------\n\nTITLE: Creating a Three-Winding Transformer in pandapower\nDESCRIPTION: Functions to create a three-winding transformer in a pandapower network. Two methods are provided: create_transformer3w for standard types and create_transformer3w_from_parameters for custom parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo3w.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npandapower.create.create_transformer3w\n\npandapower.create.create_transformer3w_from_parameters\n```\n\n----------------------------------------\n\nTITLE: External Grid Reactive Power Constraints\nDESCRIPTION: Shows the change in reactive power constraint definitions for external grid, transitioning from kVar to MVAr units.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnet.ext_grid.min_q_kvar=-300\nnet.ext_grid.max_q_kvar=400\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.ext_grid.min_q_mvar=-0.4\nnet.ext_grid.max_q_mvar=0.3\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cost Parameters and Running OPF\nDESCRIPTION: Configures polynomial cost parameters for generators and external grid, then runs the optimal power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_curtail.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 0, 'gen', cp1_eur_per_mw=-1)\npp.create_poly_cost(net, 1, 'gen', cp1_eur_per_mw=-1)\npp.create_poly_cost(net, 0, 'ext_grid', cp1_eur_per_mw=0)\npp.runopp(net, verbose=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Q Capability Curve Characteristics in pandapower\nDESCRIPTION: Function for creating reactive power capability curve characteristics for static generators in pandapower. This is used to define the reactive power limits based on active power output.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/sgen.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.control.util.create_q_capability_curve_characteristics_object\n```\n\n----------------------------------------\n\nTITLE: Importing Libraries for CIM CGMES to pandapower Conversion\nDESCRIPTION: This snippet imports the required libraries and modules for converting CIM CGMES files to pandapower format. It includes pandapower, OS operations, and pandas for data manipulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/cim2pp.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\nimport pandas as pd\n\nimport pandapower as pp\nfrom pandapower.converter import from_cim as cim2pp\n```\n\n----------------------------------------\n\nTITLE: Creating Cost Functions for Maximizing Load in pandapower OPF\nDESCRIPTION: Creates cost functions to maximize load consumption and storage by assigning a negative linear cost coefficient, incentivizing higher power consumption.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/formulation.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 0, 'load', cp1_eur_per_mw=-1)\npp.create_poly_cost(net, 0, 'storage', cp1_eur_per_mw=-1)\npp.create_pwl_cost(net, 0, \"load\", [[net.load.min_p_mw.at[0], net.load.max_p_mw.at[0], -1]])\npp.create_pwl_cost(net, 0, \"storage\", [[net.storage.min_p_mw.at[0], net.storage.max_p_mw.at[0], -1]])\n```\n\n----------------------------------------\n\nTITLE: Load Power Equations with ZIP Model\nDESCRIPTION: Mathematical formulas for calculating the active and reactive power of the load considering the ZIP model components and voltage dependency. These equations incorporate scaling factors and voltage-dependent terms.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/load.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\nP_{load} =&  p\\_mw \\cdot scaling \\cdot (p_{const} + z_{const} \\cdot V^2 + i_{const} \\cdot V ) \\\\\nQ_{load} =&  q\\_mvar \\cdot scaling \\cdot (p_{const} + z_{const} \\cdot V^2 + i_{const} \\cdot V)\n```\n\n----------------------------------------\n\nTITLE: Static Generator PQ Equations in LaTeX\nDESCRIPTION: Mathematical equations showing how PQ values are calculated from parameter table values, using scaling factors.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/asymmetric_sgen.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nP_{sgen} &= p\\_mw \\cdot scaling \\\\\nQ_{sgen} &= q\\_mvar \\cdot scaling \\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow Analysis\nDESCRIPTION: Executes a regular power flow calculation to verify the DC line model operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_dcline.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Finding Connected Components\nDESCRIPTION: Shows how to identify connected buses at the same voltage level by excluding transformers from the network graph.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/examples.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.topology import create_nxgraph, connected_components\n\nmg_no_trafos = create_nxgraph(net, include_trafos = False)\ncc = connected_components(mg_no_trafos)\n```\n\n----------------------------------------\n\nTITLE: Plotting Line Temperature vs Current for Different Solar Radiation Levels in Python\nDESCRIPTION: This code snippet creates a plot using matplotlib to visualize the relationship between line temperature and current for different solar radiation scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nax=plt.subplot()\nax.plot(np.vstack([t_0, t_500, t_1000]).T, label=[\"0 W/m²\", \"500 W/m²\", \"1000 W/m²\"])\nax.grid(True)\nax.set_ylabel('Line temperature (°C)')\nax.set_xlabel('Current (A)')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Loading Grid Data with pandapower in Python\nDESCRIPTION: This snippet imports the necessary libraries and defines a function to create a cigre medium voltage grid with controllable storage. It sets limits for bus voltage and line loading, ensuring that switches are closed, and adds a storage device to a specified bus.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_storage.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\n\ndef cigre_grid():\n    net = nw.create_cigre_network_mv(\"pv_wind\")\n    # set some limits\n    min_vm_pu = 0.95\n    max_vm_pu = 1.05\n    \n    net[\"bus\"].loc[:, \"min_vm_pu\"] = min_vm_pu\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = max_vm_pu\n    \n    net[\"line\"].loc[:, \"max_loading_percent\"] = 100.\n    \n    # close all switches\n    net.switch.loc[:, \"closed\"] = True\n    # add storage to bus 10\n    pp.create_storage(net, 10, p_mw=0.5, max_e_mwh=.2, soc_percent=0., q_mvar=0., controllable=True)\n\n    return net\n\n```\n\n----------------------------------------\n\nTITLE: Configuring Cost Parameters for OPF\nDESCRIPTION: Sets up cost parameters for external grids and defines network constraints for voltage and line loading.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_dcline.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncosteg0 = pp.create_poly_cost(net, 0, 'ext_grid', cp1_eur_per_mw=10)\ncosteg1 = pp.create_poly_cost(net, 1, 'ext_grid', cp1_eur_per_mw=8)\nnet.bus['max_vm_pu'] = 1.5\nnet.line['max_loading_percent'] = 1000\n```\n\n----------------------------------------\n\nTITLE: Calculating Tap Changer Position for Three-Winding Transformer\nDESCRIPTION: Formula to calculate the tap changer position for a three-winding transformer. This equation determines the effect of the tap changer on the transformer's voltage ratio.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo3w.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nn_tap = 1 + (tap_pos - tap_neutral) * (tap_st_percent / 100)\n```\n\n----------------------------------------\n\nTITLE: Piecewise Linear Cost Function Creation\nDESCRIPTION: Shows the change in piecewise linear cost function definition between versions, with improved clarity in cost and range specification.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.create_piecewise_linear_costs(net, 3, \"gen\", [(0, 0), (-10000, -50), (-30000, -250)])\n```\n\nLANGUAGE: python\nCODE:\n```\npp.create_pwl_cost(net, 3, \"gen\", [(0, 10, 0.5), (10, 30, 1.)])\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow with Updated Controller in Python\nDESCRIPTION: This code runs a power flow calculation with the updated DiscreteTapControl.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.runpp(net, run_control=True)\n```\n\n----------------------------------------\n\nTITLE: Plotting Grid Model with Pandapower in Python\nDESCRIPTION: Uses pandapower's plotting module to visualize the cigre medium voltage grid model. It relies on the matplotlib library to enable inline plotting. This snippet runs independently, visualizing the network state.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plot\n%matplotlib inline\nplot.simple_plot(net)\n```\n\n----------------------------------------\n\nTITLE: Filling Missing Geocoordinates in pandapower Network\nDESCRIPTION: This code snippet fills missing geocoordinates in the pandapower network by copying the first available coordinate to all missing entries. This is necessary for plotting the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/cim2pp.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nbus_geo = net.bus.geo.iloc[0]\nnet.bus.geo.fillna(bus_geo, inplace=True)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Ybus Matrix in pandapower\nDESCRIPTION: Defines a function to visualize the Ybus matrix using matplotlib's spy() function, including axis labels and grid lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as mpl\nimport numpy as np\n\nimport pandapower as pp\nimport pandapower.networks as nw\nimport pandapower.plotting as plt\nfrom pandapower.plotting import get_collection_sizes\n\ndef plot_ybus(net=None, ax=None, ybus=None):\n    if ax is None:\n        fig, ax = mpl.subplots(1, 2)\n    if ybus is None:\n        ybus = net._ppc[\"internal\"][\"Ybus\"]\n    ax.spy(ybus)\n    ax.set_title(\"Ybus shape {}\\n\".format(str(ybus.shape)))\n    ax.set_xticks(np.arange(ybus.shape[0]))\n    ax.set_xticklabels(np.arange(ybus.shape[0]))\n    ax.set_yticklabels(np.arange(ybus.shape[1]))\n    ax.set_yticks(np.arange(ybus.shape[1]))\n\n    ax.grid(which=\"both\", linestyle=\"dotted\")\n```\n\n----------------------------------------\n\nTITLE: Finding Standard Types by Parameters in PandaPower\nDESCRIPTION: Function reference for finding standard types based on parameters using pandapower.find_std_type_by_parameter\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npandapower.find_std_type_by_parameter\n```\n\n----------------------------------------\n\nTITLE: Ward Shunt Admittance Equation\nDESCRIPTION: Mathematical equation for calculating the shunt admittance component of a Ward equivalent\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ward.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{y}_{shunt} &= \\frac{pz\\_mw + j \\cdot qz\\_mvar}{S_{N}}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Creating DC Line in Network\nDESCRIPTION: Removes an existing line and creates a DC line between buses 4 and 5 with specified parameters for power flow.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents_workarounds.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.line.drop([2],inplace=True)\npp.create_dcline(net, 4, 5, 50, 0.5, 0.7, 1.0, 1.0)\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Accessing Jacobian Matrix in pandapower\nDESCRIPTION: Demonstrates how to access and display the Jacobian matrix from the last iteration of the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet._ppc[\"internal\"][\"J\"].todense()\n```\n\n----------------------------------------\n\nTITLE: Setting parameters using .at and .loc\nDESCRIPTION: Shows how to set single and multiple parameters of network elements using .at and .loc methods.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.line.length_km.at[5] = 3.2\nnet.line.at[5, \"length_km\"] = 3.2\n\nnet.line.length_km.loc[[4,6]] = [1.8, 2.2]\n\nprint(\"Line lengths after parameter setting:\")\nnet.line.length_km.loc[[4,5,6]]\n```\n\n----------------------------------------\n\nTITLE: Data Source Creation\nDESCRIPTION: Creates data source for load profiles by reading CSV files and calculating reactive power using power factor values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_data_source():\n    profiles = pd.DataFrame()\n    for loadprofile,file in (loadshapes[['Name','File']].values):\n        file_path = os.path.join(load_path, file)\n        profiles[loadprofile] = pd.read_csv(file_path).mult.values * 1e-3 \n        profiles[loadprofile+'_Q'] = profiles[loadprofile] * np.tan(\n                    np.arccos(float(loads[loads.Yearly==loadprofile].PF.values)))    \n    ds = DFData(profiles)\n    return profiles, ds\n```\n\n----------------------------------------\n\nTITLE: Finding Connected Components in Network\nDESCRIPTION: This example retrieves all buses connected to a specific bus by creating a MultiGraph and using the connected_component function from the topology package. It also shows how to define nogobuses and notravbuses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, nogobuses={1})\narea = top.connected_component(mg, 2)\nset(area)\n```\n\n----------------------------------------\n\nTITLE: Calculating Generator Power Output in pandapower\nDESCRIPTION: Formulas for calculating the generator's active power output and bus voltage magnitude based on input parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/gen.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nP_gen = p_mw * scaling\nv_bus = vm_pu\n```\n\n----------------------------------------\n\nTITLE: Calculating DC Bus Power Flow Results in Python\nDESCRIPTION: This snippet shows the mathematical formulas used to calculate voltage magnitude and active power for DC buses in pandapower. It defines how voltage magnitude (vm_pu) and active power (p_mw) are computed based on complex bus voltage and apparent power.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/bus_dc.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nvm_pu = |V_bus|\np_mw = Re(sum(S_bus, n))\n```\n\n----------------------------------------\n\nTITLE: Result Parameter Calculations - LaTeX Math Formula\nDESCRIPTION: Formulas for calculating the result parameters including voltage magnitude and power components.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/xward.rst#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nvm\\_pu &= v_{bus} \\\\\np\\_mw &= P_{const} + Re(\\frac{\\underline{V}_{bus}^2}{\\underline{Y}_{shunt}}) + Re(\\underline{I}_{int} \\cdot \\underline{V}_{bus}) \\\\\nq_mvar &= Q_{const} + Im(\\frac{\\underline{V}_{bus}^2}{\\underline{Y}_{shunt}} + Im(\\underline{I}_{int} \\cdot \\underline{V}_{bus}) )\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Parameter Renaming in Controllers for pandapower 3.0\nDESCRIPTION: Demonstrates the parameter renaming in controllers for more consistency. Controllers now refer to net elements via 'element' and 'element_index' instead of type-specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update30.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# OLD (before v3.0)\nTrafoController(net, trafotable=\"trafo\", trafotype=\"2W\", tid=1)  # type-specific parameters\n\n# NEW (v3.0+)\nTrafoController(net, element=\"trafo\", element_index=1)  # consistent naming scheme\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature for Different Air Temperatures in Python\nDESCRIPTION: This set of code snippets calculates the overhead line temperature for three different air temperature scenarios (0°C, 20°C, and 40°C) using the calc_a0_a1_a2_tau and calc_T_ngoko functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nv_m_per_s = 0.5\nt_air = 0\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_0 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nt_air = 20\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_20 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\nLANGUAGE: python\nCODE:\n```\nt_air = 40\na0, a1, a2, tau = calc_a0_a1_a2_tau(t_air, t_max, t_ref, r_ref_ohm_per_m,\n                                    conductor_outer_diameter_m, mc_joule_per_m_k,\n                                    v_m_per_s, wind_angle_degree, s_w_per_square_meter)\n\nt_40 = [calc_T_ngoko(i**2, a0, a1, a2, None, None, None) for i in range(601)]\n```\n\n----------------------------------------\n\nTITLE: Displaying Line Results After TDPF\nDESCRIPTION: This code displays the results for the lines in the network after running the power flow calculation with the TDPF option enabled, allowing for observation of temperature-dependent parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line\n```\n\n----------------------------------------\n\nTITLE: Transformer Tap Changer Type Changes in pandapower 3.0\nDESCRIPTION: Illustrates the change from boolean tap_phase_shifter to string-based tap_changer_type for explicit representation of transformer tap changer types.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update30.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# OLD (before v3.0)\ntap_phase_shifter=True  # boolean value\ntap_phase_shifter=False  # boolean value\n\n# NEW (v3.0+)\ntap_changer_type=\"Symmetrical\"  # explicit string value\ntap_changer_type=\"Ratio\"  # explicit string value\ntap_changer_type=\"Ideal\"  # explicit string value\n```\n\n----------------------------------------\n\nTITLE: Loading Multi-Voltage Level Network in PandaPower\nDESCRIPTION: Auto-imports a complex example network that demonstrates multiple voltage levels (high, medium, and low voltage) typical in European distribution networks. Includes various utility types, line lengths, and generator types across different voltage levels.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/example.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.networks.example_multivoltage\n```\n\n----------------------------------------\n\nTITLE: Calculating Shunt Power and Admittance\nDESCRIPTION: Mathematical formulas for calculating shunt power and admittance in per-unit system. These equations show how shunt parameters are converted and scaled based on voltage and step values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/shunt.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{S}_{shunt, ref} &= (p\\_mw + j \\cdot q\\_mvar) \\cdot step\n\\end{align*}\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{Y}_{shunt} = \\frac{\\underline{S}_{shunt, ref}}{vn\\_kv^2}\n\\end{align*}\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{y}_{shunt} &= \\frac{\\underline{S}_{shunt, ref}}{V_{N}^2} \\cdot Z_{N}\\\\\n                        &= \\frac{\\underline{S}_{shunt, ref}}{V_{N}^2} \\cdot \\frac{V_{N}^2}{S_{N}} \\\\\n                        &= \\frac{S_{shunt, ref}}{S_{N}}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Comparing Voltage Magnitudes\nDESCRIPTION: Compares voltage magnitude results between PowerModels and pypower calculations using numpy.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnp.allclose(vm_pm, vm_pp)\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit with Wind Parks\nDESCRIPTION: Enables the wind park static generators and recalculates short-circuit values including their contribution.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit_renewables.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.sgen.in_service = True\nsc.calc_sc(net, ip=True)\n```\n\n----------------------------------------\n\nTITLE: Approximating Thermal Resistance\nDESCRIPTION: This snippet calculates the thermal resistance using an approximation for the rated temperature rise as described in Frank et al.  It then calculates the line temperature based on this approximation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# using an approximation for the rated temperature rise:\nr_theta_kelvin_per_mw = calc_r_theta_from_t_rise(net, 25)\ncalc_T_frank(p_loss_pu, t_air_pu, r_theta_kelvin_per_mw.values * net.sn_mva / 1, None, None, None)\n```\n\n----------------------------------------\n\nTITLE: Calculating Group Power Consumption\nDESCRIPTION: Shows how to calculate and validate total power consumption for groups including losses.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfor gr_idx, gr_name in zip([gr1_idx, gr2_idx], [gr1_name, gr2_name]):\n    print(\"Group '%s' consumes %.2f MW and %.2f Mvar.\" % (\n        gr_name, pp.group_res_p_mw(net, gr_idx), pp.group_res_q_mvar(net, gr_idx)))\n\np_val = net.res_line.p_to_mw.at[14] + net.res_trafo.p_hv_mw.at[1]\nassert np.isclose(pp.group_res_p_mw(net, gr2_idx), p_val)\n```\n\n----------------------------------------\n\nTITLE: Creating Static Generator in pandapower\nDESCRIPTION: Functions for creating static generators in pandapower networks. The first function creates a basic static generator, while the second creates a static generator with a specified power factor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/sgen.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.create_sgen\n```\n\nLANGUAGE: python\nCODE:\n```\npandapower.create_sgen_from_cosphi\n```\n\n----------------------------------------\n\nTITLE: Using the PowerFactory to pandapower Converter\nDESCRIPTION: Example showing how to use the from_pfd function to convert a PowerFactory project to a pandapower network and save it as a JSON file.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.converter.powerfactory import from_pfd\nnet = from_pfd(app, prj_name=\"Your Project Name\", path_dst=\"Save Path\")\n```\n\n----------------------------------------\n\nTITLE: Internal Voltage Source Parameters - LaTeX Math Formula\nDESCRIPTION: Parameters defining the internal voltage source modeled as a PV-node.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/xward.rst#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\np\\_mw &= 0 \\\\\nvm\\_pu &= vm\\_pu\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Group Column Renaming in pandapower 3.0\nDESCRIPTION: Shows the column renaming in the groups table for clarity and consistency with other parts of the package.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update30.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# OLD (before v3.0)\nnet.groups.element  # old column name\n\n# NEW (v3.0+)\nnet.groups.element_index  # new more explicit column name\n```\n\n----------------------------------------\n\nTITLE: Performing statistical evaluations on network elements\nDESCRIPTION: Demonstrates how to calculate statistical measures like max, min, mean, and weighted mean on network element parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Maximum Line Length: %.2f km\"%net.line.length_km.max())\nprint(\"Minimum Line Length: %.2f km\"%net.line.length_km.min())\nprint(\"Mean Line Length: %.2f km\"%net.line.length_km.mean())\n\nweighted_mean_r = (net.line.length_km * net.line.r_ohm_per_km).sum() / net.line.length_km.sum()\nprint(\"Weighted Mean Resistance: %.2f Ohm per kilometer\"%weighted_mean_r)\n```\n\n----------------------------------------\n\nTITLE: Calculating Line Temperature Again (Ngoko)\nDESCRIPTION: This snippet recalculates the line temperature using the Ngoko et al. method after running the power flow with TDPF enabled. This allows for comparison of the results with and without TDPF enabled in the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ncalc_T_ngoko(np.square(net.res_line.i_ka.values * 1e3), a0, a1, a2, None, None, None)\n```\n\n----------------------------------------\n\nTITLE: MultiGraph Creation with Non-Traversable Buses\nDESCRIPTION: Creates a NetworkX MultiGraph with specified non-traversable buses in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/create_graph.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncreate_nxgraph(net, notravbuses = [4])\n```\n\n----------------------------------------\n\nTITLE: Creating and Analyzing Overloaded Network Example\nDESCRIPTION: This snippet defines a function to create an example network with overload issues and demonstrates how to use the diagnostic function to identify these problems.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef overload_example_network():\n\n    net = pp.create_empty_network()\n\n    pp.create_bus(net, name = \"110 kV bar\", vn_kv = 110, type = 'b')\n    pp.create_bus(net, name = \"20 kV bar\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 2\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 3\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 4\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 5\", vn_kv = 20, type = 'b')\n    pp.create_bus(net, name = \"bus 6\", vn_kv = 20, type = 'b')\n    \n    pp.create_ext_grid(net, 0, vm_pu = 1)\n\n    pp.create_line(net, name = \"line 0\", from_bus = 1, to_bus = 2, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 1\", from_bus = 2, to_bus = 3, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 2\", from_bus = 3, to_bus = 4, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 3\", from_bus = 4, to_bus = 5, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 4\", from_bus = 5, to_bus = 6, length_km = 1, std_type = \"NAYY 4x150 SE\")\n    pp.create_line(net, name = \"line 5\", from_bus = 6, to_bus = 1, length_km = 1, std_type = \"NAYY 4x150 SE\")\n\n    pp.create_transformer_from_parameters(net, hv_bus = 0, lv_bus = 1, i0_percent= 0.038, pfe_kw = 11.6,\n        vkr_percent = 0.322, sn_mva = 40.0, vn_lv_kv = 22.0,\n        vn_hv_kv = 110.0, vk_percent = 17.8)\n\n    pp.create_load(net, 2, p_mw = 100, q_mvar = 0.2, name = \"load 0\")\n    pp.create_load(net, 3, p_mw = 100, q_mvar = 0.2, name = \"load 1\")\n    pp.create_load(net, 4, p_mw = 100, q_mvar = 0.2, name = \"load 2\")\n    pp.create_load(net, 5, p_mw = 100, q_mvar = 0.2, name = \"load 3\")\n    pp.create_load(net, 6, p_mw = 100, q_mvar = 0.2, name = \"load 4\")\n\n    pp.create_switch(net, bus = 1, element = 0, et = 'l')\n    pp.create_switch(net, bus = 2, element = 0, et = 'l')\n    pp.create_switch(net, bus = 2, element = 1, et = 'l')\n    pp.create_switch(net, bus = 3, element = 1, et = 'l')\n    pp.create_switch(net, bus = 3, element = 2, et = 'l')\n    pp.create_switch(net, bus = 4, element = 2, et = 'l')\n    pp.create_switch(net, bus = 4, element = 3, et = 'l', closed = 0)\n    pp.create_switch(net, bus = 5, element = 3, et = 'l')\n    pp.create_switch(net, bus = 5, element = 4, et = 'l')\n    pp.create_switch(net, bus = 6, element = 4, et = 'l')\n    pp.create_switch(net, bus = 6, element = 5, et = 'l')\n    pp.create_switch(net, bus = 1, element = 5, et = 'l')\n    \n    return net\n\noverload_net = overload_example_network()\npp.runpp(overload_net)\n\npp.diagnostic(overload_net, warnings_only = True)\n```\n\n----------------------------------------\n\nTITLE: Converting Multiple CGMES Zip Files\nDESCRIPTION: Example of converting multiple CGMES zip files to a pandapower network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncgmes_files = [r'example_cim\\CGMES_v2.4.15_SmallGridTestConfiguration_Boundary_v3.0.0.zip',\n               r'example_cim\\CGMES_v2.4.15_SmallGridTestConfiguration_BaseCase_Complete_v3.0.0.zip']\n```\n\n----------------------------------------\n\nTITLE: Accessing Estimated Bus Power Injections\nDESCRIPTION: This snippet retrieves the estimated active and reactive power injections at the buses after completing the state estimation in the pandapower network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nnet.res_bus_est.p_mw\n\nnet.res_bus_est.q_mvar\n```\n\n----------------------------------------\n\nTITLE: Initializing Grid Model and Plotting\nDESCRIPTION: Sets up the environment by importing required modules, creating a case9 example grid model, and plotting it using matplotlib.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/distributed_slack.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib\nimport matplotlib.pyplot as plt\n%matplotlib notebook\n\nfrom copy import deepcopy\nimport pandapower as pp\nimport pandapower.plotting\nfrom pandapower import networks as nw\n\nfrom IPython.display import display, Markdown\n\nnet = nw.case9()\nfig = plt.figure(figsize=(4,4))\nax = fig.add_subplot()\npp.plotting.simple_plot(net, plot_loads=True, plot_gens=True, load_size=2.5, gen_size=0.1, ax=ax);\nfig.tight_layout(pad=0)\n```\n\n----------------------------------------\n\nTITLE: Saving pandapower network to pickle format\nDESCRIPTION: Function to save a pandapower network to a pickle file. Pickle is a binary serialization format in Python.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\npandapower.to_pickle\n```\n\n----------------------------------------\n\nTITLE: Basic MultiGraph Creation in Python\nDESCRIPTION: Creates a basic NetworkX MultiGraph from a PandaPower network without any special configurations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/create_graph.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncreate_nxgraph(net, respect_switches = False)\n```\n\n----------------------------------------\n\nTITLE: Creating Unbalanced Load\nDESCRIPTION: Creates an asymmetric three-phase load with different power values for each phase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.create_asymmetric_load(net, bus_load, p_a_mw=50, q_a_mvar=50, p_b_mw=10, q_b_mvar=15,\n                   p_c_mw=10, q_c_mvar=5)\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage Lines in Python\nDESCRIPTION: Imports line data from a CSV file and creates line objects connecting low voltage buses. Each line is assigned a standard type, length, and name based on the imported data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# create lines\nlv_lines = pd.read_csv('example_advanced/lv_lines.csv', sep=';', header=0, decimal=',')\nfor _, lv_line in lv_lines.iterrows():\n    from_bus = pp.get_element_index(net, \"bus\", lv_line.from_bus)\n    to_bus = pp.get_element_index(net, \"bus\", lv_line.to_bus)\n    pp.create_line(net, from_bus, to_bus, length_km=lv_line.length, std_type=lv_line.std_type, name=lv_line.line_name)\n\n# show only low voltage lines\nnet.line[net.line.from_bus.isin(lv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Preparing Power Flow Calculation with Time Series Data\nDESCRIPTION: This snippet prepares for power flow calculations by constructing a DataFrame of timeseries data for different grid elements. It uses Pandapower's DFData to format the DataFrame, sets up constant controllers for the variably distributed input data, and configures an output writer to log variables of interest.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# construct time series DataFrame\npower_df = pd.DataFrame({\n    \"p_load_r4\"  : net.load.at[load_r4  , \"p_mw\"]   * load_r4_distr,\n    \"q_load_r4\"  : net.load.at[load_r4  , \"q_mvar\"] * load_r4_distr,\n    \"p_load_ci9\" : net.load.at[load_ci9 , \"p_mw\"]   * load_ci9_distr,\n    \"q_load_ci9\" : net.load.at[load_ci9 , \"q_mvar\"] * load_ci9_distr,\n    \"p_sgen_pv10\": net.sgen.at[sgen_pv10, \"p_mw\"]   * sgen_pv10_distr,\n    \"q_sgen_pv10\": net.sgen.at[sgen_pv10, \"q_mvar\"] * sgen_pv10_distr,\n})\nts_data = pp.timeseries.DFData(power_df)\n\n# create constant controllers for variable parameters\nfor et, var, eidx, pn in zip(\n    [\"load\", \"load\", \"sgen\", \"sgen\"],\n    [\"p_mw\", \"q_mvar\"]*2,\n    [[load_r4, load_ci9]]*2+[sgen_pv10]*2,\n    [[\"p_load_r4\", \"p_load_ci9\"], [\"q_load_r4\", \"q_load_ci9\"], \"p_sgen_pv10\", \"q_sgen_pv10\"],\n    ):\n        _ = pp.control.ConstControl(net, element=et, variable=var, element_index=eidx,\n                                    profile_name=pn, data_source=ts_data)\n\n# define output writer and desired variables to be saved\now = pp.timeseries.OutputWriter(net)\now.log_variable(\"res_bus\", \"vm_pu\")\now.log_variable(\"res_line\", \"loading_percent\")\now.log_variable(\"res_trafo\", \"loading_percent\")\n```\n\n----------------------------------------\n\nTITLE: DC Line Power Flow Equations in LaTeX\nDESCRIPTION: Mathematical equations defining the power flow calculations for DC lines, showing relationships between from/to sides and loss calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/dcline.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n    P_{from} &= p\\_mw \\\\\n    P_{to} &= - (p\\_mw - loss\\_mw) \\cdot (1 - \\frac{loss\\_percent}{100})\n    \n   \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Converting UCTE-DEF files to pandapower format using from_ucte function\nDESCRIPTION: This code snippet references the from_ucte function in the pandapower.converter.ucte module that converts UCTE-DEF files to pandapower format. The function requires specifying the location of the UCTE file to be converted.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/ucte.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.converter.ucte.from_ucte.from_ucte\n```\n\n----------------------------------------\n\nTITLE: Changing Standard Types in PandaPower\nDESCRIPTION: Function reference for modifying standard types using pandapower.change_std_type\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npandapower.change_std_type\n```\n\n----------------------------------------\n\nTITLE: Setting Transformer Constraints for OPF - Python\nDESCRIPTION: This snippet sets constraints for the 3W-transformer and power lines before rerunning the AC optimal power flow optimization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo3w[\"max_loading_percent\"] = 50\nnet.line[\"max_loading_percent\"] = 20\ntry:\n    pp.runpm_ac_opf(net)\nexcept:\n    print(\"Cannot be performed due to [WinError 3] - Can't find file python39.dll\")\n```\n\n----------------------------------------\n\nTITLE: Adjusting Load and Running Power Flow with Updated Conditions\nDESCRIPTION: This snippet modifies the load in the network and re-runs the power flow simulation to evaluate the effect on active power, voltage setpoints, and transformer tap positions under new operating conditions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\nnet.load.at[0, 'p_mw'] = 20\npp.runpp(net, run_control=True)\nprint(f\"The load has active power of {net.load.at[0, 'p_mw']} MW, sgen has active power of {net.sgen.at[0, 'p_mw']} MW\")\nprint(f\"Power flowing through the transformer is {net.res_trafo.at[0, 'p_hv_mw']:.2f} MW\")\nprint(f\"Voltage setpoint from Characteristic is {c(x=net.res_trafo.at[0, 'p_hv_mw']):.3f} p. u.\")\nprint(f\"Voltage at the controlled bus is {net.res_bus.at[2, 'vm_pu']:.3f} p. u.\")\nprint(f\"Transformer tap position is {net.trafo.at[0, 'tap_pos']:.2f}\")\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: MultiGraph Creation Excluding Transformers\nDESCRIPTION: Creates a NetworkX MultiGraph while excluding transformers from the conversion process.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/create_graph.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncreate_nxgraph(net, include_trafos = False)\n```\n\n----------------------------------------\n\nTITLE: Validating Results Using Assertions in Python\nDESCRIPTION: This snippet asserts that the results from the direct calculation in Pandapower and via controllers are the same, ensuring reliability and correctness of the methodologies used.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nassert np.allclose(net.res_bus.vm_pu, net3.res_bus.vm_pu, atol=1e-6, rtol=0)\nassert np.allclose(net.res_bus.va_degree, net3.res_bus.va_degree, atol=1e-6, rtol=0)\n```\n\n----------------------------------------\n\nTITLE: Logging Output from PowerFactory to PandaPower Conversion\nDESCRIPTION: Example log output showing the progress and results of converting a PowerFactory network model to PandaPower format. It includes information on network elements processed, file saving, and a summary of the exported PandaPower network structure.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\nDIgSI/info - Python Script 'pp_export' started\n\n| [2016/11/14 18:34:52] DIgSI/info - the destination directory is: <C:/pp_projects/test>\n| [2016/11/14 18:34:52] DIgSI/info - gathering network elements\n| [2016/11/14 18:34:52] DIgSI/info - applying unit settings\n| [2016/11/14 18:34:54] DIgSI/info - collecting network elements\n| [2016/11/14 18:34:54] DIgSI/info - running load flow calculation\n| [2016/11/14 18:34:54] DIgSI/info - starting import to PandaPower\n| [2016/11/14 18:34:54] DIgSI/info - creating grid Summary Grid\n| [2016/11/14 18:34:54] DIgSI/info - imported 4 buses\n| [2016/11/14 18:34:54] DIgSI/info - imported 1 external grids\n| [2016/11/14 18:34:54] DIgSI/info - imported 2 loads\n| [2016/11/14 18:34:54] DIgSI/info - imported 1 mv loads\n| [2016/11/14 18:34:54] DIgSI/info - imported 1 trafos\n| [2016/11/14 18:34:54] DIgSI/info - imported 1 impedances\n| [2016/11/14 18:34:54] DIgSI/info - imported 2 lines\n| [2016/11/14 18:34:54] DIgSI/info - created net and controller\n| [2016/11/14 18:34:54] DIgSI/info - saving file to: <C:/pp_projects/test/test.json>\n| [2016/11/14 18:34:54] DIgSI/info - exported net:\n\nThis pandapower network includes the following parameter tables:\n    - gen (1 elements)\n    - switch (10 elements)\n    - load (3 elements)\n    - bus (13 elements)\n    - trafo (1 elements)\n    - line (13 elements)\n    - bus_geodata (13 elements)\n    - sgen (1 elements)\n    - impedance (1 elements)\n    - line_geodata (13 elements)\n\nand the following results tables:\n    - res_load (3 elements)\n    - res_gen (1 elements)\n    - res_bus (4 elements)\n    - res_sgen (1 elements)\n    - res_trafo (1 elements)\n    - res_line (13 elements)\n\nDIgSI/info - Python Script 'pp_export' successfully executed\n```\n\n----------------------------------------\n\nTITLE: Accessing Transformer Data\nDESCRIPTION: Displays transformer data from the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nnet_create.trafo\n```\n\n----------------------------------------\n\nTITLE: Using run_control Function in pandapower (Python)\nDESCRIPTION: This snippet demonstrates an alternative way to run control simulations using the run_control function from the pandapower.control module. This method provides more flexibility in configuring the controller loop simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/control/run.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.control import run_control\nrun_control(net)\n```\n\n----------------------------------------\n\nTITLE: Single-Phase Transformer Equations\nDESCRIPTION: Mathematical equations defining power, current, and reactive power calculations for single-phase transformers at both high voltage (HV) and low voltage (LV) sides.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\np_hv_mw &= Re(\\underline{v}_{hv} \\cdot \\underline{i}^*_{hv}) \\\\\nq_hv_mvar &= Im(\\underline{v}_{hv} \\cdot \\underline{i}^*_{hv}) \\\\\np_lv_mw &= Re(\\underline{v}_{lv} \\cdot \\underline{i}^*_{lv}) \\\\\nq_lv_mvar &= Im(\\underline{v}_{lv} \\cdot \\underline{i}^*_{lv}) \\\\\npl_mw &= p_hv_mw + p_lv_mw \\\\\nql_mvar &= q_hv_mvar + q_lv_mvar \\\\\ni_hv_ka &= i_{hv} \\\\\ni_lv_ka &= i_{lv}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Creating Line with Standard Type\nDESCRIPTION: Creates a transmission line using the previously defined custom line type.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.create_line(net, from_bus = bus_eg, to_bus = bus_load, length_km = 50.0, std_type=\"example_type\")\n```\n\n----------------------------------------\n\nTITLE: Creating Medium Voltage Buses in PandaPower Network\nDESCRIPTION: Creates multiple medium voltage buses with different voltage levels (20kV and 10kV).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.create_bus(net, name='Bus MV0 20kV', vn_kv=20, type='n')\nfor i in range(8):\n    pp.create_bus(net, name='Bus MV%s' % i, vn_kv=10, type='n')\n\n#show only medium voltage bus table\nmv_buses = net.bus[(net.bus.vn_kv == 10) | (net.bus.vn_kv == 20)]\nmv_buses\n```\n\n----------------------------------------\n\nTITLE: Copying Standard Types Between Networks\nDESCRIPTION: Demonstrates how to copy standard types from one network to another.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnew_net = pp.create_empty_network()\npp.copy_std_types(from_net=net, to_net=new_net, element=\"line\")\npp.available_std_types(new_net)\n```\n\n----------------------------------------\n\nTITLE: Creating Standard Types in PandaPower\nDESCRIPTION: Function references for creating single and multiple standard types using pandapower.create_std_type and pandapower.create_std_types\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npandapower.create_std_type\npandapower.create_std_types\n```\n\n----------------------------------------\n\nTITLE: Calculating Three-Phase Power in Balanced Systems (LaTeX)\nDESCRIPTION: Formula for calculating three-phase power in a balanced system using phase-to-phase voltage and phase current.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/units.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nS = 3 \\cdot V_{ph-e} \\cdot I_{ph-e}\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Four Bus System in Pandapower\nDESCRIPTION: Initializes a simple four-bus power system network using pandapower and sets transformer shift degree to 0.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport copy\nimport numpy as np\nimport pandapower as pp\nimport pandapower.networks as nw\n\nnet = nw.simple_four_bus_system()\nnet.trafo.loc[0, \"shift_degree\"] = 0.\n```\n\n----------------------------------------\n\nTITLE: Switching to Current-Based Characteristic for Tap Control\nDESCRIPTION: This snippet showcases changing the input variable for the VmSetTapControl from active power to current, using a new Characteristic defined for current-based adjustment.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\nnet.controller.at[tc.index, 'in_service'] = False\nc1 = Characteristic(net, x_values=[0, 0.2, 0.4, 0.6, 0.8, 1], y_values=[0.92, 0.97, 0.98, 1.02, 1.03, 1.08])\ntc1 = control.VmSetTapControl(net, 0, variable='i_lv_ka', characteristic_index=c1.index, tol=0.0005)\nplot_characteristic(c1,0,1,50)\n```\n\n----------------------------------------\n\nTITLE: Time Series Example Function Definition\nDESCRIPTION: Main function that orchestrates the time series analysis by creating test network, data source, controllers, and output writer.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef timeseries_example(output_dir):\n    # 1. create test net\n    net = simple_test_net()\n\n    # 2. create (random) data source\n    n_timesteps = 10\n    profiles, ds = create_data_source(n_timesteps)\n    # 3. create controllers (to control P values of the load and the sgen)\n    net = create_controllers(net, ds)\n\n    # time steps to be calculated. Could also be a list with non-consecutive time steps\n    time_steps = range(0, n_timesteps)\n\n    # 4. the output writer with the desired results to be stored to files.\n    ow = create_output_writer(net, time_steps, output_dir)\n\n    # 5. the main time series function\n    run_timeseries(net, time_steps)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Model of TCSC Impedance Calculation\nDESCRIPTION: LaTeX equation showing how the series impedance of the TCSC element is calculated, based on the reactance of the reactor, total capacitance, and thyristor firing angle.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/tcsc.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nX_{TCSC} &= \\frac{\\pi X_L}{2 (\\pi - \\alpha) + \\sin{(2\\alpha)} + \\frac{\\pi X_L}{X_{Cvar}}}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Diagnostic and Creation Functions for Shunt Characteristics\nDESCRIPTION: Functions for performing sanity checks on shunt characteristic tables and creating spline characteristic objects. These help in managing and validating shunt characteristics.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/shunt.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npandapower.control.shunt_characteristic_table_diagnostic\n```\n\nLANGUAGE: python\nCODE:\n```\npandapower.control.create_shunt_characteristic_object\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Pandapower Transformer Tap Control in Python\nDESCRIPTION: This snippet imports necessary libraries and modules for executing transformer tap control strategies using the Pandapower library in Python. Dependencies include Pandapower for power system modeling and scipy for numerical operations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport os\nimport numpy as np\nimport pandas as pd\nimport tempfile\nimport pandapower as pp\nimport pandapower.control\nimport pandapower.control as control\nfrom pandapower.control import Characteristic, SplineCharacteristic\nfrom pandapower.control.util.auxiliary import plot_characteristic\nfrom scipy.interpolate import interp1d\n```\n\n----------------------------------------\n\nTITLE: Relaxing Voltage Constraints\nDESCRIPTION: Modifies the maximum voltage constraints and reruns the optimal power flow calculation to allow for increased generator feed-in.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_curtail.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.bus[\"max_vm_pu\"] = 1.05\npp.runopp(net)\n```\n\n----------------------------------------\n\nTITLE: Transforming Impedance Values to Per Unit System in pandapower\nDESCRIPTION: Mathematical formula showing how transformer impedance values are converted to the per unit system based on network and transformer reference values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nZ_{N} &= \\frac{V_{N}^2}{S_{N}} \\\\\nZ_{ref, trafo} &= \\frac{vn\\_lv\\_kv^2 \\cdot net.sn\\_mva}{sn\\_mva} \\\\\n\\underline{z} &= \\underline{z}_k \\cdot \\frac{Z_{ref, trafo}}{Z_{N}} \\\\\n\\underline{y} &= \\underline{y}_m \\cdot \\frac{Z_{N}}{Z_{ref, trafo}} \\\\\n```\n\n----------------------------------------\n\nTITLE: Calculating Bus Distances\nDESCRIPTION: Demonstrates how to calculate the shortest network route distances between buses using calc_distance_to_bus function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/examples.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.topology import calc_distance_to_bus\n\nnet.switch.closed.at[6] = 1\nnet.switch.closed.at[8] = 0\ncalc_distance_to_bus(net, 1)\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Radial Network with Fuses in PandaPower\nDESCRIPTION: Creates a radial network with buses, external grid, transformer, lines and fuses. Includes configuration for buses, lines, transformer and switch elements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n\ndef fuse_example_net1():\n    net = pp.create_empty_network()\n    # create buses\n    pp.create_buses(net, nr_buses=5, vn_kv=[20, 0.4, 0.4, 0.4, 0.4], index=[0, 1, 2, 3, 4], name=None, type=\"n\",\n                    geodata=[(0, 0), (0, -2), (0, -4), (0, -6), (0, -8)])\n    \n    # create external grid\n    pp.create_ext_grid(net, 0, vm_pu=1.0, va_degree=0, s_sc_max_mva=100, s_sc_min_mva=50, rx_max=0.1, rx_min=0.1)\n    pp.create_lines_from_parameters(net, from_buses=[1, 2], to_buses=[2, 3], length_km=[0.1, 0.1], r_ohm_per_km=0.2067,\n                                    x_ohm_per_km=0.080424, c_nf_per_km=261, name=None, index=[0, 1], max_i_ka=0.27)\n    \n    net.line[\"endtemp_degree\"] = 250\n    # create transformer\n    pp.create_transformer(net, hv_bus=0, lv_bus=1, std_type=\"0.63 MVA 20/0.4 kV\")\n    \n    # Define trafo fuses\n    pp.create_switches(net, buses=[0, 1], elements=[0, 0], et='t', type=\"fuse\")\n    \n    # Define line fuses\n    pp.create_switches(net, buses=[1, 2], elements=[0, 1], et='l', type=\"fuse\")\n    \n    # Define load fuse (bus-bus switch)\n    pp.create_switch(net, bus=3, element=4, et='b', type=\"fuse\", z_ohm=0.0001)\n    \n    # define load\n    pp.create_load(net, bus=4, p_mw=0.1, q_mvar=0, const_z_percent=0, const_i_percent=0, sn_mva=.1,\n                   name=None, scaling=1., index=0)\n    return net\n\nnet = fuse_example_net1()\nnet\n```\n\n----------------------------------------\n\nTITLE: Customizing Diagnostic Report Output\nDESCRIPTION: These snippets show how to customize the diagnostic report by using different options like warnings_only and report_style.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/diagnostic.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# report with warnings_only\npp.diagnostic(faulty_net, warnings_only=True)\n```\n\nLANGUAGE: python\nCODE:\n```\n# report with summaries only\npp.diagnostic(faulty_net, report_style=\"compact\")\n```\n\n----------------------------------------\n\nTITLE: Power-Based Loading Calculation\nDESCRIPTION: Formula for calculating transformer loading percentage based on power measurements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nloading_percent &= max( \\frac{i_{hv} \\cdot v_{hv}}{sn_mva}, \\frac{i_{lv} \\cdot v_{lv}}{sn_mva}) \\cdot 100\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Defining DataSource Base Class in Python for pandapower\nDESCRIPTION: The DataSource base class is used in const controllers for time series simulations. It provides a get_time_step_value method to retrieve values for each time step.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/data_source.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass DataSource:\n    def get_time_step_value(time_step):\n        # Implementation not shown\n```\n\n----------------------------------------\n\nTITLE: Loading Standard Types in PandaPower\nDESCRIPTION: Function reference for loading standard types using pandapower.load_std_type\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npandapower.load_std_type\n```\n\n----------------------------------------\n\nTITLE: Calculating Three-Phase Power with Phase-to-Phase Values (LaTeX)\nDESCRIPTION: Formula for calculating three-phase power using phase-to-phase voltage and current in a balanced system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/units.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nS = \\sqrt3 \\cdot V_{ph-ph} \\cdot I_{ph-ph}\n```\n\n----------------------------------------\n\nTITLE: Generating Overview Plot for CIGRE MV Network\nDESCRIPTION: Creates and plots an overview of the CIGRE medium voltage network, including network topology and Ybus matrix visualizations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnet = nw.create_cigre_network_mv()\nplot_overview(net)\n```\n\n----------------------------------------\n\nTITLE: Setting Voltage Setpoints\nDESCRIPTION: Configures voltage setpoint parameters for buses with DERs.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet.bus[\"pm_param/setpoint_v\"] = None\nnet.bus[\"pm_param/setpoint_v\"].loc[net.sgen.bus] = 0.99\n```\n\n----------------------------------------\n\nTITLE: Importing shortcircuit test module\nDESCRIPTION: This snippet imports all functions from the shortcircuit test module, which likely contains predefined test cases for short circuit analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.test.shortcircuit.test_1ph import *\n```\n\n----------------------------------------\n\nTITLE: SVC Impedance Calculation in LaTeX\nDESCRIPTION: Mathematical formula for calculating the shunt impedance (X_SVC) of the SVC element based on reactor reactance, total capacitance, and thyristor firing angle.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/svc.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nX_{SVC} = \\frac{\\pi X_L}{2 (\\pi - \\alpha) + \\sin{(2\\alpha)} + \\frac{\\pi X_L}{X_{Cvar}}}\n```\n\n----------------------------------------\n\nTITLE: Saving pandapower network to PostgreSQL database\nDESCRIPTION: Function to save a pandapower network to a PostgreSQL database. PostgreSQL is a powerful, open-source object-relational database system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\npandapower.to_postgresql\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Electrical Network in Python\nDESCRIPTION: This function initializes and constructs an empty network. It sets a specified voltage level, adds buses, external grids, lines, and transformer connections, and prepares characteristic tables for both two- and three-winding transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef create_net():\n    net = pp.create_empty_network()\n    vn_kv = 20\n    b1 = pp.create_bus(net, vn_kv=vn_kv)\n    pp.create_ext_grid(net, b1, vm_pu=1.01)\n    b2 = pp.create_bus(net, vn_kv=vn_kv)\n    l1 = pp.create_line_from_parameters(net, b1, b2, 12.2, r_ohm_per_km=0.08, x_ohm_per_km=0.12,\n                                        c_nf_per_km=300, max_i_ka=.2, df=.8)\n    for i in range(2):\n        add_trafo_connection(net, b2)\n        net.trafo.loc[i, \"id_characteristic_table\"] = i\n        net.trafo.loc[i,\"tap_dependency_table\"] = True\n\n    # Adding the characteristics data for two- and three-winding transformers into the trafo_characteristic_table\n    net['trafo_characteristic_table'] = pd.DataFrame(\n    columns=['id_characteristic', 'step', 'voltage_ratio', 'angle_deg', 'vk_percent',\n             'vkr_percent', 'vkr_hv_percent', 'vkr_mv_percent',\n             'vkr_lv_percent', 'vk_hv_percent', 'vk_mv_percent',\n             'vk_lv_percent'])\n    trafo_data = {\n        'id_characteristic': [0, 0, 0, 0, 0, 1, 1, 1, 1, 1],\n        'step': [-2, -1, 0, 1, 2, -2, -1, 0, 1, 2],\n        'voltage_ratio': [0.95, 0.97, 1.0, 1.03, 1.05, 0.95, 0.97, 1.0, 1.03, 1.05],\n        'angle_deg': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        'vk_percent': [5, 5.2, 6, 6.8, 7, 5, 5.2, 6, 6.8, 7],\n        'vkr_percent': [1.3, 1.4, 1.44, 1.5, 1.6, 1.3, 1.4, 1.44, 1.5, 1.6],\n        'vkr_hv_percent': np.nan,\n        'vkr_mv_percent': np.nan,\n        'vkr_lv_percent': np.nan,\n        'vk_hv_percent': np.nan,\n        'vk_mv_percent': np.nan,\n        'vk_lv_percent': np.nan\n    }\n\n    net['trafo_characteristic_table'] = pd.DataFrame(trafo_data)\n\n    trafo3w_data = {\n        'id_characteristic': [2, 2, 2, 2, 2, 3, 3, 3, 3, 3],\n        'step': [-2, -1, 0, 1, 2, -2, -1, 0, 1, 2],\n        'voltage_ratio': [0.95, 0.97, 1.0, 1.03, 1.05, 0.95, 0.97, 1.0, 1.03, 1.05],\n        'angle_deg': [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n        'vk_percent': np.nan,\n        'vkr_percent': np.nan,\n        'vkr_hv_percent': [0.27, 0.28, 0.3, 0.32, 0.33, 0.27, 0.28, 0.3, 0.32, 0.33],\n        'vkr_mv_percent': [0.27, 0.28, 0.3, 0.32, 0.33, 0.27, 0.28, 0.3, 0.32, 0.33],\n        'vkr_lv_percent': [0.27, 0.28, 0.3, 0.32, 0.33, 0.27, 0.28, 0.3, 0.32, 0.33],\n        'vk_hv_percent': [0.85, 0.9, 1, 1.1, 1.15, 0.85, 0.9, 1, 1.1, 1.15],\n        'vk_mv_percent': [0.85, 0.9, 1, 1.1, 1.15, 0.85, 0.9, 1, 1.1, 1.15],\n        'vk_lv_percent': [0.85, 0.9, 1, 1.1, 1.15, 0.85, 0.9, 1, 1.1, 1.15],\n    }\n    data_frame = pd.DataFrame(trafo3w_data)\n    net['trafo_characteristic_table'] = pd.concat([net['trafo_characteristic_table'], data_frame], sort=False)\n    return net\n```\n\n----------------------------------------\n\nTITLE: Creating Cost Parameters\nDESCRIPTION: Adds polynomial cost parameters for generators and external grid connections.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfor idx in net.sgen.index:\n    pp.create_poly_cost(net, idx, \"sgen\", 1.0)\nfor idx in net.gen.index:\n    pp.create_poly_cost(net, idx, \"gen\", 1.0)\nfor idx in net.ext_grid.index:\n    pp.create_poly_cost(net, idx, \"ext_grid\", 1.0)\n```\n\n----------------------------------------\n\nTITLE: Line Impedance Calculations in Power Systems\nDESCRIPTION: Mathematical formulas showing how line impedances and admittances are calculated from per-kilometer parameters. Includes conversions for both sequence components (zero, positive, negative) and per-unit system transformations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/line.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\underline{Z_{1 or 2}} = (r\\_ohm\\_per\\_km + j \\cdot x\\_ohm\\_per\\_km) \\cdot \\frac{length\\_km}{parallel}\n\\underline{Y_{1 or 2}}= (g\\_us\\_per\\_km \\cdot 1 \\cdot 10^-6 + j \\cdot 2 \\pi f \\cdot c\\_nf\\_per\\_km \\cdot 1 \\cdot 10^-9) \\cdot length\\_km \\cdot parallel\n\\underline{Z_{0}} = (r0\\_ohm\\_per\\_km + j \\cdot x0\\_ohm\\_per\\_km) \\cdot \\frac{length\\_km}{parallel}\n\\underline{Y_{0}} = (g\\_us\\_per\\_km \\cdot 1 \\cdot 10^-6 + j \\cdot 2 \\pi f \\cdot c0\\_nf\\_per\\_km \\cdot 1 \\cdot 10^-9) \\cdot length\\_km \\cdot parallel\n```\n\n----------------------------------------\n\nTITLE: Creating Transformer with Characteristics\nDESCRIPTION: Creates a new transformer with specific characteristics and dependencies.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\npp.create_transformer(net_create, hv_bus=net_create.trafo.at[0, 'hv_bus'],\n                      lv_bus=net_create.trafo.at[0, 'lv_bus'], std_type=\"0.25 MVA 20/0.4 kV\", tap_pos=2, \n                      tap_dependency_table=True, id_characteristic_table = 0)\npp.control.create_trafo_characteristic_object(net_create)\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage CIGRE Network\nDESCRIPTION: Creates a low voltage distribution network with switches, loads, external grid, lines, transformers, buses, and bus geodata. Represents the smallest voltage level in the CIGRE benchmark systems.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/cigre.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_cigre_network_lv\n\nnet = create_cigre_network_lv()\n```\n\n----------------------------------------\n\nTITLE: Deleting Standard Types in PandaPower\nDESCRIPTION: Function reference for removing standard types using pandapower.delete_std_type\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npandapower.delete_std_type\n```\n\n----------------------------------------\n\nTITLE: Simple Plotting with Pandapower and Plotly\nDESCRIPTION: Demonstrates how to use the simple_plotly() function to create a basic interactive plot of a pandapower network. This example uses the mv_oberrhein network from the pandapower.networks package.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/built-in_plots.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.plotting.plotly import simple_plotly\nfrom pandapower.networks import mv_oberrhein\nnet = mv_oberrhein()\nsimple_plotly(net)\n```\n\n----------------------------------------\n\nTITLE: Calculating Single-Phase Power in Unbalanced Systems (LaTeX)\nDESCRIPTION: Formula for calculating single-phase power using phase-to-phase voltage and phase current in an unbalanced system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/units.rst#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\nS_{ph-e} = \\frac{V_{ph-ph} \\cdot I_{ph-ph}}{\\sqrt3 }\n```\n\n----------------------------------------\n\nTITLE: Creating Impedance and Extended Ward Equivalents in PandaPower\nDESCRIPTION: Adds impedance and extended ward equivalent elements to the network with specified parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Impedance\npp.create_impedance(net, pp.get_element_index(net, \"bus\", 'Bus HV3'), pp.get_element_index(net, \"bus\", 'Bus HV1'), \n                    rft_pu=0.074873, xft_pu=0.198872, sn_mva=100, name='Impedance')\n\n# show impedance table\nnet.impedance\n```\n\nLANGUAGE: python\nCODE:\n```\n# xwards\npp.create_xward(net, pp.get_element_index(net, \"bus\", 'Bus HV3'), ps_mw=23.942, qs_mvar=-12.24187, pz_mw=2.814571, \n                qz_mvar=0, r_ohm=0, x_ohm=12.18951, vm_pu=1.02616, name='XWard 1')\npp.create_xward(net, pp.get_element_index(net, \"bus\", 'Bus HV1'), ps_mw=3.776, qs_mvar=-7.769979, pz_mw=9.174917, \n                qz_mvar=0, r_ohm=0, x_ohm=50.56217, vm_pu=1.024001, name='XWard 2')\n\n# show xward table\nnet.xward\n```\n\n----------------------------------------\n\nTITLE: Calculating correction factor for power system unit with OLTC\nDESCRIPTION: This snippet calculates the correction factor KS for a power system unit with On-Load Tap Changer (OLTC), considering various network parameters and generator characteristics.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nv_g = net.gen.vn_kv\nv_q = net.bus.loc[net.trafo[\"hv_bus\"].values, \"vn_kv\"].values\nps_cmax = 1.1\nx_t = net.trafo[\"vk_percent\"].values / 100\nxdss_pu = net.gen.xdss_pu\nsin_phi_gen = np.sqrt(np.clip(1 - net.gen.cos_phi.values**2, 0, None))\n\nks = (v_q**2/v_g**2) * (vn_trafo_lv**2/vn_trafo_hv**2) * ps_cmax / (1 + np.abs(xdss_pu - x_t) * sin_phi_gen)\n```\n\n----------------------------------------\n\nTITLE: Setting Trafo Parameters for Reactive Power Control\nDESCRIPTION: Configures the transformer parameters to specify which side (low-voltage) is being observed for the reactive power optimization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nnet_opt.trafo[\"pm_param/side\"] = None\nnet_opt.trafo[\"pm_param/side\"][0] = \"lv\" # the observed side is the low-voltage side\n```\n\n----------------------------------------\n\nTITLE: Grid Equivalent with DC Lines\nDESCRIPTION: Demonstrates grid equivalent calculation with DC lines by modifying the network\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.drop_lines(net, [2])\npp.create_dcline(net, 4, 5, 50, 0.5, 0.7, 1.0, 1.0)\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Displaying Bus Results\nDESCRIPTION: This line of code accesses and displays the results for the buses in the power system after the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus\n```\n\n----------------------------------------\n\nTITLE: Comparing 3-Winding Transformers Simulation Times in Python\nDESCRIPTION: This snippet compares the running time for simulation between direct calculations and those involving controllers on two instances of 3-winding transformer networks, illustrating computational efficiency.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net4)\n```\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net5, run_control=True)\n```\n\n----------------------------------------\n\nTITLE: Creating and Changing Line Standard Types\nDESCRIPTION: Shows how to create a line with one standard type and then change it to another.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.create_empty_network()\nb1 = pp.create_bus(net, vn_kv=.4)\nb2 = pp.create_bus(net, vn_kv=.4)\nl2 = pp.create_line(net, from_bus=b1, to_bus=b2, length_km=0.1, std_type=\"NAYY 4x50 SE\", name=\"test_line\")\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Calculating Generator Result Parameters in pandapower\nDESCRIPTION: Formulas for calculating the generator's result parameters after power flow analysis, including active and reactive power, voltage angle, and voltage magnitude.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/gen.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\np_mw = P_gen\nq_mvar = Q_gen\nva_degree = angle(v_bus)\nvm_degree = |v_bus|\n```\n\n----------------------------------------\n\nTITLE: Managing Group Member States\nDESCRIPTION: Demonstrates how to set values for group members, including setting service status and viewing results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\npp.set_value_to_group(net, gr2_idx, \"member of group '%s'\" % gr2_name, \"name\")\n\npp.set_group_out_of_service(net, gr2_idx)\npp.runpp(net)\n\npp.set_group_in_service(net, gr2_idx)\npp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Configuring Transformer Characteristics\nDESCRIPTION: Sets transformer characteristics and dependency table settings, including handling of NaN values for voltage characteristics.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nnet6.trafo.loc[1,\"tap_dependency_table\"] = False\nnet6[\"trafo_characteristic_table\"].loc[net[\"trafo_characteristic_table\"][\"id_characteristic\"]==1, \"vk_percent\"] = np.nan\npp.control.create_trafo_characteristic_object(net6)\nnet6.trafo\n```\n\n----------------------------------------\n\nTITLE: Plotting Line Temperature vs Current for Different Wind Speeds in Python\nDESCRIPTION: This code snippet creates a plot using matplotlib to visualize the relationship between line temperature and current for different wind speed scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nax=plt.subplot()\nax.plot(np.vstack([t_05, t_2, t_5]).T, label=[\"0.5 m/s\", \"2 m/s\", \"5 m/s\"])\nax.grid(True)\nax.set_ylabel('Line temperature (°C)')\nax.set_xlabel('Current (A)')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Creating Medium Voltage CIGRE Network with PV and Wind DER\nDESCRIPTION: Creates a medium voltage network with 9 distributed energy resources including 8 photovoltaic generators and 1 wind turbine. The network maintains the base infrastructure while adding renewable generation sources.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/cigre.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_cigre_network_mv\n\nnet = create_cigre_network_mv(with_der=\"pv_wind\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Tap Factor for Longitudinal Regulator in pandapower\nDESCRIPTION: Mathematical formula showing how the tap factor is calculated for a longitudinal regulator (ratio tap changer) based on tap position and step percentage.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\nn_{tap} = 1 + (tap\\_pos - tap\\_neutral) \\cdot \\frac{tap\\_st\\_percent}{100}\n```\n\n----------------------------------------\n\nTITLE: Calculating Asynchronous Motor Impedance in LaTeX\nDESCRIPTION: These equations calculate the impedance components of an asynchronous motor. It uses parameters such as rated power, ratio of nominal to short circuit current, and R/X ratio of the motor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/voltage_source.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nZ_{k, m} = \\frac{1}{k} \\cdot \\frac{vn\\_kv^2 \\cdot 1000}{sn\\_kva} \\\\\nX_{k, m} = \\frac{Z_{sg}}{\\sqrt{1 + rx^2}} \\\\\nR_{k, m} = rx \\cdot X_{sg}\n```\n\n----------------------------------------\n\nTITLE: Calculating Current Source Contribution in Short-Circuit Analysis using LaTeX\nDESCRIPTION: This LaTeX equation represents the calculation of current source contribution in short-circuit analysis. It considers the currents fed by converter elements and the contribution at the fault bus.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ikss.rst#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{bmatrix}\nI_1 \\\\[0.2em]\n\\vdots  \\\\[0.2em]\nI_m \\\\[0.2em]\n\\vdots  \\\\\nI_n\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0 \\\\[0.2em]\n\\vdots  \\\\[0.2em]\n\\underline{I}''_{kIIj} \\\\[0.2em]\n\\vdots  \\\\\n0\n\\end{bmatrix}\n-\n\\begin{bmatrix}\nI''_{kC1} \\\\[0.2em]\n\\vdots  \\\\[0.2em]\n\\underline{I}''_{kCj} \\\\[0.2em]\n\\vdots  \\\\\nI''_{kCn}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n-I''_{kC1} \\\\[0.2em]\n\\vdots  \\\\[0.2em]\n\\underline{I}''_{kIIj} - \\underline{I}''_{kCj} \\\\[0.2em]\n\\vdots  \\\\\n-I''_{kCn}\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Running TDPF with Temperature Control\nDESCRIPTION: Executes timeseries simulations with the custom temperature controller for different time delays.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nTDPF_timeseries_control(net)\nnet.line.temperature_degree_celsius = 20\npp.timeseries.run_timeseries(net, time_steps=range(25), tdpf=True, tdpf_delay_s=15*60, max_iteration=50)\noutput_15 = ow.output[\"res_line.temperature_degree_celsius\"].copy()\nnet.line.temperature_degree_celsius = 20\npp.timeseries.run_timeseries(net, time_steps=range(25), tdpf=True, tdpf_delay_s=5*60, max_iteration=50)\noutput_5 = ow.output[\"res_line.temperature_degree_celsius\"].copy()\n```\n\n----------------------------------------\n\nTITLE: Creating Output Writer for Results\nDESCRIPTION: Configures output writer to log specific network parameters including voltage magnitudes and power values for different voltage levels.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef create_output_writer(net, time_steps, output_dir):\n    ow = OutputWriter(net, time_steps, output_path=output_dir, output_file_type=\".xlsx\", log_variables=list())\n    \n    # create a mask to get the indices of all the hv buses in the grid \n    mask_hv_buses = (net.bus.vn_kv > 70.0) & (net.bus.vn_kv < 380.0)\n    hv_busses_index = net.bus.loc[mask_hv_buses].index\n    # create a mask to get the indices of all the mv buses in the grid\n    mask_mv_buses = (net.bus.vn_kv > 1.0) & (net.bus.vn_kv < 70.0)\n    mv_busses_index = net.bus.loc[mask_mv_buses].index\n    # now define the output writer, so that it gets the indices and specify the evaluation functions\n    # since we want the maximum voltage of all mv buses, we provide the indices of the mv buses and the maximum \n    # function np.max. The variable \"eval_name\" is free to chose and contains the name of the column in\n    # which the results are saved. \n    ow.log_variable('res_bus', 'p_mw', index=hv_busses_index, eval_function=np.sum, eval_name=\"hv_bus_sum_p\")\n    ow.log_variable('res_bus', 'vm_pu', index=mv_busses_index, eval_function=np.max, eval_name=\"mv_bus_max\")\n    return ow\n```\n\n----------------------------------------\n\nTITLE: Finding Shortest Path using NetworkX\nDESCRIPTION: Demonstrates how to find the shortest path between two buses using NetworkX algorithms with a PandaPower network graph.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/examples.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.topology import create_nxgraph\nimport networkx as nx\n\nmg = create_nxgraph(net)\nnx.shortest_path(mg, 0, 5)\n```\n\n----------------------------------------\n\nTITLE: Plotting Individual Fuse Characteristic Curve in pandapower\nDESCRIPTION: Creates a visualization of a single fuse's protection characteristic curve. The code uses matplotlib and pandapower's built-in plot_protection_characteristic method to display the time-current relationship for fuse 1.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/protection/fuse.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nplt.figure(1)\nnet.protection.object.at[1].plot_protection_characteristic(net)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Delta Load Current Equations\nDESCRIPTION: Mathematical equations showing the conversion of line-line currents to line-ground currents for delta loads.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/asymmetric_load.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nI_{a}= T. \\frac{S_{ab}}{(V_{an}-V_{bn})}\n\nI_{b}= T. \\frac{S_{bc}}{(V_{bn}-V_{cn})}\n\nI_{c}= T. \\frac{S_{ca}}{(V_{cn}-V_{an})}\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Wind Power Station Short Circuit Analysis\nDESCRIPTION: This snippet imports the necessary libraries for short circuit analysis of wind power stations, including numpy, pandapower, and its shortcircuit module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandapower as pp\nimport pandapower.plotting\nimport pandapower.shortcircuit as sc\nfrom pandapower.test.shortcircuit.test_sgen import simplest_test_grid as create_net\n```\n\n----------------------------------------\n\nTITLE: Adding Shunt Element\nDESCRIPTION: Creates a shunt element (capacitor bank) with specified reactive power compensation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npp.create_shunt(net, bus3, q_mvar=-0.96, p_mw=0, name='Shunt')\n```\n\n----------------------------------------\n\nTITLE: Checking Updated Tap Positions in Python\nDESCRIPTION: This snippet checks the updated tap positions after running the controlled power flow.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo[\"tap_pos\"]\n```\n\n----------------------------------------\n\nTITLE: Validating Match between Direct Calculation and Controller Outputs for 3-Winding Transformers in Python\nDESCRIPTION: This set of assertions checks if the voltage and angle degree results from the two simulations using different methods for 3-winding transformers yield the same outputs, ensuring the integrity of the analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nassert np.allclose(net4.res_bus.vm_pu, net5.res_bus.vm_pu, atol=1e-6, rtol=0)\nassert np.allclose(net4.res_bus.va_degree, net5.res_bus.va_degree, atol=1e-6, rtol=0)\npd.merge(net4.res_bus[[\"vm_pu\", \"va_degree\"]], net5.res_bus[[\"vm_pu\", \"va_degree\"]], \n         left_index=True, right_index=True)\n```\n\n----------------------------------------\n\nTITLE: Running Power Flow with Control in pandapower (Python)\nDESCRIPTION: This code shows how to run a power flow calculation with the run_control option set to true. It imports the runpp function from pandapower and executes it with the specified network and control option.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/control/run.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower import runpp\nrunpp(net, run_control=True)\n```\n\n----------------------------------------\n\nTITLE: Creating a Network and Configuring Transformer Characteristics in Python\nDESCRIPTION: This line calls the previously defined create_net function to initialize a new electrical network, which will subsequently be populated with transformers and their characteristics for analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet = create_net()\n```\n\n----------------------------------------\n\nTITLE: Loading pandapower network from SQLite database\nDESCRIPTION: Function to load a pandapower network from a SQLite database. This reverses the to_sqlite operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\npandapower.from_sqlite\n```\n\n----------------------------------------\n\nTITLE: Setting Numba JIT Options in Python\nDESCRIPTION: Demonstrates the correct way to set the 'nopython' option when using Numba's just-in-time compilation. This change addresses deprecation warnings for Numba.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CHANGELOG.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@jit(nopython=True)\n```\n\n----------------------------------------\n\nTITLE: Network Initialization for TDPF\nDESCRIPTION: Initializes the test network with specific scaling parameters for load and generation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet = simple_test_grid(load_scaling=0.25, sgen_scaling=0.5, with_gen=True, distributed_slack=False)\n```\n\n----------------------------------------\n\nTITLE: Running OPF with Verbose Output\nDESCRIPTION: This snippet demonstrates how to run the OPF with verbose output for debugging purposes, providing more information on the solver's status.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npp.runopp(net, verbose=True, delta=1e-16)\n```\n\n----------------------------------------\n\nTITLE: Peak Factor Formula for Radial Networks\nDESCRIPTION: Mathematical formula for calculating the peak factor (κ) in radial networks using the R/X ratio of the equivalent short-circuit impedance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ip.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\kappa = 1.02 + 0.98 e^{-{3}{R/X}}\n```\n\n----------------------------------------\n\nTITLE: TCSC Power Flow Equation in Matrix Form\nDESCRIPTION: LaTeX equation representing the power flow through the TCSC element using admittance matrices, showing the relationship between power, voltage and admittance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/tcsc.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n     \\begin{bmatrix}\n    \\underline{S}_{TCSC_i} \\\\\n    \\underline{S}_{TCSC_j}\n    \\end{bmatrix}\n    =\n    \\begin{bmatrix}\n    \\underline{U}_i \\\\\n    \\underline{U}_j\n    \\end{bmatrix}\n    \\begin{bmatrix}\n    \\underline{Y}_{TCSC} & -\\underline{Y}_{TCSC}\\\\\n    -\\underline{Y}_{TCSC} & \\underline{Y}_{TCSC}\n    \\end{bmatrix}^*\n     \\begin{bmatrix}\n    \\underline{U}_i \\\\\n    \\underline{U}_j\n    \\end{bmatrix}^*\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Documenting Logarithmic Colormap Function in pandapower\nDESCRIPTION: This snippet documents the cmap_logarithmic function from pandapower's plotting.colormaps module using the autofunction directive in reStructuredText.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/matplotlib/create_colormaps.rst#2025-04-22_snippet_2\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: pandapower.plotting.colormaps.cmap_logarithmic\n```\n\n----------------------------------------\n\nTITLE: Calculating Impedance for Wind Power Station with Asynchronous Generator\nDESCRIPTION: This code calculates the impedance of an asynchronous generator in a wind power station unit. It uses the rated voltage, apparent power, and locked-rotor current ratio.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_wind_power_station_units.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nU_rG = 0.4  # kV\nS_rG = 2.5 # MVA\nI_rG = S_rG / (np.sqrt(3) * U_rG)\nI_LR = 5 * I_rG # our assumption\nI_LR_rG = I_LR / I_rG\nRX_G = 0.1\n```\n\nLANGUAGE: python\nCODE:\n```\nZ_G = 1/I_LR_rG * U_rG**2 / S_rG\nZ_G\n```\n\nLANGUAGE: python\nCODE:\n```\nZ_G_complex = (RX_G + 1j) * Z_G / (np.sqrt(1 + RX_G**2))\nZ_G_complex\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Function for Q Capability Curve Table in pandapower\nDESCRIPTION: Function to perform sanity checks on the generator reactive power capability curve table, ensuring the data is correctly formatted and valid.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/sgen.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npandapower.control.util.q_capability_curve_table_diagnostic\n```\n\n----------------------------------------\n\nTITLE: Using notravbuses with connected_components\nDESCRIPTION: This example illustrates how to pass notravbuses directly to the connected_components search, avoiding them being counted as their own connected area while still considering their connections.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, nogobuses={0})\nfor area in top.connected_components(mg, notravbuses={1}):\n    print(area)\n```\n\n----------------------------------------\n\nTITLE: Creating Low Voltage Buses in Python\nDESCRIPTION: Creates low voltage buses with a nominal voltage of 0.4 kV. Buses are created with a hierarchical naming structure (Bus LV0, Bus LV1.x, Bus LV2.x, etc.) and specific types ('n' for slack, 'm' for others).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\npp.create_bus(net, name='Bus LV0', vn_kv=0.4, type='n')\nfor i in range(1, 6):\n    pp.create_bus(net, name='Bus LV1.%s' % i, vn_kv=0.4, type='m')\nfor i in range(1, 5):\n    pp.create_bus(net, name='Bus LV2.%s' % i, vn_kv=0.4, type='m')\npp.create_bus(net, name='Bus LV2.2.1', vn_kv=0.4, type='m')\npp.create_bus(net, name='Bus LV2.2.2', vn_kv=0.4, type='m')\n\n# show only low voltage buses\nlv_buses = net.bus[net.bus.vn_kv == 0.4]\nlv_buses\n```\n\n----------------------------------------\n\nTITLE: Plotting Voltage Setpoint Characteristics in Pandapower\nDESCRIPTION: This code plots the piecewise linear characteristic of voltage setpoints against a range of active power flows to visually analyze the relationship defined by the Characteristic object.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/vm_set_tap.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nplot_characteristic(c,-25,25,50, 'p_hv_mw', 'u_set_pu')\n```\n\n----------------------------------------\n\nTITLE: Timing Performance Comparison of OPF Functions - Python\nDESCRIPTION: This snippet compares the execution time between the traditional runopp function and the more efficient runpm function provided by PowerModels.jl.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runopp(net)\n\ntry:\n    %timeit pp.runpm_ac_opf(net)\nexcept:\n    print(\"Cannot be performed due to [WinError 3] - Can't find file python39.dll\")\n```\n\n----------------------------------------\n\nTITLE: Calculating PQ-Values for Storage Components in PandaPower\nDESCRIPTION: These equations show how the active and reactive power values for storage components are calculated from the parameter table values. P_storage represents the active power while Q_storage represents the reactive power, both scaled by a scaling factor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/storage.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\nP_{storage} &= p\\_mw \\cdot scaling \\\\\nQ_{storage} &= q\\_mvar \\cdot scaling \\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Saving pandapower network to Excel format\nDESCRIPTION: Function to save a pandapower network to an Excel file. Excel format allows for human-readable spreadsheet representation of the network data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\npandapower.to_excel\n```\n\n----------------------------------------\n\nTITLE: Checking out the develop branch in pandapower\nDESCRIPTION: Command to switch to the develop branch in your local repository. This is typically where you want to be when starting new development work.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout develop\n```\n\n----------------------------------------\n\nTITLE: Executing Pandapower Network Simulation\nDESCRIPTION: This snippet creates a sample medium voltage network using `pandapower.networks.mv_oberrhein` and runs the provided main function to start the PyQt application. It requires the pandapower library to execute network simulations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_pyqt.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom pandapower.networks import mv_oberrhein\\nnet = mv_oberrhein()\\nmain(net)\n```\n\n----------------------------------------\n\nTITLE: Calculating External Grid Impedance for Maximum Short-Circuit Currents in LaTeX\nDESCRIPTION: These equations calculate the impedance components of an external grid connection for maximum short-circuit currents. It uses parameters from the ext_grid table and the voltage correction factor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/voltage_source.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nz_{k, eg} =& \\frac{c_{max}}{s\\_sc\\_max\\_mva} \\\\[1em]\nx_{k, eg} =& \\frac{z_{sg}}{\\sqrt{1 + rx\\_max^2}} \\\\[1em]\nr_{k, eg} =& rx\\_max \\cdot x_{sg}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Standard Type\nDESCRIPTION: Shows how to create and register a custom standard type for lines with specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.create_empty_network()\ntest_type = {\"r_ohm_per_km\": 0.01, \"x_ohm_per_km\": 0.02, \"c_nf_per_km\": 10, \"max_i_ka\": 0.4, \"type\": \"cs\"}\npp.create_std_type(net, name=\"test_type\", data=test_type, element=\"line\")\npp.available_std_types(net, element=\"line\")\n```\n\n----------------------------------------\n\nTITLE: SVC Reactive Power Calculation in LaTeX\nDESCRIPTION: Formula for calculating the reactive power consumption of the SVC element based on voltage and shunt impedance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/svc.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nQ_{SVC} = \\frac{V^2}{X_{SVC}}\n```\n\n----------------------------------------\n\nTITLE: Setting Python Environment in Julia (Windows)\nDESCRIPTION: Command to set Python environment variable in Julia for Windows systems to use an existing Anaconda installation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pandamodels.rst#2025-04-22_snippet_0\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"PYTHON\"]=raw\"C:\\\\Anaconda3\\\\python.exe\"\n```\n\n----------------------------------------\n\nTITLE: Adding Asynchronous Motor to Network\nDESCRIPTION: Demonstrates how to add an asynchronous motor to the network using static generator with motor type configuration. Specifies R/X ratio and nominal to short circuit current ratio.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = ring_network()\npp.create_sgen(net, 2, p_mw=0, sn_mva=0.5, k=1.2, rx=7., type=\"motor\")\nnet\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower runpp function for AC Power Flow\nDESCRIPTION: This snippet shows the import statement for the runpp function from pandapower, which is used to run balanced AC power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/ac.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.run import runpp\n```\n\n----------------------------------------\n\nTITLE: Accessing PowerModels Data Structure - Python\nDESCRIPTION: This snippet accesses the underlying data structure of PowerModels.jl that was passed during the optimization process.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet._pm[\"bus\"]\n```\n\n----------------------------------------\n\nTITLE: Mapping pandapower Bus Indices to Internal Indices\nDESCRIPTION: Shows how to use the bus mapping between pandapower indices and internal ppc indices, including an example of accessing Ybus entries.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet._pd2ppc_lookups[\"bus\"]\n\npandapower_bus_idx = 3\nppc_index = net._pd2ppc_lookups[\"bus\"][pandapower_bus_idx]\nprint(ppc_index)\n\nYbus = net._ppc[\"internal\"][\"Ybus\"]\nint_idx = net._pd2ppc_lookups[\"bus\"][ppc_index]\nYbus[int_idx, int_idx]\n\nprint(net._pd2ppc_lookups[\"bus\"][1])\nprint(net._pd2ppc_lookups[\"bus\"][2])\n\nnet.switch.loc[0]\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Test Network in pandapower\nDESCRIPTION: Defines a function to create a simple pandapower network with five buses, a transformer, three lines, a load, and a static generator (sgen). Sets up the network topology and components for the time series simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef simple_test_net():\n    \"\"\"\n    simple net that looks like:\n\n    ext_grid b0---b1 trafo(110/20) b2----b3 load\n                                    |\n                                    |\n                                    b4 sgen\n    \"\"\"\n    net = pp.create_empty_network()\n    pp.set_user_pf_options(net, init_vm_pu = \"flat\", init_va_degree = \"dc\", calculate_voltage_angles=True)\n\n    b0 = pp.create_bus(net, 110)\n    b1 = pp.create_bus(net, 110)\n    b2 = pp.create_bus(net, 20)\n    b3 = pp.create_bus(net, 20)\n    b4 = pp.create_bus(net, 20)\n\n    pp.create_ext_grid(net, b0)\n    pp.create_line(net, b0, b1, 10, \"149-AL1/24-ST1A 110.0\")\n    pp.create_transformer(net, b1, b2, \"25 MVA 110/20 kV\", name='tr1')\n    pp.create_line(net, b2, b3, 10, \"184-AL1/30-ST1A 20.0\")\n    pp.create_line(net, b2, b4, 10, \"184-AL1/30-ST1A 20.0\")\n\n    pp.create_load(net, b3, p_mw=15., q_mvar=10., name='load1')\n    pp.create_sgen(net, b4, p_mw=20., q_mvar=0.15, name='sgen1')\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower.plotting.to_html Function\nDESCRIPTION: This snippet shows the autofunction directive for the to_html function from the pandapower.plotting module. The directive automatically generates documentation from the function's docstring.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/html.rst#2025-04-22_snippet_0\n\nLANGUAGE: rest\nCODE:\n```\n.. autofunction:: pandapower.plotting.to_html\n```\n\n----------------------------------------\n\nTITLE: Loading pandapower network from JSON format\nDESCRIPTION: Function to load a pandapower network from a JSON file. This reverses the to_json operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\npandapower.from_json\n```\n\n----------------------------------------\n\nTITLE: Running all pandapower tests locally\nDESCRIPTION: Python code to run the entire pandapower test suite locally. This helps ensure your changes don't break existing functionality before submitting a pull request.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.test import run_all_tests\nrun_all_tests()\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit Currents at All Buses in LaTeX\nDESCRIPTION: This LaTeX equation shows how to calculate short-circuit currents at all buses simultaneously using the inverted nodal point admittance matrix and equivalent voltage sources.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ikss.rst#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{bmatrix}\nI''_{kI1} \\\\[0.25em]\n\\vdots  \\\\[0.25em]\nI''_{kIn} \\\\\n\\end{bmatrix}\n= \n\\begin{bmatrix}\n\\frac{V_{Q1}}{Z_{11}}  \\\\\n\\vdots  \\\\\n\\frac{V_{Qn}}{Z_{nn}} \n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Accessing Line Power Flow Results in pandapower 2.0\nDESCRIPTION: Demonstrates how to access line power flow results in MW, with an option to convert to kW if needed.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\np_from_kw = net.res_line.p_from_mw*1e3\n# or\np_from_mw = net.res_line.p_from_mw\n```\n\n----------------------------------------\n\nTITLE: Creating Example Network with pandapower\nDESCRIPTION: This snippet creates an example network using the case9 function from pandapower.networks and runs a power flow analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/gridequivalent_example.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower import runpp\nfrom pandapower.networks import case9\n\nnet = case9()\n\n# getting power flow results\nrunpp(net)\n```\n\n----------------------------------------\n\nTITLE: Configuring Line Loading Limits\nDESCRIPTION: Sets maximum loading percentages for transformers and lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo[\"max_loading_percent\"] = 500.0\nnet.line[\"max_loading_percent\"] = 500.0\n```\n\n----------------------------------------\n\nTITLE: Creating VSC in pandapower\nDESCRIPTION: Function signature for creating a Voltage Source Converter (VSC) in pandapower. The specific parameters and their descriptions are not provided in the code snippet.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/vsc.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.create.create_vsc\n```\n\n----------------------------------------\n\nTITLE: Equivalent Thermal Current Matrix Calculation in LaTeX\nDESCRIPTION: Mathematical representation of the equivalent thermal current calculation using matrices, showing the relationship between thermal current components and short-circuit currents with dc and ac parts.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ith.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix}\n\\underline{I}_{th, 1} \\\\\n\\vdots  \\\\\n\\underline{I}_{th, n} \\\\\n\\end{bmatrix} =   \n\\begin{bmatrix}\n\\sqrt{m_1 + n_1} \\\\\n\\vdots  \\\\\n\\sqrt{m_n + n_n} \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\underline{I}''_{k, 1} \\\\\n\\vdots  \\\\\n\\underline{I}''_{k, n} \\\\\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Creating Medium Voltage Lines from CSV Data in PandaPower\nDESCRIPTION: Loads medium voltage line data from a CSV file and creates lines in the network based on the data.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmv_lines = pd.read_csv('example_advanced/mv_lines.csv', sep=';', header=0, decimal=',')\nfor _, mv_line in mv_lines.iterrows():\n    from_bus = pp.get_element_index(net, \"bus\", mv_line.from_bus)\n    to_bus = pp.get_element_index(net, \"bus\", mv_line.to_bus)\n    pp.create_line(net, from_bus, to_bus, length_km=mv_line.length, std_type=mv_line.std_type, name=mv_line.line_name)\n\n# show only medium voltage lines\nnet.line[net.line.from_bus.isin(mv_buses.index)]\n```\n\n----------------------------------------\n\nTITLE: Obtaining Jacobian Entries for Generators in pandapower\nDESCRIPTION: Demonstrates how to obtain Jacobian matrix entries for generator buses using the pandapower to ppc bus mapping.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ngen_buses = net.gen.loc[net.gen.in_service.values, \"bus\"].values\nprint(f\"pandapower gen bus: {gen_buses}\")\n\nJ = net._ppc[\"internal\"][\"J\"]\nprint(f\"Jacobian shape: {J.shape}\")\n\nbus_lookup = ppc_index = net._pd2ppc_lookups[\"bus\"]\nprint(f\"pandapower to ppc lookup: {bus_lookup}\")\nppc_gen_buses = bus_lookup[gen_buses]\nprint(f\"pandapower gen bus: {gen_buses} maps to ppc gen bus: {ppc_gen_buses}\")\n\nimport numpy as np\n\npv = net._ppc[\"internal\"][\"pv\"]\npq = net._ppc[\"internal\"][\"pq\"]\npvpq = np.hstack((pv, pq))\n\nprint(\"pv and pq nodes as in the newtonpf() function\")\nprint(f\"pv buses: {pv}\\npq buses: {pq}\\npvpq buses: {pvpq}\")\n\nn_pvpq = len(pvpq)\nn_pq = len(pq)\nn_pv = len(pv)\nj11 = J[:n_pvpq, :n_pvpq]\nj12 = J[:n_pvpq, n_pvpq:]\nj21 = J[n_pvpq:, :n_pvpq]\nj22 = J[n_pvpq:, n_pvpq:]\n\nprint(\"shape of J sub-matrices:\")\nprint(f\"j11 = {j11.shape}\")\nprint(f\"j12 = {j12.shape}\")\nprint(f\"j21 = {j21.shape}\")\nprint(f\"j22 = {j22.shape}\")\n\nm = np.isin(pvpq, pv)\nn = m\n\nj11_gen_entries = j11[m, n]\nprint(f\"J11 indices: m = {m}, n = {n}\")\nprint(f\"pandapower gen {gen_buses} entries (ppc PV nodes {ppc_gen_buses}) in J11 (=dP/dVa): {j11_gen_entries}\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Short-Circuit without Wind Parks\nDESCRIPTION: Disables the static generators representing wind parks and performs short-circuit calculation for the base network configuration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/shortcircuit_renewables.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet.sgen.in_service = False\nsc.calc_sc(net, ip=True)\n```\n\n----------------------------------------\n\nTITLE: Load Power ZIP Model Constants Calculation\nDESCRIPTION: Mathematical expressions for calculating the constant impedance, current, and power components of the ZIP load model. These equations determine what percentage of the load follows each behavior.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/load.rst#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nz_{const} =& const\\_z\\_percent / 100 \\\\\ni_{const} =& const\\_i\\_percent / 100 \\\\\np_{const} =& (100 - const\\_z\\_percent - const\\_i\\_percent) / 100\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Kerber Rural Networks Type I in Python\nDESCRIPTION: Creates extreme rural Kerber networks with overhead lines or underground cables that represent the 95% confidence interval for existing grids. These Type I networks have extreme line parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_landnetz_freileitung, kb_extrem_landnetz_kabel\n\n'''Extrem Landnetz Freileitung Typ I'''\nnet = kb_extrem_landnetz_freileitung()\n\n\n'''Extrem Landnetz Kabel Typ I'''\nnet = kb_extrem_landnetz_kabel()\n```\n\n----------------------------------------\n\nTITLE: Checking Python Path Configuration\nDESCRIPTION: Verifies that PowerFactory Python folder is in the Python path by accessing environment variables.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/converter_powerfactory.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nos.environ['PYTHONPATH']\n```\n\n----------------------------------------\n\nTITLE: Saving Network as JSON in pandapower 2.0\nDESCRIPTION: Demonstrates how to load a network from a pickle file, run a power flow, and save it as a JSON file for better compatibility with pandapower 2.0.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower import from_pickle, runpp, to_json\nnet = from_pickle(\"C:\\\\my_file.p\")\nrunpp(net)\nto_json(net, \"C:\\\\my_file_2.0.json\")\n```\n\n----------------------------------------\n\nTITLE: Plotting Time Series Optimization Results\nDESCRIPTION: This code snippet plots the results of both time series optimization methods (loop-based and multi-timestep) using Matplotlib. It creates two subplots, one for each method, and displays the mean voltage value over time.  The plots are then labeled for clarity.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nfig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)\nax1.plot(range(96), y_loop)\nax1.set_title(\"results for \\n optimization in a loop\")\nax2.plot(range(96), y_multi)\nax2.set_title(\"results for \\n multi-timestep optimization\")\n\nfor ax in ax1, ax2:\n    ax.grid(True)\n    ax.label_outer()\n    ax.set_xlabel(\"time step [15min]\")\nax1.set_ylabel(\"mean voltage value for DER-buses [p.u.]\")\n```\n\n----------------------------------------\n\nTITLE: Peak Factor Formula for Method B\nDESCRIPTION: Mathematical formula for calculating the peak factor (κ) using Method B, which includes an additional multiplication factor of 1.15.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ip.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\kappa = [1.02 + 0.98 e^{-{3}{R/X}}] \\cdot 1.15\n```\n\n----------------------------------------\n\nTITLE: Creating Static Generator with Generator-Based Signing in pandapower 2.0\nDESCRIPTION: Illustrates the creation of a static generator using the new generator-based signing system and MVA units in pandapower 2.0.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npp.create_sgen(net, bus=3, p_mw=0.5, q_mvar=-0.1, sn_mva=1.)\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for pandapower Analysis\nDESCRIPTION: Imports necessary Python libraries including pandapower for power system analysis, pandas for data manipulation, numpy for numerical operations, and seaborn for visualization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/reference_system_convention.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandas as pd\nimport numpy as np\nimport seaborn as sn\n```\n\n----------------------------------------\n\nTITLE: Shunt Admittance Calculation - LaTeX Math Formula\nDESCRIPTION: Formula for calculating the shunt admittance component of the Extended Ward equivalent.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/xward.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{y}_{shunt} &= \\frac{pz\\_mw + j \\cdot qz\\_mvar}{S_{N}}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Running AC Optimal Power Flow with PowerModels - Python\nDESCRIPTION: This snippet executes the AC optimal power flow optimization on the created pandapower network using PowerModels.jl.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_opf.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_ac_opf(net)\nexcept Exception as err:\n    print(err)\n\n# or: pp.runpm(net, pm_model=\"ACPPowerModel\")\n```\n\n----------------------------------------\n\nTITLE: Printing Ward Elements\nDESCRIPTION: This snippet prints the calculated Ward elements for both the original and reduced grids.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/gridequivalent_example.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(\"--- ward (original grid) ---\")\nnet.ward\nprint(\"--- ward (reduced grid) ---\")\nnet_eq.ward\n```\n\n----------------------------------------\n\nTITLE: Importing Protection Calculation Function Documentation\nDESCRIPTION: Documentation reference for the calculate_protection_times function used to compute protection timing calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/protection/oc_relay.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: pandapower.protection.run_protection.calculate_protection_times\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Network in PandaPower\nDESCRIPTION: Creates a new network instance using the create_net() function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnet6 = create_net()\n```\n\n----------------------------------------\n\nTITLE: Checking Transformer Tap Positions in Python\nDESCRIPTION: This snippet shows how to check the current tap positions of the transformers in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo[\"tap_pos\"]\n```\n\n----------------------------------------\n\nTITLE: Comparing Shunt Elements\nDESCRIPTION: Displays shunt elements in both original and reduced grids\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprint(\"--- shunts (original grid) ---\")\ndisplay(net.shunt)\nprint(\"--- shunts (reduced grid) ---\")\ndisplay(net_eq.shunt)\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Vorstadtnetz Kabel_d Typ II Network in Python\nDESCRIPTION: This snippet demonstrates how to create an Extreme Vorstadtnetz Kabel_d Typ II network using the kb_extrem_vorstadtnetz_trafo_2() function from pandapower.networks. The resulting network is stored in the 'net' variable.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_vorstadtnetz_trafo_2\n\n'''Extrem Vorstadtnetz Kabel_d Typ II'''\nnet = kb_extrem_vorstadtnetz_trafo_2()\n```\n\n----------------------------------------\n\nTITLE: File I/O Operations\nDESCRIPTION: Demonstrates JSON serialization and deserialization of network with characteristics.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nnet2 = pp.from_json_string(pp.to_json(net))\npp.control.create_trafo_characteristic_object(net2) # need to recreate the object becuase it is binary\n\nnet2[\"trafo_characteristic_spline\"]\n```\n\n----------------------------------------\n\nTITLE: Peak Short-Circuit Current Matrix Formula\nDESCRIPTION: Mathematical formula showing the calculation of peak short-circuit current using peak factor and short-circuit currents in matrix form.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ip.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix}\ni_{p, 1}  \\\\\n\\vdots  \\\\\ni_{p, n}  \\\\\n\\end{bmatrix}\n= \\sqrt{2} \\left(\n\\begin{bmatrix}\n\\kappa_{1}  \\\\\n\\vdots  \\\\\n\\kappa_{1}   \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\underline{I}''_{kI, 1} \\\\\n\\vdots  \\\\\n\\underline{I}''_{kI, n} \\\\\n\\end{bmatrix} +\n\\begin{bmatrix}\n\\underline{I}''_{kII, 1} \\\\\n\\vdots  \\\\\n\\underline{I}''_{kII, n} \\\\\n\\end{bmatrix} \\right)\n```\n\n----------------------------------------\n\nTITLE: Setting up Timeseries Data and Output Writer\nDESCRIPTION: Configures data source and output logging for the timeseries simulation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nds = pp.timeseries.DFData(data)\npp.control.ConstControl(net, \"line\", \"wind_speed_m_per_s\", net.line.query(\"tdpf\").index, \"wind_speed_m_per_s\", ds, recycle=False)\now = pp.timeseries.OutputWriter(net)\now.log_variable(\"res_line\", \"temperature_degree_celsius\")\now.log_variable(\"line\", \"wind_speed_m_per_s\")\n```\n\n----------------------------------------\n\nTITLE: Modifying Shunt Power in MW in pandapower 2.0\nDESCRIPTION: Shows how to modify shunt power using the new MW units in pandapower 2.0.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.shunt.p_mw *= 2\n```\n\n----------------------------------------\n\nTITLE: Results Processing and Data Frame Creation\nDESCRIPTION: Processes output JSON files and creates pandas DataFrames for plotting power and voltage values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\noutput_dir = os.path.join(tempfile.gettempdir(), \"time_series_example\")\n# Power Values from secondary of the transformer\nPA = os.path.join(output_dir,'res_trafo_3ph','p_a_lv_mw.json')\nPB = os.path.join(output_dir,'res_trafo_3ph','p_b_lv_mw.json')\nPC = os.path.join(output_dir,'res_trafo_3ph','p_c_lv_mw.json')\nQA = os.path.join(output_dir,'res_trafo_3ph','q_a_lv_mvar.json')\nQB = os.path.join(output_dir,'res_trafo_3ph','q_b_lv_mvar.json')\nQC = os.path.join(output_dir,'res_trafo_3ph','q_c_lv_mvar.json')\n\n#pandapower Results\ndf_pp = pd.read_json(PA)*-1e3\ndf_pp['PB'] = pd.read_json(PB)*-1e3\ndf_pp['PC'] = pd.read_json(PC)*-1e3\ndf_pp['P_SUM'] =  df_pp.sum(axis=1)\ndf_pp = df_pp.rename(columns={0:'PA'}) \n\ndf_pq = pd.read_json(QA)*-1e3\ndf_pq['QB'] = pd.read_json(QB)*-1e3\ndf_pq['QC'] = pd.read_json(QC)*-1e3\ndf_pq = df_pq.rename(columns={0:'QA'})\ndf_pp['Q_SUM'] =  df_pq.sum(axis=1)\n\n\n#The magnitude of voltage at LOAD1 (phase A), LOAD32 (phase C), and LOAD53 (phase B) over the one-day period are shown \npp_va = os.path.join(output_dir,'res_bus_3ph','vm_a_pu.json')\npp_vb = os.path.join(output_dir,'res_bus_3ph','vm_b_pu.json')\npp_vc = os.path.join(output_dir,'res_bus_3ph','vm_c_pu.json')\n\n#pandapower Results\ndf_pp_v = pd.read_json(pp_va)*(416/np.sqrt(3))\ndf_pp_v['VB'] = pd.read_json(pp_vb)*(416/np.sqrt(3))\ndf_pp_v['VC'] = pd.read_json(pp_vc)*(416/np.sqrt(3))\ndf_pp_v= df_pp_v.rename(columns={34: \"VA\"})\n\n# This is required since json makes keys as string type, the index order is like 1, 10, 100 ,...\ndf_pp_v.index = df_pp_v.index.astype(np.int64)\ndf_pp_v = df_pp_v.sort_index()\n\ndf_pp.index = df_pp.index.astype(np.int64)\ndf_pp = df_pp.sort_index()\n```\n\n----------------------------------------\n\nTITLE: Saving pandapower network to JSON format\nDESCRIPTION: Function to save a pandapower network to a JSON file. JSON is a lightweight, human-readable data interchange format.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\npandapower.to_json\n```\n\n----------------------------------------\n\nTITLE: Loading pandapower network from PostgreSQL database\nDESCRIPTION: Function to load a pandapower network from a PostgreSQL database. This reverses the to_postgresql operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\npandapower.from_postgresql\n```\n\n----------------------------------------\n\nTITLE: Documenting pandapower Network Creation Function\nDESCRIPTION: ReStructuredText directive for auto-documenting the synthetic voltage control low voltage network creation function from pandapower.networks module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/synthetic_voltage_control_lv_networks.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: pandapower.networks.create_synthetic_voltage_control_lv_network\n```\n\n----------------------------------------\n\nTITLE: Creating example network and extracting transformer parameters\nDESCRIPTION: This code creates an example network using the vde_232() function and extracts various transformer parameters from the network. These parameters are crucial for subsequent calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet = vde_232()\nvn_trafo_hv = net.trafo.vn_hv_kv\nvn_trafo_lv = net.trafo.vn_lv_kv\nsn_mva = net.trafo.sn_mva\nvk0_percent = net.trafo.vk0_percent\nvkr0_percent = net.trafo.vkr0_percent\n```\n\n----------------------------------------\n\nTITLE: Finding Standard Types with Tolerance\nDESCRIPTION: Demonstrates finding standard types with parameter matching within a tolerance range.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\npp.find_std_type_by_parameter(net, data={\"r_ohm_per_km\": 0.12, \"x_ohm_per_km\": 0.40}, epsilon=.05)\n```\n\n----------------------------------------\n\nTITLE: Running Diagnostic for Q Capability Curve Table in Python\nDESCRIPTION: These snippets demonstrate the use of the q_capability_curve_table_diagnostic function to check for data integrity and completeness in the Q capability curve characteristics. Various scenarios are tested to show different diagnostic outputs.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/q_reactive_power_capability.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnet4 = test_net_for_q_capability_curve(characteristics_data=True)\ncreate_q_capability_curve_characteristics_object(net4)\nq_capability_curve_table_diagnostic(net4, \"gen\")\n```\n\nLANGUAGE: python\nCODE:\n```\nnet4.gen.loc[0,\"reactive_capability_curve\"] = False\nq_capability_curve_table_diagnostic(net4, \"gen\")\n```\n\nLANGUAGE: python\nCODE:\n```\nnet4 = test_net_for_q_capability_curve(characteristics_data=True)\ncreate_q_capability_curve_characteristics_object(net4)\nnet4.gen.loc[0,\"reactive_capability_curve\"] = False\nnet4.gen.loc[0,\"id_q_capability_curve_characteristic\"] = np.nan\nq_capability_curve_table_diagnostic(net4, \"gen\")\n```\n\nLANGUAGE: python\nCODE:\n```\nnet4 = test_net_for_q_capability_curve(characteristics_data=True)\ncreate_q_capability_curve_characteristics_object(net4)\nnet4.gen.loc[0, \"curve_style\"] = \"hi\"\nnet4.q_capability_curve_table.drop(columns=\"q_min_mvar\")\nq_capability_curve_table_diagnostic(net4, \"gen\")\n```\n\nLANGUAGE: python\nCODE:\n```\nnet4 = test_net_for_q_capability_curve(characteristics_data=True)\ncreate_q_capability_curve_characteristics_object(net4)\nnet4.q_capability_curve_table.q_min_mvar = np.nan\nnet4.q_capability_curve_table.drop(columns=\"q_min_mvar\")\nq_capability_curve_table_diagnostic(net4, \"gen\")\n```\n\n----------------------------------------\n\nTITLE: Changing Line Standard Type\nDESCRIPTION: Demonstrates how to change the standard type of an existing line.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\npp.change_std_type(net, l2, \"NAYY 4x150 SE\", element=\"line\")\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Creating Network Buses\nDESCRIPTION: Creates high voltage (110kV) and medium voltage (20kV) buses with different types (busbar and node).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbus1 = pp.create_bus(net, name=\"HV Busbar\", vn_kv=110, type=\"b\")\nbus2 = pp.create_bus(net, name=\"HV Busbar 2\", vn_kv=110, type=\"b\")\nbus3 = pp.create_bus(net, name=\"HV Transformer Bus\", vn_kv=110, type=\"n\")\nbus4 = pp.create_bus(net, name=\"MV Transformer Bus\", vn_kv=20, type=\"n\")\nbus5 = pp.create_bus(net, name=\"MV Main Bus\", vn_kv=20, type=\"b\")\nbus6 = pp.create_bus(net, name=\"MV Bus 1\", vn_kv=20, type=\"b\")\nbus7 = pp.create_bus(net, name=\"MV Bus 2\", vn_kv=20, type=\"b\")\n```\n\n----------------------------------------\n\nTITLE: Determining Stubs in pandapower (Python)\nDESCRIPTION: Function to identify stub connections in an electrical network. It is part of the pandapower.topology module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/searches.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\npandapower.topology.determine_stubs\n```\n\n----------------------------------------\n\nTITLE: Loading Parameters from Standard Types\nDESCRIPTION: Shows how to load additional parameters from standard types into the line table.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.parameter_from_std_type(net, parameter=\"h_per_km\")\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Calculating Phase-to-Earth Voltage in Balanced Systems (LaTeX)\nDESCRIPTION: Formula for calculating phase-to-earth voltage from phase-to-phase voltage in a balanced Wye-connected system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/units.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nv_{ph-e} = \\frac{V_{ph-ph}}{\\sqrt3}\n```\n\n----------------------------------------\n\nTITLE: Specifying nogobuses in Graph Conversion\nDESCRIPTION: This example shows how to specify certain buses as 'nogobuses' during graph conversion, preventing them from being included in the NetworkX graph for pathfinding.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nmg = top.create_nxgraph(net, respect_switches=False, nogobuses={1})\n```\n\n----------------------------------------\n\nTITLE: Loading pandapower network from Excel format\nDESCRIPTION: Function to load a pandapower network from an Excel file. This reverses the to_excel operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\npandapower.from_excel\n```\n\n----------------------------------------\n\nTITLE: Documentation Reference for get_equivalent Function\nDESCRIPTION: ReStructuredText directive that auto-generates documentation from the docstring of the get_equivalent function in the pandapower.grid_equivalents.get_equivalent module\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/run_function.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: pandapower.grid_equivalents.get_equivalent.get_equivalent\n```\n\n----------------------------------------\n\nTITLE: Initializing Imports and Random Seed in Python\nDESCRIPTION: This snippet includes the necessary libraries and sets a random seed to ensure reproducibility in results. Dependencies include Pandas, NumPy, Matplotlib, and Pandapower. These libraries are fundamental for data manipulation, plotting, and grid calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\nimport copy\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\nimport pandapower as pp\n\nnp.random.seed(10)\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Standard Types\nDESCRIPTION: Shows how to create multiple standard types at once using a dictionary of type definitions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet = pp.create_empty_network()\nlinetypes = {\"typ1\": {\"r_ohm_per_km\": 0.01, \"x_ohm_per_km\": 0.02, \"c_nf_per_km\": 10, \"max_i_ka\": 0.4, \"type\": \"cs\"},\n             \"typ2\": {\"r_ohm_per_km\": 0.015, \"x_ohm_per_km\": 0.01, \"c_nf_per_km\": 30, \"max_i_ka\": 0.3, \"type\": \"cs\"}}\npp.create_std_types(net, data=linetypes, element=\"line\")\npp.available_std_types(net)\n```\n\n----------------------------------------\n\nTITLE: Configuring Optimization Boundaries\nDESCRIPTION: Sets voltage and power limits for buses and external grid connections.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.bus[\"max_vm_pu\"] = 1.1\nnet.bus[\"min_vm_pu\"] = 0.9\n\nnet.ext_grid[\"max_q_mvar\"] = 10000.0\nnet.ext_grid[\"min_q_mvar\"] = -10000.0\nnet.ext_grid[\"max_p_mw\"] = 10000.0\nnet.ext_grid[\"min_p_mw\"] = -10000.0\n```\n\n----------------------------------------\n\nTITLE: Mathematical Representation of External Grid for Unbalanced Load Flow\nDESCRIPTION: Mathematical formulas representing the external grid model for unbalanced load flow and single phase short circuit calculations, including positive sequence voltage and zero sequence impedance calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ext_grid.rst#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\begin{align*}\n    \\underline{v}_{1} &= vm\\_pu \\cdot e^{j \\cdot \\theta} \\\\\n   \\theta &= shift\\_degree \\cdot \\frac{\\pi}{180}\n   \\end{align*}\n   \n   \\begin{align*}\n    \\underline{Z}_{0} &= c \\cdot \\frac{(vm \\cdot e^{j \\cdot \\theta})^2}{S_{sc_mva}} \\\\\n   \\theta &= shift\\_degree \\cdot \\frac{\\pi}{180}\n   \\end{align*}\n   \n   \\begin{align*}\n    \\underline{v}_{bus} &= vm\\_pu \\cdot e^{j \\cdot \\theta} \\\\\n   \\theta &= shift\\_degree \\cdot \\frac{\\pi}{180}\n   \\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Initializing Empty PandaPower Network in Python\nDESCRIPTION: Imports the pandapower module and creates an empty network object to start building the complex network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_advanced.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandas as pd\n\n#create an empty network \nnet = pp.create_empty_network()\n```\n\n----------------------------------------\n\nTITLE: Getting Maximum Unbalance Percentage\nDESCRIPTION: Retrieves the maximum unbalance percentage across all buses in the three-phase network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_asymmetric.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_3ph.unbalance_percent.max()\n```\n\n----------------------------------------\n\nTITLE: Loading Parameters with Fallback Values\nDESCRIPTION: Demonstrates loading parameters with fallback values for undefined parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\npp.parameter_from_std_type(net, parameter=\"h_per_km\", fill=0.02)\nnet.line\n```\n\n----------------------------------------\n\nTITLE: Documenting Discrete Colormap Function in pandapower\nDESCRIPTION: This snippet documents the cmap_discrete function from pandapower's plotting.colormaps module using the autofunction directive in reStructuredText.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/matplotlib/create_colormaps.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: pandapower.plotting.colormaps.cmap_discrete\n```\n\n----------------------------------------\n\nTITLE: Accessing Buses on Shortest Path\nDESCRIPTION: This code retrieves all buses on the shortest path found between bus0 and bus5 utilizing the pandas DataFrame indexing capabilities.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnet.bus.loc[path]\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure for pandapower Measurements\nDESCRIPTION: ReStructuredText documentation outlining the measurement module structure, including autofunction reference and parameter table configuration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/measurement.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n=============\nMeasurement\n=============\n\n\nCreate Function\n=====================\n\n.. _create_measurement:\n\n.. autofunction:: pandapower.create_measurement\n\nInput Parameters\n=========================\n\n*net.measurement*\n\n.. tabularcolumns:: |p{0.12\\linewidth}|p{0.10\\linewidth}|p{0.25\\linewidth}|p{0.30\\linewidth}|\n.. csv-table:: \n   :file: measurement_par.csv\n   :delim: ;\n   :widths: 10, 10, 15, 40\n```\n\n----------------------------------------\n\nTITLE: PowerFactory to pandapower Conversion Function Signature\nDESCRIPTION: Function signature for the from_pfd converter which transforms PowerFactory networks into pandapower format. Documents all available parameters and options for customizing the export process.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom_pfd(app, prj_name: str, path_dst=None, pv_as_slack=False, pv_as_slack=False, pf_variable_p_loads='plini',\n                            pf_variable_p_gen='pgini', flag_graphics='GPS', tap_opt='nntap',\n                            export_controller=True)\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower and plotting libraries\nDESCRIPTION: This snippet imports the pandapower library and its plotting module, which are essential for power system analysis and visualization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.plotting\n```\n\n----------------------------------------\n\nTITLE: Network Visualization Setup\nDESCRIPTION: Creates a visual representation of the network including buses, transformers, and loads with different colors for each phase.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_time_series.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plot\nnet = ieee_european_lv_asymmetric('on_peak_566')\n%matplotlib inline\nimport numpy as np\ntry:\n    import seaborn\n    colors = seaborn.color_palette()\nexcept:\n    colors = [\"b\", \"g\", \"r\", \"c\", \"y\"]\n\nsizes = plot.get_collection_sizes(net)\n\nbc = plot.create_bus_collection(net, net.bus.index, size=sizes['bus'], color=colors[0], zorder=10)\ntlc, tpc = plot.create_trafo_collection(net, net.trafo.index, color=\"c\",size=sizes['trafo'])\nlcd = plot.create_line_collection(net, net.line.index, color=\"grey\", linewidths=0.5, use_bus_geodata=True)\nsc = plot.create_ext_grid_collection(net, ext_grid_buses=net.ext_grid.bus.values, size=sizes['ext_grid'], color=\"c\", zorder=11)\nldA = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_a_mw >0)], patch_type=\"poly3\", size=sizes['bus'], color=\"r\", zorder=11)\nldB = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_b_mw >0)], patch_type=\"rect\", size=sizes['bus'], color=\"y\", zorder=11)\nldC = plot.create_bus_collection(net, net.asymmetric_load.bus.values[np.where(net.asymmetric_load.p_c_mw >0)], patch_type=\"circle\", size=sizes['bus'], color=\"g\", zorder=11)\nplot.draw_collections([lcd, bc, tlc, tpc, sc,ldA,ldB,ldC], figsize=(10,7))\n```\n\n----------------------------------------\n\nTITLE: Loading Parameters from Library in PandaPower\nDESCRIPTION: Function reference for loading additional parameters from the library using pandapower.parameter_from_std_type\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\npandapower.parameter_from_std_type\n```\n\n----------------------------------------\n\nTITLE: Accessing Short-Circuit Results in pandapower\nDESCRIPTION: Shows how to access the results of short-circuit calculations in pandapower. Results are stored in dedicated tables for buses, lines, and transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/currents.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnet.res_bus_sc\nnet.res_line_sc\nnet.res_trafo_sc\nnet.res_trafo3w_sc\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Coordinates for Pandapower Network in Python\nDESCRIPTION: This code snippet demonstrates how to remove existing geographical coordinates from a Pandapower network and create generic coordinates using the create_generic_coordinates function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnet = nw.mv_oberrhein()\n# net.bus.geo.drop(net.bus.geo.index, inplace=True)\nnet.bus.geo = np.nan\n# net.line.geo.drop(net.line.geo.index, inplace=True)\nnet.line.geo = np.nan\nplot.create_generic_coordinates(net, respect_switches=False) #create artificial coordinates with the igraph package\n```\n\n----------------------------------------\n\nTITLE: Copying Standard Types in PandaPower\nDESCRIPTION: Function reference for copying standard types using pandapower.copy_std_types\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npandapower.copy_std_types\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Pandapower Network Plotting in Python\nDESCRIPTION: This snippet imports necessary libraries for Pandapower network plotting, including numpy, pandapower, and matplotlib. It also attempts to import seaborn for color palettes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/plotting_structural.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandapower as pp\nimport pandapower.networks as nw\nimport pandapower.plotting as plot\n%matplotlib inline\ntry:\n    import seaborn\n    colors = seaborn.color_palette()\nexcept:\n    colors = [\"b\", \"g\", \"r\", \"c\", \"y\"]\n```\n\n----------------------------------------\n\nTITLE: Running QFlex Optimization with Error Handling\nDESCRIPTION: Executes the reactive power (Q) flexibility optimization using runpm_qflex() with error handling for missing dependencies.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    pp.runpm_qflex(net_opt)\nexcept:\n    print(\"[WinError 3] The system cannot find the path specified to the python39.dll\")\n```\n\n----------------------------------------\n\nTITLE: Loading pandapower network from pickle format\nDESCRIPTION: Function to load a pandapower network from a pickle file. This reverses the to_pickle operation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npandapower.from_pickle\n```\n\n----------------------------------------\n\nTITLE: Implementing Deprecation Warning in Python\nDESCRIPTION: This snippet shows how to raise a DeprecationWarning in Python, which is used to notify users about deprecated functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/deprecating.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nraise DeprecationWarning(\"Notification message\")\n```\n\n----------------------------------------\n\nTITLE: Initializing CIGRE Network with DERs\nDESCRIPTION: Creates a CIGRE medium voltage network with PV and wind distributed energy resources using pandapower's network database.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\nfrom copy import deepcopy\n\nnet = nw.create_cigre_network_mv(with_der=\"pv_wind\")\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for pandapower Elements in reStructuredText\nDESCRIPTION: This snippet defines a table of contents (toctree) in reStructuredText format, listing all the electric elements available in pandapower. Each item in the list corresponds to a separate documentation file for a specific element type.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n    :maxdepth: 1\n\n    elements/empty_network\n    elements/bus\n    elements/bus_dc\n    elements/line\n    elements/line_dc\n    elements/switch\n    elements/load\n    elements/motor\n    elements/asymmetric_load\n    elements/sgen\n    elements/asymmetric_sgen\n    elements/ext_grid\n    elements/trafo\n    elements/trafo3w\n    elements/gen\n    elements/shunt\n    elements/impedance\n    elements/ward\n    elements/xward\n    elements/dcline\n    elements/measurement\n    elements/storage\n    elements/svc\n    elements/tcsc\n    elements/ssc\n    elements/vsc\n```\n\n----------------------------------------\n\nTITLE: Importing Required Dependencies for PowerFactory Export\nDESCRIPTION: Sets up necessary imports for PowerFactory to pandapower conversion, including validation tools and logging configuration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/converter_powerfactory.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport pytest\n\nfrom pandapower.converter.powerfactory.validate import validate_pf_conversion\nfrom pandapower.converter.powerfactory.export_pfd_to_pp import import_project, from_pfd\nimport logging\nlogger = logging.getLogger(__name__)\nlogger.setLevel(\"INFO\")\n\nfrom pandapower.converter import powerfactory as pf\n```\n\n----------------------------------------\n\nTITLE: Removing Existing Controller in Python\nDESCRIPTION: This snippet shows how to remove an existing controller from the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet.controller.drop([trafo_controller.index], inplace = True)\n```\n\n----------------------------------------\n\nTITLE: Performance Testing Power Flow Calculation\nDESCRIPTION: Measures the execution time of power flow calculation using timeit.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net6)\n```\n\n----------------------------------------\n\nTITLE: Plotting Network Layout\nDESCRIPTION: Visualizes the grid layout using pandapower's plotting module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.plotting as plot\n%matplotlib inline\nplot.set_line_geodata_from_bus_geodata(net)\nplot.simple_plot(net)\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower runpp_pgm function for AC Power Flow using power-grid-model\nDESCRIPTION: This snippet shows the import statement for the runpp_pgm function from pandapower, which is used to run balanced AC power flow calculations using the power-grid-model library.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/ac.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.run import runpp_pgm\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Contingency Analysis in Python\nDESCRIPTION: This snippet imports necessary libraries for performing contingency analysis and time-series simulation in pandapower, including numpy, pandas, matplotlib, and various pandapower modules.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nimport pandapower as pp\nimport pandapower.networks\nimport pandapower.contingency\nimport pandapower.control\nimport pandapower.timeseries\nimport pandapower.plotting\n```\n\n----------------------------------------\n\nTITLE: Defining External Grid Limits in Python\nDESCRIPTION: This code snippet defines limits for line loading and bus voltage within the pandapower network to ensure proper execution of the power flow calculations and optimizations. It sets maximum and minimum values for external grid parameters and shows how to define costs for these settings.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_ost.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef define_ext_grid_limits(net):\n    # define line loading and bus voltage limits\n    min_vm_pu = 0.95\n    max_vm_pu = 1.05\n\n    net[\"bus\"].loc[:, \"min_vm_pu\"] = min_vm_pu\n    net[\"bus\"].loc[:, \"max_vm_pu\"] = max_vm_pu\n\n    net[\"line\"].loc[:, \"max_loading_percent\"] = 100.\n    net[\"trafo\"].loc[:, \"max_loading_percent\"] = 100.\n    \n    # define limits\n    net[\"ext_grid\"].loc[:, \"min_p_mw\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_p_mw\"] = 9999.\n    net[\"ext_grid\"].loc[:, \"min_q_mvar\"] = -9999.\n    net[\"ext_grid\"].loc[:, \"max_q_mvar\"] = 9999.\n    # define costs\n    for i in net.ext_grid.index:\n        pp.create_poly_cost(net, i, 'ext_grid', cp1_eur_per_mw=1)\n\n```\n\n----------------------------------------\n\nTITLE: Saving pandapower network to SQLite database\nDESCRIPTION: Function to save a pandapower network to a SQLite database. SQLite is a lightweight, serverless relational database engine.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\npandapower.to_sqlite\n```\n\n----------------------------------------\n\nTITLE: Asserting Version for Deprecated Functionality Tests in Python\nDESCRIPTION: This snippet shows how to add a version check in tests for deprecated functionality, ensuring they only run for specific versions of PandaPower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/deprecating.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom packaging.version import Version\nassert Version(pp.__version__) < Version('2.12')\n```\n\n----------------------------------------\n\nTITLE: Comparing Running Time of Network Simulations in Python\nDESCRIPTION: This snippet creates a second network with standard configurations to compare the computational efficiency of running power flow analyses with and without tap dependent impedance settings.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet2 = create_net()\nnet2.trafo[\"id_characteristic_table\"] = np.nan\nnet2.trafo[\"tap_dependency_table\"] = False\n```\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net2)\n```\n\nLANGUAGE: python\nCODE:\n```\n%timeit pp.runpp(net)\n```\n\n----------------------------------------\n\nTITLE: Four Loads with Branches Out Network Documentation\nDESCRIPTION: Documentation for pandapower's four loads with branches out test network configuration with visual diagram reference\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/test.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: pandapower.networks.four_loads_with_branches_out\n\n.. image:: /pics/networks/simple_nw_four_loads_with_branches_out.png\n\t:width: 20em\n\t:alt: alternate Text\n\t:align: center\n```\n\n----------------------------------------\n\nTITLE: Defining Table of Contents for Plotting Documentation in reStructuredText\nDESCRIPTION: This snippet defines a table of contents (toctree) in reStructuredText format, listing the various plotting methods available in pandapower. It includes links to documentation for Matplotlib, Plotly, HTML, and geo plotting.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree:: \n    :maxdepth: 1\n    \n    plotting/matplotlib/matplotlib\n    plotting/plotly/plotly\n    plotting/html\n    plotting/geo\n```\n\n----------------------------------------\n\nTITLE: Using warnings.warn for Deprecation in Python\nDESCRIPTION: This code demonstrates how to use the warnings.warn function to issue a deprecation warning. It allows for specifying the warning category.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/deprecating.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwarnings.warn(\"Notification message\", category=DeprecationWarning)\n```\n\n----------------------------------------\n\nTITLE: Plotting Line Temperature vs Current for Different Wind Angles in Python\nDESCRIPTION: This code snippet creates a plot using matplotlib to visualize the relationship between line temperature and current for different wind angle scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nax=plt.subplot()\nax.plot(np.vstack([t_0, t_45, t_90]).T, label=[\"0 °\", \"45 °\", \"90 °\"])\nax.grid(True)\nax.set_ylabel('Line temperature (°C)')\nax.set_xlabel('Current (A)')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Calculating Synchronous Generator Short-Circuit Impedance in LaTeX\nDESCRIPTION: These equations calculate the short-circuit impedance of a synchronous generator. It includes the generator correction factor calculation and uses parameters from the gen table.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/voltage_source.rst#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\underline{Z}_{k, gen} = K_G \\cdot (R''_d + jX''_d)\n\nz_k = xdss  \n\nK_G = \\frac{V_{N, gen}}{V_{N, bus}} \\cdot \\frac{c_{max}}{1 + x_{dss} \\cdot sin(\\varphi)}\n\n\\varphi = arcos(cos\\_phi)\n```\n\n----------------------------------------\n\nTITLE: Setting Group Reference Column\nDESCRIPTION: Shows how to set and use reference columns for group member identification instead of indices, which is more robust when element indices change.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"Group 1 data with indices:\\n\")\nprint(net.group.loc[gr1_idx])\n\npp.set_group_reference_column(net, gr1_idx, \"name\")\n\nprint(\"\\nAfter setting 'name' as reference column, the group stores the members by the names:\\n\")\nprint(net.group.loc[gr1_idx])\n```\n\n----------------------------------------\n\nTITLE: Storing PowerModels Results\nDESCRIPTION: Creates deep copies of voltage angle and magnitude results from PowerModels calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nva_pm = copy.deepcopy(net.res_bus.va_degree)\nvm_pm = copy.deepcopy(net.res_bus.vm_pu)\n```\n\n----------------------------------------\n\nTITLE: Impedance Nodal Point Admittance Matrix\nDESCRIPTION: Matrix representation of the asymmetric nodal point admittance resulting from asymmetric impedance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/impedance.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix} Y_{00} & \\dots & \\dots  & Y_{nn} \\\\\n\\vdots & \\ddots & \\underline{y}_{ft} & \\vdots \\\\\n\\vdots &  \\underline{y}_{tf} & \\ddots & \\vdots \\\\\n\\underline{Y}_{n0} & \\dots & \\dots & \\underline{y}_{nn}\\\\\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Importing Necessary Libraries\nDESCRIPTION: This code snippet imports the required libraries for the Temperature-Dependent Power Flow (TDPF) calculation in pandapower. It includes libraries for plotting, data manipulation, and pandapower-specific functionalities.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport pandapower as pp\nimport pandapower.plotting\nfrom pandapower.test.loadflow.test_tdpf import simple_test_grid\nfrom pandapower.pf.create_jacobian_tdpf import *\nfrom pandapower.pypower.idx_brch import BR_R, BR_X\n```\n\n----------------------------------------\n\nTITLE: Updating Input Data with Optimization Results in Python\nDESCRIPTION: This code snippet shows how to update the pandapower input DataFrames with the results from the OTS optimization, including the option to run a power flow calculation using the updated in_service status for lines and transformers.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_ost.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp    \n\n# Change the input data\n#net[\"line\"].loc[:,\"in_service\"].values = net[\"res_line\"].loc[:,\"in_service\"]\n#net[\"trafo\"].loc[:,\"in_service\"].values = net[\"res_trafo\"].loc[:,\"in_service\"]\n\n# optional: run a power flow calculation with the changed in service status\npp.runpp(net)\n\n```\n\n----------------------------------------\n\nTITLE: Testing PowerFactory Import\nDESCRIPTION: Simple import statement to verify PowerFactory module can be imported correctly after setup. This confirms the Python-PowerFactory integration is working.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport powerfactory\n```\n\n----------------------------------------\n\nTITLE: Commented Warning Example\nDESCRIPTION: Example of code that would raise a warning (commented out for demonstration).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n#this would raise a warning:\n#net6.trafo.loc[1,\"tap_dependency_table\"] = True\n#pp.control.util.diagnostic.trafo_characteristic_table_diagnostic(net6)\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower and loading example network\nDESCRIPTION: Imports necessary modules and loads the mv_oberrhein example network from pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\nimport pandas as pd\n\nnet = nw.mv_oberrhein()\n```\n\n----------------------------------------\n\nTITLE: Importing Required Libraries for Grid Equivalents\nDESCRIPTION: Imports necessary PandaPower modules and matplotlib for visualization of grid equivalents\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nimport pandapower as pp\nimport pandapower.plotting as plotting\nimport pandapower.networks\nimport pandapower.grid_equivalents\n```\n\n----------------------------------------\n\nTITLE: Finding Disconnected Buses\nDESCRIPTION: Shows how to identify buses that are not connected to an external grid using the unsupplied_buses function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/examples.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.topology import unsupplied_buses\n\nnet.switch.closed.at[11] = 0\nunsupplied_buses(net)\n```\n\n----------------------------------------\n\nTITLE: Git configuration for pandapower contribution\nDESCRIPTION: Git configuration that sets up multiple remotes for pandapower development. This configuration enables easy synchronization with both the official repository and your personal fork.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n[remote \"origin\"]\n    url = https://github.com/e2nIEE/pandapower.git\n    fetch = +refs/heads/*:refs/remotes/pp/*\n    pushurl = https://github.com/YOUR-USERNAME/pandapower.git\n[remote \"pp\"]\n    url = https://github.com/e2nIEE/pandapower.git\n    fetch = +refs/heads/*:refs/remotes/pp/*\n[remote \"pp_fork\"]\n    url = https://github.com/YOUR-USERNAME/pandapower.git\n    fetch = +refs/heads/*:refs/remotes/pp_fork/*\n[branch \"develop\"]\n    remote = origin\n    merge = refs/heads/develop\n```\n\n----------------------------------------\n\nTITLE: Commented Error Example\nDESCRIPTION: Example of code that would raise an error (commented out for demonstration).\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n#this would raise an error:\n#pp.runpp(net6)\n```\n\n----------------------------------------\n\nTITLE: Box Plot for Line Loading Distribution\nDESCRIPTION: This snippet creates a box plot to further analyze the distribution of loadings on Line 8, which demonstrates a narrow distribution. It uses a horizontal box plot to portray the data comprehensively and uses Matplotlib's plotting capabilities for visualization.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/uncertainties_in_powerflow.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots()\nresults_dict[\"res_line.loading_percent\"][8].plot(kind=\"box\", vert=False, color=\"orange\", ax=ax)\nax.set_ylabel(\"Line\")\nax.set_xlabel(\"Loading in percent\")\nplt.tight_layout()\n```\n\n----------------------------------------\n\nTITLE: Running Asymmetric Three-Phase Power Flow in Python using pandapower\nDESCRIPTION: This function, runpp_3ph, is used to perform asymmetric three-phase power flow calculations in pandapower. It utilizes the Sequence Frame method for solving unbalanced power flow problems.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/ac_3ph.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.pf.runpp_3ph.runpp_3ph\n```\n\n----------------------------------------\n\nTITLE: Linking to Grid Equivalents Tutorial in reStructuredText\nDESCRIPTION: This snippet provides a hyperlink to the Jupyter notebook tutorial for grid equivalents in the pandapower library. It uses reStructuredText syntax to create a clickable link to the GitHub repository where the tutorial is hosted.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/tutorials.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n`get equivalents <https://github.com/e2nIEE/pandapower/blob/develop/tutorials/grid_equivalents.ipynb>`_\n```\n\n----------------------------------------\n\nTITLE: Diagnostic Function Examples\nDESCRIPTION: Shows various diagnostic checks for transformer characteristics and configurations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nnet_diagnostics = net\nnet_diagnostics.trafo.loc[0, \"id_characteristic_table\"] = None\npp.control.util.diagnostic.trafo_characteristic_table_diagnostic(net_diagnostics)\n\nnet_diagnostics.trafo.loc[0, \"id_characteristic_table\"] = 0\nnet_diagnostics.trafo.loc[0, \"tap_changer_type\"] = None\npp.control.util.diagnostic.trafo_characteristic_table_diagnostic(net_diagnostics)\n```\n\n----------------------------------------\n\nTITLE: Initializing PowerFactory Application in Python\nDESCRIPTION: Code to import the PowerFactory module and initialize the PowerFactory Application object. This starts an instance of PowerFactory for use in Engine mode.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport powerfactory as pf\napp = pf.GetApplication()\n```\n\n----------------------------------------\n\nTITLE: Cloning a forked pandapower repository\nDESCRIPTION: Command to clone your personal fork of the pandapower repository to your local machine. This is the first step in setting up your development environment.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/YOUR-USERNAME/pandapower.git\n```\n\n----------------------------------------\n\nTITLE: Ward Result Parameter Equations\nDESCRIPTION: Mathematical equations defining the result parameters for Ward equivalents including voltage magnitude and power calculations\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ward.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nvm\\_pu &= v_{bus} \\\\\np\\_mw &= P_{const} + Re(\\frac{\\underline{V}_{bus}^2}{\\underline{Y}_{shunt}}) \\\\\nq\\_mvar &= Q_{const} + Im(\\frac{\\underline{V}_{bus}^2}{\\underline{Y}_{shunt}})\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Piecewise Linear Cost Functions\nDESCRIPTION: This snippet demonstrates how to set up piecewise linear cost functions for generators and the external grid, providing an alternative to polynomial cost functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_basic.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet.poly_cost.drop(net.poly_cost.index.values, inplace=True)\npp.create_pwl_cost(net, 0, \"gen\", [[0, 80, 15]])\npp.create_pwl_cost(net, 1, \"gen\", [[0, 100, 12]])\npp.create_pwl_cost(net, 0, \"ext_grid\", [[-1000, 1000, 10]])\n```\n\n----------------------------------------\n\nTITLE: Plotting Line Temperature vs Current for Different Air Temperatures in Python\nDESCRIPTION: This code snippet creates a plot using matplotlib to visualize the relationship between line temperature and current for different air temperature scenarios.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_parameters.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nax=plt.subplot()\nax.plot(np.vstack([t_0, t_20, t_40]).T, label=[\"0 °C\", \"20 °C\", \"40 °C\"])\nax.grid(True)\nax.set_ylabel('Line temperature (°C)')\nax.set_xlabel('Current (A)')\nax.legend()\n```\n\n----------------------------------------\n\nTITLE: Converting Phase-to-Phase Voltage to Phase-to-Earth Voltage (LaTeX)\nDESCRIPTION: Formula for converting phase-to-phase voltage to phase-to-earth voltage in a three-phase system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/units.rst#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\nv_{an} = \\frac{V_{ab}}{\\sqrt3}\n```\n\n----------------------------------------\n\nTITLE: Current-Based Loading Calculation\nDESCRIPTION: Formula for calculating transformer loading percentage based on current measurements.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_10\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nloading_percent &= max(\\frac{i_{hv} \\cdot vn_hv_kv}{sn_mva}, \\frac{i_{lv} \\cdot vn_lv_kv}{sn_mva}) \\cdot 100\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Deleting pandapower network from PostgreSQL database\nDESCRIPTION: Function to delete a pandapower network from a PostgreSQL database. This allows for removing previously saved networks from the database.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/file_io.rst#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\npandapower.delete_postgresql_net\n```\n\n----------------------------------------\n\nTITLE: Including Images in ReStructuredText for pandapower Documentation\nDESCRIPTION: This snippet demonstrates how to include and format images in ReStructuredText, specifically for the pandapower logo and developer institute logos.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. image:: /pics/pp.svg\n\t\t:width: 250em\n\t\t:align: left\n\n.. |br| raw:: html\n\n    <br />\n\n|br|\n|br|\n|br|\n\n.. image:: /pics/iee.png\n\t\t:width: 18em\n\t\t:align: left\n\n.. image:: /pics/e2n.png\n\t\t:width: 22em\n\t\t:align: right\n\n\n\n|br|\n|br|\n|br|\n|br|\n```\n\n----------------------------------------\n\nTITLE: Checking Standard Type Existence in PandaPower\nDESCRIPTION: Function reference for verifying if a standard type exists using pandapower.std_type_exists\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\npandapower.std_type_exists\n```\n\n----------------------------------------\n\nTITLE: Removing Bad Data in State Estimation for pandapower\nDESCRIPTION: This code demonstrates how to remove bad data from the state estimation process using the remove_bad_data function and access the results.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/estimation.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsuccess_rn_max = remove_bad_data(net, init=\"flat\")\nV_rn_max, delta_rn_max = net.res_bus_est.vm_pu, net.res_bus_est.va_degree\n```\n\n----------------------------------------\n\nTITLE: Explicit git commands for pulling and pushing to specific remotes\nDESCRIPTION: Commands to explicitly pull from the official pandapower repository and push to your fork. This provides more control over which repositories you're interacting with.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit pull pp develop\ngit push pp_fork develop\n```\n\n----------------------------------------\n\nTITLE: Creating External Grid Connection\nDESCRIPTION: Adds an external grid connection as slack node with specified voltage magnitude and angle.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/create_simple.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.create_ext_grid(net, bus1, vm_pu=1.02, va_degree=50)\n```\n\n----------------------------------------\n\nTITLE: Importing the CIM to pandapower Converter Module\nDESCRIPTION: Basic import statement required to use the CIM to pandapower converter functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.converter import from_cim as cim2pp\n```\n\n----------------------------------------\n\nTITLE: Accessing PowerFactory Attribute in Python\nDESCRIPTION: Shows the correct method for accessing an attribute of a PowerFactory object. This snippet fixes an error where 'GetAttributes' was incorrectly used instead of 'GetAttribute'.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CHANGELOG.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nobj.GetAttribute(a)\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Vorstadtnetz Kabel_a Typ I Network in Python\nDESCRIPTION: This snippet demonstrates how to create an Extreme Vorstadtnetz Kabel_a Typ I network using the kb_extrem_vorstadtnetz_1() function from pandapower.networks. The resulting network is stored in the 'net' variable.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_vorstadtnetz_1\n\n'''Extrem Vorstadtnetz Kabel_a Typ I'''\nnet = kb_extrem_vorstadtnetz_1()\n```\n\n----------------------------------------\n\nTITLE: MultiGraph Creation Excluding Lines and Impedances\nDESCRIPTION: Creates a NetworkX MultiGraph while excluding lines and impedances from the conversion process.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/create_graph.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncreate_nxgraph(net, include_lines = False, include_impedances = False)\n```\n\n----------------------------------------\n\nTITLE: Importing PandaPower Create Module\nDESCRIPTION: Imports the create module from pandapower for group creation functionality.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/group.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower.create\n```\n\n----------------------------------------\n\nTITLE: Adding and committing changes to pandapower\nDESCRIPTION: Commands to add all changes to the staging area and commit them with a message. The example shows how to reference an issue number in the commit message.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ngit add --all\ngit commit -m \"commit message\"\n```\n\n----------------------------------------\n\nTITLE: Four Load Branch Network Documentation\nDESCRIPTION: Documentation for pandapower's four load branch test network configuration with visual diagram reference\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/test.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: pandapower.networks.panda_four_load_branch\n\n.. image:: /pics/networks/simple_nw_panda_four_load_branch.png\n\t:width: 10em\n\t:alt: alternate Text\n\t:align: center\n```\n\n----------------------------------------\n\nTITLE: Creating Network Structure with PandaPower\nDESCRIPTION: Creates a test network with 5 buses, lines, DC line, external grids and load. Sets up the basic network topology with specific parameters for each component.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/opf_dcline.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nfrom numpy import array\nnet = pp.create_empty_network()\n\nb1 = pp.create_bus(net, 380)\nb2 = pp.create_bus(net, 380)\nb3 = pp.create_bus(net, 380)\nb4 = pp.create_bus(net, 380)\nb5 = pp.create_bus(net, 380)\n\nl1 = pp.create_line(net, b1, b2, 30, \"490-AL1/64-ST1A 380.0\")\nl2 = pp.create_line(net, b3, b4, 20, \"490-AL1/64-ST1A 380.0\")\nl3 = pp.create_line(net, b4, b5, 20, \"490-AL1/64-ST1A 380.0\")\n\ndcl1 = pp.create_dcline(net, name=\"dc line\", from_bus=b2, to_bus=b3, p_mw=200, loss_percent=1.0, \n                  loss_mw=0.5, vm_from_pu=1.01, vm_to_pu=1.012, max_p_mw=1000,\n                  in_service=True)\n\neg1 = pp.create_ext_grid(net, b1, 1.02, min_p_mw=0.)\neg2 = pp.create_ext_grid(net, b5, 1.02, min_p_mw=0.)\n\nl1 = pp.create_load(net, bus=b4, p_mw=800, controllable = False)\n```\n\n----------------------------------------\n\nTITLE: Wind Speed Data Generation and Plotting\nDESCRIPTION: Creates and visualizes wind speed profile data used for the simulation example.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndata = pd.DataFrame(columns=[\"wind_speed_m_per_s\"], data=np.arange(0.5, 3, 0.1), index=np.arange(25, dtype=np.int64))\nax = data.plot(figsize=(5, 2.5))\nax.set_title(\"Wind speed data (m/s)\")\nax.set_ylabel(\"Wind speed (m/s)\")\nax.set_xlabel(\"Time step\");\n```\n\n----------------------------------------\n\nTITLE: Updating a pull request with new commits\nDESCRIPTION: Commands to add, commit, and push additional changes to update an existing pull request. This is useful when responding to review feedback.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\ngit add --all\ngit commit -m \"I have updated the pull request after discussions #3\"\ngit push\n```\n\n----------------------------------------\n\nTITLE: Internal Resistance Definition - LaTeX Math Formula\nDESCRIPTION: Mathematical definition of the internal resistance for the Extended Ward equivalent.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/xward.rst#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{z}_{int} &= r\\_pu + j \\cdot x\\_pu\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies for TDPF Timeseries\nDESCRIPTION: Imports required libraries including pandapower and its modules for control, timeseries functionality and testing utilities.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow_timeseries.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nimport pandapower as pp\nimport pandapower.control\nimport pandapower.timeseries\n\nfrom pandapower.control.basic_controller import Controller\n\nfrom pandapower.test.loadflow.test_tdpf import simple_test_grid\n```\n\n----------------------------------------\n\nTITLE: Grid Model Export Function\nDESCRIPTION: Shows the commented code for exporting a grid model from PowerFactory to pandapower format using the from_pfd function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/converter_powerfactory.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n#net = from_pfd(app, prj_name=\"PFExample\")\n```\n\n----------------------------------------\n\nTITLE: Comparing Network Results and Creating Equivalent\nDESCRIPTION: Prints power flow results for both networks and creates a REI equivalent of the modified network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents_workarounds.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprint(\"net with dcline\", net.res_bus)\nprint(\"net with represented dcline\", net2.res_bus)\nnet_eq = get_equivalent(net2, \"rei\", [4,8], [0])\nprint(\"equivalent net\", net_eq.res_bus)\n```\n\n----------------------------------------\n\nTITLE: Pushing a new branch to your fork\nDESCRIPTION: Command to push a new feature branch to your fork and set up remote tracking. This is used when you've created a local branch that doesn't exist in your remote repository yet.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ngit push -u pp_fork my_branch\n```\n\n----------------------------------------\n\nTITLE: Accessing Geographical Data in pandapower 3.0\nDESCRIPTION: Shows the change in how geographical data is accessed in pandapower 3.0. Previously stored in separate tables, geo data is now stored as geojson strings within the element tables.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update30.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# OLD (before v3.0)\nnet.bus_geodata  # separate table for bus geo data\nnet.line_geodata  # separate table for line geo data\n\n# NEW (v3.0+)\nnet.bus.geo  # geojson strings in the bus table\nnet.line.geo  # geojson strings in the line table\n```\n\n----------------------------------------\n\nTITLE: Line Impedance Calculation in LaTeX\nDESCRIPTION: Calculates the resistance and reactance of a line considering length, parallel lines, and correction factor KL for short circuit analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/branch_elements.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{R}_k &= r\\_ohm\\_per\\_km \\cdot \\frac{length\\_km}{parallel} \\cdot K_L\\\\\n\\underline{X}_k &= x\\_ohm\\_per\\_km \\cdot \\frac{length\\_km}{parallel} \n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: PowerFactory Engine Mode Initialization\nDESCRIPTION: Contains commented code for starting and displaying PowerFactory in engine mode.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/converter_powerfactory.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#app = pf.GetApplication()\n```\n\nLANGUAGE: python\nCODE:\n```\n#app\n```\n\nLANGUAGE: python\nCODE:\n```\n#app.Show()\n```\n\n----------------------------------------\n\nTITLE: Resetting Transformer Index\nDESCRIPTION: Resets the transformer index to prevent KeyError in subsequent operations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo.reset_index(inplace=True, drop=True)\n```\n\n----------------------------------------\n\nTITLE: Including CHANGELOG.rst in reStructuredText Documentation\nDESCRIPTION: This snippet uses a reStructuredText directive to include the CHANGELOG.rst file from the parent directory into the current document. It also defines a reference label for the changelog section.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/changelog.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. _changelog:\n\n.. include:: ../../CHANGELOG.rst\n```\n\n----------------------------------------\n\nTITLE: Example of a buggy pandapower function\nDESCRIPTION: An example of a buggy implementation that would be caught by the test suite. This demonstrates how tests help maintain code quality by catching regressions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef double_rated_power(net):\n   net.sn_kva *= 3\n```\n\n----------------------------------------\n\nTITLE: Creating Test Network Configuration\nDESCRIPTION: Creates a simple test network with five buses, transformer, lines, load and static generator. Includes power flow calculation options.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_advanced_output.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef simple_test_net():\n    \"\"\"\n    simple net that looks like:\n\n    ext_grid b0---b1 trafo(110/20) b2----b3 load\n                                    |\n                                    |\n                                    b4 sgen\n    \"\"\"\n    net = pp.create_empty_network()\n    pp.set_user_pf_options(net, init_vm_pu = \"flat\", init_va_degree = \"dc\", calculate_voltage_angles=True)\n\n    b0 = pp.create_bus(net, 110)\n    b1 = pp.create_bus(net, 110)\n    b2 = pp.create_bus(net, 20)\n    b3 = pp.create_bus(net, 20)\n    b4 = pp.create_bus(net, 20)\n\n    pp.create_ext_grid(net, b0)\n    pp.create_line(net, b0, b1, 10, \"149-AL1/24-ST1A 110.0\")\n    pp.create_transformer(net, b1, b2, \"25 MVA 110/20 kV\", name='tr1')\n    pp.create_line(net, b2, b3, 10, \"184-AL1/30-ST1A 20.0\")\n    pp.create_line(net, b2, b4, 10, \"184-AL1/30-ST1A 20.0\")\n\n    pp.create_load(net, b2, p_mw=15., q_mvar=10., name='load1')\n    pp.create_sgen(net, b4, p_mw=20., q_mvar=0.15, name='sgen1')\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Comparing sgen Power Generation Before and After OPF\nDESCRIPTION: This snippet compares the power generation of a static generator (sgen) before and after executing the optimal power flow. By plotting original and optimized power generation profiles, it highlights the impact of OPF on sgen’s performance over the time series.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/timeseries_opf.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\n# sgen results\nsgen_file = os.path.join(output_dir, \"res_sgen\", \"p_mw.xlsx\")\nsgen = pd.read_excel(sgen_file, index_col=0)\nax=sgen[0].plot(label=\"sgen (after OPF)\")\nds.df.sgen1_p.plot(ax=ax, label=\"sgen (original)\", linestyle='--')\nax.legend()\nplt.xlabel(\"time step\")\nplt.ylabel(\"P [MW]\")\nplt.grid()\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Extended Ward Power Calculations - LaTeX Math Formulas\nDESCRIPTION: Mathematical formulas defining the constant apparent power calculations for the Extended Ward equivalent.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/xward.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nP_{const} &= ps\\_mw\\\\\nQ_{const} &= qs\\_mvar\\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Ward Power Equations - Constant Power Components\nDESCRIPTION: Mathematical equations defining the constant apparent power components of a Ward equivalent\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ward.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\nP_{const} &= ps\\_mw\\\\\nQ_{const} &= qs\\_mvar\\\\\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Kerber Network in Python with pandapower\nDESCRIPTION: Simple example of creating a basic Kerber network using the create_kerber_net function from pandapower.networks module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_net\n\nnet1 = create_kerber_net()\n```\n\n----------------------------------------\n\nTITLE: Linux Gurobi Environment Configuration\nDESCRIPTION: Bash environment variable configuration for Gurobi solver on Linux systems, including paths and license file location.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pandamodels.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# gurobi\nexport GUROBI_HOME=\"/opt/gurobi_VERSION/linux64\"\nexport PATH=\"${PATH}:${GUROBI_HOME}/bin\"\nexport LD_LIBRARY_PATH=\"${LD_LIBRARY_PATH}:${GUROBI_HOME}/lib\"\nexport GRB_LICENSE_FILE=\"/PATH_TO_YOUR_LICENSE_DIR/gurobi.lic\"\n```\n\n----------------------------------------\n\nTITLE: Mathematical Model of SSC Terminal-Admittance Equation in LaTeX\nDESCRIPTION: The mathematical equation representing the terminal-admittance relationship for the Static Synchronous Compensator. It shows how the SSC connects to the AC system through a coupling transformer, with Y_T representing the transformer admittance.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/ssc.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{Y}_{T} (\\underline{V}_{1} - \\underline{V}_{VSC}) = \\underline{I}_{1}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Creating Kerber Village Network in Python\nDESCRIPTION: Creates a village Kerber network (Dorfnetz) with higher number of loads per transformer compared to rural networks. This network has 57 loads and a larger transformer size.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_dorfnetz\n\nnet = create_kerber_dorfnetz()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (57 elements) p_load_in_mw=6,  q_load_in_mw=0\n  - bus (116 elements)\n  - line (114 elements) std_type=\"NAYY 150\"; std_type_branchout_line=\"NAYY 50\"\n  - trafo (1 elements) std_type=\"0.4 MVA 10/0.4 kV Yyn6 4 ASEA\"\n  - ext_grid (1 elements)\n'''\n```\n\n----------------------------------------\n\nTITLE: Accessing Matplotlib Colormaps in Python\nDESCRIPTION: Shows the updated method for accessing Matplotlib colormaps, replacing the deprecated 'get_cmap' function with the new dictionary-style access.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CHANGELOG.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nmatplotlib.colormaps[name]\n```\n\n----------------------------------------\n\nTITLE: Converting CGMES Files from a Directory\nDESCRIPTION: Example of converting all files in a directory to a pandapower network by creating a list of file paths.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os\ncurr_xml_dir = 'example_cim\\\\test'\ncgmes_files = [curr_xml_dir + os.sep + x for x in os.listdir(curr_xml_dir)]\n```\n\n----------------------------------------\n\nTITLE: VSC Terminal-Admittance Equation in LaTeX\nDESCRIPTION: Mathematical representation of the VSC terminal-admittance equation. It relates the terminal admittance, voltages, and current in the VSC system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/vsc.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{align*}\n\\underline{Y}_{T} (\\underline{V}_{1} - \\underline{V}_{VSC}) = \\underline{I}_{1}\n\\end{align*}\n```\n\n----------------------------------------\n\nTITLE: Calculating Current Source Contribution for All Buses in LaTeX\nDESCRIPTION: This LaTeX equation demonstrates how to calculate the current source contribution for short-circuit currents at all buses simultaneously using the impedance matrix and converter element currents.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ikss.rst#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{bmatrix}\n\\underline{I}''_{kII1} \\\\[0.5em]\n\\vdots  \\\\[0.5em]\n\\vdots  \\\\[0.5em]\n\\underline{I}''_{kIIn}\n\\end{bmatrix} = \n\\begin{bmatrix}\n\\underline{Z}_{11} & \\dots & \\dots & \\underline{Z}_{n1} \\\\[0.3em]\n\\vdots & \\ddots & & \\vdots \\\\[0.3em]\n\\vdots & & \\ddots & \\vdots \\\\[0.3em]\n\\underline{Z}_{1n} & \\dots & \\dots & \\underline{Z}_{nn}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\frac{I''_{kC1}}{\\underline{Z}_{11}} \\\\[0.25em]\n\\vdots  \\\\\n\\vdots  \\\\[0.25em]\n\\frac{I''_{kCn}}{\\underline{Z}_{nn}}\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Vorstadtnetz Kabel_b Typ I Network in Python\nDESCRIPTION: This snippet shows how to create an Extreme Vorstadtnetz Kabel_b Typ I network using the kb_extrem_vorstadtnetz_2() function from pandapower.networks. The resulting network is stored in the 'net' variable.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_vorstadtnetz_2\n\n'''Extrem Vorstadtnetz Kabel_b Typ I'''\nnet = kb_extrem_vorstadtnetz_2()\n```\n\n----------------------------------------\n\nTITLE: Configuration Code References\nDESCRIPTION: Code references mentioned in changelog including toolbox, cim2pp, and other module functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CHANGELOG.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ntoolbox.replace_zero_branches_with_switches\nreindex_elements\ncim2pp\n__init__\ngroups.py\ncheck_unique_group_names\nappend_to_group\n_get_bus_v_results\nOptAlgorithm\nsimple_plotly\ndrop_from_group()\nattach_to_group()\ncheck_unique_group_rows()\ntoolbox.count_elements\ntoolbox.drop_elements\ntoolbox.res_power_columns\n```\n\n----------------------------------------\n\nTITLE: Documenting Continuous Colormap Function in pandapower\nDESCRIPTION: This snippet documents the cmap_continuous function from pandapower's plotting.colormaps module using the autofunction directive in reStructuredText.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/matplotlib/create_colormaps.rst#2025-04-22_snippet_1\n\nLANGUAGE: rst\nCODE:\n```\n.. autofunction:: pandapower.plotting.colormaps.cmap_continuous\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Vorstadtnetz Kabel_c Typ II Network in Python\nDESCRIPTION: This snippet illustrates how to create an Extreme Vorstadtnetz Kabel_c Typ II network using the kb_extrem_vorstadtnetz_trafo_1() function from pandapower.networks. The resulting network is stored in the 'net' variable.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_vorstadtnetz_trafo_1\n\n'''Extrem Vorstadtnetz Kabel_c Typ II'''\nnet = kb_extrem_vorstadtnetz_trafo_1()\n```\n\n----------------------------------------\n\nTITLE: Installing Numba for Performance Improvement\nDESCRIPTION: Optional installation of numba package to increase conversion speed.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\npip install numba\n```\n\n----------------------------------------\n\nTITLE: Converting a Single CGMES Zip File\nDESCRIPTION: Example of converting a single CGMES zip file to a pandapower network using the from_cim function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/cgmes.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncgmes_files = r'example_cim\\CGMES_v2.4.15_RealGridTestConfiguration_v2.zip'\n```\n\n----------------------------------------\n\nTITLE: Correction Factors Formula in LaTeX\nDESCRIPTION: Mathematical equations for correction factors m and n used in short-circuit current calculations, where n equals 1 and m is calculated based on frequency, duration, and peak factor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ith.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nn = 1\nm = \\frac{1}{2 \\cdot f \\cdot T_k \\cdot ln(\\kappa - 1)} [e^{4 \\cdot f \\cdot T_k \\cdot ln(\\kappa - 1)} - 1]\n```\n\n----------------------------------------\n\nTITLE: Creating Table of Contents in ReStructuredText for pandapower Documentation\nDESCRIPTION: This snippet shows how to create a table of contents in ReStructuredText, listing various sections of the pandapower documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n    :maxdepth: 2\n\n    about\n    elements\n    std_types\n    powerflow\n    contingency\n    opf\n    shortcircuit\n    estimation\n    control\n    timeseries\n    gridequivalent\n    topology\n    networks\n    plotting\n    file_io\n    converter\n    group\n    toolbox\n    protection\n```\n\n----------------------------------------\n\nTITLE: RestructuredText Documentation for MATPOWER Converters\nDESCRIPTION: RestructuredText documentation defining the MATPOWER converter functions reference section, including autofunction directives for from_mpc and to_mpc converters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/matpower.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n==============\nMATPOWER\n==============\n\n.. _converter_matpower:\n\nTo communicate to MATPOWER to exchange network data these functions are available.\n\n.. autofunction:: pandapower.converter.from_mpc\n\n.. autofunction:: pandapower.converter.to_mpc\n```\n\n----------------------------------------\n\nTITLE: Creating Kerber Rural Networks with Underground Cables in Python\nDESCRIPTION: Creates rural Kerber networks (Landnetze) with underground cables using two different configurations. Each network has different number of loads and components.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_landnetz_kabel_1, create_kerber_landnetz_kabel_2\n\nnet1 = create_kerber_landnetz_kabel_1()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (8 elements)  p_load_in_mw=8,  q_load_in_mw=0\n  - bus (18 elements)\n  - line (16 elements)  std_type=\"NAYY 150\", std_type_branchout_line=\"NAYY 50\"\n  - trafo (1 elements)  std_type = \"0.125 MVA 10/0.4 kV Dyn5 ASEA\"\n  - ext_grid (1 elements)\n'''\n\nnet2 = create_kerber_landnetz_kabel_2()\n\n'''\nThis pandapower network includes the following parameter tables:\n - load (14 elements)  p_load_in_mw=8,  q_load_in_mw=0\n - bus (30 elements)\n - line (28 elements)  std_type=\"NAYY 150\", std_type_branchout_line=\"NAYY 50\"\n - trafo (1 elements)  std_type=\"0.125 MVA 10/0.4 kV Dyn5 ASEA\"\n - ext_grid (1 elements)\n'''\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Kerber Rural Networks Type II in Python\nDESCRIPTION: Creates extreme rural Kerber networks with overhead lines or underground cables and high loaded transformers. These Type II networks represent edge cases with both extreme lines and high transformer load.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_landnetz_freileitung_trafo, kb_extrem_landnetz_kabel_trafo\n\n'''Extrem Landnetz Freileitung Typ II'''\nnet = kb_extrem_landnetz_freileitung_trafo()\n\n\n'''Extrem Landnetz Kabel Typ II'''\nnet = kb_extrem_landnetz_kabel_trafo()\n```\n\n----------------------------------------\n\nTITLE: Using simple_plot function in pandapower\nDESCRIPTION: Reference to the simple_plot() function in pandapower's plotting module. This function provides basic network visualization capabilities. For more advanced plotting options, users are directed to a separate plotting tutorial.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/matplotlib/simple_plot.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.plotting.simple_plot\n```\n\n----------------------------------------\n\nTITLE: Sphinx Documentation Reference for OutputWriter Class\nDESCRIPTION: Sphinx documentation directive for automatically generating API documentation for the OutputWriter class from the pandapower.timeseries.output_writer module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/output_writer.rst#2025-04-22_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. autoclass:: pandapower.timeseries.output_writer.OutputWriter\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Creating Extreme Kerber Village Network Type I in Python\nDESCRIPTION: Creates an extreme village Kerber network (Dorfnetz) with underground cables. This Type I network features extreme line parameters to test limit values.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import kb_extrem_dorfnetz\n\n'''Extrem Dorfnetz Kabel Typ I'''\nnet = kb_extrem_dorfnetz()\n```\n\n----------------------------------------\n\nTITLE: Initializing PandaPower Network\nDESCRIPTION: Imports required PandaPower modules and creates a copy of the case9 network for grid equivalent testing.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/grid_equivalents_workarounds.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks\nfrom pandapower.grid_equivalents import get_equivalent\nfrom copy import deepcopy\nnet = pp.networks.case9()\n```\n\n----------------------------------------\n\nTITLE: Formulating Network Equations for Short-Circuit Calculation in LaTeX\nDESCRIPTION: This LaTeX equation represents the network equations for calculating short-circuit at a specific bus. It uses the nodal point admittance matrix and voltage vector to solve for the short-circuit current.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ikss.rst#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{bmatrix}\n\\underline{Y}_{11} & \\dots & \\dots & \\underline{Y}_{n1} \\\\[0.3em]\n\\vdots & \\ddots & & \\vdots \\\\[0.3em]\n\\vdots & & \\ddots & \\vdots \\\\[0.3em]\n\\underline{Y}_{1n} & \\dots & \\dots & \\underline{Y}_{nn}\n\\end{bmatrix}\n\\begin{bmatrix}\n\\underline{V}_{1}  \\\\\n\\vdots  \\\\\nV_{Qj}  \\\\\n\\vdots  \\\\\n\\underline{V}_{n}\n\\end{bmatrix}  \n= \n\\begin{bmatrix}\n0 \\\\\n\\vdots  \\\\\n\\underline{I}''_{kIj} \\\\\n\\vdots  \\\\\n0 \n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Importing MV Oberrhein Network in Python using pandapower\nDESCRIPTION: This code snippet demonstrates how to import and use the MV Oberrhein network function from pandapower. The function creates a generic medium voltage network model based on the Oberrhein region.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/mv_oberrhein.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.networks.mv_oberrhein()\n```\n\n----------------------------------------\n\nTITLE: Creating Network for Transformer Creation\nDESCRIPTION: Initializes a new network for transformer creation examples.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/tap_dependent_impedance.ipynb#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nnet_create = create_net()\n```\n\n----------------------------------------\n\nTITLE: Creating Kerber Suburban Network Type 1 in Python\nDESCRIPTION: Creates a suburban Kerber network (Vorstadtnetz) with underground cables. This network has the highest number of loads per transformer with 146 loads and features multiple types of branch lines.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/kerber.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_kerber_vorstadtnetz_kabel_1\n\nnet1 = create_kerber_vorstadtnetz_kabel_1()\n\n'''\nThis pandapower network includes the following parameter tables:\n  - load (146 elements) p_load_in_mw=2,  q_load_in_mw=0\n  - bus (294 elements)\n  - line (292 elements) std_type=\"NAYY 150\", std_type_branchout_line_1=\"NAYY 50\", std_type_branchout_line_2=\"NYY 35\"\n  - trafo (1 elements) std_type=\"0.63 MVA 20/0.4 kV Yyn6 wnr ASEA\"\n  - ext_grid (1 elements)\n'''\n```\n\n----------------------------------------\n\nTITLE: Medium Voltage Open Ring Network Documentation\nDESCRIPTION: Documentation for pandapower's medium voltage open ring test network configuration with visual diagram reference\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/test.rst#2025-04-22_snippet_3\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. autofunction:: pandapower.networks.simple_mv_open_ring_net\n\n.. image:: /pics/networks/simple_nw_simple_mv_open_ring_net.png\n\t:width: 25em\n\t:alt: alternate Text\n\t:align: center\n```\n\n----------------------------------------\n\nTITLE: Finding Branch Elements on the Shortest Path\nDESCRIPTION: This snippet shows how to locate all line and transformer elements on the shortest path between buses by using the pandapower topology functions.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/topology.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet.line.loc[top.elements_on_path(mg, path, \"line\")]\nnet.trafo.loc[top.elements_on_path(mg, path, \"trafo\")]\n```\n\n----------------------------------------\n\nTITLE: Calculating Complex Transformer Ratio with Phase Shift in pandapower\nDESCRIPTION: Mathematical formula showing how the complex transformer ratio is calculated when voltage angles are considered in the power flow calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/elements/trafo.rst#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n\\underline{n} &= n \\cdot e^{j \\cdot \\theta \\cdot \\frac{\\pi}{180}} \\\\\n\\theta &= shift\\_degree\n```\n\n----------------------------------------\n\nTITLE: Loading Simple Example Network in PandaPower\nDESCRIPTION: Auto-imports a simple example network that demonstrates basic elements supported by the pandapower format. This network serves as a basic introduction to creating pandapower networks.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/example.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.networks.example_simple\n```\n\n----------------------------------------\n\nTITLE: Setting Mapbox Access Token in pandapower\nDESCRIPTION: Code to configure the Mapbox access token for displaying pandapower networks on geographic maps. This token is required to use the Mapbox API functionality within pandapower's plotting system.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/plotting/plotly/plotly.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.plotting.plotly.mapbox_plot import set_mapbox_token\nset_mapbox_token('<token>')\n```\n\n----------------------------------------\n\nTITLE: Defining Standard Type Dictionary Structure in Python\nDESCRIPTION: This snippet shows the structure of the standard types dictionary used in pandapower networks. It includes categories for lines, transformers, and three-winding transformers, each containing type-specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnet.std_types = {\"line\": {\"standard_type\": {\"parameter\": value, ...},..}, \n                    \"trafo\": {\"standard_type\": {\"parameter\": value, ...},..}, \n                    \"trafo3w\": {\"standard_type\": {\"parameter\": value, ...},..}}\n```\n\n----------------------------------------\n\nTITLE: Using lightsim2grid for Faster Contingency Analysis in pandapower\nDESCRIPTION: This snippet demonstrates how to use the lightsim2grid library to speed up contingency analysis in pandapower. It replaces the external grid with a generator and runs the time-series simulation using the lightsim2grid-based contingency analysis function.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ngen_index = pp.replace_ext_grid_by_gen(net, slack=True, cols_to_keep=[\"slack_weight\"])\npp.timeseries.run_timeseries(net, time_steps=range(24), \n                             run_control_fct=pp.contingency.run_contingency_ls2g, nminus1_cases=nminus1_cases)\n```\n\n----------------------------------------\n\nTITLE: Importing pandapower OCRelay Class Documentation\nDESCRIPTION: Documentation reference for the OCRelay class that provides over-current protection functionality. Contains class members and methods documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/protection/oc_relay.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n..autoclass:: pandapower.protection.protection_devices.oc_relay.OCRelay\n    :members:\n    :class-doc-from: class\n```\n\n----------------------------------------\n\nTITLE: Viewing Available Standard Types in PandaPower\nDESCRIPTION: Function reference for pandapower.available_std_types to display all available standard types in the system\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/std_types/manage.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\npandapower.available_std_types\n```\n\n----------------------------------------\n\nTITLE: Calculating Inductive Short Circuit Current in pandapower\nDESCRIPTION: This LaTeX equation calculates the inductive short circuit current for static generator elements in pandapower. It uses the generator's rated power, voltage, and the ratio of nominal to short circuit current. The current angle is also considered in the calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/current_source.rst#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\underline{I}_k = \\cdot \\frac{k \\cdot s\\_n\\_kva}{\\sqrt{3} \\cdot vn\\_kv} \\cdot \\exp(1j \\cdot -\\phi_i)\n```\n\n----------------------------------------\n\nTITLE: Documenting run_timeseries Function in pandapower's Time Series Module (Python)\nDESCRIPTION: This code snippet uses Sphinx's autofunction directive to automatically generate documentation for the run_timeseries function from the pandapower.timeseries.run_time_series module. The function is likely used to execute time series simulations in pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/timeseries/run_function.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autofunction:: pandapower.timeseries.run_time_series.run_timeseries\n```\n\n----------------------------------------\n\nTITLE: Importing and Using PandaPower Diagnostic Function\nDESCRIPTION: This snippet shows how to import and use the diagnostic function from PandaPower. The function takes a network object as an argument and can be customized with optional parameters for detailed reporting and warnings-only output.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/powerflow/diagnostic.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. autofunction:: pandapower.diagnostic\n```\n\n----------------------------------------\n\nTITLE: Creating Medium Voltage CIGRE Network\nDESCRIPTION: Creates a basic medium voltage distribution network without distributed energy resources. The network includes switches, loads, external grid, lines, transformers, buses, and bus geodata.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/networks/cigre.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pandapower.networks import create_cigre_network_mv\n\nnet = create_cigre_network_mv(with_der=False)\n```\n\n----------------------------------------\n\nTITLE: Calculating Equivalent Voltage Source in LaTeX\nDESCRIPTION: This LaTeX equation defines the equivalent voltage source magnitude for three-phase and two-phase short circuit currents. It uses the voltage correction factor and nominal voltage at the fault bus.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/ikss.rst#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\nV_Q =\n\\left\\{\n\\begin{array}{@{}ll@{}}\n  \\frac{c \\cdot \\underline{V}_{N}}{\\sqrt{3}} & \\text{for three phase short circuit currents} \\\\\n  \\frac{c \\cdot \\underline{V}_{N}}{2} & \\text{for two phase short circuit currents}\n\\end{array}\\right.\n```\n\n----------------------------------------\n\nTITLE: Extending and customizing the pandapower framework\nDESCRIPTION: Shows how to extend the pandapower datastructure by adding custom fields and applying operations based on these custom attributes.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/data_analysis.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nnr_buses = len(net.bus.index)\nnet.bus.loc[net.bus.index[:nr_buses], \"zone\"] = \"A\"\nnet.bus.loc[net.bus.index[nr_buses:], \"zone\"] = \"B\"\nnet.bus.zone.head()\n\nfor i, load in net.load.iterrows():\n    if net.bus.zone.at[load.bus] == \"A\":\n        net.load.scaling.at[i] = 0.8\n    elif net.bus.zone.at[load.bus] == \"B\":\n        net.load.scaling.at[i] = 0.6\nnet.load.head(n=5)\n\nnet.scaling = 1.0 #reset\nnet.load[\"zone\"] = net.bus.zone.loc[net.load.bus.values].values\nnet.load.head(n=5)\n\nnet.load.loc[net.load[net.load.zone==\"A\"].index, \"scaling\"] = 0.8\nnet.load.loc[net.load[net.load.zone==\"B\"].index, \"scaling\"] = 0.6\nnet.load.head(n=5)\n```\n\n----------------------------------------\n\nTITLE: Setting Python Path for PowerFactory Integration\nDESCRIPTION: Code snippet showing how to add PowerFactory's Python directory to the system path. This is an alternative to setting the PYTHONPATH environment variable for PowerFactory integration.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/converter/powerfactory.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nsys.path.append(\"C:\\\\Program Files\\\\DIgSILENT\\\\PowerFactory 2022 SP1\\\\Python\\\\3.10\")\n```\n\n----------------------------------------\n\nTITLE: Calculating External Grid Impedance for Minimal Short-Circuit Currents in LaTeX\nDESCRIPTION: These equations calculate the impedance components of an external grid connection for minimal short-circuit currents. It uses parameters from the ext_grid table and the voltage correction factor.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/shortcircuit/voltage_source.rst#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nz_{k, eg} =& \\frac{c_{min}}{s\\_sc\\_min\\_mva} \\\\[1em]\nx_{k, eg} =& \\frac{z_{sg}}{\\sqrt{1 + rx\\_min^2}} \\\\[1em]\nr_{k, eg} =& rx\\_min \\cdot x_{sg}\n```\n\n----------------------------------------\n\nTITLE: Accessing B-matrix for DC Power Flow in pandapower\nDESCRIPTION: Demonstrates how to run a DC power flow and access the B-matrix (susceptance matrix) used in linear power flow calculations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/internal_datastructure.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npp.rundcpp(net)\nnet._ppc['internal']['Bbus'].toarray()\n```\n\n----------------------------------------\n\nTITLE: Calculating corrected zero-sequence impedance without OLTC\nDESCRIPTION: This code calculates the corrected zero-sequence impedance for the power system unit without OLTC, applying the previously calculated correction factor KSO.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nz_0SOK = kso * z_0THV + 3*zn\nz_0SOK.at[0]\n```\n\n----------------------------------------\n\nTITLE: Basic git pull command for pandapower development\nDESCRIPTION: Command to update your local repository with the latest changes from the official pandapower repository. This keeps your local copy synchronized with the official development branch.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Comparing Single-Bus Fault and LU Factorization Methods\nDESCRIPTION: This section compares all-bus fault, single-bus fault, and LU factorization methods for short circuit calculations on specific vector groups.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_1ph_vector_group_trafo3w.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n%%capture\nnet = single_3w_trafo_grid(\"Ynynd\")  \ncalc_sc(net, fault=\"1ph\", case=\"max\")\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\nLANGUAGE: python\nCODE:\n```\n%%capture\nnet = single_3w_trafo_grid(\"Ynynd\")  \ncalc_sc(net, fault=\"1ph\", case=\"max\", bus=0, inverse_y=False)\n```\n\nLANGUAGE: python\nCODE:\n```\ndisplay(net.res_bus_sc)\n```\n\n----------------------------------------\n\nTITLE: MultiGraph Creation with Excluded Buses\nDESCRIPTION: Creates a NetworkX MultiGraph while excluding specific buses (nogobuses) from the graph.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/create_graph.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncreate_nxgraph(net, nogobuses = [4])\n```\n\n----------------------------------------\n\nTITLE: Getting Maximum Line Loading Percentage\nDESCRIPTION: Retrieves the maximum line loading percentage across all lines in the three-phase network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_asymmetric.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nnet.res_line_3ph.loading_percent.max()\n```\n\n----------------------------------------\n\nTITLE: Creating and checking out a feature branch\nDESCRIPTION: Command to create a new branch for a specific feature and switch to it. Feature branches are used for developing new features in isolation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my_branch\n```\n\n----------------------------------------\n\nTITLE: Viewing Controller Table in pandapower (Python)\nDESCRIPTION: This snippet demonstrates how to print the controller table in a pandapower network object. The controller table provides an overview of all registered controllers in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/control/run.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprint(net.controller)\n```\n\n----------------------------------------\n\nTITLE: Checking Transformer Standard Types in Python\nDESCRIPTION: This code displays the standard types of the transformers in the network.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/control_loop.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnet.trafo.std_type\n```\n\n----------------------------------------\n\nTITLE: Finding Connected Component in pandapower (Python)\nDESCRIPTION: Function to identify a connected component in an electrical network graph. It is part of the pandapower.topology module.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/topology/searches.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npandapower.topology.connected_component\n```\n\n----------------------------------------\n\nTITLE: Storing Pypower Results\nDESCRIPTION: Creates deep copies of voltage angle and magnitude results from pypower calculation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_pf .ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nva_pp = copy.deepcopy(net.res_bus.va_degree)\nvm_pp = copy.deepcopy(net.res_bus.vm_pu)\n```\n\n----------------------------------------\n\nTITLE: Setting Python Environment in Julia (MacOS)\nDESCRIPTION: Command to set Python environment variable in Julia for MacOS systems to use an existing Anaconda installation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pandamodels.rst#2025-04-22_snippet_1\n\nLANGUAGE: julia\nCODE:\n```\nENV[\"PYTHON\"]=\"/Users/%Username/opt/anaconda3/bin/python\"\n```\n\n----------------------------------------\n\nTITLE: Polynomial Cost Function Creation\nDESCRIPTION: Demonstrates the evolution of polynomial cost function creation between versions, showing simplified parameter specification in 2.x.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\npp.create_polynomial_costs(net, 3, \"gen\", [0, -10, -100])\n```\n\nLANGUAGE: python\nCODE:\n```\npp.create_poly_cost(net, 3, \"gen\", c_per_mw=0.1, c2_per_mw2=0.01)\n```\n\n----------------------------------------\n\nTITLE: Setting DER and Generator Boundaries\nDESCRIPTION: Defines power limits for distributed energy resources and generators.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/mvsp_pandamodels.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nnet.sgen[\"max_p_mw\"] = net.sgen.p_mw.values\nnet.sgen[\"min_p_mw\"] = net.sgen.p_mw.values\nnet.sgen[\"max_q_mvar\"] = net.sgen.p_mw.values * 0.328\nnet.sgen[\"min_q_mvar\"] = -net.sgen.p_mw.values * 0.328\n\nnet.gen[\"max_p_mw\"] = net.gen.p_mw.values\nnet.gen[\"min_p_mw\"] = net.gen.p_mw.values\nnet.gen[\"max_q_mvar\"] = 10000.0\nnet.gen[\"min_q_mvar\"] = -10000.0\n```\n\n----------------------------------------\n\nTITLE: Creating a CIGRE Network with DER\nDESCRIPTION: This snippet creates a CIGRE medium voltage network with distributed energy resources (DER) using `pandapower.networks.create_cigre_network_mv`. It then runs a power flow analysis using `pp.runpp` to establish a baseline, and saves a copy of the network for later comparison.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/pandamodels_reactive power optimization.ipynb#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\nfrom copy import deepcopy\n\nnet = nw.create_cigre_network_mv(with_der=\"pv_wind\")\npp.runpp(net)\nnet_org = deepcopy(net)\n\ndisplay(net.res_trafo.q_lv_mvar[0])\n```\n\n----------------------------------------\n\nTITLE: Initializing PandaPower Library\nDESCRIPTION: Import statement for the pandapower library which is required for power system analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\n```\n\n----------------------------------------\n\nTITLE: Creating and Plotting a Simple Three-Winding Transformer Grid\nDESCRIPTION: This snippet creates a three-winding transformer grid with a 'yyy' vector group and plots it using simple_plot function from pandapower.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_1ph_vector_group_trafo3w.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nvg = \"yyy\"\nnet = single_3w_trafo_grid(vg)\n```\n\nLANGUAGE: python\nCODE:\n```\nsimple_plot(net, ext_grid_size=5)\n```\n\n----------------------------------------\n\nTITLE: Running TDPF with Distributed Slack and Delay\nDESCRIPTION: This snippet demonstrates the TDPF calculation with both distributed slack enabled and a time delay of 5 minutes (300 seconds). The `net.sn_mva` parameter is increased to improve numerical stability, and the maximum number of iterations is set to 30.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/temperature_dependent_power_flow.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nnet.sn_mva = 1000\npp.runpp(net, tdpf=True, tdpf_delay_s=5 * 60, distributed_slack=True, max_iteration=30)\n```\n\n----------------------------------------\n\nTITLE: Finding Standard Types by Parameters\nDESCRIPTION: Shows how to search for standard types using specific parameters.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/std_types.ipynb#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\npp.find_std_type_by_parameter(net, data={\"r_ohm_per_km\": 0.1188, \"x_ohm_per_km\": 0.39})\n```\n\n----------------------------------------\n\nTITLE: Adding Voltage Magnitude Measurements to Buses\nDESCRIPTION: This snippet demonstrates how to add voltage magnitude measurements to the buses in the pandapower network, specifying the measurement values and their standard deviations.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/state_estimation.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\npp.create_measurement(net, \"v\", \"bus\", 1.006, .004, element=b1)        # V at bus 1\npp.create_measurement(net, \"v\", \"bus\", 0.968, .004, element=b2)        # V at bus 2\nnet.measurement\n```\n\n----------------------------------------\n\nTITLE: Creating Transformer and Line from Parameters\nDESCRIPTION: Creates transformer and line elements using direct parameter specification instead of standard types.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/three_phase_loadflow_tutorial_simple.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\npp.create_transformer_from_parameters(net, hv_bus=bus_eg, lv_bus=bus_lv, \n                                          sn_mva= 1.6, vn_hv_kv= 10, \n                                          vn_lv_kv= 0.4, vk_percent= 6, \n                                          vkr_percent= 0.78125, pfe_kw= 2.7, \n                                          i0_percent= 0.16875, shift_degree= 0, \n                                          tap_side= 'lv',tap_neutral= 0,\n                                          tap_min= -2, tap_max= 2,\n                                          tap_step_degree= 0,\n                                          tap_step_percent= 2.5,\n                                          tap_changer_type=\"Ratio\",\n                                          vk0_percent= 6, vkr0_percent= 0.78125, \n                                          mag0_percent= 100, mag0_rx= 0.,\n                                          si0_hv_partial= 0.9,vector_group= \"Dyn\",\n                                          parallel=1,tap_pos=0,\n                                          index=pp.get_free_id(net.trafo)+1,\n                                           )\npp.create_line_from_parameters(net, bus_lv, bus_load, length_km=0.5,r_ohm_per_km= 0.1941, x_ohm_per_km= 0.07476991,\n                    c_nf_per_km= 1160., max_i_ka= 0.421,\n                    endtemp_degree= 70.0, r0_ohm_per_km= 0.7766,\n                    x0_ohm_per_km= 0.2990796,\n                    c0_nf_per_km=  496.2 ,index=pp.get_free_id(net.line)+1)\n```\n\n----------------------------------------\n\nTITLE: Plotting the network using pandapower\nDESCRIPTION: This snippet uses pandapower's simple_plot function to create a visual representation of the network, including generators, transformers, and external grids.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npp.plotting.simple_plot(net, plot_gens=True, gen_size=0.05, trafo_size=10, ext_grid_size=5);\n```\n\n----------------------------------------\n\nTITLE: Creating a simple test network\nDESCRIPTION: This function creates a basic pandapower network consisting of an external grid, buses, a transformer, lines, a load, and a generator. The network is configured with specific parameters such as voltage levels, line types, and power values for the load and generator.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/time_series_meta_control.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef simple_test_net():\n    \"\"\"\n    simple net that looks like:\n\n    ext_grid b0---b1 trafo(110/20) b2----b3 load\n                                    |\n                                    |\n                                    b4 sgen\n    \"\"\"\n    net= pp.create_empty_network()\n    pp.set_user_pf_options(net, init_vm_pu=\"flat\", init_va_degree=\"dc\", calculate_voltage_angles=True)\n\n    b0 = pp.create_bus(net, 110)\n    b1 = pp.create_bus(net, 110)\n    b2 = pp.create_bus(net, 20)\n    b3 = pp.create_bus(net, 20)\n    b4 = pp.create_bus(net, 20)\n\n    pp.create_ext_grid(net, b0)\n    pp.create_line(net, b0, b1, 10, \"149-AL1/24-ST1A 110.0\")\n    pp.create_transformer(net, b1, b2, \"25 MVA 110/20 kV\", name='tr1')\n    pp.create_line(net, b2, b3, 10, \"184-AL1/30-ST1A 20.0\")\n    pp.create_line(net, b2, b4, 10, \"184-AL1/30-ST1A 20.0\")\n\n    pp.create_load(net, b2, p_mw=20., q_mvar=10., name='load1')\n    pp.create_sgen(net, b4, p_mw=20., q_mvar=0.15, name='sgen1')\n\n    return net\n```\n\n----------------------------------------\n\nTITLE: Accessing correction factor value\nDESCRIPTION: This snippet retrieves the calculated correction factor value for the first element in the series.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/shortcircuit/sc_power_station_unit.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nks.at[0]\n```\n\n----------------------------------------\n\nTITLE: RST Documentation Structure\nDESCRIPTION: reStructuredText markup defining the documentation structure including images, links and table of contents for the pandapower library documentation.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about.rst#2025-04-22_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. image:: /pics/pp.svg\n\t\t:width: 250em\n\t\t:align: left\n\n.. |br| raw:: html\n\n    <br />\n\n.. toctree::\n    :maxdepth: 1\n\n    about/units\n    about/update30\n    about/update20\n    about/authors\n    about/changelog\n    about/license\n    about/contributing\n    about/deprecating\n```\n\n----------------------------------------\n\nTITLE: Basic git push command for pandapower development\nDESCRIPTION: Command to push your local changes to your fork of the pandapower repository. This is used after making changes that you want to eventually submit via pull request.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit push\n```\n\n----------------------------------------\n\nTITLE: Including Authors List in reStructuredText Document\nDESCRIPTION: This snippet demonstrates how to include an external file named AUTHORS in a reStructuredText document. The AUTHORS file is expected to contain a list of contributors to the pandapower project.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/authors.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. include:: ../../AUTHORS\n```\n\n----------------------------------------\n\nTITLE: Committing changes with issue reference\nDESCRIPTION: Command to commit changes with a reference to a specific issue number. This helps link commits to the issues they address in the project's issue tracker.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/CONTRIBUTING.rst#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\ngit commit -m \"commit message #3\"\n```\n\n----------------------------------------\n\nTITLE: MacOS Gurobi Environment Configuration\nDESCRIPTION: Bash environment variable configuration for Gurobi solver on MacOS systems, including paths and license file location.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/opf/pandamodels.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# gurobi\nexport GUROBI_HOME=\"/Library/gurobiVERSION/mac64\"\nexport PATH=\"$PATH:$GUROBI_HOME/bin\"\nexport LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:$GUROBI_HOME/lib\"\nexport GRB_LICENSE_FILE=\"/PATH_TO_YOUR_LICENSE_DIR/gurobi.lic\"\n```\n\n----------------------------------------\n\nTITLE: Generator Power Constraints Definition\nDESCRIPTION: Demonstrates the change in generator power constraint definitions between versions, showing the transition from kW to MW units.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/about/update20.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nnet.gen.min_p_kw=-2000\nnet.gen.max_p_kw=0\n```\n\nLANGUAGE: python\nCODE:\n```\nnet.gen.min_p_mw=0\nnet.gen.max_p_mw=2\n```\n\n----------------------------------------\n\nTITLE: Checking Element Limits in Contingency Analysis Results\nDESCRIPTION: This snippet shows how to check if all elements are within specified limits after a contingency analysis. It uses the get_element_limits and check_elements_within_limits functions from pandapower.contingency.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/contingency_analysis.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nelement_limits = pp.contingency.get_element_limits(net)\npp.contingency.check_elements_within_limits(element_limits, res, True)\n```\n\n----------------------------------------\n\nTITLE: Executing Ward-equivalent Calculation\nDESCRIPTION: This snippet performs the Ward-equivalent calculation using the get_equivalent function from pandapower.grid_equivalents.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/doc/gridequivalent/gridequivalent_example.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nnet_eq = pp.grid_equivalents.get_equivalent(net, eq_type, boundary_buses, internal_buses)\n```\n\n----------------------------------------\n\nTITLE: Initializing IEEE European LV Network in pandapower\nDESCRIPTION: Loads the IEEE European LV asymmetric network data for the on-peak period (566 min) using pandapower's built-in network models.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/ieee_european_lv_asymmetric.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pandapower as pp\nimport pandapower.networks as nw\n\nnet = nw.ieee_european_lv_asymmetric('on_peak_566')\n```\n\n----------------------------------------\n\nTITLE: Power Flow Results Validation\nDESCRIPTION: Contains commented code for comparing power flow results between PowerFactory and pandapower, including difference analysis.\nSOURCE: https://github.com/e2niee/pandapower/blob/develop/tutorials/converter_powerfactory.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n#all_diffs=validate_pf_conversion(net, tolerance_mva=1e-9)\n```\n\nLANGUAGE: python\nCODE:\n```\n#all_diffs['diff_vm'].describe()\n```"
  }
]