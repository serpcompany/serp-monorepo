[
  {
    "owner": "gravity-ui",
    "repo": "graph",
    "content": "TITLE: Complete Graph Example with React and TypeScript\nDESCRIPTION: A comprehensive example demonstrating the implementation of a custom graph with blocks, anchors, connections, styling, and event handling using TypeScript and React.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nimport React, { useCallback } from 'react';\nimport { GraphCanvas, GraphBlock, GraphBlockAnchor, useGraph, useGraphEvent, TBlock } from '@gravity-ui/graph';\n\nfunction BlockComponent({ block, graph }: { block: TBlock; graph: Graph }) {\n  return (\n    <GraphBlock \n      graph={graph} \n      block={block}\n      className=\"custom-block\"\n    >\n      {/* Block content */}\n      <div className=\"block-content\">\n        {block.name}\n      </div>\n\n      {/* Render anchors */}\n      {block.anchors.map(anchor => (\n        <GraphBlockAnchor\n          key={anchor.id}\n          graph={graph}\n          anchor={anchor}\n          position=\"fixed\"\n        >\n          {(state) => (\n            <div className={`anchor ${state.selected ? 'selected' : ''}`}>\n              <div className=\"anchor-dot\" />\n              {state.isConnecting && (\n                <div className=\"anchor-label\">\n                  {anchor.type === 'IN' ? 'Input' : 'Output'}\n                </div>\n              )}\n            </div>\n          )}\n        </GraphBlockAnchor>\n      ))}\n    </GraphBlock>\n  );\n}\n\nfunction CustomGraph() {\n  // Initialize graph\n  const { graph, setEntities, start } = useGraph({\n    viewConfiguration: {\n      colors: {\n        block: {\n          background: \"rgba(37, 27, 37, 1)\",\n          border: \"rgba(229, 229, 229, 0.2)\",\n          selectedBorder: \"rgba(255, 190, 92, 1)\",\n        },\n        connection: {\n          background: \"rgba(255, 255, 255, 0.5)\",\n          selectedBackground: \"rgba(234, 201, 74, 1)\",\n        },\n        anchor: {\n          background: \"rgba(255, 190, 92, 1)\",\n        },\n      },\n    },\n    settings: {\n      canDragCamera: true,\n      canZoomCamera: true,\n      canCreateNewConnections: true,\n      useBezierConnections: true,\n    },\n  });\n\n  // Initialize blocks\n  React.useEffect(() => {\n    const blocks: TBlock[] = [\n      {\n        id: 'block1',\n        is: 'block',\n        name: 'Source',\n        x: 100,\n        y: 100,\n        width: 200,\n        height: 100,\n        selected: false,\n        anchors: [\n          {\n            id: 'out1',\n            type: 'OUT',\n            x: 200,\n            y: 50,\n          },\n        ],\n      },\n      {\n        id: 'block2',\n        is: 'block',\n        name: 'Target',\n        x: 400,\n        y: 100,\n        width: 200,\n        height: 100,\n        selected: false,\n        anchors: [\n          {\n            id: 'in1',\n            type: 'IN',\n            x: 0,\n            y: 50,\n          },\n        ],\n      },\n    ];\n\n    setEntities({ blocks });\n    start();\n    graph.zoomTo(\"center\", { padding: 100 });\n  }, []);\n\n  // Handle clicks on blocks\n  useGraphEvent(graph, \"click\", ({ target }) => {\n    console.log('Clicked block:', target);\n  });\n\n  // Render blocks\n  const renderBlock = useCallback((graph, block) => (\n    <BlockComponent graph={graph} block={block} />\n  ), []);\n\n  return (\n    <div className=\"graph-container\">\n      <GraphCanvas \n        graph={graph} \n        renderBlock={renderBlock}\n        className=\"custom-graph\"\n      />\n    </div>\n  );\n}\n\n// Required styles\nconst styles = `\n.custom-graph {\n  width: 100%;\n  height: 100vh;\n}\n\n.custom-block {\n  background-color: var(--graph-block-bg);\n  border: 1px solid var(--graph-block-border);\n  border-radius: 4px;\n}\n\n.custom-block.selected {\n  border-color: var(--graph-block-border-selected);\n}\n\n.block-content {\n  padding: 16px;\n  color: white;\n}\n\n.anchor {\n  position: absolute;\n  width: 12px;\n  height: 12px;\n  background: var(--graph-block-anchor-bg);\n  border-radius: 50%;\n  cursor: pointer;\n}\n\n.anchor.selected {\n  border: 2px solid var(--graph-block-anchor-border-selected);\n}\n\n.anchor-label {\n  position: absolute;\n  top: -20px;\n  left: 50%;\n  transform: translateX(-50%);\n  background: rgba(0, 0, 0, 0.8);\n  color: white;\n  padding: 2px 6px;\n  border-radius: 4px;\n  font-size: 12px;\n}\n`;\n```\n\n----------------------------------------\n\nTITLE: Complete Example of a Custom RoundedBlock Implementation\nDESCRIPTION: A comprehensive example showing how to create a custom rounded block with blue styling. The example demonstrates block definition, registration, configuration with multiple blocks and connections, and graph initialization.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Group } from \"@/lib/Component\";\nimport { Block, CanvasBlock, TGraphConfig, EAnchorType } from \"@gravity-ui/graph\";\n\n// 1. Define a custom block class\nclass RoundedBlock extends CanvasBlock {\n  // Override the stroke rendering\n  protected renderStroke(color: string) {\n    this.context.ctx.lineWidth = Math.round(3 / this.context.camera.getCameraScale());\n    this.context.ctx.strokeStyle = color;\n    this.roundRect(this.context.ctx, this.state.x, this.state.y, this.state.width, this.state.height, [15]);\n    this.context.ctx.stroke();\n  }\n\n  // Override the schematic view rendering\n  public override renderSchematicView() {\n    const ctx = this.context.ctx;\n    \n    // Fill with custom color\n    ctx.fillStyle = \"#E6F7FF\";\n    ctx.beginPath();\n    this.roundRect(ctx, this.state.x, this.state.y, this.state.width, this.state.height, [15]);\n    ctx.fill();\n    \n    // Stroke\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = \"#0077CC\";\n    ctx.beginPath();\n    this.roundRect(ctx, this.state.x, this.state.y, this.state.width, this.state.height, [15]);\n    ctx.stroke();\n\n    // Render text\n    if (this.shouldRenderText) {\n      ctx.fillStyle = \"#003366\";\n      ctx.textAlign = \"center\";\n      this.renderText(this.state.label);\n    }\n    \n    // Render selection highlight\n    if (this.state.selected) {\n      this.renderStroke(this.context.colors.block.selectedBorder);\n    }\n  }\n\n  // Polyfill for roundRect\n  private roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number[] | number) {\n    const radii = typeof radius === 'number' ? [radius, radius, radius, radius] : radius;\n    ctx.moveTo(x + radii[0], y);\n    ctx.lineTo(x + width - radii[1], y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radii[1]);\n    ctx.lineTo(x + width, y + height - radii[2]);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radii[2], y + height);\n    ctx.lineTo(x + radii[3], y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radii[3]);\n    ctx.lineTo(x, y + radii[0]);\n    ctx.quadraticCurveTo(x, y, x + radii[0], y);\n    ctx.closePath();\n  }\n}\n\n// 2. Define a unique type for the block\nconst ROUNDED_BLOCK_TYPE = \"rounded-block\";\n\n// 3. Create graph configuration that uses the custom block\nexport const customBlockGraphConfig: TGraphConfig = {\n  configurationName: \"custom-blocks-example\",\n  blocks: [\n    {\n      id: \"block1\",\n      is: ROUNDED_BLOCK_TYPE,\n      x: 100,\n      y: 100,\n      width: 200,\n      height: 150,\n      label: \"Rounded Block 1\",\n      selected: false,\n      anchors: [\n        { id: \"in1\", type: EAnchorType.INPUT, point: [0, 0.3] },\n        { id: \"in2\", type: EAnchorType.INPUT, point: [0, 0.7] },\n        { id: \"out\", type: EAnchorType.OUTPUT, point: [1, 0.5] }\n      ]\n    },\n    {\n      id: \"block2\",\n      is: ROUNDED_BLOCK_TYPE,\n      x: 400,\n      y: 200,\n      width: 200,\n      height: 150,\n      label: \"Rounded Block 2\",\n      selected: false,\n      anchors: [\n        { id: \"in\", type: EAnchorType.INPUT, point: [0, 0.5] },\n        { id: \"out1\", type: EAnchorType.OUTPUT, point: [1, 0.3] },\n        { id: \"out2\", type: EAnchorType.OUTPUT, point: [1, 0.7] }\n      ]\n    }\n  ],\n  connections: [\n    {\n      id: \"conn1\",\n      from: { block: \"block1\", anchor: \"out\" },\n      to: { block: \"block2\", anchor: \"in\" }\n    }\n  ],\n  settings: {\n    blockComponents: {\n      // Register the custom block implementation\n      [ROUNDED_BLOCK_TYPE]: RoundedBlock\n    }\n  }\n};\n\n// 4. Create the graph with the custom blocks\nconst graph = new Graph(customBlockGraphConfig, document.getElementById(\"graph-container\"));\n```\n\n----------------------------------------\n\nTITLE: Setting Up an Interactive Graph Editor in TypeScript\nDESCRIPTION: Configures the graph with full editing capabilities, allowing users to move, resize, and connect blocks. This configuration is ideal for diagram creation tools or visual editors.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.updateSettings({\n  canDragCamera: true,\n  canZoomCamera: true,\n  canChangeBlockGeometry: 'all',\n  canCreateNewConnections: true,\n  showConnectionArrows: true,\n  showConnectionLabels: true,\n  useBlocksAnchors: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Graph Events in React\nDESCRIPTION: Using the useGraphEvent hook to listen for various graph events like connection creation, selection changes, and block modifications.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useGraphEvent } from '@gravity-ui/graph';\n\n// When a new connection is created\nuseGraphEvent(graph, \"connection-created\", \n  ({ sourceBlockId, targetBlockId }, event) => {\n    // Handle new connection\n    // Use event.preventDefault() to cancel if needed\n});\n\n// When blocks are selected\nuseGraphEvent(graph, \"blocks-selection-change\", \n  ({ changes }) => {\n    console.log('Added:', changes.add);\n    console.log('Removed:', changes.removed);\n});\n\n// When a block is modified\nuseGraphEvent(graph, \"block-change\", \n  ({ block }) => {\n    // Handle block changes\n});\n```\n\n----------------------------------------\n\nTITLE: Setting and Updating Graph Entities Example\nDESCRIPTION: Example showing how to use the useGraph hook to set and update graph entities like blocks and connections. Demonstrates setting initial entities and updating specific properties of blocks.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/public_api.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst {graph, setEntities, updateEntities} = useGraph({});\nuseEffect(() => {\n    // set connections\n    setEntities({\n      blocks: [{...block}, {...anotherBlock}],\n      connections: [{...connection}, {...connection}]\n    });\n}, []);\n\nconst update = useCallback(() => {\n  updateEntities({\n    blocks: [{...block, name: 'Updated Name'}],\n  });\n})\n```\n\n----------------------------------------\n\nTITLE: Complete React Graph Editor Example\nDESCRIPTION: Full example of a React component that uses the @gravity-ui/graph library to create an interactive graph editor. Shows how to initialize the graph, add blocks and connections, and handle state changes.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GraphCanvas, GraphState, GraphBlock, useGraph } from \"@gravity-ui/graph\";\nimport React from \"react\";\n\nconst config = {};\n\nexport function GraphEditor() {\n  const { graph, setEntities, start } = useGraph(config);\n\n  useEffect(() => {\n    setEntities({\n      blocks: [\n        {\n          is: \"block-action\",\n          id: \"action_1\",\n          x: -100,\n          y: -450,\n          width: 126,\n          height: 126,\n          selected: true,\n          name: \"Block #1\",\n          anchors: [],\n        },\n        {\n          id: \"action_2\",\n          is: \"block-action\",\n          x: 253,\n          y: 176,\n          width: 126,\n          height: 126,\n          selected: false,\n          name: \"Block #2\",\n          anchors: [],\n        }\n      ],\n      connections: [\n        {\n          sourceBlockId: \"action_1\",\n          targetBlockId: \"action_2\",\n        }\n      ]\n    });\n  }, [setEntities]);\n\n  const renderBlockFn = (graph, block) => {\n    return <GraphBlock graph={graph} block={block}>{block.id}</GraphBlock>;\n  };\n\n  return (\n    <GraphCanvas\n      graph={graph}\n      renderBlock={renderBlockFn}\n      onStateChanged={({ state }) => {\n        if (state === GraphState.ATTACHED) {\n          start();\n          graph.zoomTo(\"center\", { padding: 300 });\n        }\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Interactive Graph Editor Nodes with Drag and Resize\nDESCRIPTION: An EditorNode component for building full-featured graph editors with drag and resize capabilities. It implements draggable behavior conditionally based on edit mode and creates resize handles as child components with absolute positioning.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\nclass EditorNode extends GraphComponent {\n  constructor(props, parent) {\n    super(props, parent);\n    \n    // Make node draggable\n    this.onDrag({\n      isDraggable: () => this.context.editMode === 'move',\n      onDragUpdate: ({ diffX, diffY }) => {\n        this.setState({\n          x: this.state.x - diffX,\n          y: this.state.y - diffY\n        });\n      }\n    });\n  }\n  \n  // Add resize handles as child components with absolute positioning\n  updateChildren() {\n    return [\n      ResizeHandle.create({ \n        position: 'topLeft',\n        x: this.state.x,\n        y: this.state.y,\n        onResize: this.handleResize \n      }, { key: 'resize-tl' }),\n      // ... other handles\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using Graph Event Listener in TypeScript\nDESCRIPTION: Demonstrates how to create a Graph instance, add an event listener for the 'mouseenter' event, and later unsubscribe from it. The example shows event handling, accessing event details, and using event methods.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/events.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph } from \"@gravity-ui/graph\";\n\nconst graph = new Graph(...props);\n\nconst unsubscribe = graph.on(\"mouseenter\", (event) => {\n  console.log(\"mouseenter\", event.detail);\n  console.log('hovered element', event.detail.target);\n  console.log('original event', event.detail.sourceEvent);\n\n  event.preventDefault();\n  event.stopPropagation();\n}, {\n  once: true,\n  capture: true\n});\n\nunsubscribe();\n```\n\n----------------------------------------\n\nTITLE: Configuring Graph Behavior Settings in React\nDESCRIPTION: Configuration for interaction settings including camera controls, block interactions, connection settings, and visual preferences. Also shows how to register custom block components.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nconst config = {\n  settings: {\n    // Camera controls\n    canDragCamera: true,\n    canZoomCamera: true,\n    \n    // Block interactions\n    canDragBlocks: true,\n    canDuplicateBlocks: false,\n    canChangeBlockGeometry: 'ALL', // 'NONE' | 'ALL' | 'SELECTED'\n    \n    // Connection settings\n    canCreateNewConnections: true,\n    showConnectionArrows: true,\n    useBezierConnections: true,\n    \n    // Visual settings\n    scaleFontSize: 1,\n    useBlocksAnchors: true,\n    showConnectionLabels: false,\n    \n    // Custom block components\n    blockComponents: {\n      'action-block': ActionBlockComponent,\n      'text-block': TextBlockComponent\n    }\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Using GraphBlock Component in React\nDESCRIPTION: Implementation of the GraphBlock component that wraps HTML content and handles synchronization with the canvas layer. It manages positioning, state, and layout.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<GraphBlock \n  graph={graph} \n  block={block}\n  className=\"custom-block\"\n  containerClassName=\"custom-container\"\n>\n  <div>Your block content here</div>\n</GraphBlock>\n```\n\n----------------------------------------\n\nTITLE: Initializing Graph with Custom Settings in TypeScript\nDESCRIPTION: Creates a new Graph instance with specified settings that control camera dragging, zooming, and connection styling. This demonstrates how to pass settings during the initial graph creation.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph } from '@gravity-ui/graph';\n\n// Create a graph instance with custom settings\nconst graph = new Graph(\n  {\n    settings: {\n      canDragCamera: true,\n      canZoomCamera: true,\n      useBezierConnections: true,\n      // other settings...\n    },\n  },\n  document.getElementById(\"graph-container\")\n);\n```\n\n----------------------------------------\n\nTITLE: Available Public API Methods for Gravity UI Graph\nDESCRIPTION: Comprehensive list of public methods available for manipulating graph state, including zooming, styling, selection, and entity management.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/public_api.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n  public zoomToRect(rect: TGeometry, transition?: number): void;\n\n  public zoomToBlocks(blockIds: TBlockId[], transition?: number): void;\n\n  public zoomToViewPort(transition?: number): void;\n\n  public getGraphColors(): TGraphColors;\n\n  public updateGraphColors(colors: TGraphColors): void;\n\n  public getGraphConstants(): TGraphConstants;\n\n  public updateGraphConstants(constants: TGraphConstants): void;\n\n  public isGraphEmpty(): boolean;\n\n  public setSetting(flagPath: keyof TGraphSettingsConfig, value: boolean | number | ECanChangeBlockGeometry): void;\n\n  public setCurrentConfigurationName(newName: string): void;\n\n  public deleteSelected(): void;\n\n  public selectBlocks(blockIds: TBlockId[], selected: boolean, strategy: ESelectionStrategy = ESelectionStrategy.REPLACE): void;\n\n  public updateBlock(block: { id: TBlockId } & Partial<Omit<TBlock, \"id\">>): void;\n\n  public setAnchorSelection(blockId: TBlockId, anchorId: string, selected: boolean): void;\n\n  public getBlockById(blockId: TBlockId): TBlock;\n\n  public getUsableRect(): TGeometry;\n\n  public unsetSelection(): void;\n\n  public addBlock(block: Omit<TBlock, \"id\"> & { id?: TBlockId }): TBlockId;\n\n  public addConnection(connection: TConnection): TConnectionId\n\n  public updateConnection(id: TConnectionId, connection: Partial<TConnection>): void;\n\n  public selectConnections(connectionIds: TConnectionId[], selected: boolean, strategy: ESelectionStrategy = ESelectionStrategy.REPLACE): void;\n```\n\n----------------------------------------\n\nTITLE: Implementing Auto Position GraphBlockAnchor\nDESCRIPTION: Using GraphBlockAnchor component with auto positioning mode. Anchors are automatically positioned based on their type (inputs on left, outputs on right).\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n<GraphBlockAnchor \n  graph={graph} \n  anchor={anchor}\n  position=\"auto\"\n  // Inputs will be placed on the left, outputs on the right\n>\n  {(state) => (\n    <div className={state.selected ? 'selected' : ''}>\n      {/* Anchor visuals */}\n    </div>\n  )}\n</GraphBlockAnchor>\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using a Basic Scheduler in TypeScript\nDESCRIPTION: Demonstrates how to create a scheduler, set the root component, and start/stop the scheduler. This code shows the fundamental operations needed to use the scheduler system.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/scheduler-system.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Create a scheduler\nconst scheduler = new Scheduler();\n\n// Set the root component\nconst rootComponent = CoreComponent.mount(MyRootComponent, props);\nscheduler.setRoot(rootComponent.__comp.treeNode);\n\n// Start the scheduler\nscheduler.start();\n\n// Later, stop the scheduler when done\nscheduler.stop();\n```\n\n----------------------------------------\n\nTITLE: Rendering React Components in GraphCanvas\nDESCRIPTION: Example of how to render custom React components within the GraphCanvas component. The renderBlock prop accepts a function that receives graph and block parameters and returns a React component.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Example of React components rendering\nconst MyGraph = () => {\n  return (\n    <GraphCanvas\n      graph={graph}\n      renderBlock={(graph, block) => (\n        <MyCustomBlockComponent \n          graph={graph} \n          block={block}\n        />\n      )}\n    />\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Rendering a Graph Canvas in React\nDESCRIPTION: Basic usage of the GraphCanvas component to render a graph. It requires a graph object and a renderBlock function.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n<GraphCanvas \n  graph={graph}\n  renderBlock={renderBlock}\n  className=\"my-graph\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphComponent with HitBox in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a GraphComponent class that extends the base Component class and initializes a HitBox. The HitBox is crucial for spatial awareness and interaction detection in the graph system.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@/lib/Component\";\nimport { HitBox } from \"@/services/HitTest\";\n\ninterface Props {\n  x: number;\n  y: number;\n}\n\nclass GraphComponent extends Component<Props> {\n  constructor(props: Props, parent: Component) {\n    super(props, parent);\n    // This line is critical - it registers the component in the spatial system\n    this.hitBox = new HitBox(this, this.context.graph.hitTest);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: React Graph Component Implementation\nDESCRIPTION: Demonstrates how to implement a basic graph component using React with custom block rendering and automatic state management.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README-ru.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyGraph = () => {\n  return (\n    <GraphCanvas\n      graph={graph}\n      renderBlock={(graph, block) => (\n        <MyCustomBlockComponent \n          graph={graph} \n          block={block}\n        />\n      )}\n    />\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Building Interactive Diagram Nodes with Event Handlers\nDESCRIPTION: A DiagramNode component implementing interactive elements with click and mouseover event handling. It shows detailed information panels on click and highlights connected elements on mouseover using context services.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\nclass DiagramNode extends GraphComponent {\n  constructor(props, parent) {\n    super(props, parent);\n    this.addEventListener('click', this.handleClick);\n    this.addEventListener('mouseover', this.handleMouseOver);\n  }\n  \n  handleClick = () => {\n    // Show detailed information panel\n    this.context.uiService.showDetails(this.props.id);\n  }\n  \n  handleMouseOver = () => {\n    // Highlight connected elements\n    this.context.highlightService.highlightConnected(this.props.id);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Block Implementation Example in TypeScript\nDESCRIPTION: Example showing how to extend the Block class with custom rendering and interaction behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nclass CustomBlock extends Block {\n  // Override rendering methods to customize appearance\n  protected renderBody(ctx: CanvasRenderingContext2D) {\n    // Custom rendering code\n    ctx.fillStyle = \"blue\";\n    ctx.fillRect(this.state.x, this.state.y, this.state.width, this.state.height);\n    \n    // Call the base implementation if needed\n    // super.renderBody(ctx);\n  }\n  \n  // Override behavior methods to customize interactions\n  protected onDragStart(event: MouseEvent) {\n    // Custom drag start handling\n    console.log(\"Custom drag start\");\n    \n    // Call the base implementation\n    super.onDragStart(event);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Mouse Events and Drag Operations in GraphComponent\nDESCRIPTION: This code snippet illustrates how to add mouse event listeners and implement drag functionality in a GraphComponent. It includes handlers for click, mouseenter, mouseleave events, and a specialized drag handling system.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Listen for basic mouse events\nthis.addEventListener('click', (event) => {\n  console.log('Component clicked at:', event.point);\n  this.setState({ selected: true });\n});\n\nthis.addEventListener('mouseenter', () => {\n  this.setState({ hovered: true });\n  this.performRender();\n});\n\nthis.addEventListener('mouseleave', () => {\n  this.setState({ hovered: false });\n  this.performRender();\n});\n\n// Use the specialized drag handling system\nthis.onDrag({\n  isDraggable: (event) => !this.props.locked && event.button === 0,\n  onDragStart: (event) => {\n    this.setState({ dragging: true });\n    this.context.graph.emit('element-drag-start', { element: this });\n  },\n  onDragUpdate: ({ diffX, diffY }, event) => {\n    this.updatePosition(this.state.x - diffX, this.state.y - diffY);\n  },\n  onDrop: () => {\n    this.setState({ dragging: false });\n    this.context.graph.emit('element-drag-end', { element: this });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Updates in GraphComponent\nDESCRIPTION: Shows how to create components that reactively update in response to external data changes. By subscribing to signals, components can automatically update their state and rendering when graph data changes without manual polling.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nclass DataAwareComponent extends GraphComponent {\n  constructor(props, parent) {\n    super(props, parent);\n    \n    // Subscribe to graph updates\n    this.subscribeSignal(this.context.graph.updateSignal, (updateData) => {\n      this.setState({\n        graphData: updateData\n      });\n      this.performRender(); // Request a render with the new graph data\n    });\n  }\n  \n  protected render() {\n    if (!this.isVisible()) return;\n    \n    const ctx = this.context.ctx;\n    \n    // Use the current state and theme colors\n    ctx.fillStyle = this.colorMap[this.state.status] || '#cccccc';\n    ctx.fillRect(this.state.x, this.state.y, this.state.width, this.state.height);\n    \n    // Render text if needed\n    ctx.fillStyle = '#ffffff';\n    this.renderText(`${this.state.label}: ${this.state.value}`);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Block Selection Change Handler in React\nDESCRIPTION: Shows how to implement a block selection change handler in a React component using the GraphCanvas. The handler logs selected blocks and recently changed selections, and prevents the default event behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/events.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst YourPrettyGraphComponent = () => {\n  const onBlockSelectionChange = useCallback(\n    (detail: SelectionEvent<TBlockId>, event: CustomEvent<SelectionEvent<TBlockId>>) => {\n      console.log('Selected blocks:', detail.list);\n      console.log('Recently selected:', detail.changed.add);\n      console.log('Recently unselected:', detail.changed.removed);\n      event.preventDefault();\n    },\n    []\n  );\n\n  return <GraphCanvas onBlockSelectionChange={onBlockSelectionChange} />;\n};\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Block Implementations in Graph Configuration\nDESCRIPTION: Demonstrates how to create a custom block class that extends the base Block class, define a custom identifier, and register it in the graph configuration. The example includes custom rendering logic with a gold-colored block and text rendering.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Block, EAnchorType } from \"@gravity-ui/graph\";\n\n// Define a custom block type\nclass MySpecialBlock extends Block {\n  protected renderSchematicView(ctx: CanvasRenderingContext2D) {\n    // Custom rendering logic\n    ctx.fillStyle = \"#FFD700\"; // Gold color\n    ctx.beginPath();\n    this.roundRect(ctx, this.state.x, this.state.y, this.state.width, this.state.height, [10]);\n    ctx.fill();\n    \n    // Render text\n    if (this.shouldRenderText) {\n      ctx.fillStyle = \"#000\";\n      this.renderText(this.state.label);\n    }\n  }\n\n  // Polyfill for roundRect\n  private roundRect(ctx: CanvasRenderingContext2D, x: number, y: number, width: number, height: number, radius: number[] | number) {\n    const radii = typeof radius === 'number' ? [radius, radius, radius, radius] : radius;\n    ctx.moveTo(x + radii[0], y);\n    ctx.lineTo(x + width - radii[1], y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + radii[1]);\n    ctx.lineTo(x + width, y + height - radii[2]);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - radii[2], y + height);\n    ctx.lineTo(x + radii[3], y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - radii[3]);\n    ctx.lineTo(x, y + radii[0]);\n    ctx.quadraticCurveTo(x, y, x + radii[0], y);\n    ctx.closePath();\n  }\n}\n\n// Define a unique identifier for this block type\nconst SPECIAL_BLOCK_TYPE = \"special-block\";\n\n// Create graph configuration with custom block\nconst graphConfig: TGraphConfig = {\n  blocks: [\n    {\n      id: \"block1\",\n      is: SPECIAL_BLOCK_TYPE, // Use the custom block type\n      x: 100,\n      y: 200,\n      width: 180,\n      height: 120,\n      label: \"My Special Block\",\n      selected: false,\n      anchors: [\n        // Define anchors for the block\n        { id: \"input1\", type: EAnchorType.INPUT, point: [0, 0.5] },\n        { id: \"output1\", type: EAnchorType.OUTPUT, point: [1, 0.5] }\n      ]\n    }\n  ],\n  settings: {\n    // Register the custom block implementation\n    blockComponents: {\n      [SPECIAL_BLOCK_TYPE]: MySpecialBlock\n    }\n  }\n};\n\n// Create the graph with the custom configuration\nconst graph = new Graph(graphConfig, rootElement);\n```\n\n----------------------------------------\n\nTITLE: Intelligent Rendering Based on Zoom Level in GraphComponent\nDESCRIPTION: Shows how to implement efficient rendering by adapting component visual complexity based on camera zoom level. Components display simplified versions when zoomed out and more detailed versions when zoomed in, improving performance and usability.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ECameraScaleLevel } from \"@/services/camera/CameraService\";\n\nclass MyEfficientComponent extends GraphComponent {\n  protected render() {\n    // First check: are we visible at all?\n    if (!this.isVisible()) return;\n    \n    const ctx = this.context.ctx;\n    const detailLevel = this.context.camera.getCameraBlockScaleLevel();\n    \n    // Second check: at current zoom level, which detail to show?\n    if (detailLevel === ECameraScaleLevel.Minimalistic) {\n      // At far zoom levels, render simplified version\n      this.renderSimplified(ctx);\n    } else if (detailLevel === ECameraScaleLevel.Schematic) {\n      // At medium zoom levels, show schematic version\n      this.renderSchematic(ctx);\n    } else {\n      // At closest zoom level (Detailed), show full detail\n      this.renderDetailed(ctx);\n    }\n    \n    // Only render text if it would be legible\n    if (detailLevel === ECameraScaleLevel.Schematic || detailLevel === ECameraScaleLevel.Detailed) {\n      this.renderText(ctx);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Connection Line with Hover Effects in TypeScript\nDESCRIPTION: Creates an annotated connection component extending BaseConnection with hover effects, labels, and arrows. The implementation includes event handling for hover states and custom rendering for highlighting connections.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { BaseConnection } from \"@/components/canvas/connections/BaseConnection\";\nimport { Component } from \"@/lib/Component\";\n\ninterface AnnotatedConnectionProps {\n  id: string;\n  from: {\n    block: string;\n    anchor: string;\n  };\n  to: {\n    block: string;\n    anchor: string;\n  };\n}\n\nclass AnnotatedConnection extends BaseConnection<AnnotatedConnectionProps> {\n  constructor(props: AnnotatedConnectionProps, parent: Component) {\n    super(props, parent);\n    \n    // BaseConnection already sets up hitbox and state from the connection store\n    // and subscribes to geometry changes\n    \n    // Additional initialization if needed\n    this.state = {\n      ...this.state,\n      hovered: false,\n      labelText: 'Connection'\n    };\n    \n    // Listen for mouse events\n    this.addEventListener('mouseover', this.handleMouseOver);\n    this.addEventListener('mouseout', this.handleMouseOut);\n  }\n  \n  private handleMouseOver = () => {\n    this.setState({ hovered: true });\n  }\n  \n  private handleMouseOut = () => {\n    this.setState({ hovered: false });\n  }\n  \n  // Use updateChildren to create and manage child components\n  protected updateChildren() {\n    // Connection points are provided by BaseConnection\n    if (!this.connectionPoints) return [];\n    \n    const [sourcePoint, targetPoint] = this.connectionPoints;\n    \n    // Calculate midpoint for label\n    const midX = (sourcePoint.x + targetPoint.x) / 2;\n    const midY = (sourcePoint.y + targetPoint.y) / 2;\n    \n    // Calculate angle for arrow\n    const angle = Math.atan2(\n      targetPoint.y - sourcePoint.y,\n      targetPoint.x - sourcePoint.x\n    );\n    \n    // Create label component\n    return [\n      // Create a label at the midpoint\n      Label.create(\n        {\n          x: midX,\n          y: midY,\n          text: this.state.labelText,\n          angle: angle,\n          highlighted: this.state.hovered\n        },\n        { key: 'label' }\n      ),\n      \n      // Create an arrow at the end\n      Arrow.create(\n        {\n          x: targetPoint.x,\n          y: targetPoint.y,\n          angle: angle,\n          size: 10,\n          highlighted: this.state.hovered\n        },\n        { key: 'arrow' }\n      )\n    ];\n  }\n  \n  // Override the path creation to customize the line style\n  protected createPath() {\n    if (!this.connectionPoints || this.connectionPoints.length < 2) return null;\n    \n    const [sourcePoint, targetPoint] = this.connectionPoints;\n    const path = new Path2D();\n    \n    // Simple straight line\n    path.moveTo(sourcePoint.x, sourcePoint.y);\n    path.lineTo(targetPoint.x, targetPoint.y);\n    \n    return path;\n  }\n  \n  // Override the render method to customize the visual appearance\n  protected render() {\n    super.render(); // This draws the base connection line\n    \n    // Add custom highlights when hovered\n    if (this.state.hovered && this.path) {\n      const ctx = this.context.ctx;\n      \n      // Draw glow effect\n      ctx.save();\n      ctx.strokeStyle = this.context.colors.highlightColor;\n      ctx.lineWidth = this.context.lineWidth + 4;\n      ctx.globalAlpha = 0.4;\n      ctx.stroke(this.path);\n      ctx.restore();\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Component with Children Management in TypeScript\nDESCRIPTION: Demonstrates how to implement a component that manages children with the updateChildren method and related lifecycle hooks. Shows the creation of child components with props and keys.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@gravity-ui/graph\";\n\nclass ParentComponent extends Component {\n  protected updateChildren() {\n    return [\n      ChildComponent.create({ value: this.state.value }, { key: 'child1' }),\n      AnotherChild.create({ data: this.props.data }, { key: 'child2' })\n    ];\n  }\n  \n  protected willUpdateChildren() {\n    console.log('About to update children');\n  }\n  \n  protected didUpdateChildren() {\n    console.log('Children updated');\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Layer in TypeScript\nDESCRIPTION: Basic structure for creating a custom layer in the Graph library. Demonstrates layer initialization with canvas and HTML elements, context setup, event subscription, and resource cleanup.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Layer, LayerContext, LayerProps } from \"@/services/Layer\";\nimport { CameraService } from \"@/services/camera/CameraService\";\nimport { Graph } from \"@/graph\";\n\ninterface MyLayerProps extends LayerProps {\n  customOption?: string;\n}\n\nexport class MyLayer extends Layer<MyLayerProps> {\n  constructor(props: MyLayerProps) {\n    super({\n      // Canvas element for drawing\n      canvas: {\n        zIndex: 10,\n        classNames: [\"my-layer\"]\n      },\n      // HTML element for DOM-based interactions\n      html: {\n        zIndex: 10,\n        classNames: [\"my-layer-html\"],\n        transformByCameraPosition: true\n      },\n      ...props\n    });\n    \n    this.setContext({\n      canvas: this.getCanvas(),\n      ctx: this.getCanvas().getContext(\"2d\"),\n      camera: props.camera,\n      graph: this.props.graph\n    });\n    \n    // Subscribe to events\n    this.context.graph.on(\"camera-change\", this.performRender);\n  }\n  \n  // Rendering method\n  protected render() {\n    const { ctx } = this.context;\n    ctx.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);\n    // Custom rendering code\n  }\n  \n  // Resource cleanup\n  protected unmount(): void {\n    this.context.graph.off(\"camera-change\", this.performRender);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Consistent HitBox Management in GraphComponent\nDESCRIPTION: Demonstrates how to properly manage hit boxes in a rectangular component by initializing in the constructor and updating whenever geometry changes. This ensures components are clickable in the right locations and interactions remain consistent.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@/lib/Component\";\nimport { HitBox } from \"@/services/HitTest\";\n\ninterface MyRectangleComponentState {\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n}\n\nclass MyRectangleComponent extends GraphComponent<any, MyRectangleComponentState> {\n  constructor(props: any, parent: Component) {\n    super(props, parent);\n    \n    this.state = {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0\n    };\n\n    // Always initialize the hitbox in constructor\n    this.updateHitBoxFromState();\n  }\n  \n  // Centralize hitbox updates in one method\n  private updateHitBoxFromState() {\n    // For rectangular components, use the bounds\n    this.setHitBox(\n      this.state.x,\n      this.state.y,\n      this.state.x + this.state.width,\n      this.state.y + this.state.height\n    );\n  }\n  \n  // Update hitbox whenever geometry changes\n  protected stateChanged(nextState: MyRectangleComponentState) {\n    if (\n      nextState.x !== this.state.x ||\n      nextState.y !== this.state.y ||\n      nextState.width !== this.state.width ||\n      nextState.height !== this.state.height\n    ) {\n      // We must update this immediately, not wait for render\n      // Otherwise mouse interaction would be incorrect\n      super.stateChanged(nextState);\n      this.updateHitBoxFromState();\n    } else {\n      super.stateChanged(nextState);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic BlockConnection in TypeScript\nDESCRIPTION: Shows how to instantiate a BlockConnection with common configuration options including bezier curves, arrows, and labels.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// The BlockConnection class is typically used directly\n// with different options for customization\nconst connection = new BlockConnection({\n  id: \"connection1\",\n  useBezier: true,\n  bezierDirection: \"vertical\",\n  showConnectionArrows: true,\n  showConnectionLabels: true\n}, parent);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Connection Logic in Graph\nDESCRIPTION: Intercepting the connection-created event to implement custom connection validation and creation logic instead of using the default behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\nuseGraphEvent(graph, \"connection-created\", \n  (connection, event) => {\n    event.preventDefault(); // Prevent default connection\n    \n    // Apply your own connection logic\n    if (validateConnection(connection)) {\n      graph.api.addConnection({\n        ...connection,\n        // Add custom properties\n      });\n    }\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing Rendering with Props Change Detection in TypeScript\nDESCRIPTION: Shows how to optimize component performance by controlling rendering based on prop changes, implementing the propsChanged lifecycle method to avoid unnecessary renders.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nprotected propsChanged(nextProps) {\n  // Only render if relevant props have changed\n  this.shouldRender = nextProps.value !== this.props.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Graph View in React\nDESCRIPTION: Configuration for the graph's visual appearance using the viewConfiguration object. Includes color settings for blocks, connections, anchors, and canvas elements.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nconst config = {\n  viewConfiguration: {\n    colors: {\n      block: {\n        background: \"rgba(37, 27, 37, 1)\",\n        border: \"rgba(229, 229, 229, 0.2)\",\n        selectedBorder: \"rgba(255, 190, 92, 1)\"\n      },\n      connection: {\n        background: \"rgba(255, 255, 255, 0.5)\",\n        selectedBackground: \"rgba(234, 201, 74, 1)\"\n      },\n      anchor: {\n        background: \"rgba(255, 190, 92, 1)\"\n      },\n      canvas: {\n        layerBackground: \"rgba(22, 13, 27, 1)\",\n        dots: \"rgba(255, 255, 255, 0.2)\"\n      }\n    },\n    constants: {\n      block: {\n        SCALES: [0.1, 0.2, 0.5], // Zoom levels for block rendering\n      }\n    }\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Updating HitBox for Spatial Awareness in TypeScript\nDESCRIPTION: This code snippet shows how to update the HitBox of a GraphComponent. Updating the HitBox is essential for maintaining accurate spatial information, which is used for mouse interactions and spatial queries.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\npublic setHitBox(minX: number, minY: number, maxX: number, maxY: number, force?: boolean) {\n  this.hitBox.update(minX, minY, maxX, maxY, force);\n  // After this call, your component can be found in spatial queries\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Automatic Groups in TypeScript\nDESCRIPTION: Demonstrates how to create automatically updating groups based on block properties. Shows grouping function implementation and group styling configuration.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/blocks/groups.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph, GroupsList } from '@gravity-ui/graph';\n\n// Make groups automatically\nconst AutoGroups = GroupsList.withBlockGrouping({\n  // Put blocks in groups\n  groupingFn: (blocks) => {\n    const groups = {};\n    blocks.forEach(block => {\n      const groupId = block.type; // or any other property\n      if (!groups[groupId]) groups[groupId] = [];\n      groups[groupId].push(block);\n    });\n    return groups;\n  },\n  // Set how groups look\n  mapToGroups: (groupId, { rect }) => ({\n    id: groupId,\n    rect,\n    style: {\n      background: \"rgba(0, 100, 200, 0.1)\"\n    }\n  })\n});\n\n// Add groups to graph\ngraph.addLayer(AutoGroups, {\n  draggable: true,  // groups can be moved\n  updateBlocksOnDrag: true  // blocks move with group. Works only if group is draggable and used Automatic Groups \n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Data with Signal Subscriptions in GraphComponent\nDESCRIPTION: This code demonstrates how to use signal subscriptions in GraphComponent to implement reactive programming. It shows examples of subscribing to color theme changes and selection state updates.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Subscribe to a color theme change\nthis.subscribeSignal(this.context.theme.colorSignal, (newColors) => {\n  this.setState({ fillColor: newColors.getColorFor(this.props.type) });\n  this.performRender(); // Request a render with the new colors\n});\n\n// Subscribe to selection state\nthis.subscribeSignal(this.props.selectionManager.selectionSignal, (selection) => {\n  const isSelected = selection.has(this.props.id);\n  if (isSelected !== this.state.selected) {\n    this.setState({ selected: isSelected });\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Block Component Props Interface in TypeScript\nDESCRIPTION: Type definition for the Block component's props including essential rendering properties.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype TBlockProps = {\n  id: TBlockId;  // ID of the block to render\n  font: string;  // Font to use for text rendering\n  label: string; // Label of the block to render\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Camera-based Culling in GraphComponent\nDESCRIPTION: This method demonstrates how GraphComponent implements camera-based culling. It checks if the component is visible within the camera's view area before rendering, which optimizes performance by skipping the rendering of off-screen components.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprotected willIterate(): void {\n  super.willIterate();\n  if (!this.firstIterate) {\n    // This optimization prevents drawing components that aren't visible\n    this.shouldRender = this.isVisible();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Badge Component with Interactive Features\nDESCRIPTION: A full implementation of a circular badge component that demonstrates all the patterns: precise hit detection with circular shape, zoom-level-based rendering, subscription to selection changes, and draggable functionality when not locked.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@/lib/Component\";\nimport { HitBox, HitBoxData } from \"@/services/HitTest\";\n\ninterface BadgeComponentProps {\n  x: number;\n  y: number;\n  radius?: number;\n  count?: number;\n  id: string;\n  locked: boolean;\n}\n\ninterface BadgeComponentState {\n  x: number;\n  y: number;\n  radius: number;\n  count: number;\n  selected: boolean;\n}\n\nclass BadgeComponent extends GraphComponent<BadgeComponentProps, BadgeComponentState> {\n  constructor(props: BadgeComponentProps, parent: Component) {\n    super(props, parent);\n    \n    this.state = {\n      x: props.x,\n      y: props.y,\n      radius: props.radius || 20,\n      count: props.count || 0,\n      selected: false\n    };\n    \n    // Set up the circular hitbox\n    this.updateHitBox();\n    \n    // Subscribe to selection changes\n    this.subscribeSignal(this.context.selectionService.signal, (selection) => {\n      const isSelected = selection.has(this.props.id);\n      if (isSelected !== this.state.selected) {\n        this.setState({ selected: isSelected });\n      }\n    });\n    \n    // Make it draggable\n    this.onDrag({\n      isDraggable: () => !this.props.locked,\n      onDragUpdate: ({ diffX, diffY }) => {\n        this.setState({\n          x: this.state.x - diffX,\n          y: this.state.y - diffY\n        });\n        this.updateHitBox();\n      }\n    });\n  }\n  \n  private updateHitBox() {\n    // Create a square hitbox that encompasses the circle\n    const r = this.state.radius;\n    this.setHitBox(\n      this.state.x - r,\n      this.state.y - r,\n      this.state.x + r,\n      this.state.y + r\n    );\n  }\n  \n  // Precise hit detection for the circle\n  public onHitBox(data: HitBoxData) {\n    if (!super.onHitBox(data)) return false;\n    \n    // Check if the point is actually within the circle\n    const dx = data.point.x - this.state.x;\n    const dy = data.point.y - this.state.y;\n    const distSquared = dx*dx + dy*dy;\n    \n    return distSquared <= this.state.radius * this.state.radius;\n  }\n  \n  protected render() {\n    if (!this.isVisible()) return;\n    \n    const ctx = this.context.ctx;\n    const { x, y, radius, count, selected } = this.state;\n    \n    // Draw circle\n    ctx.beginPath();\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    \n    // Fill with appropriate color\n    ctx.fillStyle = selected ? \n      this.context.colors.selectedBackground : \n      this.context.colors.badgeBackground;\n    ctx.fill();\n    \n    // Draw border\n    ctx.lineWidth = 2;\n    ctx.strokeStyle = selected ?\n      this.context.colors.selectedBorder :\n      this.context.colors.badgeBorder;\n    ctx.stroke();\n    \n    // Draw count\n    if (this.context.camera.getCameraBlockScaleLevel() !== ECameraScaleLevel.Minimalistic) {\n      ctx.fillStyle = this.context.colors.badgeText;\n      ctx.font = '16px Arial';\n      ctx.textAlign = 'center';\n      ctx.textBaseline = 'middle';\n      ctx.fillText(count.toString(), x, y);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Graph Settings After Creation in TypeScript\nDESCRIPTION: Shows how to update graph settings, colors, and constants after the graph instance has been created. This approach allows for dynamic modification of the graph's appearance and behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Update specific settings\ngraph.updateSettings({\n  showConnectionArrows: true,\n  canChangeBlockGeometry: 'onlySelected',\n});\n\n// Change color scheme\ngraph.setColors({\n  block: {\n    background: '#f5f5f5',\n    border: '#cccccc',\n  },\n});\n\n// Update constants\ngraph.setConstants({\n  block: {\n    WIDTH: 300,\n    HEIGHT: 200,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Minimizing Context State Changes in Canvas Rendering\nDESCRIPTION: Optimizes rendering performance by grouping similar drawing operations to reduce context state changes. This approach sets canvas styles once for each group of similarly styled elements rather than changing styles repeatedly.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\n// Group similar drawing operations together\nprotected render() {\n  if (!this.isVisible()) return;\n  \n  const ctx = this.context.ctx;\n  \n  // Set styles once for all similar elements\n  ctx.fillStyle = '#ff0000';\n  \n  // Draw all red elements\n  this.redElements.forEach(element => {\n    ctx.fillRect(element.x, element.y, element.width, element.height);\n  });\n  \n  // Then change style once for the next group\n  ctx.fillStyle = '#0000ff';\n  \n  // Draw all blue elements\n  this.blueElements.forEach(element => {\n    ctx.fillRect(element.x, element.y, element.width, element.height);\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Curved Multipoint Paths in MultipointConnection\nDESCRIPTION: Shows how MultipointConnection creates paths with multiple segments and curved corners using an array of points.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\npublic createPath() {\n  const { points } = this.connectedState.$state.value;\n  if (!points.length) {\n    return super.createPath();\n  }\n  return curvePolyline(points, 10);\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Multiple Labels in MultipointConnection\nDESCRIPTION: Shows how MultipointConnection renders multiple labels along a connection path with custom positioning for each label.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nprivate renderLabelsText(ctx: CanvasRenderingContext2D) {\n  const { labels } = this.connectedState.$state.value;\n  if (!labels || !labels.length) {\n    return;\n  }\n\n  this.labelsGeometry = [];\n  labels.forEach(({ x, y, text, height, width }) => {\n    // ... label rendering ...\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Scheduler Priority Levels for Performance Optimization\nDESCRIPTION: A TypeScript example demonstrating how to create schedulers with different priority levels and add them to the global scheduler, allowing for more control over the update sequence based on component importance.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Create schedulers with different priority levels\nconst highPriorityScheduler = new Scheduler();\nconst lowPriorityScheduler = new Scheduler();\n\n// Add schedulers with different priorities\nglobalScheduler.addScheduler(highPriorityScheduler, 0); // High priority\nglobalScheduler.addScheduler(lowPriorityScheduler, 4); // Low priority\n```\n\n----------------------------------------\n\nTITLE: Zooming to Content in Graph\nDESCRIPTION: Using the graph's zoomTo method to focus on specific content, either centering all content or zooming to specific blocks with transition effects.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n// Zoom to center with padding\ngraph.zoomTo(\"center\", { padding: 300 });\n\n// Zoom to specific blocks\ngraph.zoomTo([blockId1, blockId2], { \n  transition: 250 \n});\n```\n\n----------------------------------------\n\nTITLE: Handling State Changes in Custom Blocks\nDESCRIPTION: Shows how to implement the stateChanged lifecycle method to respond to changes in block state properties such as selection, label, and position. The example includes optimizations to minimize unnecessary renders.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nclass OptimizedBlock extends Block {\n  protected stateChanged(nextState: TBlock): void {\n    // Check what changed in the state\n    if (nextState.selected !== this.state.selected) {\n      // Handle selection state change\n      console.log(`Block ${this.state.id} selection changed to ${nextState.selected}`);\n      \n      // Raise block z-index when selected\n      this.zIndex = nextState.selected ? \n        this.context.constants.block.DEFAULT_Z_INDEX + 1 : \n        this.context.constants.block.DEFAULT_Z_INDEX;\n    }\n    \n    if (nextState.label !== this.state.label) {\n      // Handle label change\n      console.log(`Block label changed from \"${this.state.label}\" to \"${nextState.label}\"`);\n      \n      // Only trigger a render if text-related properties change\n      this.shouldRender = true;\n    } else if (nextState.x !== this.state.x || nextState.y !== this.state.y) {\n      // Handle position change\n      console.log(`Block position changed to (${nextState.x}, ${nextState.y})`);\n      \n      // Update hit box for interaction\n      // this.updateHitBox(nextState); // TODO: Implement updateHitBox\n    } else {\n      // Skip render for other property changes\n      this.shouldRender = false;\n    }\n    \n    // Always call parent method after your custom logic\n    super.stateChanged(nextState);\n  }\n```\n\n----------------------------------------\n\nTITLE: Custom Extended Groups Implementation in TypeScript\nDESCRIPTION: Advanced example showing how to create custom group types with additional properties. Includes implementation of extended group class with custom rendering.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/blocks/groups.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph, GroupsList, Group } from '@gravity-ui/graph';\n\n// 1. Define extended group type\ninterface ExtendedTGroup extends TGroup {\n  description: string;\n  priority: number;\n}\n\n// 2. Create custom group class\nclass CustomGroup extends Group<ExtendedTGroup> {\n  protected override render() {\n    super.render();\n    const ctx = this.context.ctx;\n    const rect = this.getRect();\n\n    // Draw description\n    if (this.state.description) {\n      ctx.font = \"12px Arial\";\n      ctx.fillStyle = this.style.textColor;\n      ctx.fillText(this.state.description, rect.x + 10, rect.y + 25);\n    }\n\n    // Draw priority in top right corner\n    if (this.state.priority) {\n      ctx.font = \"bold 14px Arial\";\n      const text = `P${this.state.priority}`;\n      const textWidth = ctx.measureText(text).width;\n      ctx.fillText(text, rect.x + rect.width - textWidth - 10, rect.y + 25);\n    }\n  }\n}\n\n// 3. Create groups with extended properties\nconst groups = graph.addLayer(GroupsList, {\n  draggable: false,\n  groupComponent: CustomGroup, // Use our custom component\n});\n\n// 4. Set groups with extended properties\ngroups.setGroups([\n  {\n    id: \"group1\",\n    description: \"Contains critical blocks\",\n    priority: 1,\n    rect: { x: 0, y: 0, width: 800, height: 400 }\n  },\n  {\n    id: \"group2\",\n    description: \"Contains regular blocks\",\n    priority: 2,\n    rect: { x: 850, y: 0, width: 800, height: 400 }\n  }\n]);\n```\n\n----------------------------------------\n\nTITLE: Styling GraphBlock with CSS Variables\nDESCRIPTION: CSS styling for GraphBlock components using CSS variables. Shows both position variables set automatically by GraphBlock and theme variables from graph settings.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_2\n\nLANGUAGE: css\nCODE:\n```\n.custom-block {\n  /* Position variables (automatically set by GraphBlock) */\n  --graph-block-geometry-x: 0px;\n  --graph-block-geometry-y: 0px;\n  --graph-block-geometry-width: 200px;\n  --graph-block-geometry-height: 100px;\n  --graph-block-z-index: 1;\n  --graph-block-order: 0;\n\n  /* Theme variables (from graph settings) */\n  --graph-block-bg: rgba(37, 27, 37, 1);\n  --graph-block-border: rgba(229, 229, 229, 0.2);\n  --graph-block-border-selected: rgba(255, 190, 92, 1);\n\n  /* Custom styling */\n  background-color: var(--graph-block-bg);\n  border: 1px solid var(--graph-block-border);\n}\n\n.custom-block.selected {\n  border-color: var(--graph-block-border-selected);\n}\n```\n\n----------------------------------------\n\nTITLE: Batching State Updates for Performance in TypeScript\nDESCRIPTION: Demonstrates how to batch multiple state updates into a single setState call for better performance, reducing the number of render cycles.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Instead of multiple setState calls:\n// this.setState({ value: 1 });\n// this.setState({ count: 2 });\n\n// Batch updates in one call:\nthis.setState({ value: 1, count: 2 });\n```\n\n----------------------------------------\n\nTITLE: JavaScript Graph Implementation\nDESCRIPTION: Vanilla JavaScript implementation showing how to create and initialize a graph with blocks and connections.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README-ru.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Graph } from \"@gravity-ui/graph\";\n\n//  \nconst container = document.createElement('div');\ncontainer.style.width = '100vw';\ncontainer.style.height = '100vh';\ncontainer.style.overflow = 'hidden';\ndocument.body.appendChild(container);\n\n//    \nconst graph = new Graph({\n    configurationName: \"example\",\n    blocks: [],\n    connections: [],\n    settings: {\n        canDragCamera: true,\n        canZoomCamera: true,\n        useBezierConnections: true,\n        showConnectionArrows: true\n    }\n}, container);\n\n//    \ngraph.setEntities({\n    blocks: [\n        {\n            is: \"block-action\",\n            id: \"block1\",\n            x: 100,\n            y: 100,\n            width: 120,\n            height: 120,\n            name: \" #1\"\n        },\n        {\n            is: \"block-action\",\n            id: \"block2\",\n            x: 300,\n            y: 300,\n            width: 120,\n            height: 120,\n            name: \" #2\"\n        }\n    ],\n    connections: [\n        {\n            sourceBlockId: \"block1\",\n            targetBlockId: \"block2\"\n        }\n    ]\n});\n\n//  \ngraph.start();\n\n//  \ngraph.zoomTo(\"center\", { padding: 100 });\n```\n\n----------------------------------------\n\nTITLE: Implementing Path2DRenderInstance for Custom Connections\nDESCRIPTION: Demonstrates how to implement the Path2DRenderInstance interface for completely custom connection types that don't extend BlockConnection.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n// Only for completely custom connection types not using BlockConnection\nclass MyCustomPathImplementation implements Path2DRenderInstance {\n  public getPath(): Path2D {\n    // Create and return a Path2D object\n    const path = new Path2D();\n    // ... draw your path ...\n    return path;\n  }\n  \n  public style(ctx: CanvasRenderingContext2D) {\n    // Set up styles for your path\n    ctx.strokeStyle = '#4285f4';\n    ctx.lineWidth = 2;\n    return { type: 'stroke' };  // or 'fill' or 'both'\n  }\n  \n  public afterRender?(ctx: CanvasRenderingContext2D): void {\n    // Optional: Add any additional rendering after the main path\n    // This is ideal for labels, arrows, etc.\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Grid Layer in TypeScript\nDESCRIPTION: Complete example of a grid layer implementation that draws a scalable grid based on camera state. Includes constructor setup, rendering logic, and proper event handling.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Layer } from \"@/services/Layer\";\nimport { CameraService } from \"@/services/camera/CameraService\";\n\ninterface GridLayerProps {\n  camera: CameraService;\n  graph: any;\n}\n\nexport class GridLayer extends Layer<GridLayerProps> {\n\n  protected ctx: CanvasRenderingContext2D;\n\n  constructor(props: GridLayerProps) {\n    super({\n      canvas: { zIndex: 1, classNames: [\"grid-layer\"] },\n      ...props\n    });\n    \n    this.ctx = this.getCanvas().getContext(\"2d\");\n    \n    this.context.graph.on(\"camera-change\", this.performRender);\n  }\n  \n  protected render() {\n    const { ctx, camera } = this.context;\n    const { width, height, scale, x, y } = camera.getCameraState();\n    \n    ctx.clearRect(0, 0, width, height);\n    \n    // Draw grid\n    ctx.beginPath();\n    ctx.strokeStyle = \"rgba(0, 0, 0, 0.1)\";\n    \n    const gridSize = 20 * scale;\n    const offsetX = x % gridSize;\n    const offsetY = y % gridSize;\n    \n    for (let i = offsetX; i < width; i += gridSize) {\n      ctx.moveTo(i, 0);\n      ctx.lineTo(i, height);\n    }\n    \n    for (let i = offsetY; i < height; i += gridSize) {\n      ctx.moveTo(0, i);\n      ctx.lineTo(width, i);\n    }\n    \n    ctx.stroke();\n  }\n  \n  protected unmount(): void {\n    this.context.graph.off(\"camera-change\", this.performRender);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Real-time Monitoring Nodes with Automatic Updates\nDESCRIPTION: A MonitoringNode component that updates automatically with real-time data from an API endpoint. It sets up an interval to fetch metrics every 5 seconds and properly cleans up the interval when unmounted.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\nclass MonitoringNode extends GraphComponent {\n  constructor(props, parent) {\n    super(props, parent);\n    \n    // Update component every 5 seconds with new data\n    this.interval = setInterval(() => {\n      fetch(`/api/metrics/${this.props.id}`)\n        .then(res => res.json())\n        .then(data => {\n          this.setState({ metrics: data });\n        });\n    }, 5000);\n  }\n  \n  unmount() {\n    clearInterval(this.interval);\n    super.unmount();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using GraphComponents as Children in Blocks\nDESCRIPTION: Creates rich, interactive block content by implementing GraphComponents as children within Block components. This pattern uses absolute positioning to place interactive elements like badges, icons, and progress indicators within a block.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\nclass ComplexBlock extends Block {\n  protected updateChildren() {\n    return [\n      // Add a badge to top-right corner with absolute positioning\n      BadgeComponent.create({\n        x: this.state.x + this.state.width - 10,\n        y: this.state.y,\n        count: this.props.notifications,\n      }, { key: 'badge' }),\n      \n      // Add an icon to the left side with absolute positioning\n      IconComponent.create({\n        x: this.state.x,\n        y: this.state.y + this.state.height / 2,\n        icon: this.props.icon,\n      }, { key: 'icon' }),\n      \n      // Add a progress indicator to the bottom with absolute positioning\n      ProgressBarComponent.create({\n        x: this.state.x,\n        y: this.state.y + this.state.height - 5,\n        width: this.state.width,\n        progress: this.props.progress,\n      }, { key: 'progress' })\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Block Reference Getters\nDESCRIPTION: TypeScript getters for accessing source and target block references in BaseConnection class.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nprotected get sourceBlock(): Block {\n  return this.connectedState.$sourceBlock.value?.getViewComponent();\n}\n\nprotected get targetBlock(): Block {\n  return this.connectedState.$targetBlock.value?.getViewComponent();\n}\n```\n\n----------------------------------------\n\nTITLE: Handling connection-create-start Event in TypeScript\nDESCRIPTION: Shows how to listen for and handle the event when a user starts creating a connection.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"connection-create-start\", (event) => {\n  console.log('Creating connection from block', event.detail.blockId);\n})\n```\n\n----------------------------------------\n\nTITLE: Class Diagram: Graph Connection System Architecture\nDESCRIPTION: Mermaid class diagram showing the hierarchy and relationships between core connection classes including GraphComponent, BaseConnection, BlockConnection, and related utilities.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n    GraphComponent <|-- BaseConnection\n    BaseConnection <|-- BlockConnection\n    BlockConnection <|-- CustomConnections\n    CustomConnections : MultipointConnection\n    BlockConnection -- Path2DRenderInstance\n    BlockConnection -- BatchPath2D\n    \n    class GraphComponent {\n        +hitBox: HitBox\n        +render()\n        +updateChildren()\n    }\n    \n    class BaseConnection {\n        +connectionPoints\n        +anchorsPoints\n        +connectedState\n        +updatePoints()\n    }\n    \n    class BlockConnection {\n        +path2d\n        +createPath()\n        +style()\n        +getClassName()\n    }\n    \n    class Path2DRenderInstance {\n        <<interface>>\n        +getPath()\n        +style()\n        +afterRender()\n    }\n    \n    class BatchPath2D {\n        -batches: Map\n        +add()\n        +update()\n        +delete()\n        +render()\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic Component in TypeScript\nDESCRIPTION: Shows how to create a simple component with state management and lifecycle methods. Demonstrates willMount for initialization, render for display logic, and a public method for state manipulation.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@gravity-ui/graph\";\n\nclass MyComponent extends Component {\n  protected willMount() {\n    // Initialize, similar to constructor but guaranteed to run before first render\n    this.setState({ counter: 0 });\n  }\n  \n  protected render() {\n    // Render logic\n    console.log('Rendering with counter:', this.state.counter);\n  }\n  \n  public increment() {\n    this.setState({ counter: this.state.counter + 1 });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing HitBox Updates for Graph Components\nDESCRIPTION: Demonstrates how to optimize hitbox updates in GraphComponents by only updating the hitbox when geometry changes, rather than on every state change. This reduces stress on the spatial index system.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// Bad - updating hitbox on every state change\nprotected stateChanged() {\n  super.stateChanged();\n  this.updateHitBox(); // Don't do this for every state change!\n}\n\n// Good - only update when position changes\nprotected stateChanged(nextState) {\n  if (nextState.x !== this.state.x || nextState.y !== this.state.y) {\n    super.stateChanged(nextState);\n    this.updateHitBox();\n  } else {\n    super.stateChanged(nextState);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Connection Implementation Example\nDESCRIPTION: Example implementation of a basic connection using BaseConnection class.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nclass SimpleConnection extends BaseConnection {\n  protected render() {\n    if (!this.connectionPoints) return;\n    \n    const [source, target] = this.connectionPoints;\n    const ctx = this.context.ctx;\n    \n    ctx.beginPath();\n    ctx.moveTo(source.x, source.y);\n    ctx.lineTo(target.x, target.y);\n    ctx.stroke();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Global UI Elements in Custom Layers with GraphComponents\nDESCRIPTION: A custom Layer implementation called ToolbarLayer that creates global UI elements floating above the graph. It renders zoom controls and selection information using various component types.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nclass ToolbarLayer extends Layer {\n  protected updateChildren() {\n    return [\n      ButtonComponent.create({\n        icon: 'zoom-in',\n        action: () => this.context.camera.zoomIn(),\n      }, { key: 'zoom-in' }),\n      \n      ButtonComponent.create({\n        icon: 'zoom-out',\n        action: () => this.context.camera.zoomOut(),\n      }, { key: 'zoom-out' }),\n      \n      SelectionInfoComponent.create({\n        selection: this.context.selection,\n      }, { key: 'selection-info' })\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Block Duplication Completion Event\nDESCRIPTION: Shows how to listen for the block-added-from-shadow event, which fires when block duplication is completed. This event provides the source block ID and coordinates where the new block should be created.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/newBlockLayer/NewBlockLayer.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"block-added-from-shadow\", (event) => {\n  console.log('Block duplicated from', event.detail.sourceBlockId);\n  console.log('At coordinates', event.detail.coord);\n  \n  // Create the actual block based on the source block\n  const newBlock = createBlockFromSource(\n    event.detail.sourceBlockId, \n    event.detail.coord\n  );\n})\n```\n\n----------------------------------------\n\nTITLE: Dynamic Connection Styling Implementation\nDESCRIPTION: Methods for handling dynamic connection styling based on state and providing render style instructions.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\npublic getClassName(state = this.state) {\n  const hovered = state.hovered ? \"hovered\" : \"none\";\n  const selected = state.selected ? \"selected\" : \"none\";\n  const stroke = this.getStrokeColor(state);\n  const dash = state.dashed ? (state.styles?.dashes || [6, 4]).join(\",\") : \"\";\n  return `connection/${hovered}/${selected}/${stroke}/${dash}`;\n}\n\npublic style(ctx: CanvasRenderingContext2D): Path2DRenderStyleResult | undefined {\n  this.setRenderStyles(ctx, this.state);\n  return { type: \"stroke\" };\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Schedulers with Different Priority Levels\nDESCRIPTION: Demonstrates how to create and configure multiple schedulers with different priority levels using the GlobalScheduler. Lower priority levels (0) are processed before higher levels (4).\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/scheduler-system.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// Create two schedulers with different priority levels\nconst highPriorityScheduler = new Scheduler();\nconst lowPriorityScheduler = new Scheduler();\n\n// Add the schedulers to the global scheduler with different priority levels\nglobalScheduler.addScheduler(highPriorityScheduler, 0); // High priority\nglobalScheduler.addScheduler(lowPriorityScheduler, 4); // Low priority\n\n// Start the global scheduler\nglobalScheduler.start();\n\n// Assign different components to the schedulers\nhighPriorityScheduler.setRoot(highPriorityRootComponent.__comp.treeNode);\nlowPriorityScheduler.setRoot(lowPriorityRootComponent.__comp.treeNode);\n```\n\n----------------------------------------\n\nTITLE: Visualizing GraphComponent Inheritance and Relationships with Mermaid\nDESCRIPTION: A class diagram showing the inheritance structure of GraphComponent and its relationships with other classes in the system. It illustrates how GraphComponent extends EventedComponent and is the base for Block, Anchor, and Connection classes.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n    EventedComponent <|-- GraphComponent\n    GraphComponent <|-- Block\n    GraphComponent <|-- Anchor\n    GraphComponent <|-- Connection\n    GraphComponent -- HitBox\n    GraphComponent -- Camera\n    \n    class EventedComponent {\n        +props: TComponentProps\n        +state: TComponentState\n        +context: TComponentContext\n        +addEventListener()\n        +removeEventListener()\n    }\n    \n    class GraphComponent {\n        +hitBox: HitBox\n        +setHitBox()\n        +getHitBox()\n        +isVisible()\n        +onDrag()\n        +subscribeSignal()\n    }\n```\n\n----------------------------------------\n\nTITLE: Connection Label Rendering\nDESCRIPTION: Implementation of label rendering logic with zoom-level based visibility.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\npublic afterRender?(ctx: CanvasRenderingContext2D): void {\n  const cameraClose = this.context.camera.getCameraScale() >= \n    this.context.constants.connection.MIN_ZOOM_FOR_CONNECTION_ARROW_AND_LABEL;\n\n  if (this.state.label && this.props.showConnectionLabels && cameraClose) {\n    this.renderLabelText(ctx);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Initialization Phase with Mermaid\nDESCRIPTION: A flowchart diagram showing the component initialization phase from constructor to component readiness.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    A[new Component/CoreComponent] --> B[constructor]\n    B --> C[Initialize private data]\n    C --> D[Set up Tree node]\n    D --> E[Initialize props/state]\n    E --> F[Component is ready]\n```\n\n----------------------------------------\n\nTITLE: Managing Block Selection in Graph\nDESCRIPTION: Handling the blocks-selection-change event to track which blocks are currently selected and update the UI accordingly.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nuseGraphEvent(graph, \"blocks-selection-change\", \n  ({ changes }) => {\n    const selectedBlocks = changes.add.map(id => \n      graph.rootStore.blocksList.getBlock(id)\n    );\n    // Update your UI with selected blocks\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Global Scheduler Instances\nDESCRIPTION: Demonstrates how to create and export global scheduler instances for convenient sharing across components. This allows components to share a single scheduler instance and animation frame loop.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/scheduler-system.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const globalScheduler = new GlobalScheduler();\nexport const scheduler = globalScheduler;\n```\n\n----------------------------------------\n\nTITLE: Defining GraphMouseEvent Interface in TypeScript\nDESCRIPTION: Defines the GraphMouseEvent interface used for mouse events in the graph visualization library. It extends CustomEvent and includes properties for the target component, source event, and pointer state.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/events.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EventedComponent } from \"@gravity-ui/graph\";\n\ninterface GraphMouseEvent<E extends Event = Event> = CustomEvent<{\n  target?: EventedComponent;\n  sourceEvent: E;\n  pointerPressed?: boolean;\n}>\n```\n\n----------------------------------------\n\nTITLE: Implementing Enhanced Connections with Child Components\nDESCRIPTION: Creates connections with labels, decorations, and interactive elements by implementing GraphComponents as children of a connection. This pattern uses absolute positioning based on the connection's points to place elements like labels, action buttons, and arrows.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nclass EnhancedConnection extends BaseConnection {\n  protected updateChildren() {\n    if (!this.connectionPoints) return [];\n    \n    const [start, end] = this.connectionPoints;\n    const midX = (start.x + end.x) / 2;\n    const midY = (start.y + end.y) / 2;\n    \n    return [\n      // Add a label in the middle with absolute positioning\n      ConnectionLabel.create({\n        x: midX,\n        y: midY,\n        text: this.props.label,\n      }, { key: 'label' }),\n      \n      // Add interactive buttons with absolute positioning\n      ActionButton.create({\n        x: midX + 20,\n        y: midY - 10,\n        icon: 'edit',\n        action: () => this.props.onEdit(),\n      }, { key: 'edit-button' }),\n      \n      // Add decorative elements with absolute positioning\n      ArrowComponent.create({\n        x: end.x,\n        y: end.y,\n        angle: Math.atan2(end.y - start.y, end.x - start.x),\n      }, { key: 'arrow' })\n    ];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Vanilla JavaScript Graph Creation Example\nDESCRIPTION: Example of using @gravity-ui/graph with vanilla JavaScript instead of React. Shows how to create a container, initialize the graph, add blocks and connections, and control the view.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README.md#2025-04-17_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Graph } from \"@gravity-ui/graph\";\n\n// Create container element\nconst container = document.createElement('div');\ncontainer.style.width = '100vw';\ncontainer.style.height = '100vh';\ncontainer.style.overflow = 'hidden';\ndocument.body.appendChild(container);\n\n// Initialize graph with configuration\nconst graph = new Graph({\n    configurationName: \"example\",\n    blocks: [],\n    connections: [],\n    settings: {\n        canDragCamera: true,\n        canZoomCamera: true,\n        useBezierConnections: true,\n        showConnectionArrows: true\n    }\n}, container);\n\n// Add blocks and connections\ngraph.setEntities({\n    blocks: [\n        {\n            is: \"block-action\",\n            id: \"block1\",\n            x: 100,\n            y: 100,\n            width: 120,\n            height: 120,\n            name: \"Block #1\"\n        },\n        {\n            is: \"block-action\",\n            id: \"block2\",\n            x: 300,\n            y: 300,\n            width: 120,\n            height: 120,\n            name: \"Block #2\"\n        }\n    ],\n    connections: [\n        {\n            sourceBlockId: \"block1\",\n            targetBlockId: \"block2\"\n        }\n    ]\n});\n\n// Start rendering\ngraph.start();\n\n// Center the view\ngraph.zoomTo(\"center\", { padding: 100 });\n```\n\n----------------------------------------\n\nTITLE: Path2D Caching for Complex Shapes in GraphComponent\nDESCRIPTION: Improves rendering performance by creating and caching Path2D objects for complex shapes instead of redrawing paths on every frame. The cached path is only regenerated when geometry changes.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\n// Cache the path when geometry changes\nprivate updatePath() {\n  const path = new Path2D();\n  // Complex path drawing operations...\n  this.cachedPath = path;\n}\n\n// Use the cached path during rendering\nprotected render() {\n  if (!this.isVisible()) return;\n  if (!this.cachedPath) this.updatePath();\n  \n  const ctx = this.context.ctx;\n  ctx.stroke(this.cachedPath);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Graph Events for ConnectionLayer in TypeScript\nDESCRIPTION: Interface definition for events related to connection creation in the ConnectionLayer, including connection-create-start and connection-created events.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Key events\ninterface GraphEventsDefinitions {\n  \"connection-create-start\": (event: CustomEvent<{ blockId: string; anchorId: string | undefined }>) => void;\n  \"connection-created\": (event: CustomEvent<{ \n    source: { blockId: string; anchorId?: string; };\n    target: { blockId: string; targetAnchorId?: string };\n  }>) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Vertical Flow Layout in TypeScript\nDESCRIPTION: Updates graph settings to use vertical connection direction with arrows. This configuration is useful for flowcharts or diagrams that follow a top-to-bottom layout.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.updateSettings({\n  bezierConnectionDirection: 'vertical',\n  showConnectionArrows: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Visualizing GraphComponent Lifecycle with Mermaid Sequence Diagram\nDESCRIPTION: This sequence diagram illustrates the lifecycle of a GraphComponent, showing its interactions with the Graph System, Spatial Index, and Camera System. It demonstrates component creation, rendering, mouse interaction, and cleanup processes.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant App as Application\n    participant Graph as Graph System\n    participant Comp as GraphComponent\n    participant HitTest as Spatial Index\n    participant Camera as Camera System\n    \n    App->>Graph: Create new component\n    Graph->>Comp: Initialize component\n    Comp->>HitTest: Register hitbox\n    \n    Note over Comp,HitTest: Component now exists in spatial system\n    \n    loop Each Frame\n        Graph->>Comp: iterate()\n        Comp->>Camera: isVisible check\n        Camera-->>Comp: Visibility result\n        \n        alt Component is visible\n            Comp->>Comp: render()\n            Note over Comp: Visual updates appear\n        else Component is off-screen\n            Note over Comp: Skips rendering\n        end\n    end\n    \n    App->>Graph: User mouses over component\n    Graph->>HitTest: Query spatial index\n    HitTest-->>Graph: Component found at position\n    Graph->>Comp: Mouse event triggered\n    \n    App->>Graph: User drags component\n    Comp->>Comp: onDragUpdate executed\n    Comp->>Comp: Update position state\n    Comp->>HitTest: Update hitbox position\n    \n    App->>Graph: Component is no longer needed\n    Graph->>Comp: unmount()\n    Comp->>Comp: Cleanup subscriptions\n    Comp->>HitTest: Remove hitbox\n```\n\n----------------------------------------\n\nTITLE: Manual Group Management in TypeScript\nDESCRIPTION: Shows how to manually create and manage groups using GroupsList methods. Includes examples of creating and updating groups with specific properties.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/blocks/groups.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph, GroupsList } from '@gravity-ui/graph';\n\n// Add groups to graph\nconst groups = graph.addLayer(GroupsList, {\n  draggable: true,\n});\n\n// Set groups\ngroups.setGroups([\n  {\n    id: \"group1\",\n    rect: { x: 0, y: 0, width: 100, height: 100 },\n    style: {\n      background: \"rgba(0, 100, 200, 0.1)\"\n    }\n  }\n]);\n\n// Update specific groups\ngroups.updateGroups([\n  {\n    id: \"group1\",\n    rect: { x: 50, y: 50, width: 100, height: 100 }\n  }\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating Fixed Area Groups in TypeScript\nDESCRIPTION: Example of creating fixed area groups with specific styling and positioning. Demonstrates how to set up non-draggable groups with custom backgrounds and borders.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/blocks/groups.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph, GroupsList } from '@gravity-ui/graph';\n\n// Add fixed area groups to graph\nconst areas = graph.addLayer(GroupsList, {\n  draggable: false,  // areas cannot be moved\n});\n\n// Create fixed areas\nareas.setGroups([\n  {\n    id: \"area1\",\n    rect: { x: 0, y: 0, width: 800, height: 400 },\n    style: {\n      background: \"rgba(100, 149, 237, 0.1)\",\n      border: \"rgba(100, 149, 237, 0.3)\"\n    }\n  },\n  {\n    id: \"area2\",\n    rect: { x: 800, y: 0, width: 800, height: 400 },\n    style: {\n      background: \"rgba(144, 238, 144, 0.1)\",\n      border: \"rgba(144, 238, 144, 0.3)\"\n    }\n  }\n]);\n```\n\n----------------------------------------\n\nTITLE: TBlock Interface Definition in TypeScript\nDESCRIPTION: Type definition for the basic block data structure including properties for identification, positioning, and metadata.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype TBlock<T extends Record<string, unknown> = {}> = {\n  id: TBlockId;              // Unique identifier\n  is: string;                // Block type identifier\n  x: number;                 // X coordinate\n  y: number;                 // Y coordinate\n  group?: string;            // Optional group identifier\n  width: number;             // Width of the block\n  height: number;            // Height of the block\n  selected: boolean;         // Selection state\n  label: string;              // Display name\n  anchors: TAnchor[];        // Connection points\n  settings?: TBlockSettings; // Additional settings\n  meta?: T;                  // Custom metadata\n};\n```\n\n----------------------------------------\n\nTITLE: Handling connection-create-drop Event in TypeScript\nDESCRIPTION: Demonstrates how to handle the event when a user drops the connection endpoint, regardless of whether a connection was created.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"connection-create-drop\", (event) => {\n  console.log('Connection dropped at', event.detail.point);\n})\n```\n\n----------------------------------------\n\nTITLE: Best Practices for Custom Block Rendering\nDESCRIPTION: A collection of code snippets demonstrating best practices for custom block implementations, including camera scale handling, theme color usage, selection state rendering, and performance optimization techniques.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// Scale line widths based on camera zoom\nctx.lineWidth = Math.round(2 / this.context.camera.getCameraScale());\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Use colors from graph theme\nctx.fillStyle = this.context.colors.block.background;\nctx.strokeStyle = this.context.colors.block.border;\n```\n\nLANGUAGE: typescript\nCODE:\n```\nif (this.state.selected) {\n  // Custom selection visualization\n  this.renderStroke(this.context.colors.block.selectedBorder);\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Only render text when needed\nif (this.shouldRenderText && this.context.camera.getCameraScale() > 0.5) {\n  this.renderText(this.state.label);\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Incorrect - don't transform coordinates manually\n// const worldX = originalX * transform.scale + transform.x;\n\n// Correct - use original coordinates\nctx.fillRect(this.state.x, this.state.y, this.state.width, this.state.height);\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Optimize for performance with complex custom blocks\nprotected willRender() {\n  // Only update complex calculations when needed\n  if (this.needsRecalculation) {\n    this.calculateGeometry();\n    this.needsRecalculation = false;\n  }\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\n// Implement both schematic and detailed views\npublic renderSchematicView(ctx: CanvasRenderingContext2D) {\n  // Simplified rendering for schematic view\n}\n\npublic renderDetailedView(ctx: CanvasRenderingContext2D) {\n  // More detailed rendering for close-up view\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Layers in Graph Initialization\nDESCRIPTION: Example of how to attach layers to a Graph instance either during initialization or dynamically. Shows usage of NewBlockLayer and ConnectionLayer with configuration options.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Graph } from \"@/graph\";\nimport { NewBlockLayer } from \"@/components/canvas/layers/newBlockLayer\";\nimport { ConnectionLayer } from \"@/components/canvas/layers/connectionLayer\";\n\n// Attach when creating a graph\nconst graph = new Graph({\n  layers: [\n    [NewBlockLayer, { ghostBackground: \"rgba(0, 0, 255, 0.3)\" }],\n    [ConnectionLayer, {}]\n  ]\n});\n\n// Or add dynamically\nconst newBlockLayer = graph.addLayer(NewBlockLayer, { ghostBackground: \"rgba(0, 0, 255, 0.3)\" });\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced State Diffing for Optimized Rendering in TypeScript\nDESCRIPTION: This snippet demonstrates advanced state diffing techniques for complex blocks with many properties. It uses lodash's isEqual function to compare current and next state, focusing on style and data properties to determine if a render is necessary.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isEqual } from 'lodash';\n\nclass OptimizedBlock extends Block {\n  protected stateChanged(nextState: TBlock): void {\n    // Compare relevant properties using lodash's isEqual\n    if (!isEqual(nextState.style, this.state.style)) {\n      // Style changed, need to render\n      this.shouldRender = true;\n    } else if (!isEqual(nextState.data, this.state.data)) {\n      // Data changed, need to render\n      this.shouldRender = true;\n    } else {\n      // No relevant changes, skip rendering\n      this.shouldRender = false;\n    }\n    \n    // Always call parent method after your custom logic\n    super.stateChanged(nextState);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fixed Position GraphBlockAnchor\nDESCRIPTION: Using GraphBlockAnchor component with fixed positioning mode. Anchors are placed at exact coordinates relative to the block.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n<GraphBlockAnchor \n  graph={graph} \n  anchor={anchor}\n  position=\"fixed\"\n>\n  {(state) => (\n    <div className={state.selected ? 'selected' : ''}>\n      {/* Anchor visuals */}\n    </div>\n  )}\n</GraphBlockAnchor>\n```\n\n----------------------------------------\n\nTITLE: Adding Elements to BatchPath2D in TypeScript\nDESCRIPTION: Demonstrates how elements are added to the BatchPath2D rendering system with z-index and grouping information.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nthis.context.batch.add(this, { \n  zIndex: this.zIndex, \n  group: this.getClassName() \n});\n```\n\n----------------------------------------\n\nTITLE: Custom Arrow Rendering in MultipointConnection\nDESCRIPTION: Demonstrates how to create and position arrows at the end of a multipoint connection based on the direction of the last segment.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trangleArrowForVector } from \"@/utils/shapes\";\n\npublic createArrowPath(): Path2D {\n  const { points } = this.connectedState.$state.value;\n  if (!points.length) {\n    return undefined;\n  }\n\n  const [start, end] = points.slice(points.length - 2);\n  return trangleArrowForVector(start, end, 16, 10);\n}\n```\n\n----------------------------------------\n\nTITLE: Interacting Between Layers in TypeScript\nDESCRIPTION: Example showing how to access another layer instance and subscribe to events from other layers, demonstrating layer interaction patterns.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ConnectionLayer } from \"@/components/canvas/layers/connectionLayer\";\n\n// Access another layer\nconst connectionLayer = this.context.graph.layers.find(layer => layer instanceof ConnectionLayer);\n\n// Use events\nthis.context.graph.on(\"connection-created\", (event) => {\n  // React to connection creation\n});\n```\n\n----------------------------------------\n\nTITLE: Defining ConnectionLayerProps Interface in TypeScript\nDESCRIPTION: Defines the structure of props for ConnectionLayer, including icon configurations and line drawing function.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype ConnectionLayerProps = LayerProps & {\n  createIcon?: TIcon;\n  point?: TIcon;\n  drawLine?: DrawLineFunction;\n};\n\ntype TIcon = {\n  path: string;       // SVG path\n  fill?: string;      // Fill color\n  stroke?: string;    // Stroke color\n  width: number;      // Width of the icon\n  height: number;     // Height of the icon\n  viewWidth: number;  // View width\n  viewHeight: number; // View height\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Connection with Custom Path\nDESCRIPTION: Demonstrates creating a custom connection by extending BlockConnection and overriding the path creation method to create a custom path shape.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyCustomConnection extends BlockConnection {\n  // Override the path creation for custom appearance\n  public createPath(): Path2D {\n    const path = new Path2D();\n    \n    // Example: Create a dashed custom path\n    const { x1, y1, x2, y2 } = this.geometry;\n    const midX = (x1 + x2) / 2;\n    \n    path.moveTo(x1, y1);\n    path.lineTo(midX, y1);\n    path.lineTo(midX, y2);\n    path.lineTo(x2, y2);\n    \n    return path;\n  }\n```\n\n----------------------------------------\n\nTITLE: Connection Batch Rendering Setup\nDESCRIPTION: Constructor implementation for BlockConnection showing batch rendering system integration.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconstructor(props: TConnectionProps, parent: BlockConnections) {\n  super(props, parent);\n  this.addEventListener(\"click\", this);\n\n  this.context.batch.add(this, { zIndex: this.zIndex, group: this.getClassName() });\n  this.context.batch.add(this.arrowShape, { zIndex: this.zIndex, group: `arrow/${this.getClassName()}` });\n}\n```\n\n----------------------------------------\n\nTITLE: Styling GraphBlockAnchor with CSS Variables\nDESCRIPTION: CSS styling for anchor components using CSS variables provided by the graph library.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/react/usage.md#2025-04-17_snippet_5\n\nLANGUAGE: css\nCODE:\n```\n.anchor {\n  --graph-block-anchor-bg: rgba(255, 190, 92, 1);\n  --graph-block-anchor-border-selected: rgba(255, 190, 92, 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative Initialization of NewBlockLayer\nDESCRIPTION: Shows an alternative way to initialize NewBlockLayer directly during graph creation. This approach adds the layer as part of the initial graph configuration.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/newBlockLayer/NewBlockLayer.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst graph = useGraph({\n    layers: [[NewBlockLayer, {}]]\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Z-Index for Optimal Rendering Order\nDESCRIPTION: A TypeScript example showing how to set the z-index property to control the rendering order of components, ensuring proper layering in the visual output.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// Set z-index for proper rendering order\nthis.zIndex = 5; // Higher z-index components render on top\n```\n\n----------------------------------------\n\nTITLE: Defining Common Event Types for Graph Visualization Library\nDESCRIPTION: Provides TypeScript interface definitions for common event types used in the graph visualization library, including SelectionEvent, TCameraState, TBlock, TAnchor, and type aliases for TBlockId and TConnection.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/events.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface SelectionEvent<T> {\n  list: T[];\n  changed: {\n    add: T[];\n    removed: T[];\n  };\n}\n\ninterface TCameraState {\n  x: number;\n  y: number;\n  scale: number;\n}\n\ninterface TBlock {\n  id: string;\n}\n\ninterface TAnchor {\n  id: string;\n}\n\ntype TBlockId = string;\ntype TConnection = string;\n```\n\n----------------------------------------\n\nTITLE: Scale-Dependent Rendering Implementation in TypeScript\nDESCRIPTION: Method implementation for rendering blocks at different zoom levels based on camera scale.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprotected render() {\n  const scaleLevel = this.context.graph.cameraService.getCameraBlockScaleLevel();\n  \n  switch (scaleLevel) {\n    case ECameraScaleLevel.Minimalistic:\n      this.renderMinimalisticBlock(this.context.ctx);\n      break;\n    case ECameraScaleLevel.Schematic:\n      this.renderSchematicView(this.context.ctx);\n      break;\n    case ECameraScaleLevel.Detailed:\n      this.renderDetailedView(this.context.ctx);\n      break;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Package Installation Command\nDESCRIPTION: NPM installation command for the @gravity-ui/graph package.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README-ru.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @gravity-ui/graph\n```\n\n----------------------------------------\n\nTITLE: Creating a Read-Only Graph View in TypeScript\nDESCRIPTION: Configures the graph as a read-only view where users can navigate but not modify the structure. This is useful for presentation or viewing contexts where editing is not desired.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.updateSettings({\n  canDragCamera: true,\n  canZoomCamera: true,\n  canChangeBlockGeometry: 'none',\n  canCreateNewConnections: false,\n});\n```\n\n----------------------------------------\n\nTITLE: React Graph Editor Implementation\nDESCRIPTION: Full example of a React-based graph editor with block creation, connections, and zoom functionality.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README-ru.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GraphCanvas, GraphState, GraphBlock, useGraph } from \"@gravity-ui/graph\";\nimport React from \"react\";\n\nconst config = {};\n\nexport function GraphEditor() {\n  const { graph, setEntities, start } = useGraph(config);\n\n  useEffect(() => {\n    setEntities({\n      blocks: [\n        {\n          is: \"block-action\",\n          id: \"action_1\",\n          x: -100,\n          y: -450,\n          width: 126,\n          height: 126,\n          selected: true,\n          name: \" #1\",\n          anchors: [],\n        },\n        {\n          id: \"action_2\",\n          is: \"block-action\",\n          x: 253,\n          y: 176,\n          width: 126,\n          height: 126,\n          selected: false,\n          name: \" #2\",\n          anchors: [],\n        }\n      ],\n      connections: [\n        {\n          sourceBlockId: \"action_1\",\n          targetBlockId: \"action_2\",\n        }\n      ]\n    });\n  }, [setEntities]);\n\n  const renderBlockFn = (graph, block) => {\n    return <GraphBlock graph={graph} block={block}>{block.id}</GraphBlock>;\n  };\n\n  return (\n    <GraphCanvas\n      graph={graph}\n      renderBlock={renderBlockFn}\n      onStateChanged={({ state }) => {\n        if (state === GraphState.ATTACHED) {\n          start();\n          graph.zoomTo(\"center\", { padding: 300 });\n        }\n      }}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Block Component Class Diagram in Mermaid\nDESCRIPTION: Class diagram showing the relationships between Block component and related classes including inheritance and associations.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nclassDiagram\n    GraphComponent <|-- Block\n    Block <|-- CustomBlock\n    Block -- BlockState\n    Block -- BlockController\n    Block -- GraphLayer\n    \n    class GraphComponent {\n        +props\n        +state\n        +context\n        +iterate()\n        +render()\n    }\n    \n    class Block {\n        +static IS: string\n        +isBlock: boolean\n        +connectedState: BlockState\n        +blockController: BlockController\n        +$viewState: Signal\n        +getGeometry()\n        +updatePosition()\n        +handleEvent()\n        +getAnchorPosition()\n        +renderBody()\n        +renderSchematicView()\n        +renderDetailedView()\n    }\n    \n    class BlockState {\n        +$state: Signal\n        +$anchors: Signal\n        +$geometry: Signal\n        +updateXY()\n        +setViewComponent()\n    }\n    \n    class BlockController {\n        +handleEvent()\n        +onDragStart()\n        +onDragUpdate()\n        +onDragEnd()\n    }\n```\n\n----------------------------------------\n\nTITLE: Controlling Rendering with Lifecycle Flags in TypeScript\nDESCRIPTION: A TypeScript example showing how to optimize performance by controlling the rendering of a component based on props changes, by only setting the shouldRender flag to true when relevant props have changed.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nprotected propsChanged(nextProps) {\n  // Only render if relevant props have changed\n  this.shouldRender = nextProps.value !== this.props.value;\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating a Component with the Scheduler System\nDESCRIPTION: Shows how a component interacts with the scheduler by calling performRender() when state updates, which schedules an update to be processed during the next animation frame.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/scheduler-system.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyComponent extends Component {\n  public updateValue(newValue) {\n    this.setState({ value: newValue });\n    // This calls performRender() which schedules an update\n  }\n  \n  protected render() {\n    // This will be called during the next animation frame\n    console.log('Rendering with value:', this.state.value);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing NewBlockLayer in Gravity UI Graph\nDESCRIPTION: Shows how to initialize and control the NewBlockLayer in a graph instance. This approach creates the layer after graph initialization and provides methods to enable or disable the functionality.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/newBlockLayer/NewBlockLayer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst graph = useGraph();\n\nconst newBlockLayer = graph.addLayer(NewBlockLayer, {});\n\n// Enable or disable the functionality as needed\nnewBlockLayer.enable();\nnewBlockLayer.disable();\n```\n\n----------------------------------------\n\nTITLE: Optimizing Child Component Creation in GraphComponent\nDESCRIPTION: Demonstrates how to efficiently create child components only when necessary and use stable keys to prevent unnecessary recreation. This optimization prevents performance issues when components update frequently.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nprotected updateChildren() {\n  // Only create children if parent is visible\n  if (!this.isVisible()) return [];\n  \n  // Use stable keys so React/GraphComponents don't recreate unnecessarily\n  return [\n    ChildComponent.create({...}, { key: 'stable-id-1' }),\n    ChildComponent.create({...}, { key: 'stable-id-2' })\n  ];\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Child Updates with State Change Detection\nDESCRIPTION: A TypeScript example demonstrating how to skip unnecessary child component updates by setting the shouldUpdateChildren flag based on specific state changes, improving rendering performance.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprotected stateChanged(nextState) {\n  // Only update children if specific state changed\n  this.shouldUpdateChildren = nextState.items !== this.state.items;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Level of Detail (LOD) for GraphComponents\nDESCRIPTION: Adapts rendering complexity based on camera zoom level, improving performance by simplifying visual representation when zoomed out. This technique uses the camera's scale level to determine the appropriate rendering detail.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ECameraScaleLevel } from \"@/services/camera/CameraService\";\n\nprotected render() {\n  const detailLevel = this.context.camera.getCameraBlockScaleLevel();\n  \n  // Render based on the detail level enum from Camera\n  if (detailLevel === ECameraScaleLevel.Minimalistic) {\n    // Lowest detail: render as a single pixel dot\n    this.renderAsDot();\n  } else if (detailLevel === ECameraScaleLevel.Schematic) {\n    // Medium detail: render simplified shape\n    this.renderSimple();\n  } else {\n    // Highest detail (ECameraScaleLevel.Detailed): render full detail\n    this.renderDetailed();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extending BlockConnection for Custom Connections\nDESCRIPTION: Shows how to extend the BlockConnection class to create custom connection types with customized path geometry and styling.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyCustomConnection extends BlockConnection {\n  // Override createPath() to change the path geometry\n  public createPath(): Path2D {\n    // Your custom path creation logic\n    return new Path2D();\n  }\n  \n  // Override style() to change the appearance\n  public style(ctx: CanvasRenderingContext2D) {\n    // Your custom styling logic\n    return { type: 'stroke' };\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling connection-created Event in TypeScript\nDESCRIPTION: Shows how to handle the event when a connection is successfully created, with an option to prevent default behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"connection-created\", (event) => {\n  // The connection is added to connectionsList by default\n  // You can prevent this:\n  event.preventDefault();\n})\n```\n\n----------------------------------------\n\nTITLE: Zoom Threshold Configuration in TypeScript\nDESCRIPTION: Configuration example for setting zoom level thresholds that control block rendering modes.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.setConstants({\n  block: {\n    SCALES: [0.125, 0.225, 0.5] // Detailed view stays until zoom = 0.5\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Emitting Custom Events in Graph Visualization Library\nDESCRIPTION: Demonstrates how to emit a custom event in the graph visualization library. It defines a custom event detail object and uses the graph's emit method to trigger the event.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/events.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// Define custom event detail\nconst customEventDetail = {\n  message: 'Custom event triggered',\n  timestamp: Date.now()\n};\n\n// Emit the custom event\ngraph.emit('my-custom-event', customEventDetail);\n```\n\n----------------------------------------\n\nTITLE: Path2D Generation for Block Connections\nDESCRIPTION: Implementation of Path2D generation methods for both bezier and straight connections.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bezierCurveLine } from \"@/utils/shapes/curvePolyline\";\nimport { curvePolyline } from \"@/utils/shapes/polyline\";\n\nprotected generatePath() {\n  this.path2d = this.createPath();\n  return this.path2d;\n}\n\nprotected createPath(): Path2D {\n  if (this.props.useBezier) {\n    return bezierCurveLine(\n      { x: this.geometry.x1, y: this.geometry.y1 },\n      { x: this.geometry.x2, y: this.geometry.y2 },\n      this.props.bezierDirection\n    );\n  }\n  const path2d = new Path2D();\n  path2d.moveTo(this.geometry.x1, this.geometry.y1);\n  path2d.lineTo(this.geometry.x2, this.geometry.y2);\n  return path2d;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Dark Theme to Graph in TypeScript\nDESCRIPTION: Updates the graph's color scheme to create a dark-themed visualization. This example changes the canvas, block, and connection colors to create a cohesive dark interface.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/graph-settings.md#2025-04-17_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.setColors({\n  canvas: {\n    belowLayerBackground: '#2d2d2d',\n    layerBackground: '#3d3d3d',\n    dots: '#4d4d4d',\n    border: '#2d2d2d',\n  },\n  block: {\n    background: '#4d4d4d',\n    border: '#5d5d5d',\n    text: '#f5f5f5',\n    selectedBorder: '#ffcc00',\n  },\n  connection: {\n    background: '#a0a0a0',\n    selectedBackground: '#ffcc00',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Property Change Detection in TypeScript for Graph Blocks\nDESCRIPTION: This snippet shows how to override the shouldRender method to customize rendering behavior based on specific property changes. It checks for changes in position (x, y) and font properties to determine if a render is necessary.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nclass OptimizedBlock extends Block {\n  // Override shouldRender to customize rendering behavior\n  protected shouldRender(nextState: TBlock, nextProps: TBlockProps): boolean {\n    // Check if relevant properties have changed\n    if (nextState.x !== this.state.x || nextState.y !== this.state.y) {\n      // Position changed, need to render\n      return true;\n    }\n    \n    if (nextProps.font !== this.props.font) {\n      // Font changed, need to render\n      return true;\n    }\n    \n    // No relevant changes, skip rendering\n    return false;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Block Duplication Start Event\nDESCRIPTION: Demonstrates how to listen for the block-add-start-from-shadow event, which is fired when a user initiates block duplication with Alt+mousedown. This event provides the source block's ID.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/newBlockLayer/NewBlockLayer.md#2025-04-17_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"block-add-start-from-shadow\", (event) => {\n  console.log('Duplicating block', event.detail.sourceBlockId);\n})\n```\n\n----------------------------------------\n\nTITLE: Proper Resource Cleanup in GraphComponent\nDESCRIPTION: Demonstrates correct resource cleanup in the unmount method to prevent memory leaks. This pattern ensures any custom resources, event listeners, or subscriptions are properly disposed of when a component is removed from the graph.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyCleanComponent extends GraphComponent {\n  constructor(props, parent) {\n    super(props, parent);\n    \n    // Custom resources or listeners\n    this.myCustomResource = createExpensiveResource();\n    this.externalListener = window.addEventListener('resize', this.handleResize);\n  }\n  \n  protected unmount() {\n    // Release any resources you created\n    this.myCustomResource.dispose();\n    window.removeEventListener('resize', this.handleResize);\n    \n    // ALWAYS call super.unmount() last!\n    // This ensures GraphComponent's cleanup runs\n    super.unmount();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding CLA Agreement Statement to Pull Requests\nDESCRIPTION: The required statement to include in pull requests to confirm agreement to the Contributor License Agreement. Contributors must include this text to indicate they have read and agreed to the CLA terms.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/CONTRIBUTING.md#2025-04-17_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nI hereby agree to the terms of the CLA available at: [link].\n```\n\n----------------------------------------\n\nTITLE: Initializing BaseConnection Component\nDESCRIPTION: TypeScript implementation of the BaseConnection class showing core connection state management and initialization. Handles connection state synchronization with the store.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Component } from \"@/lib/Component\";\nimport { selectConnectionById } from \"@/store/connection/selectors\";\nimport { ConnectionState } from \"@/store/connection/ConnectionState\";\nimport { Block } from \"@/store/block/Block\";\nimport { HitBox, HitBoxData } from \"@/services/HitTest\";\n\ninterface Props {\n  id: string;\n}\n\ninterface TBaseConnectionState {\n  id: string;\n  sourceBlockId: string;\n  targetBlockId: string;\n}\n\ninterface Path2DRenderStyleResult {\n  type: 'stroke' | 'fill' | 'both';\n}\n\ninterface Connection {\n  id: string;\n}\n\nclass BaseConnection extends Component<Props> {\n  protected connectedState: ConnectionState<Connection>;\n\n  constructor(props: Props, parent: Component) {\n    super(props, parent);\n    this.connectedState = selectConnectionById(this.context.graph, this.props.id);\n    this.setState({ ...(this.connectedState.$state.value as TBaseConnectionState), hovered: false });\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing ConnectionLayer in TypeScript\nDESCRIPTION: Demonstrates how to add a ConnectionLayer to a graph, including configuration of icons and line drawing function.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst graph = useGraph();\n\ngraph.addLayer(ConnectionLayer, {\n  createIcon: {\n    path: \"M7 0.75C7.41421...\",\n    width: 14,\n    height: 14,\n    viewWidth: 14,\n    viewHeight: 14,\n    fill: \"#someColor\", // optional\n    stroke: \"#someColor\" // optional\n  },\n  point: {\n    path: \"M15.53 1.53A...\",\n    width: 14,\n    height: 14,\n    viewWidth: 16,\n    viewHeight: 16,\n    fill: \"#someColor\", // optional\n    stroke: \"#someColor\" // optional\n  },\n  drawLine: (start, end) => {\n    const path = new Path2D();\n    path.moveTo(start.x, start.y);\n    path.lineTo(end.x, end.y);\n    return {\n      path,\n      style: { color: \"blue\", dash: [5, 5] }\n    };\n  },\n  // ... other props\n})\n```\n\n----------------------------------------\n\nTITLE: Handling connection-create-hover Event in TypeScript\nDESCRIPTION: Demonstrates how to prevent connection to a specific target when hovering during connection creation.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/src/components/canvas/layers/connectionLayer/ConnectionLayer.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ngraph.on(\"connection-create-hover\", (event) => {\n  // Prevent connection to this target\n  event.preventDefault();\n})\n```\n\n----------------------------------------\n\nTITLE: Connection Hit Detection Implementation\nDESCRIPTION: Implementation of hit detection logic for connections including line and label detection.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isPointInStroke } from \"@/utils/functions/isPointInStroke\";\n\npublic onHitBox(shape: HitBoxData): boolean {\n  const THRESHOLD_LINE_HIT = this.context.constants.connection.THRESHOLD_LINE_HIT;\n\n  if (isPointInStroke(this.context.ctx, this.path2d, shape.x, shape.y, THRESHOLD_LINE_HIT * 2)) {\n    return true;\n  }\n\n  // Or if pointer over label\n  if (this.labelGeometry !== undefined) {\n    // ... label hit detection ...\n  }\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Built-in CSS Classes with Layers\nDESCRIPTION: Examples of using the built-in CSS classes like no-pointer-events and no-user-select with layer configuration to control interaction behavior.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncanvas: {\n  zIndex: 4,\n  classNames: [\"no-pointer-events\"]\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nhtml: {\n  zIndex: 5,\n  classNames: [\"no-user-select\"]\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nhtml: {\n  zIndex: 3,\n  classNames: [\"my-custom-layer\", \"no-pointer-events\", \"no-user-select\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Connection Points Update Logic\nDESCRIPTION: Method for updating connection points based on source and target block positions.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nprotected updatePoints() {\n  if (!this.sourceBlock || !this.targetBlock) return;\n\n  this.connectionPoints = [\n    this.sourceBlock.getConnectionPoint(\"out\"), \n    this.targetBlock.getConnectionPoint(\"in\")\n  ];\n  \n  // ... further processing ...\n\n  this.updateHitBox();\n}\n```\n\n----------------------------------------\n\nTITLE: Hit Box Update Implementation\nDESCRIPTION: Method for updating the connection's hit box dimensions based on connection geometry.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nprivate updateHitBox = () => {\n  const [x1, y1, x2, y2] = this.getBBox();\n  const threshold = this.context.constants.connection.THRESHOLD_LINE_HIT;\n  this.setHitBox(\n    Math.min(x1, x2) - threshold,\n    Math.min(y1, y2) - threshold,\n    Math.max(x1, x2) + threshold,\n    Math.max(y1, y2) + threshold\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Flow Diagram Nodes with GraphComponents\nDESCRIPTION: A ProcessNode component that visualizes data processing steps with statistics and indicators. The component would render processing status, throughput metrics, error indicators, and resource utilization information.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/canvas-graph-component.md#2025-04-17_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nclass ProcessNode extends GraphComponent {\n  render() {\n    // Render node with inner components showing:\n    // - Processing status\n    // - Data throughput metrics\n    // - Error indicators\n    // - Resource utilization\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Graph Events for NewBlockLayer in TypeScript\nDESCRIPTION: Interface definition for events related to block creation in the NewBlockLayer, including block-add-start-from-shadow and block-added-from-shadow events.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/rendering/layers.md#2025-04-17_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Key events\ninterface GraphEventsDefinitions {\n  \"block-add-start-from-shadow\": (event: CustomEvent<{ block: Block }>) => void;\n  \"block-added-from-shadow\": (event: CustomEvent<{ block: Block; coord: {x: number, y: number} }>) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Browser Environment Differences for Animation Frames\nDESCRIPTION: Shows how the scheduler system adapts to different environments by providing alternative implementations for requestAnimationFrame and performance timing functions in non-browser environments.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/scheduler-system.md#2025-04-17_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// For browser environments\nconst rAF = window.requestAnimationFrame;\nconst cAF = window.cancelAnimationFrame;\nconst getNow = window.performance.now.bind(window.performance);\n\n// For non-browser environments\nconst rAF = (fn) => global.setTimeout(fn, 16);\nconst cAF = global.clearTimeout;\nconst getNow = global.Date.now.bind(global.Date);\n```\n\n----------------------------------------\n\nTITLE: Block Event Flow Sequence Diagram in Mermaid\nDESCRIPTION: Sequence diagram showing the interaction flow for drag events between User, Block, BlockController, and Store.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/components/block-component.md#2025-04-17_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant User\n    participant Block\n    participant BlockController\n    participant Store\n    \n    User->>Block: Mouse Down\n    Block->>BlockController: onDragStart()\n    BlockController->>Block: Emit \"block-drag-start\"\n    User->>Block: Mouse Move\n    Block->>BlockController: onDragUpdate()\n    BlockController->>Block: Calculate next position\n    Block->>Block: applyNextPosition()\n    Block->>Store: Update position\n    Block->>Block: Emit \"block-drag\"\n    User->>Block: Mouse Up\n    Block->>BlockController: onDragEnd()\n    BlockController->>Block: Emit \"block-drag-end\"\n```\n\n----------------------------------------\n\nTITLE: Integrated Update Flow Sequence Diagram\nDESCRIPTION: A mermaid sequence diagram showing the step-by-step interaction between Browser, Scheduler, Component, and Rendering during a typical update cycle, illustrating the complete flow from animation frame request to rendering.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Browser\n    participant Scheduler\n    participant Component\n    participant Rendering\n    \n    Browser->>Scheduler: requestAnimationFrame\n    Scheduler->>Scheduler: tick()\n    Scheduler->>Component: iterate()\n    Component->>Component: checkData()\n    Component->>Component: willIterate()\n    \n    alt shouldRender is true\n        Component->>Component: willRender()\n        Component->>Rendering: render()\n        Component->>Component: didRender()\n    else shouldRender is false\n        Component->>Component: willNotRender()\n    end\n    \n    alt shouldUpdateChildren is true\n        Component->>Component: willUpdateChildren()\n        Component->>Component: updateChildren()\n        Component->>Component: didUpdateChildren()\n    end\n    \n    Component->>Component: didIterate()\n    Scheduler->>Browser: Next animation frame\n```\n\n----------------------------------------\n\nTITLE: Visualizing Component Iteration Process with Mermaid\nDESCRIPTION: A flowchart showing the sequence of lifecycle method calls during component iteration.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-lifecycle.md#2025-04-17_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n    A[checkData] --> B[willIterate]\n    B --> C{shouldRender?}\n    C -->|Yes| D[willRender]\n    D --> E[render]\n    E --> F[didRender]\n    C -->|No| G[willNotRender]\n    G --> H{shouldUpdateChildren?}\n    F --> H\n    H -->|Yes| I[willUpdateChildren]\n    I --> J[updateChildren]\n    J --> K[didUpdateChildren]\n    H -->|No| L[didIterate]\n    K --> L\n```\n\n----------------------------------------\n\nTITLE: Visualizing Architectural Overview with Mermaid Diagram\nDESCRIPTION: A mermaid diagram illustrating the relationship between the three subsystems: Scheduler System, Component Lifecycle, and Rendering Mechanism, showing how they interact in the rendering pipeline.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/system/component-rendering-lifecycle.md#2025-04-17_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph TD\n    A[Scheduler System] -->|Triggers Updates| B[Component Lifecycle]\n    B -->|Renders Visual Elements| C[Rendering Mechanism]\n    C -->|Schedules Next Frame| A\n```\n\n----------------------------------------\n\nTITLE: Installing @gravity-ui/graph Package\nDESCRIPTION: Command to install the @gravity-ui/graph package using npm package manager.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/README.md#2025-04-17_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @gravity-ui/graph\n```\n\n----------------------------------------\n\nTITLE: Sorting Render Order in BatchPath2D\nDESCRIPTION: Shows how BatchPath2D handles the sorting of rendering elements by z-index to ensure proper layering of visual elements.\nSOURCE: https://github.com/gravity-ui/graph/blob/main/docs/connections/canvas-connection-system.md#2025-04-17_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\n// In BatchPath2D\nprivate sortRenderOrder() {\n  this.renderOrder = [...this.batches.keys()].sort((a, b) => {\n    const aSettings = this.batchSettings.get(a);\n    const bSettings = this.batchSettings.get(b);\n    return (aSettings?.zIndex || 0) - (bSettings?.zIndex || 0);\n  });\n}\n```"
  }
]