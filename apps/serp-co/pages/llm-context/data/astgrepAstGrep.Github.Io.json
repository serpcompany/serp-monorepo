[
  {
    "owner": "ast-grep",
    "repo": "ast-grep.github.io",
    "content": "TITLE: Minimal ast-grep Rule\nDESCRIPTION: This YAML snippet demonstrates a minimal ast-grep rule. The rule, identified by `no-await-in-promise-all`, searches for `Promise.all` expressions in TypeScript code that contain an `await` expression within them. It illustrates the basic structure of an ast-grep rule with `id`, `language`, and `rule` fields.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n\"id: no-await-in-promise-all\nlanguage: TypeScript\nrule:\n  pattern: Promise.all($A)\n  has:\n    pattern: await $_\n    stopBy: end\"\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of ast-grep JavaScript API\nDESCRIPTION: Demonstrates the core workflow of using ast-grep's JavaScript API, including parsing source code, getting the root node, finding a specific node, and extracting information.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { parse, Lang } from '@ast-grep/napi';\n\nlet source = `console.log(\"hello world\")`\nconst ast = parse(Lang.JavaScript, source)  // 1. parse the source\nconst root = ast.root()                     // 2. get the root\nconst node = root.find('console.log($A)')   // 3. find the node\nnode.getMatch('A').text()                   // 4. collect the info\n// \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Multi Meta Variable Matching (Function Arguments)\nDESCRIPTION: This snippet shows how `console.log($$$)` can match zero or more arguments passed to `console.log`. It demonstrates matching different numbers of arguments, including spread syntax.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.log()                       // matches zero AST node\nconsole.log('hello world')          // matches one node\nconsole.log('debug: ', key, value)  // matches multiple nodes\nconsole.log(...args)                // it also matches spread\n```\n\n----------------------------------------\n\nTITLE: Full Rule Object YAML\nDESCRIPTION: This YAML snippet showcases the full range of fields available in an ast-grep rule object, including atomic, relational, and composite rules. Each field represents a different matching condition. The rules combines sub-rules together using logical operators.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n\"rule:\n  # atomic rule\n  pattern: 'search.pattern'\n  kind: 'tree_sitter_node_kind'\n  regex: 'rust|regex'\n  # relational rule\n  inside: { pattern: 'sub.rule' }\n  has: { kind: 'sub_rule' }\n  follows: { regex: 'can|use|any' }\n  precedes: { kind: 'multi_keys', pattern: 'in.sub' }\n  # composite rule\n  all: [ {pattern: 'match.all'}, {kind: 'match_all'} ]\n  any: [ {pattern: 'match.any'}, {kind: 'match_any'} ]\n  not: { pattern: 'not.this' }\n  matches: 'utility-rule'\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Rule for AST Matching in YAML\nDESCRIPTION: This snippet demonstrates how to define a pattern rule that matches the 'console.log' function call within an AST structure. It illustrates the basic pattern matching syntax, which can be a simple string or an object specifying context and selector.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\npattern: console.log($ARG)\n```\n\n----------------------------------------\n\nTITLE: SgNode Class Definition in TypeScript\nDESCRIPTION: This code snippet defines the `SgNode` class in TypeScript, which is the main interface to traverse the AST. It includes methods for reading node information, checking if a node meets certain patterns, getting matched meta variables, traversing the node tree, and editing nodes. It provides a comprehensive set of functionalities for analyzing and manipulating the AST.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nclass SgNode {\n  // Read node's information\n  range(): Range\n  isLeaf(): boolean\n  isNamed(): boolean\n  isNamedLeaf(): boolean\n  kind(): string\n  // check if node has kind\n  is(kind: string): boolean\n  // for TypeScript type narrow\n  kindToRefine: string\n  text(): string\n  // Check if node meets certain patterns\n  matches(m: string): boolean\n  inside(m: string): boolean\n  has(m: string): boolean\n  precedes(m: string): boolean\n  follows(m: string): boolean\n  // Get nodes' matched meta variables\n  getMatch(m: string): SgNode | null\n  getMultipleMatches(m: string): Array<SgNode>\n  // Get node's SgRoot\n  getRoot(): SgRoot\n  // Traverse node tree\n  children(): Array<SgNode>\n  find(matcher: string | number | NapiConfig): SgNode | null\n  findAll(matcher: string | number | NapiConfig): Array<SgNode>\n  field(name: string): SgNode | null\n  parent(): SgNode | null\n  child(nth: number): SgNode | null\n  ancestors(): Array<SgNode>\n  next(): SgNode | null\n  nextAll(): Array<SgNode>\n  prev(): SgNode | null\n  prevAll(): Array<SgNode>\n  // Edit\n  replace(text: string): Edit\n  commitEdits(edits: Edit[]): string\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via Cargo\nDESCRIPTION: Command to install ast-grep using Rust's Cargo package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# install via cargo\ncargo install ast-grep --locked\n```\n\n----------------------------------------\n\nTITLE: Rule TypedDict Definition in Python\nDESCRIPTION: This code snippet defines the `Rule` TypedDict in Python, representing a rule configuration. It includes fields for atomic rules (pattern, kind, regex), relational rules (inside, has, precedes, follows), and composite rules (all, any, not, matches). The snippet also shows a `Pattern` TypedDict used within the `Rule` TypedDict.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass Pattern(TypedDict):\n    selector: str\n    context: str\n\nclass Rule(TypedDict, total=False):\n    # atomic rule\n    pattern: str | Pattern\n    kind: str\n    regex: str\n\n    # relational rule\n    inside: Relation\n    has: Relation\n    precedes: Relation\n    follows: Relation\n\n    # composite rule\n    all: List[Rule]\n    any: List[Rule]\n    # pseudo code below for demo.\n    \"not\": Rule # Python does not allow \"not\" keyword as attribute\n    matches: str\n```\n```\n\n----------------------------------------\n\nTITLE: Multi Meta Variable Matching (Function Parameters)\nDESCRIPTION: This example shows how to use `function $FUNC($$$ARGS) { $$$ }` to match function definitions with different numbers of parameters. It demonstrates capturing various parameter lists.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nfunction foo(bar) {\n  return bar\n}\n\nfunction noop() {}\n\nfunction add(a, b, c) {\n  return a + b + c\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Search or Rewrite with ast-grep\nDESCRIPTION: This shell command allows you to perform a one-time search or code rewrite using ast-grep. You need to specify a pattern with the `--pattern` option. It's possible to specify paths to search, with a default of the current directory. Other options allow customization of the search, such as setting the language, controlling output formatting, and deciding the level of strictness. Dependencies include having ast-grep installed and configured. The command outputs the search results, and optionally, modifies the code directly if a rewrite pattern is provided.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep run [OPTIONS] --pattern <PATTERN> [PATHS]...\n```\n\n----------------------------------------\n\nTITLE: Defining and Testing ast-grep Rules\nDESCRIPTION: This YAML snippet demonstrates how to define multiple rules in ast-grep. Users can specify patterns and rewrite expressions in separate rules within the matcher editor. Each rule is separated by '---' and can include both pattern matching and replacement logic, allowing for comprehensive testing and simulation of pattern matching behavior.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/playground.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($A)\nfix:\n  logger.log($A)\n---\nrule:\n  pattern: function $A() { $$$BODY }\nfix: 'const $A = () => { $$$BODY }'\n```\n\n----------------------------------------\n\nTITLE: Parsing and Searching Python Code with ast-grep\nDESCRIPTION: Example of parsing a Python string, getting the root node, finding a specific pattern, and extracting information.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom ast_grep_py import SgRoot\n\nroot = SgRoot(\"print('hello world')\", \"python\") # 1. parse\nnode = root.root()                              # 2. get root\nprint_stmt = node.find(pattern=\"print($A)\")     # 3. find\nprint_stmt.get_match('A').text()                # 4. collect information\n# 'hello world'\n```\n\n----------------------------------------\n\nTITLE: Meta Variable Capturing\nDESCRIPTION: The pattern `$A == $A` demonstrates meta variable capturing, where the same meta variable name must match identical AST nodes on both sides of the `==` operator. It shows examples that match and those that do not.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// will match these patterns\na == a\n1 + 1 == 1 + 1\n// but will not match these\na == b\n1 + 1 == 2\n```\n\n----------------------------------------\n\nTITLE: NapiConfig Interface Definition in TypeScript\nDESCRIPTION: This code snippet defines the `NapiConfig` interface in TypeScript, which is used in `find` or `findAll` methods. It includes fields for defining rules, constraints, language, transform, and utils. The `NapiConfig` has similar fields as the rule config.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface NapiConfig {\n  rule: object\n  constraints?: object\n  language?: FrontEndLanguage\n  // @experimental\n  transform?: object\n  utils?: object\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Different Matcher Types in ast-grep\nDESCRIPTION: Shows various ways to use the find and findAll methods with different matcher types: string patterns, kind numbers, and NapiConfig objects.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// basic find example\nroot.find('console.log($A)')    // returns SgNode of call_expression\nlet l = Lang.JavaScript         // calling kind function requires Lang\nconst kind = kind(l, 'string')  // convert kind name to kind id number\nroot.find(kind)                 // returns SgNode of string\nroot.find('notExist')           // returns null if not found\n\n// basic find all example\nconst nodes = root.findAll('function $A($$$) {$$$}')\nArray.isArray(nodes)     // true, findAll returns SgNode\nnodes.map(n => n.text()) // string array of function source\nconst empty = root.findAll('not exist') // returns []\nempty.length === 0 // true\n\n// find i.e. `console.log(\"hello world\")` using a NapiConfig\nconst node = root.find({\n  rule: {\n    pattern: \"console.log($A)\"\n  },\n  constraints: {\n    A: { regex: \"hello\" }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Main Functions for NAPI in TypeScript\nDESCRIPTION: This code snippet shows the type definitions for the main functions `parse`, `kind`, and `pattern` provided by `@ast-grep/napi`. These functions are used to parse a string into an `SgRoot` object, get the `kind` number from its string name, and compile a string to an ast-grep Pattern, respectively.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/** Parse a string to an ast-grep instance */\nexport function parse(lang: Lang, src: string): SgRoot\n/** Get the `kind` number from its string name. */\nexport function kind(lang: Lang, kindName: string): number\n/** Compile a string to ast-grep Pattern. */\nexport function pattern(lang: Lang, pattern: string): NapiConfig\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing AST-Grep Command for Code Rewriting using Shell Script\nDESCRIPTION: This snippet demonstrates how to run an ast-grep command to transform JavaScript code by replacing 'var' declarations with 'let'. It shows the basic usage with input and output details pertaining to the command-line syntax.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/introduction.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nast-grep --pattern 'var code = $PAT' --rewrite 'let code = $PAT' --lang js\n```\n\n----------------------------------------\n\nTITLE: Specifying Language for ast-grep Rules in YAML\nDESCRIPTION: This snippet illustrates how to specify the programming language that the rule will parse in YAML format. The 'language' field is required and should match one of the valid values listed in the documentation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nlanguage: JavaScript\n```\n\n----------------------------------------\n\nTITLE: Matching Code with Pattern\nDESCRIPTION: The snippet demonstrates how a simple pattern `a + 1` can match various JavaScript code snippets that contain the expression. It showcases the capability of AST-grep to match nested expressions within the syntax tree.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst b = a + 1\n\nfuncCall(a + 1)\n\ndeeplyNested({\n  target: a + 1\n})\n```\n\n----------------------------------------\n\nTITLE: Modifying Python Code with ast-grep\nDESCRIPTION: Example of using the replace and commit_edits methods to modify Python code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nroot = SgRoot(\"print('hello world')\", \"python\").root()\nnode = root.find(pattern=\"print($A)\")\nedit = node.replace(\"logger.log('bye world')\")\nnew_src = node.commit_edits([edit])\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Rule in YAML for ast-grep\nDESCRIPTION: Demonstrates how to define a simple pattern rule in ast-grep using YAML. This rule matches console.log statements with a variable greeting.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($GREETING)\n```\n\n----------------------------------------\n\nTITLE: TypeScript Match Object Definition\nDESCRIPTION: This TypeScript code defines the interface for the match object returned by ast-grep when using the `--json` flag. It includes properties like text, range, file, lines, replacement, replacementOffsets, and metaVariables. These interfaces represent the structure of the JSON output and can be used for type checking and data manipulation in TypeScript projects.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n\"interface Match {\\n  text: string\\n  range: Range\\n  file: string // relative path to the file\\n  // the surrounding lines of the match.\\n  // It can be more than one line if the match spans multiple ones.\\n  lines: string\\n  // optional replacement if the match has a replacement\\n  replacement?: string\\n  replacementOffsets?: ByteOffset\\n  metaVariables?: MetaVariables // optional metavars generated in the match\\n}\\n\\ninterface Range {\\n  byteOffset: ByteOffset\\n  start: Position\\n  end: Position\\n}\\n// UTF-8 encoded byte offset\\ninterface ByteOffset {\\n  start: number // start is inclusive\\n  end: number   // end is exclusive\\n}\\ninterface Position {\\n  line: number   // zero-based line number\\n  column: number // zero-based column number\\n}\\n\\n// See Pattern doc\\ninterface MetaVariables {\\n  single: Record<String, MetaVar>\\n  multi: Record<String, MetaVar[]>\\n  transformed: Record<String, String> // See Rewrite doc\\n}\\ninterface MetaVar {\\n  text: string\\n  range: Range\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Files and Ignores in a Lint Rule in YAML\nDESCRIPTION: This YAML snippet details how to apply lint rules selectively to specific files or ignore certain files using glob patterns. This approach allows for finer control over which parts of the codebase are affected by the lint rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/lint-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nfiles:\n- \"tests/**\"\n- \"integration_tests/test.py\"\n\nignores:\n- \"tests/config/**\"\n```\n\n----------------------------------------\n\nTITLE: Defining Language Enum for NAPI in TypeScript\nDESCRIPTION: This code snippet defines an enum `Lang` in TypeScript representing supported languages by `@ast-grep/napi`. It also shows how to define a custom language type, although it is not widely used and users are encouraged to file an issue if they need support.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nexport const enum Lang {\n  Html = 'Html',\n  JavaScript = 'JavaScript',\n  Tsx = 'Tsx',\n  Css = 'Css',\n  TypeScript = 'TypeScript',\n}\n\n// More custom languages can be loaded\n// see https://github.com/ast-grep/langs\ntype CustomLang = string & {}\n```\n```\n\n----------------------------------------\n\nTITLE: Setting Fix Patterns in ast-grep YAML\nDESCRIPTION: This snippet outlines how to define a 'fix' pattern that ast-grep will use to automatically resolve detected issues. This can also include a pattern to remove matches if necessary.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\nfix: logger.log($$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Applying String Fix in ast-grep (YAML)\nDESCRIPTION: A String Fix is a straightforward replacement tool in ast-grep where the matched AST node is replaced with a specified string, potentially containing meta variables. It does not parse the string through tree-sitter, allowing the meta variables to appear flexibly. This example shows how to replace console.log with logger.log using a pattern match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/fix.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($$$ARGS)\nfix: logger.log($$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Testing Rule with Valid and Invalid Cases - YAML\nDESCRIPTION: Defines valid and invalid code scenarios to test the rule's effectiveness in the ast-grep tool. The valid cases should not trigger any warnings, whereas the invalid cases should.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/test-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-await-in-loop\nvalid:\n  - for (let a of b) { console.log(a) }\n  # .... more valid test cases\ninvalid:\n  - async function foo() { for (var bar of baz) await bar; }\n  # .... more invalid test cases\n```\n\n----------------------------------------\n\nTITLE: Meta Variable Matching\nDESCRIPTION: This snippet illustrates how to use meta variables, denoted by a `$` sign, to match dynamic content in JavaScript code. The pattern `console.log($GREETING)` will match any `console.log` statement with a single argument.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction tryAstGrep() {\n  console.log('Hello World')\n}\n\nconst multiLineExpression =\n  console\n   .log('Also matched!')\n```\n\n----------------------------------------\n\nTITLE: JavaScript pattern for method lookup\nDESCRIPTION: Example of a JavaScript pattern used to match code that checks for a method's existence before calling it.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nobj.val && obj.val()\n```\n\n----------------------------------------\n\nTITLE: TypeScript RuleMatch Object Definition\nDESCRIPTION: This TypeScript code defines the interface for the `RuleMatch` object, extending the base `Match` object with additional properties specific to lint rules. It includes fields such as `ruleId`, `severity`, `note`, and `message`. The `Severity` enum defines the possible severity levels for a rule match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n\"interface RuleMatch extends Match {\\n  ruleId: string\\n  severity: Severity\\n  note?: string\\n  message: string\\n}\\n\\nenum Severity {\\n  Error = \\\"error\\\",\\n  Warning = \\\"warning\\\",\\n  Info = \\\"info\\\",\\n  Hint = \\\"hint\\\",\\n}\"\n```\n\n----------------------------------------\n\nTITLE: Refactoring TypeScript with ast-grep\nDESCRIPTION: Command to refactor TypeScript code using ast-grep, replacing the old pattern with optional chaining operator in an interactive mode.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n# pattern and language argument support short form\nast-grep -p '$PROP && $PROP()' \\\n   --rewrite '$PROP?.()' \\\n   --interactive \\\n   -l ts \\\n   TypeScript/src\n```\n\n----------------------------------------\n\nTITLE: Example Usage of parse and Lang with SgRoot in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the `parse` function and `Lang` enum from `@ast-grep/napi` and use them to parse JavaScript source code into an `SgRoot` object.  It then shows how to find nodes matching a given pattern using `root.find()`.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { parse, Lang } from '@ast-grep/napi'\n\nconst ast = parse(Lang.JavaScript, source)\nconst root = ast.root()\nroot.find(\"console.log\")\n```\n```\n\n----------------------------------------\n\nTITLE: Running ast-grep with full command\nDESCRIPTION: Full command to run ast-grep with a specified pattern and language on the TypeScript source directory.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nast-grep --pattern '$PROP && $PROP()' --lang ts TypeScript/src\n```\n\n----------------------------------------\n\nTITLE: Defining a Lint Rule for 'no-await-in-loop' in YAML\nDESCRIPTION: This YAML snippet defines a lint rule that triggers a warning when 'await' is used inside a for-in or while loop, which can hinder performance by preventing parallel execution of promises. The rule specifies the structure necessary to create a linting rule within the ast-grep framework, including the error message and severity level.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/lint-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-await-in-loop\nlanguage: TypeScript\nrule:\n  pattern: await $_\n  inside:\n    any:\n    - kind: for_in_statement\n    - kind: while_statement\n\n# Other linting related fields\nmessage: Don't use await inside of loops\nseverity: warning\nnote: |\n  Performing an await as part of each operation is an indication that\n  the program is not taking full advantage of the parallelization benefits of async/await.\n```\n\n----------------------------------------\n\nTITLE: Rewrite Identifier Nodes to Individual Imports\nDESCRIPTION: This YAML rewriter rule captures identifier nodes and rewrites them to individual import statements. It modifies each identifier import path to be specific to each imported entity.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  fix: import $IDENT from './module/$IDENT'\n```\n\n----------------------------------------\n\nTITLE: Scanning and Rewriting Code with ast-grep\nDESCRIPTION: This shell command scans and optionally rewrites the code according to configuration files. It requires paths to search and allows the use of a configuration file to define rules. Optional parameters include setting color output, JSON structured output, and rule filtering via regular expressions. The primary input is the configuration file or inline rules, and output can include diagnostic information and rewritten code, depending on the specified options.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nast-grep scan [OPTIONS] [PATHS]...\n```\n\n----------------------------------------\n\nTITLE: Define and Test Rules using YAML - TypeScript\nDESCRIPTION: This YAML code defines a rule in ast-grep to warn against using 'await' inside loops in TypeScript. It specifies code patterns to look for inside certain loop statements, aligning with the rule testing framework.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/test-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-await-in-loop\nmessage: Don't use await inside of loops\nseverity: warning\nlanguage: TypeScript\nrule:\n  all:\n    - inside:\n        any:\n          - kind: for_in_statement\n          - kind: while_statement\n        stopBy:\n          end\n    - pattern: await $_\n```\n\n----------------------------------------\n\nTITLE: Matching 'hello' after 'world' with YAML in ast-grep\nDESCRIPTION: Demonstrates using the 'follows' relational rule to match a 'hello' console log that comes after a 'world' console log.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\npattern: console.log('hello');\nfollows:\n  pattern: console.log('world');\n```\n\n----------------------------------------\n\nTITLE: Configuring AST-grep for TypeScript Import Detection\nDESCRIPTION: YAML configuration for AST-grep to detect various import patterns in TypeScript. Includes rules for alias imports, default imports, regular imports, and dynamic imports with different syntaxes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n# find-all-imports-and-requires.yaml\nid: find-all-imports-and-requires\nlanguage: TypeScript\nmessage: Found module import or require.\nseverity: info\nrule:\n  any:\n    # ALIAS IMPORTS\n    # --------------------------------------------------------------\n    # import { ORIGINAL as ALIAS } from 'SOURCE'\n    # --------------------------------------------------------------\n    - all:\n        # 1. Target the specific node type for named imports\n        - kind: import_specifier\n        # 2. Ensure it *has* an 'alias' field, capturing the alias identifier\n        - has:\n            field: alias\n            pattern: $ALIAS\n        # 3. Capture the original identifier (which has the 'name' field)\n        - has:\n            field: name\n            pattern: $ORIGINAL\n        # 4. Find an ANCESTOR import_statement and capture its source path\n        - inside:\n            stopBy: end # <<<--- This is the key fix! Search ancestors.\n            kind: import_statement\n            has: # Ensure the found import_statement has the source field\n              field: source\n              pattern: $SOURCE\n\n    # DEFAULT IMPORTS\n    # --------------------------------------------------------------\n    # import { ORIGINAL } from 'SOURCE'\n    # --------------------------------------------------------------\n    - all:\n        - kind: import_statement\n        - has:\n            # Ensure it has an import_clause...\n            kind: import_clause\n            has:\n              # ...that directly contains an identifier (the default import name)\n              # This identifier is NOT under a 'named_imports' or 'namespace_import' node\n              kind: identifier\n              pattern: $DEFAULT_NAME\n        - has:\n            field: source\n            pattern: $SOURCE\n    \n    # REGULAR IMPORTS\n    # --------------------------------------------------------------\n    # import { ORIGINAL } from 'SOURCE'\n    # --------------------------------------------------------------\n    - all:\n        # 1. Target the specific node type for named imports\n        - kind: import_specifier\n        # 2. Ensure it *has* an 'alias' field, capturing the alias identifier\n        - has:\n            field: name\n            pattern: $ORIGINAL\n        # 4. Find an ANCESTOR import_statement and capture its source path\n        - inside:\n            stopBy: end # <<<--- This is the key fix! Search ancestors.\n            kind: import_statement\n            has: # Ensure the found import_statement has the source field\n              field: source\n              pattern: $SOURCE\n\n    # DYNAMIC IMPORTS (Single Variable Assignment) \n    # --------------------------------------------------------------\n    # eg: (const VAR_NAME = require('SOURCE'))\n    # --------------------------------------------------------------\n    - all:\n        - kind: variable_declarator\n        - has:\n            field: name\n            kind: identifier\n            pattern: $VAR_NAME # Capture the single variable name\n        - has:\n            field: value\n            any:\n              # Direct call\n              - all: # Wrap conditions in all\n                  - kind: call_expression\n                  - has: { field: function, regex: '^(require|import)$' }\n                  - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              # Awaited call\n              - kind: await_expression\n                has:\n                  all: # Wrap conditions in all\n                    - kind: call_expression\n                    - has: { field: function, regex: '^(require|import)$' }\n                    - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n\n    # DYNAMIC IMPORTS (Destructured Shorthand Assignment)     \n    # --------------------------------------------------------------\n    # eg: (const { ORIGINAL } = require('SOURCE'))\n    # --------------------------------------------------------------\n    - all:\n        # 1. Target the shorthand identifier within the pattern\n        - kind: shorthand_property_identifier_pattern\n        - pattern: $ORIGINAL\n        # 2. Ensure it's inside an object_pattern that is the name of a variable_declarator\n        - inside:\n            kind: object_pattern\n            inside: # Check the variable_declarator it belongs to\n              kind: variable_declarator\n              # 3. Check the value assigned by the variable_declarator\n              has:\n                field: value\n                any:\n                  # Direct call\n                  - all:\n                      - kind: call_expression\n                      - has: { field: function, regex: '^(require|import)$' }\n                      - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n                  # Awaited call\n                  - kind: await_expression\n                    has:\n                      all:\n                        - kind: call_expression\n                        - has: { field: function, regex: '^(require|import)$' }\n                        - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              stopBy: end # Search ancestors to find the correct variable_declarator\n\n    # DYNAMIC IMPORTS (Destructured Alias Assignment) \n    # --------------------------------------------------------------\n    # eg: (const { ORIGINAL: ALIAS } = require('SOURCE'))\n    # --------------------------------------------------------------\n    - all:\n        # 1. Target the pair_pattern for aliased destructuring\n        - kind: pair_pattern\n        # 2. Capture the original identifier (key)\n        - has:\n            field: key\n            kind: property_identifier # Could be string/number literal too, but property_identifier is common\n            pattern: $ORIGINAL\n        # 3. Capture the alias identifier (value)\n        - has:\n            field: value\n            kind: identifier\n            pattern: $ALIAS\n        # 4. Ensure it's inside an object_pattern that is the name of a variable_declarator\n        - inside:\n            kind: object_pattern\n            inside: # Check the variable_declarator it belongs to\n              kind: variable_declarator\n              # 5. Check the value assigned by the variable_declarator\n              has:\n                field: value\n                any:\n                  # Direct call\n                  - all:\n                      - kind: call_expression\n                      - has: { field: function, regex: '^(require|import)$' }\n                      - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n                  # Awaited call\n                  - kind: await_expression\n                    has:\n                      all:\n                        - kind: call_expression\n                        - has: { field: function, regex: '^(require|import)$' }\n                        - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              stopBy: end # Search ancestors to find the correct variable_declarator\n            stopBy: end # Ensure we check ancestors for the v\n```\n\n----------------------------------------\n\nTITLE: Lambda to Def Conversion YAML Rule in Python\nDESCRIPTION: Defines a YAML rule to convert lambda functions to standard def functions in Python, preserving indentation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nid: lambda-to-def\nlanguage: Python\nrule:\n  pattern: '$B = lambda: $R'\nfix: |-\n  def $B():\n    return $R\n```\n\n----------------------------------------\n\nTITLE: SgRoot Class Definition in Python\nDESCRIPTION: This code snippet defines the `SgRoot` class in Python, which serves as the entry point object for ast-grep. It includes methods for initializing the class with source code and language, and for accessing the root `SgNode` of the syntax tree.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass SgRoot:\n    def __init__(self, src: str, language: str) -> None: ...\n    def root(self) -> SgNode: ...\n```\n```\n\n----------------------------------------\n\nTITLE: Defining no-await-in-promise-all rule in YAML\nDESCRIPTION: YAML configuration for a rule that detects await usage inside Promise.all arrays. It specifies the pattern to match, the context to look for, and the fix to apply.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-await-in-promise-all.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-await-in-promise-all\nlanguage: typescript\nrule:\n  pattern: await $A\n  inside:\n    pattern: Promise.all($_)\n    stopBy:\n      not: { any: [{kind: array}, {kind: arguments}] }\nfix: $A\n```\n\n----------------------------------------\n\nTITLE: OpenAI Migration Rules in YAML\nDESCRIPTION: YAML configuration containing three rules for migrating OpenAI SDK code: updating imports, client initialization, and completion API calls.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/migrate-openai-sdk.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: import-openai\nlanguage: python\nrule:\n  pattern: import openai\nfix: from openai import Client\n---\nid: rewrite-client\nlanguage: python\nrule:\n  pattern: openai.api_key = $KEY\nfix: client = Client($KEY)\n---\nid: rewrite-chat-completion\nlanguage: python\nrule:\n  pattern: openai.Completion.create($$$ARGS)\nfix: |-\n  client.completions.create(\n    $$$ARGS\n  )\n```\n\n----------------------------------------\n\nTITLE: Creating the Folder Structure for ast-grep\nDESCRIPTION: This snippet shows the expected directory structure after running the setup command for an ast-grep project. It details the locations of rules, tests, utilities, and configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nmy-awesome-project\n  |- rules           # where rules go\n  |- rule-tests       # test cases for rules\n  |- utils           # global utility rules for reusing\n  |- sgconfig.yml    # root configuration file\n```\n```\n\n----------------------------------------\n\nTITLE: Using Transform in a Lint Rule in YAML\nDESCRIPTION: This YAML snippet illustrates the use of the 'transform' field within a lint rule for transforming matched AST nodes. It is particularly useful for modifying variable names or formats when a match is found, enabling automatic code rewriting.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/lint-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($GREET)\nfix: console.log('Hello ' + $GREET)\n```\n\n----------------------------------------\n\nTITLE: FindConfig Interface Definition in TypeScript\nDESCRIPTION: This code snippet defines the `FindConfig` interface in TypeScript, which is used in `findInFiles` method. It includes fields for specifying paths to search and the matcher to use. It allows to search multiple paths and recursively find all files under the paths.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface FindConfig {\n  // You can search multiple paths\n  // ast-grep will recursively find all files under the paths.\n  paths: Array<string>\n  // Specify what nodes will be matched\n  matcher: NapiConfig\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Composite Rule for Method Definition Matching in YAML\nDESCRIPTION: This YAML snippet defines a complex composite rule to find the usage of 'this.foo' specifically within a class getter method. It uses nested rules to specify the context and locations within the abstract syntax tree (AST) structure that need to be matched. Dependencies include understanding of AST node types such as 'method_definition' and 'class_body'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  all:\n    - pattern: this.foo                              # the root node\n    - inside:                                        # inside another node\n        all:\n          - pattern:\n              context: class A { get $_() { $$$ } }  # a class getter inside\n              selector: method_definition\n          - inside:                                  # class body\n              kind: class_body\n        stopBy:                                      # but not inside nested\n          any:\n            - kind: object                           # either object\n            - kind: class_body                       # or class\n```\n\n----------------------------------------\n\nTITLE: Complete YAML Rule for Dict to Literal Conversion\nDESCRIPTION: This YAML code presents a complete ast-grep rule for converting dict() function calls to dictionary literals. It includes the rewriter definition, pattern matching, transformation, and final fix.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# define rewriters\nrewriters:\n- id: dict-rewrite\n  rule:\n    kind: keyword_argument\n    all:\n    - has:\n        field: name\n        pattern: $KEY\n    - has:\n        field: value\n        pattern: $VAL\n  fix: \"'$KEY': $VAL\"\n# find the target node\nrule:\n  pattern: dict($$$ARGS)\n# apply rewriters to sub node\ntransform:\n  LITERAL:\n    rewrite:\n      rewriters: [dict-rewrite]\n      source: $$$ARGS\n# combine and replace\nfix: '{ $LITERAL }'\n```\n\n----------------------------------------\n\nTITLE: Searching Python AST with Config\nDESCRIPTION: Examples of using Config objects to search the AST with more complex rules and constraints.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# will find a string node with text 'hello world'\nroot.root().find({\n  \"rule\": {\n    \"pattern\": \"print($A)\",\n  },\n  \"constraints\": {\n    \"A\": { \"regex\": \"hello\" }\n  }\n})\n# will return None because constraints are not satisfied\nroot.root().find({\n  \"rule\": {\n    \"pattern\": \"print($A)\",\n  },\n  \"constraints\": {\n    \"A\": { \"regex\": \"no match\" }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Rules in ast-grep YAML Configuration\nDESCRIPTION: This YAML snippet demonstrates how to implement recursive rules in ast-grep. It defines an 'is-number' utility rule that can match number literals and parenthesized expressions containing numbers recursively.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nutils:\n  is-number:\n    any:\n      - kind: number\n      - kind: parenthesized_expression\n        has:\n          matches: is-number\nrule:\n  matches: is-number\n```\n\n----------------------------------------\n\nTITLE: Sequential Transformations for Complex Name Conversions\nDESCRIPTION: A multi-step transformation that converts function names from 'fooDebug' to 'fooRelease' using case conversions and replacements\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/transform.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrule: {pattern: $OLD_FN($$$ARGS)}\nconstraints: {OLD_FN: {regex: Debug$}}\ntransform:\n  KEBABED:\n    convert:\n      source: $OLD_FN\n      toCase: kebabCase\n  RELEASED:\n    replace:\n      source: $KEBABED\n      replace: (?<ROOT>)-debug\n      by: $ROOT-release\n  UNKEBABED:\n    convert:\n      source: $RELEASED\n      toCase: camelCase\nfix: $UNKEBABED($$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Implementing not Composite Rule in YAML\nDESCRIPTION: Demonstrates a composite rule that matches console.log calls while excluding a specific pattern\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($GREETING)\n  not:\n    pattern: console.log('Hello World')\n```\n\n----------------------------------------\n\nTITLE: ast-grep scan with Inline Rules\nDESCRIPTION: This bash command demonstrates how to run an ast-grep rule directly from the command line using the `--inline-rules` option. The YAML configuration is passed as a string argument. It is used for ad-hoc searches or when calling ast-grep from other programs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"ast-grep scan --inline-rules '\\nid: no-await-in-promise-all\nlanguage: TypeScript\nrule:\n  pattern: Promise.all($A)\n  has:\n    pattern: await $_\n    stopBy: end\n' test.ts\"\n```\n\n----------------------------------------\n\nTITLE: Complex relational rule with multiple loop types in YAML for ast-grep\nDESCRIPTION: Shows how to compose a more complex relational rule that matches await expressions inside various types of loops (for, for-in, while, do-while) using the 'any' operator.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: await $PROMISE\n  inside:\n    any:\n      - kind: for_in_statement\n      - kind: for_statement\n      - kind: while_statement\n      - kind: do_statement\n    stopBy: end\n```\n\n----------------------------------------\n\nTITLE: Implementing Runtime Type Checking for AST Nodes in TypeScript\nDESCRIPTION: Defines an 'is' method on the SgNode class for runtime type checking and type narrowing. This allows for safe type refinement when working with nodes of uncertain types.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nclass SgNode<M, K> {\n  is<T extends K>(kind: T): this is SgNode<M, T>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Projects or Items with ast-grep\nDESCRIPTION: This shell command initializes a new ast-grep project, rule, test, or utility. You need to specify the type of item to create and optionally its name. It supports further customization options like defining the language and base directory. This operation is dependent on scaffolding configurations and outputs a structured directory or files tailored to the command specified.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nast-grep new [COMMAND] [OPTIONS] [NAME]\n```\n\n----------------------------------------\n\nTITLE: Specifying Precedes Relational Rule\nDESCRIPTION: This YAML snippet illustrates a relational rule that matches a target node based on its position relative to another node. The example shows the required structure for the precedes rule including the stopBy property.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nprecedes:\n  kind: function_declaration   # a sub rule object\n  stopBy: end                  # stopBy accepts 'end', 'neighbor' or another rule object.\n```\n\n----------------------------------------\n\nTITLE: Finding Nodes in AST using Patterns\nDESCRIPTION: Demonstrates how to use the find method with a pattern string to locate specific nodes in the AST.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst log = root.find('console.log($A)') // search node\nconst arg = log.getMatch('A') // get matched variable\nlog.text() // \"hello world\"\n```\n\n----------------------------------------\n\nTITLE: Transform and Rewrite with Lowercase Conversion\nDESCRIPTION: Enhancing the rewriter rule to convert imported identifiers to lowercase using the `convert` function in the `transform` section, aiming to match import paths with lowercase letters.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  transform:\n    LIB: { convert: { source: $IDENT, toCase: lowerCase } }\n  fix: import $IDENT from './module/$LIB'\n```\n\n----------------------------------------\n\nTITLE: Defining Rewriters Field in YAML Rule\nDESCRIPTION: This snippet shows how to define the 'rewriters' field in the root of a YAML rule for ast-grep. It includes an example of a rewriter with an ID, rule, and fix.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: rewriter-demo\nlanguage: Python\nrewriters:\n- id: sub-rule\n  rule: # some rule\n  fix: # some fix\n```\n\n----------------------------------------\n\nTITLE: Defining Global Utility Rules in ast-grep YAML Configuration\nDESCRIPTION: This YAML snippet shows how to define a global utility rule in ast-grep. It includes the required fields such as id, language, and rule definition for matching literal values in TypeScript.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# is-literal.yml\nid: is-literal\nlanguage: TypeScript\nrule:\n  any:\n    - kind: 'false'\n    - kind: undefined\n    - kind: 'null'\n    - kind: 'true'\n    - kind: regex\n    - kind: number\n    - kind: string\n```\n\n----------------------------------------\n\nTITLE: Converting Generator Expression to List Comprehension in Python\nDESCRIPTION: A transform rule that converts a generator expression to a list comprehension by extracting the generator's contents and wrapping it in square brackets\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/transform.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: convert_generator\nrule:\n  kind: generator_expression\n  pattern: $GEN\ntransform:\n  LIST:\n    substring:\n      source: $GEN\n      startChar: 1\n      endChar: -1\nfix: '([$LIST])'\n```\n\n----------------------------------------\n\nTITLE: Creating Overloaded Method Signatures for Node Type Refinement in TypeScript\nDESCRIPTION: Defines an interface with overloaded method signatures to support both untyped and typed versions of node methods. This allows for flexible usage while maintaining type safety.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ninterface NodeMethod<M, K> {\n  (): SgNode<M>                     // Untyped version\n  <T extends K>(): RefineNode<M, T> // Typed version\n}\n```\n\n----------------------------------------\n\nTITLE: Executing ast-grep Test Command\nDESCRIPTION: This snippet demonstrates the basic usage of the ast-grep test command in a shell environment. It serves to run tests defined in the configuration while providing various options for customization.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/test.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep test [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep NAPI Package with npm\nDESCRIPTION: Command to install the ast-grep NAPI package using npm package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install --save @ast-grep/napi\n```\n\n----------------------------------------\n\nTITLE: Matching Literal Values or Arrays of Literals in JavaScript using YAML in ast-grep\nDESCRIPTION: This YAML snippet shows how to match either literal values or an array of literal values in JavaScript using ast-grep rules. It demonstrates the repetitive nature of rules without utility mechanisms.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  any:\n    - kind: 'false'\n    - kind: undefined\n    # more literal kinds omitted\n    # ...\n    - kind: array\n      has:\n        any:\n          - kind: 'false'\n          - kind: undefined\n          # more literal kinds omitted\n          # ...\n```\n\n----------------------------------------\n\nTITLE: YAML Rule for Function Renaming in Python\nDESCRIPTION: Defines a YAML rule to rename a function 'foo' to 'baz' in Python, including both the function definition and calls.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nid: change_def\nlanguage: Python\nrule:\n  pattern: |\n    def foo($X):\n      $$$S\nfix: |-\n  def baz($X):\n    $$$S\n\n---\n\nid: change_param\nrule:\n  pattern: foo($X)\nfix: baz($X)\n```\n\n----------------------------------------\n\nTITLE: Defining the Rule Configuration in YAML\nDESCRIPTION: This snippet depicts the YAML configuration for a rule named 'no-eval' aimed at preventing the use of 'eval' in JavaScript. It contains placeholders for the rule message, severity, and pattern to match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n```yml\nid: no-eval\nmessage: Add your rule message here....\nseverity: error # error, warning, hint, info\nlanguage: JavaScript\nrule:\n  pattern: Your Rule Pattern here...\n# utils: Extract repeated rule as local utility here.\n# note: Add detailed explanation for the rule.\n```\n```\n\n----------------------------------------\n\nTITLE: Defining an Any Composite Rule\nDESCRIPTION: This YAML snippet demonstrates how to create an 'any' composite rule where at least one of the specified sub-rules must match. It provides the correct syntax for defining such rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_12\n\nLANGUAGE: yaml\nCODE:\n```\nany:\n  - pattern: console.log($ARG)\n  - pattern: console.warn($ARG)\n  - pattern: console.error($ARG)\n```\n\n----------------------------------------\n\nTITLE: Modifying Source Code with ast-grep\nDESCRIPTION: Illustrates how to use the replace() method to generate an Edit object and apply changes to the source code using commitEdits().\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nconst root = parse(Lang.JavaScript, \"console.log('hello world')\").root()\nconst node = root.find('console.log($A)')\nconst edit = node.replace(\"console.error('bye world')\")\nconst newSource = node.commitEdits([edit])\n// \"console.error('bye world')\"\n```\n\n----------------------------------------\n\nTITLE: ast-grep Match Object JSON Example\nDESCRIPTION: This is an example of the JSON output format for a match object generated by ast-grep. It includes information about the matched text, its range in the file, the file path, surrounding lines, replacement text, replacement offsets, language, and any meta-variables captured during the match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n\"[\\n  {\\n    \\\"text\\\": \\\"Some(matched)\\\",\\n    \\\"range\\\": {\\n      \\\"byteOffset\\\": { \\\"start\\\": 10828, \\\"end\\\": 10841 },\\n      \\\"start\\\": { \\\"line\\\": 303, \\\"column\\\": 2 },\\n      \\\"end\\\": { \\\"line\\\": 303, \\\"column\\\": 15 }\\n    },\\n    \\\"file\\\": \\\"crates/config/src/rule/mod.rs\\\",\\n    \\\"lines\\\": \\\"  Some(matched)\\\",\\n    \\\"replacement\\\": \\\"None\\\",\\n    \\\"replacementOffsets\\\": { \\\"start\\\": 10828, \\\"end\\\": 10841 },\\n    \\\"language\\\": \\\"Rust\\\",\\n    \\\"metaVariables\\\": {\\n      \\\"single\\\": {\\n        \\\"A\\\": {\\n          \\\"text\\\": \\\"matched\\\",\\n          \\\"range\\\": {\\n            \\\"byteOffset\\\": { \\\"start\\\": 10833, \\\"end\\\": 10840 },\\n            \\\"start\\\": { \\\"line\\\": 303, \\\"column\\\": 7 },\\n            \\\"end\\\": { \\\"line\\\": 303, \\\"column\\\": 14 }\\n          }\\n        }\\n      },\\n      \\\"multi\\\": {},\\n      \\\"transformed\\\": {}\\n    }\\n  }\\n]\"\n```\n\n----------------------------------------\n\nTITLE: Matching and Retrieving Nodes in Python AST\nDESCRIPTION: Examples of matching and retrieving nodes using meta variables in the AST.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nsrc = \"\"\"\nprint('hello')\nlogger('hello', 'world', '!')\n\"\"\"\nroot = SgRoot(src, \"python\").root()\nnode = root.find(pattern=\"print($A)\")\narg = node.get_match(\"A\") # returns SgNode('hello')\nassert arg # assert node is found\narg.text() # returns 'hello'\n# returns [] because $A and $$$A are different\nnode.get_multiple_matches(\"A\")\n\nlogs = root.find(pattern=\"logger($$$ARGS)\")\n# returns [SgNode('hello'), SgNode(','), SgNode('world'), SgNode(','), SgNode('!')]\nlogs.get_multiple_matches(\"ARGS\")\nlogs.get_match(\"A\") # returns None\n```\n\n----------------------------------------\n\nTITLE: Resolving Tree-sitter Type Aliases in TypeScript\nDESCRIPTION: Defines a TypeScript type ResolveType that recursively resolves Tree-sitter type aliases to their concrete node kinds. This ensures correct mapping of aliases to actual node types used in ast-grep rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype ResolveType<M, T extends keyof M> =\n  M[T] extends {subtypes: infer S extends {type: string}[] }\n    ? ResolveType<M, S[number]['type']>\n    : T\n```\n\n----------------------------------------\n\nTITLE: AST-Grep Pattern for Refactoring Digit Count in Rust\nDESCRIPTION: This shell command uses ast-grep to find and replace inefficient digit count calculations in Rust files. It matches the pattern of string conversion and replaces it with the efficient logarithmic method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/get-digit-count-in-usize.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p '$NUM.to_string().chars().count()' \\\n   -r '$NUM.checked_ilog10().unwrap_or(0) + 1' \\\n   -l rs\n```\n\n----------------------------------------\n\nTITLE: Utilizing Utility Rules in ast-grep YAML\nDESCRIPTION: This code snippet shows how to define utility rules within the 'utils' section of an ast-grep rule. Utility rules can be utilized locally to aid in matches.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\nutils:\n  match-function:\n    any:\n      - kind: function\n      - kind: function_declaration\n      - kind: arrow_function\n```\n\n----------------------------------------\n\nTITLE: Basic ast-grep Rule for Console Log Transformation\nDESCRIPTION: A simple rule demonstrating how to replace console.log calls with logger.log while preserving the message argument using meta-variables.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($MSG)\nfix: logger.log($MSG)\n```\n\n----------------------------------------\n\nTITLE: Running Interactive Scans with ast-grep\nDESCRIPTION: This snippet demonstrates using the ast-grep tool in interactive mode via the `--interactive` flag, allowing users to manually accept or reject rewrites of query results.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan --interactive\n```\n\n----------------------------------------\n\nTITLE: Using Not Composite Rule\nDESCRIPTION: This snippet showcases how to use the not composite rule to create a condition that matches a node if a specified sub-rule does not match it. It provides an example of its application.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_13\n\nLANGUAGE: yaml\nCODE:\n```\nnot:\n  pattern: console.log($ARG)\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via pip\nDESCRIPTION: Command to install ast-grep using Python's pip package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n# install via pip\npip install ast-grep-cli\n```\n\n----------------------------------------\n\nTITLE: Creating a New ast-grep Project\nDESCRIPTION: This snippet demonstrates the interactive prompts involved in setting up a new ast-grep project using the command line interface. It guides the user in creating the necessary folder structure for rules and tests.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```markdown\nNo sgconfig.yml found. Creating a new ast-grep project...\n> Where do you want to have your rules? rules\n> Do you want to create rule tests? Yes\n> Where do you want to have your tests? rule-tests\n> Do you want to create folder for utility rules? Yes\n> Where do you want to have your utilities? utils\nYour new ast-grep project has been created!\n```\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Rule with Context and Selector\nDESCRIPTION: This snippet shows how to use a pattern rule in YAML that selects class fields in JavaScript. It includes context and a selector to specify the AST structure being matched.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  selector: field_definition\n  context: class { $F }\n```\n\n----------------------------------------\n\nTITLE: Implementing Base Tree-sitter Node Class in TypeScript\nDESCRIPTION: Definition of the core Tree-sitter Node class showing basic untyped API methods for AST traversal.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nclass Node {\n  kind(): string     // Get the type of node, e.g., 'function_declaration'\n  field(name: string): Node  // Get a specific child by its field name\n  parent(): Node             // Navigate to the parent node\n  children(): Node[]         // Get all child nodes\n  text(): string             // Get the actual source code text\n}\n```\n\n----------------------------------------\n\nTITLE: Refining Node Selection in ast-grep\nDESCRIPTION: Demonstrates the use of refinement methods like matches(), inside(), has(), precedes(), and follows() to further filter matched nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst node = root.find('console.log($A)')\nnode.matches('console.$METHOD($B)') // true\n```\n\n----------------------------------------\n\nTITLE: Defining AST-Grep Pattern for Finding TypeScript/JavaScript Import Statements\nDESCRIPTION: A comprehensive YAML rule for ast-grep that matches various import statement patterns in TypeScript/JavaScript code. The pattern captures different import styles including named imports with aliases, default imports, regular imports, dynamic requires, destructured imports, namespace imports, and side-effect imports. Each pattern extracts relevant identifiers and source paths.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\nid: find-all-imports-and-identifiers\nlanguage: TypeScript\nrule:\n  any:\n    # ALIAS IMPORTS\n    # ------------------------------------------------------------\n    # import { ORIGINAL as ALIAS } from 'SOURCE'\n    # ------------------------------------------------------------\n    - all:\n        # 1. Target the specific node type for named imports\n        - kind: import_specifier\n        # 2. Ensure it *has* an 'alias' field, capturing the alias identifier\n        - has:\n            field: alias\n            pattern: $ALIAS\n        # 3. Capture the original identifier (which has the 'name' field)\n        - has:\n            field: name\n            pattern: $ORIGINAL\n        # 4. Find an ANCESTOR import_statement and capture its source path\n        - inside:\n            stopBy: end # <<<--- Search ancestors.\n            kind: import_statement\n            has: # Ensure the found import_statement has the source field\n              field: source\n              pattern: $SOURCE\n\n    # DEFAULT IMPORTS\n    # ------------------------------------------------------------\n    # import { ORIGINAL } from 'SOURCE'\n    # ------------------------------------------------------------\n    - all:\n        - kind: import_statement\n        - has:\n            # Ensure it has an import_clause...\n            kind: import_clause\n            has:\n              # ...that directly contains an identifier (the default import name)\n              # This identifier is NOT under a 'named_imports' or 'namespace_import' node\n              kind: identifier\n              pattern: $DEFAULT_NAME\n        - has:\n            field: source\n            pattern: $SOURCE\n    \n    # REGULAR IMPORTS\n    # ------------------------------------------------------------\n    # import { ORIGINAL } from 'SOURCE'\n    # ------------------------------------------------------------\n    - all:\n        # 1. Target the specific node type for named imports\n        - kind: import_specifier\n        # 2. Ensure it *has* an 'alias' field, capturing the alias identifier\n        - has:\n            field: name\n            pattern: $ORIGINAL\n        # 4. Find an ANCESTOR import_statement and capture its source path\n        - inside:\n            stopBy: end # <<<--- This is the key fix! Search ancestors.\n            kind: import_statement\n            has: # Ensure the found import_statement has the source field\n              field: source\n              pattern: $SOURCE\n\n    # DYNAMIC IMPORTS (Single Variable Assignment) \n    # ------------------------------------------------------------\n    # const VAR_NAME = require('SOURCE')\n    # ------------------------------------------------------------\n    - all:\n        - kind: variable_declarator\n        - has:\n            field: name\n            kind: identifier\n            pattern: $VAR_NAME # Capture the single variable name\n        - has:\n            field: value\n            any:\n              # Direct call\n              - all: # Wrap conditions in all\n                  - kind: call_expression\n                  - has: { field: function, regex: '^(require|import)$' }\n                  - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              # Awaited call\n              - kind: await_expression\n                has:\n                  all: # Wrap conditions in all\n                    - kind: call_expression\n                    - has: { field: function, regex: '^(require|import)$' }\n                    - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n\n    # DYNAMIC IMPORTS (Destructured Shorthand Assignment)     \n    # ------------------------------------------------------------\n    # const { ORIGINAL } = require('SOURCE')\n    # ------------------------------------------------------------\n    - all:\n        # 1. Target the shorthand identifier within the pattern\n        - kind: shorthand_property_identifier_pattern\n        - pattern: $ORIGINAL\n        # 2. Ensure it's inside an object_pattern that is the name of a variable_declarator\n        - inside:\n            kind: object_pattern\n            inside: # Check the variable_declarator it belongs to\n              kind: variable_declarator\n              # 3. Check the value assigned by the variable_declarator\n              has:\n                field: value\n                any:\n                  # Direct call\n                  - all:\n                      - kind: call_expression\n                      - has: { field: function, regex: '^(require|import)$' }\n                      - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n                  # Awaited call\n                  - kind: await_expression\n                    has:\n                      all:\n                        - kind: call_expression\n                        - has: { field: function, regex: '^(require|import)$' }\n                        - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              stopBy: end # Search ancestors to find the correct variable_declarator\n\n    # DYNAMIC IMPORTS (Destructured Alias Assignment) \n    # ------------------------------------------------------------\n    # const { ORIGINAL: ALIAS } = require('SOURCE')\n    # ------------------------------------------------------------\n    - all:\n        # 1. Target the pair_pattern for aliased destructuring\n        - kind: pair_pattern\n        # 2. Capture the original identifier (key)\n        - has:\n            field: key\n            kind: property_identifier # Could be string/number literal too, but property_identifier is common\n            pattern: $ORIGINAL\n        # 3. Capture the alias identifier (value)\n        - has:\n            field: value\n            kind: identifier\n            pattern: $ALIAS\n        # 4. Ensure it's inside an object_pattern that is the name of a variable_declarator\n        - inside:\n            kind: object_pattern\n            inside: # Check the variable_declarator it belongs to\n              kind: variable_declarator\n              # 5. Check the value assigned by the variable_declarator\n              has:\n                field: value\n                any:\n                  # Direct call\n                  - all:\n                      - kind: call_expression\n                      - has: { field: function, regex: '^(require|import)$' }\n                      - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n                  # Awaited call\n                  - kind: await_expression\n                    has:\n                      all:\n                        - kind: call_expression\n                        - has: { field: function, regex: '^(require|import)$' }\n                        - has: { field: arguments, has: { kind: string, pattern: $SOURCE } } # Capture source\n              stopBy: end # Search ancestors to find the correct variable_declarator\n            stopBy: end # Ensure we check ancestors for the variable_declarator\n\n    # DYNAMIC IMPORTS (Side Effect / Source Only) \n    # ------------------------------------------------------------\n    # require('SOURCE')\n    # ------------------------------------------------------------\n    - all:\n        - kind: string # Target the source string literal directly\n        - pattern: $SOURCE\n        - inside: # String must be the argument of require() or import()\n            kind: arguments\n            parent:\n              kind: call_expression\n              has:\n                field: function\n                # Match 'require' identifier or 'import' keyword used dynamically\n                regex: '^(require|import)$'\n            stopBy: end # Search ancestors if needed (for the arguments/call_expression)\n        - not:\n            inside:\n              kind: lexical_declaration\n              stopBy: end # Search all ancestors up to the root\n\n    # NAMESPACE IMPORTS \n    # ------------------------------------------------------------\n    # import * as ns from 'mod'\n    # ------------------------------------------------------------\n    - all:\n        - kind: import_statement\n        - has:\n            kind: import_clause\n            has:\n              kind: namespace_import\n              has:\n                # namespace_import's child identifier is the alias\n                kind: identifier\n                pattern: $NAMESPACE_ALIAS\n        - has:\n            field: source\n            pattern: $SOURCE\n\n    # SIDE EFFECT IMPORTS \n    # ------------------------------------------------------------\n    # import 'mod'\n    # ------------------------------------------------------------\n    - all:\n        - kind: import_statement\n        - not: # Must NOT have an import_clause\n            has: { kind: import_clause }\n        - has: # But must have a source\n            field: source\n            pattern: $SOURCE\n```\n\n----------------------------------------\n\nTITLE: Refactoring a Rule for Class Getter Matching in YAML\nDESCRIPTION: This YAML rule refactoring example illustrates rewriting a complex rule for matching 'this.foo' in class getter methods to reduce indentation and improve clarity. It retains the original functionality while demonstrating a flatter structure that is easier to manage and understand.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: this.foo\n  inside:\n    pattern:\n      context: class A { get $GETTER() { $$$ } }\n      selector: method_definition\n    inside:\n        kind: class_body\n    stopBy:\n      any:\n        - kind: object\n        - kind: class_body\n```\n\n----------------------------------------\n\nTITLE: Configuring MobX Component Rewrite Rule in YAML\nDESCRIPTION: YAML configuration for an ast-grep rule to rewrite MobX component style. It defines a pattern to match and a fix to apply, transforming the component structure to allow better ESLint hook checking.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rewrite-mobx-component.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: rewrite-mobx-component\nlanguage: typescript\nrule:\n  pattern: export const $COMP = observer($FUNC)\nfix: |-\n  const Base$COMP = $FUNC\n  export const $COMP = observer(Base$COMP)\n```\n\n----------------------------------------\n\nTITLE: Executing ast-grep with Custom Configuration\nDESCRIPTION: This bash snippet demonstrates how to run the ast-grep scan command using a custom configuration file path specified by the '--config' option. This allows users to apply configuration settings from a designated YAML file when scanning projects. Requires the 'ast-grep' CLI tool to be installed.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/project-config.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan --config path/to/config.yml\n```\n\n----------------------------------------\n\nTITLE: Complete Rewriter Definition for Dictionary Conversion\nDESCRIPTION: This YAML code defines a complete rewriter for transforming dict() function calls to dictionary literals. It includes the rule to match keyword arguments and the fix to create key-value pairs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nrewriters:\n- id: dict-rewrite\n  rule:\n    kind: keyword_argument\n    all:\n    - has:\n        field: name\n        pattern: $KEY\n    - has:\n        field: value\n        pattern: $VAL\n  fix: \"'$KEY': $VAL\"\n```\n\n----------------------------------------\n\nTITLE: Applying Rewriter to Dict Function Call\nDESCRIPTION: This YAML snippet shows how to apply the dict-rewrite rewriter to transform a dict() function call. It matches the function call pattern and applies the rewriter to the arguments.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: dict($$$ARGS)        # match dict function call, capture $$$ARGS\ntransform:\n  LITERAL:                      # the transformed code\n    rewrite:\n      rewriters: [dict-rewrite] # specify the rewriter defined above\n      source: $$$ARGS           # apply rewriters to $$$ARGS arguments\n```\n\n----------------------------------------\n\nTITLE: ast-grep scan with Rule File\nDESCRIPTION: This bash command demonstrates how to run an ast-grep rule from a YAML file using the `scan` subcommand. It assumes that the rule configuration is saved in `no-await-in-promise-all.yml` and scans the `test.ts` file. It illustrates how to execute a predefined rule against a specific codebase.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"ast-grep scan --rule no-await-in-promise-all.yml test.ts\"\n```\n\n----------------------------------------\n\nTITLE: Matching Literal Values in JavaScript using YAML in ast-grep\nDESCRIPTION: This YAML snippet demonstrates how to match various literal value types in JavaScript using ast-grep rules. It includes boolean values, undefined, null, regex, numbers, and strings.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nany:\n  - kind: 'false'\n  - kind: undefined\n  - kind: 'null'\n  - kind: 'true'\n  - kind: regex\n  - kind: number\n  - kind: string\n```\n\n----------------------------------------\n\nTITLE: Parsing Source Code with ast-grep\nDESCRIPTION: Shows how to parse a JavaScript source string into an AST using the parse function and Lang enum from ast-grep's NAPI package.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Lang, parse } from '@ast-grep/napi';\n\nconst source = `console.log(\"hello world\")`\nconst ast = parse(Lang.JavaScript, source)\n```\n\n----------------------------------------\n\nTITLE: Using SgRoot to Parse and Access Python Code\nDESCRIPTION: Example of using SgRoot to parse a Python string and access the root node.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nroot = SgRoot(\"print('hello world')\", \"python\") # 1. parse\nnode = root.root()                              # 2. get root\n```\n\n----------------------------------------\n\nTITLE: Using Alternative Joiner with Rewriters\nDESCRIPTION: This YAML snippet demonstrates how to use an alternative joiner when applying multiple rewriters. It shows how to specify a custom string to join the transformed sub-nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    rewrite:\n      rewriters: [rewrite-num, rewrite-str]\n      source: $$$LIST\n      joinBy: ' + '\n```\n\n----------------------------------------\n\nTITLE: Searching Python AST with Rules\nDESCRIPTION: Examples of searching the AST using different rules and patterns.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nroot = SgRoot(\"print('hello world')\", \"python\")\nnode = root.root()\nnode.find(pattern=\"print($A)\") # will return the print function call\nnode.find(kind=\"string\") # will return the string 'hello world'\n# below will return print function call because it matches both rules\nnode.find(pattern=\"print($A)\", kind=\"call\")\n# below will return None because the pattern cannot be a string literal\nnode.find(pattern=\"print($A)\", kind=\"string\")\n\nstrings = node.find_all(kind=\"string\") # will return [SgNode(\"hello world\")]\nassert len(strings) == 1\n```\n\n----------------------------------------\n\nTITLE: Rewriting AST Subsets - YAML\nDESCRIPTION: This snippet documents the experimental `rewrite` transformation which applies rewriter rules to subsets of an AST captured by meta-variables. The `source` property indicates the meta-variable, while `rewriters` is an array of rule names. An optional `joinBy` property specifies how rewritten nodes should be concatenated. The output is a transformed syntax structure or an aggregated result based on rules applied.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/transformation.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    rewrite:\n      source: $VAR\n      rewriters: [rule1, rule2]\n      joinBy: \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: TypeScript code example\nDESCRIPTION: This TypeScript code snippet is an example of code that the `no-await-in-promise-all` rule might match.  It contains an `await` call inside the array passed to `Promise.all`. It shows an example of a code pattern matched by ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n\"await Promise.all([\n  await foo(),\n])\"\n```\n\n----------------------------------------\n\nTITLE: Creating an Inside Relational Rule\nDESCRIPTION: This YAML snippet illustrates a relational rule that matches a target node nested within another node defined by a pattern. It includes specifications for the stopBy and field attributes to control matching behavior.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\ninside:\n  pattern: class $TEST { $$$ } # a sub rule object\n  stopBy: end                  # stopBy accepts 'end', 'neighbor' or another rule object.\n  field: body                  # specify the sub-node in the target\n```\n\n----------------------------------------\n\nTITLE: Creating a New ast-grep Project via CLI\nDESCRIPTION: Command to create a new ast-grep project with default configuration, including config file, rules, tests, and utility rules folders\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/new.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep new project\n```\n\n----------------------------------------\n\nTITLE: SgRoot Class Definition in TypeScript\nDESCRIPTION: This code snippet defines the `SgRoot` class in TypeScript, which represents the parsed tree of code. It includes methods for accessing the root `SgNode` and the filename associated with the parsed code. The `filename()` method returns \"anonymous\" if the instance is created by `parse(lang, source)`.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/** Represents the parsed tree of code. */\nclass SgRoot {\n  /** Returns the root SgNode of the ast-grep instance. */\n  root(): SgNode\n  /**\n   * Returns the path of the file if it is discovered by ast-grep's `findInFiles`.\n   * Returns `\"anonymous\"` if the instance is created by `parse(lang, source)`.\n   */\n  filename(): string\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Capture Import Statement in YAML\nDESCRIPTION: This YAML snippet describes a rule to capture import statements for identifiers in JavaScript. It sets the pattern to match imports containing multiple identifiers.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\nrule:\n  pattern: import {$$$IDENTS} from './module'\n```\n\n----------------------------------------\n\nTITLE: Implementing Counted Promise for findInFiles in TypeScript\nDESCRIPTION: Provides a solution for handling premature returns in findInFiles by implementing a counted promise. This ensures all files are processed before the function completes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ntype Callback = (t: any, cb: any) => Promise<number>\nfunction countedPromise<F extends Callback>(func: F) {\n  type P = Parameters<F>\n  return async (t: P[0], cb: P[1]) => {\n    let i = 0\n    let fileCount: number | undefined = undefined\n    // resolve will be called after all files are processed\n    let resolve = () => {}\n    function wrapped(...args: any[]) {\n      let ret = cb(...args)\n      if (++i === fileCount) resolve()\n      return ret\n    }\n    fileCount = await func(t, wrapped as P[1])\n    // not all files are processed, await `resolve` to be called\n    if (fileCount > i) {\n      await new Promise<void>(r => resolve = r)\n    }\n    return fileCount\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule for Barrel Imports in YAML\nDESCRIPTION: This YAML snippet specifies a rule for recognizing and fixing barrel import statements in TypeScript projects. The rule includes a pattern for detecting imports from a barrel and a mechanism to rewrite these imports to direct module imports.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/speed-up-barrel-import.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: speed-up-barrel-import\nlanguage: typescript\n# find the barrel import statement\nrule:\n  pattern: import {$$$IDENTS} from './barrel'\n# rewrite imported identifiers to direct imports\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  fix: import $IDENT from './barrel/$IDENT'\n# apply the rewriter to the import statement\ntransform:\n  IMPORTS:\n    rewrite:\n      rewriters: [rewrite-identifer]\n      # $$$IDENTS contains imported identifiers\n      source: $$$IDENTS\n      # join the rewritten imports by newline\n      joinBy: \"\\n\"\nfix: $IMPORTS\n```\n\n----------------------------------------\n\nTITLE: Implementing all Composite Rule in YAML\nDESCRIPTION: Demonstrates a composite rule that matches an AST node satisfying multiple conditions simultaneously, specifically matching a console.log expression statement\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  all:\n    - pattern: console.log('Hello World');\n    - kind: expression_statement\n```\n\n----------------------------------------\n\nTITLE: Finding JavaScript object property with 'prototype' key using YAML in ast-grep\nDESCRIPTION: Shows how to use the 'field' option with the 'has' relational rule to find JavaScript object properties specifically with the key 'prototype'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nkind: pair # key-value pair in JS\nhas:\n  field: key # note here\n  regex: 'prototype'\n```\n\n----------------------------------------\n\nTITLE: Defining Local Utility Rules in ast-grep YAML Configuration\nDESCRIPTION: This YAML snippet shows how to define and use a local utility rule in ast-grep. It defines an 'is-literal' utility rule and uses it in the main rule section.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nutils:\n  is-literal:\n    any:\n      - kind: 'false'\n      - kind: undefined\n      - kind: 'null'\n      - kind: 'true'\n      - kind: regex\n      - kind: number\n      - kind: string\nrule:\n  matches: is-literal\n```\n\n----------------------------------------\n\nTITLE: Identifying Functions Without Return Types in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates how to identify functions that do not have return types by using the `kind: arrow_function` rule to target arrow function nodes. The example provided will trigger an error since it returns a number without an explicit return type.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst foo = () => {\n\treturn 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Composite Rule with Multiple Conditions\nDESCRIPTION: Shows how to construct a rule that matches an arguments node with both number and string child nodes\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: arguments\n  all:\n    - has: { kind: number }\n    - has: { kind: string }\n```\n\n----------------------------------------\n\nTITLE: Running the ast-grep Scan\nDESCRIPTION: This snippet shows the command line interface output when scanning a JavaScript file using ast-grep after creating the rule 'no-eval'. It demonstrates how errors will be reported when the pattern is matched in the code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n```bash\nerror[no-eval]: Add your rule message here....\n   test.js:1:1\n  \n1  eval('hello')\n   ^^^^^^^^^^^^^\n\nError: 1 error(s) found in code.\nHelp: Scan succeeded and found error level diagnostics in the codebase.\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Rule for Detecting Nested Links in TSX\nDESCRIPTION: This YAML configuration defines an ast-grep rule to detect nested <a> tags in TSX code. It sets the rule ID, language, severity, and specifies the pattern to match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/avoid-nested-links.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-nested-links\nlanguage: tsx\nseverity: error\nrule:\n  pattern: <a $$$>$$$A</a>\n  has:\n    pattern: <a $$$>$$$</a>\n    stopBy: end\n```\n\n----------------------------------------\n\nTITLE: Configuring JSON Key-Value Pattern Match in YAML\nDESCRIPTION: Demonstrates how to properly match JSON key-value pairs using ast-grep pattern object with context and selector\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern:\n    context: '{\"key\": \"$VAL\"}'\n    selector: pair\n```\n\n----------------------------------------\n\nTITLE: Type Definition for FindConfig Interface in TypeScript with AST-Grep\nDESCRIPTION: Defines the FindConfig interface used in the findInFiles function. It specifies the paths to search and the matcher configuration for finding nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface FindConfig {\n  paths: Array<string>\n  matcher: NapiConfig\n}\n```\n\n----------------------------------------\n\nTITLE: Non Capturing Match\nDESCRIPTION: This snippet demonstrates non-capturing meta variables, using `$_` as a prefix.  The pattern `$_FUNC($_FUNC)` matches function calls where the argument is also a function call, allowing different content for each occurrence of `$_FUNC`.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// Given this pattern\n\n$_FUNC($_FUNC)\n\n// it will match all function call with one argument or spread call\ntest(a)\ntestFunc(1 + 1)\ntestFunc(...args)\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings - YAML\nDESCRIPTION: This snippet shows the `substring` transformation in YAML, used to extract substrings from meta-variable strings by specifying starting and ending character indices. It supports inclusive start and exclusive end, while indices can be negative for reverse indexing. The crucial parameters are `startChar`, `endChar`, and the meta-variable `source`, which must be prefixed with `$`. The output is a new substring defined by the start and end indices.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/transformation.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    substring:\n      startChar: 1\n      endChar: -1\n      source: $VAR\n```\n\n----------------------------------------\n\nTITLE: Configuring Async Function Removal in ast-grep (YAML)\nDESCRIPTION: YAML configuration for ast-grep that defines rules to remove async/await patterns from Python functions. Uses pattern matching and rewriters to transform async functions into synchronous ones while handling nested await calls.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/remove-async-await.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: remove-async-def\nlanguage: python\nrule:\n  pattern:\n    context: 'async def $FUNC($$$ARGS): $$$BODY'\n    selector: function_definition\nrewriters:\n  remove-await-call:\n    pattern: 'await $$$CALL'\n    fix: $$$CALL\ntransform:\n  REMOVED_BODY:\n    rewrite:\n      rewriters: [remove-await-call]\n      source: $$$BODY\nfix: |-\n  def $FUNC($$$ARGS):\n    $REMOVED_BODY\n```\n\n----------------------------------------\n\nTITLE: Meta Variable Non-Matching Examples\nDESCRIPTION: The provided code snippets demonstrate cases where the pattern `console.log($GREETING)` will not match. This is because it requires exactly one AST node as an argument, excluding cases with no arguments, multiple arguments, or code within comments/strings.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/pattern-syntax.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// console.log(123) in comment is not matched\n'console.log(123) in string' // is not matched as well\nconsole.log() // mismatch argument\nconsole.log(a, b) // too many arguments\n```\n\n----------------------------------------\n\nTITLE: Comparing Sync and Async Parsing in TypeScript with AST-Grep NAPI\nDESCRIPTION: Demonstrates the difference between synchronous parse and asynchronous parseAsync methods for code parsing. parseAsync is recommended for better performance as it can utilize multiple threads.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { js } from '@ast-grep/napi';\n// only one thread parsing\nconst root = js.parse('console.log(\"hello world\")')\n// better, can use multiple threads\nconst root = await js.parseAsync('console.log(\"hello world\")')\n```\n\n----------------------------------------\n\nTITLE: Debugging AST-Grep Query Using CLI\nDESCRIPTION: Shows how to use the debug-query flag in ast-grep CLI to investigate parsing issues and view AST nodes\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nast-grep run -p <PATTERN> --debug-query ast\n```\n\n----------------------------------------\n\nTITLE: Variable Swapping YAML Rule in Python\nDESCRIPTION: Defines a YAML rule to swap the left-hand side and right-hand side of assignment statements in Python.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nid: swap\nlanguage: Python\nrule:\n  pattern: $X = $Y\nfix: $Y = $X\n```\n\n----------------------------------------\n\nTITLE: Pattern Context Configuration for Function Matching\nDESCRIPTION: Example of using pattern object with context to match function definitions in a complete code context\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern:\n    context: 'int main() { return 0; }'\n    selector: function\n```\n\n----------------------------------------\n\nTITLE: SgNode Refinement Method Signatures in Python\nDESCRIPTION: Method signatures for refining node searches in the SgNode class.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass SgNode:\n    def matches(self, **rule: Unpack[Rule]) -> bool: ...\n    def inside(self, **rule: Unpack[Rule]) -> bool: ...\n    def has(self, **rule: Unpack[Rule]) -> bool: ...\n    def precedes(self, **rule: Unpack[Rule]) -> bool: ...\n    def follows(self, **rule: Unpack[Rule]) -> bool: ...\n```\n\n----------------------------------------\n\nTITLE: JavaScript Import Pattern Examples\nDESCRIPTION: Comprehensive examples of different JavaScript/TypeScript import patterns including named imports, aliased imports, default imports, namespace imports, side-effect imports, and various require patterns.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n//@ts-nocheck\n// Named import\nimport { testing } from './tests';\n\n// Aliased import\nimport { testing as test } from './tests2';\n\n// Default import\nimport hello from 'hello_world1';\n\n// Namespace import\nimport * as something from 'hello_world2';\n\n// Side-effect import\nimport '@fastify/static';\n\n// Type import\nimport {type hello1243 as testing} from 'hello';\n\n// Require patterns\nconst mod = require('some-module');\nrequire('polyfill');\n\n// Destructured require\nconst { test122, test2 } = require('./destructured1');\n// Aliased require\nconst { test122: test123, test2: test23, test3: test33 } = require('./destructured2');\n\n// Mixed imports\nimport defaultExport, { namedExport } from './mixed';\nimport defaultExport2, * as namespace from './mixed2';\n\n\n// Multiple import lines from the same file\nimport { one, two as alias, three } from './multiple';\nimport { never, gonna, give, you, up } from './multiple';\n\n// String literal variations\nimport { test1 } from \"./double-quoted\";\nimport { test2 } from './single-quoted';\n\n// Multiline imports\nimport {\n    longImport1,\n    longImport2 as alias2,\n    longImport3\n} from './multiline';\n\n// Dynamic imports\nconst dynamicModule = import('./dynamic1');\nconst {testing, testing123} = import('./dynamic2');\nconst asyncDynamicModule = await import('./async_dynamic1').then(module => module.default);\n// Aliased dynamic import\nconst { originalIdentifier: aliasedDynamicImport} = await import('./async_dynamic2');\n\n// Comments in imports\nimport /* test */ { \n    // Comment in import\n    commentedImport \n} from './commented'; // End of line comment\n```\n\n----------------------------------------\n\nTITLE: SgNode Class Definition in Python\nDESCRIPTION: This code snippet defines the `SgNode` class in Python, representing a node in the syntax tree. It includes various methods for inspecting node properties (e.g., range, kind, text), refining search criteria (e.g., matches, inside, has), traversing the tree (e.g., parent, children, next), and editing nodes (e.g., replace, commit_edits). The class definition includes type hints and overloads for different method signatures.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass SgNode:\n    # Node Inspection\n    def range(self) -> Range: ...\n    def is_leaf(self) -> bool: ...\n    def is_named(self) -> bool: ...\n    def is_named_leaf(self) -> bool: ...\n    def kind(self) -> str: ...\n    def text(self) -> str: ...\n\n    # Refinement\n    def matches(self, **rule: Unpack[Rule]) -> bool: ...\n    def inside(self, **rule: Unpack[Rule]) -> bool: ...\n    def has(self, **rule: Unpack[Rule]) -> bool: ...\n    def precedes(self, **rule: Unpack[Rule]) -> bool: ...\n    def follows(self, **rule: Unpack[Rule]) -> bool: ...\n    def get_match(self, meta_var: str) -> Optional[SgNode]: ...\n    def get_multiple_matches(self, meta_var: str) -> List[SgNode]: ...\n    def get_transformed(self, meta_var: str) -> Optional[str]: ...\n    def __getitem__(self, meta_var: str) -> SgNode: ...\n\n    # Search\n    @overload\n    def find(self, config: Config) -> Optional[SgNode]: ...\n    @overload\n    def find(self, **kwargs: Unpack[Rule]) -> Optional[SgNode]: ...\n    @overload\n    def find_all(self, config: Config) -> List[SgNode]: ...\n    @overload\n    def find_all(self, **kwargs: Unpack[Rule]) -> List[SgNode]: ...\n\n    # Tree Traversal\n    def get_root(self) -> SgRoot: ...\n    def field(self, name: str) -> Optional[SgNode]: ...\n    def parent(self) -> Optional[SgNode]: ...\n    def child(self, nth: int) -> Optional[SgNode]: ...\n    def children(self) -> List[SgNode]: ...\n    def ancestors(self) -> List[SgNode]: ...\n    def next(self) -> Optional[SgNode]: ...\n    def next_all(self) -> List[SgNode]: ...\n    def prev(self) -> Optional[SgNode]: ...\n    def prev_all(self) -> List[SgNode]: ...\n\n    # Edit\n    def replace(self, new_text: str) -> Edit: ...\n    def commit_edits(self, edits: List[Edit]) -> str: ...\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep for Unnecessary React Hook Detection in YAML\nDESCRIPTION: YAML configuration for ast-grep to detect unnecessary React hooks. It defines patterns for function declarations and arrow functions with names starting with 'use', and checks if the body contains any hook calls.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/unnecessary-react-hook.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: unnecessary-react-hook\nlanguage: Tsx\nutils:\n  hook_call:\n    has:\n      kind: call_expression\n      regex: ^use\n      stopBy: end\nrule:\n  any:\n  - pattern: function $FUNC($$$) { $$$ }\n  - pattern: let $FUNC = ($$$) => $$$\n  - pattern: const $FUNC = ($$$) => $$$\n  has:\n    pattern: $BODY\n    kind: statement_block\n    stopBy: end\nconstraints:\n  FUNC: {regex: ^use }\n  BODY: { not: { matches: hook_call } }\n```\n\n----------------------------------------\n\nTITLE: Implementing any Composite Rule in YAML\nDESCRIPTION: Shows a composite rule that matches AST nodes satisfying at least one of multiple variable declaration patterns\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  any:\n    - pattern: var a = $A\n    - pattern: const a = $A\n    - pattern: let a = $A\n```\n\n----------------------------------------\n\nTITLE: Diff showing the fix for await in Promise.all\nDESCRIPTION: TypeScript code diff illustrating the correction of await usage inside Promise.all. The await keyword is removed from the getFoo() call.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-await-in-promise-all.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst [foo, bar] = await Promise.all([\n  await getFoo(), // [!code --]\n  getFoo(), // [!code ++]\n  getBar(),\n  (async () => { await getBaz()})(),\n])\n```\n\n----------------------------------------\n\nTITLE: Using Typed Rules in AST Node Search\nDESCRIPTION: This snippet shows how to use typed rules when searching for nodes in an AST. It demonstrates type checking for the 'kind' property, which helps prevent errors and improves code completion in IDEs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nsgNode.find({\n  rule: {\n    // kind: 'invalid_kind', // error!\n    kind: 'function_declaration', // typed!\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule for Avoiding '&&' Short Circuit in JSX (YAML)\nDESCRIPTION: This YAML configuration defines a rule to detect and fix the use of '&&' short circuit in JSX expressions. It targets JSX expressions that are not inside JSX attributes and provides a fix using a ternary operator.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/avoid-jsx-short-circuit.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: do-what-brooooooklyn-said\nlanguage: Tsx\nrule:\n  kind: jsx_expression\n  has:\n    pattern: $A && $B\n  not:\n    inside:\n      kind: jsx_attribute\nfix: \"{$A ? $B : null}\"\n```\n\n----------------------------------------\n\nTITLE: Using Configuration File for Scanning\nDESCRIPTION: This flag allows specifying a configuration file for scanning, with a default value of 'sgconfig.yml'. It is essential for loading custom rules defined in the configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n-c, --config <CONFIG_FILE>\n```\n\n----------------------------------------\n\nTITLE: Identifier Rewriter Definition in YAML\nDESCRIPTION: Defines a rewriter that transforms individual identifiers into separate import statements. The rewriter captures each identifier and creates a new import statement with a specific path.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  fix: import $IDENT from './barrel/$IDENT'\n```\n\n----------------------------------------\n\nTITLE: Matching await inside for loop with YAML in ast-grep\nDESCRIPTION: Demonstrates using the 'inside' relational rule to match an await expression inside a for-in loop. This rule helps identify potentially problematic asynchronous operations within loops.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: await $PROMISE\n  inside:\n    kind: for_in_statement\n    stopBy: end\n```\n\n----------------------------------------\n\nTITLE: Edit and SgNode Replace Method Signatures in Python\nDESCRIPTION: Definitions of the Edit class and the replace method in SgNode for modifying code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass Edit:\n    # The start position of the edit\n    start_pos: int\n    # The end position of the edit\n    end_pos: int\n    # The text to be inserted\n    inserted_text: str\n\nclass SgNode:\n    # Edit\n    def replace(self, new_text: str) -> Edit: ...\n    def commit_edits(self, edits: List[Edit]) -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Defining Migration Rules for XState v5 in YAML\nDESCRIPTION: This YAML snippet defines rules for transforming XState v4 code to v5. The rules specify patterns to identify and replace old function calls (e.g., Machine, interpret) with their new counterparts (e.g., createMachine, createActor). Dependencies include a knowledge of YAML syntax and the XState package. Key parameters are `id` for rule identification and `pattern` for code matching. It outputs transformed code with new XState v5 imports.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/migrate-xstate-v5.md#2025-04-21_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nid: migrate-import-name\\nutils:\\n  FROM_XS: {kind: import_statement, has: {kind: string, regex: xstate}}\\n  XS_EXPORT:\\n    kind: identifier\\n    inside: { has: { matches: FROM_XS }, stopBy: end }\\nrule: { regex: ^Machine|interpret$, pattern: $IMPT, matches: XS_EXPORT }\\ntransform:\\n  STEP1:\\n    replace: {by: create$1, replace: (Machine), source: $IMPT }\\n  FINAL:\\n    replace: { by: createActor, replace: interpret, source: $STEP1 }\\nfix: $FINAL\\n\\n---\\nid: migrate-to-provide\\nrule: { pattern: $MACHINE.withConfig }\\nfix: $MACHINE.provide\\n\\n---\\nid: migrate-to-actors\\nrule:\\n  kind: property_identifier\\n  regex: ^services$\\n  inside: { pattern:  $M.withConfig($$$ARGS), stopBy: end }\\nfix: actors\n```\n\n----------------------------------------\n\nTITLE: Final Rule: Transform Barrel to Single Imports\nDESCRIPTION: This final YAML rule combines previous steps to transform JavaScript barrel imports to single imports using the `IMPORTS` transform in the `fix` field, ensuring each import statement is individually rewritten.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\nid: barrel-to-single\nlanguage: JavaScript\nrule:\n  pattern: import {$$$IDENTS} from './module'\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  transform:\n    LIB: { convert: { source: $IDENT, toCase: lowerCase } }\n  fix: import $IDENT from './module/$LIB'\ntransform:\n  IMPORTS:\n    rewrite:\n      rewriters: [rewrite-identifer]\n      source: $$$IDENTS\n      joinBy: \"\\n\"\nfix: $IMPORTS\n```\n\n----------------------------------------\n\nTITLE: Rule with pattern and meta variable\nDESCRIPTION: This YAML defines a rule with a pattern that includes a meta variable `$GREET`. The rule matches `console.log('Hello World')`. The rule captures the string inside `console.log` function call into the meta variable $GREET.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n\"rule:\n  pattern: console.log($GREET)\"\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Rules for AST Manipulation\nDESCRIPTION: This code defines a typed interface for rules in AST manipulation. It demonstrates how to use TypeScript's type system to ensure correct 'kind' values in rule definitions, improving rule correctness and user experience.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Rule<M extends TypeMaps> {\n    kind: Kinds<M>\n    ... // other rules\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule Directories in ast-grep - YAML\nDESCRIPTION: This YAML snippet shows how to configure directories for rule files and rule test configurations in ast-grep using the sgconfig.yml file. It specifies paths for storing rules and corresponding test cases.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/test-rule.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nruleDirs:\n  - rules\n# testConfigs contains a list of test directories for rules.\ntestConfigs:\n  - testDir: rule-tests\n```\n\n----------------------------------------\n\nTITLE: Using nthChild Rule to Match Second Number in JavaScript Array\nDESCRIPTION: Demonstrates how to use the nthChild rule in combination with the kind rule to match the second number in a JavaScript array.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: number\n  nthChild: 2\n```\n\n----------------------------------------\n\nTITLE: Complete AST Transformation Rule in YAML\nDESCRIPTION: Complete configuration that combines pattern matching, rewriting, and transformation to convert a grouped import statement into individual import statements.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: import {$$$IDENTS} from './barrel'\nrewriters:\n- id: rewrite-identifer\n  rule:\n    pattern: $IDENT\n    kind: identifier\n  fix: import $IDENT from './barrel/$IDENT'\ntransform:\n  IMPORTS:\n    rewrite:\n      rewriters: [rewrite-identifer]\n      source: $$$IDENTS\n      joinBy: \"\\n\"\nfix: $IMPORTS\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Utility Rules in ast-grep YAML Configuration\nDESCRIPTION: This YAML snippet demonstrates how to define and use utility rules in ast-grep. It shows the definition of an 'is-literal' utility rule and its usage in the main rule section, reducing repetition.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# define util rules using utils field\nutils:\n  # it accepts a string-keyed dictionary of rule object\n  is-literal:               # rule-id\n    any:                    # actual rule object\n      - kind: 'false'\n      - kind: undefined\n      - kind: 'null'\n      - kind: 'true'\n      - kind: regex\n      - kind: number\n      - kind: string\nrule:\n  any:\n    - matches: is-literal # reference the util!\n    - kind: array\n      has:\n        matches: is-literal # reference it again!\n```\n\n----------------------------------------\n\nTITLE: Regex Capture Groups Transformation with Function Name Replacement\nDESCRIPTION: A transformation that uses regex capture groups to replace function names starting with 'debug' with 'release', preserving additional suffix\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/transform.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nid: debug-to-release\nlanguage: js\nrule: {pattern: $OLD_FN($$$ARGS)}\nconstraints: {OLD_FN: {regex: ^debug}}\ntransform:\n  NEW_FN:\n    replace:\n      source: $OLD_FN\n      replace: debug(?<REG>.*)\n      by: release$REG\nfix: $NEW_FN($$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: AST-Grep YAML Migration Rule Configuration\nDESCRIPTION: YAML configuration for ast-grep that defines rules to identify and replace deprecated filter methods with their action equivalents in Rails controllers. Includes pattern matching for before, after, and around filters.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/migrate-action-filter.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: migration-action-filter\nlanguage: ruby\nrule:\n  any:\n    - pattern: before_filter $$$ACTION\n    - pattern: around_filter $$$ACTION\n    - pattern: after_filter $$$ACTION\n  has:\n    pattern: $FILTER\n    field: method\nfix:\n  $NEW_ACTION $$$ACTION\ntransform:\n  NEW_ACTION:\n    replace:\n      source: $FILTER\n      replace: _filter\n      by: _action\n```\n\n----------------------------------------\n\nTITLE: Enhanced Generator Expression Rule with Function Constraints\nDESCRIPTION: Advanced ast-grep rule that specifically targets list comprehensions used with iterator-compatible functions like any(), all(), and sum(), including function pattern constraints.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/prefer-generator-expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: prefer-generator-expressions\nlanguage: python\nrule:\n  pattern: $FUNC($LIST)\nconstraints:\n  LIST: { kind: list_comprehension }\n  FUNC:\n    any:\n      - pattern: any\n      - pattern: all\n      - pattern: sum\n      # ...\ntransform:\n  INNER:\n    substring: {source: $LIST, startChar: 1, endChar: -1 }\nfix: $FUNC($INNER)\n```\n\n----------------------------------------\n\nTITLE: AST-Grep Method to Function Transform Configuration\nDESCRIPTION: YAML configuration for ast-grep that defines the pattern matching and transformation rules to convert method-style calls to function calls. Includes pattern matching for method calls and transformation logic for argument handling.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/rewrite-method-to-function-call.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: method_receiver\nlanguage: c\nrule:\n  pattern: $R.$METHOD($$$ARGS)\ntransform:\n  MAYBE_COMMA:\n    replace:\n      source: $$$ARGS\n      replace: '^.+'\n      by: ', '\nfix:\n  $METHOD(&$R$MAYBE_COMMA$$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Suppressing Linting Errors in JavaScript with ast-grep\nDESCRIPTION: Illustrates various methods to suppress ast-grep linting errors in JavaScript code using inline comments. Includes examples of general suppression and rule-specific suppression.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/severity.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.log('hello')  // match\n// ast-grep-ignore\nconsole.log('suppressed') // suppressed\n// ast-grep-ignore: no-console\nconsole.log('suppressed') // suppressed\n// ast-grep-ignore: other-rule\nconsole.log('world') // match\n\n// Same line suppression\nconsole.log('suppressed') // ast-grep-ignore\nconsole.log('suppressed') // ast-grep-ignore: no-console\n```\n\n----------------------------------------\n\nTITLE: Defining a Regex Rule in YAML for Node Text Matching\nDESCRIPTION: This snippet provides examples of how to define a regex rule that utilizes Rust regular expressions to match the entire text of an AST node. It demonstrates the correct syntax and constraints associated with regex patterns.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nregex: console\n```\n\nLANGUAGE: yaml\nCODE:\n```\nregex: ^[a-z]+$\n```\n\nLANGUAGE: yaml\nCODE:\n```\nregex: (?i)a(?-i)b+\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Rule for Matching Golang Function Calls\nDESCRIPTION: This YAML configuration defines an ast-grep rule to match function calls in Golang. It uses a contextual pattern to avoid ambiguity with type conversions and specifies the call_expression selector.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/go/match-function-call.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: match-function-call\nlanguage: go\nrule:\n  pattern:\n    context: 'func t() { fmt.Println($A) }'\n    selector: call_expression\n```\n\n----------------------------------------\n\nTITLE: Creating a Rule for Custom Language\nDESCRIPTION: YAML rule definition for the custom Mojo language in ast-grep, showing how to create a rule that searches for the 'print' pattern in Mojo files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nid: my-first-mojo-rule\nlanguage: mojo  # the name we register before!\nseverity: hint\nrule:\n  pattern: print\n```\n\n----------------------------------------\n\nTITLE: Replacing Text using Regular Expressions - YAML\nDESCRIPTION: This snippet demonstrates the use of the `replace` key in a YAML transformation object, which utilizes a Rust regular expression to find and replace text within a meta-variable. Dependencies include specifying the regex pattern in `replace`, the replacement text in `by`, and the target meta-variable in `source`. The operation assumes a valid regex pattern and a meta-variable prefixed with `$`. The output is a transformed string where the specified pattern is replaced.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/transformation.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    replace:\n      replace: regex\n      by: replacement\n      source: $VAR\n```\n\n----------------------------------------\n\nTITLE: Scanning with ast-grep\nDESCRIPTION: This command allows users to scan and rewrite code by specifying options and paths to search. The primary usage involves the use of command-line options to customize the scanning process.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep scan [OPTIONS] [PATHS]...\n```\n\n----------------------------------------\n\nTITLE: Apply Rewriter to Identify and Rewrite Imports\nDESCRIPTION: In this transform section, the `rewrite` operation applies the previously defined rewriter to captured identifiers, joining rewritten statements with newline characters.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\ntransform:\n  IMPORTS:\n    rewrite:\n      rewriters: [rewrite-identifer]\n      source: $$$IDENTS\n      joinBy: \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: Basic List Comprehension Detection Rule in YAML\nDESCRIPTION: Initial ast-grep rule configuration for detecting list comprehensions and converting them to generator expressions by manipulating substring contents.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/prefer-generator-expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: prefer-generator-expressions\nlanguage: python\nrule:\n  pattern: $LIST\n  kind: list_comprehension\ntransform:\n  INNER:\n    substring: {source: $LIST, startChar: 1, endChar: -1 }\nfix: ($INNER)\n```\n\n----------------------------------------\n\nTITLE: Configuring FixConfig in ast-grep (YAML)\nDESCRIPTION: FixConfig provides a more advanced fixing strategy for replacing AST nodes, accommodating scenarios where string substitution alone is insufficient, such as removing array items or key-value pairs. This example illustrates using FixConfig to expand the fix range to remove an entire key-value pair and its trailing comma.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/fix.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: pair\n  has:\n    field: key\n    regex: Remove\n# remove the key-value pair and its comma\nfix:\n  template: ''\n  expandEnd: { regex: ',' }\n```\n\n----------------------------------------\n\nTITLE: Named vs Unnamed Node Matching in JavaScript\nDESCRIPTION: Demonstrates the difference between matching named and unnamed nodes in JavaScript return statements using ast-grep patterns.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/core-concepts.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nreturn 123 // `123` is named `number` and matched.\nreturn;    // `;` is unnamed and not matched.\n```\n\n----------------------------------------\n\nTITLE: SgNode Traversal Method Signatures in Python\nDESCRIPTION: Method signatures for traversing the AST in the SgNode class.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass SgNode:\n    def get_root(self) -> SgRoot: ...\n    def field(self, name: str) -> Optional[SgNode]: ...\n    def parent(self) -> Optional[SgNode]: ...\n    def child(self, nth: int) -> Optional[SgNode]: ...\n    def children(self) -> List[SgNode]: ...\n    def ancestors(self) -> List[SgNode]: ...\n    def next(self) -> Optional[SgNode]: ...\n    def next_all(self) -> List[SgNode]: ...\n    def prev(self) -> Optional[SgNode]: ...\n    def prev_all(self) -> List[SgNode]: ...\n```\n\n----------------------------------------\n\nTITLE: Matching Utility Rules in YAML\nDESCRIPTION: This snippet illustrates how to define a matches rule that corresponds with a previously defined utility rule, demonstrating effective structuring for complex queries in AST matching.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_14\n\nLANGUAGE: yaml\nCODE:\n```\nutils:\n  isFunction:\n    any:\n      - kind: function_declaration\n      - kind: function\nrule:\n  matches: isFunction\n```\n\n----------------------------------------\n\nTITLE: Creating a GitHub Action for ast-grep\nDESCRIPTION: Shows an example workflow configuration for using ast-grep in GitHub Actions to automate code linting whenever a commit is pushed.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_7\n\nLANGUAGE: yml\nCODE:\n```\non: [push]\n\njobs:\n  sg-lint:\n    runs-on: ubuntu-latest\n    name: Run ast-grep lint\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n      - name: ast-grep lint step\n        uses: ast-grep/action@v1.4\n```\n\n----------------------------------------\n\nTITLE: Setting Up Neovim LSP with ast-grep\nDESCRIPTION: This Lua snippet configures the Neovim LSP for ast-grep using the nvim-lspconfig plugin. It sets default options such as the command to start ast-grep, filetypes to associate with, and the root directory detection pattern.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_1\n\nLANGUAGE: lua\nCODE:\n```\nrequire('lspconfig').ast_grep.setup({\n  -- these are the default options, you only need to specify\n  -- options you'd like to change from the default\n  cmd = { 'ast-grep', 'lsp' },\n  filetypes = { \"c\", \"cpp\", \"rust\", \"go\", \"java\", \"python\", \"javascript\", \"typescript\", \"html\", \"css\", \"kotlin\", \"dart\", \"lua\" },\n  root_dir = require('lspconfig.util').root_pattern('sgconfig.yaml', 'sgconfig.yml')\n})\n```\n\n----------------------------------------\n\nTITLE: Matching Key-Value Pairs with String Keys in JavaScript Objects\nDESCRIPTION: This YAML configuration defines a rule to match key-value pairs in JavaScript objects where the key is a string. It uses the 'has' relational rule with a 'field' specification to target pairs that have a string as their key.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/core-concepts.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: pair\n  has:\n    field: key\n    kind: string\n```\n\n----------------------------------------\n\nTITLE: Running AST-Grep with Patterns in Shell\nDESCRIPTION: This snippet shows how to invoke the `ast-grep run` command with options to match specific patterns in given paths. It allows users to specify the pattern they want to search for and the paths where the search should occur.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/run.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep run [OPTIONS] --pattern <PATTERN> [PATHS]...\n```\n\n----------------------------------------\n\nTITLE: Defining Rule Directories with YAML Configuration\nDESCRIPTION: This YAML snippet is used to specify directories containing ast-grep rule files within a project repository. It includes the key 'ruleDirs', which lists directories where ast-grep will search for rule files recursively. The snippet illustrates how to organize rules under a 'rules' folder for ast-grep to recognize them.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/project-config.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nruleDirs:\n  - rules\n```\n\n----------------------------------------\n\nTITLE: Applying YAML Rule with ast-grep CLI\nDESCRIPTION: Shows the command to apply a YAML rule file to a Python source file using ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan -r change_func.yml test.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Cases in YAML\nDESCRIPTION: This snippet demonstrates the 'testConfigs' option in 'sgconfig.yml' which allows users to define the directory structure for test cases used by ast-grep. The format supports specifying both the test directory and an optional snapshot directory.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/sgconfig.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntestConfigs:\n- testDir: test\n  snapshotDir: __snapshots__\n- testDir: anotherTestDir\n```\n\n----------------------------------------\n\nTITLE: Specifying Node Kind in AST Matching\nDESCRIPTION: This snippet illustrates how to define a kind rule in YAML, specifying the kind of AST node to match. It is useful for narrowing down matches to specific types of nodes, enhancing the targeting of rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nkind: call_expression\n```\n\n----------------------------------------\n\nTITLE: SgNode Inspection Method Signatures in Python\nDESCRIPTION: Method signatures for inspecting nodes in the SgNode class.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass SgNode:\n    def range(self) -> Range: ...\n    def is_leaf(self) -> bool: ...\n    def is_named(self) -> bool: ...\n    def is_named_leaf(self) -> bool: ...\n    def kind(self) -> str: ...\n    def text(self) -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Function Renaming with YAML Rule in Python\nDESCRIPTION: Shows a Python code snippet that will be transformed by a YAML rule to rename a function from 'foo' to 'baz'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef foo(x):\n    return x + 1\n\ny = foo(2)\nprint(y)\n```\n\n----------------------------------------\n\nTITLE: Edit Interface Definition in TypeScript\nDESCRIPTION: This code snippet defines the `Edit` interface in TypeScript, which is used in `replace` and `commitEdits` methods. It includes fields for specifying the start and end positions of the edit, and the text to be inserted.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\ninterface Edit {\n  startPos: number\n  endPos: number\n  insertedText: string\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Edit Class Definition in Python\nDESCRIPTION: This code snippet defines the `Edit` class in Python, representing an edit operation. It includes fields for specifying the start and end positions of the edit, and the text to be inserted. This class is used in `replace` and `commit_edits` methods for modifying the source code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass Edit:\n    # The start position of the edit\n    start_pos: int\n    # The end position of the edit\n    end_pos: int\n    # The text to be inserted\n    inserted_text: str\n```\n```\n\n----------------------------------------\n\nTITLE: Utilizing the All Composite Rule\nDESCRIPTION: This snippet shows how to define a composite rule that requires all sub-rules to match for a successful query. It illustrates the necessary structure for using the all key with sub-rule definitions.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nall:\n  - kind: call_expression\n  - pattern: console.log($ARG)\n```\n\n----------------------------------------\n\nTITLE: Defining Rule Directories in YAML\nDESCRIPTION: This snippet outlines how to specify directories where ast-grep will look for rule definitions. The 'ruleDirs' option is mandatory and accepts a list of string paths relative to the 'sgconfig.yml' location.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/sgconfig.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nruleDirs:\n- rules\n- anotherRuleDir\n```\n\n----------------------------------------\n\nTITLE: Configuring i18n Key Extraction Rule in YAML\nDESCRIPTION: YAML configuration for ast-grep rule that matches static text nodes and transforms them into i18n key references. Includes pattern matching and exclusion of mustache syntax via regex.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/extract-i18n-key.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: extract-i18n-key\nlanguage: html\nrule:\n  kind: text\n  pattern: $T\n  # skip dynamic text in mustache syntax\n  not: { regex: '\\{\\{.*\\}\\}' }\nfix: \"{{ $('$T') }}\"\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Rewriters for Different Node Types\nDESCRIPTION: This YAML snippet defines two rewriters: one for integer nodes and another for string nodes. It demonstrates how to create rewriters for different types of AST nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nrewriters:\n- id: rewrite-int\n  rule: {kind: integer}\n  fix: integer\n- id: rewrite-str\n  rule: {kind: string}\n  fix: string\n```\n\n----------------------------------------\n\nTITLE: Finding and Accessing Nodes in Python AST\nDESCRIPTION: Example of finding a specific node in the AST and accessing its text.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nnode = root.root()\nstring = node.find(kind=\"string\")\nassert string # assume we can find a string node in the source\nprint(string.text())\n```\n\n----------------------------------------\n\nTITLE: Simplifying Nested Rules in YAML\nDESCRIPTION: This snippet demonstrates how to simplify a nested rule by directly using 'inside' as a key without the need for multiple layers of indentation. It shows that this structure is equivalent to a more verbose representation, aiding readability while maintaining functionality. It highlights the use of a rule that can be written in multiple ways with the same result.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/composite-rule.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\npattern: this.foo\ninside:\n  kind: class_body\n```\n\nLANGUAGE: yaml\nCODE:\n```\nall:\n  - pattern: this.foo\n  - inside:\n      kind: class_body\n```\n\n----------------------------------------\n\nTITLE: Configuring Recursive Type Rewriting in ast-grep\nDESCRIPTION: YAML configuration for ast-grep that recursively transforms Python type annotations from Optional and Union syntax to the pipe (|) syntax. The configuration includes three rewriters that work together to handle nested type expressions by recursively applying transformations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/recursive-rewrite-type.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: recursive-rewrite-types\nlanguage: python\nrewriters:\n# rewrite Optional[T] to T | None\n- id: optional\n  rule:\n    any:\n    - pattern:\n        context: 'arg: Optional[$TYPE]'\n        selector: generic_type\n    - pattern: Optional[$TYPE]\n  # recursively apply rewriters to $TYPE\n  transform:\n    NT:\n      rewrite:\n        rewriters: [optional, unions]\n        source: $TYPE\n  # use the new variable $NT\n  fix: $NT | None\n\n# similar to Optional, rewrite Union[T1, T2] to T1 | T2\n- id: unions\n  language: Python\n  rule:\n    pattern:\n      context: 'a: Union[$$$TYPES]'\n      selector: generic_type\n  transform:\n    UNIONS:\n      # rewrite all types inside $$$TYPES\n      rewrite:\n        rewriters: [ rewrite-unions ]\n        source: $$$TYPES\n        joinBy: \" | \"\n  fix: $UNIONS\n- id: rewrite-unions\n  rule:\n    pattern: $TYPE\n    kind: type\n  # recursive part\n  transform:\n    NT:\n      rewrite:\n        rewriters: [optional, unions]\n        source: $TYPE\n  fix: $NT\n\n# find all types\nrule:\n  kind: type\n  pattern: $TPE\n# apply the recursive rewriters\ntransform:\n  NEW_TYPE:\n    rewrite:\n      rewriters: [optional, unions]\n      source: $TPE\n# output\nfix: $NEW_TYPE\n```\n\n----------------------------------------\n\nTITLE: Example of YAML Configuration Triggering Rule\nDESCRIPTION: This example illustrates how the detection rule can match host and port configurations in YAML. The given configuration for 'server' uses port 8001 which would trigger the detection rule defined above, leading to an error message. The example helps to verify the practical application of the detection YAML rule.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/yaml/find-key-value.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ndb:\n  username: root\n  password: root\nserver:\n  host: 127.0.0.1\n  port: 8001\n```\n\n----------------------------------------\n\nTITLE: Matching Console.log Statements in JavaScript\nDESCRIPTION: Demonstrates how to match complete console.log statements including the semicolon in JavaScript using ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.log(\"Hello\")\nconsole.log(\"World\");\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Rewriters to a Single Source\nDESCRIPTION: This YAML code shows how to apply multiple rewriters to the same source metavariable. It demonstrates the application of both integer and string rewriters to a list of values.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nrule: {pattern: '[$$$LIST]' }\ntransform:\n  NEW_VAR:\n    rewrite:\n      rewriters: [rewrite-num, rewrite-str]\n      source: $$$LIST\n```\n\n----------------------------------------\n\nTITLE: Configuring Language Injections in YAML\nDESCRIPTION: This snippet provides examples for configuring language injections in 'sgconfig.yml'. This allows for defining embedded languages within host languages, including dynamic language detection based on the content of the host.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/sgconfig.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nlanguageInjections:\n- hostLanguage: js\n  rule:\n    pattern: styled.$TAG`$CONTENT`\n  injected: css\n```\n\nLANGUAGE: yaml\nCODE:\n```\nlanguageInjections:\n- hostLanguage: js\n  rule:\n    pattern: styled.$LANG`$CONTENT`\n  injected: [css, scss, less]\n```\n\n----------------------------------------\n\nTITLE: ast-grep JSON Output Example\nDESCRIPTION: This command demonstrates how to run ast-grep with the `--json` flag to output the results in JSON format. It searches for code matching the pattern 'Some($A)' and replaces it with 'None'. The JSON output can be piped to other tools for further processing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"ast-grep run -p 'Some($A)' -r 'None' --json\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Namespace Imports Detection in YAML for Ast-Grep\nDESCRIPTION: YAML configuration that defines pattern matching rules for namespace imports like 'import * as ns from 'mod''. It captures both the namespace alias identifier and the source module.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n# NAMESPACE IMPORTS \n# -------------------------------------------------------\n# eg: (import * as ns from 'mod')\n# -------------------------------------------------------\n- all:\n    - kind: import_statement\n    - has:\n        kind: import_clause\n        has:\n          kind: namespace_import\n          has:\n            # namespace_import's child identifier is the alias\n            kind: identifier\n            pattern: $NAMESPACE_ALIAS\n    - has:\n        field: source\n        pattern: $SOURCE\n```\n\n----------------------------------------\n\nTITLE: Pattern Rule with Strictness Attribute\nDESCRIPTION: This example defines a pattern rule with a strictness attribute, altering the matching algorithm. The 'strictness' field specifies the level of strictness, allowing for more flexible pattern matching.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  context: foo($BAR)\n  strictness: relaxed\n```\n\n----------------------------------------\n\nTITLE: Searching CSS in JavaScript with ast-grep\nDESCRIPTION: Command to search for CSS patterns within JavaScript files using ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nast-grep -p 'background: $COLOR' -C 2\n```\n\n----------------------------------------\n\nTITLE: Configuring AST-grep Rule for Optional to Union Type Rewrite in YAML\nDESCRIPTION: YAML configuration for an AST-grep rule that rewrites Optional[Type] to Type | None in Python code. The rule uses a pattern object with context to correctly identify generic types.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/optional-to-none-union.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: optional-to-none-union\nlanguage: python\nrule:\n  pattern:\n    context: 'a: Optional[$T]'\n    selector: generic_type\nfix: $T | None\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep for React Memoization Removal\nDESCRIPTION: YAML configuration for ast-grep to remove useCallback, memo, and useMemo from React components. It defines two rules: one for useCallback and memo, and another for useMemo.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/reverse-react-compiler.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: rewrite-cache\nlanguage: tsx\nrule:\n  any:\n  - pattern: useCallback($FN, $$$)\n  - pattern: memo($FN, $$$)\nfix: $FN\n---\nid: rewrite-use-memo\nlanguage: tsx\nrule: { pattern: 'useMemo($FN, $$$)' }\nfix: ($FN)()\n```\n\n----------------------------------------\n\nTITLE: Testing Rule Execution in ast-grep - Bash\nDESCRIPTION: Command line instructions to execute tests for the rules configured in ast-grep. It indicates running tests and skipping snapshot tests initially for quicker iteration during development.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/test-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ ast-grep test --skip-snapshot-tests\n```\n\n----------------------------------------\n\nTITLE: Migrating Chai Should Assertions to Expect in TypeScript\nDESCRIPTION: This YAML snippet defines rules to transform Chai 'should' style assertions to 'expect' style. The given patterns show how specific 'should' style usage can be replaced by 'expect' style to improve compatibility with undefined and null values in TypeScript.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/switch-from-should-to-expect.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: should_to_expect_instanceof\nlanguage: TypeScript\nrule:\n  any:\n  - pattern: $NAME.should.be.an.instanceof($TYPE)\n  - pattern: $NAME.should.be.an.instanceOf($TYPE)\nfix: |-\n  expect($NAME).instanceOf($TYPE)\n---\nid: should_to_expect_genericShouldBe\nlanguage: TypeScript\nrule:\n  pattern: $NAME.should.be.$PROP\nfix: |-\n  expect($NAME).to.be.$PROP\n```\n\n----------------------------------------\n\nTITLE: Basic Transform Syntax for YAML Rules\nDESCRIPTION: Demonstrates the basic structure of the transform key with substring and replace operations, allowing manipulation of meta-variables in code transformations\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/transform.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    replace:\n      source: $VAR_NAME\n      replace: regex\n      by: replacement\n  ANOTHER_NEW_VAR:\n    substring:\n      source: $NEW_VAR\n      startChar: 1\n      endChar: -1\n```\n\n----------------------------------------\n\nTITLE: Matching and Extracting Node Information\nDESCRIPTION: Illustrates how to use getMatch and getMultipleMatches methods to extract information from matched nodes in the AST.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst src = `\nconsole.log('hello')\nlogger('hello', 'world', '!')\n`\nconst root = parse(Lang.JavaScript, src).root()\nconst node = root.find('console.log($A)')\nconst arg = node.getMatch(\"A\") // returns SgNode('hello')\narg !== null // true, node is found\narg.text() // returns 'hello'\n// returns [] because $A and $$$A are different\nnode.getMultipleMatches('A')\n\nconst logs = root.find('logger($$$ARGS)')\n// returns [SgNode('hello'), SgNode(','), SgNode('world'), SgNode(','), SgNode('!')]\nlogs.getMultipleMatches(\"ARGS\")\nlogs.getMatch(\"A\") // returns null\n```\n\n----------------------------------------\n\nTITLE: Defining Pytest Context Utilities in YAML\nDESCRIPTION: Utility patterns to identify nodes inside pytest contexts and fixture arguments within test/fixture function parameters.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/refactor-pytest-fixtures.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nutils:\n  is-pytest-context:\n    # Pytest context is a node inside a pytest\n    # test/fixture\n    inside:\n      stopBy: end\n      any:\n        - matches: is-fixture-function\n        - matches: is-test-function\n  is-fixture-arg:\n    # Fixture arguments are identifiers inside the \n    # parameters of a test/fixture function\n    all:\n      - kind: identifier\n      - inside:\n          kind: parameters\n      - matches: is-pytest-context\n```\n\n----------------------------------------\n\nTITLE: Custom stopBy rule for function scope in YAML for ast-grep\nDESCRIPTION: Demonstrates using a custom stopBy rule to find if a node is inside a function named 'test', stopping the search when it encounters any function node.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ninside:\n  stopBy:\n    kind: function\n  pattern: function test($$$) { $$$ }\n```\n\n----------------------------------------\n\nTITLE: ast-grep JSON Output with jq and jless\nDESCRIPTION: This bash command demonstrates how to use ast-grep with the `--json` flag to output the results in JSON format, and then pipe the output to `jq` to extract the `replacement` field from each match object. Finally, the extracted data is piped to `jless` for easy viewing of the JSON data.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n\"ast-grep run -p 'Some($A)' -r 'None' --json | jq '.[].replacement' | jless\"\n```\n\n----------------------------------------\n\nTITLE: JavaScript Diff for Migrating XState v4 to v5\nDESCRIPTION: This code diff demonstrates the migration of XState v4 code to v5 in JavaScript. It replaces deprecated methods (e.g., Machine, interpret) with updated v5 methods (e.g., createMachine, createActor) alongside showing changes in configuration object properties. Dependencies include the updated XState library. The input consists of JavaScript code using XState v4 syntax, resulting in output compliant with v5 upgrades.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/migrate-xstate-v5.md#2025-04-21_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Machine, interpret } from 'xstate'; // [!code --]\\nimport { createMachine, createActor } from 'xstate'; // [!code ++]\\n\\nconst machine = Machine({ /*...*/}); // [!code --]\\nconst machine = createMachine({ /*...*/}); // [!code ++]\\n\\nconst specificMachine = machine.withConfig({ // [!code --]\\nconst specificMachine = machine.provide({ // [!code ++]\\n  actions: { /* ... */ },\\n  guards: { /* ... */ },\\n  services: { /* ... */ }, // [!code --]\\n  actors: { /* ... */ }, // [!code ++]\\n});\\n\\nconst actor = interpret(specificMachine, { // [!code --]\\nconst actor = createActor(specificMachine, { // [!code ++]\\n  /* actor options */\\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Pytest Function Matchers in YAML\nDESCRIPTION: Utility patterns to identify pytest fixture functions and test functions using ast-grep. Matches function definitions with fixture decorators and test functions starting with 'test_'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/refactor-pytest-fixtures.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nutils:\n  is-fixture-function:\n    kind: function_definition\n    follows:\n      kind: decorator\n      has:\n        kind: identifier\n        regex: ^fixture$\n        stopBy: end\n  is-test-function:\n    kind: function_definition\n    has:\n      field: name\n      regex: ^test_\n```\n\n----------------------------------------\n\nTITLE: JavaScript Function Matching Example with Default Strictness\nDESCRIPTION: Demonstrates how ast-grep's default smart matching works by matching both plain and async functions using a simple pattern.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// function $A() {}\nfunction foo() {}    // matched\nasync function bar() {} // matched\n```\n\n----------------------------------------\n\nTITLE: React Hook Pattern Matching Configuration\nDESCRIPTION: YAML configuration showing how to match React Hook function names using regex constraints\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: $HOOK($$$ARGS)\nconstraints:\n  HOOK: { regex: '^use' }\n```\n\n----------------------------------------\n\nTITLE: Rewriting Identifiers with ast-grep CLI\nDESCRIPTION: Demonstrates using the ast-grep CLI with the --rewrite flag to rename an identifier from 'foo' to 'bar' in Python code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nast-grep run --pattern 'foo' --rewrite 'bar' --lang python\n```\n\n----------------------------------------\n\nTITLE: Finding Import Usage with YAML Rules\nDESCRIPTION: This YAML snippet defines a rule for ast-grep to locate usage of a module imported in TypeScript. It identifies identifiers and ensures they are part of an import statement within the program. Required dependencies include the ast-grep tool, and it primarily targets TypeScript identifiers with specific patterns. The rule specification must be tightly integrated within the ast-grep configuration framework.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-usage.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: find-import-usage\nlanguage: typescript\nrule:\n  kind: identifier # ast-grep requires a kind\n  pattern: $MOD   # the identifier to find\n  inside: # find the root\n    stopBy: end\n    kind: program\n    has: # and has the import statement\n      kind: import_statement\n      has: # look for the matching identifier\n        stopBy: end\n        kind: import_specifier\n        pattern: $MOD # same pattern as the usage is enforced here\n```\n\n----------------------------------------\n\nTITLE: Defining a Pattern Object Rule in YAML for ast-grep\nDESCRIPTION: Shows how to use a pattern object to match class field definitions in JavaScript. This approach resolves ambiguity in parsing by providing context and a selector.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  selector: field_definition\n  context: class A { $FIELD = $INIT }\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Rules for Ant Design Vue Migration\nDESCRIPTION: YAML configuration for ast-grep to identify and replace :visible attribute with :open in a-modal and a-tooltip components. The rule uses element matching and tag name constraints to ensure only popup components are affected.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/upgrade-ant-design-vue.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: upgrade-ant-design-vue\nlanguage: HTML\nutils:\n  inside-tag:\n    inside:\n      kind: element\n      stopBy: { kind: element }\n      has:\n        stopBy: { kind: tag_name }\n        kind: tag_name\n        pattern: $TAG_NAME\nrule:\n  kind: attribute_name\n  regex: :visible\n  matches: inside-tag\nconstraints:\n  TAG_NAME:\n    regex: a-modal|a-tooltip\nfix: :open\n```\n\n----------------------------------------\n\nTITLE: Scanning JavaScript in HTML using ast-grep\nDESCRIPTION: Command to use ast-grep scan with a rule file to detect JavaScript alerts in HTML files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nast-grep scan --rule no-alert.yml\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Rule for Detecting Imports without File Extensions\nDESCRIPTION: This YAML configuration defines an ast-grep rule to find import statements (both static and dynamic) that reference files without file extensions. It uses a regex pattern and AST node matching to identify relevant imports.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-file-without-extension.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: find-import-file\nlanguage: js\nrule:\n  regex: \"/[^.]+[^/]$\"\n  kind: string_fragment\n  any:\n    - inside:\n        stopBy: end\n        kind: import_statement\n    - inside:\n        stopBy: end\n        kind: call_expression\n        has:\n          field: function\n          regex: \"^import$\"\n```\n\n----------------------------------------\n\nTITLE: Using Telescope with ast-grep\nDESCRIPTION: This snippet demonstrates how to use the Telescope plugin to invoke ast-grep within Neovim. The usage reflects invoking a structured search through ast-grep using Telescope's interface.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_3\n\nLANGUAGE: vim\nCODE:\n```\nTelescope ast_grep\n```\n\n----------------------------------------\n\nTITLE: Rewriting Barrel Imports in JavaScript\nDESCRIPTION: This code snippet illustrates the initial JavaScript barrel imports that are to be transformed into individual imports using ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/rewriter.md#2025-04-21_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { A, B, C } from './module';\n// rewrite the above to\nimport A from './module/a';\nimport B from './module/b';\nimport C from './module/c';\n```\n\n----------------------------------------\n\nTITLE: Declaration Removal Pattern Rule in YAML\nDESCRIPTION: Complementary AST-grep rule that removes the original variable declaration after it has been converted to use the walrus operator in the if statement.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/use-walrus-operator-in-if.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: remove-declaration\nrule:\n  pattern:\n    context: $VAR = $$$EXPR\n    selector: expression_statement\n  precedes:\n    pattern: \"if $VAR: $$$B\"\nfix: ''\n```\n\n----------------------------------------\n\nTITLE: Inspecting Rule Severity in ast-grep\nDESCRIPTION: Shows how to use the --inspect flag in ast-grep to debug and display the severity levels of enabled rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/severity.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan --inspect entity\n```\n\n----------------------------------------\n\nTITLE: Example Usage of findInFiles Function in TypeScript with AST-Grep\nDESCRIPTION: Demonstrates how to use the findInFiles function to search for member expressions in a specified directory. It shows the configuration of paths and matcher, as well as handling the callback function.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nlet fileCount = await js.findInFiles({\n  paths: ['relative/path/to/code'],\n  matcher: {\n    rule: {kind: 'member_expression'}\n  },\n}, (err, n) => {\n  t.is(err, null)\n  t.assert(n.length > 0)\n  t.assert(n[0].text().includes('.'))\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Recursive Function Detection Rule in YAML\nDESCRIPTION: YAML configuration for detecting recursive function calls in JavaScript using ast-grep. The rule matches a function declaration and then checks for a call to the same function within its body.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nid: recursive-call\nlanguage: JavaScript\nrule:\n  all:\n  - pattern: function $F() { $$$ }\n  - has:\n      pattern: $F()\n      stopBy: end\n```\n\n----------------------------------------\n\nTITLE: Implementing Walrus Operator Pattern Rule in YAML\nDESCRIPTION: AST-grep rule configuration for identifying opportunities to use the walrus operator. The rule matches an if statement that follows a variable assignment and provides a fix to combine them using the := operator.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/use-walrus-operator-in-if.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: use-walrus-operator\nlanguage: python\nrule:\n  pattern: \"if $VAR: $$$B\"\n  follows:\n    pattern:\n      context: $VAR = $$$EXPR\n      selector: expression_statement\nfix: |-\n  if $VAR := $$$EXPR:\n    $$$B\n```\n\n----------------------------------------\n\nTITLE: Outputting Matches in JSON Format\nDESCRIPTION: This option allows the output of scan matches in structured JSON format, which can be customized using additional parameters to control the output style.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n--json[=<STYLE>]\n```\n\n----------------------------------------\n\nTITLE: Identifying Unnecessary useState<boolean> Type in TypeScript React\nDESCRIPTION: Pattern to find and remove unnecessary <boolean> type annotation in useState hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/redundant-usestate-type.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nast-grep -p 'useState<boolean>($A)' -r 'useState($A)'\n```\n\n----------------------------------------\n\nTITLE: Parsing Code from StdIn with ast-grep\nDESCRIPTION: Demonstrates using ast-grep with the `--stdin` flag to read input directly from standard input, useful for processing code streams in a pipeline.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -s https://schedule2021.scipy.org/2022/conference/  |\n  ast-grep -p '<div $$$> $$$ <i>$AUTHORS</i> </div>' --lang html --json --stdin |\n  jq '.[] | .metaVariables | .single.AUTHORS.text'\n```\n\n----------------------------------------\n\nTITLE: Defining Constraints in a Lint Rule in YAML\nDESCRIPTION: This YAML snippet demonstrates how to specify constraints for a rule to limit the types of AST nodes matched. This particular rule constrains matched nodes to be of kind identifier, ensuring that only valid identifiers are logged.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/lint-rule.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($GREET)\nconstraints:\n  GREET:\n    kind: identifier\n```\n\n----------------------------------------\n\nTITLE: Relation and StopBy Type Definitions in Python\nDESCRIPTION: This code snippet defines the `Relation` TypedDict and `StopBy` type alias in Python, used for specifying relational rules. `Relation` extends `Rule` and includes optional `stopBy` and `field` keys. `StopBy` is a union of literal strings \"neighbor\", \"end\", and the `Rule` type itself, allowing to define complex stopping conditions for relational rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n```python\n# Relational Rule Related\nStopBy = Union[Literal[\"neighbor\"], Literal[\"end\"], Rule]\nclass Relation(Rule, total=False):\n    stopBy: StopBy\n    field: str\n```\n```\n\n----------------------------------------\n\nTITLE: Correct AST Pattern Structure\nDESCRIPTION: The proper AST pattern structure that correctly matches struct inheritance including base class and field declarations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/find-struct-inheritance.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nstruct_specifier\n  $SOMETHING\n  base_class_clause\n    $INHERITS\n  field_declaration_list\n    field_declaration\n      $$$BODY\n```\n\n----------------------------------------\n\nTITLE: Efficient Node Finding Using findAll Method in TypeScript with AST-Grep\nDESCRIPTION: Demonstrates a more efficient way of finding all member_expression nodes using the findAll method. This approach reduces the number of FFI calls, resulting in better performance.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst root = sgroot.root()\n// only call FFI `findAll` once\nconst nodes = root.findAll({kind: 'member_expression'})\n```\n\n----------------------------------------\n\nTITLE: Capturing Import Statement Pattern in YAML\nDESCRIPTION: Defines a rule to capture multiple identifiers from an import statement using the $$$IDENTS metavariable.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: import {$$$IDENTS} from './barrel'\n```\n\n----------------------------------------\n\nTITLE: Defining Follows Relational Rule\nDESCRIPTION: This snippet demonstrates the follows relational rule in YAML, which matches if a specified target node appears after another node. The absence of a field option is noted and a sample structure is provided.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_10\n\nLANGUAGE: yaml\nCODE:\n```\nfollows:\n  kind: function_declaration   # a sub rule object\n  stopBy: end                  # stopBy accepts 'end', 'neighbor' or another rule object.\n```\n\n----------------------------------------\n\nTITLE: Inspecting Nodes in Python AST\nDESCRIPTION: Example of inspecting a node in the AST, including retrieving its text and range information.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nroot = SgRoot(\"print('hello world')\", \"python\")\nnode = root.root()\nnode.text() # will return \"print('hello world')\"\n\nrng = node.range()\npos = rng.start # or rng.end, both are `Pos` objects\npos.line # 0, line starts with 0\npos.column # 0, column starts with 0\nrng.end.index # 17, index starts with 0\n```\n\n----------------------------------------\n\nTITLE: Adding Glob Patterns in ast-grep YAML Rules\nDESCRIPTION: This code snippet illustrates how to define glob patterns that determine which files the rule should apply to. This helps in refining the scope of the rule's applicability.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_8\n\nLANGUAGE: YAML\nCODE:\n```\nfiles:\n  - src/**/*.js\n  - src/**/*.ts\n```\n\n----------------------------------------\n\nTITLE: Identifying Unnecessary useState<string> Type in TypeScript React\nDESCRIPTION: Pattern to find and remove unnecessary <string> type annotation in useState hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/redundant-usestate-type.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nast-grep -p 'useState<string>($A)' -r 'useState($A)'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unnecessary and Necessary React Hooks in TypeScript/JavaScript\nDESCRIPTION: Example code showing two unnecessary React hooks (useIAmNotHookActually and useIAmNotHookToo) that don't use any React features, and one necessary hook (useTrueHook) that uses the useEffect hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/unnecessary-react-hook.md#2025-04-21_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useIAmNotHookActually(args) {\n    console.log('Called in React but I dont need to be a hook')\n    return args.length\n}\nconst useIAmNotHookToo = (...args) => {\n    console.log('Called in React but I dont need to be a hook')\n    return args.length\n}\n\nfunction useTrueHook() {\n    useEffect(() => {\n      console.log('Real hook')\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Shell Completions with ast-grep\nDESCRIPTION: This command generates shell completion scripts for different shells, enhancing command-line usability with tab completion.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nast-grep completions <SHELL>\n```\n\n----------------------------------------\n\nTITLE: Configuring no-console-except-error rule in YAML\nDESCRIPTION: YAML configuration for a rule that disallows console methods except for console.error in catch blocks. It defines patterns to match console calls and specifies constraints for allowed methods.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-console-except-catch.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-console-except-error\nlanguage: typescript\nrule:\n  any:\n    - pattern: console.error($$$)\n      not:\n        inside:\n          kind: catch_clause\n          stopBy: end\n    - pattern: console.$METHOD($$$)\nconstraints:\n  METHOD:\n    regex: 'log|debug|warn'\n```\n\n----------------------------------------\n\nTITLE: Overriding Rule Severity via CLI in ast-grep\nDESCRIPTION: Shows how to override the severity level of rules using command-line flags in ast-grep. Multiple rules can be adjusted using different severity flags.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/severity.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan --error rule-id --warning other-rule-id\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Code Example\nDESCRIPTION: Example JavaScript code snippet demonstrating the pattern to be matched by the ast-grep rule. The first line is highlighted to indicate the match.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rule-template.md#2025-04-21_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nvar a = 123\n```\n\n----------------------------------------\n\nTITLE: Conditional Comma Insertion in Function Arguments\nDESCRIPTION: A transform technique to conditionally add a comma when inserting a new argument into an existing function call\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/transform.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nid: add-leading-argument\nlanguage: python\nrule:\n  pattern: $FUNC($$$ARGS)\ntransform:\n  MAYBE_COMMA:\n    replace:\n      source: $$$ARGS\n      replace: '^.+'\n      by: ', '\nfix:\n  $FUNC(new_argument$MAYBE_COMMA$$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Configuring User-Defined Selector in YAML\nDESCRIPTION: Shows how to use a pattern object to explicitly specify the effective node as 'expression_statement' for matching console.log statements.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  context: console.log($$$)\n  selector: expression_statement\n```\n\n----------------------------------------\n\nTITLE: Python Code Example With Diff\nDESCRIPTION: Demonstration of the code changes when applying the walrus operator transformation, shown with diff annotations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/use-walrus-operator-in-if.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\na = foo() # [!code --]\n\nif a: # [!code --]\nif a := foo(): # [!code ++]\n    do_bar()\n```\n\n----------------------------------------\n\nTITLE: Defining Transformations in ast-grep YAML\nDESCRIPTION: This snippet displays how to apply transformations to meta-variables in an ast-grep rule. The transformation specifies how a meta variable should be processed.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\ntransform:\n  NEW_VAR_NAME:      # new variable name\n    replace:         # transform operation\n      source: $ARGS\n      replace: '^.+'\n      by: ', '\n```\n\n----------------------------------------\n\nTITLE: Defining Rule ID in YAML for ast-grep\nDESCRIPTION: This snippet shows how to define a unique identifier for an ast-grep rule in YAML format. The 'id' is mandatory and should be descriptive enough to identify the rule's purpose.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\nid: no-console-log\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rule in ast-grep\nDESCRIPTION: This snippet outlines the process of creating a new rule within the ast-grep framework, including prompts for naming the rule, selecting the programming language, and setting up associated test files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```markdown\n> What is your rule's name? no-eval\n> Choose rule's language JavaScript\nCreated rules at ./rules/no-eval.yml\n> Do you also need to create a test for the rule? Yes\nCreated test at rule-tests/no-eval-test.yml\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Symbol over Proc Rule in YAML\nDESCRIPTION: YAML configuration for an AST-grep rule that matches Ruby proc syntax patterns and provides a fix to convert them to symbol syntax. Includes pattern matching for map, select, and each iterators.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/prefer-symbol-over-proc.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: prefer-symbol-over-proc\nlanguage: ruby\nrule:\n  pattern: $LIST.$ITER { |$V| $V.$METHOD }\nconstraints:\n  ITER:\n    regex: 'map|select|each'\nfix: '$LIST.$ITER(&:$METHOD)'\n```\n\n----------------------------------------\n\nTITLE: JavaScript Import Statement Matching Example\nDESCRIPTION: Demonstrates matching behavior for import statements with different quotation styles under AST strictness level.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport $A from 'lib' // pattern\nimport A1 from 'lib' // match, quotation is ignored\nimport A2 from \"lib\" // match, quotation is ignored\nimport A3 from \"not\" // no match, string_fragment is checked\n```\n\n----------------------------------------\n\nTITLE: Example Go Code for Function Name Pattern Matching\nDESCRIPTION: This Go code snippet demonstrates a function declaration that would be matched by the ast-grep rule. It defines a test function 'TestAbs' which follows the pattern specified in the YAML configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/go/find-func-declaration-with-prefix.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage abs\nimport \"testing\"\nfunc TestAbs(t *testing.T) {\n    got := Abs(-1)\n    if got != 1 {\n        t.Errorf(\"Abs(-1) = %d; want 1\", got)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating YAML Rules with Diagnostics\nDESCRIPTION: This YAML code snippet shows how to define a rule with diagnostic reporting in ast-grep. The rule includes fields such as 'id', 'message', and 'severity', which control the diagnostics displayed in the code editor. These diagnostics help identify and correct code issues by highlighting problematic areas with severity indicators like 'error' or 'warning'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/playground.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-console\nrule:\n  pattern: console.$METHOD($A)\nmessage: Unexpected console\nseverity: warning\n\n---\n\nid: no-debugger\nrule:\n  pattern: debugger\nmessage: Unexpected debugger\nseverity: error\n```\n\n----------------------------------------\n\nTITLE: Executing Single Queries with ast-grep\nDESCRIPTION: This example illustrates how to run a single query using ast-grep with debugging enabled, providing the AST of the query for analysis.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nast-grep run -p 'YOUR_PATTERN' --debug-query\n```\n\n----------------------------------------\n\nTITLE: Defining Host/Port Detection Rule in YAML\nDESCRIPTION: This YAML snippet defines a rule to detect if specific host and port settings are used in the code. It sets an error message to prompt users to change the port to 8000 if the configuration deviates. Required dependencies include a compatible YAML parser and the implementation environment where this detection logic will be executed.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/yaml/find-key-value.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: detect-host-port\nmessage: You are using $HOST on Port $PORT, please change it to 8000\nseverity: error\nrule:\n  any:\n    - pattern: |\n        port: $PORT\n    - pattern: |\n        host: $HOST\n```\n\n----------------------------------------\n\nTITLE: Defining YAML Rule for Detecting Duplicate Exports in Rust\nDESCRIPTION: This YAML configuration defines a rule for detecting potential duplicate exports in Rust code. It checks for 'pub use' statements within a source file that also contains a 'pub mod' declaration for the same module.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/avoid-duplicated-exports.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nid: avoid-duplicate-export\nlanguage: rust\nrule:\n  all:\n     - pattern: pub use $B::$C;\n     - inside:\n        kind: source_file\n        has:\n          pattern: pub mod $A;\n     - has:\n        pattern: $A\n        stopBy: end\n```\n\n----------------------------------------\n\nTITLE: Inspect File/Rule Discovery\nDESCRIPTION: This flag enables inspections of file and rule discovery during scans, outputting how many and why files and rules are skipped, aiding in debugging and understanding scan behavior.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n--inspect <GRANULARITY>\n```\n\n----------------------------------------\n\nTITLE: Using a Has Relational Rule\nDESCRIPTION: This snippet demonstrates a relational rule that matches a target node if it has a descendant that fulfills a specified condition. It showcases the use of the kind, stopBy, and field properties.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nhas:\n  kind: property_identifier    # a sub rule object\n  stopBy: end                  # stopBy accepts 'end', 'neighbor' or another rule object.\n  field: name                  # specify the sub-node in the target\n```\n\n----------------------------------------\n\nTITLE: Example of Barrel Import in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates using a barrel import with multiple identifiers. It follows the conventional format of importing several modules from a single barrel file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/speed-up-barrel-import.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {a, b, c} from './barrel'\n```\n\n----------------------------------------\n\nTITLE: Configuring Side Effect Imports Detection in YAML for Ast-Grep\nDESCRIPTION: YAML configuration that defines pattern matching rules for side effect imports like 'import 'mod''. It identifies import statements that have a source but no import clause.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\n# SIDE EFFECT IMPORTS \n# -------------------------------------------------------\n# eg: (import 'mod')\n# -------------------------------------------------------\n- all:\n    - kind: import_statement\n    - not: # Must NOT have an import_clause\n        has: { kind: import_clause }\n    - has: # But must have a source\n        field: source\n        pattern: $SOURCE\n```\n\n----------------------------------------\n\nTITLE: Type Definition for findInFiles Function in TypeScript with AST-Grep\nDESCRIPTION: Provides the function signature for findInFiles, which is used for parsing multiple files and searching for relevant nodes in parallel Rust threads. This method is recommended for optimal performance when dealing with multiple files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport function findInFiles(\n  /** specify the file path and matcher */\n  config: FindConfig,\n  /** callback function for found nodes in a file */\n  callback: (err: null | Error, result: SgNode[]) => void\n): Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Diff Annotation for Barrel Imports in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates the differences between using a barrel import and replacing it with direct module imports. It employs comments to annotate the changes clearly.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/speed-up-barrel-import.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {a, b, c} from './barrel' // [!code --]\nimport a from './barrel/a' // [!code ++]\nimport b from './barrel/b' // [!code ++]\nimport c from './barrel/c' // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Pattern Object for Complete JSON Snippet\nDESCRIPTION: This YAML configuration shows how to use a pattern object to provide a complete JSON code snippet for matching a key-value pair.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  context: '{ \"a\": 123 }'\n  selector: pair\n```\n\n----------------------------------------\n\nTITLE: Testing Single Rules with ast-grep\nDESCRIPTION: Shows how to test an individual rule file using the ast-grep tool, useful for isolated rule testing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan -r path/to/your/rule.yml\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep YAML Rule for Go Function Name Pattern Matching\nDESCRIPTION: This YAML configuration sets up an ast-grep rule to find Go function declarations with names starting with 'Test'. It uses the 'regex' atomic rule to match the function name pattern.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/go/find-func-declaration-with-prefix.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: test-functions\nlanguage: go\nrule:\n  kind: function_declaration\n  has:\n    field: name\n    regex: Test.*\n```\n\n----------------------------------------\n\nTITLE: Example Fixture Type Hint Rule in YAML\nDESCRIPTION: Rule pattern to add type hints to fixture arguments named 'foo'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/refactor-pytest-fixtures.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  matches: is-fixture-arg\n  regex: ^foo$\nfix: 'foo: int'\n```\n\n----------------------------------------\n\nTITLE: Searching Code with Custom Language\nDESCRIPTION: Command to search for 'print' pattern in Mojo files using ast-grep with the custom language support, demonstrating how to use the -l flag to specify the language.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nast-grep -p \"print\" -l mojo\n```\n\n----------------------------------------\n\nTITLE: Matching String Keys in JavaScript Objects using ast-grep\nDESCRIPTION: This YAML configuration defines a rule to match string nodes that are keys in key-value pairs within JavaScript objects. It uses the 'inside' relational rule with a 'field' specification to target the key of a pair.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/core-concepts.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: string\n  inside:\n    field: key\n    kind: pair\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Removal of Unnecessary useState<string> Type in TypeScript React\nDESCRIPTION: Code diff demonstrating the removal of an unnecessary <string> type annotation in useState hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/redundant-usestate-type.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction Component() {\n  const [name, setName] = useState<string>('React') // [!code --]\n  const [name, setName] = useState('React') // [!code ++]\n}\n```\n\n----------------------------------------\n\nTITLE: Import Transform Configuration in YAML\nDESCRIPTION: Configures the transformation to apply the rewriter to the captured identifiers and join the results with newlines.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  IMPORTS:\n    rewrite:\n      rewriters: [rewrite-identifer]\n      source: $$$IDENTS\n      joinBy: \"\\n\"\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration for GraphQL Custom Language\nDESCRIPTION: Configuration in sgconfig.yml to define GraphQL as a custom language for ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\ncustomLanguages:\n  graphql:\n    libraryPath: graphql.so # the graphql tree-sitter parser dynamic library\n    extensions: [graphql]   # graphql file extension\n    expandoChar: $          # see reference above for explanation\n```\n\n----------------------------------------\n\nTITLE: YAML Rule Configuration for JavaScript Alerts\nDESCRIPTION: A YAML configuration file defining a rule to detect and warn about the use of alert() in JavaScript code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-alert\nlanguage: JavaScript\nseverity: warning\nrule:\n  pattern: alert($MSG)\nmessage: Prefer use appropriate custom UI instead of obtrusive alert call.\n```\n\n----------------------------------------\n\nTITLE: Rule Configuration for Matching Object Accessors in JavaScript\nDESCRIPTION: This YAML configuration demonstrates how to use a rule to match object accessors in JavaScript, using kind and regex properties.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: method_definition\n  regex: '^get|set\\s'\n```\n\n----------------------------------------\n\nTITLE: Modifying the Rule Configurations\nDESCRIPTION: This snippet demonstrates how to revise an existing rule configuration in YAML. It changes both the message and the pattern to enforce better coding standards by banning 'eval'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/scan-project.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n```yml\nid: no-eval\nmessage: Add your rule message here.... # [!code --]\nmessage: Do not use eval! Dangerous! Hazardous! Perilous! # [!code ++]\nseverity: error\nlanguage: JavaScript\nrule:\n  pattern: Your Rule Pattern here... # [!code --]\n  pattern: eval($CODE) # [!code ++]\n```\n```\n\n----------------------------------------\n\nTITLE: Refactoring add_stage_after method calls in Bevy using ast-grep\nDESCRIPTION: Uses ast-grep to refactor 'add_stage_after' method calls to 'configure_set' with 'after' in Bevy Rust code. This addresses changes in system scheduling in Bevy 0.10. Two commands are provided to handle different argument patterns.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nast-grep \\\n  -p '$APP.add_stage_after($STAGE, $OWN_STAGE, SystemStage::parallel())' \\\n  -r '$APP.configure_set($OWN_STAGE.after($STAGE))' -i\n```\n\nLANGUAGE: shell\nCODE:\n```\nast-grep \\\n  -p 'app.add_stage_after($STAGE, $OWN_STAGE, SystemStage::parallel(),)' \\\n  -r 'app.configure_set($OWN_STAGE.after($STAGE))' -i\n```\n\n----------------------------------------\n\nTITLE: Defining SVG Attribute Transformation Rule in YAML\nDESCRIPTION: This YAML configuration specifies a rule for transforming hyphenated SVG attribute names into camelCase. It captures the original property and applies a regex to identify hyphenated attributes specifically within JSX attributes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rename-svg-attribute.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: rewrite-svg-attribute\nlanguage: tsx\nrule:\n  pattern: $PROP            # capture in metavar\n  regex: ([a-z]+)-([a-z])   # hyphenated name\n  kind: property_identifier\n  inside:\n    kind: jsx_attribute     # in JSX attribute\ntransform:\n  NEW_PROP:                 # new property name\n    convert:                # use ast-grep's convert\n      source: $PROP\n      toCase: camelCase     # to camelCase naming\nfix: $NEW_PROP\n```\n\n----------------------------------------\n\nTITLE: Example of incorrect await usage in Promise.all\nDESCRIPTION: TypeScript code snippet demonstrating incorrect usage of await inside a Promise.all array. The second line is highlighted as the problematic part.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-await-in-promise-all.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst [foo, bar] = await Promise.all([\n  await getFoo(),\n  getBar(),\n  (async () => { await getBaz()})(),\n])\n```\n\n----------------------------------------\n\nTITLE: Removing Key-Value Pair YAML Rule in JavaScript\nDESCRIPTION: Defines a YAML rule to remove a key-value pair with the key 'Remove' from a JavaScript object, including trailing comma.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite-code.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nlanguage: javascript\nrule:\n  kind: pair\n  has:\n    field: key\n    regex: Remove\nfix:\n  template: ''\n  expandEnd: { regex: ',' }\n```\n\n----------------------------------------\n\nTITLE: Ruby Rails Controller Example\nDESCRIPTION: Example Rails controller code showing the use of deprecated filter methods that need to be migrated to action methods. Includes before, around, and after filters with various configurations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/migrate-action-filter.md#2025-04-21_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\nclass TodosController < ApplicationController\n  before_filter :authenticate\n  around_filter :wrap_in_transaction, only: :show\n  after_filter do |controller|\n    flash[:error] = \"You must be logged in\"\n  end\n\n  def index\n    @todos = Todo.all\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Searching CSS in HTML using ast-grep CLI\nDESCRIPTION: Demonstrates how to use the ast-grep run command to search for CSS patterns within an HTML file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nast-grep run -p 'color: $COLOR'\n```\n\n----------------------------------------\n\nTITLE: GritQL Pattern Matching and Transformation\nDESCRIPTION: A GritQL query demonstrating pattern matching and code transformation for console logging methods.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_7\n\nLANGUAGE: gritql\nCODE:\n```\n`console.$method($msg)` => `winston.$method($msg)` where {\n  $method <: or {\n    `log` => `debug`,\n    `error` => `warn`\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing MongoDB Client in TypeScript\nDESCRIPTION: This TypeScript example demonstrates how to import the MongoDB Client and initialize a new client with a specified URL. The code snippet showcases a basic asynchronous function setup (`run`) where the imported `MongoClient` class is utilized. It primarily deals with establishing a MongoDB connection, with the key parameter being the connection URL. It targets Node.js environments and presumes prior installation of the mongodb package.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-usage.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { MongoClient } from 'mongodb';\nconst url = 'mongodb://localhost:27017';\nasync function run() {\n  const client = new MongoClient(url);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using nthChild in AST Matching Rules\nDESCRIPTION: In this snippet, the nthChild key is utilized to find nodes based on their index within a parent node's list of children. It demonstrates different ways to specify nthChild using a number, formula, or an object.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\n# a number to match the exact nth child\nnthChild: 3\n```\n\nLANGUAGE: yaml\nCODE:\n```\n# An+B style string to match position based on formula\nnthChild: 2n+1\n```\n\nLANGUAGE: yaml\nCODE:\n```\nnthChild:\n  position: 2n+1\n  reverse: true # default is false\n  ofRule:\n    kind: function_declaration # accepts ast-grep rule\n```\n\n----------------------------------------\n\nTITLE: Program-based DSL Examples\nDESCRIPTION: Examples of programmatic APIs using ast-grep NAPI, JSCodeshift, and Code Property Graph for AST manipulation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parse, Lang } from '@ast-grep/napi'\n\nlet source = `console.log(\"hello world\")`\nconst ast = parse(Lang.JavaScript, source)  // 1. parse the source\nconst root = ast.root()                     // 2. get the root\nconst node = root.find('console.log($A)')   // 3. find the node\nnode.getMatch('A').text()                   // 4. collect the info\n// \"hello world\"\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst j = require('jscodeshift');\n\nconst root = j(`const a = 1; const b = 2;`);\n\nconst types = root.find(j.VariableDeclarator).getTypes();\nconsole.log(types); // Set { 'VariableDeclarator' }\n```\n\nLANGUAGE: scala\nCODE:\n```\nimport io.shiftleft.codepropertygraph.Cpg\nimport io.shiftleft.semanticcpg.language._\n\nobject FindExecCalls {\n  def main(args: Array[String]): Unit = {\n    // Load the C codebase\n    val cpg: Cpg = Cpg.apply(\"path/to/your/codebase\")\n\n    // Find all `exec` function calls and print their locations\n    cpg.call(\"exec\").location.l.foreach(println)\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: ast-grep Pattern Command\nDESCRIPTION: Command line pattern for finding struct inheritance in C++ code using ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/find-struct-inheritance.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nast-grep --lang cpp --pattern '\nstruct $SOMETHING: $INHERITS { $$$BODY; }'\n```\n\n----------------------------------------\n\nTITLE: Initializing and Migrating XState Machines in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates initializing state machines using XState v4 and showcases their migration to v5 syntax. It includes importing functions from XState, creating a machine, and setting configurations with actions, guards, and services. The primary dependencies are the XState library and knowledge of JavaScript. Inputs are configuration objects, and outputs are initialized machines and actors. It highlights the transition to v5 functions such as createMachine and createActor.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/migrate-xstate-v5.md#2025-04-21_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { Machine, interpret } from 'xstate';\\n\\nconst machine = Machine({ /*...*/});\\n\\nconst specificMachine = machine.withConfig({\\n  actions: { /* ... */ },\\n  guards: { /* ... */ },\\n  services: { /* ... */ },\\n});\\n\\nconst actor = interpret(specificMachine, {\\n  /* actor options */\\n});\n```\n\n----------------------------------------\n\nTITLE: Example Java Code with Unused Variable\nDESCRIPTION: Sample Java code demonstrating the detection of unused variables. Shows a case where one variable is unused and another is properly utilized.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/java/no-unused-vars.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nString unused = \"unused\"; // [!code --]\nString used = \"used\";\nSystem.out.println(used);\n```\n\n----------------------------------------\n\nTITLE: Example of Matched Golang Function Call\nDESCRIPTION: This Go code snippet demonstrates a function call that would be matched by the ast-grep rule. The fmt.Println() call is highlighted as the matched expression.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/go/match-function-call.md#2025-04-21_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc main() {\n    fmt.Println(\"OK\")\n}\n```\n\n----------------------------------------\n\nTITLE: AST Node Kind Matching in YAML Configuration\nDESCRIPTION: Shows how to use ast-grep's atomic rule 'kind' to match specific AST nodes in the code structure.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/core-concepts.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: binary_expression\n# matches `1 + 1`\n```\n\n----------------------------------------\n\nTITLE: Python List Comprehension Example\nDESCRIPTION: Example Python code showing a list comprehension used with the any() function that could be optimized to use a generator expression.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/prefer-generator-expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nany([x for x in range(10)])\n```\n\n----------------------------------------\n\nTITLE: Corrected JSX Expression Using Ternary Operator (TSX)\nDESCRIPTION: This TSX code snippet shows the corrected version of the problematic code, using a ternary operator instead of '&&' short circuit. This ensures proper conditional rendering of the JSX element.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/avoid-jsx-short-circuit.md#2025-04-21_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n<div>{ list.length && list.map(i => <p/>) }</div> // [!code --]\n<div>{ list.length ?  list.map(i => <p/>) : null }</div> // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Pattern Object for Disambiguating JavaScript Object Property\nDESCRIPTION: This YAML configuration shows how to use a pattern object to provide context for matching an object property in JavaScript, avoiding ambiguity.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\npattern:\n  context: '{ a: 123 }'\n  selector: pair\n```\n\n----------------------------------------\n\nTITLE: Searching for Method with Placeholder in Java\nDESCRIPTION: An example of a code query with holes, searching for a specific method signature in Java with a placeholder for the method body.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_1\n\nLANGUAGE: java\nCODE:\n```\npublic void actionClose (JButton a, JFrame f) {\n $$$BODY\n}\n```\n\n----------------------------------------\n\nTITLE: SgNode Match Method Signatures in Python\nDESCRIPTION: Method signatures for matching and retrieving meta variables in SgNode.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass SgNode:\n    def get_match(self, meta_var: str) -> Optional[SgNode]: ...\n    def get_multiple_matches(self, meta_var: str) -> List[SgNode]: ...\n    def __getitem__(self, meta_var: str) -> SgNode: ...\n```\n\n----------------------------------------\n\nTITLE: Configuring Rule Severity in YAML for ast-grep\nDESCRIPTION: Demonstrates how to set the severity level for a rule in the ast-grep configuration file. The severity is set to 'error' for the given rule ID.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/severity.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: rule-id\nseverity: error\n# ... more fields\n```\n\n----------------------------------------\n\nTITLE: Diff view of console usage corrections in TypeScript\nDESCRIPTION: Diff representation showing the removal of disallowed console.debug and console.log calls while retaining the allowed console.error in the catch block.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-console-except-catch.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.debug('') // [!code --]\ntry {\n    console.log('hello') // [!code --]\n} catch (e) {\n    console.error(e) // OK\n}\n```\n\n----------------------------------------\n\nTITLE: Ruby Rails Controller Migration Diff\nDESCRIPTION: Diff showing the changes made when migrating from filter methods to action methods in a Rails controller. Demonstrates the before/after state of the code transformation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/migrate-action-filter.md#2025-04-21_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\nclass TodosController < ApplicationController\n  before_action :authenticate  # [!code --]\n  before_filter :authenticate # [!code ++]\n  around_action :wrap_in_transaction, only: :show # [!code --]\n  around_filter :wrap_in_transaction, only: :show # [!code ++]\n  after_action do |controller|  # [!code --]\n     flash[:error] = \"You must be logged in\" # [!code --]\n  end # [!code --]\n  after_filter do |controller| # [!code ++]\n    flash[:error] = \"You must be logged in\" # [!code ++]\n  end # [!code ++]\n\n  def index\n    @todos = Todo.all\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Format String Vulnerability Fix Rule in YAML for ast-grep\nDESCRIPTION: A YAML configuration for ast-grep that detects format string vulnerabilities in C++ code. It matches printf-family functions that don't use an explicit format string specifier and provides an automatic fix by inserting \"%s\" as the format string.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/fix-format-vuln.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: fix-format-security-error\nlanguage: Cpp\nrule:\n  pattern: $PRINTF($S, $VAR)\nconstraints:\n  PRINTF: # a format string function\n    { regex: \"^sprintf|fprintf$\" }\n  VAR: # not a literal string\n    not:\n      any:\n      - { kind: string_literal }\n      - { kind: concatenated_string }\nfix: $PRINTF($S, \"%s\", $VAR)\n```\n\n----------------------------------------\n\nTITLE: Configuration DSL Examples in YAML\nDESCRIPTION: Examples of configuration-based embedded DSLs using YAML for ast-grep and Semgrep pattern matching rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nid: match-function-call\nlanguage: c\nrule:\n  pattern:\n    context: $M($$$);\n    selector: call_expression\n```\n\nLANGUAGE: yaml\nCODE:\n```\nrules:\n  - id: my-pattern-name\n    pattern: |\n      TODO\n    message: \"Some message to display to the user\"\n    languages: [python]\n    severity: ERROR\n```\n\n----------------------------------------\n\nTITLE: Example Pytest Fixture Implementation\nDESCRIPTION: Example Python code showing fixture definition and usage with proposed changes highlighted for renaming.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/refactor-pytest-fixtures.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@pytest.fixture\ndef foo() -> int:\n    return 5\n\n@pytest.fixture(scope=\"function\")\ndef some_fixture(foo: int) -> str:\n    return str(foo)\n\ndef regular_function(foo) -> None:\n    ...\n\ndef test_code(foo: int) -> None:\n    assert foo == 5\n```\n\n----------------------------------------\n\nTITLE: Snapshot Test Execution in ast-grep - Bash\nDESCRIPTION: Demonstrates running snapshot tests and updating snapshots in ast-grep. It uses command-line options to check and accept updates to rule test outputs interactively.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/test-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nast-grep test --interactive\n```\n\n----------------------------------------\n\nTITLE: Mapping Non-standard File Extensions to Languages\nDESCRIPTION: This snippet illustrates how to use 'languageGlobs' in 'sgconfig.yml' to associate languages with files that have non-standard extensions. This configuration enables ast-grep to parse files that would typically be ignored based on their extension.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/sgconfig.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nlanguageGlobs:\n  html: ['*.vue', '*.svelte', '*.astro']\n  json: ['.eslintrc']\n  cpp: ['*.c'] # override the default parsers\n  tsx: ['*.ts'] # useful for rule reuse\n```\n\n----------------------------------------\n\nTITLE: JavaScript examples for 'prototype' property matching\nDESCRIPTION: Provides JavaScript code examples to illustrate which objects match and don't match the rule for finding 'prototype' as a property key.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nvar a = {\n  prototype: anotherObject\n}\n\nvar a = {\n  normalKey: prototype\n}\n```\n\n----------------------------------------\n\nTITLE: Matching Binary Expressions with Custom Operators in YAML\nDESCRIPTION: Demonstrates how to use 'kind' and 'has' fields to match binary expressions with arbitrary operators using double dollar sign meta variables.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_9\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: binary_expression\n  has:\n    field: operator\n    pattern: $$OP\n    # pattern: $OP\n```\n\n----------------------------------------\n\nTITLE: Example of Rust Code with Potential Duplicate Exports\nDESCRIPTION: This Rust code example demonstrates both problematic and acceptable use of exports. The first two lines show potential duplicate exports, while the last two lines show acceptable single exports from different modules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/avoid-duplicated-exports.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub mod foo;\npub use foo::Foo;\npub use foo::A::B;\n\n\npub use aaa::A;\npub use woo::Woo;\n```\n\n----------------------------------------\n\nTITLE: Converting String Cases - YAML\nDESCRIPTION: This YAML snippet guides the `convert` transformation which changes the case of strings in meta-variables. Users specify `toCase` to select the target case (e.g., camelCase, snakeCase) and can provide `separatedBy` to define word separators. The source is a meta-variable prefixed with `$`. This function outputs the converted string respecting the defined case rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml/transformation.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    convert:\n      toCase: kebabCase\n      separatedBy: [underscore]\n      source: $VAR\n```\n\n----------------------------------------\n\nTITLE: Parsing TypeScript AST with Optional Type Information\nDESCRIPTION: This snippet demonstrates how to parse TypeScript code with and without type information. It shows the import of language-specific types and the use of the parse function with type parameters for better performance and type checking.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { parse } from '@ast-grep/napi'\nimport TS from '@ast-grep/napi/lang/TypeScript' // import this can be slow\nconst untyped = parse(Lang.TypeScript, code)\nconst typed = parse<TS>(Lang.TypeScript, code)\n```\n\n----------------------------------------\n\nTITLE: Defining a Rule Pattern in YAML for ast-grep\nDESCRIPTION: This snippet defines the 'rule' object, which specifies the method to find matching AST nodes. The 'pattern' key indicates the criteria for matching nodes in the syntax tree.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\nrule:\n  pattern: console.log($$$ARGS)\n```\n\n----------------------------------------\n\nTITLE: Logic-based Query in CodeQL\nDESCRIPTION: A CodeQL query to identify redundant if statements in Python where the first statement is a pass statement.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_4\n\nLANGUAGE: sql\nCODE:\n```\nfrom If ifstmt, Stmt pass\nwhere pass = ifstmt.getStmt(0) and\n  pass instanceof Pass\nselect ifstmt, \"This 'if' statement is redundant.\"\n```\n\n----------------------------------------\n\nTITLE: Diff Comparison of SVG Attributes Before and After Transformation in TS\nDESCRIPTION: This TS snippet compares the changes made to SVG attributes before and after the transformation from hyphenated to camelCase. The comments indicate the modifications made for better compatibility with React.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rename-svg-attribute.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst element = (\n  <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\">\n    <path d=\"M10 20 L30 40\" stroke-linecap=\"round\" fill-opacity=\"0.5\" /> // [!code --]\n    <path d=\"M10 20 L30 40\" strokeLinecap=\"round\" fillOpacity=\"0.5\" />   // [!code ++]\n  </svg>\n)\n```\n\n----------------------------------------\n\nTITLE: JavaScript Async Function Pattern Matching\nDESCRIPTION: Shows how including 'async' keyword in the pattern affects matching behavior by requiring it in the target code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// async function $A() {}\nfunction foo() {}    // not matched\nasync function bar() {} // matched\n```\n\n----------------------------------------\n\nTITLE: JavaScript examples of await in different loop types\nDESCRIPTION: Provides JavaScript code examples that match the complex relational rule for await expressions inside various loop types.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nwhile (foo) {\n  await bar()\n}\nfor (let i = 0; i < 10; i++) {\n  await bar()\n}\nfor (let key in obj) {\n  await bar()\n}\ndo {\n  await bar()\n} while (condition)\n```\n\n----------------------------------------\n\nTITLE: Example Python Code with Nested Type Annotations\nDESCRIPTION: An example Python code snippet showing a variable with deeply nested type annotations using Optional and Union, which will be transformed by the ast-grep configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/recursive-rewrite-type.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nresults:  Optional[Union[List[Union[str, dict]], str]]\n```\n\n----------------------------------------\n\nTITLE: Diff View of Format String Vulnerability Fixes in JavaScript\nDESCRIPTION: A diff view showing the before and after code changes needed to fix format string vulnerabilities. The fixes add \"%s\" as the format string parameter for all printf-family function calls that were previously vulnerable.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/fix-format-vuln.md#2025-04-21_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// Error\nfprintf(stderr, out); // [!code --]\nfprintf(stderr, \"%s\", out); // [!code ++]\nsprintf(&buffer[2], obj->Text); // [!code --]\nsprintf(&buffer[2], \"%s\", obj->Text); // [!code ++]\nsprintf(buf1, Text_String(TXT_WAITING_FOR_CONNECTIONS)); // [!code --]\nsprintf(buf1, \"%s\", Text_String(TXT_WAITING_FOR_CONNECTIONS)); // [!code ++]\n// OK\nfprintf(stderr, \"%s\", out);\nsprintf(&buffer[2], \"%s\", obj->Text);\nsprintf(buf1, \"%s\", Text_String(TXT_WAITING_FOR_CONNECTIONS));\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Problematic Rust Re-exports\nDESCRIPTION: This code snippet shows an example of duplicated exports in Rust, where items are exposed under multiple paths. This practice is discouraged as it unnecessarily increases the API surface and can cause issues with IDE auto-completion.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/avoid-duplicated-exports.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub mod foo;\npub use foo::Foo;\n\n```\n\n----------------------------------------\n\nTITLE: Timing Single Pattern Execution in ast-grep\nDESCRIPTION: Command to measure the execution time of a single ast-grep pattern against the TypeScript source.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ntime ast-grep run -p '$A && $A()' TypeScript/src --json > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Project for Global Utility Rules\nDESCRIPTION: This YAML snippet demonstrates how to configure an ast-grep project to use global utility rules. It specifies the directories for rules and utilities in the project configuration file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/utility-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nruleDirs:\n  - rules\nutilDirs:\n  - utils\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JavaScript Code Fix with Diff\nDESCRIPTION: Diff representation of the code fix applied by the ast-grep rule. It shows the transformation from using 'var' to 'let' for variable declaration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rule-template.md#2025-04-21_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nvar a = 123 // [!code --]\nlet a = 123 // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Example HTML Template for Migration\nDESCRIPTION: Sample Vue template showing the target components that need migration from :visible to :open prop. Includes both affected components (a-modal, a-tooltip) and unaffected components (a-tag).\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/upgrade-ant-design-vue.md#2025-04-21_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <a-modal :visible=\"visible\">content</a-modal>\n  <a-tooltip :visible=\"visible\" />\n  <a-tag :visible=\"visible\">tag</a-tag>\n</template>\n```\n\n----------------------------------------\n\nTITLE: YAML Pattern Strictness Configuration\nDESCRIPTION: Demonstrates how to configure pattern strictness in a YAML rule definition.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nid: test-pattern-strictness\nlanguage: JavaScript\nrule:\n  pattern:\n    context: $FOO($BAR)\n    strictness: ast\n```\n\n----------------------------------------\n\nTITLE: Starting ast-grep LSP Server via Command Line\nDESCRIPTION: This Bash command runs the ast-grep LSP server with a specified configuration file. The `-c` option allows setting a custom path for the `sgconfig.yml` configuration file, overriding the default root-based configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nast-grep lsp -c <configPath>\n```\n\n----------------------------------------\n\nTITLE: Python Generator Expression Transformation\nDESCRIPTION: Diff showing the transformation from list comprehension to generator expression in Python, demonstrating the removal of square brackets.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/prefer-generator-expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nany([x for x in range(10)]) # [!code --]\nany(x for x in range(10)) # [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Memoization Removal in React Component\nDESCRIPTION: A diff view of the React component before and after the Reverse React Compiler transformation. It shows the removal of useCallback and useMemo, replacing them with regular functions and immediate invocations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/reverse-react-compiler.md#2025-04-21_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = () => {\n  const [count, setCount] = useState(0)\n  const increment = useCallback(() => {     // [!code --]\n    setCount((prevCount) => prevCount + 1)  // [!code --]\n  }, [])                                 // [!code --]\n  const increment = () => {         // [!code ++]\n    setCount((prevCount) => prevCount + 1) // [!code ++]\n  } // [!code ++]\n  const expensiveCalculation = useMemo(() => { // [!code --]\n    // mock Expensive calculation             // [!code --]\n    return count * 2                        // [!code --]\n  }, [count])                             // [!code --]\n  const expensiveCalculation = (() => { // [!code ++]\n    // mock Expensive calculation      // [!code ++]\n    return count * 2                 // [!code ++]\n  })()                            // [!code ++]\n  return (\n    <>\n      <p>Expensive Result: {expensiveCalculation}</p>\n      <button onClick={increment}>{count}</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Sample Vue Template for i18n Extraction\nDESCRIPTION: Example Vue template showing static and dynamic text content to demonstrate where the i18n extraction rule will be applied.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/extract-i18n-key.md#2025-04-21_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <span>Hello</span>\n  <span>{{ text }}</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Refactoring add_system_to_stage method calls in Bevy using ast-grep\nDESCRIPTION: Demonstrates using ast-grep to refactor 'add_system_to_stage' method calls to 'add_system' with 'in_base_set' in Bevy Rust code. This addresses changes in system scheduling in Bevy 0.10.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\nast-grep \\\n  -p '$APP.add_system_to_stage($STAGE, $SYS)' \\\n  -r '$APP.add_system($SYS.in_base_set($STAGE))' -i\n```\n\n----------------------------------------\n\nTITLE: Refactored Message-Passing Worker Implementation\nDESCRIPTION: Refactored implementation using a message-passing model with mpsc channels. The Worker now sends results to a dedicated printer thread instead of sharing a printer instance.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/fearless-concurrency.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Worker {\n    sender: Sender<...>,\n}\n\nimpl Worker {\n    fn search(&self, file: &File) {\n        let results = self.search_in_file(file);\n        self.sender.send(results).unwrap();\n    }\n    // other methods, no generic used\n}\n\nfn main() {\n    let (sender, receiver) = mpsc::channel();\n    let mut printer = StdoutPrinter::new();\n    let printer_thread = thread::spawn(move || {\n        for result in receiver {\n            printer.print(result);\n        }\n    });\n    // spawn worker threads\n}\n```\n\n----------------------------------------\n\nTITLE: Running Queries in JSON Mode with ast-grep\nDESCRIPTION: This snippet showcases the usage of ast-grep with the `--json` flag to output query results in JSON format, facilitating integration with other tools like jq for further data processing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nast-grep run -p 'Some($A)' -r 'None' --json | jq '.[].replacement' | jless\n```\n\n----------------------------------------\n\nTITLE: Ruby Code Transformation Diff\nDESCRIPTION: Demonstration of how the code will be transformed, showing the before and after states using diff notation. Shows conversion from proc syntax to symbol syntax.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/prefer-symbol-over-proc.md#2025-04-21_snippet_2\n\nLANGUAGE: ruby\nCODE:\n```\n[1, 2, 3].select { |v| v.even? }\n[1, 2, 3].select(&:even?)\n(1..100).each { |i| i.to_s }\n(1..100).each(&:to_s)\n\nnot_list.no_match { |v| v.even? }\n```\n\n----------------------------------------\n\nTITLE: JavaScript File with styled-components\nDESCRIPTION: Example JavaScript file using styled-components to demonstrate CSS-in-JS language injection.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nimport styled from 'styled-components';\n\nconst Button = styled.button`\n  background: red;\n  color: white;\n  padding: 10px 20px;\n  border-radius: 3px;\n`\n\nexport default function App() {\n  return <Button>Click Me</Button>\n}\n```\n\n----------------------------------------\n\nTITLE: Python Dictionary Creation Examples\nDESCRIPTION: This code snippet shows two ways to create a dictionary in Python: using the dict() function and using a dictionary literal. It's used to illustrate the transformation goal of the rewriter example.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# dict function call\nd = dict(a=1, b=2)\n# dictionary literal\nd = {'a': 1, 'b': 2}\n```\n\n----------------------------------------\n\nTITLE: Refining Node Searches in Python AST\nDESCRIPTION: Example of refining a node search using the matches method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nnode = root.find(pattern=\"print($A)\")\nif node[\"A\"].matches(kind=\"string\"):\n  print(\"A is a string\")\n```\n\n----------------------------------------\n\nTITLE: Example Usage of parse and Lang in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the `parse` function and `Lang` enum from `@ast-grep/napi` and use them to parse JavaScript source code into an `SgRoot` object. It then shows how to find nodes matching a given pattern using `root.find()`.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { parse, Lang } from '@ast-grep/napi'\n\nconst ast = parse(Lang.JavaScript, source)\nconst root = ast.root()\nroot.find(\"console.log\")\n```\n```\n\n----------------------------------------\n\nTITLE: Efficient Digit Count Calculation in Rust\nDESCRIPTION: This snippet demonstrates an efficient way to calculate the number of digits in a usize number using checked_ilog10. It avoids string allocation and is faster than the string conversion method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/get-digit-count-in-usize.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nnum.checked_ilog10().unwrap_or(0) + 1\n```\n\n----------------------------------------\n\nTITLE: Inefficient Manual Traversal for Finding Member Expressions in TypeScript\nDESCRIPTION: Shows an inefficient way of finding all member_expression nodes by manually traversing the syntax tree. This method results in numerous FFI calls, which can slow down performance.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/performance-tip.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst root = sgroot.root()\nfunction findMemberExpression(node: SgNode): SgNode[] {\n  let ret: SgNode[] = []\n  // `node.kind()` is a FFI call\n  if (node.kind() === 'member_expression') {\n    ret.push(node)\n  }\n  // `node.children()` is a FFI call\n  for (let child of node.children()) {\n    // recursion makes more FFI calls\n    ret = ret.concat(findMemberExpression(child))\n  }\n  return ret\n}\nconst nodes = findMemberExpression(root)\n```\n\n----------------------------------------\n\nTITLE: Refactoring Digit Count Calculation in Rust\nDESCRIPTION: This diff demonstrates the replacement of the inefficient string conversion method with the efficient logarithmic method for calculating digit count in Rust.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/get-digit-count-in-usize.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nlet width = (lines + num).to_string().chars().count(); // [!code --]\nlet width = (lines + num).checked_ilog10().unwrap_or(0) + 1; // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Replacing StageLabel with SystemSet using ast-grep in Rust\nDESCRIPTION: Demonstrates using ast-grep to replace 'StageLabel' with 'SystemSet' in Rust code, addressing another breaking change in the Bevy 0.10 update. The command performs an interactive search and replace operation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p 'StageLabel' -r SystemSet -i\n```\n\n----------------------------------------\n\nTITLE: Configuring Linting Severity in ast-grep YAML\nDESCRIPTION: This snippet shows how to specify the severity level for a rule's matched result in ast-grep. Different levels of severity can control the output of the rule during scanning.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_7\n\nLANGUAGE: YAML\nCODE:\n```\nseverity: warning\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Type Annotation Transformation\nDESCRIPTION: A diff showing the before and after states of the Python code. The deeply nested type annotation is transformed into a flattened pipe-syntax version according to PEP 604 style.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/recursive-rewrite-type.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nresults:  Optional[Union[List[Union[str, dict]], str]] # [!code --]\nresults:  List[str | dict] | str | None #[!code ++]\n```\n\n----------------------------------------\n\nTITLE: Basic ast-grep CLI Usage Pattern\nDESCRIPTION: General syntax for the ast-grep new command, allowing creation of different project components with optional arguments and flags\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/new.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nast-grep new [COMMAND] [OPTIONS] [NAME]\n```\n\n----------------------------------------\n\nTITLE: HTML File with Embedded CSS and JavaScript\nDESCRIPTION: An example HTML file containing embedded CSS and JavaScript, used to demonstrate ast-grep's multi-language search capabilities.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<style>\n  h1 { color: red; }\n</style>\n<h1>\n  Hello World!\n</h1>\n<script>\n  alert('hello world!')\n</script>\n```\n\n----------------------------------------\n\nTITLE: Updated OpenAI SDK Implementation\nDESCRIPTION: Migrated Python code showing the new OpenAI SDK patterns with Client initialization.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/migrate-openai-sdk.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport os\nfrom openai import Client\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\nclient = Client(os.getenv(\"OPENAI_API_KEY\"))\n\n@app.route(\"/chat\", methods=(\"POST\"))\ndef index():\n    animal = request.form[\"animal\"]\n    response = client.completions.create(\n      model=\"text-davinci-003\",\n      prompt=generate_prompt(animal),\n      temperature=0.6,\n    )\n    return jsonify(response.choices)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Byte Offsets with char_indices() in Rust\nDESCRIPTION: This snippet shows how char_indices() correctly handles byte offsets in a UTF-8 encoded string, which is crucial for accurate string manipulation in Rust.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/boshen-footgun.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet yes = \"yes\";\nlet mut char_indices = yes.char_indices();\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'y')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n// note the 3 here - the last character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n```\n\n----------------------------------------\n\nTITLE: Corrected String Iteration Using char_indices() in Rust\nDESCRIPTION: This diff shows the correction from chars().enumerate() to char_indices(), ensuring correct byte offsets when iterating over a Rust string.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/boshen-footgun.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfor (i, char) in source.chars().enumerate() { // [!code --]\nfor (i, char) in source.char_indices() { // [!code ++]\n    println!(\"Boshen is angry :)\");\n}\n```\n\n----------------------------------------\n\nTITLE: Replacing CoreStage with CoreSet using ast-grep in Rust\nDESCRIPTION: Uses ast-grep to replace 'CoreStage' with 'CoreSet' in Rust code, addressing a breaking change in the Bevy 0.10 update. The command searches for 'CoreStage' and replaces it with 'CoreSet' interactively.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p 'CoreStage' -r CoreSet -i\n```\n\n----------------------------------------\n\nTITLE: Example JavaScript Code with Various Import Statements\nDESCRIPTION: This JavaScript code snippet demonstrates different types of import statements, including those with and without file extensions. The lines 1, 5, and 7 show imports without file extensions that would be detected by the ast-grep rule.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-file-without-extension.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport a, {b, c, d} from \"./file\";\nimport e from \"./other_file.js\";\nimport \"./folder/\";\nimport {x} from \"package\";\nimport {y} from \"package/with/path\";\n\nimport(\"./dynamic1\");\nimport(\"./dynamic2.js\");\n\nmy_func(\"./unrelated_path_string\")\n```\n\n----------------------------------------\n\nTITLE: Diff Showing Optional to Union Type Rewrite in Python\nDESCRIPTION: Diff showing the before and after of the Optional to Union type rewrite in Python, demonstrating the change from Optional[Int] to Int | None.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/optional-to-none-union.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef a(arg: Optional[Int]): pass # [!code --]\ndef a(arg: Int | None): pass # [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Running grug-far with ast-grep Engine\nDESCRIPTION: This Vim script shows how to use the grug-far.nvim plugin with ast-grep as its search engine. It allows live searching and replacing through the ast-grep engine.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_4\n\nLANGUAGE: vim\nCODE:\n```\n:lua require('grug-far').grug_far({ engine = 'astgrep' })\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via npm\nDESCRIPTION: Command to install ast-grep globally using npm (Node Package Manager).\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n# install via npm\nnpm i @ast-grep/cli -g\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration for styled-components Injection\nDESCRIPTION: Configuration in sgconfig.yml to define language injection for styled-components CSS in JavaScript files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nlanguageInjections:\n- hostLanguage: js\n  rule:\n    pattern: styled.$TAG`$CONTENT`\n  injected: css\n```\n\n----------------------------------------\n\nTITLE: Python Function Transformation Diff\nDESCRIPTION: Demonstrates the before and after states of the Python code transformation, showing how the async function is converted to a synchronous one.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/remove-async-await.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def main3():\n  await somecall(1, 5)\ndef main3():\n  somecall(1, 5)\n```\n\n----------------------------------------\n\nTITLE: Defining nthChild Rules in YAML for ast-grep\nDESCRIPTION: Demonstrates various ways to use the nthChild rule for selecting nodes based on their position among siblings. Includes examples of exact matching, formula-based matching, and object-style configuration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n# a number to match the exact nth child\nnthChild: 3\n\n# An+B style string to match position based on formula\nnthChild: 2n+1\n\n# object style nthChild rule\nnthChild:\n  # accepts number or An+B style string\n  position: 2n+1\n  # optional, count index from the end of sibling list\n  reverse: true # default is false\n  # optional, filter the sibling node list based on rule\n  ofRule:\n    kind: function_declaration # accepts ast-grep rule\n```\n\n----------------------------------------\n\nTITLE: Ruby Code Examples for Symbol Conversion\nDESCRIPTION: Example Ruby code showing the patterns that will be matched by the rule, including array operations with select and each methods using proc syntax.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/ruby/prefer-symbol-over-proc.md#2025-04-21_snippet_1\n\nLANGUAGE: ruby\nCODE:\n```\n[1, 2, 3].select { |v| v.even? }\n(1..100).each { |i| i.to_s }\nnot_list.no_match { |v| v.even? }\n```\n\n----------------------------------------\n\nTITLE: Diff Showing MobX Component Rewrite in JavaScript\nDESCRIPTION: A diff showing the changes made to rewrite the MobX component. It separates the component function and the observer wrapper to improve ESLint hook rule checking.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rewrite-mobx-component.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Example = observer(() => { // [!code --]\n  return <div>Hello World</div>         // [!code --]\n})                                      // [!code --]\nconst BaseExample = () => {             // [!code ++]\n  return <div>Hello World</div>         // [!code ++]\n}                                       // [!code ++]\nexport const Example = observer(BaseExample) // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Hybrid Query Examples in ast-grep\nDESCRIPTION: Examples showing ast-grep's hybrid approach combining YAML configuration and programmatic API.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  pattern: console.log($A)\n  inside:\n    kind: function_declaration\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Lang, parse } from '@ast-grep/napi'\n\nconst sg = parse(Lang.JavaScript, code)\nsg.root().find({\n  rule: {\n    pattern: 'console.log($A)',\n    inside: {\n      kind: 'function_declaration'\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Including Documentation Links in ast-grep YAML Rules\nDESCRIPTION: This snippet describes how to add a documentation URL to an ast-grep YAML rule. This link provides additional context or guidance for the rule when referenced in an editor extension.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_9\n\nLANGUAGE: YAML\nCODE:\n```\nurl: 'https://ast-grep.github.io/catalog/python/#migrate-openai-sdk'\n```\n\n----------------------------------------\n\nTITLE: Searching for File Creation in Java\nDESCRIPTION: An example of a plain code query to search for instances of creating a temporary file in Java using File.createTempFile().\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_0\n\nLANGUAGE: java\nCODE:\n```\ntry {\n  File file = File.createTempFile(\"foo\", \"bar\");\n} catch (IOException e) {\n}\n```\n\n----------------------------------------\n\nTITLE: Example Java Code Matching Comby Pattern\nDESCRIPTION: An example of Java code that would match the Comby pattern for if statements with comparisons.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nif (width <= 1280 && height <= 800) {\n  return 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via Homebrew\nDESCRIPTION: Command to install ast-grep using the Homebrew package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# install via homebrew\nbrew install ast-grep\n```\n\n----------------------------------------\n\nTITLE: Initial Thread-Safe Printer Implementation in Rust\nDESCRIPTION: Original implementation of a thread-safe Printer trait and StdoutPrinter struct using Mutex for synchronization across multiple threads. The printer implements Send + Sync traits to enable thread safety.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/fearless-concurrency.md#2025-04-21_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\ntrait Printer: Send + Sync {\n    fn print(&self, result: ...);\n}\n\n// demo Printer implementation\nstruct StdoutPrinter {\n    // output is shared between threads\n    output: Mutex<Stdout>,\n}\nimpl Printer for StdoutPrinter {\n    fn print(&self, result: ...) {\n        // lock the output to print\n        let stdout = self.output.lock().unwrap();\n        writeln!(stdout, \"{}\", result).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Diff of Migrated Chai Assertions in JavaScript\nDESCRIPTION: This JavaScript snippet shows both the original 'should' style and the new 'expect' style assertions side-by-side using a diff view. It visually differentiates between the old and new styles, marking them with comments for clarity.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/switch-from-should-to-expect.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nit('should produce an instance of chokidar.FSWatcher', () => {\n  watcher.should.be.an.instanceof(chokidar.FSWatcher); // [!code --]\n  expect(watcher).instanceOf(chokidar.FSWatcher); // [!code ++]\n});\nit('should expose public API methods', () => {\n  watcher.on.should.be.a('function');   // [!code --]\n  watcher.emit.should.be.a('function'); // [!code --]\n  watcher.add.should.be.a('function');  // [!code --]\n  watcher.close.should.be.a('function'); // [!code --]\n  watcher.getWatched.should.be.a('function'); // [!code --]\n  expect(watcher.on).to.be.a('function'); // [!code ++]\n  expect(watcher.emit).to.be.a('function'); // [!code ++]\n  expect(watcher.add).to.be.a('function'); // [!code ++]\n  expect(watcher.close).to.be.a('function'); // [!code ++]\n  expect(watcher.getWatched).to.be.a('function'); // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Language Support in TypeScript\nDESCRIPTION: Updates the lang.ts file to add support for a new programming language in the ast-grep playground. This involves adding the WebAssembly parser path and the display name for the language in the configuration objects.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\n// Add language parserPaths\nconst parserPaths = {\n  // ...\n  swift: 'tree-sitter-swift.wasm', // [!code ++]\n}\n\n// Add language display name\nexport const languageDisplayNames: Record<SupportedLang, string> = {\n  // ...\n  swift: 'Swift',\n}\n```\n\n----------------------------------------\n\nTITLE: Example of MobX Component Before Rewrite in JavaScript\nDESCRIPTION: An example of a MobX component using the observer function directly on the export. This style can cause issues with ESLint hook rule checking.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rewrite-mobx-component.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport const Example = observer(() => {\n  return <div>Hello World</div>\n})\n```\n\n----------------------------------------\n\nTITLE: YAML Configuration for GraphQL Injection in JavaScript\nDESCRIPTION: Configuration in sgconfig.yml to define language injection for GraphQL in JavaScript files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\nlanguageInjections:\n- hostLanguage: js\n  rule:\n    pattern: graphql`$CONTENT`\n  injected: graphql\n```\n\n----------------------------------------\n\nTITLE: Example C++ Struct Inheritance\nDESCRIPTION: Sample C++ code demonstrating the struct inheritance pattern that will be matched.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/find-struct-inheritance.md#2025-04-21_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Bar: Baz {\n  int a, b;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Various Import and Require Patterns in TypeScript\nDESCRIPTION: This code snippet demonstrates a comprehensive collection of import and require patterns in TypeScript, including named imports, default imports, namespace imports, side-effect imports, type imports, CommonJS require patterns, destructured requires, dynamic imports, and various formatting styles. Line 60 is highlighted to emphasize a specific import pattern.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n//@ts-nocheck\n// Named import\nimport { testing } from './tests';\n\n// Aliased import\nimport { testing as test } from './tests2';\n\n// Default import\nimport hello from 'hello_world1';\n\n// Namespace import\nimport * as something from 'hello_world2';\n\n// Side-effect import\nimport '@fastify/static';\n\n// Type import\nimport {type hello1243 as testing} from 'hello';\n\n// Require patterns\nconst mod = require('some-module');\nrequire('polyfill');\n\n// Destructured require\nconst { test122, test2 } = require('./destructured1');\n// Aliased require\nconst { test122: test123, test2: test23, test3: test33 } = require('./destructured2');\n\n// Mixed imports\nimport defaultExport, { namedExport } from './mixed';\nimport defaultExport2, * as namespace from './mixed2';\n\n\n// Multiple import lines from the same file\nimport { one, two as alias, three } from './multiple';\nimport { never, gonna, give, you, up } from './multiple';\n\n// String literal variations\nimport { test1 } from \"./double-quoted\";\nimport { test2 } from './single-quoted';\n\n// Multiline imports\nimport {\n    longImport1,\n    longImport2 as alias2,\n    longImport3\n} from './multiline';\n\n// Dynamic imports\nconst dynamicModule = import('./dynamic1');\nconst {testing, testing123} = import('./dynamic2');\nconst asyncDynamicModule = await import('./async_dynamic1').then(module => module.default);\n// Aliased dynamic import\nconst { originalIdentifier: aliasedDynamicImport} = await import('./async_dynamic2');\n\n// Comments in imports\nimport /* test */ { \n    // Comment in import\n    commentedImport \n} from './commented'; // End of line comment \n```\n\n----------------------------------------\n\nTITLE: Updating Documentation Comments in Rust\nDESCRIPTION: This code diff updates documentation comments in Rust to properly add systems to stages using the Bevy framework. These changes are necessary for ensuring that documentation tests pass by adhering to the current API.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -137,8 +137,8 @@\n-//!         .add_system_to_stage(BigBrainStage::Actions, drink_action_system)\n-//!         .add_system_to_stage(BigBrainStage::Scorers, thirsty_scorer_system)\n+//!         .add_system(drink_action_system.in_set(BigBrainStage::Actions))\n+//!         .add_system(thirsty_scorer_system.in_set(BigBrainStage::Scorers))\n```\n\n----------------------------------------\n\nTITLE: Barrel Import Example - Original Code\nDESCRIPTION: Example of a barrel import pattern in JavaScript that imports multiple modules from a single file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport {a, b, c} from './barrel';\n```\n\n----------------------------------------\n\nTITLE: Problematic Rewrite Scenarios\nDESCRIPTION: Examples showing the limitations of simple find-and-replace patterns for complex transformations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// we cannot rewrite the whole import statements\n// because we don't know how to rewrite a, b, c as a list\nimport ??? from './barrel';\n// we cannot rewrite each identifier\n// because the replaced text is inside the import statement\nimport { ??, ??, ?? } from './barrel';\n```\n\n----------------------------------------\n\nTITLE: Vue Template i18n Extraction Diff\nDESCRIPTION: Diff output showing the transformation of static text into i18n key references while preserving dynamic content.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/extract-i18n-key.md#2025-04-21_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <span>Hello</span> // [!code --]\n  <span>{{ $('Hello') }}</span> // [!code ++]\n  <span>{{ text }}</span>\n</template>\n```\n\n----------------------------------------\n\nTITLE: SgRoot Class Definition in Python\nDESCRIPTION: Definition of the SgRoot class, showing its constructor and root method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass SgRoot:\n    def __init__(self, src: str, language: str) -> None: ...\n    def root(self) -> SgNode: ...\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Languages in YAML\nDESCRIPTION: This snippet shows the syntax for specifying custom languages under the 'customLanguages' section of 'sgconfig.yml'. Users can define a custom language with its library path and associated file extensions, although this feature is marked experimental.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/sgconfig.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ncustomLanguages:\n  mojo:\n      libraryPath: mojo.so     # path to dynamic library\n      extensions: [mojo, ]   # file extensions for this language\n      expandoChar: _           # optional char to replace $ in your pattern\n```\n\n----------------------------------------\n\nTITLE: Python Code Example Before Refactoring\nDESCRIPTION: Example Python code showing the target pattern before applying the walrus operator transformation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/use-walrus-operator-in-if.md#2025-04-21_snippet_2\n\nLANGUAGE: python\nCODE:\n```\na = foo()\n\nif a:\n    do_bar()\n```\n\n----------------------------------------\n\nTITLE: Barrel Import Example - Transformed Code\nDESCRIPTION: The desired transformation output showing individual imports for each module.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/find-n-patch.md#2025-04-21_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport a from './barrel/a';\nimport b from './barrel/b';\nimport c from './barrel/c';\n```\n\n----------------------------------------\n\nTITLE: Using llms.txt for AST-Grep Documentation\nDESCRIPTION: Steps to utilize llms.txt format for accessing ast-grep documentation through AI chatbots. This approach improves the accuracy of LLM responses by providing comprehensive context.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/more-llm-support.md#2025-04-21_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n1. Visit https://ast-grep.github.io/llms-full.txt and copy the full documentation text\n2. Paste these documents into your conversation with your preferred AI chatbot\n3. Ask AI questions about ast-grep\n```\n\n----------------------------------------\n\nTITLE: Transformed C Code with Function Calls\nDESCRIPTION: The resulting C code after transformation, showing the converted function calls with proper pointer handling and argument passing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/rewrite-method-to-function-call.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nvoid test_func() {\n    some_struct->field.method(); // [!code --]\n    method(&some_struct->field); // [!code ++]\n    some_struct->field.other_method(1, 2, 3); // [!code --]\n    other_method(&some_struct->field, 1, 2, 3); // [!code ++]\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Swift to WASM Language Enum - Rust\nDESCRIPTION: This snippet shows how to add a new language variant for Swift to the WasmLang enum in wasm_lang.rs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// new variant\npub enum WasmLang {\n  // ...\n  Swift, // [!code ++]\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Ignoring Hidden Files\nDESCRIPTION: This option ensures that the scanning process does not respect any hidden files or directories that are typically ignored based on standard ignore files like .gitignore.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\n--no-ignore <FILE_TYPE>\n```\n\n----------------------------------------\n\nTITLE: Yoda Condition Transformation Diff\nDESCRIPTION: Diff showing the transformation from regular equality comparison to Yoda condition style, where the number literal is moved to the left side of the comparison.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/yoda-condition.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nif (myNumber == 42) { /* ... */} // [!code --]\nif (42 == myNumber) { /* ... */} // [!code ++]\nif (notMatch == another) { /* ... */}\nif (notMatch) { /* ... */}\n```\n\n----------------------------------------\n\nTITLE: Before and After Migration Diff\nDESCRIPTION: Diff showing the changes made by the migration rule, demonstrating how :visible is replaced with :open only in a-modal and a-tooltip components while leaving a-tag unchanged.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/html/upgrade-ant-design-vue.md#2025-04-21_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n<template>\n  <a-modal :visible=\"visible\">content</a-modal>\n  <a-modal :open=\"visible\">content</a-modal>\n  <a-tooltip :visible=\"visible\" />\n  <a-tooltip :open=\"visible\" />\n  <a-tag :visible=\"visible\">tag</a-tag>\n</template>\n```\n\n----------------------------------------\n\nTITLE: Executing ast-grep Pattern Matching in Shell\nDESCRIPTION: Shell command to run ast-grep with a specified pattern and rewrite rule for JavaScript files. It demonstrates both the fixing and non-fixing versions of the command.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rule-template.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p pattern -r rewrite -l js\n# or without fixer\nast-grep -p pattern -l js\n```\n\n----------------------------------------\n\nTITLE: Defining a Range Object for Node Positioning\nDESCRIPTION: This snippet shows how to define a range object in YAML that specifies the start and end positions of an AST node. The start and end are defined with line and column numbers, facilitating precise node matching.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/rule.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrange:\n  start:\n    line: 0\n    column: 0\n  end:\n    line: 0\n    column: 3\n```\n\n----------------------------------------\n\nTITLE: RuleObject TypeScript Interface\nDESCRIPTION: This TypeScript code defines the `RuleObject` interface, representing the structure of a rule object in ast-grep. It includes properties for atomic, relational, and composite rules, along with related interfaces like `Pattern` and `Relation`. It's intended as a reference for understanding the rule object's structure.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n\"interface RuleObject {\n  // atomic rule\n  pattern?: string | Pattern\n  kind?: string\n  regex?: string\n  // relational rule\n  inside?: RuleObject & Relation\n  has?: RuleObject & Relation\n  follows?: RuleObject & Relation\n  precedes?: RuleObject & Relation\n  // composite rule\n  all?: RuleObject[]\n  any?: RuleObject[]\n  not?: RuleObject\n  matches?: string\n}\n\n// See Atomic rule for explanation\ninterface Pattern {\n  context: string\n  selector: string\n  strictness?: Strictness\n}\n\n// See https://ast-grep.github.io/advanced/match-algorithm.html\ntype Strictness =\n  | 'cst'\n  | 'smart'\n  | 'ast'\n  | 'relaxed'\n  | 'signature'\n\n// See Relation rule for explanation\ninterface Relation {\n  stopBy?: 'neighbor' | 'end' | RuleObject\n  field?: string\n}\"\n```\n\n----------------------------------------\n\nTITLE: Example JavaScript Function for Recursive Call Detection\nDESCRIPTION: A sample JavaScript function that demonstrates a recursive call, which can be detected by the corresponding ast-grep rule.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nfunction recurse() {\n  foo()\n  recurse()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Tree-sitter Grammar Rules in JavaScript\nDESCRIPTION: Demonstrates how to define grammar rules in Tree-sitter, showing the difference between named and unnamed nodes. Named nodes are defined with a format 'kind: parseRule' while unnamed nodes are defined with string literals.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/core-concepts.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nrules: {\n  // named nodes are defined with the format `kind: parseRule`\n  identifier: $ => /[a-z]+/,\n  // binary_expression is also a named node,\n  // the `+` operator is defined with a string literal, so it is an unnamed node\n  binary_expression: $ => seq($.identifier, '+', $.identifier),\n                                          //  unnamed node\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Tree-sitter for WASM - Bash\nDESCRIPTION: This snippet provides the commands to set up Tree-sitter in order to prepare for building a WASM file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_7\n\nLANGUAGE: Bash\nCODE:\n```\n\"\"\"bash\ntree-sitter generate # if grammar is not generated before\ntree-sitter build --wasm\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Reading Input from Standard Input\nDESCRIPTION: Enables the tool to accept code directly from standard input, which is useful for processing code streams dynamically.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n--stdin\n```\n\n----------------------------------------\n\nTITLE: Matching Console Log in JavaScript using AST Expressions\nDESCRIPTION: This JavaScript snippet illustrates the detailed process of matching a 'console.log' call in an AST context, emphasizing the complexity involved in AST manipulations with tools like Babel compared to ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/introduction.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\npath.parentPath.isMemberExpression() &&\npath.parentPath.get('object').isIdentifier({ name: 'console' }) &&\npath.parentPath.get('property').isIdentifier({ name: 'log' })\n```\n\n----------------------------------------\n\nTITLE: Defining Range for AST Node Matching in YAML\nDESCRIPTION: This YAML snippet defines a `range` rule that matches source code nodes based on their start and end positions. The rule accepts a `range` object that specifies `start` and `end` fields, which include line and column information. The provided example will match the first three characters of the first line in the source code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  range:\n    start:\n      line: 0\n      column: 0\n    end:\n      line: 1\n      column: 5\n```\n\n----------------------------------------\n\nTITLE: Configuring ast-grep Rule for Matching C Function Calls\nDESCRIPTION: This YAML configuration defines an ast-grep rule to match function calls in C code. It uses a contextual pattern and a selector to accurately identify call expressions.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/match-function-call.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: match-function-call\nlanguage: c\nrule:\n  pattern:\n    context: $M($$$);\n    selector: call_expression\n```\n\n----------------------------------------\n\nTITLE: Simplified Console Log Pattern Matching using AST-Grep in Shell Script\nDESCRIPTION: This snippet illustrates how easily one can search for 'console.log' statements in JavaScript using ast-grep, simplifying a task that would normally require extensive code for AST manipulation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/introduction.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nast-grep -p \"console.log\"\n```\n\n----------------------------------------\n\nTITLE: Compiling Mojo Parser with GCC\nDESCRIPTION: Specific GCC command to compile the Mojo language parser as a dynamic library, including necessary flags and paths for the Mojo grammar.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ngcc -shared -fPIC -fno-exceptions -g -I 'src' -o mojo.so -O2 src/scanner.cc -xc src/parser.c -lstdc++\n```\n\n----------------------------------------\n\nTITLE: Using stopBy with 'end' in YAML for ast-grep\nDESCRIPTION: Shows how to use the stopBy option with 'end' value to make ast-grep search for surrounding nodes until it reaches the end of the scope.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nhas:\n  stopBy: end\n  pattern: $MY_PATTERN\n```\n\n----------------------------------------\n\nTITLE: Wiring Rewriters with Other ast-grep Fields\nDESCRIPTION: This snippet illustrates how to combine rewriters with other ast-grep fields to create a complete rule. It includes a pattern match and a fix using the transformed variable.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule: { pattern: a = $OLD_VAR }\n# ... rewriters and transform\nfix: a = $NEW_VAR\n```\n\n----------------------------------------\n\nTITLE: Creating a Union Type for All AST Node Kinds in TypeScript\nDESCRIPTION: Defines a Kinds type that represents all possible AST node types, including resolved aliases and a fallback string type. This creates a more robust API while maintaining good type inference and completion.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ntype Kinds<M> = ResolveType<M, keyof M> & LowPriorityString\ntype LowPriorityString = string & {}\n```\n\n----------------------------------------\n\nTITLE: Inspecting Project Directory with ast-grep\nDESCRIPTION: This bash command uses the '--inspect summary' flag to display the current project directory and path to the configuration file in use by ast-grep. This assists users in verifying which directory and configuration are being applied during a scan operation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/project-config.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan --inspect summary\n```\n\n----------------------------------------\n\nTITLE: Example TypeScript AST Node Definition\nDESCRIPTION: Concrete example of a TypeScript function declaration node type definition using Tree-sitter's type structure.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype TypeScript = {\n  // AST node type definition\n  function_declaration: {\n    type: \"function_declaration\", // kind\n    named: true,                  // is named\n    fields: {\n      body: {\n        types: [ { type: \"statement_block\", named: true } ]\n      },\n    }\n  },\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing Files with Tree-sitter CLI\nDESCRIPTION: Command to parse and display the AST (Abstract Syntax Tree) of a file using the Tree-sitter CLI, useful for inspecting how a custom parser interprets code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\ntree-sitter parse [file_path]\n```\n\n----------------------------------------\n\nTITLE: Refactoring add_system_set_to_stage method calls in Bevy using ast-grep\nDESCRIPTION: Uses ast-grep to refactor 'add_system_set_to_stage' method calls to 'add_systems' with 'in_set' in Bevy Rust code. This addresses changes in system set handling in Bevy 0.10.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\nast-grep \\\n  -p '$APP.add_system_set_to_stage($STAGE, $SYS,)' \\\n  -r '$APP.add_systems($SYS.in_set($STAGE))' -i\n```\n\n----------------------------------------\n\nTITLE: Example of Problematic '&&' Short Circuit in JSX (TSX)\nDESCRIPTION: This TSX code snippet demonstrates the problematic use of '&&' short circuit in JSX, where a number (list.length) is used on the left side of '&&'. This can lead to unexpected rendering of '0' instead of the intended JSX element.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/avoid-jsx-short-circuit.md#2025-04-21_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n<div>{ list.length && list.map(i => <p/>) }</div>\n```\n\n----------------------------------------\n\nTITLE: Using __getitem__ for Node Matching in Python\nDESCRIPTION: Example of using __getitem__ for safer node matching with type checking.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nnode = root.find(pattern=\"print($A)\")\n# node.get_match(\"A\").text() # error: node.get_match(\"A\") can be None\nnode[\"A\"].text() # Ok\n```\n\n----------------------------------------\n\nTITLE: Correct Pattern Object for Matching Class Fields\nDESCRIPTION: A proper way to match class fields in JavaScript using ast-grep's pattern object. This approach provides full context for parsing and selects the specific node type.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\n# this is one single pattern rule!\npattern:\n  context: 'class A { a = 123 }' # provide full context code\n  selector: field_definition     # select the effective pattern\n```\n\n----------------------------------------\n\nTITLE: Defining a Regex Rule in YAML for ast-grep\nDESCRIPTION: Shows how to use a regex rule to match AST nodes based on their text content. This example matches any word character sequence.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  regex: \"\\w+\"\n```\n\n----------------------------------------\n\nTITLE: Invalid Pattern for Binary Expression in JavaScript\nDESCRIPTION: This snippet demonstrates an invalid pattern for matching binary expressions. The pattern is not parsed correctly because it's seen as three consecutive identifiers separated by spaces.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$LEFT $OP $RIGHT\n```\n\n----------------------------------------\n\nTITLE: Project Directory and Configuration Output Format\nDESCRIPTION: This output indicates the results of using the '--inspect summary' option, showing whether the scan has identified the project as valid and displaying the project directory path. The format resembles pipeline-delimited key-value pairs typically included in summary inspections.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/project-config.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nsg: summary|project: isProject=true,projectDir=/path/to/project\n```\n\n----------------------------------------\n\nTITLE: Registering Ruby in SupportLang Enum - Rust\nDESCRIPTION: This snippet demonstrates how to register the new Ruby language in the SupportLang enum within lib.rs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// lib.rs\npub enum SupportLang {\n  ...\n  Ruby, // [!code ++]\n  ...\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Cloning Mojo Grammar Repository\nDESCRIPTION: Command to clone a mock Tree-sitter grammar for Mojo language from GitHub, which will be used as an example for custom language integration.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/HerringtonDarkholme/tree-sitter-mojo.git\n```\n\n----------------------------------------\n\nTITLE: Building Tree-sitter Parser as Dynamic Library\nDESCRIPTION: Command to compile a Tree-sitter parser as a dynamic library using the tree-sitter build command, which generates a shared object file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ntree-sitter build --output mojo.so\n```\n\n----------------------------------------\n\nTITLE: Example of SVG Element with Hyphenated Attributes in TSX\nDESCRIPTION: This TSX code snippet illustrates how an SVG element is defined with hyphenated attributes, which need to be transformed for compatibility with React. The primary attributes include width, height, and a path with hyphenated properties.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/rename-svg-attribute.md#2025-04-21_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst element = (\n  <svg width=\"100\" height=\"100\" viewBox=\"0 0 100 100\">\n    <path d=\"M10 20 L30 40\" stroke-linecap=\"round\" fill-opacity=\"0.5\" />\n  </svg>\n)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Nested Links Detection in React Components\nDESCRIPTION: This TSX code snippet shows two React components: one with an incorrect nested link structure that would be flagged by the rule, and another with a correct single link implementation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/avoid-nested-links.md#2025-04-21_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction Component() {\n  return <a href='/destination'>\n    <a href='/anotherdestination'>Nested link!</a>\n  </a>;\n}\nfunction OkayComponent() {\n  return <a href='/destination'>\n    I am just a link.\n  </a>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ast-grep to Replace chars().enumerate() with char_indices() in Rust\nDESCRIPTION: This shell command uses ast-grep to find and replace instances of chars().enumerate() with char_indices() in Rust files, addressing the character vs byte offset issue.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/boshen-footgun.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p '$A.chars().enumerate()' \\\n   -r '$A.char_indices()' \\\n   -l rs\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep Python Library\nDESCRIPTION: Command to install the ast-grep Python library using pip.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install ast-grep-py\n```\n\n----------------------------------------\n\nTITLE: Configuring Unused Suppression Reporting in ast-grep\nDESCRIPTION: Demonstrates how to configure ast-grep to report unused suppression comments and modify the severity of these reports using CLI flags.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/severity.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# treat unused directive as error, useful in CI/CD\nast-grep scan --error unused-suppression\n# enable report even not all rules are enabled\nast-grep --rule rule.yml scan --hint unused-suppression\n```\n\n----------------------------------------\n\nTITLE: Invalid Pattern for Object Accessors in JavaScript\nDESCRIPTION: This snippet shows an invalid pattern for matching object accessors in JavaScript. The meta-variable is not parsed as the keywords 'get' and 'set'.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nobj = { $KIND foo() { } }\n```\n\n----------------------------------------\n\nTITLE: Example of Unnecessary useState<string> Type in TypeScript React Component\nDESCRIPTION: Example showing a React component with an unnecessary <string> type annotation in useState hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/redundant-usestate-type.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction Component() {\n  const [name, setName] = useState<string>('React')\n}\n```\n\n----------------------------------------\n\nTITLE: Timing ast-grep After Rule Matching Optimization\nDESCRIPTION: Command to measure the execution time of ast-grep after implementing the potential_kinds optimization for rule matching.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan -c eslint/sgconfig.yml TypeScript/src --json > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Manually Compiling Tree-sitter Parser\nDESCRIPTION: Generic GCC command for manually compiling a Tree-sitter parser as a dynamic library, specifying various compilation parameters and paths.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngcc -shared -fPIC -fno-exceptions -g -I {header_path} -o {lib_path} -O2 {scanner_path} -xc {parser_path} {other_flags}\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Cargo in Rust\nDESCRIPTION: This snippet demonstrates how to run tests using Rust's cargo test command and displays test failures related to the execution order of systems. It highlights a panic caused by incompatible configurations in the plugin.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nrunning 1 test\n\ntest steps ... FAILED\n\nfailures:\n\n---- steps stdout ----\nsteps test\nthread 'steps' panicked at '`\"Update\"` and `\"Cleanup\"` have a `before`-`after` relationship (which may be transitive) but share systems.'\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n```\n\n----------------------------------------\n\nTITLE: Example Async Python Function\nDESCRIPTION: Sample Python code showing an async function that will be transformed. Contains an async function definition with an await call inside.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/remove-async-await.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def main3():\n  await somecall(1, 5)\n```\n\n----------------------------------------\n\nTITLE: Handling Swift in execute_lang_method Macro for WASM - Rust\nDESCRIPTION: This snippet demonstrates how to handle the new Swift language variant in the execute_lang_method macro in wasm_lang.rs.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// handle variant in macro\nmacro_rules! execute_lang_method {\n  ($me: path, $method: ident, $($pname:tt),*) => {\n    use WasmLang as W;\n    match $me {\n      W::Swift => L::Swift.$method($($pname,)*), // [!code ++]\n    }\n  }\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep NAPI Package with pnpm\nDESCRIPTION: Command to install the ast-grep NAPI package using pnpm package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @ast-grep/napi\n```\n\n----------------------------------------\n\nTITLE: Example React Component with Memoization\nDESCRIPTION: A sample React component using useState, useCallback, and useMemo hooks. This example demonstrates the type of code that the Reverse React Compiler targets for transformation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/reverse-react-compiler.md#2025-04-21_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = () => {\n  const [count, setCount] = useState(0)\n  const increment = useCallback(() => {\n    setCount((prevCount) => prevCount + 1)\n  }, [])\n  const expensiveCalculation = useMemo(() => {\n    // mock Expensive calculation\n    return count * 2\n  }, [count])\n\n  return (\n    <>\n      <p>Expensive Result: {expensiveCalculation}</p>\n      <button onClick={increment}>{count}</button>\n    </>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Code Diff for Fixing Configuration in Rust Plugin\nDESCRIPTION: This code diff adjusts the system configuration in a Rust plugin by changing methods related to the stage configuration. It addresses a bug regarding system execution order to resolve test failures.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\n--- a/src/lib.rs\n+++ b/src/lib.rs\n@@ -225,7 +225,7 @@ impl Plugin for BigBrainPlugin {\n-        app.configure_set(BigBrainStage::Scorers.after(First));\n+        app.configure_set(BigBrainStage::Scorers.in_base_set(First));\n@@ -242,12 +242,12 @@ impl Plugin for BigBrainPlugin {\n-        app.configure_set(BigBrainStage::Actions.after(PreUpdate));\n+        app.configure_set(BigBrainStage::Actions.in_base_set(PreUpdate));\n```\n\n----------------------------------------\n\nTITLE: Refining Node Types for Specific and General Cases in TypeScript\nDESCRIPTION: Implements the RefineNode type to bridge the gap between general and specific node types. This utility type preserves general node behavior when needed and refines to specific types when possible, improving type inference and narrowing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntype RefineNode<M, K> = string extends K ? SgNode<M, K> : // one SgNode\n  K extends keyof M ? SgNode<M, K> : never  // distribute over union\n```\n\n----------------------------------------\n\nTITLE: Configuring Schema Validation for YAML\nDESCRIPTION: This YAML comment is used to add schema validation for the ast-grep rule files. It requires installing a VSCode extension that supports YAML schema validation, like YAML by Red Hat, to provide autocompletion and error-checking features.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# yaml-language-server: $schema=https://raw.githubusercontent.com/ast-grep/ast-grep/main/schemas/rule.json\n```\n\n----------------------------------------\n\nTITLE: Incorrect Order of Rules for Recursive Function Detection\nDESCRIPTION: An example of incorrectly ordered rules in YAML that fail to detect recursive function calls due to the 'has' rule being applied before the function pattern is matched.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nid: recursive-call\nlanguage: JavaScript\nrule:\n  all:\n  - has:\n      pattern: $F()\n      stopBy: end\n  - pattern: function $F() { $$$ }\n```\n\n----------------------------------------\n\nTITLE: Final Timing of Optimized ast-grep\nDESCRIPTION: Command to measure the final execution time of ast-grep after all optimizations, including merging rules to avoid duplicate tree traversal.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nast-grep scan -c eslint/sgconfig.yml TypeScript/src --json > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Using Metavariables in ast-grep Python API\nDESCRIPTION: Example showing that metavariables like $A are not automatically replaced in the Python API unlike the CLI. Developers need to manually handle metavariable replacement using the get_match method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_18\n\nLANGUAGE: markdown\nCODE:\n```\n# \"logger.log('bye world')\"\n```\n\n----------------------------------------\n\nTITLE: Inspecting AST Nodes\nDESCRIPTION: Shows how to use various inspection methods like text(), range(), isLeaf(), and kind() to examine properties of AST nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/js-api.md#2025-04-21_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst ast = parse(Lang.JavaScript, \"console.log('hello world')\")\nroot = ast.root()\nroot.text() // will return \"console.log('hello world')\"\n\nconst rng = node.range()\nconst pos = rng.start // or rng.end, both are `Pos` objects\npos.line // 0, line starts with 0\npos.column // 0, column starts with 0\nrng.end.index // 17, index starts with 0\n```\n\n----------------------------------------\n\nTITLE: Specifying Threads for Scanning\nDESCRIPTION: This option allows users to set the approximate number of threads to use during the scan, with a default of 0, which lets the tool automatically determine an optimal thread count.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n-j, --threads <NUM>\n```\n\n----------------------------------------\n\nTITLE: Generating Shell Completion Scripts with ast-grep\nDESCRIPTION: Generates a shell completion script for the specified shell environment. The output script facilitates command line completion for ast-grep commands. Supports major shell environments by inferring the environment or taking a user-specified shell type.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nast-grep completions [SHELL]\n```\n\n----------------------------------------\n\nTITLE: Example of Chai Assertion Migration in JavaScript\nDESCRIPTION: This JavaScript code snippet provides examples of using Chai's 'should' style assertions to describe expected behaviors. The aim here is to demonstrate the process of migrating these assertions to 'expect' style, which is achieved through provided transformation rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/switch-from-should-to-expect.md#2025-04-21_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nit('should produce an instance of chokidar.FSWatcher', () => {\n  watcher.should.be.an.instanceof(chokidar.FSWatcher);\n});\nit('should expose public API methods', () => {\n  watcher.on.should.be.a('function');\n  watcher.emit.should.be.a('function');\n  watcher.add.should.be.a('function');\n  watcher.close.should.be.a('function');\n  watcher.getWatched.should.be.a('function');\n});\n```\n\n----------------------------------------\n\nTITLE: Following Symbolic Links\nDESCRIPTION: This flag allows the scanning process to follow symbolic links in directories. By default, scanning does not follow these links, but this can be enabled for more thorough evaluations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n--follow\n```\n\n----------------------------------------\n\nTITLE: Installing coc-ast-grep with vim-plug\nDESCRIPTION: This Vim script installs the coc-ast-grep extension using vim-plug for the coc.nvim plugin. It requires coc.nvim to be installed, and the command includes dependency installation through yarn.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/editors.md#2025-04-21_snippet_2\n\nLANGUAGE: vim\nCODE:\n```\nPlug 'yaegassy/coc-ast-grep', {'do': 'yarn install --frozen-lockfile'}\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Git Hooks\nDESCRIPTION: This command installs pre-commit hooks for automatic code quality checks. Pre-commit helps ensure code style and quality by running checks before each commit.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"pre-commit install\"\n```\n\n----------------------------------------\n\nTITLE: Reduced AST Structure Example\nDESCRIPTION: Shows the simplified Abstract Syntax Tree with only named nodes retained.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\nimport_statement\n  import_clause\n    identifier      // $A\n  string\n    string_fragment // lib\n```\n\n----------------------------------------\n\nTITLE: Timing ast-grep Execution Before Optimization\nDESCRIPTION: Command to measure the execution time of ast-grep before optimization, using the 'time' command.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ntime ast-grep scan -c eslint/sgconfig.yml TypeScript/src\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints in ast-grep YAML Rules\nDESCRIPTION: This snippet demonstrates how to include constraints in an ast-grep rules YAML configuration. Constraints allow for additional filtering of matched nodes based on specific criteria.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/yaml.md#2025-04-21_snippet_3\n\nLANGUAGE: YAML\nCODE:\n```\nconstraints:\n  ARG:\n    kind: number\n```\n\n----------------------------------------\n\nTITLE: Example Python Code with Optional Type Annotation\nDESCRIPTION: Example Python function definition using Optional[Int] as a type annotation for the argument.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/optional-to-none-union.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef a(arg: Optional[Int]): pass\n```\n\n----------------------------------------\n\nTITLE: Starting a Language Server with ast-grep\nDESCRIPTION: Starts a language server for diagnostics and editor integration. Requires a config file and can be integrated with compatible editors to provide real-time code analysis. Outputs diagnostic information which is useful for continuous code quality checks.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nast-grep lsp\n```\n\n----------------------------------------\n\nTITLE: Example Rust Code with indoc! Macro\nDESCRIPTION: This Rust code snippet demonstrates the use of the indoc! macro with a raw string literal containing CSS-like content. The highlighted lines show the part that will be transformed by the ast-grep command.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/rewrite-indoc-macro.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    indoc! {r#\"\n        .foo {\n            order: 1;\n        }\n    \"#};\n}\n```\n\n----------------------------------------\n\nTITLE: Ineffective Combination of 'kind' and 'pattern' Rules\nDESCRIPTION: An example of a rule that incorrectly attempts to combine 'kind' and 'pattern' rules to match a class field in JavaScript. This approach doesn't work as intended in ast-grep.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/faq.md#2025-04-21_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\n# these are two separate rules\npattern: a = 123          # rule 1\nkind: field_definition    # rule 2\n```\n\n----------------------------------------\n\nTITLE: Creating New Git Branch for Migration\nDESCRIPTION: Git command to create and switch to a new branch for the migration process\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit checkout -b upgrade-bevy\n```\n\n----------------------------------------\n\nTITLE: Example of Incorrect String Iteration in Rust\nDESCRIPTION: This code snippet demonstrates the problematic use of chars().enumerate() for string iteration in Rust, which can lead to incorrect character offsets.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/boshen-footgun.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfor (i, char) in source.chars().enumerate() {\n    println!(\"Boshen is angry :)\");\n}\n```\n\n----------------------------------------\n\nTITLE: CLI Strictness Configuration Example\nDESCRIPTION: Shows how to configure pattern strictness using the CLI command.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nast-grep run -p '$FOO($BAR)' --strictness ast\n```\n\n----------------------------------------\n\nTITLE: Installing Flamegraph Profiling Tool in Rust\nDESCRIPTION: Command to install the flamegraph profiling tool using Cargo, Rust's package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install flamegraph\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Language in sgconfig.yml\nDESCRIPTION: YAML configuration for registering a custom language (Mojo) in ast-grep's project configuration file, specifying the library path, file extensions, and expandoChar for meta-variables.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\n# sgconfig.yml\nruleDirs: [\"./rules\"]\ncustomLanguages:\n  mojo:\n      libraryPath: mojo.so     # path to dynamic library\n      extensions: [mojo, ]   # file extensions for this language\n      expandoChar: _           # optional char to replace $ in your pattern\n```\n\n----------------------------------------\n\nTITLE: SgNode Search Method Signatures in Python\nDESCRIPTION: Method signatures for the find and find_all methods of SgNode class.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/api-usage/py-api.md#2025-04-21_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass SgNode:\n    @overload\n    def find(self, **kwargs: Unpack[Rule]) -> Optional[SgNode]: ...\n    @overload\n    def find_all(self, **kwargs: Unpack[Rule]) -> List[SgNode]: ...\n    @overload\n    def find(self, config: Config) -> Optional[SgNode]: ...\n    @overload\n    def find_all(self, config: Config) -> List[SgNode]: ...\n```\n\n----------------------------------------\n\nTITLE: Common Cargo Commands\nDESCRIPTION: These are common cargo commands used in Rust projects. They are used for running tests, checking code, running clippy, and formatting code respectively.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo test     # Run test\ncargo check    # Run checking\ncargo clippy   # Run clippy\ncargo fmt      # Run formatting\"\n```\n\n----------------------------------------\n\nTITLE: Testing Rules with ast-grep\nDESCRIPTION: This shell command is used to execute tests on ast-grep rules. It requires specifying a configuration file and optionally a directory for storing test YAML files. Other options allow for selective testing with glob patterns and updating snapshots. Dependencies include configured test directories and the necessary YAML files. The command checks the validity of test code and generates reports based on the test outcomes, facilitating the verification of rule correctness.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nast-grep test [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Rewriting indoc! Macro with ast-grep in Shell\nDESCRIPTION: This command uses ast-grep to find and rewrite indoc! macro invocations, replacing them with backtick-quoted strings. It captures the content of the raw string literal and wraps it in backticks.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/rewrite-indoc-macro.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nast-grep --pattern 'indoc! { r#\"$$$A\"# }' --rewrite '`$$$A`' sgtest.rs\n```\n\n----------------------------------------\n\nTITLE: Handling Document Test Failures in Rust\nDESCRIPTION: This snippet shows a failed document test due to a missing method in the Bevy framework. It illustrates the need for manual fixes in the documentation comments to ensure that they are processed correctly by the documentation tool.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\n---- src/lib.rs - (line 127) stdout ----\nerror[E0599]:\n  no method named `add_system_to_stage` found for mutable reference\n    `&mut bevy::prelude::App`\n  in the current scope\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Vue Component\nDESCRIPTION: This snippet demonstrates the setup of a Vue.js component in a single-file component format. It imports the 'App' component from the specified path and initializes it in the template. No additional dependencies are required beyond Vue.js itself.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/playground.md#2025-04-21_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport App from './src/App.vue'\n</script>\n\n<App/>\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark\nDESCRIPTION: These commands are used for running benchmark. They navigate to the benches directory, and run the cargo bench command.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n\"cd benches\ncargo bench\"\n```\n\n----------------------------------------\n\nTITLE: Controlling Output Color\nDESCRIPTION: This option determines when to use colored output in the terminal, with a default setting of 'auto', which dynamically adapts based on the output destination.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n--color <WHEN>\n```\n\n----------------------------------------\n\nTITLE: Running ast-grep without language specification\nDESCRIPTION: Command to run ast-grep without specifying the language, allowing it to infer based on file extensions.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n# ast-grep will infer languages based on file extensions\nast-grep -p '$PROP && $PROP()' TypeScript/src\n```\n\n----------------------------------------\n\nTITLE: JavaScript File with Embedded GraphQL\nDESCRIPTION: Example JavaScript file using Relay with embedded GraphQL query to demonstrate language injection.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_9\n\nLANGUAGE: js\nCODE:\n```\nimport React from \"react\"\nimport { graphql } from \"react-relay\"\n\nconst artistsQuery = graphql`\n  query ArtistQuery($artistID: String!) {\n    artist(id: $artistID) {\n      name\n      ...ArtistDescription_artist\n    }\n  }\n`\n```\n\n----------------------------------------\n\nTITLE: Releasing a New Version\nDESCRIPTION: This command uses `cargo xtask` to bump the version and create a git tag. `cargo xtask` automates various release-related tasks. The version number is provided as an argument.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n\"cargo xtask [version-number]\"\n```\n\n----------------------------------------\n\nTITLE: Filtering Scans with Regex\nDESCRIPTION: Allows filtering which rules to scan based on a regular expression match against rule IDs. This is particularly useful for narrowing down the evaluation within a large set of rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n--filter <REGEX>\n```\n\n----------------------------------------\n\nTITLE: Example C Code for Yoda Condition Check\nDESCRIPTION: Sample C code showing various conditional statements, with the first line demonstrating a match for the Yoda condition pattern where a number literal is compared on the right side.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/yoda-condition.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nif (myNumber == 42) { /* ... */}\nif (notMatch == another) { /* ... */}\nif (notMatch) { /* ... */}\n```\n\n----------------------------------------\n\nTITLE: Installing Tree-sitter CLI via npm\nDESCRIPTION: Command to install the Tree-sitter CLI tool globally using npm, which is required for compiling custom language parsers.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -g tree-sitter-cli\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Deprecated js Object in TypeScript\nDESCRIPTION: This code snippet demonstrates how to import the deprecated `js` object from `@ast-grep/napi` and use it to parse JavaScript source code into an `SgRoot` object. This example illustrates the usage of the deprecated API before its removal.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\nimport { js } from '@ast-grep/napi'\n\nconst source = `console.log(\"hello world\")`\nconst ast = js.parse(source)\n```\n```\n\n----------------------------------------\n\nTITLE: Ambiguous JavaScript Pattern\nDESCRIPTION: This JavaScript snippet demonstrates an ambiguous pattern that could be interpreted as either an object key-value pair or a labeled statement.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\na: 123\n```\n\n----------------------------------------\n\nTITLE: Setting up ast-grep in zsh for Autocompletion\nDESCRIPTION: Illustrates the setup required to enable shell autocompletions for ast-grep in zsh by evaluating the generated script in the shell initialization file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tooling-overview.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\neval \"$(ast-grep completions)\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Language Trait - Rust\nDESCRIPTION: This snippet illustrates how to implement the language trait for Ruby using a macro in the lib.rs file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// lib.rs\nimpl_lang_expando!(Ruby, language_ruby, ''); // [!code ++]\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Original OpenAI SDK Implementation\nDESCRIPTION: Example Python code using the old OpenAI SDK patterns with Flask web framework.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/python/migrate-openai-sdk.md#2025-04-21_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\nimport openai\nfrom flask import Flask, jsonify\n\napp = Flask(__name__)\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\n\n@app.route(\"/chat\", methods=(\"POST\"))\ndef index():\n    animal = request.form[\"animal\"]\n    response = openai.Completion.create(\n        model=\"text-davinci-003\",\n        prompt=generate_prompt(animal),\n        temperature=0.6,\n    )\n    return jsonify(response.choices)\n```\n\n----------------------------------------\n\nTITLE: Checking ast-grep installation\nDESCRIPTION: Commands to verify the installation of ast-grep by displaying the help information.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nast-grep --help\n# if you are not on Linux\nsg --help\n```\n\n----------------------------------------\n\nTITLE: Inline Rules for Quick Testing\nDESCRIPTION: Enables users to scan codebases with rules defined directly in the command line, which is useful for quick tests without creating external YAML files.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n--inline-rules <RULE_TEXT>\n```\n\n----------------------------------------\n\nTITLE: Original C Code with Method-Style Calls\nDESCRIPTION: Example C code showing the original method-style calls on struct fields that need to be transformed.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/rewrite-method-to-function-call.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nvoid test_func() {\n    some_struct->field.method();\n    some_struct->field.other_method(1, 2, 3);\n}\n```\n\n----------------------------------------\n\nTITLE: Timing ast-grep After Regex Optimization\nDESCRIPTION: Command to measure the execution time of ast-grep after optimizing regex handling.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntime ast-grep scan -c eslint/sgconfig.yml TypeScript/src --json > /dev/null\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Vue Component for ast-grep Rule Catalog\nDESCRIPTION: This Vue script imports and renders a Catalog component, likely containing the list of ast-grep rewriting rules. It uses the <script setup> syntax, indicating Vue 3 Composition API usage.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/index.md#2025-04-21_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport Catalog from '../src/catalog/index.vue'\n</script>\n\n<Catalog/>\n```\n\n----------------------------------------\n\nTITLE: Final Test Results in Rust Project\nDESCRIPTION: This snippet provides the final output of the test results after running the `cargo test` command, showing successful test completion without failures.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\ntest result: ok. 21 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 4.68s\n```\n\n----------------------------------------\n\nTITLE: Incomplete JSON Pattern\nDESCRIPTION: This JSON snippet is an incomplete pattern that won't be parsed correctly by ast-grep because it's missing the enclosing curly braces.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/pattern-parse.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n\"a\": 123\n```\n\n----------------------------------------\n\nTITLE: Cloning TypeScript repository\nDESCRIPTION: Git command to clone the TypeScript repository for demonstration purposes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:microsoft/TypeScript.git --depth 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Parser Function for Ruby - Rust\nDESCRIPTION: This snippet depicts the function to implement the Tree-sitter Ruby parser within the parsers.rs file based on feature flags.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n#[cfg(feature = \"builtin-parser\")]\nmod parser_implementation  {\n  ...\n  pub fn language_ruby() -> TSLanguage { // [!code ++]\n    tree_sitter_ruby::language().into()  // [!code ++]\n  }                                      // [!code ++]\n  ...\n}\n\n#[cfg(not(feature = \"builtin-parser\"))]\nmod parser_implementation  {\n  impl_parsers!(\n    ...\n    language_ruby, // [!code ++]\n    ...\n  );\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Stable Version\nDESCRIPTION: This command uses rustup to install the stable version of the Rust toolchain. rustup is a tool for managing Rust versions and associated tools.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\"rustup install stable\"\n```\n\n----------------------------------------\n\nTITLE: Scanning with Single Rule File\nDESCRIPTION: This option allows scanning the codebase using a specific rule defined in a rule file, with a conflict against using a configuration file, making it suitable for single-rule evaluations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/scan.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n-r, --rule <RULE_FILE>\n```\n\n----------------------------------------\n\nTITLE: Cargo xtask example\nDESCRIPTION: The example demonstrates the usage of cargo xtask. xtask is a tool to automate releasing versions of the project.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\nnull\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via Package Managers\nDESCRIPTION: Commands for installing the ast-grep tool using either Cargo or Homebrew package managers\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# install the binary `ast-grep`\ncargo install ast-grep\n# or use brew\nbrew install ast-grep\n```\n\n----------------------------------------\n\nTITLE: Cloning Repository for Migration\nDESCRIPTION: Git command to clone the big-brain repository for demonstration purposes\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:HerringtonDarkholme/big-brain.git\n```\n\n----------------------------------------\n\nTITLE: Adding Built-in Parser Feature in Cargo.toml - Rust\nDESCRIPTION: This snippet shows how to add the Tree-sitter Ruby dependency to the built-in parser feature in the Cargo.toml file.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n\"\"\"toml\n# Cargo.toml\n[features]\nbuiltin-parser = [\n  ...\n  \"tree-sitter-ruby\",  // [!code ++]\n  ...\n]\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Config TypedDict Definition in Python\nDESCRIPTION: This code snippet defines the `Config` TypedDict in Python, representing a configuration object. It includes fields for defining rules, constraints, utils, and transform. It's similar to the YAML rule config used in the CLI.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n```python\nclass Config(TypedDict, total=False):\n    rule: Rule\n    constraints: Dict[str, Mapping]\n    utils: Dict[str, Rule]\n    transform: Dict[str, Mapping]\n```\n```\n\n----------------------------------------\n\nTITLE: Trying ast-grep in nix-shell\nDESCRIPTION: Command to try ast-grep in a nix-shell environment.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# try ast-grep in nix-shell\nnix-shell -p ast-grep\n```\n\n----------------------------------------\n\nTITLE: Searching GraphQL in JavaScript with ast-grep\nDESCRIPTION: Command to search for GraphQL fragment spreads within JavaScript files using ast-grep scan with inline rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/language-injection.md#2025-04-21_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nast-grep scan --inline-rules=\"{id: test, language: graphql, rule: {kind: fragment_spread}}\"\n```\n\n----------------------------------------\n\nTITLE: Adding Dependencies in Cargo.toml - Rust\nDESCRIPTION: This snippet demonstrates how to add the Tree-sitter Ruby crate as an optional dependency in the Cargo.toml file of the language crate.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_0\n\nLANGUAGE: TOML\nCODE:\n```\n\"\"\"toml\n# Cargo.toml\n[dependencies]\n...\ntree-sitter-ruby = {version = \"0.20.0\", optional = true } // [!code ++]\n...\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Generating New Cargo Lock File\nDESCRIPTION: Command to check code and generate new Cargo.lock file with updated dependencies\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\ncargo check\n```\n\n----------------------------------------\n\nTITLE: Configuring Vue Blog Page with Frontmatter\nDESCRIPTION: Vue template that configures a blog index page using frontmatter metadata and imports a BlogIndex component to render the content. The frontmatter disables sidebar and outline features.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog.md#2025-04-21_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n---\nsidebar: false\noutline: false\n---\n\n# ast-grep Blog\n\n<script setup>\nimport BlogIndex from './src/BlogIndex.vue'\n</script>\n\n<BlogIndex/>\n```\n\n----------------------------------------\n\nTITLE: Implementing FromStr for WASM Language Enum - Rust\nDESCRIPTION: This snippet illustrates how to implement the FromStr trait for the WasmLang enum to support conversion from string to enum variant.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// impl FromStr\nimpl FromStr for WasmLang {\n  // ...\n  fn from_str(s: &str) -> Result<Self, Self::Err> {\n    Ok(match s {\n      \"swift\" => Swift, // [!code ++]\n    })\n  }\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registering Ruby in all_langs Array - Rust\nDESCRIPTION: This snippet demonstrates how to include Ruby in the all_langs definition in lib.rs, ensuring it's recognized as a supported language.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// lib.rs\n// Add new lang in [`all_langs`](https://github.com/ast-grep/ast-grep/blob/be10ff97d6d5adad4b524961d82e40ca76ab4259/crates/language/src/lib.rs#L143)\n\n// Add new lang in [`alias`](https://github.com/ast-grep/ast-grep/blob/be10ff97d6d5adad4b524961d82e40ca76ab4259/crates/language/src/lib.rs#L188)\n\n// Add new lang in [`extension`](https://github.com/ast-grep/ast-grep/blob/be10ff97d6d5adad4b524961d82e40ca76ab4259/crates/language/src/lib.rs#L281)\n\n// Add new lang in [`file_types`](https://github.com/ast-grep/ast-grep/blob/be10ff97d6d5adad4b524961d82e40ca76ab4259/crates/language/src/lib.rs#L331)\n\nSee this [commit](https://github.com/ast-grep/ast-grep/commit/ffe14ceb8773c5d2b85559ff7455070e2a1a9388#diff-1f2939360f8f95434ed23b53406eac0aa8b2f404171b63c6466bbdfda728c82d) for the detailed code change. \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing ast-grep via MacPorts\nDESCRIPTION: Command to install ast-grep using the MacPorts package manager.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# install via MacPorts\nsudo port install ast-grep\n```\n\n----------------------------------------\n\nTITLE: AST Node Structure Example\nDESCRIPTION: Shows the tree structure of parsed code with annotations for named and unnamed nodes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/match-algorithm.md#2025-04-21_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nimport_statement    // named\n  import            // unnamed\n  import_clause     // named\n    identifier      // named\n  from              // unnamed\n  string            // named\n    \"               // unnamed\n    string_fragment // named\n    \"               // unnamed\n```\n\n----------------------------------------\n\nTITLE: Example C Code for Function Call Matching\nDESCRIPTION: This C code snippet demonstrates the application of the ast-grep rule for matching function calls. The matched lines are highlighted to show where the rule applies.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/match-function-call.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define test(x) (2*x)\nint a = test(2);\nint main(){\n    int b = test(2);\n}\n```\n\n----------------------------------------\n\nTITLE: N-API Development Commands\nDESCRIPTION: These commands are used for developing the N-API binding. They navigate to the napi directory, install dependencies using yarn, build the binding, and run tests.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n\"cd crates/napi\nyarn   # Install dependencies\nyarn build # Build the binding\nyarn test # Run test\"\n```\n\n----------------------------------------\n\nTITLE: Handling Ruby in execute_lang_method Macro - Rust\nDESCRIPTION: This snippet shows how to handle the Ruby language in the execute_lang_method macro within lib.rs, allowing method execution for the Ruby language.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/add-lang.md#2025-04-21_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\n\"\"\"rust\n// lib.rs\nmacro_rules! execute_lang_method {\n  ($me: path, $method: ident, $($pname:tt),*) => {\n    use SupportLang as S;\n    match $me {\n      ...\n      S::Ruby => Ruby.$method($($pname,)*), // [!code ++]\n    }\n  }\n}\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring YAML Metadata for Blog Post\nDESCRIPTION: This YAML snippet defines metadata for the blog post, including author information, search settings, publication date, and OpenGraph metadata for social sharing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/stars-8000.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nauthor:\n  - name: Herrington Darkholme\nsearch: false\ndate: 2025-03-04\nhead:\n  - - meta\n    - property: og:type\n      content: website\n  - - meta\n    - property: og:title\n      content: ast-grep Rockets to 8000 Stars!\n  - - meta\n    - property: og:url\n      content: https://ast-grep.github.io/blog/stars-8000.html\n  - - meta\n    - property: og:description\n      content: ast-grep has recently reached 6000 stars on GitHub! This is a remarkable achievement for the project and I am deeply grateful for all the support and feedback that I have received from the open source community.\n---\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration Subtype Example\nDESCRIPTION: Example of Tree-sitter's subtype mechanism for TypeScript declarations, showing type aliasing.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype TypeScript = {\n  // node type alias\n  declaration: {\n    type: \"declaration\",\n    subtypes: [\n      { type: \"class_declaration\", named: true },\n      { type: \"function_declaration\", named: true },\n    ]\n  },\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Running ast-grep with short form command\nDESCRIPTION: Short form command to run ast-grep with a specified pattern and language on the TypeScript source directory.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\nast-grep -p '$PROP && $PROP()' -l ts TypeScript/src\n```\n\n----------------------------------------\n\nTITLE: Inefficient Digit Count Calculation in Rust\nDESCRIPTION: This snippet shows the inefficient method of calculating digit count by converting the number to a string and counting its characters. This approach is memory-intensive and slower compared to the logarithmic method.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/get-digit-count-in-usize.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet width = (lines + num).to_string().chars().count();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating console usage in TypeScript\nDESCRIPTION: TypeScript example showing both allowed and disallowed console usage. It highlights the lines that violate the rule (console.debug and console.log) while showing that console.error in a catch block is permitted.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/no-console-except-catch.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconsole.debug('')\ntry {\n    console.log('hello')\n} catch (e) {\n    console.error(e) // OK\n}\n```\n\n----------------------------------------\n\nTITLE: ast-grep JSON Stream Output Example\nDESCRIPTION: This command demonstrates how to run ast-grep with the `--json=stream` flag to output the results in JSON stream format. It searches for code matching the pattern 'pattern'. The JSON output will be a sequence of JSON objects, each followed by a newline character.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/tools/json.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n\"$ ast-grep -p pattern --json=stream\\n{\\\"text\\\":\\\"Some(matched)\\\", ... }\\n{\\\"text\\\":\\\"Some(matched)\\\", ... }\\n{\\\"text\\\":\\\"Some(matched)\\\", ... }\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Imports Detection in YAML for Ast-Grep\nDESCRIPTION: YAML configuration that defines pattern matching rules for dynamic imports like require('SOURCE') or import('SOURCE'). It targets string literals that are arguments to require() or import() calls, while excluding declarations.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/typescript/find-import-identifiers.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# DYNAMIC IMPORTS (Side Effect / Source Only) \n# -------------------------------------------------------\n# eg: (require('SOURCE'))\n# -------------------------------------------------------\n- all:\n    - kind: string # Target the source string literal directly\n    - pattern: $SOURCE\n    - inside: # String must be the argument of require() or import()\n        kind: arguments\n        parent:\n          kind: call_expression\n          has:\n            field: function\n            # Match 'require' identifier or 'import' keyword used dynamically\n            regex: '^(require|import)$'\n        stopBy: end # Search ancestors if needed (for the arguments/call_expression)\n    - not:\n        inside:\n          kind: lexical_declaration\n          stopBy: end # Search all ancestors up to the root\n```\n\n----------------------------------------\n\nTITLE: Generating Parser Library with Environment Variable\nDESCRIPTION: Alternative approach to generate a dynamic library by setting the TREE_SITTER_LIBDIR environment variable and running tree-sitter test. This was used in older Tree-sitter versions.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/advanced/custom-language.md#2025-04-21_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncd path/to/mojo/parser\nexport TREE_SITTER_LIBDIR=path/to/your/dir\ntree-sitter test\n```\n\n----------------------------------------\n\nTITLE: Defining Tree-sitter TypeMap Interface\nDESCRIPTION: TypeScript interface definition for Tree-sitter's static node type information structure.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface TypeMap {\n  [kind: string]: {\n    type: string\n    named: boolean\n    fields?: {\n      [field: string]: {\n        types: { type: string, named: boolean }[]\n      }\n    }\n    children?: { name: string, type: string }[]\n    subtypes?: { type: string, named: boolean }[]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Typed SgNode Class\nDESCRIPTION: Definition of the typed SgNode class with generic type parameters for language-specific type information.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/typed-napi.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nclass SgNode<M extends TypesMap, K extends Kinds<M> = Kinds<M>> {\n  kind: K\n  fields: M[K]['fields'] // demo definition, real one is more complex\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Kind Rule in YAML for ast-grep\nDESCRIPTION: Demonstrates how to use the 'kind' rule to match specific AST node types. This example matches field definitions in JavaScript classes.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/atomic-rule.md#2025-04-21_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: field_definition\n```\n\n----------------------------------------\n\nTITLE: Defining a Rewriter Rule for Dictionary Conversion\nDESCRIPTION: This YAML snippet defines a rewriter rule to match keyword arguments in a dict() function call and transform them into dictionary key-value pairs. It extracts the key and value into metavariables.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nrule:\n  kind: keyword_argument\n  all:\n  - has:\n      field: name\n      pattern: $KEY\n  - has:\n      field: value\n      pattern: $VAL\n```\n\n----------------------------------------\n\nTITLE: JavaScript pattern with meta variable\nDESCRIPTION: Example of a JavaScript pattern using a meta variable to match any property checking code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/quick-start.md#2025-04-21_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n$PROP && $PROP()\n```\n\n----------------------------------------\n\nTITLE: AST-Grep Configuration for Unused Variables Detection\nDESCRIPTION: YAML configuration for AST-Grep that detects unused local variable declarations in Java code. The rule uses pattern matching to identify variable declarations and checks if the variable is used later in the code.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/java/no-unused-vars.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: no-unused-vars\nrule:\n    kind: local_variable_declaration\n    all:\n        - has:\n            has:\n                kind: identifier\n                pattern: $IDENT\n        - not:\n            precedes:\n                stopBy: end\n                has:\n                    stopBy: end\n                    any:\n                        - { kind: identifier, pattern: $IDENT }\n                        - { has: {kind: identifier, pattern: $IDENT, stopBy: end}}\nfix: ''\n```\n\n----------------------------------------\n\nTITLE: Ignoring Linting Errors in JavaScript\nDESCRIPTION: This JavaScript example shows how to suppress linting errors for specific lines of code by using special comments. This can be useful for temporarily bypassing rules that are not applicable in certain contexts.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/project/lint-rule.md#2025-04-21_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// ast-grep-ignore\n// ast-grep-ignore: <rule-id>, <more-rule-id>\n```\n\n----------------------------------------\n\nTITLE: Format String Vulnerability Examples in C++\nDESCRIPTION: Examples of C++ code with format string vulnerabilities (marked with comments as 'Error') and their fixes (marked as 'OK'). The vulnerable code passes variables directly to printf-family functions without format specifiers.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/fix-format-vuln.md#2025-04-21_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// Error\nfprintf(stderr, out);\nsprintf(&buffer[2], obj->Text);\nsprintf(buf1, Text_String(TXT_WAITING_FOR_CONNECTIONS));\n// OK\nfprintf(stderr, \"%s\", out);\nsprintf(&buffer[2], \"%s\", obj->Text);\nsprintf(buf1, \"%s\", Text_String(TXT_WAITING_FOR_CONNECTIONS));\n```\n\n----------------------------------------\n\nTITLE: Simplified Printer Without Thread Safety Requirements\nDESCRIPTION: Final printer implementation that removes Send + Sync bounds and uses mutable references instead of Mutex, since the printer is no longer shared between threads.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/fearless-concurrency.md#2025-04-21_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntrait Printer {\n    fn print(&mut self, result: ...);\n}\n// stdout printer implementation\nstruct StdoutPrinter {\n    output: Stdout, // no more Mutex\n}\nimpl Printer for StdoutPrinter {\n    fn print(&mut self, result: ...) {\n        writeln!(self.output, \"{}\", result).unwrap();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Worker Implementation with Shared Printer\nDESCRIPTION: Initial worker implementation that uses a shared printer across multiple threads. The Worker struct is generic over the Printer trait.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/fearless-concurrency.md#2025-04-21_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// in the worker thread\nstruct Worker<P: Printer> {\n    // printer is shareable between threads\n    // because it implements Send + Sync\n    printer: P,\n}\nimpl<P> Worker<P> {\n    fn search(&self, file: &File) {\n        let results = self.search_in_file(file);\n        self.printer.print(results);\n    }\n    // other methods not using printer...\n}\n```\n\n----------------------------------------\n\nTITLE: Legacy Emscripten Setup Commands\nDESCRIPTION: Deprecated shell commands for setting up the project with Emscripten compiler, including WASM compilation and binding generation.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nEMCC_CFLAGS=\"-s ERROR_ON_UNDEFINED_SYMBOLS=0 --no-entry\" cargo build --target wasm32-unknown-emscripten\nwasm-bindgen --target web ../../target/wasm32-unknown-emscripten/debug/ast_grep_wasm.wasm --out-dir pkg\n```\n\n----------------------------------------\n\nTITLE: Applying Rewriters to a Metavariable via Transform\nDESCRIPTION: This code demonstrates how to apply defined rewriters to a metavariable using the 'transform' field in ast-grep. It shows the syntax for rewriting a source variable using a specific rewriter.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rewrite/rewriter.md#2025-04-21_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ntransform:\n  NEW_VAR:\n    rewrite:\n      rewriters: [sub-rule]\n      source: $OLD_VAR\n```\n\n----------------------------------------\n\nTITLE: Development Environment Setup Shell Commands\nDESCRIPTION: Shell commands for setting up the development environment, including building WASM files and creating necessary symbolic links for dev-time WASM bundling.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd website/.vitepress/cache/deps\nln -s ../../../../pkg/ast_grep_wasm_bg.wasm\ncd ../../../..\n```\n\n----------------------------------------\n\nTITLE: Deprecated Language Objects for NAPI in TypeScript\nDESCRIPTION: This code snippet shows deprecated language-specific objects for `html`, `js`, and `css` in `@ast-grep/napi`. These objects are deprecated and will be removed in the next version. The code defines a namespace `js` with deprecated methods like `parse`, `parseAsync`, `kind`, `pattern`, and `findInFiles`.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/api.md#2025-04-21_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n```ts\n/**\n * @deprecated language specific objects are deprecated\n * use the equivalent functions like `parse` in @ast-grep/napi\n */\nexport declare namespace js {\n  /** @deprecated use `parse(Lang.JavaScript, src)` instead */\n  export function parse(src: string): SgRoot\n  /** @deprecated use `parseAsync(Lang.JavaScript, src)` instead */\n  export function parseAsync(src: string): Promise<SgRoot>\n  /** @deprecated use `kind(Lang.JavaScript, kindName)` instead */\n  export function kind(kindName: string): number\n  /** @deprecated use `pattern(Lang.JavaScript, p)` instead */\n  export function pattern(pattern: string): NapiConfig\n  /** @deprecated use `findInFiles(Lang.JavaScript, config, callback)` instead */\n  export function findInFiles(\n    config: FindConfig,\n    callback: (err: null | Error, result: SgNode[]) => void\n  ): Promise<number>\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Matching If Statements with Comby\nDESCRIPTION: A Comby query using pattern matching symbols to find if statements where the condition is a comparison.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/code-search-design-space.md#2025-04-21_snippet_2\n\nLANGUAGE: comby\nCODE:\n```\nif (:[var] <= :[rest])\n```\n\n----------------------------------------\n\nTITLE: Configuring Yoda Condition Check in YAML\nDESCRIPTION: YAML configuration for ast-grep that detects equality comparisons where the right side is a number literal and rewrites them to place the constant on the left side. The rule targets comparisons within if statements.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/c/yoda-condition.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nid: may-the-force-be-with-you\nlanguage: c\nrule:\n  pattern: $A == $B\n  inside:\n    kind: parenthesized_expression\n    inside: {kind: if_statement}\nconstraints:\n  B: { kind: number_literal }\nfix: $B == $A\n```\n\n----------------------------------------\n\nTITLE: Identifying Unnecessary useState<number> Type in TypeScript React\nDESCRIPTION: Pattern to find and remove unnecessary <number> type annotation in useState hook.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/tsx/redundant-usestate-type.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nast-grep -p 'useState<number>($A)' -r 'useState($A)' -l tsx\n```\n\n----------------------------------------\n\nTITLE: JavaScript example for 'follows' relational rule\nDESCRIPTION: Provides a JavaScript code example showing which console.log statements match the 'follows' relational rule.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/guide/rule-config/relational-rule.md#2025-04-21_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconsole.log('hello'); // does not match\nconsole.log('world');\nconsole.log('hello'); // matches!!\n```\n\n----------------------------------------\n\nTITLE: Updating Bevy Dependencies in Cargo.toml\nDESCRIPTION: Diff showing the version updates for Bevy dependencies from 0.9.0 to 0.10.0\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\ndiff --git a/Cargo.toml b/Cargo.toml\nindex c495381..9e99a3b 100644\n--- a/Cargo.toml\n+++ b/Cargo.toml\n@@ -14,11 +14,11 @@ homepage = \"https://github.com/zkat/big-brain\"\n [workspace]\n\n [dependencies]\n-bevy = { version = \"0.9.0\", default-features = false }\n+bevy = { version = \"0.10.0\", default-features = false }\n big-brain-derive = { version = \"=0.16.0\", path = \"./derive\" }\n\n [dev-dependencies]\n-bevy = { version = \"0.9.0\", default-features = true }\n+bevy = { version = \"0.10.0\", default-features = true }\n rand = { version = \"0.8.5\", features = [\"small_rng\"] }\n\n [features]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Rule with Specific Language\nDESCRIPTION: Command to create a new rule with a specified programming language, using optional flags for non-interactive mode\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/reference/cli/new.md#2025-04-21_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nast-grep new rule -l javascript my_new_rule\n```\n\n----------------------------------------\n\nTITLE: Wrong AST Pattern Structure\nDESCRIPTION: Example of an incorrect pattern structure that doesn't properly match the AST nodes for struct inheritance.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/cpp/find-struct-inheritance.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nERROR\n  $SOMETHING\n  base_class_clause\n    $INHERITS\n```\n\n----------------------------------------\n\nTITLE: Formatting Rust code using cargo fmt\nDESCRIPTION: Uses cargo fmt to format the Rust code after performing automated refactoring. This ensures that the code remains readable and consistent with Rust formatting standards.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/migrate-bevy.md#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\ncargo fmt\n```\n\n----------------------------------------\n\nTITLE: Diff of Rust Code Transformation\nDESCRIPTION: This diff shows the before and after states of the Rust code when applying the ast-grep transformation. The indoc! macro is removed, and the content is wrapped in backticks.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/catalog/rust/rewrite-indoc-macro.md#2025-04-21_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    indoc! {r#\" // [!code --]\n    `.foo {    // [!code ++]\n        order: 1;\n    }\n    \"#}; // [!code --]\n        `; // [!code ++]\n}\n```\n\n----------------------------------------\n\nTITLE: Commit Message Format\nDESCRIPTION: An example of commit message format. The example demonstrates the structure of a commit message following conventional commits.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/contributing/development.md#2025-04-21_snippet_7\n\nLANGUAGE: plain text\nCODE:\n```\n\"<type>[optional scope]: <description>\n\n[optional body]\n\n[optional footer(s)]\"\n```\n\n----------------------------------------\n\nTITLE: Profiling ast-grep with Flamegraph\nDESCRIPTION: Command to run ast-grep with flamegraph profiling, scanning a TypeScript codebase using eslint rules.\nSOURCE: https://github.com/ast-grep/ast-grep.github.io/blob/main/website/blog/optimize-ast-grep.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo flamegraph -- ast-grep scan -c eslint/sgconfig.yml TypeScript/src --json > /dev/null\n```"
  }
]