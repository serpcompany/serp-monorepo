[
  {
    "owner": "pyo3",
    "repo": "pyo3",
    "content": "TITLE: Creating a Basic Python Module with PyO3\nDESCRIPTION: Creates a simple Python module that exports a 'double' function to Python using PyO3's #[pymodule] attribute. The module includes documentation and demonstrates the basic pattern for exporting Rust functions to Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n/// This module is implemented in Rust.\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Cloneable PyO3 Class Implementation\nDESCRIPTION: Shows how to implement a cloneable PyO3 class using #[derive(Clone)] and how to handle class instances passed by value.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Clone)]\nstruct MyClass {\n    my_field: Box<i32>,\n}\n\n#[pyfunction]\nfn dissamble_clone(my_class: MyClass) {\n    let MyClass { mut my_field } = my_class;\n    *my_field += 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python-like Number Class with PyO3 in Rust\nDESCRIPTION: This code snippet defines a Number struct and implements various Python special methods using PyO3. It includes methods for initialization, representation, string conversion, hashing, comparison, and boolean conversion. The class is then added to a Python module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nuse pyo3::prelude::*;\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Self(value)\n    }\n\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        Ok(format!(\"{}({})\", class_name, slf.borrow().0))\n    }\n\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Python Interpreter in Rust with PyO3\nDESCRIPTION: Example of embedding and interacting with a Python interpreter in a Rust application using PyO3. Imports Python modules, accesses Python variables, and evaluates Python code within Rust, demonstrating core functionality for Python interoperability.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/README.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\nuse pyo3::ffi::c_str;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let sys = py.import(\"sys\")?;\n        let version: String = sys.getattr(\"version\")?.extract()?;\n\n        let locals = [(\"os\", py.import(\"os\")?)].into_py_dict(py)?;\n        let code = c_str!(\"os.getenv('USER') or os.getenv('USERNAME') or 'Unknown'\");\n        let user: String = py.eval(code, None, Some(&locals))?.extract()?;\n\n        println!(\"Hello {}, I'm Python {}\", user, version);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Python Iterator Implementation in PyO3\nDESCRIPTION: Shows how to implement a Python iterator in Rust using PyO3. The class implements both __iter__ and __next__ methods to conform to Python's iterator protocol.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nuse std::sync::Mutex;\n\n#[pyclass]\nstruct MyIterator {\n    iter: Mutex<Box<dyn Iterator<Item = PyObject> + Send>>,\n}\n\n#[pymethods]\nimpl MyIterator {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n    fn __next__(slf: PyRefMut<'_, Self>) -> Option<PyObject> {\n        slf.iter.lock().unwrap().next()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Class Constructors with #[new]\nDESCRIPTION: Examples showing how to define constructors for Python classes using the #[new] attribute. Includes a simple constructor and one that returns a PyResult to handle potential errors.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Number(value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Python Module in Rust using PyO3\nDESCRIPTION: Example implementation of a Python module in Rust using PyO3. Defines a function 'sum_as_string' that adds two numbers and returns the result as a string, and exposes it as a Python function through the PyO3 framework.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A Python module implemented in Rust. The name of this function must match\n/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to\n/// import the module.\n#[pymodule]\nfn string_sum(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)?;\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Rust Function Exposed to Python\nDESCRIPTION: Example Rust code using PyO3 to create a Python module with a function that adds two numbers and returns the result as a string.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// Formats the sum of two numbers as string.\n#[pyfunction]\nfn sum_as_string(a: usize, b: usize) -> PyResult<String> {\n    Ok((a + b).to_string())\n}\n\n/// A Python module implemented in Rust. The name of this function must match\n/// the `lib.name` setting in the `Cargo.toml`, else Python will not be able to\n/// import the module.\n#[pymodule]\nfn pyo3_example(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(sum_as_string, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Python Exceptions in Rust using PyO3\nDESCRIPTION: This example demonstrates how to handle Python exceptions when calling Python functions from Rust. It shows how to catch and process Python errors using PyO3's error handling mechanisms.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function-calls.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyValueError;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let fun = PyModule::import(py, \"builtins\")?.getattr(\"int\")?\n        match fun.call1((\"not a number\",)) {\n            Ok(_) => println!(\"This should not happen\"),\n            Err(e) => {\n                assert!(e.is_instance_of::<PyValueError>(py));\n                println!(\"Python exception: {}\", e);\n            }\n        }\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Python Class in Rust\nDESCRIPTION: Demonstrates how to define a simple Python class with a getter method using PyO3. It also shows how to create an instance and access its properties.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    #[pyo3(get)]\n    num: i32,\n}\n\nPython::with_gil(|py| {\n    let obj = Bound::new(py, MyClass { num: 3 }).unwrap();\n    {\n        let obj_ref = obj.borrow(); // Get PyRef\n        assert_eq!(obj_ref.num, 3);\n        // You cannot get PyRefMut unless all PyRefs are dropped\n        assert!(obj.try_borrow_mut().is_err());\n    }\n    {\n        let mut obj_mut = obj.borrow_mut(); // Get PyRefMut\n        obj_mut.num = 5;\n        // You cannot get any other refs until the PyRefMut is dropped\n        assert!(obj.try_borrow().is_err());\n        assert!(obj.try_borrow_mut().is_err());\n    }\n\n    // You can convert `Bound` to a Python object\n    pyo3::py_run!(py, obj, \"assert obj.num == 5\");\n});\n```\n\n----------------------------------------\n\nTITLE: Deriving FromPyObject for Enums\nDESCRIPTION: Demonstrates deriving FromPyObject for enums to handle Python union types. Variants are tried in order until extraction succeeds, with support for various field configurations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\n# #[derive(Debug)]\nenum RustyEnum<'py> {\n    Int(usize),                    // input is a positive int\n    String(String),                // input is a string\n    IntTuple(usize, usize),        // input is a 2-tuple with positive ints\n    StringIntTuple(String, usize), // input is a 2-tuple with String and int\n    Coordinates3d {\n        // needs to be in front of 2d\n        x: usize,\n        y: usize,\n        z: usize,\n    },\n    Coordinates2d {\n        // only gets checked if the input did not have `z`\n        #[pyo3(attribute(\"x\"))]\n        a: usize,\n        #[pyo3(attribute(\"y\"))]\n        b: usize,\n    },\n    #[pyo3(transparent)]\n    CatchAll(Bound<'py, PyAny>), // This extraction never fails\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Python APIs using PyModule::import in Rust\nDESCRIPTION: Demonstrates how to import and use Python modules from Rust using PyO3's PyModule::import function. This example imports the 'builtins' module and uses its 'sum' function.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let builtins = PyModule::import(py, \"builtins\")?;\n        let total: i32 = builtins\n            .getattr(\"sum\")?\n            .call1((vec![1, 2, 3],))?\n            .extract()?;\n        assert_eq!(total, 6);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Using #[pyfn] Shorthand in PyO3\nDESCRIPTION: Demonstrates the use of the #[pyfn] shorthand for defining Python functions within a module in PyO3.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    #[pyfn(m)]\n    fn double(x: usize) -> usize {\n        x * 2\n    }\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Instance Methods with PyO3\nDESCRIPTION: Example of implementing instance methods for a Python class using the #[pymethods] attribute block. Both immutable and mutable self references are supported.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    fn method1(&self) -> PyResult<i32> {\n        Ok(10)\n    }\n\n    fn set_method(&mut self, value: i32) -> PyResult<()> {\n        self.num = value;\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Python Class to a Module\nDESCRIPTION: Example showing how to add a Python class to a PyO3 module using the add_class method in the module initializer function.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Raising Python ValueError from Rust Function\nDESCRIPTION: Demonstrates how to raise a Python ValueError exception from a Rust function using PyO3. The function checks if a number is positive and raises an exception if negative.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/error-handling.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::exceptions::PyValueError;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn check_positive(x: i32) -> PyResult<()> {\n    if x < 0 {\n        Err(PyValueError::new_err(\"x is negative\"))\n    } else {\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Complex Exception Classes in PyO3 with pyclass\nDESCRIPTION: Demonstrates how to create a more complex exception class by subclassing PyException using pyclass. The example includes custom fields, getters, and a constructor for creating exception instances.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(dead_code)]\n# #[cfg(any(not(feature = \"abi3\")))] {\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\nuse pyo3::exceptions::PyException;\n\n#[pyclass(extends=PyException)]\nstruct CustomError {\n    #[pyo3(get)]\n    url: String,\n\n    #[pyo3(get)]\n    message: String,\n}\n\n#[pymethods]\nimpl CustomError {\n    #[new]\n    fn new(url: String, message: String) -> Self {\n        Self { url, message }\n    }\n}\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    let ctx = [(\"CustomError\", py.get_type::<CustomError>())].into_py_dict(py)?;\n    pyo3::py_run!(\n        py,\n        *ctx,\n        \"assert str(CustomError) == \\\"<class 'builtins.CustomError'>\\\", repr(CustomError)\"\n    );\n    pyo3::py_run!(py, *ctx, \"assert CustomError('https://example.com', 'something went bad').args == ('https://example.com', 'something went bad')\");\n    pyo3::py_run!(py, *ctx, \"assert CustomError('https://example.com', 'something went bad').url == 'https://example.com'\");\n#   Ok(())\n})\n# }\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating Class Methods with PyO3\nDESCRIPTION: Example of implementing class methods (equivalent to Python's @classmethod) using the #[classmethod] attribute, with the class type as first parameter.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[classmethod]\n    fn cls_method(cls: &Bound<'_, PyType>) -> PyResult<i32> {\n        Ok(10)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up PyO3 with Maturin for Python Extension Development\nDESCRIPTION: Bash script for setting up a PyO3 development environment with Maturin. Creates a Python virtual environment, installs Maturin, initializes a new PyO3 project, and builds and installs the package for development.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/README.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nmkdir string_sum && cd \"$_\"\npython -m venv .env\nsource .env/bin/activate\npip install maturin\nmaturin init --bindings pyo3\nmaturin develop\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality Comparison for PyO3 Enums\nDESCRIPTION: Example showing how to create an enum with equality comparison and implement a __repr__ method. The enum is exposed to Python with equivalent functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_26\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Answer = 42,\n}\n\n#[pymethods]\nimpl MyEnum {\n    fn __repr__(&self) -> &'static str {\n        \"42\"\n    }\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, cls, \"assert repr(cls.Answer) == '42'\")\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Class Constructors with Error Handling\nDESCRIPTION: Example of implementing a Python class constructor that can fail by returning PyResult<Self>, which allows raising Python exceptions when invalid parameters are provided.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# use pyo3::prelude::*;\n# use pyo3::exceptions::PyValueError;\n# #[pyclass]\n# struct Nonzero(i32);\n#\n#[pymethods]\nimpl Nonzero {\n    #[new]\n    fn py_new(value: i32) -> PyResult<Self> {\n        if value == 0 {\n            Err(PyValueError::new_err(\"cannot be zero\"))\n        } else {\n            Ok(Nonzero(value))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Python Submodules with PyO3\nDESCRIPTION: Demonstrates how to create a module hierarchy within a single extension module using PyO3. This example creates a parent_module and a child_module, with the child module containing a function 'func'.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pymodule]\nfn parent_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    register_child_module(m)?;\n    Ok(())\n}\n\nfn register_child_module(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {\n    let child_module = PyModule::new(parent_module.py(), \"child_module\")?;\n    child_module.add_function(wrap_pyfunction!(func, &child_module)?)?;\n    parent_module.add_submodule(&child_module)\n}\n\n#[pyfunction]\nfn func() -> String {\n    \"func\".to_string()\n}\n\n# Python::with_gil(|py| {\n#    use pyo3::wrap_pymodule;\n#    use pyo3::types::IntoPyDict;\n#    use pyo3::ffi::c_str;\n#    let parent_module = wrap_pymodule!(parent_module)(py);\n#    let ctx = [(\"parent_module\", parent_module)].into_py_dict(py).unwrap();\n#\n#    py.run(c_str!(\"assert parent_module.child_module.func() == 'func'\"), None, Some(&ctx)).unwrap();\n# })\n```\n\n----------------------------------------\n\nTITLE: Calling Python Functions with Different Argument Types in Rust\nDESCRIPTION: Demonstrates various ways to call Python functions using PyO3, including calls with no arguments, positional arguments using Rust tuples, and Python tuples. The example creates a Python function through a module and shows different calling patterns.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/function-calls.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyTuple;\nuse pyo3_ffi::c_str;\n\nfn main() -> PyResult<()> {\n    let arg1 = \"arg1\";\n    let arg2 = \"arg2\";\n    let arg3 = \"arg3\";\n\n    Python::with_gil(|py| {\n        let fun: Py<PyAny> = PyModule::from_code(\n            py,\n            c_str!(\"def example(*args, **kwargs):\\n                if args != ():\\n                    print('called with args', args)\\n                if kwargs != {}:\\n                    print('called with kwargs', kwargs)\\n                if args == () and kwargs == {}:\\n                    print('called with no arguments')\"),\n            c_str!(\"\"),\n            c_str!(\"\"),\n        )?\n        .getattr(\"example\")?\n        .into();\n\n        // call object without any arguments\n        fun.call0(py)?;\n\n        // pass object with Rust tuple of positional arguments\n        let args = (arg1, arg2, arg3);\n        fun.call1(py, args)?;\n\n        // call object with Python tuple of positional arguments\n        let args = PyTuple::new(py, &[arg1, arg2, arg3])?;\n        fun.call1(py, args)?;\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Keyword Arguments Handler in Rust with PyO3\nDESCRIPTION: Example showing how to create a Python function that accepts arbitrary keyword arguments and returns their count using PyO3's signature configuration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/signature.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\n\n#[pyfunction]\n#[pyo3(signature = (**kwds))]\nfn num_kwds(kwds: Option<&Bound<'_, PyDict>>) -> usize {\n    kwds.map_or(0, |dict| dict.len())\n}\n\n#[pymodule]\nfn module_with_functions(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(num_kwds, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe PyO3 Class Using Atomic Data Structures\nDESCRIPTION: A PyO3 class implementation that uses atomic integers to ensure thread safety without runtime borrow checking errors. The frozen attribute prevents PyO3 from adding its own interior mutability wrapper.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/thread-safety.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::atomic::{AtomicI32, Ordering};\n\n#[pyclass(frozen)]\nstruct MyClass {\n    x: AtomicI32,\n    y: AtomicI32,\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.x.load(Ordering::Relaxed)\n    }\n\n    fn set_y(&self, value: i32) {\n        self.y.store(value, Ordering::Relaxed)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete PyO3 Trait Implementation and Python Module Exposure\nDESCRIPTION: Full implementation of a PyO3 module that exposes Rust traits to Python, including the Model trait implementation, UserModel struct with Python methods, and a solve function wrapper that connects Python to Rust's core functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\npub trait Model {\n    fn set_variables(&mut self, var: &Vec<f64>);\n    fn get_results(&self) -> Vec<f64>;\n    fn compute(&mut self);\n}\n\npub fn solve<T: Model>(model: &mut T) {\n    println!(\"Magic solver that mutates the model into a resolved state\");\n}\n\n#[pyfunction]\n#[pyo3(name = \"solve\")]\npub fn solve_wrapper(model: &mut UserModel) {\n    solve(model);\n}\n\n#[pyclass]\npub struct UserModel {\n    model: Py<PyAny>,\n}\n\n#[pymodule]\nfn trait_exposure(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<UserModel>()?;\n    m.add_function(wrap_pyfunction!(solve_wrapper, m)?)?;\n    Ok(())\n}\n\n#[pymethods]\nimpl UserModel {\n    #[new]\n    pub fn new(model: Py<PyAny>) -> Self {\n        UserModel { model }\n    }\n\n    pub fn set_variables(&mut self, var: Vec<f64>) {\n        println!(\"Set variables from Python calling Rust\");\n        Model::set_variables(self, &var)\n    }\n\n    pub fn get_results(&mut self) -> Vec<f64> {\n        println!(\"Get results from Python calling Rust\");\n        Model::get_results(self)\n    }\n\n    pub fn compute(&mut self) {\n        Model::compute(self)\n    }\n}\n\nimpl Model for UserModel {\n    fn set_variables(&mut self, var: &Vec<f64>) {\n        println!(\"Rust calling Python to set the variables\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"set_variables\", (PyList::new(py, var).unwrap(),), None)\n                .unwrap();\n        })\n    }\n\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Get results from Rust calling Python\");\n        Python::with_gil(|py| {\n            let py_result: Bound<'_, PyAny> = self\n                .model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap();\n\n            if py_result.get_type().name().unwrap() != \"list\" {\n                panic!(\n                    \"Expected a list for the get_results() method signature, got {}\",\n                    py_result.get_type().name().unwrap()\n                );\n            }\n            py_result.extract()\n        })\n        .unwrap()\n    }\n\n    fn compute(&mut self) {\n        println!(\"Rust calling Python to perform the computation\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"compute\", (), None)\n                .unwrap();\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Keyword Arguments with PyO3\nDESCRIPTION: Shows how to create and pass keyword arguments to Python functions using PyO3's IntoPyDict trait. Demonstrates different ways to create kwargs using PyDict, Vec, and HashMap.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/function-calls.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\nuse std::collections::HashMap;\nuse pyo3_ffi::c_str;\n\nfn main() -> PyResult<()> {\n    let key1 = \"key1\";\n    let val1 = 1;\n    let key2 = \"key2\";\n    let val2 = 2;\n\n    Python::with_gil(|py| {\n        let fun: Py<PyAny> = PyModule::from_code(\n            py,\n            c_str!(\"def example(*args, **kwargs):\\n                if args != ():\\n                    print('called with args', args)\\n                if kwargs != {}:\\n                    print('called with kwargs', kwargs)\\n                if args == () and kwargs == {}:\\n                    print('called with no arguments')\"),\n            c_str!(\"\"),\n            c_str!(\"\"),\n        )?\n        .getattr(\"example\")?\n        .into();\n\n        // call object with PyDict\n        let kwargs = [(key1, val1)].into_py_dict(py)?;\n        fun.call(py, (), Some(&kwargs))?;\n\n        // pass arguments as Vec\n        let kwargs = vec![(key1, val1), (key2, val2)];\n        fun.call(py, (), Some(&kwargs.into_py_dict(py)?))?;\n\n        // pass arguments as HashMap\n        let mut kwargs = HashMap::<&str, i32>::new();\n        kwargs.insert(key1, 1);\n        fun.call(py, (), Some(&kwargs.into_py_dict(py)?))?;\n\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python<'py> Token Usage in Rust with PyO3\nDESCRIPTION: This code snippet demonstrates the usage of the Python<'py> token in PyO3. It shows how the token provides access to global Python interpreter APIs and is used to bind PyO3 types to the Python interpreter.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nPython<'py>\n```\n\n----------------------------------------\n\nTITLE: Using Declarative Module Syntax in PyO3\nDESCRIPTION: Shows how to use PyO3's declarative module syntax based on Rust inline modules. This approach allows defining functions, classes, and submodules within a module structure that mimics the resulting Python module hierarchy.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# mod declarative_module_test {\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule]\nmod my_extension {\n    use super::*;\n\n    #[pymodule_export]\n    use super::double; // Exports the double function as part of the module\n\n    #[pyfunction] // This will be part of the module\n    fn triple(x: usize) -> usize {\n        x * 3\n    }\n\n    #[pyclass] // This will be part of the module\n    struct Unit;\n\n    #[pymodule]\n    mod submodule {\n        // This is a submodule\n    }\n\n    #[pymodule_init]\n    fn init(m: &Bound<'_, PyModule>) -> PyResult<()> {\n        // Arbitrary code to run at the module initialization\n        m.add(\"double2\", m.getattr(\"double\")?)\n    }\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Class-Based Constructor Implementation\nDESCRIPTION: Example demonstrating how to create a constructor that takes a class argument by combining #[classmethod] and #[new] attributes, useful for handling subclass attributes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl BaseClass {\n    #[new]\n    #[classmethod]\n    fn py_new(cls: &Bound<'_, PyType>) -> PyResult<Self> {\n        // Get an abstract attribute (presumably) declared on a subclass of this class.\n        let subclass_attr: Bound<'_, PyAny> = cls.getattr(\"a_class_attr\")?;\n        Ok(Self(subclass_attr.unbind()))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Raising and Fetching Python Exceptions in PyO3\nDESCRIPTION: Demonstrates how to manually create, raise, and fetch Python exceptions using PyO3. This shows direct manipulation of the Python interpreter's global error state.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{Python, PyErr};\nuse pyo3::exceptions::PyTypeError;\n\nPython::with_gil(|py| {\n    PyTypeError::new_err(\"Error\").restore(py);\n    assert!(PyErr::occurred(py));\n    drop(PyErr::fetch(py));\n});\n```\n\n----------------------------------------\n\nTITLE: Calling a Python Function with Multiple Arguments using PyO3\nDESCRIPTION: This example demonstrates how to call a Python function that takes multiple arguments. It uses the `call1` method with a tuple of arguments.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function-calls.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let fun = PyModule::import(py, \"builtins\")?.getattr(\"max\")?\n        let result = fun.call1((vec![1, 2, 3, 4],))?;\n        assert_eq!(result.extract::<i32>()?, 4);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Basic PyO3 Class Implementation with Field Access\nDESCRIPTION: Demonstrates different ways to handle references to PyO3 class instances, including direct mutation, automatic borrowing, manual borrowing, and GIL-independent references.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {\n    my_field: i32,\n}\n\n#[pyfunction]\nfn increment_field(my_class: &mut MyClass) {\n    my_class.my_field += 1;\n}\n\n#[pyfunction]\nfn print_field(my_class: PyRef<'_, MyClass>) {\n    println!(\"{}\", my_class.my_field);\n}\n\n#[pyfunction]\nfn increment_then_print_field(my_class: &Bound<'_, MyClass>) {\n    my_class.borrow_mut().my_field += 1;\n    println!(\"{}\", my_class.borrow().my_field);\n}\n\n#[pyfunction]\nfn print_refcnt(my_class: Py<MyClass>, py: Python<'_>) {\n    println!(\"{}\", my_class.get_refcnt(py));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Call Counter Decorator in Rust using PyO3\nDESCRIPTION: This code snippet demonstrates how to create a callable object in Rust using PyO3. It implements a decorator that counts and logs the number of times a wrapped function is called.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/call.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse std::sync::atomic::{AtomicU64, Ordering};\n\n#[pyclass]\nstruct Counter {\n    count: AtomicU64,\n    wraps: Py<PyAny>,\n}\n\n#[pymethods]\nimpl Counter {\n    #[new]\n    fn new(wraps: Py<PyAny>) -> Self {\n        Counter {\n            count: AtomicU64::new(0),\n            wraps,\n        }\n    }\n\n    #[pyo3(signature = (*args, **kwargs))]\n    fn __call__(\n        &self,\n        py: Python<'_>,\n        args: &Bound<'_, PyTuple>,\n        kwargs: Option<&Bound<'_, PyDict>>,\n    ) -> PyResult<Py<PyAny>> {\n        let count = self.count.fetch_add(1, Ordering::SeqCst);\n        let name = self.wraps.getattr(py, \"__name__\")?;\n\n        println!(\"{} has been called {} time(s).\", name, count + 1);\n\n        // After doing something, we finally forward the call to the wrapped function\n        let ret = self.wraps.call(py, args, kwargs)?;\n\n        // We could do something with the return value of\n        // the function before returning it\n        Ok(ret)\n    }\n}\n\n#[pymodule]\nfn decorator(_py: Python, m: &PyModule) -> PyResult<()> {\n    m.add_class::<Counter>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Arithmetic Operations for Number in PyO3\nDESCRIPTION: Implements various binary arithmetic operations for the Number class, including addition, subtraction, multiplication, and division, with proper error handling.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __add__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_add(other.0))\n    }\n\n    fn __sub__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_sub(other.0))\n    }\n\n    fn __mul__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_mul(other.0))\n    }\n\n    fn __truediv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __rshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __lshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Exception Types in PyO3\nDESCRIPTION: Demonstrates how to check if an exception is of a specific type using the is_instance_of method. This is useful for conditionally handling different exception types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::exceptions::PyTypeError;\n# use pyo3::prelude::*;\n# Python::with_gil(|py| {\n# let err = PyTypeError::new_err(());\nerr.is_instance_of::<PyTypeError>(py);\n# });\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Comparisons with __richcmp__\nDESCRIPTION: Implements all six comparison operations at once using the __richcmp__ method. This method handles less than, less than or equal, equal, not equal, greater than, and greater than or equal comparisons.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\n\n#[pymethods]\nimpl Number {\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Context Managers in Rust using PyO3\nDESCRIPTION: This snippet demonstrates how to use a Python context manager in Rust code using PyO3. It creates a custom 'House' class with __enter__ and __exit__ methods, then shows how to invoke these methods from Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::ffi::c_str;\n\nfn main() {\n    Python::with_gil(|py| {\n        let custom_manager = PyModule::from_code(\n            py,\n            c_str!(r#\"\nclass House(object):\n    def __init__(self, address):\n        self.address = address\n    def __enter__(self):\n        print(f\"Welcome to {self.address}!\")\n    def __exit__(self, type, value, traceback):\n        if type:\n            print(f\"Sorry you had {type} trouble at {self.address}\")\n        else:\n            print(f\"Thank you for visiting {self.address}, come again soon!\")\n\n        \"#),\n            c_str!(\"house.py\"),\n            c_str!(\"house\"),\n        )\n        .unwrap();\n\n        let house_class = custom_manager.getattr(\"House\").unwrap();\n        let house = house_class.call1((\"123 Main Street\",)).unwrap();\n\n        house.call_method0(\"__enter__\").unwrap();\n\n        let result = py.eval(c_str!(\"undefined_variable + 1\"), None, None);\n\n        // If the eval threw an exception we'll pass it through to the context manager.\n        // Otherwise, __exit__  is called with empty arguments (Python \"None\").\n        match result {\n            Ok(_) => {\n                let none = py.None();\n                house\n                    .call_method1(\"__exit__\", (&none, &none, &none))\n                    .unwrap();\n            }\n            Err(e) => {\n                house\n                    .call_method1(\n                        \"__exit__\",\n                        (\n                            e.get_type(py),\n                            e.value(py),\n                            e.traceback(py),\n                        ),\n                    )\n                    .unwrap();\n            }\n        }\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Exception Types with create_exception! Macro in PyO3\nDESCRIPTION: Demonstrates how to define a new Python exception type using the create_exception! macro, which takes the module name, exception name, and parent exception type as parameters.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::create_exception;\n\ncreate_exception!(module, MyError, pyo3::exceptions::PyException);\n```\n\n----------------------------------------\n\nTITLE: Module Attribute Setting for PyClasses in PyO3\nDESCRIPTION: Demonstrates how the #[pymodule] macro automatically sets the module attribute of #[pyclass] macros declared inside it. This example shows the module attribute inheritance for nested modules and classes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# mod declarative_module_module_attr_test {\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Ext;\n\n#[pymodule]\nmod my_extension {\n    use super::*;\n\n    #[pymodule_export]\n    use super::Ext;\n\n    #[pymodule]\n    mod submodule {\n        use super::*;\n        // This is a submodule\n\n        #[pyclass] // This will be part of the module\n        struct Unit;\n    }\n}\n# }\n```\n\n----------------------------------------\n\nTITLE: Checking Python Object Types with is_instance in PyO3\nDESCRIPTION: Shows how to check an object's type using PyAny::is_instance_of, which is equivalent to Python's isinstance() function. The example tests different Python types including PyBool and PyList.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::{PyBool, PyList};\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    assert!(PyBool::new(py, true).is_instance_of::<PyBool>());\n    let list = PyList::new(py, &[1, 2, 3, 4])?;\n    assert!(!list.is_instance_of::<PyBool>());\n    assert!(list.is_instance_of::<PyList>());\n# Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Implementing Class Inheritance in PyO3\nDESCRIPTION: Shows how to implement class inheritance in PyO3, including creating base classes, subclasses, and methods that interact with parent classes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass(subclass)]\nstruct BaseClass {\n    val1: usize,\n}\n\n#[pymethods]\nimpl BaseClass {\n    #[new]\n    fn new() -> Self {\n        BaseClass { val1: 10 }\n    }\n\n    pub fn method1(&self) -> PyResult<usize> {\n        Ok(self.val1)\n    }\n}\n\n#[pyclass(extends=BaseClass, subclass)]\nstruct SubClass {\n    val2: usize,\n}\n\n#[pymethods]\nimpl SubClass {\n    #[new]\n    fn new() -> (Self, BaseClass) {\n        (SubClass { val2: 15 }, BaseClass::new())\n    }\n\n    fn method2(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let super_ = self_.as_super(); // Get &PyRef<BaseClass>\n        super_.method1().map(|x| x * self_.val2)\n    }\n}\n\n#[pyclass(extends=SubClass)]\nstruct SubSubClass {\n    val3: usize,\n}\n\n#[pymethods]\nimpl SubSubClass {\n    #[new]\n    fn new() -> PyClassInitializer<Self> {\n        PyClassInitializer::from(SubClass::new()).add_subclass(SubSubClass { val3: 20 })\n    }\n\n    fn method3(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let base = self_.as_super().as_super(); // Get &PyRef<'_, BaseClass>\n        base.method1().map(|x| x * self_.val3)\n    }\n\n    fn method4(self_: PyRef<'_, Self>) -> PyResult<usize> {\n        let v = self_.val3;\n        let super_ = self_.into_super(); // Get PyRef<'_, SubClass>\n        SubClass::method2(super_).map(|x| x * v)\n    }\n\n    fn get_values(self_: PyRef<'_, Self>) -> (usize, usize, usize) {\n        let val1 = self_.as_super().as_super().val1;\n        let val2 = self_.as_super().val2;\n        (val1, val2, self_.val3)\n    }\n\n    fn double_values(mut self_: PyRefMut<'_, Self>) {\n        self_.as_super().as_super().val1 *= 2;\n        self_.as_super().val2 *= 2;\n        self_.val3 *= 2;\n    }\n\n    #[staticmethod]\n    fn factory_method(py: Python<'_>, val: usize) -> PyResult<PyObject> {\n        let base = PyClassInitializer::from(BaseClass::new());\n        let sub = base.add_subclass(SubClass { val2: val });\n        if val % 2 == 0 {\n            Ok(Py::new(py, sub)?.into_any())\n        } else {\n            let sub_sub = sub.add_subclass(SubSubClass { val3: val });\n            Ok(Py::new(py, sub_sub)?.into_any())\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Field Attributes for Object Properties\nDESCRIPTION: Simple example showing how to expose struct fields as Python properties using the #[pyo3(get, set)] attribute directly on field definitions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {\n    #[pyo3(get, set)]\n    num: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Python Function with PyO3 in Rust\nDESCRIPTION: Demonstrates how to define a Python function 'double' from Rust code using the #[pyfunction] attribute and add it to a Python module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Foreign Error Type Handling with Newtype Pattern\nDESCRIPTION: Demonstrates handling third-party error types using a newtype wrapper pattern to implement PyO3 error conversion traits.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/error-handling.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyValueError;\nuse some_crate::{OtherError, get_x};\n\nstruct MyOtherError(OtherError);\n\nimpl From<MyOtherError> for PyErr {\n    fn from(error: MyOtherError) -> Self {\n        PyValueError::new_err(error.0.message())\n    }\n}\n\nimpl From<OtherError> for MyOtherError {\n    fn from(other: OtherError) -> Self {\n        Self(other)\n    }\n}\n\n#[pyfunction]\nfn wrapped_get_x() -> Result<i32, MyOtherError> {\n    let x: i32 = get_x()?;\n    Ok(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Equality Implementation with PartialEq Trait\nDESCRIPTION: Demonstrates how to automatically implement __eq__ by using the eq attribute and implementing the PartialEq trait. This is a more concise approach when the class has a natural equality implementation in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq)]\n#[derive(PartialEq)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: Implementing Async Sleep Function in PyO3\nDESCRIPTION: Demonstrates implementing an async sleep function that can be called from Python. The function takes a duration in seconds and an optional result value to return after sleeping. Uses oneshot channel for async coordination.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/async-await.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{thread, time::Duration};\nuse futures::channel::oneshot;\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(signature=(seconds, result=None))]\nasync fn sleep(seconds: f64, result: Option<PyObject>) -> Option<PyObject> {\n    let (tx, rx) = oneshot::channel();\n    thread::spawn(move || {\n        thread::sleep(Duration::from_secs_f64(seconds));\n        tx.send(()).unwrap();\n    });\n    rx.await.unwrap();\n    result\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Frozen Classes in PyO3\nDESCRIPTION: Demonstrates how to create a frozen class that opts out of interior mutability. It uses atomic types for thread-safe interior mutability and can be accessed without the Python GIL.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::atomic::{AtomicUsize, Ordering};\nuse pyo3::prelude::*;\n\n#[pyclass(frozen)]\nstruct FrozenCounter {\n    value: AtomicUsize,\n}\n\nlet py_counter: Py<FrozenCounter> = Python::with_gil(|py| {\n    let counter = FrozenCounter {\n        value: AtomicUsize::new(0),\n    };\n\n    Py::new(py, counter).unwrap()\n});\n\npy_counter.get().value.fetch_add(1, Ordering::Relaxed);\n\nPython::with_gil(move |_py| drop(py_counter));\n```\n\n----------------------------------------\n\nTITLE: Implementing Parallel Word Count in Rust with Rayon\nDESCRIPTION: A PyO3 example that uses rayon to count word occurrences in parallel. The function takes advantage of parallel line processing to efficiently count words across multiple CPU cores.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/parallelism.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\n// These traits let us use `par_lines` and `map`.\nuse rayon::str::ParallelString;\nuse rayon::iter::ParallelIterator;\n\n/// Count the occurrences of needle in line, case insensitive\nfn count_line(line: &str, needle: &str) -> usize {\n    let mut total = 0;\n    for word in line.split(' ') {\n        if word == needle {\n            total += 1;\n        }\n    }\n    total\n}\n\n#[pyfunction]\nfn search(contents: &str, needle: &str) -> usize {\n    contents\n        .par_lines()\n        .map(|line| count_line(line, needle))\n        .sum()\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Python Dictionary Type with PyO3\nDESCRIPTION: Example showing how to create a custom class that extends Python's dictionary (PyDict) type. It implements a new method with custom arguments handling for initialization.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(extends=PyDict)]\nstruct MyDict {\n    private: i32,\n}\n\n#[pymethods]\nimpl MyDict {\n    #[new]\n    #[pyo3(signature = (*args, **kwargs))]\n    fn new(args: &Bound<'_, PyAny>, kwargs: Option<&Bound<'_, PyAny>>) -> Self {\n        Self { private: 0 }\n    }\n\n    // some custom methods that use `private` here...\n}\n```\n\n----------------------------------------\n\nTITLE: Struct to Python Dictionary Conversion with IntoPyObject\nDESCRIPTION: Examples of struct and tuple struct conversions to Python types using the IntoPyObject derive macro.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(IntoPyObject)]\nstruct Struct {\n    count: usize,\n    obj: Py<PyAny>,\n}\n\n#[derive(IntoPyObject)]\nstruct Tuple<'a, K: Hash + Eq, V>(&'a str, HashMap<K, V>)\n```\n\n----------------------------------------\n\nTITLE: Defining Python Classes with #[pyclass] in Rust\nDESCRIPTION: Example showing how to define Python classes using various Rust struct and enum types with the #[pyclass] attribute. Includes regular structs, tuple structs, unit-only enums, and enums with variants containing data.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    inner: i32,\n}\n\n// A \"tuple\" struct\n#[pyclass]\nstruct Number(i32);\n\n// PyO3 supports unit-only enums (which contain only unit variants)\n// These simple enums behave similarly to Python's enumerations (enum.Enum)\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Variant,\n    OtherVariant = 30, // PyO3 supports custom discriminants.\n}\n\n// PyO3 supports custom discriminants in unit-only enums\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum HttpResponse {\n    Ok = 200,\n    NotFound = 404,\n    Teapot = 418,\n    // ...\n}\n\n// PyO3 also supports enums with Struct and Tuple variants\n// These complex enums have sligtly different behavior from the simple enums above\n// They are meant to work with instance checks and match statement patterns\n// The variants can be mixed and matched\n// Struct variants have named fields while tuple enums generate generic names for fields in order _0, _1, _2, ...\n// Apart from this both types are functionally identical\n#[pyclass]\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    RegularPolygon(u32, f64),\n    Nothing(),\n}\n```\n\n----------------------------------------\n\nTITLE: Custom-Named Property Getters and Setters\nDESCRIPTION: Example showing how to specify custom property names for getter and setter methods using the #[getter(name)] and #[setter(name)] attributes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[getter(number)]\n    fn num(&self) -> PyResult<i32> {\n        Ok(self.num)\n    }\n\n    #[setter(number)]\n    fn set_num(&mut self, value: i32) -> PyResult<()> {\n        self.num = value;\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of PyO3 API for Python List Manipulation in Rust\nDESCRIPTION: This code snippet demonstrates how PyO3's API for Python objects uses shared references due to Python's lack of exclusive &mut references. It shows the PyListMethods::append method as an example.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nPyListMethods::append\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Method Signatures with PyO3\nDESCRIPTION: Demonstrates implementation of a Python class method with mixed positional, keyword arguments, and default values using PyO3's signature configuration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/signature.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[new]\n    #[pyo3(signature = (num=-1))]\n    fn new(num: i32) -> Self {\n        MyClass { num }\n    }\n\n    #[pyo3(signature = (num=10, *py_args, name=\"Hello\", **py_kwargs))]\n    fn method(\n        &mut self,\n        num: i32,\n        py_args: &Bound<'_, PyTuple>,\n        name: &str,\n        py_kwargs: Option<&Bound<'_, PyDict>>,\n    ) -> String {\n        let num_before = self.num;\n        self.num = num;\n        format!(\n            \"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \",\n            num, num_before, py_args, name, py_kwargs,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 Method Arguments with Signatures\nDESCRIPTION: Demonstrates how to define method signatures with default values, variable arguments, and keyword arguments using the #[pyo3(signature)] attribute.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[new]\n    #[pyo3(signature = (num=-1))]\n    fn new(num: i32) -> Self {\n        MyClass { num }\n    }\n\n    #[pyo3(signature = (num=10, *py_args, name=\"Hello\", **py_kwargs))]\n    fn method(\n        &mut self,\n        num: i32,\n        py_args: &Bound<'_, PyTuple>,\n        name: &str,\n        py_kwargs: Option<&Bound<'_, PyDict>>,\n    ) -> String {\n        let num_before = self.num;\n        self.num = num;\n        format!(\n            \"num={} (was previously={}), py_args={:?}, name={}, py_kwargs={:?} \",\n            num, num_before, py_args, name, py_kwargs,\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting ParseIntError to Python Exception\nDESCRIPTION: Shows how to handle Rust's ParseIntError and convert it to a Python exception using PyO3's automatic error conversion functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/error-handling.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::num::ParseIntError;\n\n#[pyfunction]\nfn parse_int(x: &str) -> Result<usize, ParseIntError> {\n    x.parse()\n}\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Native Python Types in PyO3\nDESCRIPTION: Demonstrates how to inherit from native Python types like PyDict in PyO3. It shows how to implement custom methods and interact with the base class.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse std::collections::HashMap;\n\n#[pyclass(extends=PyDict)]\n#[derive(Default)]\nstruct DictWithCounter {\n    counter: HashMap<String, usize>,\n}\n\n#[pymethods]\nimpl DictWithCounter {\n    #[new]\n    fn new() -> Self {\n        Self::default()\n    }\n\n    fn set(slf: &Bound<'_, Self>, key: String, value: Bound<'_, PyAny>) -> PyResult<()> {\n        slf.borrow_mut().counter.entry(key.clone()).or_insert(0);\n        let dict = slf.downcast::<PyDict>()?;\n        dict.set_item(key, value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Enums and Variants in PyO3\nDESCRIPTION: Demonstrates how to rename enums and their variants when exposing them to Python using the #[pyo3(name)] attribute. This allows customizing Python-facing names while maintaining original Rust names.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int, name = \"RenamedEnum\")]\n#[derive(PartialEq)]\nenum MyEnum {\n    #[pyo3(name = \"UPPERCASE\")]\n    Variant,\n}\n\nPython::with_gil(|py| {\n    let x = Py::new(py, MyEnum::Variant).unwrap();\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, x cls, r#\"\n        assert repr(x) == 'RenamedEnum.UPPERCASE'\n        assert x == cls.UPPERCASE\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Getters and Setters with Prefixed Names\nDESCRIPTION: Example of implementing getters and setters with prefixed function names (get_/set_), where PyO3 automatically removes these prefixes for the property name.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[getter]\n    fn get_num(&self) -> PyResult<i32> {\n        Ok(self.num)\n    }\n\n    #[setter]\n    fn set_num(&mut self, value: i32) -> PyResult<()> {\n        self.num = value;\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Between Py<T> and Bound<'py, T> Smart Pointers in Rust\nDESCRIPTION: This code demonstrates how to convert between Py<T> and Bound<'py, T> smart pointer types using bind(), into_bound(), as_unbound(), and unbind() methods. These operations allow switching between owned and borrowing representations of Python objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyAny> = ...;\nlet bound: &Bound<'py, PyAny> = obj.bind(py);\nlet bound: Bound<'py, PyAny> = obj.into_bound(py);\n\nlet obj: &Py<PyAny> = bound.as_unbound();\nlet obj: Py<PyAny> = bound.unbind();\n```\n\n----------------------------------------\n\nTITLE: Custom Error Type with Python Exception Conversion\nDESCRIPTION: Implements a custom Rust error type with conversion to Python OSError through From trait implementation. Includes a complete example with error definition and usage.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/error-handling.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::exceptions::PyOSError;\nuse pyo3::prelude::*;\nuse std::fmt;\n\n#[derive(Debug)]\nstruct CustomIOError;\n\nimpl std::error::Error for CustomIOError {}\n\nimpl fmt::Display for CustomIOError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"Oh no!\")\n    }\n}\n\nimpl std::convert::From<CustomIOError> for PyErr {\n    fn from(err: CustomIOError) -> PyErr {\n        PyOSError::new_err(err.to_string())\n    }\n}\n\npub struct Connection {/* ... */}\n\nfn bind(addr: String) -> Result<Connection, CustomIOError> {\n    if &addr == \"0.0.0.0\" {\n        Err(CustomIOError)\n    } else {\n        Ok(Connection{ /* ... */})\n    }\n}\n\n#[pyfunction]\nfn connect(s: String) -> Result<(), CustomIOError> {\n    bind(s)?;\n    // etc.\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting Python List to Rust Vector\nDESCRIPTION: Demonstrates the basic usage of the extract() method to convert a Python list to a Rust Vec<i32>. The method returns a PyResult with a type error if conversion fails.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet v: Vec<i32> = list.extract()?\n```\n\n----------------------------------------\n\nTITLE: Customizing Module Name in PyO3\nDESCRIPTION: Demonstrates how to override the default module name using the #[pyo3(name = \"custom_name\")] attribute. This allows the module to be imported in Python with a different name than the Rust function name.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn double(x: usize) -> usize {\n    x * 2\n}\n\n#[pymodule(name = \"custom_name\")]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(double, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe PyO3 Class Using Mutex Locks\nDESCRIPTION: A PyO3 class implementation that uses a Mutex to ensure thread safety by making threads wait for access to shared data. The frozen attribute is used to prevent PyO3 from adding its own interior mutability.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/thread-safety.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Mutex;\n\nstruct MyClassInner {\n    x: i32,\n    y: i32,\n}\n\n#[pyclass(frozen)]\nstruct MyClass {\n    inner: Mutex<MyClassInner>\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.inner.lock().expect(\"lock not poisoned\").x\n    }\n\n    fn set_y(&self, value: i32) {\n        self.inner.lock().expect(\"lock not poisoned\").y = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Python Expressions with eval in Rust\nDESCRIPTION: Shows how to use Python::eval to execute a Python expression from Rust. This example evaluates a list comprehension and extracts the result as a Rust vector.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::ffi::c_str;\n\n# fn main() -> Result<(), ()> {\nPython::with_gil(|py| {\n    let result = py\n        .eval(c_str!(\"[i * 10 for i in range(5)]\"), None, None)\n        .map_err(|e| {\n            e.print_and_set_sys_last_vars(py);\n        })?;\n    let res: Vec<i64> = result.extract().unwrap();\n    assert_eq!(res, vec![0, 10, 20, 30, 40]);\n    Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Working with Generic Types in Python Classes\nDESCRIPTION: Example demonstrating how to work around PyO3's restriction on generic parameters in #[pyclass] by using a macro to create concrete implementations for each type needed.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\nstruct GenericClass<T> {\n    data: T,\n}\n\nmacro_rules! create_interface {\n    ($name: ident, $type: ident) => {\n        #[pyclass]\n        pub struct $name {\n            inner: GenericClass<$type>,\n        }\n        #[pymethods]\n        impl $name {\n            #[new]\n            pub fn new(data: $type) -> Self {\n                Self {\n                    inner: GenericClass { data: data },\n                }\n            }\n        }\n    };\n}\n\ncreate_interface!(IntClass, i64);\ncreate_interface!(FloatClass, String);\n```\n\n----------------------------------------\n\nTITLE: Implementing Getter Methods for Properties\nDESCRIPTION: Example demonstrating how to create property getters using the #[getter] attribute in a #[pymethods] block, useful for properties requiring computation or side effects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    #[getter]\n    fn num(&self) -> PyResult<i32> {\n        Ok(self.num)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Class Attributes with Constants\nDESCRIPTION: Example demonstrating how to define class attributes using associated constants, which is simpler when the attribute value is a constant expression.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[classattr]\n    const MY_CONST_ATTRIBUTE: &'static str = \"foobar\";\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a PyO3 Project Directly with Maturin\nDESCRIPTION: Commands to create a new PyO3 project using Maturin's new command, specifying PyO3 as the binding type, and setting up a Python environment.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nmaturin new -b pyo3 pyo3-example\ncd pyo3-example\npyenv virtualenv pyo3\npyenv local pyo3\n```\n\n----------------------------------------\n\nTITLE: Downcasting to Custom PyClass Types in PyO3\nDESCRIPTION: This code shows how to cast from a generic PyAny to a custom #[pyclass] type named MyClass. It demonstrates both non-transferring ownership with downcast() and transferring ownership with downcast_into(), leveraging the PyTypeCheck trait implementation for custom classes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {}\n\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = Bound::new(py, MyClass {})?.into_any();\n\n// use `.downcast()` to cast to `MyClass` without transferring ownership\nlet _: &Bound<'py, MyClass> = obj.downcast()?;\n\n// use `.downcast_into()` to cast to `MyClass` with transfer of ownership\nlet _: Bound<'py, MyClass> = obj.downcast_into()?;\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Implementing GIL Release for Async Operations\nDESCRIPTION: Shows how to implement a wrapper type AllowThreads that enables releasing the GIL during future polling. This is a workaround for handling the GIL in async contexts.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/async-await.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::{future::Future, pin::{Pin, pin}, task::{Context, Poll}};\nuse pyo3::prelude::*;\n\nstruct AllowThreads<F>(F);\n\nimpl<F> Future for AllowThreads<F>\nwhere\n    F: Future + Unpin + Send,\n    F::Output: Send,\n{\n    type Output = F::Output;\n\n    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n        let waker = cx.waker();\n        Python::with_gil(|gil| {\n            gil.allow_threads(|| pin!(&mut self.0).poll(&mut Context::from_waker(waker)))\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing GC Support in PyO3 Rust Class\nDESCRIPTION: Example implementation of garbage collector integration for a PyO3 class that holds a reference to a Python object. Shows how to implement __traverse__ to visit referenced objects and __clear__ to break reference cycles.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::PyTraverseError;\nuse pyo3::gc::PyVisit;\n\n#[pyclass]\nstruct ClassWithGCSupport {\n    obj: Option<PyObject>,\n}\n\n#[pymethods]\nimpl ClassWithGCSupport {\n    fn __traverse__(&self, visit: PyVisit<'_>) -> Result<(), PyTraverseError> {\n        if let Some(obj) = &self.obj {\n            visit.call(obj)?\n        }\n        Ok(())\n    }\n\n    fn __clear__(&mut self) {\n        // Clear reference, this decrements ref counter.\n        self.obj = None;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellable Async Function in PyO3\nDESCRIPTION: Shows how to implement a cancellable async function using CancelHandle. The function can be cancelled from Python and will handle the cancellation appropriately.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/async-await.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse futures::FutureExt;\nuse pyo3::prelude::*;\nuse pyo3::coroutine::CancelHandle;\n\n#[pyfunction]\nasync fn cancellable(#[pyo3(cancel_handle)] mut cancel: CancelHandle) {\n    futures::select! {\n        /* _ = ... => println!(\"done\"), */\n        _ = cancel.cancelled().fuse() => println!(\"cancelled\"),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Model Trait and Solver Function in Rust\nDESCRIPTION: Defines a Model trait with three required methods and a solve function that operates on any type implementing the Model trait.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait Model {\n    fn set_variables(&mut self, inputs: &Vec<f64>);\n    fn compute(&mut self);\n    fn get_results(&self) -> Vec<f64>;\n}\n\npub fn solve<T: Model>(model: &mut T) {\n    println!(\"Magic solver that mutates the model into a resolved state\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Custom Exception in PyO3\nDESCRIPTION: Shows a complete example of creating a custom exception, adding it to a Python context, and verifying its behavior in Python code. The example demonstrates string representation and argument handling.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::create_exception;\nuse pyo3::types::IntoPyDict;\nuse pyo3::exceptions::PyException;\n\ncreate_exception!(mymodule, CustomError, PyException);\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    let ctx = [(\"CustomError\", py.get_type::<CustomError>())].into_py_dict(py)?;\n    pyo3::py_run!(\n        py,\n        *ctx,\n        \"assert str(CustomError) == \\\"<class 'mymodule.CustomError'>\\\"\"\n    );\n    pyo3::py_run!(py, *ctx, \"assert CustomError('oops').args == ('oops',)\");\n#   Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Using Py<T> to Avoid Cloning with PyO3 Getters\nDESCRIPTION: Shows how to use Py<T> to store references to Python heap-allocated objects, avoiding unnecessary cloning when accessing struct fields from Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Inner {/* fields omitted */}\n\n#[pyclass]\nstruct Outer {\n    inner: Py<Inner>,\n}\n\n#[pymethods]\nimpl Outer {\n    #[new]\n    fn __new__(py: Python<'_>) -> PyResult<Self> {\n        Ok(Self {\n            inner: Py::new(py, Inner {})?,\n        })\n    }\n\n    #[getter]\n    fn inner(&self, py: Python<'_>) -> Py<Inner> {\n        self.inner.clone_ref(py)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation of Custom Number Class in PyO3\nDESCRIPTION: Provides the full implementation of the Number class, including all arithmetic operations, comparisons, and Python integration methods.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\nuse std::hash::{Hash, Hasher};\n\nuse pyo3::exceptions::{PyValueError, PyZeroDivisionError};\nuse pyo3::prelude::*;\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::{PyComplex, PyString};\n\nfn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {\n    let val = obj.call_method1(\"__and__\", (0xFFFFFFFF_u32,))?;\n    let val: u32 = val.extract()?;\n    Ok(val as i32)\n}\n/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\n/// It's not a story C would tell you. It's a Rust legend.\n#[pyclass(module = \"my_module\")]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(#[pyo3(from_py_with = wrap)] value: i32) -> Self {\n        Self(value)\n    }\n\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n       // Get the class name dynamically in case `Number` is subclassed\n       let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        Ok(format!(\"{}{}\", class_name, slf.borrow().0))\n    }\n\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> PyResult<bool> {\n        match op {\n            CompareOp::Lt => Ok(self.0 < other.0),\n            CompareOp::Le => Ok(self.0 <= other.0),\n            CompareOp::Eq => Ok(self.0 == other.0),\n            CompareOp::Ne => Ok(self.0 != other.0),\n            CompareOp::Gt => Ok(self.0 > other.0),\n            CompareOp::Ge => Ok(self.0 >= other.0),\n        }\n    }\n\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n\n    fn __add__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_add(other.0))\n    }\n\n    fn __sub__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_sub(other.0))\n    }\n\n    fn __mul__(&self, other: &Self) -> Self {\n        Self(self.0.wrapping_mul(other.0))\n    }\n\n    fn __truediv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __floordiv__(&self, other: &Self) -> PyResult<Self> {\n        match self.0.checked_div(other.0) {\n            Some(i) => Ok(Self(i)),\n            None => Err(PyZeroDivisionError::new_err(\"division by zero\")),\n        }\n    }\n\n    fn __rshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shr(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __lshift__(&self, other: &Self) -> PyResult<Self> {\n        match other.0.try_into() {\n            Ok(rhs) => Ok(Self(self.0.wrapping_shl(rhs))),\n            Err(_) => Err(PyValueError::new_err(\"negative shift count\")),\n        }\n    }\n\n    fn __xor__(&self, other: &Self) -> Self {\n        Self(self.0 ^ other.0)\n    }\n\n    fn __or__(&self, other: &Self) -> Self {\n        Self(self.0 | other.0)\n    }\n\n    fn __and__(&self, other: &Self) -> Self {\n        Self(self.0 & other.0)\n    }\n\n    fn __int__(&self) -> i32 {\n        self.0\n    }\n\n    fn __float__(&self) -> f64 {\n        self.0 as f64\n    }\n\n    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {\n        PyComplex::from_doubles(py, self.0 as f64, 0.0)\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Bidirectional Logging with pyo3-pylogger\nDESCRIPTION: Example showing how to set up bidirectional logging between Python and Rust using pyo3-pylogger, including initialization of environment logger and demonstration of logging from both languages.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/ecosystem/logging.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse log::{info, warn};\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    // register the host handler with python logger, providing a logger target\n    // set the name here to something appropriate for your application\n    pyo3_pylogger::register(\"example_application_py_logger\");\n\n    // initialize up a logger\n    env_logger::Builder::from_env(env_logger::Env::default().default_filter_or(\"trace\")).init();\n\n    // Log some messages from Rust.\n    info!(\"Just some normal information!\");\n    warn!(\"Something spooky happened!\");\n\n    // Log some messages from Python\n    Python::with_gil(|py| {\n        py.run(\n            \"\nimport logging\nlogging.error('Something bad happened')\n\",\n            None,\n            None,\n        )\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 Simple Enum Implementation\nDESCRIPTION: Shows how to implement a simple enum with PyO3 including comparison and integer conversion support.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, eq_int)]\n#[derive(PartialEq)]\nenum MyEnum {\n    Variant,\n    OtherVariant,\n}\n\nPython::with_gil(|py| {\n    let x = Py::new(py, MyEnum::Variant).unwrap();\n    let y = Py::new(py, MyEnum::OtherVariant).unwrap();\n    let cls = py.get_type::<MyEnum>();\n    pyo3::py_run!(py, x y cls, r#\"\n        assert x == cls.Variant\n        assert y == cls.OtherVariant\n        assert x != y\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Migrating from PyProto to PyMethods in Rust\nDESCRIPTION: Example showing how to migrate from deprecated #[pyproto] attribute to #[pymethods] for implementing Python magic methods. The new implementation simplifies the code by consolidating protocol methods directly in the pymethods block.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_25\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::class::{PyObjectProtocol, PyIterProtocol};\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct MyClass {}\n\n#[pyproto]\nimpl PyObjectProtocol for MyClass {\n    fn __str__(&self) -> &'static [u8] {\n        b\"hello, world\"\n    }\n}\n\n#[pyproto]\nimpl PyIterProtocol for MyClass {\n    fn __iter__(slf: PyRef<self>) -> PyResult<&PyAny> {\n        PyString::new(slf.py(), \"hello, world\").iter()\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyString;\n\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    fn __str__(&self) -> &'static [u8] {\n        b\"hello, world\"\n    }\n\n    fn __iter__(slf: PyRef<self>) -> PyResult<&PyAny> {\n        PyString::new(slf.py(), \"hello, world\").iter()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Separate Iterable and Iterator Classes in PyO3\nDESCRIPTION: Demonstrates how to implement Python's iteration protocol with separate iterable and iterator classes in PyO3. The Container class generates Iter objects that handle the actual iteration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n\n#[pyclass]\nstruct Iter {\n    inner: std::vec::IntoIter<usize>,\n}\n\n#[pymethods]\nimpl Iter {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n\n    fn __next__(mut slf: PyRefMut<'_, Self>) -> Option<usize> {\n        slf.inner.next()\n    }\n}\n\n#[pyclass]\nstruct Container {\n    iter: Vec<usize>,\n}\n\n#[pymethods]\nimpl Container {\n    fn __iter__(slf: PyRef<'_, Self>) -> PyResult<Py<Iter>> {\n        let iter = Iter {\n            inner: slf.iter.clone().into_iter(),\n        };\n        Py::new(slf.py(), iter)\n    }\n}\n\n# Python::with_gil(|py| {\n#     let container = Container { iter: vec![1, 2, 3, 4] };\n#     let inst = pyo3::Py::new(py, container).unwrap();\n#     pyo3::py_run!(py, inst, \"assert list(inst) == [1, 2, 3, 4]\");\n#     pyo3::py_run!(py, inst, \"assert list(iter(iter(inst))) == [1, 2, 3, 4]\");\n# });\n```\n\n----------------------------------------\n\nTITLE: Casting Between Python Types Using downcast() in PyO3\nDESCRIPTION: This code demonstrates type casting between Python objects using downcast() and downcast_into() methods. It shows how to cast from a generic PyAny to a specific PyTuple type, both with and without transferring ownership of the object.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::PyTuple;\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = PyTuple::empty(py).into_any();\n\n// use `.downcast()` to cast to `PyTuple` without transferring ownership\nlet _: &Bound<'py, PyTuple> = obj.downcast()?;\n\n// use `.downcast_into()` to cast to `PyTuple` with transfer of ownership\nlet _: Bound<'py, PyTuple> = obj.downcast_into()?;\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Custom Enum with FromPyObject Derive\nDESCRIPTION: Example showing a Rust enum with custom Python type annotations using #[pyo3] attributes to control error messages during type conversion failures.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[derive(FromPyObject)]\nenum RustyEnum {\n    #[pyo3(transparent, annotation = \"str\")]\n    String(String),\n    #[pyo3(transparent, annotation = \"int\")]\n    Int(isize),\n}\n```\n\n----------------------------------------\n\nTITLE: Using the into_py_with Field Attribute in IntoPyObject Derive\nDESCRIPTION: Demonstration of the into_py_with field attribute to apply a custom function for converting a field from Rust into Python. Shows how to implement a conversion function that works with both IntoPyObject and IntoPyObjectRef derive macros.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(Clone)]\nstruct NotIntoPy(usize);\n\n#[derive(IntoPyObject, IntoPyObjectRef)]\nstruct MyStruct {\n    #[pyo3(into_py_with = convert)]\n    not_into_py: NotIntoPy,\n}\n\n/// Convert `NotIntoPy` into Python\nfn convert<'py>(not_into_py: Cow<'_, NotIntoPy>, py: Python<'py>) -> PyResult<Bound<'py, PyAny>> {\n    not_into_py.0.into_bound_py_any(py)\n}\n```\n\n----------------------------------------\n\nTITLE: Using BoundObject to Work with Both Bound and Borrowed Types\nDESCRIPTION: Example showing the difference between IntoPyObject implementations that return Bound vs Borrowed. Includes a generic function that uses BoundObject trait to convert different vectors into a common Vec<Py<PyAny>> format.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nfn convert_to_vec_of_pyobj<'py, T>(py: Python<'py>, the_vec: Vec<T>) -> PyResult<Vec<Py<PyAny>>>\nwhere\n   T: IntoPyObject<'py> + Copy\n{\n    the_vec.iter()\n        .map(|x| {\n            Ok(\n                // Note: the below is equivalent to `x.into_py_any()`\n                // from the `IntoPyObjectExt` trait\n                x.into_pyobject(py)\n                .map_err(Into::into)?\n                .into_any()\n                .unbind()\n            )\n        })\n        .collect()\n}\n\nlet vec_of_pyobjs: Vec<Py<PyAny>> = Python::with_gil(|py| {\n    let mut bools_as_pyany = convert_to_vec_of_pyobj(py, bools).unwrap();\n    let mut ints_as_pyany = convert_to_vec_of_pyobj(py, ints).unwrap();\n    let mut result: Vec<Py<PyAny>> = vec![];\n    result.append(&mut bools_as_pyany);\n    result.append(&mut ints_as_pyany);\n    result\n});\n```\n\n----------------------------------------\n\nTITLE: Sharing Python Objects Between Rust Threads\nDESCRIPTION: Example showing how to share Python objects between Rust threads by properly dropping and re-acquiring the GIL. It uses rayon for parallelization while avoiding deadlocks with Python objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/parallelism.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n// These traits let us use int_par_iter and map\nuse rayon::iter::{IntoParallelRefIterator, ParallelIterator};\n\n#[pyclass]\nstruct UserID {\n    id: i64,\n}\n\nlet allowed_ids: Vec<bool> = Python::with_gil(|outer_py| {\n    let instances: Vec<Py<UserID>> = (0..10).map(|x| Py::new(outer_py, UserID { id: x }).unwrap()).collect();\n    outer_py.allow_threads(|| {\n        instances.par_iter().map(|instance| {\n            Python::with_gil(|inner_py| {\n                instance.borrow(inner_py).id > 5\n            })\n        }).collect()\n    })\n});\nassert!(allowed_ids.into_iter().filter(|b| *b).count() == 4);\n```\n\n----------------------------------------\n\nTITLE: Calling a Python Function with Keyword Arguments using PyO3\nDESCRIPTION: This snippet shows how to call a Python function with keyword arguments. It uses the `call` method with separate tuples for positional and keyword arguments.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function-calls.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::IntoPyDict;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let fun = PyModule::import(py, \"builtins\")?.getattr(\"max\")?\n        let args = (1, 2);\n        let kwargs = vec![(\"default\", 0)].into_py_dict(py);\n        let result = fun.call(args, Some(kwargs))?;\n        assert_eq!(result.extract::<i32>()?, 2);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Module to PyO3 Function\nDESCRIPTION: Demonstrates how to use #[pyo3(pass_module)] to pass the containing module as the first argument to a Python function defined in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyString;\n\n#[pyfunction]\n#[pyo3(pass_module)]\nfn pyfunction_with_module<'py>(\n    module: &Bound<'py, PyModule>,\n) -> PyResult<Bound<'py, PyString>> {\n    module.name()\n}\n\n#[pymodule]\nfn module_with_fn(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(pyfunction_with_module, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Cloning Behavior with PyO3 Getter\nDESCRIPTION: Illustrates how PyO3's #[pyo3(get)] attribute can lead to unexpected cloning of struct fields when accessed from Python code.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\n#[derive(Clone)]\nstruct Inner {/* fields omitted */}\n\n#[pyclass]\nstruct Outer {\n    #[pyo3(get)]\n    inner: Inner,\n}\n\n#[pymethods]\nimpl Outer {\n    #[new]\n    fn __new__() -> Self {\n        Self { inner: Inner {} }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving FromPyObject for a Basic Struct\nDESCRIPTION: Shows how to derive FromPyObject for a struct, where field extraction attempts to access Python object attributes with the same name as the struct fields.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    my_string: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Thread-Unsafe Iterator in PyO3\nDESCRIPTION: Example of a basic PyO3 class that demonstrates potential thread-safety issues when accessed concurrently. The class implements a simple counter that increments on each iteration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Default)]\nstruct ThreadIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl ThreadIter {\n    #[new]\n    pub fn new() -> Self {\n        Default::default()\n    }\n\n    fn __next__(&mut self, py: Python<'_>) -> usize {\n        self.count += 1;\n        self.count\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Transparent Type Conversion with IntoPyObject\nDESCRIPTION: Implementation of transparent type conversion using the #[pyo3(transparent)] attribute for newtype pattern structs.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(IntoPyObject)]\nstruct TransparentTuple(PyObject);\n\n#[derive(IntoPyObject)]\n#[pyo3(transparent)]\nstruct TransparentStruct<'py> {\n    inner: Bound<'py, PyAny>,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Python's ThreadPoolExecutor with PyO3 Functions\nDESCRIPTION: Python code that demonstrates how to use ThreadPoolExecutor to run PyO3 functions in parallel, achieving true parallelism by releasing the GIL during function execution.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/parallelism.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom concurrent.futures import ThreadPoolExecutor\nfrom word_count import search_sequential_allow_threads\n\nexecutor = ThreadPoolExecutor(max_workers=2)\n\nfuture_1 = executor.submit(\n    word_count.search_sequential_allow_threads, contents, needle\n)\nfuture_2 = executor.submit(\n    word_count.search_sequential_allow_threads, contents, needle\n)\nresult_1 = future_1.result()\nresult_2 = future_2.result()\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for PyO3\nDESCRIPTION: Example Cargo.toml configuration for a PyO3 project, specifying cdylib crate type and PyO3 dependencies with extension-module feature.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_8\n\nLANGUAGE: toml\nCODE:\n```\n# If you already have [package] information in `Cargo.toml`, you can ignore\n# this section!\n[package]\n# `name` here is name of the package.\nname = \"pyo3_start\"\n# these are good defaults:\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# The name of the native library. This is the name which will be used in Python to import the\n# library (i.e. `import string_sum`). If you change this, you must also change the name of the\n# `#[pymodule]` in `src/lib.rs`.\nname = \"pyo3_example\"\n\n# \"cdylib\" is necessary to produce a shared library for Python to import from.\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { {{#PYO3_CRATE_VERSION}}, features = [\"extension-module\"] }\n```\n\n----------------------------------------\n\nTITLE: Importing Python Exceptions into Rust with import_exception! Macro\nDESCRIPTION: Shows how to import exceptions defined in Python modules for use in Rust code. The example creates a Rust type for the io.UnsupportedOperation exception and uses it in error handling.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#![allow(dead_code)]\nuse pyo3::prelude::*;\n\nmod io {\n    pyo3::import_exception!(io, UnsupportedOperation);\n}\n\nfn tell(file: &Bound<'_, PyAny>) -> PyResult<u64> {\n    match file.call_method0(\"tell\") {\n        Err(_) => Err(io::UnsupportedOperation::new_err(\"not supported: tell\")),\n        Ok(x) => x.extract::<u64>(),\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Python List Items Using PyO3 Traits in Rust\nDESCRIPTION: This function demonstrates accessing the first item in a Python list using the get_item() method from the PyListMethods trait. It returns the item as a Bound<'py, PyAny> and includes a test that verifies it works correctly with a string item.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn get_first_item<'py>(list: &Bound<'py, PyList>) -> PyResult<Bound<'py, PyAny>> {\n    list.get_item(0)\n}\n# Python::with_gil(|py| {\n#     let l = PyList::new(py, [\"hello world\"]).unwrap();\n#     assert!(get_first_item(&l).unwrap().eq(\"hello world\").unwrap());\n# })\n```\n\n----------------------------------------\n\nTITLE: Manual IntoPyObject Implementation - After\nDESCRIPTION: Updated implementation using the new IntoPyObject trait with support for owned and referenced types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'py> IntoPyObject<'py> for MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Bound<'py, Self::Target>;\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.into_bound(py))\n    }\n}\n\nimpl<'a, 'py> IntoPyObject<'py> for &'a MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Borrowed<'a, 'py, Self::Target>;\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.bind_borrowed(py))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Complex Enums in PyO3\nDESCRIPTION: Demonstrates how to expose complex enums with struct and tuple variants to Python. Shows field access, pattern matching, and automatic type conversions between Rust and Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nenum Shape {\n    Circle { radius: f64 },\n    Rectangle { width: f64, height: f64 },\n    RegularPolygon(u32, f64),\n    Nothing { },\n}\n\n# #[cfg(Py_3_10)]\nPython::with_gil(|py| {\n    let circle = Shape::Circle { radius: 10.0 }.into_pyobject(py)?;\n    let square = Shape::RegularPolygon(4, 10.0).into_pyobject(py)?;\n    let cls = py.get_type::<Shape>();\n    pyo3::py_run!(py, circle square cls, r#\"\n        assert isinstance(circle, cls)\n        assert isinstance(circle, cls.Circle)\n        assert circle.radius == 10.0\n\n        assert isinstance(square, cls)\n        assert isinstance(square, cls.RegularPolygon)\n        assert square[0] == 4 # Gets _0 field\n        assert square[1] == 10.0 # Gets _1 field\n\n        def count_vertices(cls, shape):\n            match shape:\n                case cls.Circle():\n                    return 0\n                case cls.Rectangle():\n                    return 4\n                case cls.RegularPolygon(n):\n                    return n\n                case cls.Nothing():\n                    return 0\n\n        assert count_vertices(cls, circle) == 0\n        assert count_vertices(cls, square) == 4\n    \"#);\n#   Ok::<_, PyErr>(())\n})\n# .unwrap();\n```\n\n----------------------------------------\n\nTITLE: Custom Argument Conversion in PyO3\nDESCRIPTION: Shows how to use #[pyo3(from_py_with = ...)] to specify a custom function for converting a Python argument to a Rust type.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn get_length(obj: &Bound<'_, PyAny>) -> PyResult<usize> {\n    obj.len()\n}\n\n#[pyfunction]\nfn object_length(#[pyo3(from_py_with = get_length)] argument: usize) -> usize {\n    argument\n}\n```\n\n----------------------------------------\n\nTITLE: Calling a Simple Python Function from Rust using PyO3\nDESCRIPTION: This snippet shows how to call a simple Python function that takes no arguments and returns a string. It demonstrates the basic usage of PyO3 to interact with Python code from Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function-calls.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let fun = PyModule::import(py, \"builtins\")?.getattr(\"len\")?\n        let result = fun.call1((\"Hello\",))?;\n        assert_eq!(result.extract::<usize>()?, 5);\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Rust UserModel Wrapper Implementation\nDESCRIPTION: Rust wrapper struct that implements the Model trait by forwarding calls to the Python model.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct UserModel {\n    model: Py<PyAny>,\n}\n\nimpl Model for UserModel {\n    fn set_variables(&mut self, var: &Vec<f64>) {\n        println!(\"Rust calling Python to set the variables\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"set_variables\", (PyList::new(py, var).unwrap(),), None)\n                .unwrap();\n        })\n    }\n\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Rust calling Python to get the results\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap()\n                .extract()\n                .unwrap()\n        })\n    }\n\n    fn compute(&mut self) {\n        println!(\"Rust calling Python to perform the computation\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"compute\", (), None)\n                .unwrap();\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: VS Code Debug Configuration for PyO3\nDESCRIPTION: Launch configuration for debugging PyO3 applications in VS Code using LLDB debugger with various debugging scenarios.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Debug PyO3\",\n            \"type\": \"lldb\",\n            \"request\": \"attach\",\n            \"program\": \"${workspaceFolder}/.venv/bin/python\",\n            \"pid\": \"${command:pickProcess}\",\n            \"sourceLanguages\": [\n                \"rust\"\n            ]\n        },\n        {\n            \"name\": \"Launch Python with PyO3\",\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/.venv/bin/python\",\n            \"args\": [\"${file}\"],\n            \"cwd\": \"${workspaceFolder}\",\n            \"sourceLanguages\": [\"rust\"]\n        },\n        {\n            \"name\": \"Debug PyO3 with Args\",\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/.venv/bin/python\",\n            \"args\": [\"path/to/your/script.py\", \"arg1\", \"arg2\"],\n            \"cwd\": \"${workspaceFolder}\",\n            \"sourceLanguages\": [\"rust\"]\n        },\n        {\n            \"name\": \"Debug PyO3 Tests\",\n            \"type\": \"lldb\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/.venv/bin/python\",\n            \"args\": [\"-m\", \"pytest\", \"tests/your_test.py::test_function\", \"-v\"],\n            \"cwd\": \"${workspaceFolder}\",\n            \"sourceLanguages\": [\"rust\"]\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Py<T> for Longer-Lived Python Objects\nDESCRIPTION: Shows how to use Py<T> to create Python objects with a longer lifetime, which can be stored in Rust structs. It demonstrates creating, returning, and accessing such objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct MyClass {\n    num: i32,\n}\n\nfn return_myclass() -> Py<MyClass> {\n    Python::with_gil(|py| Py::new(py, MyClass { num: 1 }).unwrap())\n}\n\nlet obj = return_myclass();\n\nPython::with_gil(move |py| {\n    let bound = obj.bind(py); // Py<MyClass>::bind returns &Bound<'py, MyClass>\n    let obj_ref = bound.borrow(); // Get PyRef<T>\n    assert_eq!(obj_ref.num, 1);\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Serializable and Deserializable PyO3 Classes with Serde in Rust\nDESCRIPTION: Demonstrates how to use the 'serde' feature flag to enable serialization and deserialization of PyO3 classes. This allows the use of #[derive(Serialize, Deserialize)] on structs containing references to #[pyclass] instances.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/features.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\n#[derive(Serialize, Deserialize)]\nstruct Permission {\n    name: String,\n}\n\n#[pyclass]\n#[derive(Serialize, Deserialize)]\nstruct User {\n    username: String,\n    permissions: Vec<Py<Permission>>,\n}\n```\n\n----------------------------------------\n\nTITLE: Sequential Word Count Implementation in Rust\nDESCRIPTION: A sequential version of the word count function that processes lines one at a time. This serves as a baseline for demonstrating parallelism benefits.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/parallelism.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# fn count_line(line: &str, needle: &str) -> usize {\n#     let mut total = 0;\n#     for word in line.split(' ') {\n#         if word == needle {\n#             total += 1;\n#         }\n#     }\n#     total\n# }\n#\nfn search_sequential(contents: &str, needle: &str) -> usize {\n    contents.lines().map(|line| count_line(line, needle)).sum()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tracing in Rust Extension Modules with pyo3-python-tracing-subscriber\nDESCRIPTION: Example of how to implement tracing in a Rust extension module using pyo3-python-tracing-subscriber. It shows how to instrument a function and initialize tracing with a Python-provided implementation.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/ecosystem/tracing.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[tracing::instrument]\n#[pyfunction]\nfn fibonacci(index: usize, use_memoized: bool) -> PyResult<usize> {\n    // ...\n}\n\n#[pyfunction]\npub fn initialize_tracing(py_impl: Bound<'_, PyAny>) {\n    tracing_subscriber::registry()\n        .with(pyo3_python_tracing_subscriber::PythonCallbackLayerBridge::new(py_impl))\n        .init();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Thread-Safe PyO3 Class Using Interior Mutability\nDESCRIPTION: A simple PyO3 class that is thread-safe using PyO3's default interior mutability pattern. This allows either multiple readers or a single writer to access the data, with runtime checks preventing concurrent access.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/thread-safety.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {\n    x: i32,\n    y: i32,\n}\n\n#[pymethods]\nimpl MyClass {\n    fn get_x(&self) -> i32 {\n        self.x\n    }\n\n    fn set_y(&mut self, value: i32) {\n        self.y = value;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Using Bound<'py, PyList> without Type Annotations\nDESCRIPTION: A more concise version of the previous example without explicit type annotations, relying on Rust's type inference to determine the types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn example(py: Python<'_>) -> PyResult<()> {\n    let x = PyList::empty(py);\n    x.append(1)?;\n    let y = x.clone();\n    drop(x);\n    Ok(())\n}\n# Python::with_gil(example).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Creating Python Modules from Code Snippets in Rust\nDESCRIPTION: Illustrates how to use PyModule::from_code to create a Python module from a code snippet in Rust. This example defines Python functions and calls them from Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{prelude::*, types::IntoPyDict};\nuse pyo3_ffi::c_str;\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| {\n    let activators = PyModule::from_code(\n        py,\n        c_str!(r#\"\ndef relu(x):\n    \"\"\"see https://en.wikipedia.org/wiki/Rectifier_(neural_networks)\"\"\"\n    return max(0.0, x)\n\ndef leaky_relu(x, slope=0.01):\n    return x if x >= 0 else x * slope\n    \"#),\n        c_str!(\"activators.py\"),\n        c_str!(\"activators\"),\n    )?;\n\n    let relu_result: f64 = activators.getattr(\"relu\")?.call1((-1.0,))?.extract()?;\n    assert_eq!(relu_result, 0.0);\n\n    let kwargs = [(\"slope\", 0.2)].into_py_dict(py)?;\n    let lrelu_result: f64 = activators\n        .getattr(\"leaky_relu\")?\n        .call((-1.0,), Some(&kwargs))?\n        .extract()?;\n    assert_eq!(lrelu_result, -0.2);\n#    Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Creating Class Attributes with Method Functions\nDESCRIPTION: Example showing how to define class attributes (class variables) using the #[classattr] attribute on methods that take no arguments.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[classattr]\n    fn my_attribute() -> String {\n        \"hello\".to_string()\n    }\n}\n\nPython::with_gil(|py| {\n    let my_class = py.get_type::<MyClass>();\n    pyo3::py_run!(py, my_class, \"assert my_class.my_attribute == 'hello'\")\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing Type Checks with downcast in PyO3\nDESCRIPTION: Shows a more efficient approach to polymorphic type handling by using downcast() instead of extract() for native Python types, avoiding the costly conversion of PyDowncastError to PyErr.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/performance.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn frobnicate<'py>(value: &Bound<'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {\n    // Use `downcast` instead of `extract` as turning `PyDowncastError` into `PyErr` is quite costly.\n    if let Ok(list) = value.downcast::<PyList>() {\n        frobnicate_list(list)\n    } else if let Ok(vec) = value.extract::<Vec<Bound<'_, PyAny>>>() {\n        frobnicate_vec(vec)\n    } else {\n        Err(PyTypeError::new_err(\"Cannot frobnicate that type.\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling System Signals in Rust with PyO3\nDESCRIPTION: This snippet shows how to handle system signals (like Ctrl-C) in Rust code using PyO3. It sets the SIGINT signal to have the default action using Python's signal module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n# fn main() -> PyResult<()> {\nPython::with_gil(|py| -> PyResult<()> {\n    let signal = py.import(\"signal\")?;\n    // Set SIGINT to have the default action\n    signal\n        .getattr(\"signal\")?\n        .call1((signal.getattr(\"SIGINT\")?, signal.getattr(\"SIG_DFL\")?))?;\n    Ok(())\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Defining Car Class in Python Stub File\nDESCRIPTION: Example of a stub file (*.pyi) for a PyO3 module, defining a Car class with type hints and docstrings.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-typing-hints.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Car:\n    \"\"\"\n    A class representing a car.\n\n    :param body_type: the name of body type, e.g. hatchback, sedan\n    :param horsepower: power of the engine in horsepower\n    \"\"\"\n    def __init__(self, body_type: str, horsepower: int) -> None: ...\n\n    @classmethod\n    def from_unique_name(cls, name: str) -> 'Car':\n        \"\"\"\n        Creates a Car based on unique name\n\n        :param name: model name of a car to be created\n        :return: a Car instance with default data\n        \"\"\"\n\n    def best_color(self) -> str:\n        \"\"\"\n        Gets the best color for the car.\n\n        :return: the name of the color our great algorithm thinks is the best for this car\n        \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Extracting Rust Data from Python Objects Using extract() in PyO3\nDESCRIPTION: This code demonstrates how to extract Rust data structures from Python objects using the extract() method. It creates a Python tuple of integers and extracts it into a Rust tuple of i32 values, making use of the FromPyObject trait implementation.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::PyTuple;\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// create a new Python `tuple`, and use `.into_any()` to erase the type\nlet obj: Bound<'py, PyAny> = PyTuple::new(py, [1, 2, 3])?.into_any();\n\n// extracting the Python `tuple` to a rust `(i32, i32, i32)` tuple\nlet (x, y, z) = obj.extract::<(i32, i32, i32)>()?;\nassert_eq!((x, y, z), (1, 2, 3));\n# Ok(())\n# }\n# Python::with_gil(example).unwrap()\n```\n\n----------------------------------------\n\nTITLE: Accessing Python Class Name in __repr__\nDESCRIPTION: Shows how to access the Python class name in __repr__ to handle subclassing properly. This uses a Bound parameter to get access to both Python type information and the Rust struct fields.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __repr__(slf: &Bound<'_, Self>) -> PyResult<String> {\n        // This is the equivalent of `self.__class__.__name__` in Python.\n        let class_name: Bound<'_, PyString> = slf.get_type().qualname()?;\n        // To access fields of the Rust struct, we need to borrow the `PyCell`.\n        Ok(format!(\"{}({})\", class_name, slf.borrow().0))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Rust-Python Type Conversion with Unwrap\nDESCRIPTION: Implementation of the Model trait for UserModel showing basic type conversion between Rust and Python using unwrap(), which provides poor error handling when type conversion fails.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nimpl Model for UserModel {\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Rust calling Python to get the results\");\n        Python::with_gil(|py| {\n            self.model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap()\n                .extract()\n                .unwrap()\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring pyproject.toml for PyO3\nDESCRIPTION: Example pyproject.toml configuration for a PyO3 project, specifying Maturin as the build backend and defining Python package metadata.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_9\n\nLANGUAGE: toml\nCODE:\n```\n[build-system]\nrequires = [\"maturin>=1,<2\"]\nbuild-backend = \"maturin\"\n\n[project]\nname = \"pyo3_example\"\nrequires-python = \">=3.7\"\nclassifiers = [\n    \"Programming Language :: Rust\",\n    \"Programming Language :: Python :: Implementation :: CPython\",\n    \"Programming Language :: Python :: Implementation :: PyPy\",\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing Ordering for PyO3 Enums\nDESCRIPTION: Shows how to add ordering comparison operators to PyO3 enums using the #[pyo3(ord)] attribute. Requires implementing PartialOrd trait in Rust, and enables Python comparison operators like <, <=, >, and >=.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, ord)]\n#[derive(PartialEq, PartialOrd)]\nenum MyEnum{\n    A,\n    B,\n    C,\n}\n\nPython::with_gil(|py| {\n    let cls = py.get_type::<MyEnum>();\n    let a = Py::new(py, MyEnum::A).unwrap();\n    let b = Py::new(py, MyEnum::B).unwrap();\n    let c = Py::new(py, MyEnum::C).unwrap();\n    pyo3::py_run!(py, cls a b c, r#\"\n        assert (a < b) == True\n        assert (c <= b) == False\n        assert (c > a) == True\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe Single Initialization with OnceExt in PyO3\nDESCRIPTION: Example showing how to use PyO3's OnceExt trait for thread-safe single initialization of a runtime cache containing a Python dictionary.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse std::sync::Once;\nuse pyo3::sync::OnceExt;\nuse pyo3::types::PyDict;\n\nstruct RuntimeCache {\n    once: Once,\n    cache: Option<Py<PyDict>>\n}\n\nlet mut cache = RuntimeCache {\n    once: Once::new(),\n    cache: None\n};\n\nPython::with_gil(|py| {\n    // guaranteed to be called once and only once\n    cache.once.call_once_py_attached(py, || {\n        cache.cache = Some(PyDict::new(py).unbind());\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Python Threading Example with PyO3\nDESCRIPTION: Python code demonstrating how to trigger thread-safety issues by accessing a PyO3 class from multiple threads simultaneously using ThreadPoolExecutor.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport concurrent.futures\nfrom my_module import ThreadIter\n\ni = ThreadIter()\n\ndef increment():\n    next(i)\n\nwith concurrent.futures.ThreadPoolExecutor(max_workers=16) as tpe:\n    futures = [tpe.submit(increment) for _ in range(100)]\n    [f.result() for f in futures]\n```\n\n----------------------------------------\n\nTITLE: Migrating From PyRef::new to PyCell::new\nDESCRIPTION: Example showing how to update object creation code from using PyRef::new and PyRefMut::new to using PyCell::new with borrow() or borrow_mut() when needed.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_39\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct MyClass {}\n# Python::with_gil(|py| {\nlet obj_ref = PyRef::new(py, MyClass {}).unwrap();\n# })\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# #[pyclass]\n# struct MyClass {}\n# Python::with_gil(|py| {\nlet obj = PyCell::new(py, MyClass {}).unwrap();\nlet obj_ref = obj.borrow();\n# })\n```\n\n----------------------------------------\n\nTITLE: Configuring Function Signatures with Default Values in PyO3\nDESCRIPTION: Shows how to create a Python function with positional-only arguments and default values, including text signature configuration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/signature.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// This function adds two unsigned 64-bit integers.\n#[pyfunction]\n#[pyo3(signature = (a, b=0, /))]\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Item and Attribute Names\nDESCRIPTION: Shows how to customize the attribute or key names used for extraction with #[pyo3(item(\"key\"))] and #[pyo3(attribute(\"name\"))] annotations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    #[pyo3(item(\"key\"))]\n    string_in_mapping: String,\n    #[pyo3(attribute(\"name\"))]\n    string_attr: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type Conversions for Number in PyO3\nDESCRIPTION: Implements methods to support conversion of Number to int, float, and complex types in Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __int__(&self) -> i32 {\n        self.0\n    }\n\n    fn __float__(&self) -> f64 {\n        self.0 as f64\n    }\n\n    fn __complex__<'py>(&self, py: Python<'py>) -> Bound<'py, PyComplex> {\n        PyComplex::from_doubles(py, self.0 as f64, 0.0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating PyO3 pyclass Attribute Usage in Rust\nDESCRIPTION: This code snippet shows two equivalent ways of applying pyclass attributes to a Rust struct. The first method passes arguments directly to the #[pyclass] annotation, while the second uses separate #[pyo3] annotations for the same effect.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/pyclass-parameters.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// Argument supplied directly to the `#[pyclass]` annotation.\n#[pyclass(name = \"SomeName\", subclass)]\nstruct MyClass {}\n\n// Argument supplied as a separate annotation.\n#[pyclass]\n#[pyo3(name = \"SomeName\", subclass)]\nstruct MyClass {}\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Alternative Implementation Using PyObject Return Type\nDESCRIPTION: An alternative implementation that avoids explicit lifetime parameters by returning PyObject (Py<PyAny>), which has no lifetime. This requires using unbind() to convert from Bound to Py.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nfn add(left: &Bound<'_, PyAny>, right: &Bound<'_, PyAny>) -> PyResult<PyObject> {\n    let output: Bound<'_, PyAny> = left.add(right)?;\n    Ok(output.unbind())\n}\n# Python::with_gil(|py| {\n#     let s = pyo3::types::PyString::new(py, \"s\");\n#     assert!(add(&s, &s).unwrap().bind(py).eq(\"ss\").unwrap());\n# })\n```\n\n----------------------------------------\n\nTITLE: Defining Number Struct with Custom Constructor in PyO3\nDESCRIPTION: Creates the Number struct and implements its constructor using the custom 'wrap' function for argument extraction.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n/// Did you ever hear the tragedy of Darth Signed The Overfloweth? I thought not.\n/// It's not a story C would tell you. It's a Rust legend.\n#[pyclass(module = \"my_module\")]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(#[pyo3(from_py_with = wrap)] value: i32) -> Self {\n        Self(value)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Unary Arithmetic Operations for Number in PyO3\nDESCRIPTION: Implements unary arithmetic operations for the Number class, including positive, negative, absolute value, and bitwise not.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __pos__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {\n        slf\n    }\n\n    fn __neg__(&self) -> Self {\n        Self(-self.0)\n    }\n\n    fn __abs__(&self) -> Self {\n        Self(self.0.abs())\n    }\n\n    fn __invert__(&self) -> Self {\n        Self(!self.0)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Using Bound<'py, PyList> with Type Annotations\nDESCRIPTION: A Rust implementation of the Python list example using PyO3's `Bound<'py, PyList>`. This example shows creating a list, appending an item, creating a second reference with clone(), and dropping the original reference.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyList;\n\nfn example<'py>(py: Python<'py>) -> PyResult<()> {\n    let x: Bound<'py, PyList> = PyList::empty(py);\n    x.append(1)?;\n    let y: Bound<'py, PyList> = x.clone(); // y is a new reference to the same list\n    drop(x); // release the original reference x\n    Ok(())\n}\n# Python::with_gil(example).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Adding Extension Module Link Arguments in build.rs for macOS Support\nDESCRIPTION: A build script that adds the necessary linker arguments for PyO3 extension modules on macOS. This ensures proper linking when the extension-module feature disables linking to libpython.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::add_extension_module_link_args();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Methods with PyO3\nDESCRIPTION: Example of creating static methods for a Python class using the #[staticmethod] attribute, which don't require a self or cls parameter.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    #[staticmethod]\n    fn static_method(param1: i32, param2: &str) -> PyResult<i32> {\n        Ok(10)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Embedding Python in Rust with Additional Modules\nDESCRIPTION: Shows how to embed Python in Rust with additional modules using the append_to_inittab macro. This example adds a custom module 'foo' to the embedded Python interpreter.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::ffi::c_str;\n\n#[pyfunction]\nfn add_one(x: i64) -> i64 {\n    x + 1\n}\n\n#[pymodule]\nfn foo(foo_module: &Bound<'_, PyModule>) -> PyResult<()> {\n    foo_module.add_function(wrap_pyfunction!(add_one, foo_module)?)?;\n    Ok(())\n}\n\nfn main() -> PyResult<()> {\n    pyo3::append_to_inittab!(foo);\n    Python::with_gil(|py| Python::run(py, c_str!(\"import foo; foo.add_one(6)\"), None, None))\n}\n```\n\n----------------------------------------\n\nTITLE: Running Python Statements with py_run! Macro in Rust\nDESCRIPTION: Demonstrates the use of the py_run! macro to execute Python statements from Rust. This example defines a Rust struct exposed to Python and runs Python code to interact with it.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::py_run;\n\n# fn main() {\n#[pyclass]\nstruct UserData {\n    id: u32,\n    name: String,\n}\n\n#[pymethods]\nimpl UserData {\n    fn as_tuple(&self) -> (u32, String) {\n        (self.id, self.name.clone())\n    }\n\n    fn __repr__(&self) -> PyResult<String> {\n        Ok(format!(\"User {}(id: {})\", self.name, self.id))\n    }\n}\n\nPython::with_gil(|py| {\n    let userdata = UserData {\n        id: 34,\n        name: \"Yu\".to_string(),\n    };\n    let userdata = Py::new(py, userdata).unwrap();\n    let userdata_as_tuple = (34, \"Yu\");\n    py_run!(py, userdata userdata_as_tuple, r#\"\nassert repr(userdata) == \"User Yu(id: 34)\"\nassert userdata.as_tuple() == userdata_as_tuple\n    \"#);\n})\n# }\n```\n\n----------------------------------------\n\nTITLE: Optimized GIL Token Access Using Bound::py\nDESCRIPTION: Shows an efficient approach to accessing the GIL token by using Bound::py() when a GIL-bound reference is already available, avoiding the overhead of Python::with_gil.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/performance.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nimpl PartialEq<Foo> for FooBound<'_> {\n    fn eq(&self, other: &Foo) -> bool {\n        // Access to `&Bound<'py, PyAny>` implies access to `Python<'py>`.\n        let py = self.0.py();\n        let len = other.0.bind(py).len();\n        self.0.len() == len\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Manually Adding Python Modules to sys.modules in Rust\nDESCRIPTION: Demonstrates how to manually create and add a Python module to sys.modules when append_to_inittab cannot be used. This example creates a 'foo' module and adds it to sys.modules.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust/calling-existing-code.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyDict;\nuse pyo3::ffi::c_str;\n\n#[pyfunction]\npub fn add_one(x: i64) -> i64 {\n    x + 1\n}\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        // Create new module\n        let foo_module = PyModule::new(py, \"foo\")?;\n        foo_module.add_function(wrap_pyfunction!(add_one, &foo_module)?)?;\n\n        // Import and get sys.modules\n        let sys = PyModule::import(py, \"sys\")?;\n        let py_modules: Bound<'_, PyDict> = sys.getattr(\"modules\")?.downcast_into()?;\n\n        // Insert foo into sys.modules\n        py_modules.set_item(\"foo\", foo_module)?;\n\n        // Now we can import + run our python code\n        Python::run(py, c_str!(\"import foo; foo.add_one(6)\"), None, None)\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing String Representations in PyO3\nDESCRIPTION: Implements __repr__ and __str__ methods for the Number class to provide both formal and informal string representations. These methods allow the object to be printed in a user-friendly way.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    // For `__repr__` we want to return a string that Python code could use to recreate\n    // the `Number`, like `Number(5)` for example.\n    fn __repr__(&self) -> String {\n        // We use the `format!` macro to create a string. Its first argument is a\n        // format string, followed by any number of parameters which replace the\n        // `{}`'s in the format string.\n        //\n        //                       👇 Tuple field access in Rust uses a dot\n        format!(\"Number({})\", self.0)\n    }\n    // `__str__` is generally used to create an \"informal\" representation, so we\n    // just forward to `i32`'s `ToString` trait implementation to print a bare number.\n    fn __str__(&self) -> String {\n        self.0.to_string()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring PyO3 for Embedding Python in Rust\nDESCRIPTION: Cargo.toml dependency configuration for embedding Python in a Rust application. Includes the PyO3 dependency with the 'auto-initialize' feature which automatically handles Python interpreter initialization.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/README.md#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\nversion = \"0.24.0\"\nfeatures = [\"auto-initialize\"]\n```\n\n----------------------------------------\n\nTITLE: Python Model Class Implementation\nDESCRIPTION: Example Python class implementing the methods required by the Rust Model trait.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 - 3 for elt in self.inputs]\n    def get_results(self):\n        return self.results\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of IntoPyObject Trait in Rust\nDESCRIPTION: Example of manually implementing the IntoPyObject trait for a struct when the derive macro is not suitable. Demonstrates both an owned implementation and a reference implementation that optimizes reference counting using Borrowed.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyPyObjectWrapper(PyObject);\n\nimpl<'py> IntoPyObject<'py> for MyPyObjectWrapper {\n    type Target = PyAny; // the Python type\n    type Output = Bound<'py, Self::Target>; // in most cases this will be `Bound`\n    type Error = std::convert::Infallible; // the conversion error type, has to be convertable to `PyErr`\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.into_bound(py))\n    }\n}\n\n// equivalent to former `ToPyObject` implementations\nimpl<'a, 'py> IntoPyObject<'py> for &'a MyPyObjectWrapper {\n    type Target = PyAny;\n    type Output = Borrowed<'a, 'py, Self::Target>; // `Borrowed` can be used to optimized reference counting\n    type Error = std::convert::Infallible;\n\n    fn into_pyobject(self, py: Python<'py>) -> Result<Self::Output, Self::Error> {\n        Ok(self.0.bind_borrowed(py))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating PyO3 Smart Pointer Types in Rust\nDESCRIPTION: This code snippet shows the smart pointer types provided by PyO3 for working with Python objects in Rust. These types (Py<T>, Bound<'py, T>, and Borrowed<'a, 'py, T>) use Python reference counting to manage object lifetimes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-from-rust.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nPy<T>, Bound<'py, T>, and Borrowed<'a, 'py, T>\n```\n\n----------------------------------------\n\nTITLE: Python Interface Implementation\nDESCRIPTION: PyO3 wrapper methods to expose the Model trait implementation to Python with proper type conversions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl UserModel {\n    pub fn set_variables(&mut self, var: Vec<f64>) {\n        println!(\"Set variables from Python calling Rust\");\n        Model::set_variables(self, &var)\n    }\n\n    pub fn get_results(&mut self) -> Vec<f64> {\n        println!(\"Get results from Python calling Rust\");\n        Model::get_results(self)\n    }\n\n    pub fn compute(&mut self) {\n        println!(\"Compute from Python calling Rust\");\n        Model::compute(self)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Extract for Polymorphic Type Handling in PyO3\nDESCRIPTION: Demonstrates the initial approach of using extract() to handle different Python types in a polymorphic API, which creates overhead by converting PyDowncastError to PyErr unnecessarily.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/performance.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn frobnicate_list<'py>(list: &Bound<'_, PyList>) -> PyResult<Bound<'py, PyAny>> {\n    todo!()\n}\n\nfn frobnicate_vec<'py>(vec: Vec<Bound<'py, PyAny>>) -> PyResult<Bound<'py, PyAny>> {\n    todo!()\n}\n\n#[pyfunction]\nfn frobnicate<'py>(value: &Bound<'py, PyAny>) -> PyResult<Bound<'py, PyAny>> {\n    if let Ok(list) = value.extract::<Bound<'_, PyList>>() {\n        frobnicate_list(&list)\n    } else if let Ok(vec) = value.extract::<Vec<Bound<'_, PyAny>>>() {\n        frobnicate_vec(vec)\n    } else {\n        Err(PyTypeError::new_err(\"Cannot frobnicate that type.\"))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rich Comparison with Special Cases in PyO3\nDESCRIPTION: Demonstrates how to implement the __richcmp__ magic method in PyO3 to handle comparison operations. This example shows implementation of equality comparisons while returning NotImplemented for other operations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\nuse pyo3::types::PyNotImplemented;\n\n# use pyo3::prelude::*;\n# use pyo3::BoundObject;\n#\n# #[pyclass]\n# struct Number(i32);\n#\n#[pymethods]\nimpl Number {\n    fn __richcmp__<'py>(&self, other: &Self, op: CompareOp, py: Python<'py>) -> PyResult<Borrowed<'py, 'py, PyAny>> {\n        match op {\n            CompareOp::Eq => Ok((self.0 == other.0).into_pyobject(py)?.into_any()),\n            CompareOp::Ne => Ok((self.0 != other.0).into_pyobject(py)?.into_any()),\n            _ => Ok(PyNotImplemented::get(py).into_any()),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New PyO3 Projects with cargo-generate\nDESCRIPTION: Commands to install cargo-generate and use it to create a new project based on a PyO3 example. The user needs to replace '<example>' with the specific example they want to use as a template.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/<example>\n```\n\n----------------------------------------\n\nTITLE: Sending Rust Logs to Python using pyo3-log\nDESCRIPTION: Example of configuring Rust to send log messages to Python's logging system using pyo3-log. Shows implementation of a PyModule with logging initialization and a logging function.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/ecosystem/logging.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse log::info;\nuse pyo3::prelude::*;\n\n#[pyfunction]\nfn log_something() {\n    // This will use the logger installed in `my_module` to send the `info`\n    // message to the Python logging facilities.\n    info!(\"Something!\");\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // A good place to install the Rust -> Python logger.\n    pyo3_log::init();\n\n    m.add_function(wrap_pyfunction!(log_something, m)?)?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Object Extraction in PyO3\nDESCRIPTION: Example of migrating code that extracts &T and &mut T to use PyRef<T> and PyRefMut<T> instead. Shows how to handle object extraction after PyCell introduction in PyO3 0.9.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_40\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: &PyAny = create_obj();\nlet obj_ref: &MyClass = obj.extract().unwrap();\nlet obj_ref_mut: &mut MyClass = obj.extract().unwrap();\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::types::IntoPyDict;\n# #[pyclass] #[derive(Clone)] struct MyClass {}\n# #[pymethods] impl MyClass { #[new]fn new() -> Self { MyClass {} }}\n# Python::with_gil(|py| {\n# let typeobj = py.get_type::<MyClass>();\n# let d = [(\"c\", typeobj)].into_py_dict(py);\n# let create_obj = || py.eval(\"c()\", None, Some(d)).unwrap();\nlet obj: &PyAny = create_obj();\nlet obj_cell: &PyCell<MyClass> = obj.extract().unwrap();\nlet obj_cloned: MyClass = obj.extract().unwrap(); // extracted by cloning the object\n{\n    let obj_ref: PyRef<'_, MyClass> = obj.extract().unwrap();\n    // we need to drop obj_ref before we can extract a PyRefMut due to Rust's rules of references\n}\nlet obj_ref_mut: PyRefMut<'_, MyClass> = obj.extract().unwrap();\n# })\n```\n\n----------------------------------------\n\nTITLE: Demonstrating IntoPyObject Derive for an Enum in Rust\nDESCRIPTION: Example of using the IntoPyObject derive macro with an enum containing different variants like transparent tuples, transparent structs, tuples, and structures. Shows how enums are supported and converted using the same rules as structs.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(IntoPyObject)]\nenum Enum<'a, 'py, K: Hash + Eq, V> { // enums are supported and convert using the same\n    TransparentTuple(PyObject),       // rules on the variants as the structs above\n    #[pyo3(transparent)]\n    TransparentStruct { inner: Bound<'py, PyAny> },\n    Tuple(&'a str, HashMap<K, V>),\n    Struct { count: usize, obj: Py<PyAny> }\n}\n```\n\n----------------------------------------\n\nTITLE: Allowing Multi-threading with PyO3's allow_threads\nDESCRIPTION: This function wraps the sequential search with Python::allow_threads to release the GIL during execution, enabling true parallelism when called from multiple Python threads.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/parallelism.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\n# use pyo3::prelude::*;\n#\n# fn count_line(line: &str, needle: &str) -> usize {\n#     let mut total = 0;\n#     for word in line.split(' ') {\n#         if word == needle {\n#             total += 1;\n#         }\n#     }\n#     total\n# }\n#\n# fn search_sequential(contents: &str, needle: &str) -> usize {\n#    contents.lines().map(|line| count_line(line, needle)).sum()\n# }\n#[pyfunction]\nfn search_sequential_allow_threads(py: Python<'_>, contents: &str, needle: &str) -> usize {\n    py.allow_threads(|| search_sequential(contents, needle))\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 GIL Management Pattern 1\nDESCRIPTION: Shows how to manage the Python GIL by releasing it before reacquiring, using Python::with_gil for object creation and cleanup.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_21\n\nLANGUAGE: rust\nCODE:\n```\nlet first = Python::with_gil(|py| Object::new(py));\nlet second = Python::with_gil(|py| Object::new(py));\ndrop(first);\ndrop(second);\n```\n\n----------------------------------------\n\nTITLE: Converting Between Py<T> and Borrowed<'a, 'py, T> Smart Pointers in Rust\nDESCRIPTION: This code illustrates converting between Py<T> and Borrowed<'a, 'py, T> using bind_borrowed() and shows two ways to convert back to Py<T>: either using as_unbound() or by creating a new Bound with to_owned() and then unbinding it.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyAny> = ...;\nlet borrowed: Borrowed<'_, 'py, PyAny> = bound.as_borrowed();\n\n// via deref coercion to Bound and then using Bound::as_unbound\nlet obj: &Py<PyAny> = borrowed.as_unbound();\n\n// via a new Bound by increasing the Python reference count, and unbind it\nlet obj: Py<PyAny> = borrowed.to_owned().unbind().\n```\n\n----------------------------------------\n\nTITLE: Declaring a Free-Threaded Python Module in Rust\nDESCRIPTION: This snippet demonstrates how to declare a Python module that supports free-threaded Python using the PyO3 library. The 'gil_used = false' parameter indicates that the module is thread-safe and does not require the Global Interpreter Lock.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n/// This module supports free-threaded Python\n#[pymodule(gil_used = false)]\nfn my_extension(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // add members to the module that you know are thread-safe\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: PyO3 Build Script Configuration\nDESCRIPTION: Example build.rs script to enable PyO3 cfg flags\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    // If you have an existing build.rs file, just add this line to it.\n    pyo3_build_config::use_pyo3_cfgs();\n}\n```\n\n----------------------------------------\n\nTITLE: Manual Implementation of __hash__ in PyO3\nDESCRIPTION: Implements the __hash__ method for a PyO3 class by using Rust's DefaultHasher. This allows instances to be used as dictionary keys or in sets.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse std::collections::hash_map::DefaultHasher;\n\n// Required to call the `.hash` and `.finish` methods, which are defined on traits.\nuse std::hash::{Hash, Hasher};\n\n#[pymethods]\nimpl Number {\n    fn __hash__(&self) -> u64 {\n        let mut hasher = DefaultHasher::new();\n        self.0.hash(&mut hasher);\n        hasher.finish()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Overriding Python Function Name in PyO3\nDESCRIPTION: Shows how to use the #[pyo3(name = \"...\")] attribute to override the name of a Python function exposed from Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyfunction]\n#[pyo3(name = \"no_args\")]\nfn no_args_py() -> usize {\n    42\n}\n\n#[pymodule]\nfn module_with_functions(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_function(wrap_pyfunction!(no_args_py, m)?)\n}\n```\n\n----------------------------------------\n\nTITLE: Alternative ParseInt Implementation with PyResult\nDESCRIPTION: Shows an alternative implementation of parse_int that directly returns PyResult, using the try operator for error conversion.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/function/error-handling.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\nfn parse_int(s: String) -> PyResult<usize> {\n    let x = s.parse()?;\n    Ok(x)\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Call Counter Decorator in Python\nDESCRIPTION: This Python code demonstrates how to use the Counter decorator implemented in Rust. It applies the decorator to a function and calls it multiple times to show the counting behavior.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/call.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom decorator import Counter\n\n@Counter\ndef say_hello():\n    print(\"hello\")\n\nsay_hello()\nsay_hello()\nsay_hello()\nsay_hello()\n```\n\n----------------------------------------\n\nTITLE: Using PyCell for Reference Management\nDESCRIPTION: Example demonstrating the introduction of PyCell in PyO3 0.9 for handling Rust's reference rules. The example shows how a method requiring multiple mutable borrows will properly raise exceptions when used incorrectly in Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_38\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n\n#[pyclass]\nstruct Names {\n    names: Vec<String>,\n}\n\n#[pymethods]\nimpl Names {\n    #[new]\n    fn new() -> Self {\n        Names { names: vec![] }\n    }\n    fn merge(&mut self, other: &mut Names) {\n        self.names.append(&mut other.names)\n    }\n}\n# Python::with_gil(|py| {\n#     let names = Py::new(py, Names::new()).unwrap();\n#     pyo3::py_run!(py, names, r\"\n#     try:\n#        names.merge(names)\n#        assert False, 'Unreachable'\n#     except RuntimeError as e:\n#        assert str(e) == 'Already borrowed'\n#     \");\n# })\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic PyO3 Class Structure\nDESCRIPTION: Demonstrates creation of a basic Python class using PyO3 with a wrapper struct for managing a Python object reference.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_20\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct SomeClass {}\n\nstruct Object {\n    object: Py<SomeClass>,\n}\n\nimpl Object {\n    fn new(py: Python<'_>) -> Self {\n        let object = Py::new(py, SomeClass {}).unwrap();\n\n        Self { object }\n    }\n```\n\n----------------------------------------\n\nTITLE: Avoiding dangling pointers with Option<Bound<PyAny>> in Rust\nDESCRIPTION: Demonstrates the correct way to handle Option<Bound<PyAny>> to avoid creating dangling pointers when using as_ptr().\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nlet opt: Option<Bound<PyAny>> = ...;\nlet p: *mut ffi::PyObject = opt.as_ref().map_or(std::ptr::null_mut(), Bound::as_ptr);\n```\n\n----------------------------------------\n\nTITLE: Automatic __hash__ Implementation with Hash Trait\nDESCRIPTION: Shows how to automatically implement __hash__ by using the hash attribute with PyO3 and the Hash trait. This approach requires the class to be frozen to prevent hash values from changing.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(frozen, eq, hash)]\n#[derive(PartialEq, Hash)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: Automatic __str__ Generation with Display Trait\nDESCRIPTION: Shows how to automatically generate the __str__ implementation by implementing the Display trait and using the str attribute on pyclass. This is a convenient way to avoid writing the __str__ method manually.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(str)]\nstruct Coordinate {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n\nimpl Display for Coordinate {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        write!(f, \"({}, {}, {})\", self.x, self.y, self.z)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Improved Rust-Python Type Checking for Better Error Messages\nDESCRIPTION: Enhanced implementation of get_results() method with explicit type checking to provide meaningful error messages when Python returns the wrong type, improving the developer experience for Python users.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nimpl Model for UserModel {\n    fn get_results(&self) -> Vec<f64> {\n        println!(\"Get results from Rust calling Python\");\n        Python::with_gil(|py| {\n            let py_result: Bound<'_, PyAny> = self\n                .model\n                .bind(py)\n                .call_method(\"get_results\", (), None)\n                .unwrap();\n\n            if py_result.get_type().name().unwrap() != \"list\" {\n                panic!(\n                    \"Expected a list for the get_results() method signature, got {}\",\n                    py_result.get_type().name().unwrap()\n                );\n            }\n            py_result.extract()\n        })\n        .unwrap()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating PyO3 Constructor Syntax\nDESCRIPTION: Example of migrating from the old constructor syntax using PyRawObject to the new syntax that allows returning Self or Result<Self> directly. This change was introduced in PyO3 0.9.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_37\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[new]\n    fn new(obj: &PyRawObject) {\n        obj.init(MyClass {})\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n#[pyclass]\nstruct MyClass {}\n\n#[pymethods]\nimpl MyClass {\n    #[new]\n    fn new() -> Self {\n        MyClass {}\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Struct with FromPyObject Attribute Configuration\nDESCRIPTION: Example of a Rust struct using FromPyObject with custom item mapping and default value handling through attribute configuration.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    #[pyo3(item(\"value\"), default, from_py_with = Bound::<'_, PyAny>::len)]\n    len: usize,\n    #[pyo3(item)]\n    other: usize,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic PyO3 Class in Rust\nDESCRIPTION: Creates a simple Number class with a constructor that can be used from Python. This serves as the foundation for further customization examples.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct Number(i32);\n\n#[pymethods]\nimpl Number {\n    #[new]\n    fn new(value: i32) -> Self {\n        Self(value)\n    }\n}\n\n#[pymodule]\nfn my_module(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<Number>()?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Equality with __eq__\nDESCRIPTION: Shows how to implement just the equality comparison by defining the __eq__ method. This method is automatically used for both equality (==) and inequality (!=) operations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __eq__(&self, other: &Self) -> bool {\n        self.0 == other.0\n    }\n}\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| {\n        let x = &Bound::new(py, Number(4))?;\n        let y = &Bound::new(py, Number(4))?;\n        assert!(x.eq(y)?);\n        assert!(!x.ne(y)?); \n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Function with Explicit Lifetime Parameters\nDESCRIPTION: The correct way to implement the function that adds two Python objects by explicitly naming the 'py lifetime, which allows the compiler to connect the input and output lifetimes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nfn add<'py>(\n    left: &Bound<'py, PyAny>,\n    right: &Bound<'py, PyAny>,\n) -> PyResult<Bound<'py, PyAny>> {\n    left.add(right)\n}\n# Python::with_gil(|py| {\n#     let s = pyo3::types::PyString::new(py, \"s\");\n#     assert!(add(&s, &s).unwrap().eq(\"ss\").unwrap());\n# })\n```\n\n----------------------------------------\n\nTITLE: Implementing a Python Layer for Rust Tracing\nDESCRIPTION: A Python implementation of the Layer interface for use with pyo3-python-tracing-subscriber. This class demonstrates the required methods to capture span events from Rust and how to use the extension's tracing initialization.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/ecosystem/tracing.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport rust_extension\n\nclass MyPythonLayer:\n    def __init__(self):\n        pass\n\n    # `on_new_span` can return some state\n    def on_new_span(self, span_attrs: str, span_id: str) -> int:\n        print(f\"[on_new_span]: {span_attrs} | {span_id}\")\n        return random.randint(1, 1000)\n\n    # The state from `on_new_span` is passed back into other trait methods\n    def on_event(self, event: str, state: int):\n        print(f\"[on_event]: {event} | {state}\")\n\n    def on_close(self, span_id: str, state: int):\n        print(f\"[on_close]: {span_id} | {state}\")\n\n    def on_record(self, span_id: str, values: str, state: int):\n        print(f\"[on_record]: {span_id} | {values} | {state}\")\n\ndef main():\n    rust_extension.initialize_tracing(MyPythonLayer())\n\n    print(\"10th fibonacci number: \", rust_extension.fibonacci(10, True))\n```\n\n----------------------------------------\n\nTITLE: Converting Rust Values to Python Objects with IntoPy\nDESCRIPTION: Demonstrates how to convert Rust values to Python objects using the IntoPy trait after the removal of the FromPy trait. Shows converting a floating-point number to a PyObject.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_31\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: PyObject = 1.234.into_py(py);\n```\n\n----------------------------------------\n\nTITLE: Configuring Crate Types for PyO3 Extension Modules\nDESCRIPTION: Demonstrates how to configure crate types in Cargo.toml to include both 'cdylib' and 'rlib'. This allows the crate to be used for both extension modules and integration tests.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml\n[lib]\ncrate-type = [\"cdylib\", \"rlib\"]\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Iterator in Rust using Option\nDESCRIPTION: Demonstrates the recommended way to implement a Python iterator in Rust using Option, which is more idiomatic and efficient.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> Option<usize> {\n        if self.count < 5 {\n            self.count += 1;\n            Some(self.count)\n        } else {\n            None\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Single-Field Tuple Struct with Explicit Tuple Extraction\nDESCRIPTION: Demonstrates how to ensure a single-field tuple struct extracts from a Python tuple rather than using the transparent behavior.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyTuple((String,));\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Model Class with Incorrect Return Type\nDESCRIPTION: A Python Model class implementation with an incorrect return type in the get_results method, which should return a list but instead returns a single element, causing a Rust panic when PyO3 tries to convert it.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 -3 for elt in self.inputs]\n    def get_results(self):\n        return self.results[0]\n        #return self.results <-- this is the expected output\n```\n\n----------------------------------------\n\nTITLE: Implementing Truthiness with __bool__\nDESCRIPTION: Implements the __bool__ method to determine the truth value of a PyO3 class instance. This allows the object to be used in boolean contexts like if statements.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl Number {\n    fn __bool__(&self) -> bool {\n        self.0 != 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving FromPyObject for Tuple Structs\nDESCRIPTION: Shows how to derive FromPyObject for tuple structs, which extracts from Python tuples where each field position corresponds to the tuple element position.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyTuple(String, String);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Python Native Module in Rust\nDESCRIPTION: This Rust code implements a Python native module named 'string_sum' using pyo3-ffi. It defines module structure, methods, and implements a function to sum two integers and return the result as a string.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse std::os::raw::{c_char, c_long};\nuse std::ptr;\n\nuse pyo3_ffi::*;\n\nstatic mut MODULE_DEF: PyModuleDef = PyModuleDef {\n    m_base: PyModuleDef_HEAD_INIT,\n    m_name: c_str!(\"string_sum\").as_ptr(),\n    m_doc: c_str!(\"A Python module written in Rust.\").as_ptr(),\n    m_size: 0,\n    m_methods: unsafe { METHODS as *const [PyMethodDef] as *mut PyMethodDef },\n    m_slots: std::ptr::null_mut(),\n    m_traverse: None,\n    m_clear: None,\n    m_free: None,\n};\n\nstatic mut METHODS: &[PyMethodDef] = &[\n    PyMethodDef {\n        ml_name: c_str!(\"sum_as_string\").as_ptr(),\n        ml_meth: PyMethodDefPointer {\n            PyCFunctionFast: sum_as_string,\n        },\n        ml_flags: METH_FASTCALL,\n        ml_doc: c_str!(\"returns the sum of two integers as a string\").as_ptr(),\n    },\n    PyMethodDef::zeroed(),\n];\n\n#[allow(non_snake_case)]\n#[no_mangle]\npub unsafe extern \"C\" fn PyInit_string_sum() -> *mut PyObject {\n    let module = PyModule_Create(ptr::addr_of_mut!(MODULE_DEF));\n    if module.is_null() {\n        return module;\n    }\n    #[cfg(Py_GIL_DISABLED)]\n    {\n        if PyUnstable_Module_SetGIL(module, Py_MOD_GIL_NOT_USED) < 0 {\n            Py_DECREF(module);\n            return std::ptr::null_mut();\n        }\n    }\n    module\n}\n\nunsafe fn parse_arg_as_i32(obj: *mut PyObject, n_arg: usize) -> Option<i32> {\n    if PyLong_Check(obj) == 0 {\n        let msg = format!(\n            \"sum_as_string expected an int for positional argument {}\\0\",\n            n_arg\n        );\n        PyErr_SetString(PyExc_TypeError, msg.as_ptr().cast::<c_char>());\n        return None;\n    }\n\n    let mut overflow = 0;\n    let i_long: c_long = PyLong_AsLongAndOverflow(obj, &mut overflow);\n\n    #[allow(irrefutable_let_patterns)]\n    if overflow != 0 {\n        raise_overflowerror(obj);\n        None\n    } else if let Ok(i) = i_long.try_into() {\n        Some(i)\n    } else {\n        raise_overflowerror(obj);\n        None\n    }\n}\n\nunsafe fn raise_overflowerror(obj: *mut PyObject) {\n    let obj_repr = PyObject_Str(obj);\n    if !obj_repr.is_null() {\n        let mut size = 0;\n        let p = PyUnicode_AsUTF8AndSize(obj_repr, &mut size);\n        if !p.is_null() {\n            let s = std::str::from_utf8_unchecked(std::slice::from_raw_parts(\n                p.cast::<u8>(),\n                size as usize,\n            ));\n            let msg = format!(\"cannot fit {} in 32 bits\\0\", s);\n\n            PyErr_SetString(PyExc_OverflowError, msg.as_ptr().cast::<c_char>());\n        }\n        Py_DECREF(obj_repr);\n    }\n}\n\npub unsafe extern \"C\" fn sum_as_string(\n    _self: *mut PyObject,\n    args: *mut *mut PyObject,\n    nargs: Py_ssize_t,\n) -> *mut PyObject {\n    if nargs != 2 {\n        PyErr_SetString(\n            PyExc_TypeError,\n            c_str!(\"sum_as_string expected 2 positional arguments\").as_ptr(),\n        );\n        return std::ptr::null_mut();\n    }\n\n    let (first, second) = (*args, *args.add(1));\n\n    let first = match parse_arg_as_i32(first, 1) {\n        Some(x) => x,\n        None => return std::ptr::null_mut(),\n    };\n    let second = match parse_arg_as_i32(second, 2) {\n        Some(x) => x,\n        None => return std::ptr::null_mut(),\n    };\n\n    match first.checked_add(second) {\n        Some(sum) => {\n            let string = sum.to_string();\n            PyUnicode_FromStringAndSize(string.as_ptr().cast::<c_char>(), string.len() as isize)\n        }\n        None => {\n            PyErr_SetString(\n                PyExc_OverflowError,\n                c_str!(\"arguments too large to add\").as_ptr(),\n            );\n            std::ptr::null_mut()\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Cross-Compilation Environment for Linux Target\nDESCRIPTION: Demonstrates how to set environment variables for cross-compiling a PyO3 module to an ARM Linux target, specifying the location of the target's Python libraries.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target armv7-unknown-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Fixing PyString::from_object in Rust to prevent out of bounds reads\nDESCRIPTION: This code snippet fixes a security issue in PyString::from_object by properly null-terminating the encoding and errors strings. The fix ensures proper handling of these parameters before passing them to Python's API functions, preventing potential out of bounds memory reads.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/5008.fixed.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn from_object(ob: &PyAny, encoding: Option<&str>, errors: Option<&str>) -> PyResult<&'a PyString> {\n    unsafe {\n        // NOTE: These are using raw strings, do not want to increment the ref count.\n        // Don't use opt.unwrap_or_else(|| std::ptr::null()) as that may cause out of bounds read.\n        let encoding_cstring = encoding.map(|s| CString::new(s).unwrap());\n        let errors_cstring = errors.map(|s| CString::new(s).unwrap());\n        let encoding_ptr = encoding_cstring\n            .as_ref()\n            .map_or(std::ptr::null(), |s| s.as_ptr());\n        let errors_ptr = errors_cstring\n            .as_ref()\n            .map_or(std::ptr::null(), |s| s.as_ptr());\n        ob.py()\n            .from_owned_ptr_or_err(ffi::PyUnicode_AsEncodedString(\n                ob.as_ptr(),\n                encoding_ptr,\n                errors_ptr,\n            ))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Borrowed<T> to Py<T> in PyO3\nDESCRIPTION: Demonstration of type conversion traits between Borrowed<T> and Py<T> types in PyO3, used for managing Python object references in Rust code. This implements From/Into traits to allow seamless conversion between these wrapper types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/5054.added.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimpl<T> From<Borrowed<T>> for Py<T>\n```\n\n----------------------------------------\n\nTITLE: Initializing PyO3 Module in Python Package\nDESCRIPTION: Content of __init__.py file for a PyO3-based Python package, importing all symbols from the native module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-typing-hints.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom .my_project import *\n```\n\n----------------------------------------\n\nTITLE: Registering a Free-Threaded Child Module in Rust\nDESCRIPTION: This code snippet shows how to create and register a child module that supports free-threaded Python without using the pymodule macro. It explicitly sets the module as not using the GIL with the gil_used method.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n# #[allow(dead_code)]\nfn register_child_module(parent_module: &Bound<'_, PyModule>) -> PyResult<()> {\n    let child_module = PyModule::new(parent_module.py(), \"child_module\")?\n    child_module.gil_used(false)?;\n    parent_module.add_submodule(&child_module)\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Ordering Implementation with PartialOrd Trait\nDESCRIPTION: Shows how to automatically implement ordering methods (__lt__, __le__, __gt__, __ge__) by using the ord attribute and implementing the PartialOrd trait. The eq attribute is also required.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(eq, ord)]\n#[derive(PartialEq, PartialOrd)]\nstruct Number(i32);\n```\n\n----------------------------------------\n\nTITLE: PyO3 Function Signature Generation\nDESCRIPTION: Demonstrates automatic text signature generation for Python functions with both simple and default arguments.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_24\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction(text_signature = \"(a, b, c)\")]\nfn simple_function(a: i32, b: i32, c: i32) {}\n\n#[pyfunction(signature = (a, b = 1, c = 2), text_signature = \"(a, b=1, c=2)\")]\nfn function_with_defaults(a: i32, b: i32, c: i32) {}\n```\n\n----------------------------------------\n\nTITLE: Building the Plugin API with PyO3 Extension Module\nDESCRIPTION: Command to build the Python extension module with proper PyO3 features enabled. The extension-module feature is required for PyO3 to work correctly as a Python extension.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/plugin/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ncd plugin_api\nmaturin build --features \"extension-module\"\n```\n\n----------------------------------------\n\nTITLE: Using CompareOp.matches for __richcmp__ Implementation\nDESCRIPTION: Demonstrates a shortcut for implementing __richcmp__ by using the matches method on CompareOp. This approach is more concise when comparing Rust values that implement Ord.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::class::basic::CompareOp;\n\n#[pymethods]\nimpl Number {\n    fn __richcmp__(&self, other: &Self, op: CompareOp) -> bool {\n        op.matches(self.0.cmp(&other.0))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pure Python Implementation of Call Counter Decorator\nDESCRIPTION: This code snippet shows how to implement the same Call Counter decorator functionality in pure Python, demonstrating both a class-based and a higher-order function approach.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/call.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Counter:\n    def __init__(self, wraps):\n        self.count = 0\n        self.wraps = wraps\n\n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"{self.wraps.__name__} has been called {self.count} time(s)\")\n        self.wraps(*args, **kwargs)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef Counter(wraps):\n    count = 0\n    def call(*args, **kwargs):\n        nonlocal count\n        count += 1\n        print(f\"{wraps.__name__} has been called {count} time(s)\")\n        return wraps(*args, **kwargs)\n    return call\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling with Specific Python Version Targeting\nDESCRIPTION: Shows how to set environment variables to specify a particular Python version when cross-compiling a PyO3 module with multiple Python versions available in the target directory.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nexport PYO3_CROSS_PYTHON_VERSION=3.8\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target armv7-unknown-linux-gnueabihf\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPyObject and IntoPyObjectRef\nDESCRIPTION: Example showing how to use the new derive macros for implementing IntoPyObject and IntoPyObjectRef traits on a struct.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(IntoPyObject, IntoPyObjectRef)]\nstruct Struct {\n    count: usize,\n    obj: Py<PyAny>\n}\n```\n\n----------------------------------------\n\nTITLE: Passing Python Token to Object Methods in PyO3 0.10\nDESCRIPTION: Shows the updated pattern for calling methods on Python objects that now require an explicit Python token argument to ensure the GIL is held.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_35\n\nLANGUAGE: rust\nCODE:\n```\npy.None().get_refcnt(py);\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for macOS System Python Framework Path\nDESCRIPTION: Cargo configuration that manually specifies the rpath to the Python framework on macOS, providing an alternative to using pyo3-build-config for system Python support.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\n  \"-C\", \"link-args=-Wl,-rpath,/Library/Developer/CommandLineTools/Library/Frameworks\",\n]\n```\n\n----------------------------------------\n\nTITLE: Using Py::as_ref Instead of AsPyRef in PyO3 0.11\nDESCRIPTION: Shows how to use Py::as_ref method instead of the removed AsPyRef trait. Demonstrates converting a Py<PyList> to a reference to PyList.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_32\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::{Py, types::PyList};\n# pyo3::Python::with_gil(|py| {\nlet list_py: Py<PyList> = PyList::empty(py).into();\nlet list_ref: &PyList = list_py.as_ref(py);\n# })\n```\n\n----------------------------------------\n\nTITLE: Creating Unsendable PyClasses in PyO3 0.11.1\nDESCRIPTION: Demonstrates how to mark a PyClass as unsendable when it cannot implement Send, such as when it contains raw pointers. Uses the unsendable flag to ensure thread safety.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_34\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\n\n#[pyclass(unsendable)]\nstruct Unsendable {\n    pointers: Vec<*mut std::os::raw::c_char>,\n}\n```\n\n----------------------------------------\n\nTITLE: Working with Error Types in PyO3 0.12\nDESCRIPTION: Demonstrates how to create and work with the new Python exception objects in PyO3 0.12. Shows creating a PyErr, displaying it as a string, and interacting with the exception instance.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_29\n\nLANGUAGE: rust\nCODE:\n```\nlet err: PyErr = PyTypeError::new_err(\"error message\");\n\n// Uses Display for PyErr, new for PyO3 0.12\nassert_eq!(err.to_string(), \"TypeError: error message\");\n\n// Now possible to interact with exception instances, new for PyO3 0.12\nlet instance: &PyBaseException = err.instance(py);\nassert_eq!(\n    instance.getattr(\"__class__\")?,\n    PyTypeError::type_object(py).as_ref()\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Optional Extension Module Feature in Cargo.toml\nDESCRIPTION: Shows how to make the 'extension-module' feature optional in Cargo.toml. This allows building with maturin while avoiding linking errors during cargo test.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\n{{#PYO3_CRATE_VERSION}}\n\n[features]\nextension-module = [\"pyo3/extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Migrating from PyTryFrom to PyTypeCheck in Rust with PyO3\nDESCRIPTION: Demonstrates how to update code that previously used PyTryFrom::try_from to instead use obj.downcast() with PyTypeCheck. This change is part of the deprecation of the GIL Refs API.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nPython::with_gil(|py| {\n    let list = PyList::new(py, 0..5);\n    let b = <PyInt as PyTryFrom>::try_from(list.get_item(0).unwrap())?;\n    Ok(())\n})\n```\n\nLANGUAGE: rust\nCODE:\n```\nPython::with_gil(|py| {\n    // Note that PyList::new is deprecated for PyList::new_bound as part of the GIL Refs API removal,\n    // see the section below on migration to Bound<T>.\n    #[allow(deprecated)]\n    let list = PyList::new(py, 0..5);\n    let b = list.get_item(0).unwrap().downcast::<PyInt>()?;\n    Ok(())\n})\n```\n\n----------------------------------------\n\nTITLE: Python Test Cases for Number Type\nDESCRIPTION: Python test script demonstrating expected behavior of Number type including value comparison, signature validation, and string representation.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nassert Number(12345234523452) == Number(1498514748)\ntry:\n    import inspect\n    assert inspect.signature(Number).__str__() == '(value)'\nexcept ValueError:\n    # Not supported with `abi3` before Python 3.10\n    pass\nassert Number(1337).__str__() == '1337'\nassert Number(1337).__repr__() == 'Number(1337)'\n```\n\n----------------------------------------\n\nTITLE: Building and Using a PyO3 Module\nDESCRIPTION: Commands to build a PyO3 module with Maturin and demonstrate its usage in a Python REPL session.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n$ maturin develop\n# lots of progress output as maturin runs the compilation...\n$ python\n>>> import pyo3_example\n>>> pyo3_example.sum_as_string(5, 20)\n'25'\n```\n\n----------------------------------------\n\nTITLE: Python Container Example with Magic Methods\nDESCRIPTION: Example Python class demonstrating container protocol implementation with __len__ and __getitem__ magic methods. Shows how Python handles sequence and mapping protocols with the same methods.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nclass ExampleContainer:\n\n    def __len__(self):\n        return 5\n\n    def __getitem__(self, idx: int) -> int:\n        if idx < 0 or idx > 5:\n            raise IndexError()\n        return idx\n```\n\n----------------------------------------\n\nTITLE: Setting Up ThreadSanitizer for PyO3\nDESCRIPTION: Commands for installing nightly Rust toolchain and compiling PyO3 projects with ThreadSanitizer support for detecting thread safety issues.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nrustup install nightly\nrustup override set nighty\nrustup component add rust-src\n```\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=\"-Zsanitizer=thread\" maturin develop -Zbuild-std --target x86_64-unknown-linux-gnu\n```\n\n----------------------------------------\n\nTITLE: Setting Default Extension Module Feature in Cargo.toml\nDESCRIPTION: Demonstrates how to make the 'extension-module' feature optional and default in Cargo.toml. This configuration allows running tests with 'cargo test --no-default-features'.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\n{{#PYO3_CRATE_VERSION}}\n\n[features]\nextension-module = [\"pyo3/extension-module\"]\ndefault = [\"extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Manual IntoPyObject Implementation - Before\nDESCRIPTION: Legacy implementation example using the old IntoPy and ToPyObject traits.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyPyObjectWrapper(PyObject);\n\nimpl IntoPy<PyObject> for MyPyObjectWrapper {\n    fn into_py(self, py: Python<'_>) -> PyObject {\n        self.0\n    }\n}\n\nimpl ToPyObject for MyPyObjectWrapper {\n    fn to_object(&self, py: Python<'_>) -> PyObject {\n        self.0.clone_ref(py)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting between &PyAny and &Bound<PyAny> in Rust\nDESCRIPTION: Demonstrates how to convert between &PyAny (GIL Ref) and &Bound<PyAny> using the as_borrowed() method.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_11\n\nLANGUAGE: rust\nCODE:\n```\nlet gil_ref: &PyAny = ...;\nlet bound: &Bound<PyAny> = &gil_ref.as_borrowed();\n```\n\n----------------------------------------\n\nTITLE: Adding Python Framework Link Arguments for macOS System Python\nDESCRIPTION: A build script that adds the necessary linker arguments when using macOS system Python. This resolves runtime errors related to Python framework loading.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::add_python_framework_link_args();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Iterator in Rust using StopIteration\nDESCRIPTION: Shows how to implement a Python iterator in Rust by raising a StopIteration exception, mimicking Python's behavior.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyStopIteration;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> PyResult<usize> {\n        if self.count < 5 {\n            self.count += 1;\n            Ok(self.count)\n        } else {\n            Err(PyStopIteration::new_err(\"done\"))\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Advanced VS Code Debug Configuration with Environment Variables\nDESCRIPTION: Extended launch configuration for VS Code that includes environment variables and Rust debug flags.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"Debug PyO3 with Environment\",\n    \"type\": \"lldb\",\n    \"request\": \"launch\",\n    \"program\": \"${workspaceFolder}/.venv/bin/python\",\n    \"args\": [\"${file}\"],\n    \"env\": {\n        \"RUST_BACKTRACE\": \"1\",\n        \"PYTHONPATH\": \"${workspaceFolder}\"\n    },\n    \"sourceLanguages\": [\"rust\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for PyO3 Project\nDESCRIPTION: Command to install Maturin, a build tool for Python extensions written in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/sequential/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy for Custom Types in PyO3 0.12\nDESCRIPTION: Shows how to implement the IntoPy trait for custom types after the removal of FromPy. The implementation converts the custom type to a PyObject when needed by Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\nstruct MyPyObjectWrapper(PyObject);\n\n# #[allow(deprecated)]\nimpl IntoPy<PyObject> for MyPyObjectWrapper {\n    fn into_py(self, _py: Python<'_>) -> PyObject {\n        self.0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Python Example: Creating and Manipulating a List\nDESCRIPTION: A simple Python code example that demonstrates creating a list, appending an item, creating a second reference, and deleting the original reference.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef example():\n    x = list()   # create a Python list\n    x.append(1)  # append the integer 1 to it\n    y = x        # create a second reference to the list\n    del x        # delete the original reference\n```\n\n----------------------------------------\n\nTITLE: Inefficient GIL Token Access with with_gil\nDESCRIPTION: Demonstrates a suboptimal approach to accessing the GIL by using Python::with_gil when implementing PartialEq, which incurs unnecessary overhead when the GIL is already held.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/performance.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nstruct Foo(Py<PyList>);\n\nstruct FooBound<'py>(Bound<'py, PyList>);\n\nimpl PartialEq<Foo> for FooBound<'_> {\n    fn eq(&self, other: &Foo) -> bool {\n        Python::with_gil(|py| {\n            let len = other.0.bind(py).len();\n            self.0.len() == len\n        })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Python Functions with Signature Parameters\nDESCRIPTION: Shows the updated syntax for defining Python function signatures using the #[pyo3(signature = (...))] attribute instead of the deprecated direct specification method.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\n#[pyo3(signature = (a, b=0, /))]\nfn add(a: u64, b: u64) -> u64 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Adding PyO3 Signature Attribute in Rust\nDESCRIPTION: Introduces a new #[pyo3(signature = (...))] option for #[pyfunction] and #[pymethods] macros.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\n#[pyo3(signature = (...))]\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Python Native Module\nDESCRIPTION: This snippet shows the Cargo.toml configuration for building a Python native module using pyo3-ffi. It specifies the crate type as 'cdylib' and includes necessary dependencies.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[lib]\nname = \"string_sum\"\ncrate-type = [\"cdylib\"]\n\n[dependencies.pyo3-ffi]\nversion = \"0.24.0\"\nfeatures = [\"extension-module\"]\n\n[build-dependencies]\npyo3_build_config = \"0.24.0\"\n```\n\n----------------------------------------\n\nTITLE: Extracting &str from PyAny with gil-refs feature in Rust\nDESCRIPTION: Demonstrates how to extract a &str from a PyAny object when the gil-refs feature is enabled.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[allow(deprecated)] // GIL Ref API\nlet obj: &'py PyType = py.get_type::<PyList>();\nlet name: &'py str = obj.getattr(\"__name__\")?.extract()?;\nassert_eq!(name, \"list\");\n```\n\n----------------------------------------\n\nTITLE: Creating a New PyO3 Project Environment\nDESCRIPTION: Commands to create a new directory for a PyO3 project, set up a virtual environment with pyenv, and configure it as the local Python environment.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nmkdir pyo3-example\ncd pyo3-example\npyenv virtualenv pyo3\npyenv local pyo3\n```\n\n----------------------------------------\n\nTITLE: Extracting &str from Bound<PyAny> without gil-refs feature in Rust\nDESCRIPTION: Shows how to extract a &str from a Bound<PyAny> object when the gil-refs feature is disabled, using intermediate variables to handle lifetimes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Bound<'py, PyType> = py.get_type_bound::<PyList>();\nlet name_obj: Bound<'py, PyAny> = obj.getattr(\"__name__\")?;\n// the lifetime of the data is no longer `'py` but the much shorter\n// lifetime of the `name_obj` smart pointer above\nlet name: &'_ str = name_obj.extract()?;\nassert_eq!(name, \"list\");\n```\n\n----------------------------------------\n\nTITLE: Using the Basic PyO3 Class in Python\nDESCRIPTION: Shows how to import and instantiate the Number class from Python. Without custom string representations, the default object representation is used.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom my_module import Number\n\nn = Number(5)\nprint(n)\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Pytest\nDESCRIPTION: Instructions for installing the module and running benchmarks using pytest with the benchmark flag enabled. This approach allows developers to test the performance of PyO3 functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pytests/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npip install .\npytest --benchmark-enable\n```\n\n----------------------------------------\n\nTITLE: PyO3 GIL Management Pattern 2\nDESCRIPTION: Demonstrates nested GIL management ensuring proper lock release order by wrapping operations in Python::with_gil blocks.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_22\n\nLANGUAGE: rust\nCODE:\n```\nPython::with_gil(|py| {\n    let first = Object::new(py);\n    let second = Python::with_gil(|py| Object::new(py));\n    drop(first);\n    drop(second);\n});\n```\n\n----------------------------------------\n\nTITLE: Building and Testing Python Extension Module\nDESCRIPTION: These commands install development requirements, build the package in development mode, and run tests using pytest.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/setuptools-rust-starter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\npython setup.py develop && pytest\n```\n\n----------------------------------------\n\nTITLE: Class Constructor with Subtype Parameter\nDESCRIPTION: Example showing constructor definition that receives a subtype's class/PyType as first argument.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[new]\n#[classmethod]\n```\n\n----------------------------------------\n\nTITLE: Building and Testing with Maturin\nDESCRIPTION: Commands to install development dependencies, build the project with maturin, and run tests using pytest.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/decorator/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Using Shorthand Format String for __str__\nDESCRIPTION: Demonstrates using a shorthand format string with the str attribute to automatically generate an __str__ implementation for structs. This approach provides a concise way to format struct fields.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass(str=\"({x}, {y}, {z})\")]\nstruct Coordinate {\n    x: i32,\n    y: i32,\n    z: i32,\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring build.rs for Python Version Compatibility\nDESCRIPTION: This build script uses pyo3_build_config to enable conditional compilation based on Python version or compilation settings.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/README.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn main() {\n    pyo3_build_config::use_pyo3_cfgs()\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Arguments with PyO3 Functions\nDESCRIPTION: Shows migration example for handling required arguments after optional ones using explicit signature declarations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_23\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction(signature = (x, y))]\nfn required_argument_after_option_a(x: Option<i32>, y: i32) {}\n\n#[pyfunction(signature = (x=None, y=0))]\nfn required_argument_after_option_b(x: Option<i32>, y: i32) {}\n```\n\n----------------------------------------\n\nTITLE: Using PyBackedStr with PyO3 for String References\nDESCRIPTION: Example showing how to use PyBackedStr to handle Python strings in Rust without worrying about lifetimes, which is especially helpful for abi3 builds with Python older than 3.10.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::pybacked::PyBackedStr;\nlet obj: Bound<'py, PyType> = py.get_type_bound::<PyList>();\nlet name: PyBackedStr = obj.getattr(\"__name__\")?.extract()?;\nassert_eq!(&*name, \"list\");\n```\n\n----------------------------------------\n\nTITLE: Implementing with_critical_section2 Binding in Rust for PyO3\nDESCRIPTION: This code snippet defines a new function `with_critical_section2` in the PyO3 project. It takes a closure as an argument and executes it within a critical section, ensuring thread-safe access to shared resources.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/4992.added.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\npub fn with_critical_section2<F, R>(f: F) -> R\nwhere\n    F: FnOnce() -> R,\n{\n    crate::sync::with_critical_section(f)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding GILOnceCell::get_or_try_init Method in Rust\nDESCRIPTION: Adds a new method get_or_try_init to GILOnceCell for fallible initialization.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\nGILOnceCell::get_or_try_init\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin and Initializing a Project\nDESCRIPTION: Commands to install Maturin in a virtual environment and initialize a new PyO3 project with the default template.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npip install maturin\nmaturin init\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Failed Function with Lifetime Inference\nDESCRIPTION: An example showing a function that fails to compile because the Rust compiler cannot infer which lifetimes should be connected to the output when using wildcards.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\nfn add(left: &'_ Bound<'_, PyAny>, right: &'_ Bound<'_, PyAny>) -> PyResult<Bound<'_, PyAny>> {\n    left.add(right)\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Module Privacy in PyO3\nDESCRIPTION: Example showing how to properly handle Rust privacy rules with wrap_pymodule! macro. Demonstrates the correct way to make private submodules accessible to the macro.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_27\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    use pyo3::prelude::*;\n\n    #[pymodule]\n    fn private_submodule(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n        Ok(())\n    }\n}\n\nuse pyo3::prelude::*;\nuse foo::*;\n\n#[pymodule]\nfn my_module(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n    m.add_wrapped(wrap_pymodule!(private_submodule))?;\n    Ok(())\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nmod foo {\n    use pyo3::prelude::*;\n\n    #[pymodule]\n    pub(crate) fn private_submodule(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n        Ok(())\n    }\n}\n\nuse pyo3::prelude::*;\nuse pyo3::wrap_pymodule;\nuse foo::*;\n\n#[pymodule]\nfn my_module(_py: Python<'_>, m: &PyModule) -> PyResult<()> {\n    m.add_wrapped(wrap_pymodule!(private_submodule))?;\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Critical Section API in Rust\nDESCRIPTION: Introduces a wrapper around the Python Critical Section API for Python 3.13 and newer in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nAdd `pyo3::sync::with_critical_section`, a wrapper around the Python Critical Section API added in Python 3.13.\n```\n\n----------------------------------------\n\nTITLE: Building a Python Package with Cargo.toml Configuration\nDESCRIPTION: Cargo.toml configuration for creating a Python extension module with PyO3. Specifies the package metadata, library type as 'cdylib' for Python compatibility, and PyO3 dependency with the 'extension-module' feature.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[package]\nname = \"string_sum\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[lib]\n# The name of the native library. This is the name which will be used in Python to import the\n# library (i.e. `import string_sum`). If you change this, you must also change the name of the\n# `#[pymodule]` in `src/lib.rs`.\nname = \"string_sum\"\n# \"cdylib\" is necessary to produce a shared library for Python to import from.\n#\n# Downstream Rust code (including code in `bin/`, `examples/`, and `tests/`) will not be able\n# to `use string_sum;` unless the \"rlib\" or \"lib\" crate type is also included, e.g.:\n# crate-type = [\"cdylib\", \"rlib\"]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\npyo3 = { version = \"0.24.0\", features = [\"extension-module\"] }\n```\n\n----------------------------------------\n\nTITLE: Updating PyErr::new_type signature in Rust\nDESCRIPTION: PyErr::new_type now takes an optional docstring and returns PyResult<Py<PyType>> instead of a raw pointer.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_17\n\nLANGUAGE: Rust\nCODE:\n```\nPyErr::new_type(/* args */) -> PyResult<Py<PyType>>\n```\n\n----------------------------------------\n\nTITLE: Defining Python Functions with Required Arguments After Optional Arguments\nDESCRIPTION: Demonstrates how to correctly define Python functions that have required arguments after optional arguments using the #[pyo3(signature = (...))] attribute.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\n#[pyo3(signature = (x, y))] // both x and y have no defaults and are required\nfn x_or_y(x: Option<u64>, y: u64) -> u64 {\n    x.unwrap_or(y)\n}\n```\n\n----------------------------------------\n\nTITLE: Adding #[classattr] Support for Functions in #[pymethods] in Rust\nDESCRIPTION: Enables defining class attributes using the #[classattr] attribute on functions within #[pymethods], providing a way to create class-level attributes in Python classes defined in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_23\n\nLANGUAGE: Rust\nCODE:\n```\nAdd ability to define class attributes using `#[classattr]` on functions in `#[pymethods]`.\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Argument Extraction in PyO3\nDESCRIPTION: Defines a 'wrap' function to handle overflow in the Number constructor by masking Python integers to 32 bits.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nfn wrap(obj: &Bound<'_, PyAny>) -> PyResult<i32> {\n    let val = obj.call_method1(\"__and__\", (0xFFFFFFFF_u32,))?;\n    let val: u32 = val.extract()?;\n    //     👇 This intentionally overflows!\n    Ok(val as i32)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring VS Code Debugging for PyO3 in Jupyter\nDESCRIPTION: Helper functions to automate VS Code launch configuration for debugging PyO3 code in Jupyter notebooks. Includes functions to detect Jupyter kernel PID and update launch.json with appropriate debug settings.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pathlib import Path\nimport os\nimport json\nimport sys\n\n\ndef update_launch_json(vscode_config_file_path=None):\n    \"\"\"Update VSCode launch.json with the correct Jupyter kernel PID.\n    \n    Args:\n        vscode_config_file_path (str, optional): Path to the .vscode/launch.json file.\n            If not provided, will use the current working directory.\n    \"\"\"\n    pid = get_jupyter_kernel_pid()\n    if not pid:\n        print(\"Could not determine Jupyter kernel PID.\")\n        return\n        \n    # Determine launch.json path\n    if vscode_config_file_path:\n        launch_json_path = vscode_config_file_path\n    else:\n        launch_json_path = os.path.join(Path(os.getcwd()), \".vscode\", \"launch.json\")\n\n    # Get Python interpreter path\n    python_path = sys.executable\n    \n    # Default debugger config\n    debug_config = {\n        \"version\": \"0.2.0\",\n        \"configurations\": [\n            {\n                \"name\": \"Debug PyO3 (Jupyter)\",\n                \"type\": \"lldb\",\n                \"request\": \"attach\",\n                \"program\": python_path,\n                \"pid\": pid,\n                \"sourceLanguages\": [\"rust\"],\n            },\n            {\n                \"name\": \"Launch Python with PyO3\",\n                \"type\": \"lldb\", \n                \"request\": \"launch\",\n                \"program\": python_path,\n                \"args\": [\"${file}\"],\n                \"cwd\": \"${workspaceFolder}\",\n                \"sourceLanguages\": [\"rust\"]\n            }\n        ],\n    }\n\n    # Create .vscode directory if it doesn't exist\n    try:\n        os.makedirs(os.path.dirname(launch_json_path), exist_ok=True)\n        \n        # If launch.json already exists, try to update it instead of overwriting\n        if os.path.exists(launch_json_path):\n            try:\n                with open(launch_json_path, \"r\") as f:\n                    existing_config = json.load(f)\n                \n                # Check if our configuration already exists\n                config_exists = False\n                for config in existing_config.get(\"configurations\", []):\n                    if config.get(\"name\") == \"Debug PyO3 (Jupyter)\":\n                        config[\"pid\"] = pid\n                        config[\"program\"] = python_path\n                        config_exists = True\n                \n                if not config_exists:\n                    existing_config.setdefault(\"configurations\", []).append(debug_config[\"configurations\"][0])\n                \n                debug_config = existing_config\n            except Exception:\n                # If reading fails, we'll just overwrite with our new configuration\n                pass\n        \n        with open(launch_json_path, \"w\") as f:\n            json.dump(debug_config, f, indent=4)\n        print(f\"Updated launch.json with PID: {pid} at {launch_json_path}\")\n    except Exception as e:\n        print(f\"Error updating launch.json: {e}\")\n\n\ndef get_jupyter_kernel_pid():\n    \"\"\"Find the process ID (PID) of the running Jupyter kernel.\n    \n    Returns:\n        int: The process ID of the Jupyter kernel, or None if not found.\n    \"\"\"\n    # Check if we're running in a Jupyter environment\n    if 'ipykernel' in sys.modules:\n        pid = os.getpid()\n        print(f\"Jupyter kernel PID: {pid}\")\n        return pid\n    else:\n        print(\"Not running in a Jupyter environment.\")\n        return None\n```\n\n----------------------------------------\n\nTITLE: Python Logging Configuration\nDESCRIPTION: Python code demonstrating how to configure logging format and level for receiving logs from Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/ecosystem/logging.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nimport my_module\n\nFORMAT = '%(levelname)s %(name)s %(asctime)-15s %(filename)s:%(lineno)d %(message)s'\nlogging.basicConfig(format=FORMAT)\nlogging.getLogger().setLevel(logging.INFO)\nmy_module.log_something()\n```\n\n----------------------------------------\n\nTITLE: Attribute Getter and Setter Implementation\nDESCRIPTION: Example showing the getter and setter attribute macros for property definitions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\n#[getter]\n#[setter]\n```\n\n----------------------------------------\n\nTITLE: Converting between Py<T> and Bound<T> in Rust\nDESCRIPTION: Shows how to convert between Py<T> and Bound<T> using bind(), into_bound(), as_unbound(), and unbind() methods.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\nlet obj: Py<PyList> = ...;\nlet bound: &Bound<'py, PyList> = obj.bind(py);\nlet bound: Bound<'py, PyList> = obj.into_bound(py);\n\nlet obj: &Py<PyList> = bound.as_unbound();\nlet obj: Py<PyList> = bound.unbind();\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoPy<PyObject> for HashSet and BTreeSet in Rust\nDESCRIPTION: Adds implementations of IntoPy<PyObject> for HashSet and BTreeSet types, allowing them to be converted into Python objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_22\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `IntoPy<PyObject>` for `HashSet` and `BTreeSet`.\n```\n\n----------------------------------------\n\nTITLE: Updating PyO3 Datetime Rust Wrappers for ABI3 Compatibility\nDESCRIPTION: This code snippet demonstrates the changes made to PyO3's datetime rust wrappers to ensure compatibility with the abi3 feature. It likely involves modifying function signatures, type definitions, or API usage to conform to the ABI3 specifications.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/4970.changed.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n// No specific code provided, but the changes would involve modifying the existing Rust wrappers for datetime to be compatible with abi3 feature\n```\n\n----------------------------------------\n\nTITLE: Using Custom Number Class in Python\nDESCRIPTION: Demonstrates usage of the custom Number class in Python, including a string hashing algorithm that relies on integer wrapping.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom my_module import Number\n\ndef hash_djb2(s: str):\n\t'''\n\tA version of Daniel J. Bernstein's djb2 string hashing algorithm\n\tLike many hashing algorithms, it relies on integer wrapping.\n\t'''\n\n\tn = Number(0)\n\tfive = Number(5)\n\n\tfor x in s:\n\t\tn = Number(ord(x)) + ((n << five) - n)\n\treturn n\n\nassert hash_djb2('l50_50') == Number(-1152549421)\n```\n\n----------------------------------------\n\nTITLE: Removing ObjectProtocol Usage in PyO3\nDESCRIPTION: Example showing how to update code after the removal of ObjectProtocol. Since the methods were moved to PyAny and native types implement Deref<Target=PyAny>, users only need to remove the explicit import.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_36\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::ObjectProtocol;\n\n# pyo3::Python::with_gil(|py| {\nlet obj = py.eval(\"lambda: 'Hi :)'\" , None, None).unwrap();\nlet hi: &pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();\nassert_eq!(hi.len().unwrap(), 5);\n# })\n```\n\nLANGUAGE: rust\nCODE:\n```\n# pyo3::Python::with_gil(|py| {\nlet obj = py.eval(\"lambda: 'Hi :)'\" , None, None).unwrap();\nlet hi: &pyo3::types::PyString = obj.call0().unwrap().downcast().unwrap();\nassert_eq!(hi.len().unwrap(), 5);\n# })\n```\n\n----------------------------------------\n\nTITLE: Accessing Python Module Documentation\nDESCRIPTION: Shows how to access the documentation of a PyO3 module from Python. The Rust doc comments from the module initialization function are automatically applied as the Python docstring.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/module.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport my_extension\n\nprint(my_extension.__doc__)\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with nox\nDESCRIPTION: Alternative command to run tests using nox, which creates an isolated test environment.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/getitem/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: Command to run tests in an isolated environment using Nox, an automation tool for Python projects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/sequential/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Implementing Deref<Target = PyAny> for Builtin Types in Rust\nDESCRIPTION: Adds Deref implementations with PyAny as the target for all builtin types like PyList, PyTuple, PyDict, etc., allowing them to be dereferenced to PyAny.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_25\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `Deref<Target = PyAny>` for all builtin types. (`PyList`, `PyTuple`, `PyDict` etc.)\n```\n\n----------------------------------------\n\nTITLE: Renaming PyErr methods in Rust\nDESCRIPTION: Several methods on PyErr have been renamed for clarity. The old names are deprecated.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_16\n\nLANGUAGE: Rust\nCODE:\n```\npytype -> get_type\npvalue -> value\nptraceback -> traceback\nfrom_instance -> from_value\ninto_instance -> into_value\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin with System Python\nDESCRIPTION: Command to install Maturin build tool using the system-wide Python installation with the --user flag.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install maturin --user\n```\n\n----------------------------------------\n\nTITLE: Rust Module Setup with PyO3\nDESCRIPTION: Rust code setting up a Python module with Number type object using PyO3's GIL handling and module import functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::PyTypeInfo;\n\nfn main() -> PyResult<()> {\n    Python::with_gil(|py| -> PyResult<()> {\n        let globals = PyModule::import(py, \"__main__\")?.dict();\n        globals.set_item(\"Number\", Number::type_object(py))?;\n\n        py.run(SCRIPT, Some(&globals), None)?;\n        Ok(())\n    })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Thread-Safe PyClasses in PyO3 0.11\nDESCRIPTION: Shows how to modify a PyClass to implement Send by using thread-safe types such as Arc and Mutex instead of non-thread-safe types like Rc and RefCell.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_33\n\nLANGUAGE: rust\nCODE:\n```\n# #![allow(dead_code)]\nuse pyo3::prelude::*;\nuse std::sync::{Arc, Mutex};\n\n#[pyclass]\nstruct ThreadSafe {\n    shared_bools: Arc<Mutex<Vec<bool>>>,\n    closure: Box<dyn Fn() + Send>,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating PyProto Implementations for PyCell\nDESCRIPTION: Example showing how to migrate PySequenceProtocol implementation to use PyRef instead of &T for arguments after PyCell introduction in PyO3 0.9.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_41\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::class::PySequenceProtocol;\n#[pyclass]\nstruct ByteSequence {\n    elements: Vec<u8>,\n}\n#[pyproto]\nimpl PySequenceProtocol for ByteSequence {\n    fn __concat__(&self, other: &Self) -> PyResult<Self> {\n        let mut elements = self.elements.clone();\n        elements.extend_from_slice(&other.elements);\n        Ok(Self { elements })\n    }\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\n# use pyo3::prelude::*;\n# use pyo3::class::PySequenceProtocol;\n#[pyclass]\nstruct ByteSequence {\n    elements: Vec<u8>,\n}\n#[pyproto]\nimpl PySequenceProtocol for ByteSequence {\n    fn __concat__(&self, other: PyRef<'p, Self>) -> PyResult<Self> {\n        let mut elements = self.elements.clone();\n        elements.extend_from_slice(&other.elements);\n        Ok(Self { elements })\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin with Poetry\nDESCRIPTION: Command to add Maturin as a development dependency in a Poetry-managed Python project.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npoetry add -G dev maturin\n```\n\n----------------------------------------\n\nTITLE: Using Python GIL in Instance Methods\nDESCRIPTION: Example showing how to access the Python GIL (Global Interpreter Lock) in an instance method by adding a Python parameter to the signature.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n#[pymethods]\nimpl MyClass {\n    fn method2(&self, py: Python<'_>) -> PyResult<i32> {\n        Ok(10)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding abi3-py311 Feature in Rust\nDESCRIPTION: Adds the abi3-py311 feature to PyO3.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_14\n\nLANGUAGE: Rust\nCODE:\n```\nabi3-py311\n```\n\n----------------------------------------\n\nTITLE: Running GDB with Python Example\nDESCRIPTION: Example command showing how to run rust-gdb with Python to debug a specific package function.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nrust-gdb --args python -c \"import my_package; my_package.sum_to_string(1, 2)\"\n```\n\n----------------------------------------\n\nTITLE: Rust Example: Using Borrowed<'a, 'py, T> with PyTuple\nDESCRIPTION: An example demonstrating the use of Borrowed<'a, 'py, T> when working with Python tuples. The example creates a tuple and extracts each item as a Borrowed smart pointer.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::types::PyTuple;\n\n# fn example<'py>(py: Python<'py>) -> PyResult<()> {\n// Create a new tuple with the elements (0, 1, 2)\nlet t = PyTuple::new(py, [0, 1, 2])?;\nfor i in 0..=2 {\n    let entry: Borrowed<'_, 'py, PyAny> = t.get_borrowed_item(i)?;\n    // `PyAnyMethods::extract` is available on `Borrowed`\n    // via the dereference to `Bound`\n    let value: usize = entry.extract()?;\n    assert_eq!(i, value);\n}\n# Ok(())\n# }\n# Python::with_gil(example).unwrap();\n```\n\n----------------------------------------\n\nTITLE: Adding Py::downcast Method in Rust\nDESCRIPTION: Adds Py::downcast() as a companion to PyAny::downcast(), along with downcast_unchecked() for both types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_12\n\nLANGUAGE: Rust\nCODE:\n```\nPy::downcast()\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Iterator in Rust with PyO3\nDESCRIPTION: Demonstrates how to implement an asynchronous iterator in Rust that directly returns an awaitable, which is now possible without wrapping in Yield or Some.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\n\n#[pyclass]\nstruct PyClassAwaitable {\n    number: usize,\n}\n\n#[pymethods]\nimpl PyClassAwaitable {\n    fn __next__(&self) -> usize {\n        self.number\n    }\n\n    fn __await__(slf: Py<Self>) -> Py<Self> {\n        slf\n    }\n}\n\n#[pyclass]\nstruct PyClassAsyncIter {\n    number: usize,\n}\n\n#[pymethods]\nimpl PyClassAsyncIter {\n    fn __anext__(&mut self) -> PyClassAwaitable {\n        self.number += 1;\n        PyClassAwaitable {\n            number: self.number,\n        }\n    }\n\n    fn __aiter__(slf: Py<Self>) -> Py<Self> {\n        slf\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Project from Template\nDESCRIPTION: Commands to install cargo-generate and create a new project using the PyO3 decorator example template.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/decorator/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/decorator\n```\n\n----------------------------------------\n\nTITLE: PyO3 Module and Constructor Implementation\nDESCRIPTION: Adds PyO3 module initialization and constructor for the UserModel class.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct UserModel {\n    model: Py<PyAny>,\n}\n\n#[pymodule]\nfn trait_exposure(m: &Bound<'_, PyModule>) -> PyResult<()> {\n    m.add_class::<UserModel>()?;\n    Ok(())\n}\n\n#[pymethods]\nimpl UserModel {\n    #[new]\n    pub fn new(model: Py<PyAny>) -> Self {\n        UserModel { model }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FromPyObject with get_item Getter\nDESCRIPTION: Example showing new attribute syntax for deriving FromPyObject to specify get_item as getter for all fields.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n#[pyo3(from_item_all)]\n```\n\n----------------------------------------\n\nTITLE: Expanding PyO3 Macros using Cargo\nDESCRIPTION: Command to expand procedural macros in PyO3 code to view the generated source code. Requires nightly Rust build.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc --profile=check -- -Z unstable-options --pretty=expanded > expanded.rs; rustfmt expanded.rs\n```\n\n----------------------------------------\n\nTITLE: Converting Between Bound<'py, T> and Borrowed<'a, 'py, T> Smart Pointers in Rust\nDESCRIPTION: This code shows how to convert between Bound<'py, T> and Borrowed<'a, 'py, T> smart pointer types using as_borrowed() and to_owned() methods. The Borrowed type has a deref coercion to Bound, and to_owned() creates a new Bound by incrementing the Python reference count.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/types.md#2025-04-16_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nlet bound: Bound<'py, PyAny> = ...;\nlet borrowed: Borrowed<'_, 'py, PyAny> = bound.as_borrowed();\n\n// deref coercion\nlet bound: &Bound<'py, PyAny> = &borrowed;\n\n// create a new Bound by increase the Python reference count\nlet bound: Bound<'py, PyAny> = borrowed.to_owned();\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for macOS Extension Module Linking\nDESCRIPTION: Cargo configuration that manually specifies the linker arguments needed for PyO3 extensions on macOS, providing an alternative to using pyo3-build-config. Sets the necessary flags for both Intel and ARM architectures.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[target.x86_64-apple-darwin]\nrustflags = [\n  \"-C\", \"link-arg=-undefined\",\n  \"-C\", \"link-arg=dynamic_lookup\",\n]\n\n[target.aarch64-apple-darwin]\nrustflags = [\n  \"-C\", \"link-arg=-undefined\",\n  \"-C\", \"link-arg=dynamic_lookup\",\n]\n```\n\n----------------------------------------\n\nTITLE: Configuring Maturin Features in pyproject.toml\nDESCRIPTION: Shows how to configure maturin to use the 'extension-module' feature in pyproject.toml. This approach avoids the need to modify Cargo.toml for PyO3 projects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.maturin]\nfeatures = [\"pyo3/extension-module\"]\n# Or for maturin 0.12:\n# cargo-extra-args = [\"--features\", \"pyo3/extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin Package Manager\nDESCRIPTION: Command to install the Maturin build system for Python packages with Rust extensions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/string-sum/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: PyO3 Cargo Dependencies Configuration\nDESCRIPTION: Example Cargo.toml configuration showing how to specify PyO3 dependencies with optional features to work around linking issues when running tests.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_26\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.pyo3]\nversion = \"0.6.0\"\n\n[features]\nextension-module = [\"pyo3/extension-module\"]\ndefault = [\"extension-module\"]\n```\n\n----------------------------------------\n\nTITLE: Deprecating PyUnicode in Rust\nDESCRIPTION: Deprecates the PyUnicode type in favor of PyString in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_5\n\nLANGUAGE: Rust\nCODE:\n```\nDeprecate `PyUnicode` in favour of `PyString`.\n```\n\n----------------------------------------\n\nTITLE: Installing the Package\nDESCRIPTION: Command to install the word count package using pip\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/word-count/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install .\n```\n\n----------------------------------------\n\nTITLE: Migrating from GILProtected to Mutex in PyO3\nDESCRIPTION: Examples showing how to migrate from PyO3's GILProtected type to std::sync::Mutex for thread-safe static data access in free-threaded Python environments.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/free-threading.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::sync::GILProtected;\nuse pyo3::types::{PyDict, PyNone};\nuse std::cell::RefCell;\n\nstatic OBJECTS: GILProtected<RefCell<Vec<Py<PyDict>>>> =\n    GILProtected::new(RefCell::new(Vec::new()));\n\nPython::with_gil(|py| {\n    // stand-in for something that executes arbitrary Python code\n    let d = PyDict::new(py);\n    d.set_item(PyNone::get(py), PyNone::get(py)).unwrap();\n    OBJECTS.get(py).borrow_mut().push(d.unbind());\n});\n```\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::types::{PyDict, PyNone};\nuse std::sync::Mutex;\n\nstatic OBJECTS: Mutex<Vec<Py<PyDict>>> = Mutex::new(Vec::new());\n\nPython::with_gil(|py| {\n    // stand-in for something that executes arbitrary Python code\n    let d = PyDict::new(py);\n    d.set_item(PyNone::get(py), PyNone::get(py)).unwrap();\n    // as with any `Mutex` usage, lock the mutex for as little time as possible\n    // in this case, we do it just while pushing into the `Vec`\n    OBJECTS.lock().unwrap().push(d.unbind());\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin with pipx\nDESCRIPTION: Command to install Maturin build tool using pipx, which creates isolated environments for Python applications.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npipx install maturin\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies for PyO3\nDESCRIPTION: Specifies required Python packages and their version constraints needed for PyO3 development. Includes pytest for testing, setuptools_rust for Rust integration, and core build tools pip and wheel.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/setuptools-rust-starter/requirements-dev.txt#2025-04-16_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest>=3.5.0\nsetuptools_rust~=1.0.0\npip>=21.3\nwheel\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin Package Manager\nDESCRIPTION: Command to install maturin Python package manager for building Rust extensions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/decorator/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative command to run tests in an isolated environment using nox.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/decorator/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Enabling gil-refs feature in Cargo.toml\nDESCRIPTION: Update the Cargo.toml file to enable the gil-refs feature when upgrading to PyO3 0.21. This silences deprecation warnings related to the API change, allowing for a smoother transition.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n# Cargo.toml\n[dependencies]\npyo3 = { version = \"0.21\", features = [\"gil-refs\"] }\n```\n\n----------------------------------------\n\nTITLE: Default Object Representation Output\nDESCRIPTION: The default output when printing a PyO3 object without custom string representations, showing the memory address but not useful information.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n<builtins.Number object at 0x000002B4D185D7D0>\n```\n\n----------------------------------------\n\nTITLE: Installing Python with pyenv\nDESCRIPTION: Command to install Python 3.12 with pyenv while keeping the source files for debugging purposes.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npyenv install 3.12 --keep\n```\n\n----------------------------------------\n\nTITLE: Disabling Default Contains Method in PyO3\nDESCRIPTION: Example of how to disable Python's default __contains__ implementation for a PyO3 class. This is done by setting the __contains__ class attribute to None, similar to how it would be done in pure Python.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct NoContains {}\n\n#[pymethods]\nimpl NoContains {\n    #[classattr]\n    const __contains__: Option<PyObject> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin with pip\nDESCRIPTION: Installs the maturin build tool using pip. Maturin is required to build the Python extension module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/maturin-starter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Running Tests\nDESCRIPTION: Command to run tests using nox test runner\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/word-count/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Generating Structured Changelog with Jinja2 for PyO3 Project\nDESCRIPTION: This Jinja2 template iterates through sections and categories to create a structured changelog. It organizes changes into packaging, added features, changes, removals, and fixes, with proper formatting and links to pull requests.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/.towncrier.template.md#2025-04-16_snippet_0\n\nLANGUAGE: jinja2\nCODE:\n```\n{% for section_text, section in sections.items() %}{%- if section %}{{section_text}}{% endif -%}\n{% if section %}\n{% for category in ['packaging', 'added', 'changed', 'removed', 'fixed' ] if category in section %}\n### {{ definitions[category]['name'] }}\n\n{% if definitions[category]['showcontent'] %}\n{% for text, pull_requests in section[category].items() %}\n- {{ text }} {{ pull_requests|join(', ') }}\n{% endfor %}\n{% else %}\n- {{ section[category]['']|join(', ') }}\n{% endif %}\n\n{% endfor %}{% else %}No significant changes.{% endif %}{% endfor %}\n```\n\n----------------------------------------\n\nTITLE: PyTuple API Usage - Before and After\nDESCRIPTION: Example showing the API changes from the removal of the gil-refs feature, demonstrating the simplified naming convention.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet tup = PyTuple::new_bound(py, [1, 2, 3]);\n```\n\nLANGUAGE: rust\nCODE:\n```\nlet tup = PyTuple::new(py, [1, 2, 3]);\n```\n\n----------------------------------------\n\nTITLE: Creating New Projects from PyO3-FFI Examples using cargo-generate\nDESCRIPTION: Instructions for using cargo-generate to create new PyO3-FFI projects based on the example crates. The commands install cargo-generate and then use it to clone and customize a specific example from the PyO3 repository.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/<example>\n```\n\n----------------------------------------\n\nTITLE: Including Contributing Guidelines with Markdown Include Directive\nDESCRIPTION: A markdown include directive that imports the contents of a Contributing.md file from two directory levels up\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/contributing.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n{{#include ../../Contributing.md}}\n```\n\n----------------------------------------\n\nTITLE: Deriving FromPyObject with Item Attribute\nDESCRIPTION: Demonstrates using the #[pyo3(item)] attribute on struct fields to extract values using get_item instead of getattr, useful for dictionary-like Python objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyStruct {\n    #[pyo3(item)]\n    my_string: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining PyAny Structure in Rust\nDESCRIPTION: Defines the PyAny structure as a transparent wrapper around UnsafeCell<ffi::PyObject>. This is the core representation of Python objects in PyO3.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Architecture.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\npub struct PyAny(UnsafeCell<ffi::PyObject>);\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling for Windows Target\nDESCRIPTION: Shows environment variable setup for cross-compiling a PyO3 module to a Windows target, specifying both the Python version and library directory.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nexport PYO3_CROSS_PYTHON_VERSION=3.9\nexport PYO3_CROSS_LIB_DIR=\"/home/pyo3/cross/sysroot/usr/lib\"\n\ncargo build --target x86_64-pc-windows-gnu\n```\n\n----------------------------------------\n\nTITLE: Automatic Text Signature Generation\nDESCRIPTION: Example showing the text_signature option being used with new method in pymethods.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[new]\n#[pymethods]\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: An alternative method to run tests using nox, which creates an isolated environment for testing.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/maturin-starter/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Transparent Wrapper Types\nDESCRIPTION: Shows how to create transparent wrapper types with #[pyo3(transparent)] that extract directly from the input object instead of accessing attributes or items.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\nstruct RustyTransparentTupleStruct(String);\n\n#[derive(FromPyObject)]\n#[pyo3(transparent)]\nstruct RustyTransparentStruct {\n    inner: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Python Platform Tags\nDESCRIPTION: Command to query the platform-specific extension suffix from Python's sysconfig module, showing examples for different Python implementations.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# CPython 3.10 on macOS\n.cpython-310-darwin.so\n\n# PyPy 7.3 (Python 3.9) on Linux\n$ python -c 'import sysconfig; print(sysconfig.get_config_var(\"EXT_SUFFIX\"))'\n.pypy39-pp73-x86_64-linux-gnu.so\n```\n\n----------------------------------------\n\nTITLE: Unsafe FFI Implementation for Python Integer Conversion\nDESCRIPTION: Implementation of unsafe FFI code to wrap Python integers using PyLong_AsUnsignedLongMask, including proper error handling and GIL management.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/numeric.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nuse std::os::raw::c_ulong;\nuse pyo3::prelude::*;\nuse pyo3::ffi;\n\nfn wrap(obj: &Bound<'_, PyAny>) -> Result<i32, PyErr> {\n    let py: Python<'_> = obj.py();\n\n    unsafe {\n        let ptr = obj.as_ptr();\n\n        let ret: c_ulong = ffi::PyLong_AsUnsignedLongMask(ptr);\n        if ret == c_ulong::MAX {\n            if let Some(err) = PyErr::take(py) {\n                return Err(err);\n            }\n        }\n\n        Ok(ret as i32)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing and Using Cargo Generate for Project Cloning\nDESCRIPTION: Commands to install cargo-generate and create a new project based on this example. This simplifies the process of copying and using the plugin example.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/plugin/README.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/plugin\n```\n\n----------------------------------------\n\nTITLE: Building and Testing with Maturin\nDESCRIPTION: Installs development dependencies, builds the extension module using maturin develop, and runs pytest for testing.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/maturin-starter/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop && pytest\n```\n\n----------------------------------------\n\nTITLE: Making a PyO3 Class Not Hashable\nDESCRIPTION: Demonstrates how to make a PyO3 class not hashable by setting __hash__ to None. This prevents instances from being used as dictionary keys or in sets.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/object.md#2025-04-16_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct NotHashable {}\n\n#[pymethods]\nimpl NotHashable {\n    #[classattr]\n    const __hash__: Option<Py<PyAny>> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing maturin for PyO3 Package Building\nDESCRIPTION: Command to install the maturin build tool, which is required for building Python packages with PyO3 Rust bindings.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/getitem/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Adding IntoPyObject Trait in Rust\nDESCRIPTION: Introduces the IntoPyObject trait for converting Rust values to Python values. This is a fallible conversion trait.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nAdd `IntoPyObject` (fallible) conversion trait to convert from Rust to Python values.\n```\n\n----------------------------------------\n\nTITLE: Specifying PyO3 Crate Location for Proc-Macros\nDESCRIPTION: Demonstrates how to use the 'crate' attribute to specify the location of the PyO3 crate when it's re-exported or indirectly depended upon, allowing proc-macros to function correctly.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/faq.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\npub extern crate pyo3;\nmod reexported { pub use ::pyo3; }\n\n#[pyclass]\n#[pyo3(crate = \"reexported::pyo3\")]\nstruct MyClass;\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks with Nox\nDESCRIPTION: Alternative method for running benchmarks using nox with the bench session. This provides a simplified command for executing benchmarks in an isolated environment.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pytests/README.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s bench\n```\n\n----------------------------------------\n\nTITLE: Customizing Enum Variant Constructors in PyO3\nDESCRIPTION: Shows how to customize the constructor signatures for enum variants using the #[pyo3(constructor = (...))] attribute, allowing default values and parameter customization.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class.md#2025-04-16_snippet_30\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nenum Shape {\n    #[pyo3(constructor = (radius=1.0))]\n    Circle { radius: f64 },\n    #[pyo3(constructor = (*, width, height))]\n    Rectangle { width: f64, height: f64 },\n    #[pyo3(constructor = (side_count, radius=1.0))]\n    RegularPolygon { side_count: u32, radius: f64 },\n    Nothing { },\n}\n\n# #[cfg(Py_3_10)]\nPython::with_gil(|py| {\n    let cls = py.get_type::<Shape>();\n    pyo3::py_run!(py, cls, r#\"\n        circle = cls.Circle()\n        assert isinstance(circle, cls)\n        assert isinstance(circle, cls.Circle)\n        assert circle.radius == 1.0\n\n        square = cls.Rectangle(width = 1, height = 1)\n        assert isinstance(square, cls)\n        assert isinstance(square, cls.Rectangle)\n        assert square.width == 1\n        assert square.height == 1\n\n        hexagon = cls.RegularPolygon(6)\n        assert isinstance(hexagon, cls)\n        assert isinstance(hexagon, cls.RegularPolygon)\n        assert hexagon.side_count == 6\n        assert hexagon.radius == 1\n    \"#)\n})\n```\n\n----------------------------------------\n\nTITLE: Python Usage Example\nDESCRIPTION: Example Python code demonstrating how to use the exposed Rust functionality.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/trait-bounds.md#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Model:\n    def set_variables(self, inputs):\n        self.inputs = inputs\n    def compute(self):\n        self.results = [elt**2 - 3 for elt in self.inputs]\n    def get_results(self):\n        return self.results\n\nif __name__==\"__main__\":\n  import trait_exposure\n\n  myModel = Model()\n  my_rust_model = trait_exposure.UserModel(myModel)\n  my_rust_model.set_variables([2.0])\n  print(\"Print value from Python: \", myModel.inputs)\n  my_rust_model.compute()\n  print(\"Print value from Python through Rust: \", my_rust_model.get_results())\n  print(\"Print value directly from Python: \", myModel.get_results())\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Examples in Rust\nDESCRIPTION: Demonstrates usage of cfg attributes for conditional compilation based on Python versions\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(Py_3_7)]\nfn function_only_supported_on_python_3_7_and_up() {}\n\n#[cfg(not(Py_3_8))]\nfn function_only_supported_before_python_3_8() {}\n\n#[cfg(not(Py_LIMITED_API))]\nfn function_incompatible_with_abi3_feature() {}\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: This command uses nox to run tests in an isolated environment, providing an alternative method for testing the package.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/setuptools-rust-starter/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox in Isolated Environment\nDESCRIPTION: Alternative method for running tests using nox, which creates an isolated environment for testing. This approach ensures consistent testing environments across different systems.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pytests/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Using Word Count Functions\nDESCRIPTION: Example usage of the different search implementations showing Python and Rust search functions\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/word-count/README.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom word_count import search_py, search, search_sequential\n\nsearch_py(\"foo bar\", \"foo\")\nsearch(\"foo bar\", \"foo\")\nsearch_sequential(\"foo bar\", \"foo\")\n```\n\n----------------------------------------\n\nTITLE: Updating PyType method names in Rust\nDESCRIPTION: Changes to method names on PyType, PyErr and PyAny for consistency. The old names are deprecated but still available.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_15\n\nLANGUAGE: Rust\nCODE:\n```\nPyType::is_subclass -> PyType::is_subclass_of\nPyErr::is_instance -> PyErr::is_instance_of\nPyAny::is_instance -> PyAny::is_instance_of\n```\n\n----------------------------------------\n\nTITLE: Setting Up and Running Tests with Maturin and Pytest\nDESCRIPTION: Instructions for installing maturin, building the PyO3 extension module, and running tests using pytest. This is the basic workflow for testing the PyO3 module during development.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pytests/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Byte Collection Conversion Example\nDESCRIPTION: Example showing how byte collections now convert to PyBytes instead of PyList in Python conversions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[pyfunction]\nfn foo() -> Vec<u8> {\n    vec![0, 1, 2, 3]\n}\n\n#[pyfunction]\nfn bar() -> Vec<u16> {\n    vec![0, 1, 2, 3]\n}\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Isolated Environment with Nox\nDESCRIPTION: Command to run tests for the plugin API in an isolated environment using nox.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/plugin/README.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Project Generation Commands\nDESCRIPTION: Commands to install cargo-generate and create a new project based on this example\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/word-count/README.md#2025-04-16_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/word-count\n```\n\n----------------------------------------\n\nTITLE: Adding PyErr::warn_explicit Method in Rust\nDESCRIPTION: Adds types for all built-in Warning classes and the PyErr::warn_explicit method.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_13\n\nLANGUAGE: Rust\nCODE:\n```\nPyErr::warn_explicit\n```\n\n----------------------------------------\n\nTITLE: Removing Deprecated Traits from PyO3\nDESCRIPTION: Removal of the IntoPy and ToPyObject traits from PyO3 codebase. These traits were previously used for Python object conversion but have been deprecated in favor of newer conversion mechanisms.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/5010.removed.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nIntoPy\nToPyObject\n```\n\n----------------------------------------\n\nTITLE: Changing PyModule::from_code Arguments in Rust\nDESCRIPTION: Updates the PyModule::from_code method to expect &CStr arguments instead of &str in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n`PyModule::from_code` now expects `&CStr` as arguments instead of `&str`.\n```\n\n----------------------------------------\n\nTITLE: Building and Testing PyO3 Project with Maturin\nDESCRIPTION: Commands to install development requirements, build the project, and run tests using Maturin and pytest.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/sequential/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: PyO3 Build Config Dependency Configuration\nDESCRIPTION: Shows how to add pyo3-build-config as a build dependency in Cargo.toml\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[build-dependencies]\npyo3-build-config = { {{#PYO3_CRATE_VERSION}}, features = [\"resolve-config\"] }\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Dict Type in Rust\nDESCRIPTION: Defines the PyDict structure as a transparent wrapper around PyAny. This demonstrates how specific Python types are implemented in PyO3.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Architecture.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(transparent)]\npub struct PyDict(PyAny);\n```\n\n----------------------------------------\n\nTITLE: Building and Testing with Maturin\nDESCRIPTION: Commands to install development dependencies, build the package with Maturin, and run tests using pytest.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/string-sum/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin for Python Package Building\nDESCRIPTION: Command to install maturin, a tool for building and publishing Rust-based Python packages.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/plugin/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Installing Maturin with pyenv\nDESCRIPTION: Commands to activate a pyenv virtual environment and install Maturin build tool within it.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/getting-started.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npyenv activate pyo3\npip install maturin\n```\n\n----------------------------------------\n\nTITLE: Printing PyO3 Build Configuration\nDESCRIPTION: Example output when running a cargo build with PYO3_PRINT_CONFIG=1 to display the Python configuration that PyO3 will use.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ PYO3_PRINT_CONFIG=1 cargo build\n   Compiling pyo3 v0.14.1 (/home/david/dev/pyo3)\nerror: failed to run custom build command for `pyo3 v0.14.1 (/home/david/dev/pyo3)`\n\nCaused by:\n  process didn't exit successfully: `/home/david/dev/pyo3/target/debug/build/pyo3-7a8cf4fe22e959b7/build-script-build` (exit status: 101)\n  --- stdout\n  cargo:rerun-if-env-changed=PYO3_CROSS\n  cargo:rerun-if-env-changed=PYO3_CROSS_LIB_DIR\n  cargo:rerun-if-env-changed=PYO3_CROSS_PYTHON_VERSION\n  cargo:rerun-if-env-changed=PYO3_PRINT_CONFIG\n\n  -- PYO3_PRINT_CONFIG=1 is set, printing configuration and halting compile --\n  implementation=CPython\n  version=3.8\n  shared=true\n  abi3=false\n  lib_name=python3.8\n  lib_dir=/usr/lib\n  executable=/usr/bin/python\n  pointer_width=64\n  build_flags=\n  suppress_build_script_link_lines=false\n```\n\n----------------------------------------\n\nTITLE: Installing setuptools_rust for Python Extension Module\nDESCRIPTION: This command installs the setuptools_rust package, which is required for building the Python extension module.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/setuptools-rust-starter/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install setuptools_rust\n```\n\n----------------------------------------\n\nTITLE: Migrating FromPyObject implementation to use extract_bound in Rust\nDESCRIPTION: Shows how to update a FromPyObject implementation to use the new extract_bound method instead of extract.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\nimpl<'py> FromPyObject<'py> for MyType {\n    fn extract_bound(obj: &Bound<'py, PyAny>) -> PyResult<Self> {\n        /* ... */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Copying the Example Project using Cargo Generate\nDESCRIPTION: Instructions for installing cargo-generate and using it to create a new project based on the maturin-starter example.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/maturin-starter/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/maturin-starter\n```\n\n----------------------------------------\n\nTITLE: Debugging Macros with Trace Option\nDESCRIPTION: Command to expand and trace classic macros in PyO3 code. Includes additional trace information for debugging.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/debugging.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo rustc --profile=check -- -Z unstable-options --pretty=expanded -Z trace-macros > expanded.rs; rustfmt expanded.rs\n```\n\n----------------------------------------\n\nTITLE: Copying PyO3 Sequential Project with Cargo Generate\nDESCRIPTION: Commands to install cargo-generate and use it to create a new project based on the PyO3 sequential example.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/sequential/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/sequential\n```\n\n----------------------------------------\n\nTITLE: Implementing getattr_opt method in PyAnyMethods trait for PyO3\nDESCRIPTION: This code snippet adds the getattr_opt method to the PyAnyMethods trait. It allows for optional attribute retrieval from Python objects in Rust, returning None if the attribute doesn't exist instead of raising an exception.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/newsfragments/4978.added.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nfn getattr_opt<'py>(&'py self, name: &str) -> PyResult<Option<&'py PyAny>> {\n    let ptr = ffi!(PyObject_GetAttrString(self.as_ptr(), name.as_ptr() as *const c_char));\n    if ptr.is_null() {\n        if PyErr_ExceptionMatches(PyExc_AttributeError()) != 0 {\n            PyErr_Clear();\n            Ok(None)\n        } else {\n            Err(PyErr::fetch(self.py()))\n        }\n    } else {\n        Ok(Some(unsafe { PyAny::from_borrowed_ptr(self.py(), ptr) }))\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating New Project from Template\nDESCRIPTION: Commands to install cargo-generate and create a new project based on this example using the PyO3 template.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/string-sum/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/string_sum\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Alternative testing approach using Nox for isolated test environment execution.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/pyo3-ffi/examples/string-sum/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Version Tag Format Example\nDESCRIPTION: Demonstrates the format for version tags in PyO3 releases, where <version> represents the new version number with a preceding 'v'.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Releasing.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nv<version>\n```\n\n----------------------------------------\n\nTITLE: Building and Testing PyO3 Project with maturin\nDESCRIPTION: Commands to install development dependencies, build the Rust library with maturin in development mode, and run tests using pytest.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/getitem/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install -r requirements-dev.txt\nmaturin develop\npytest\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Exceptions to a PyO3 Extension Module\nDESCRIPTION: Demonstrates how to add a custom exception to a PyO3 extension module, making it importable from Python. The exception is created with create_exception! and added to the module using the add method.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/exception.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::exceptions::PyException;\n\npyo3::create_exception!(mymodule, CustomError, PyException);\n\n#[pymodule]\nfn mymodule(py: Python<'_>, m: &Bound<'_, PyModule>) -> PyResult<()> {\n    // ... other elements added to module ...\n    m.add(\"CustomError\", py.get_type::<CustomError>())?;\n\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Exception Classes in Python Stub File\nDESCRIPTION: Example of how exception classes are defined in a Python stub file, showing the interface description without implementation details.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/python-typing-hints.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass BaseException(object):\n    args: Tuple[Any, ...]\n    __cause__: BaseException | None\n    __context__: BaseException | None\n    __suppress_context__: bool\n    __traceback__: TracebackType | None\n    def __init__(self, *args: object) -> None: ...\n    def __str__(self) -> str: ...\n    def __repr__(self) -> str: ...\n    def with_traceback(self: _TBE, tb: TracebackType | None) -> _TBE: ...\n\nclass SystemExit(BaseException):\n    code: int\n\nclass Exception(BaseException): ...\n\nclass StopIteration(Exception):\n    value: Any\n```\n\n----------------------------------------\n\nTITLE: Contributors List Command\nDESCRIPTION: Nox command to generate a list of contributors between the previous version and the new release branch.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Releasing.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s contributors -- v<prev-version> release-<BRANCH_VER>\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks\nDESCRIPTION: Command to execute benchmarks using nox\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/word-count/README.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nnox -s bench\n```\n\n----------------------------------------\n\nTITLE: Running the Rust Application with Python Plugin\nDESCRIPTION: Command to build and run the main application that uses Python plugin functionality. This builds both the Rust app and the plugin API, then demonstrates the plugin in action.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/plugin/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo run\n```\n\n----------------------------------------\n\nTITLE: Setting Up Project Using cargo-generate\nDESCRIPTION: Instructions for cloning and setting up the example project using cargo-generate, which helps create new Rust projects from templates.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/getitem/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/decorator\n```\n\n----------------------------------------\n\nTITLE: Copying PyO3 setuptools-rust-starter Example\nDESCRIPTION: These commands install cargo-generate and use it to create a new project based on the setuptools-rust-starter example from the PyO3 repository.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/examples/setuptools-rust-starter/README.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ cargo install cargo-generate\n$ cargo generate --git https://github.com/PyO3/pyo3 examples/setuptools-rust-starter\n```\n\n----------------------------------------\n\nTITLE: Release Branch Format for Patch Releases\nDESCRIPTION: Shows the branch naming convention for patch releases (0.X.Y), using the full version number.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Releasing.md#2025-04-16_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\nrelease-0.X.Y\n```\n\n----------------------------------------\n\nTITLE: Publish Command\nDESCRIPTION: Nox command to publish the release to crates.io\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Releasing.md#2025-04-16_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nnox -s publish\n```\n\n----------------------------------------\n\nTITLE: Defining PyCell Structure for Python Class Compatibility\nDESCRIPTION: Implements the PyCell structure to ensure Python object compatibility. It includes the required ob_base field and wraps the user-defined type T.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Architecture.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[repr(C)]\npub struct PyCell<T: PyClass> {\n    ob_base: crate::ffi::PyObject,\n    inner: T,\n}\n```\n\n----------------------------------------\n\nTITLE: Release Branch Format for Minor Releases\nDESCRIPTION: Shows the branch naming convention for minor releases (0.X.0), using just the major and minor version numbers.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/Releasing.md#2025-04-16_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nrelease-0.X\n```\n\n----------------------------------------\n\nTITLE: Adding FFI Definitions in Rust\nDESCRIPTION: Adds various FFI definitions for Python functions and constants in Rust, primarily for Python 3.13 and newer versions.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: Rust\nCODE:\n```\nAdd FFI definitions `PyObject_GetOptionalAttr`, `PyObject_GetOptionalAttrString`, `PyObject_HasAttrWithError`, `PyObject_HasAttrStringWithError`, `Py_CONSTANT_*` constants, `Py_GetConstant`, `Py_GetConstantBorrowed`, and `PyType_GetModuleByDef` on Python 3.13 and newer.\n```\n\n----------------------------------------\n\nTITLE: Deprecating PyTuple Methods in Rust\nDESCRIPTION: Deprecation of PyTuple::split_from and PyTuple::slice methods, with new PyTuple::get_slice method added using usize indices.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_20\n\nLANGUAGE: Rust\nCODE:\n```\n// Deprecated\npy_tuple.split_from(1);\npy_tuple.slice(0, 2);\n\n// New\npy_tuple.get_slice(0, 2);\n```\n\n----------------------------------------\n\nTITLE: Extracting All Fields with get_item Method\nDESCRIPTION: Demonstrates using #[pyo3(from_item_all)] on a struct to extract every field with the get_item method, useful for mapping-like Python objects.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/conversions/traits.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(FromPyObject)]\n#[pyo3(from_item_all)]\nstruct RustyStruct {\n    foo: String,\n    bar: String,\n    #[pyo3(item(\"foobar\"))]\n    baz: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Updating PyErr Usage in Rust\nDESCRIPTION: Changes to PyErr::fetch to panic in debug mode if no exception is present, and addition of PyErr::cause and PyErr::set_cause methods.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_21\n\nLANGUAGE: Rust\nCODE:\n```\n// New behavior\nlet err = PyErr::fetch(py); // May panic in debug mode\n\n// New methods\nlet cause = err.cause(py);\nerr.set_cause(py, Some(cause));\n```\n\n----------------------------------------\n\nTITLE: Implementing Python Iterator in Rust using IterNextOutput\nDESCRIPTION: Shows an example of implementing a Python iterator in Rust using the deprecated IterNextOutput type. This approach is no longer recommended.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::prelude::*;\nuse pyo3::iter::IterNextOutput;\n\n#[pyclass]\nstruct PyClassIter {\n    count: usize,\n}\n\n#[pymethods]\nimpl PyClassIter {\n    fn __next__(&mut self) -> IterNextOutput<usize, &'static str> {\n        if self.count < 5 {\n            self.count += 1;\n            IterNextOutput::Yield(self.count)\n        } else {\n            IterNextOutput::Return(\"done\")\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Error Due to LTO Version Mismatch in Static Embedding\nDESCRIPTION: Shows a fatal error that can occur when linking the Python interpreter statically with mismatched compiler versions, specifically when the bytecode stream is generated with a different LTO version than expected.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nlto1: fatal error: bytecode stream in file 'rust-numpy/target/release/deps/libpyo3-6a7fb2ed970dbf26.rlib' generated with LTO version 6.0 instead of the expected 6.2\n```\n\n----------------------------------------\n\nTITLE: Example of PIE Relocation Error in Static Embedding\nDESCRIPTION: Shows a linker error that can occur when embedding the Python interpreter statically with mismatched compilation flags, specifically when trying to use a non-PIE object in a PIE context.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution.md#2025-04-16_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/9/../../../x86_64-linux-gnu/libpython3.9.a(zlibmodule.o): relocation R_X86_64_32 against `.data' can not be used when making a PIE object; recompile with -fPIE\n```\n\n----------------------------------------\n\nTITLE: Using Direct Error Construction in PyO3 0.12\nDESCRIPTION: Shows how to construct a PyResult directly with Err instead of using the removed Into<PyResult<T>> for PyErr. Demonstrates the updated pattern using the new exception types.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/migration.md#2025-04-16_snippet_28\n\nLANGUAGE: rust\nCODE:\n```\nlet result: PyResult<()> = Err(PyTypeError::new_err(\"error message\"));\n```\n\n----------------------------------------\n\nTITLE: Disabling Python's Default Hash in a PyClass\nDESCRIPTION: Shows how to make a PyO3 class non-hashable by setting the __hash__ class attribute to None, which prevents the default hash implementation from being used.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/class/protocols.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[pyclass]\nstruct NotHashable {}\n\n#[pymethods]\nimpl NotHashable {\n    #[classattr]\n    const __hash__: Option<PyObject> = None;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating PyO3 API Usage in Rust\nDESCRIPTION: Changes to PyO3 APIs for PyList, PyTuple, and PySequence to use usize indices instead of isize, and return PyResult types instead of panicking.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_19\n\nLANGUAGE: Rust\nCODE:\n```\n// Old\npy_list.get_item(-1); // isize index, may panic\n\n// New \npy_list.get_item(0)?; // usize index, returns PyResult\n```\n\n----------------------------------------\n\nTITLE: Runtime Python Version Check Example\nDESCRIPTION: Demonstrates how to check Python version at runtime using PyO3's version_info API\nSOURCE: https://github.com/PyO3/pyo3/blob/main/guide/src/building-and-distribution/multiple-python-versions.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nuse pyo3::Python;\n\nPython::with_gil(|py| {\n    // PyO3 supports Python 3.7 and up.\n    assert!(py.version_info() >= (3, 7));\n    assert!(py.version_info() >= (3, 7, 0));\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing PartialEq for PyInt in Rust\nDESCRIPTION: Implements PartialEq for Bound<'py, PyInt> with various integer types in Rust.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `PartialEq` for `Bound<'py, PyInt>` with `u8`, `u16`, `u32`, `u64`, `u128`, `usize`, `i8`, `i16`, `i32`, `i64`, `i128` and `isize`.\n```\n\n----------------------------------------\n\nTITLE: Deprecating PyType::is_instance in favor of object method\nDESCRIPTION: PyType::is_instance is deprecated. Use the is_instance method on the object instead for consistency.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_18\n\nLANGUAGE: Rust\nCODE:\n```\n// Old (deprecated)\ntyp.is_instance(obj)\n\n// New\nobj.is_instance(typ)\n```\n\n----------------------------------------\n\nTITLE: Implementing Clone for PyObject and Py<T> in Rust\nDESCRIPTION: Adds Clone implementations for PyObject and Py<T> types, allowing them to be cloned.\nSOURCE: https://github.com/PyO3/pyo3/blob/main/CHANGELOG.md#2025-04-16_snippet_24\n\nLANGUAGE: Rust\nCODE:\n```\nImplement `Clone` for `PyObject` and `Py<T>`.\n```"
  }
]