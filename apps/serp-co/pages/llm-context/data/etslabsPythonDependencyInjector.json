[
  {
    "owner": "ets-labs",
    "repo": "python-dependency-injector",
    "content": "TITLE: Configuring and Using Dependency Injector Containers in Python\nDESCRIPTION: This Python code demonstrates how to set up and use Dependency Injector's core components: declarative containers, providers, configuration injection, and automatic dependency wiring into Python functions. Dependencies like ApiClient and Service are provided via Singleton and Factory providers, while configuration values are injected from environment variables. The snippet also illustrates how to override providers for testing, requiring dependency_injector and optionally mock for testing. Inputs are environment variables (API_KEY and TIMEOUT); outputs are injected Service instances and controllable execution with overridden dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/index.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\nfrom dependency_injector.wiring import Provide, inject\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    api_client = providers.Singleton(\n        ApiClient,\n        api_key=config.api_key,\n        timeout=config.timeout,\n    )\n\n    service = providers.Factory(\n        Service,\n        api_client=api_client,\n    )\n\n\n@inject\ndef main(service: Service = Provide[Container.service]) -> None:\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.config.api_key.from_env(\"API_KEY\", required=True)\n    container.config.timeout.from_env(\"TIMEOUT\", as_=int, default=5)\n    container.wire(modules=[__name__])\n\n    main()  # <-- dependency is injected automatically\n\n    with container.api_client.override(mock.Mock()):\n        main()  # <-- overridden dependency is injected automatically\n\n```\n\n----------------------------------------\n\nTITLE: Creating the Main Application Entry Point in Python\nDESCRIPTION: Implements the main application module which initializes the containers, loads configuration, and executes the application logic. Shows how to use dependency injection to wire together application components.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-multiple-containers.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n../../examples/miniapps/application-multiple-containers/example/__main__.py\n```\n\n----------------------------------------\n\nTITLE: Checking Container Dependencies in Python Dependency Injector\nDESCRIPTION: This code snippet demonstrates how to verify container dependencies using the check_dependencies() method in a Python dependency injection container. It ensures that all dependencies are defined and defaults are set, raising an error if any are missing. The snippet emphasizes the importance of dependency completeness before container usage.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/check_dependencies.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport dependency_injector\n\ncontainer = dependency_injector.containers.DynamicContainer()\n\n# Check all dependencies in the container\ncontainer.check_dependencies()\n\n# The method raises an error if unresolved dependencies exist; otherwise, proceed\n```\n\n----------------------------------------\n\nTITLE: Wiring Container to Modules and Packages Using container.wire() Method in Python\nDESCRIPTION: Describes usage of the container.wire() method to enable wiring of container providers into specified modules or packages. Modules can be specified as import strings or already imported module objects. Packages are recursively processed for wiring. Supports relative imports resolved with optional from_package argument. Wiring patches functions and methods with markers to provide injections when called. Functions are injected with keyword arguments by default. Explicit unwiring is supported to revert patching. Wiring usage is shown for testing scenarios with unittest and pytest. Limitations of patching individually imported functions are noted.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncontainer.wire(\n    modules=[\n        \"yourapp.module1\",\n        \"yourapp.module2\",\n    ],\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n# In module \"yourapp.main\":\n\ncontainer.wire(\n    modules=[\n        \".module1\",  # Resolved to: \"yourapp.module1\"\n        \".module2\",  # Resolved to: \"yourapp.module2\"\n    ],\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n# In module \"yourapp.main\":\n\ncontainer.wire(\n    modules=[\n        \".module1\",  # Resolved to: \"anotherapp.module1\"\n        \".module2\",  # Resolved to: \"anotherapp.module2\"\n    ],\n    from_package=\"anotherapp\",\n)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom yourapp import module1, module2\n\n\ncontainer = Container()\ncontainer.wire(modules=[module1, module2])\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.wire(\n    packages=[\n        \"yourapp.package1\",\n        \"yourapp.package2\",\n    ],\n)\n```\n\nLANGUAGE: python\nCODE:\n```\n@inject\ndef foo(bar: Bar = Provide[Container.bar]):\n    ...\n\n\ncontainer = Container()\ncontainer.wire(modules=[__name__])\n\nfoo()  # <--- Argument \"bar\" is injected\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo()  # Equivalent to:\nfoo(bar=container.bar())\n```\n\nLANGUAGE: python\nCODE:\n```\nfoo(bar=Bar())  # Bar() is injected\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.unwire()\n```\n\nLANGUAGE: python\nCODE:\n```\nimport unittest\n\n\nclass SomeTest(unittest.TestCase):\n\n    def setUp(self):\n        self.container = Container()\n        self.container.wire(modules=[\"yourapp.module1\", \"yourapp.module2\"])\n        self.addCleanup(self.container.unwire)\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pytest\n\n\n@pytest.fixture\ndef container():\n    container = Container()\n    container.wire(modules=[\"yourapp.module1\", \"yourapp.module2\"])\n    yield container\n    container.unwire()\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Modules and Class Attributes Using Provide with String Identifiers in Python\nDESCRIPTION: Demonstrates injection of container providers into module-level variables and class attributes using Provide markers with string identifiers. This technique allows avoiding explicit container dependencies in classes or modules by assigning provider injections directly to variables or attribute annotations. Enables seamless injection especially for singleton-like services. Requires dependency-injector wiring.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nservice: Service = Provide[\"service\"]\n\n\nclass Main:\n\n    service: Service = Provide[\"service\"]\n```\n\n----------------------------------------\n\nTITLE: Testing FastAPI Endpoint with Dependency Overriding in Python\nDESCRIPTION: Demonstrates how to test the FastAPI endpoint defined in `application.py` using `pytest` and `TestClient`. It utilizes the `container.override` context manager to replace the `Service` provided by the container with a `unittest.mock.Mock` object during the test. This allows testing the endpoint's behavior in isolation, verifying that the mocked service method (`process`) is called as expected, without requiring a real Redis instance.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n\"Tests module.\"\n\nfrom unittest import mock\n\nimport pytest\n\nfrom fastapi.testclient import TestClient\n\nfrom .application import app\nfrom .containers import Container\nfrom .services import Service\n\n\n@pytest.fixture\ndef client(container: Container) -> TestClient:\n    \"\"\"Test client fixture.\n\n    Args:\n        container (Container): Container instance.\n\n    Returns:\n        TestClient: Test client instance.\n    \"\"\"\n    return TestClient(app)\n\n\n@pytest.fixture\ndef container() -> Container:\n    \"\"\"Container fixture.\n\n    Returns:\n        Container: Container instance.\n    \"\"\"\n    return app.container\n\n\ndef test_main_endpoint(\n        client: TestClient,\n        container: Container,\n):\n    \"\"\"Test main endpoint.\n\n    Args:\n        client (TestClient): Test client instance.\n        container (Container): Container instance.\n    \"\"\"\n    service_mock = mock.AsyncMock(spec=Service)\n    service_mock.process.return_value = 'foo'\n\n    with container.service.override(service_mock):\n        response = client.get('/')\n\n    assert response.status_code == 200\n    # assert response.json() == {'value': 'foo'}\n    # service_mock.process.assert_called_once()\n\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Dependency Error in Python Dependency Injector\nDESCRIPTION: This Python code sample illustrates how the Dependency provider raises an error when a dependency is not provided or overridden. It features error handling around an attempt to use an undefined dependency and shows proper exception management for missing dependencies within the Dependency Injector framework. Requires dependency_injector. A correct override or provision of the dependency is necessary to avoid an exception.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/dependency.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    dependency = providers.Dependency()\n\ncontainer = Container()\ntry:\n    obj = container.dependency()\nexcept Exception as exc:\n    print(f\"Dependency not provided: {exc}\")\n\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Injection Container with Dependency Injector in Python\nDESCRIPTION: Defines a DeclarativeContainer class to configure providers for an API client singleton and a service factory using the Dependency Injector framework. The container uses configuration providers to load parameters such as API key and timeout from environment variables. Dependencies are injected automatically into functions decorated with @inject via wiring. Provider overriding demonstrates how to replace a real API client with a mock for testing. This snippet requires the dependency_injector Python package and assumes ApiClient and Service classes exist. Inputs are environment variables for configuration; outputs are assembled service instances injected at runtime.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/README.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\nfrom dependency_injector.wiring import Provide, inject\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    api_client = providers.Singleton(\n        ApiClient,\n        api_key=config.api_key,\n        timeout=config.timeout,\n    )\n\n    service = providers.Factory(\n        Service,\n        api_client=api_client,\n    )\n\n\n@inject\ndef main(service: Service = Provide[Container.service]) -> None:\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.config.api_key.from_env(\"API_KEY\", required=True)\n    container.config.timeout.from_env(\"TIMEOUT\", as_=int, default=5)\n    container.wire(modules=[__name__])\n\n    main()  # <-- dependency is injected automatically\n\n    with container.api_client.override(mock.Mock()):\n        main()  # <-- overridden dependency is injected automatically\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies in FastAPI Handlers Using @inject Decorator in Python\nDESCRIPTION: Shows integration of dependency-injector wiring with FastAPI route handlers. The async route function is decorated with @inject and uses the FastAPI Depends combined with Provide to specify dependencies. This example demonstrates combining FastAPI's dependency injection with the wiring feature to seamlessly inject services during request processing. Requires FastAPI and dependency-injector packages along with a properly configured Container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\napp = FastAPI()\n\n\n@app.api_route(\"/\")\n@inject\nasync def index(service: Annotated[Service, Depends(Provide[Container.service])]):\n    value = await service.process()\n    return {\"result\": value}\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies Using @inject Decorator in Python\nDESCRIPTION: Defines use of the @inject decorator from the dependency_injector.wiring module to inject container providers into function or method arguments. The decorator must be the very first decorator to ensure proper wiring and performance. Typical usage decorates functions with @inject and specifies dependencies via default argument values using Provide[Container.provider]. This snippet illustrates basic injection and usage with multiple decorators ensuring @inject is outermost. It requires the dependency-injector package and an existing Container class defining providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.wiring import inject, Provide\n\n@inject\ndef foo(bar: Bar = Provide[Container.bar]):\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.wiring import inject, Provide\n\n@decorator_etc\n@decorator_2\n@decorator_1\n@inject\ndef foo(bar: Bar = Provide[Container.bar]):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Testing MovieLister Logic with Pytest and Dependency Injector in Python\nDESCRIPTION: Implements unit tests for the MovieLister component using pytest and unittest.mock, leveraging Dependency Injector's provider overriding feature to inject a mock finder dependency. Key test functions validate correct filtering by director and year. Prerequisites are pytest and dependency_injector. Inputs are mock movie data; outputs are pytest assertions. Limitations: assumes container and providers are correctly defined elsewhere in the package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Tests module.\"\"\"\n\nfrom unittest import mock\n\nimport pytest\n\nfrom .containers import Container\n\n\n@pytest.fixture\ndef container():\n    container = Container(\n        config={\n            \"finder\": {\n                \"type\": \"csv\",\n                \"csv\": {\n                    \"path\": \"/fake-movies.csv\",\n                    \"delimiter\": \",\",\n                },\n                \"sqlite\": {\n                    \"path\": \"/fake-movies.db\",\n                },\n            },\n        },\n    )\n    return container\n\n\n@pytest.fixture\ndef finder_mock(container):\n    finder_mock = mock.Mock()\n    finder_mock.find_all.return_value = [\n        container.movie(\"The 33\", 2015, \"Patricia Riggen\"),\n        container.movie(\"The Jungle Book\", 2016, \"Jon Favreau\"),\n    ]\n\n    return finder_mock\n\n\ndef test_movies_directed_by(container, finder_mock):\n    with container.finder.override(finder_mock):\n        lister = container.lister()\n        movies = lister.movies_directed_by(\"Jon Favreau\")\n\n    assert len(movies) == 1\n    assert movies[0].title == \"The Jungle Book\"\n\n\ndef test_movies_released_in(container, finder_mock):\n    with container.finder.override(finder_mock):\n        lister = container.lister()\n        movies = lister.movies_released_in(2015)\n\n    assert len(movies) == 1\n    assert movies[0].title == \"The 33\"\n```\n\n----------------------------------------\n\nTITLE: Initializing and Shutting Down Redis Connection Pool in Python\nDESCRIPTION: Defines asynchronous functions `init_redis_pool` and `shutdown_redis_pool` within the `redis.py` module to manage an `aioredis` connection pool. `init_redis_pool` creates and returns a Redis pool configured from environment variables, while `shutdown_redis_pool` closes the pool and waits for connections to terminate gracefully. These are intended for use during application startup and shutdown.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n\"Redis module.\"\n\nimport os\n\nimport aioredis\n\n\nasync def init_redis_pool() -> aioredis.Redis:\n    \"\"\"Init redis pool.\n\n    Returns:\n        aioredis.Redis: Redis pool instance.\n    \"\"\"\n    redis_host = os.getenv('REDIS_HOST', 'localhost')\n    redis_port = int(os.getenv('REDIS_PORT', '6379'))\n    redis_db = int(os.getenv('REDIS_DB', '0'))\n    redis_password = os.getenv('REDIS_PASSWORD')\n\n    return await aioredis.from_url(\n        f\"redis://{redis_host}:{redis_port}\",\n        db=redis_db,\n        password=redis_password,\n        encoding=\"utf-8\",\n        decode_responses=True,\n    )\n\n\nasync def shutdown_redis_pool(redis: aioredis.Redis):\n    \"\"\"Shutdown redis pool.\n\n    Args:\n        redis (aioredis.Redis): Redis pool instance.\n    \"\"\"\n    await redis.close()\n\n```\n\n----------------------------------------\n\nTITLE: Handling Asynchronous Injections in Python Providers\nDESCRIPTION: This snippet demonstrates how Python providers switch into async mode when they have awaitable dependencies, how they run multiple dependencies concurrently, and how injections are prepared asynchronously. It includes code comments and examples showing the behavior in different scenarios.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/async.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/async.py\n   :language: python\n   :emphasize-lines: 26-29\n   :lines: 3-\n```\n\n----------------------------------------\n\nTITLE: Using String Identifiers for Dependency Injection with Provide Marker in Python\nDESCRIPTION: Shows wiring injections via string identifiers matching provider names in the container rather than direct container references. Supports nested containers with dot notation separators. Injection modifiers such as as_int(), as_float(), as_(), required(), invariant(), and provided() can be used to modify or validate the injected values. Also demonstrates special injection of the container instance using the \"<container>\" identifier. This approach reduces coupling with container classes and can simplify injection in some cases.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@inject\ndef foo(service: UserService = Provide[\"services.user\"]) -> None:\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.wiring import (\n    inject,\n    Provide,\n    as_int,\n    as_float,\n    as_,\n    required,\n    invariant,\n    provided,\n)\n\n\n@inject\ndef foo(value: int = Provide[\"config.option\", as_int()]) -> None:\n    ...\n\n\n@inject\ndef foo(value: float = Provide[\"config.option\", as_float()]) -> None:\n    ...\n\n\n@inject\ndef foo(value: Decimal = Provide[\"config.option\", as_(Decimal)]) -> None:\n    ...\n\n@inject\ndef foo(value: str = Provide[\"config.option\", required()]) -> None:\n    ...\n\n@inject\ndef foo(value: int = Provide[\"config.option\", required().as_int()]) -> None:\n    ...\n\n\n@inject\ndef foo(value: int = Provide[\"config.option\", invariant(\"config.switch\")]) -> None:\n    ...\n\n@inject\ndef foo(value: int = Provide[\"service\", provided().foo[\"bar\"].call()]) -> None:\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@inject\ndef foo(container: Container = Provide[\"<container>\"]) -> None:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Test Setup with Provider Overriding in Python\nDESCRIPTION: Configures tests to override specific dependencies, such as the GitHub client, with mocks using Provider overriding capabilities. This setup allows testing route handlers and business logic in isolation from external services.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/flask-blueprints.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Content of githubnavigator/tests.py\n# Overrides dependencies with mocks for testing\nfrom dependency_injector import providers\nfrom githubnavigator.containers import Container\n\ndef test_search_repos(monkeypatch):\n    container = Container()\n    mock_github_client = mock.MagicMock()\n    mock_github_client.search_repositories.return_value = [{'name': 'mock-repo'}]\n    container.github_service.override(providers.Singleton(lambda: mock_github_client))\n    # Additional test setup and assertions\n\n```\n\n----------------------------------------\n\nTITLE: Traditional Dependency Implementation in Python\nDESCRIPTION: Shows how dependencies are traditionally implemented in Python with tight coupling. The ApiClient fetches configuration from environment variables, the Service directly creates ApiClient, and the main function creates Service.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/di_in_python.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\n\nclass ApiClient:\n\n    def __init__(self) -> None:\n        self.api_key = os.getenv(\"API_KEY\")  # <-- dependency\n        self.timeout = int(os.getenv(\"TIMEOUT\"))  # <-- dependency\n\n\nclass Service:\n\n    def __init__(self) -> None:\n        self.api_client = ApiClient()  # <-- dependency\n\n\ndef main() -> None:\n    service = Service()  # <-- dependency\n    ...\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Creating FastAPI Application with Dependency Injection Wiring in Python\nDESCRIPTION: Sets up the FastAPI application in `application.py`. It initializes the `Container`, wires it to the relevant modules (`__name__`), creates a `FastAPI` instance, and adds event handlers to initialize and shut down the Redis pool resource during application startup and shutdown. An endpoint `/` is defined, using the `@inject` decorator to receive an instance of `Service` provided by the container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n\"Application module.\"\n\nfrom fastapi import FastAPI, Depends\n\nfrom dependency_injector.wiring import inject, Provide\n\nfrom .containers import Container\nfrom .services import Service\n\n\n@inject\ndef main(service: Service = Depends(Provide[Container.service])) -> dict:\n    \"\"\"Main endpoint handler.\n\n    Args:\n        service (Service): Injected service dependency.\n\n    Returns:\n        dict: Response data.\n    \"\"\"\n    # value = await service.process()\n    # return {'value': value}\n    return {}\n\n\ndef create_app() -> FastAPI:\n    \"\"\"Create FastAPI application.\n\n    Returns:\n        FastAPI: Application instance.\n    \"\"\"\n    container = Container()\n    container.wire(modules=[__name__])\n\n    app = FastAPI()\n    app.container = container\n    app.add_event_handler(\"startup\", container.redis_pool.init)\n    app.add_event_handler(\"shutdown\", container.redis_pool.shutdown)\n    app.add_api_route(\"/\", main)\n    return app\n\n\napp = create_app()\n\n```\n\n----------------------------------------\n\nTITLE: Using the Singleton Provider in Python for Dependency Injection\nDESCRIPTION: This snippet demonstrates the basic usage of the `Singleton` provider in Python's dependency_injector framework. The provider ensures a single instance of an object is created and reused, if dependencies are injected during object creation. It also explains the scope being tied to the container, not global, and how specialization and abstract singletons work similarly to factories.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport dependency_injector.providers\n\n# Creating singleton provider instance\nsingleton_provider = dependency_injector.providers.Singleton(SomeClass)\n\n# Using singleton provider in a container\ncontainer = dependency_injector.containers.Container()\ncontainer.service = singleton_provider\n\n# Accessing singleton instance\nservice_instance = container.service()\n\n# Resetting singleton object if needed\nsingleton_provider.reset()\n```\n\n----------------------------------------\n\nTITLE: Context-managed Provider Overrides in Python DeclarativeContainer\nDESCRIPTION: This snippet explains using the override_providers() method as a context manager to temporarily override container providers. Providers are substituted within the with-block for testing or runtime flexibility, and the original providers are automatically restored after the block exits, ensuring isolation of overrides.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\n\nwith container.override_providers(foo=mock.Mock(Foo), bar=mock.Mock(Bar)):\n    assert isinstance(container.foo(), mock.Mock)\n    assert isinstance(container.bar(), mock.Mock)\n\nassert isinstance(container.foo(), Foo)\nassert isinstance(container.bar(), Bar)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Injector Container for User Services and Database in Python\nDESCRIPTION: Defines a declarative Dependency Injector container that wires user service, user repository, and database utility components together. This container centralizes dependency management, allowing configured components to be injected cleanly across the application’s various modules.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/containers.py showing container setup and component wiring\n```\n\n----------------------------------------\n\nTITLE: Using Wiring Markers (Provide and Provider) for Dependency Injection in Python\nDESCRIPTION: Demonstrates use of wiring markers Provide and Provider to specify injections as default argument values. Provide is typically used to inject instances produced by container providers, while Provider (or Provide with '.provider') can be used to inject the provider itself for manual instantiation. Examples show how to inject factory providers or configuration values with type annotations or without. Dependencies include dependency_injector.providers and dependency_injector.wiring modules.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.providers import Factory\nfrom dependency_injector.wiring import inject, Provide\n\n@inject\ndef foo(bar_provider: Factory[Bar] = Provide[Container.bar.provider]):\n    bar = bar_provider(argument=\"baz\")\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.providers import Factory\nfrom dependency_injector.wiring import inject, Provider\n\n@inject\ndef foo(bar_provider: Factory[Bar] = Provider[Container.bar]):\n    bar = bar_provider(argument=\"baz\")\n    ...\n```\n\nLANGUAGE: python\nCODE:\n```\n@inject\ndef foo(token: str = Provide[Container.config.api_token]):\n    ...\n\n@inject\ndef foo(timeout: int = Provide[Container.config.timeout.as_(int)]):\n    ...\n\n@inject\ndef foo(baz: Baz = Provide[Container.bar.provided.baz]):\n    ...\n\n@inject\ndef foo(bar: Bar = Provide[Container.subcontainer.bar]):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining FastAPI Endpoints with Injected Services in Python\nDESCRIPTION: Implements example API endpoints in the FastAPI framework which depend on a user service injected through Dependency Injector's wiring feature. This module declares routes and leverages dependency injection to decouple endpoint logic from service instantiation, enabling cleaner code and easier testing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/endpoints.py demonstrating user-related API endpoints and dependency injection\n```\n\n----------------------------------------\n\nTITLE: Wiring Dynamically Imported Modules in Python\nDESCRIPTION: Demonstrates how to use an import hook to automatically wire containers to dynamically imported modules.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport importlib\n\nfrom dependency_injector.wiring import register_loader_containers\n\nfrom .containers import Container\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    register_loader_containers(container)  # <--- installs import hook\n\n    module = importlib.import_module(\"package.module\")\n    module.foo()\n```\n\n----------------------------------------\n\nTITLE: Initializing FastAPI Application Factory Using Python\nDESCRIPTION: Defines an application factory function that sets up the Dependency Injector container, wires it with endpoint modules, creates a FastAPI application instance, configures routes, and initializes the database if it does not exist. It serves as the entry point for creating a fully configured web application respecting dependency injection principles.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/application.py (application factory implementation)\n```\n\n----------------------------------------\n\nTITLE: Configuring Container Providers for API Client - Python\nDESCRIPTION: Enhances the Dependency Injector container by registering configuration and factory providers for the GiphyClient. The Configuration provider loads settings from a YAML file, while the Factory provider instantiates GiphyClient with API key and timeout parameters from the configuration. This setup enables decoupled, flexible dependency management. Requires dependency-injector and a valid config.yml.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import giphy\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    giphy_client = providers.Factory(\n        giphy.GiphyClient,\n        api_key=config.giphy.api_key,\n        timeout=config.giphy.request_timeout,\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Injector Container for Services - Python\nDESCRIPTION: Defines a `dependency_injector.containers.DeclarativeContainer` class named `Container`. It configures a `Configuration` provider to load settings, a `Singleton` provider for the `GiphyClient` (dependent on configuration), and a `Factory` provider for the `SearchService` (dependent on the Giphy client). This centralizes dependency management for the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Code included from ../../examples/miniapps/fastapi/giphynavigator/containers.py\n```\n\n----------------------------------------\n\nTITLE: Defining the Index Handler with aiohttp - Python\nDESCRIPTION: This handler function processes incoming GET requests to the root endpoint. It extracts the 'query' and 'limit' parameters from the request, defaults these if unspecified, and returns a JSON response that includes the query, limit, and an empty list of GIFs. Dependencies include aiohttp.web. Expected input parameters are optional 'query' and 'limit' in the request URL. The handler currently returns a placeholder response with no GIF URLs.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Handlers module.\"\"\"\n\nfrom aiohttp import web\n\n\nasync def index(request: web.Request) -> web.Response:\n    query = request.query.get(\"query\", \"Dependency Injector\")\n    limit = int(request.query.get(\"limit\", 10))\n\n    gifs = []\n\n    return web.json_response(\n        {\n            \"query\": query,\n            \"limit\": limit,\n            \"gifs\": gifs,\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from Pydantic BaseSettings Object Using Dependency Injector in Python\nDESCRIPTION: Shows how to load configuration from a pydantic_settings.BaseSettings object via the from_pydantic method. The Configuration provider calls the model_dump() method of the Pydantic settings object, with optional keyword arguments to customize behavior (e.g., exclude fields). Configuration can also be loaded automatically by passing Pydantic settings instances upon provider declaration. Pydantic-settings or dependency-injector[pydantic2] package required for this functionality. Both Pydantic v1 and v2 are supported for backward compatibility.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.from_pydantic(Settings(), exclude={\"optional\"})\n```\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(pydantic_settings=[Settings()])\n\n\nif __name__ == \"__main__\":\n    container = Container()  # Config is loaded from Settings()\n```\n\n----------------------------------------\n\nTITLE: Implementing Dependency Injection in Python\nDESCRIPTION: Demonstrates how to implement dependency injection by modifying classes to accept dependencies as constructor arguments rather than creating them internally, decoupling components and improving testability.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/di_in_python.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os\n\n\nclass ApiClient:\n\n    def __init__(self, api_key: str, timeout: int) -> None:\n        self.api_key = api_key  # <-- dependency is injected\n        self.timeout = timeout  # <-- dependency is injected\n\n\nclass Service:\n\n    def __init__(self, api_client: ApiClient) -> None:\n        self.api_client = api_client  # <-- dependency is injected\n\n\ndef main(service: Service) -> None:  # <-- dependency is injected\n    ...\n\n\nif __name__ == \"__main__\":\n    main(\n        service=Service(\n            api_client=ApiClient(\n                api_key=os.getenv(\"API_KEY\"),\n                timeout=int(os.getenv(\"TIMEOUT\")),\n            ),\n        ),\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Multiple Containers in Python Dependency Injector\nDESCRIPTION: Defines multiple declarative containers for a Python application using Dependency Injector. Includes a main container and packages container that wire together various dependencies including database and AWS S3 clients.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-multiple-containers.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n../../examples/miniapps/application-multiple-containers/example/containers.py\n```\n\n----------------------------------------\n\nTITLE: Performing Dependency Injection in DeclarativeContainer in Python\nDESCRIPTION: This snippet shows how to inject dependencies by defining providers within the declarative container. Users create container instances and obtain dependencies by calling provider attributes, supporting automatic injection patterns typical in dependency injection frameworks.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\nfoo = container.foo()\nbar = container.bar()\n```\n\n----------------------------------------\n\nTITLE: Defining User Repository for Data Access Using SQLAlchemy in Python\nDESCRIPTION: Implements user data access operations via SQLAlchemy ORM in a repository class. This module abstracts database interactions for the user model, providing query and modification methods to the user service layer.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/repositories.py implementing user repository methods\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Container and Providers in Python\nDESCRIPTION: This Python code defines the dependency-injector container using `DeclarativeContainer`. It includes providers for loading configuration from a YAML file and factory providers for creating instances of `GiphyClient` and `SearchService`, injecting dependencies where needed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import giphy, services\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    giphy_client = providers.Factory(\n        giphy.GiphyClient,\n        api_key=config.giphy.api_key,\n        timeout=config.giphy.request_timeout,\n    )\n\n    search_service = providers.Factory(\n        services.SearchService,\n        giphy_client=giphy_client,\n    )\n```\n\n----------------------------------------\n\nTITLE: Application Factory in Python for Flask with Dependency Injection\nDESCRIPTION: Creates and configures the Flask application, initializes the dependency injection container, applies wiring for blueprints, and sets up routes. This function ensures all dependencies are wired correctly before running the app, enabling modular and testable architecture.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/flask-blueprints.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Content of githubnavigator/application.py\n# Creates Flask app, sets up dependency container, wiring, and routes\nfrom flask import Flask\nfrom dependency_injector.wiring import inject, Provide\nfrom githubnavigator.containers import Container\nfrom githubnavigator.blueprints.example import example_bp\n\ndef create_app() -> Flask:\n    container = Container()\n    container.config.from_yaml('config.yml')\n    app = Flask(__name__)\n    # Wiring dependencies to blueprints\n    container.wire(modules=[__name__, 'githubnavigator.blueprints'])\n    # Register blueprints\n    app.register_blueprint(example_bp)\n    return app\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Aiohttp App and Dependency Container in Python\nDESCRIPTION: This Python function creates an aiohttp web application and initializes the dependency-injector container. It demonstrates loading the Giphy API key from the 'GIPHY_API_KEY' environment variable and adding application routes.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom aiohttp import web\n\nfrom .containers import Container\nfrom . import handlers\n\n\ndef create_app() -> web.Application:\n    container = Container()\n    container.config.giphy.api_key.from_env(\"GIPHY_API_KEY\")\n\n    app = web.Application()\n    app.container = container\n    app.add_routes([\n        web.get(\"/\", handlers.index),\n    ])\n    return app\n\n\nif __name__ == \"__main__\":\n    app = create_app()\n    web.run_app(app)\n```\n\n----------------------------------------\n\nTITLE: Overriding Dependency Injector Providers at Runtime in Python\nDESCRIPTION: Demonstrates how to override providers in a Dependency Injector container using another container instance at runtime. This approach is useful for replacing service implementations during testing or reconfiguring dependencies for different environments. Providers in the overriding container replace those with the same names in the original container. Requires the dependency_injector package. Inputs are two containers, and outputs are the overridden container state. Limitations include the necessity for provider names to match for successful overriding.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/overriding.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass ApiClient:\n    ...\n\nclass StubApiClient:\n    ...\n\nclass Container(containers.DeclarativeContainer):\n    api_client = providers.Singleton(ApiClient)\n\nclass TestContainer(containers.DeclarativeContainer):\n    api_client = providers.Singleton(StubApiClient)\n\ncontainer = Container()\ntest_container = TestContainer()\ncontainer.override(test_container)\ncontainer.api_client()  # returns instance of StubApiClient\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Decorators with Dependency Injection Using @inject in Python\nDESCRIPTION: Defines two example custom decorators that wrap functions and inject dependencies using the @inject decorator inside the wrapper function. Each decorator extracts injected configuration values using Provide and adds these to the decorated function's result. This pattern allows combining arbitrary decorators with dependency-injector wiring by placing @inject inside the inner wrapper, ensuring proper dependency injection. Requires functools and dependency-injector wiring module.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef decorator1(func):\n    @functools.wraps(func)\n    @inject\n    def wrapper(value1: int = Provide[Container.config.value1]):\n        result = func()\n        return result + value1\n    return wrapper\n\n\ndef decorator2(func):\n    @functools.wraps(func)\n    @inject\n    def wrapper(value2: int = Provide[Container.config.value2]):\n        result = func()\n        return result + value2\n    return wrapper\n\n@decorator1\n@decorator2\ndef sample():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Injection Container in Python\nDESCRIPTION: This Python code defines a declarative container using `dependency_injector.containers` and `dependency_injector.providers`. It sets up providers for configuration from a YAML file, an HTTP client session, the Giphy API client, and the search service, making them available for injection throughout the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/aiohttp.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nimport logging.config\n\nimport aiohttp\nfrom dependency_injector import containers, providers\n\nfrom . import giphy, services\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    logging = providers.Resource(\n        logging.config.dictConfig,\n        config=config.logging,\n    )\n\n    http_client = providers.Factory(\n        aiohttp.ClientSession,\n    )\n\n    giphy_client = providers.Factory(\n        giphy.GiphyClient,\n        api_key=config.giphy.api_key,\n        http_client=http_client,\n    )\n\n    search_service = providers.Factory(\n        services.SearchService,\n        giphy_client=giphy_client,\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Overriding GiphyClient Dependency in aiohttp Application Test (Python)\nDESCRIPTION: This snippet shows how to override the GiphyClient dependency within the application container during testing. It performs an asynchronous GET request to the root endpoint, then asserts the response status code and specific fields in the JSON response, verifying the correct behavior when dependencies are mocked.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_20\n\nLANGUAGE: Python\nCODE:\n```\n    with app.container.giphy_client.override(giphy_client_mock):\n        response = await client.get(\"/\")\n\n    assert response.status == 200\n    data = await response.json()\n    assert data[\"query\"] == app.container.config.default.query()\n    assert data[\"limit\"] == app.container.config.default.limit()\n```\n\n----------------------------------------\n\nTITLE: Accessing All Aggregated Providers as Dictionary in Python\nDESCRIPTION: Shows how to retrieve a dictionary of all aggregated providers using the .providers attribute, which returns a mapping of keys to their corresponding provider instances.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/aggregate.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config_readers.providers == {\n    \"yaml\": <YAML provider>,\n    \"json\": <JSON provider>,\n}\n```\n\n----------------------------------------\n\nTITLE: Resetting Singletons in Python Dependency Injector Containers\nDESCRIPTION: This snippet demonstrates how to use the .reset_singletons() method to reset all singleton instances within a container. It highlights the direct invocation of .reset_singletons() to clear singletons so that newly requested instances are created instead of cached ones. The snippet requires the Dependency Injector package and a container with singleton providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/reset_singletons.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    service = providers.Singleton(object)\n\ncontainer = Container()\ncontainer.service()\ncontainer.reset_singletons()  # Resets all singletons\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Interpolation in Configuration Files\nDESCRIPTION: Explains syntax and usage for interpolating environment variables within configuration files via the Configuration provider. Variables are represented as ${ENV_NAME} or with defaults as ${ENV_NAME:default}, enabling dynamic substitution during configuration loading. This feature supports INI, YAML, and JSON configuration formats.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_12\n\nLANGUAGE: ini\nCODE:\n```\nsection:\n  option: ${ENV_NAME}\n```\n\nLANGUAGE: ini\nCODE:\n```\n[section]\noption = ${ENV_NAME:default}\n```\n\n----------------------------------------\n\nTITLE: Using Dependency Injector with Boto3 AWS Clients in Python\nDESCRIPTION: This snippet demonstrates leveraging the Dependency Injector framework to manage and inject Boto3 AWS clients, such as S3, SQS, Route53, EC2, and Lambda, in a structured, testable way. It requires the 'boto3' library and 'Dependency Injector' package, and provides modular dependency configurations for AWS services, promoting clean and maintainable code.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/boto3.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport boto3\nfrom dependency_injector import containers, providers\n\nclass AwsClients(containers.DeclarativeContainer):\n    s3_client = providers.Singleton(boto3.client, 's3')\n    sqs_client = providers.Singleton(boto3.client, 'sqs')\n    route53_client = providers.Singleton(boto3.client, 'route53')\n    ec2_client = providers.Singleton(boto3.client, 'ec2')\n    lambda_client = providers.Singleton(boto3.client, 'lambda')\n\n# Usage example:\nif __name__ == '__main__':\n    container = AwsClients()\n    s3 = container.s3_client()\n    # Perform operations with the s3 client, e.g., list buckets\n    buckets = s3.list_buckets()\n    print(buckets)\n```\n\n----------------------------------------\n\nTITLE: Implementing Handlers with Dependency Injection in Python\nDESCRIPTION: Contains HTTP request handlers in handlers.py that depend on the search service and configuration options. Dependencies are injected using the wiring feature of Dependency Injector, enabling decoupled business logic from framework and infrastructure code. Handlers process REST API requests for searching GIFs and returning JSON responses. The snippet depends on the container's configured providers and Sanic routing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/sanic.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nProvided externally in handlers.py via literalinclude directive.\n```\n\n----------------------------------------\n\nTITLE: Creating Flask Application Factory with Container Configuration\nDESCRIPTION: Defines the create_app function that initializes the Flask application, sets up the container, configures GitHub authentication from environment variables, and registers routes.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom flask import Flask\nfrom flask_bootstrap import Bootstrap\n\nfrom .containers import Container\nfrom . import views\n\n\ndef create_app() -> Flask:\n    container = Container()\n    container.config.github.auth_token.from_env(\"GITHUB_TOKEN\")\n\n    app = Flask(__name__)\n    app.container = container\n    app.add_url_rule(\"/\", \"index\", views.index)\n\n    bootstrap = Bootstrap()\n    bootstrap.init_app(app)\n\n    return app\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Injection Container for FastAPI-Redis App in Python\nDESCRIPTION: Defines a `DeclarativeContainer` named `Container` in `containers.py` using `dependency_injector`. It configures a `Resource` provider for the Redis pool, using the `init_redis_pool` function as an initializer and `shutdown_redis_pool` as a finalizer. It also defines a `Factory` provider for the `Service`, automatically injecting the `redis_pool` resource. The container specifies the modules (`.application`, `.endpoints`) where dependency injection wiring should be applied.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n\"Containers module.\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import redis, services\n\n\nclass Container(containers.DeclarativeContainer):\n    \"\"\"Container for dependency injection.\n\n    It wires together the dependencies for the application.\n    \"\"\"\n\n    config = providers.Configuration()\n\n    redis_pool = providers.Resource(\n        redis.init_redis_pool,\n    )\n\n    service = providers.Factory(\n        services.Service,\n        redis=redis_pool,\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Using ThreadLocalSingleton for Thread-Local Singleton in Python\nDESCRIPTION: This snippet describes the usage of `ThreadLocalSingleton` which manages separate singleton instances per thread using thread-locals, perfect for multi-threaded applications requiring thread-specific singletons. It involves declaration and usage within a container context.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndependency_injector.providers.ThreadLocalSingleton\n\nthread_local_singleton = dependency_injector.providers.ThreadLocalSingleton(SomeClass)\n\n# Use across different threads, each will have its own singleton instance\ncontainer = dependency_injector.containers.Container()\ncontainer.thread_local_service = thread_local_singleton\n```\n\n----------------------------------------\n\nTITLE: Example: Overriding Providers in Python\nDESCRIPTION: Demonstrates overriding providers using `Provider.override()` and context managers in the `dependency-injector` library. It shows replacing a provider's output with another provider or a specific value (mock/stub), useful for testing or adapting configurations for different environments.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/overriding.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport unittest\nimport sqlite3\nfrom dependency_injector import containers, providers\n\n\nclass ApiClient:\n    def __init__(self, api_key: str, timeout: int):\n        self.api_key = api_key\n        self.timeout = timeout\n\n    def get(self) -> dict:\n        # Imagine hitting a real API here\n        return {'data': f'api_key={self.api_key}, timeout={self.timeout}'}\n\n\nclass Service:\n    def __init__(self, api_client: ApiClient):\n        self.api_client = api_client\n\n    def process(self) -> dict:\n        return self.api_client.get()\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    api_client = providers.Singleton(\n        ApiClient,\n        api_key=config.api_key,\n        timeout=config.timeout,\n    )\n\n    service = providers.Factory(\n        Service,\n        api_client=api_client,\n    )\n\n\nif __name__ == '__main__':\n    container = Container()\n    container.config.from_dict({'api_key': 'some-real-key', 'timeout': 10})\n\n    # --- Overriding with another provider --- #\n\n    class StubApiClient(ApiClient):\n        def get(self) -> dict:\n            return {'data': 'stub'}\n\n    container.api_client.override(\n        providers.Singleton(StubApiClient, api_key='stub-key', timeout=1),\n    )\n\n    service = container.service()\n    data = service.process()\n    assert data == {'data': 'stub'}\n    assert isinstance(service.api_client, StubApiClient)\n    assert service.api_client.api_key == 'stub-key'\n    assert service.api_client.timeout == 1\n\n    # --- Overriding with a value --- #\n\n    class MockApiClient:\n        def get(self) -> dict:\n            return {'data': 'mock'}\n\n    container.api_client.override(MockApiClient())\n\n    service = container.service()\n    data = service.process()\n    assert data == {'data': 'mock'}\n    assert isinstance(service.api_client, MockApiClient)\n\n    # --- Context manager overriding --- #\n\n    class TestApiClient(ApiClient):\n        def get(self) -> dict:\n            return {'data': 'test'}\n\n    with container.api_client.override(TestApiClient('test-key', 0)):\n        service = container.service()\n        data = service.process()\n        assert data == {'data': 'test'}\n        assert isinstance(service.api_client, TestApiClient)\n\n    # --- Overriding is reset --- #\n\n    service = container.service()\n    data = service.process()\n    assert data == {'data': 'mock'}  # Previous non-context override is restored\n    assert isinstance(service.api_client, MockApiClient)\n\n    # --- Resetting the override --- #\n\n    container.api_client.reset_override()\n\n    service = container.service()\n    data = service.process()\n    assert data == {'data': 'api_key=some-real-key, timeout=10'} # Original provider\n    assert isinstance(service.api_client, ApiClient)\n    assert service.api_client.api_key == 'some-real-key'\n    assert service.api_client.timeout == 10\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers at Container Instantiation in Python Dependency Injector\nDESCRIPTION: This snippet illustrates overriding container providers by passing alternative implementations during container instance creation. It demonstrates modifying the provider behavior by specifying keyword arguments to substitute existing providers, allowing flexible testing or runtime modification without altering container code.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container(foo=mock.Mock(Foo), bar=mock.Mock(Bar))\n```\n\n----------------------------------------\n\nTITLE: Testing with Provider Overriding for Dependency Injection in Python\nDESCRIPTION: Provides test cases that demonstrate usage of Dependency Injector's provider-overriding feature to replace real repository implementations with mocks. This facilitates isolated testing of services and endpoints without accessing actual databases.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/tests.py highlighting provider overriding in tests at lines 25, 45, 58, 74, 86, and 97\n```\n\n----------------------------------------\n\nTITLE: Implementing Scoped Singleton using Reset on Demand in Python\nDESCRIPTION: This example illustrates how to implement scope control by resetting a singleton provider manually when needed, thereby creating a scoped singleton where each scope gets a fresh instance. It showcases how to reset the singleton during application runtime for controlled lifetime management.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport dependency_injector.providers\n\nservice_provider = dependency_injector.providers.Singleton(Service)\n\n# During a particular scope, reset the singleton to create a new instance\nservice_provider.reset()\n```\n\n----------------------------------------\n\nTITLE: Passing Arguments to Nested Underlying Factory Providers (Python)\nDESCRIPTION: This snippet exemplifies passing arguments down a nested factory chain using the double-underscore (__) convention in keyword arguments. It allows for selectively targeting arguments to specific underlying providers within an object graph. It depends on Python and dependency_injector, with the nested providers constructed via Factory for each layer and accepts arguments like dependency__arg=value. Limitation: argument delegation only works through the prescribed __ syntax.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_init_injections_underlying.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 44,49\n\n```\n\n----------------------------------------\n\nTITLE: Creating FastAPI Application Instance and Wiring - Python\nDESCRIPTION: Provides a factory function (`create_app`) responsible for initializing and configuring the FastAPI application. This involves setting up the Dependency Injector container, loading configuration (e.g., from a YAML file), wiring the container to the endpoints module to enable dependency injection, creating the `FastAPI` app instance, and registering the defined API routes.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Code included from ../../examples/miniapps/fastapi/giphynavigator/application.py\n```\n\n----------------------------------------\n\nTITLE: Injecting Container Self using Self Provider in Python\nDESCRIPTION: Demonstrates defining a container (`Container`) using `dependency_injector.containers.DeclarativeContainer`. It defines a `Self` provider, named `__self__` using `dependency_injector.providers.Self()`. This `__self__` provider is then injected as the `container` argument into the `Service` factory provider (`providers.Factory`), allowing the `Service` instance to access its parent container. Line 20 (`container=__self__,`) shows the direct injection point. Line 26 (`container=self.__self__,`) shows an alternative attribute reference (commented out in the example). The `Self` provider itself is not listed in `container.providers`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/inject_self.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\n\nclass Service:\n    def __init__(self, container):\n        self.container = container\n\n\nclass Container(containers.DeclarativeContainer):\n\n    # Define the Self provider. Container can have only one Self provider.\n    # Usually you will use name ``__self__``.\n    # You can also use different name. When you use different name container\n    # will also reference defined ``Self`` provider in ``.__self__`` attribute.\n    # Provider ``Self`` is not listed in container ``.providers`` attributes.\n    __self__ = providers.Self()\n\n    # Another name also works:\n    # _self_ = providers.Self()\n\n    service = providers.Factory(\n        Service,\n        container=__self__,  # <-- Inject container \"self\"\n    )\n\n    # You can also use reference via attribute:\n    # service = providers.Factory(\n    #     Service,\n    #     container=self.__self__,  # <-- Inject container \"self\" via attribute reference\n    # )\n\n\nif __name__ == '__main__':\n    container = Container()\n\n    service_instance = container.service()\n\n    assert isinstance(service_instance, Service)\n    assert service_instance.container is container\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Injections in Python\nDESCRIPTION: Demonstrates how to use asynchronous injections with the wiring feature, including resource providers that need initialization.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    db = providers.Resource(init_async_db_client)\n\n    cache = providers.Resource(init_async_cache_client)\n\n\n@inject\nasync def main(\n    db: Database = Provide[Container.db],\n    cache: Cache = Provide[Container.cache],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing FastAPI Endpoints with Injected Services - Python\nDESCRIPTION: Contains FastAPI route definitions (likely using `@app.get()` decorators). It demonstrates using `Dependency Injector`'s wiring mechanism (`@containers.Container.wiring(...)`) to automatically inject the `SearchService` dependency into endpoint functions. It also shows how default values for query parameters can be related to application configuration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Code included from ../../examples/miniapps/fastapi/giphynavigator/endpoints.py\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Resources with Async and Sync Initializers in Python\nDESCRIPTION: Shows how to initialize and shutdown multiple resources (both synchronous and asynchronous) in a container. The container methods must be awaited if at least one resource is asynchronous.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\n\nclass Container(containers.DeclarativeContainer):\n\n    connection1 = providers.Resource(init_async_connection)\n\n    connection2 = providers.Resource(init_sync_connection)\n\n\nasync def main():\n    container = Container()\n    await container.init_resources()\n    await container.shutdown_resources()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Defining Main Application Container in Python\nDESCRIPTION: Defines the main application container responsible for wiring all components together. It reads configuration, initializes 3rd party clients (like database and S3), instantiates package containers (`UserContainer`, `PhotoContainer`, `AnalyticsContainer`), and injects the required dependencies (clients, repositories) into the respective package containers using provider overrides.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Content of example/containers.py\n# Defines the ApplicationContainer, responsible for initializing external resources\n# (db, s3 based on config) and wiring package containers together.\n\nimport sqlite3\nimport boto3\n\nfrom dependency_injector import containers, providers\n\nfrom .analytics.containers import AnalyticsContainer\nfrom .photo.containers import PhotoContainer\nfrom .user.containers import UserContainer\n\n\nclass ApplicationContainer(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    # Gateways\n    database_client = providers.Singleton(\n        sqlite3.connect,\n        config.database.dsn,\n    )\n\n    s3_client = providers.Singleton(\n        boto3.client,\n        service_name='s3',\n        aws_access_key_id=config.aws.access_key_id,\n        aws_secret_access_key=config.aws.secret_access_key,\n    )\n\n    # Packages\n    user_package = providers.Container(\n        UserContainer,\n        db=database_client,\n    )\n\n    photo_package = providers.Container(\n        PhotoContainer,\n        db=database_client,\n        s3=s3_client,\n    )\n\n    analytics_package = providers.Container(\n        AnalyticsContainer,\n        user_repository=user_package.repository,\n        photo_repository=photo_package.repository,\n    )\n```\n\n----------------------------------------\n\nTITLE: Testing with Provider Overriding in Django\nDESCRIPTION: Test snippets in 'web/tests.py' demonstrate how to override providers, replacing real clients with mocks to facilitate isolated testing. The code employs provider overriding features to inject mock dependencies, ensuring tests are deterministic and independent of external services.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/django.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: ../../examples/miniapps/django/web/tests.py\n   :language: python\n   :emphasize-lines: 39,60\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Flask View Function\nDESCRIPTION: Updates the index view function to use dependency injection for obtaining the SearchService instance. This demonstrates how to use the Dependency Injector's wiring feature in a Flask application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Views module.\"\"\"\n\nfrom flask import request, render_template\nfrom dependency_injector.wiring import inject, Provide\n\nfrom .services import SearchService\nfrom .containers import Container\n\n\n@inject\ndef index(search_service: SearchService = Provide[Container.search_service]):\n    query = request.args.get(\"query\", \"Dependency Injector\")\n    limit = request.args.get(\"limit\", 10, int)\n\n    repositories = search_service.search_repositories(query, limit)\n\n    return render_template(\n        \"index.html\",\n        query=query,\n        limit=limit,\n        repositories=repositories,\n    )\n```\n\n----------------------------------------\n\nTITLE: Testing Aiohttp Application with Dependency Overriding in Python\nDESCRIPTION: This Python code showcases asynchronous unit tests for the Aiohttp application using `unittest` and `aiohttp.test_utils`. It demonstrates how to use the `override` context manager from the dependency container (`app.container`) to replace the actual `giphy_client` provider with a mock object (`AsyncMock`) during testing, allowing isolated testing of the handler logic.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/aiohttp.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Tests module.\"\"\"\n\nimport unittest\nfrom unittest.mock import AsyncMock, Mock, patch\n\nfrom aiohttp.test_utils import AioHTTPTestCase, unittest_run_loop\n\nfrom .application import create_app\nfrom .containers import Container\n\n\nclass ApplicationTestCase(AioHTTPTestCase):\n\n    async def get_application(self):\n        \"\"\"Retrieve web application in test mode.\"\"\"\n        return create_app()\n\n    @unittest_run_loop\n    async def test_index(self):\n        \"\"\"Test index page.\"\"\"\n        giphy_client_mock = AsyncMock()\n        giphy_client_mock.search.return_value = [{\"id\": 1}, {\"id\": 2}]\n\n        with self.app.container.giphy_client.override(giphy_client_mock):\n            response = await self.client.request(\"GET\", \"/\")\n\n        self.assertEqual(response.status, 200)\n\n        response_data = await response.json()\n        self.assertEqual(response_data, {\n            \"query\": \"cats\",\n            \"gifs\": [\n                {\"id\": 1},\n                {\"id\": 2},\n            ],\n        })\n\n        giphy_client_mock.search.assert_called_once_with(\"cats\", 3)\n\n    @unittest_run_loop\n    async def test_index_with_query(self):\n        \"\"\"Test index page with query.\"\"\"\n        giphy_client_mock = AsyncMock()\n        giphy_client_mock.search.return_value = [{\"id\": 1}]\n\n        with self.app.container.giphy_client.override(giphy_client_mock):\n            response = await self.client.request(\"GET\", \"/?query=dogs\")\n\n        self.assertEqual(response.status, 200)\n\n        response_data = await response.json()\n        self.assertEqual(response_data, {\n            \"query\": \"dogs\",\n            \"gifs\": [\n                {\"id\": 1},\n            ],\n        })\n\n        giphy_client_mock.search.assert_called_once_with(\"dogs\", 3)\n\n    def test_openapi_spec(self):\n        \"\"\"Test openapi spec availability.\"\"\"\n        self.assertTrue(self.app.container.config.giphy.api_key())\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n\n```\n\n----------------------------------------\n\nTITLE: Provider Delegation with .provider Attribute in dependency_injector (Python)\nDESCRIPTION: This snippet demonstrates injecting the provider instance itself instead of its result using the .provider attribute. This is used when an object requires access to a provider for later or conditional use, rather than a ready-made dependency. Requires Python and dependency_injector; .provider is available on all providers. The injected object has direct access to the provider for further operations.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_delegation.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 28\n\n```\n\n----------------------------------------\n\nTITLE: Creating Objects with Factory Provider in dependency_injector (Python)\nDESCRIPTION: This snippet demonstrates the initialization of a Factory provider with a class, factory function, or method. The Factory provider injects dependencies into the created object or callable. Dependencies can be other providers or literal values, and are injected every time a new object instance is created. Requires Python and the dependency_injector.providers module; accepts any class or function as the first argument, followed by dependencies as positional or keyword arguments.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory.py\n   :language: python\n   :lines: 3-\n\n```\n\n----------------------------------------\n\nTITLE: Creating Dependency Injector Container with GitHub API Client\nDESCRIPTION: Defines a container for dependency injection that includes a GitHub client configuration. The container uses Factory and Configuration providers to manage dependencies and application settings.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\nfrom github import Github\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    github_client = providers.Factory(\n        Github,\n        login_or_token=config.github.auth_token,\n        timeout=config.github.request_timeout,\n    )\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from Environment Variables Using Dependency Injector in Python\nDESCRIPTION: Shows how to load configuration options from environment variables using from_env method. Supports type casting via the as_ argument to convert string environment variables to desired types (str, float, int). Parameters include the environment variable name, type casting, default values, and whether the variable is required. This method ensures typesafety and allows default fallback values when environment variables are absent.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# API_KEY=secret\ncontainer.config.api_key.from_env(\"API_KEY\", as_=str, required=True)\nassert container.config.api_key() == \"secret\"\n\n# SAMPLING_RATIO=0.5\ncontainer.config.sampling.from_env(\"SAMPLING_RATIO\", as_=float, required=True)\nassert container.config.sampling() == 0.5\n\n# TIMEOUT undefined, default is used\ncontainer.config.timeout.from_env(\"TIMEOUT\", as_=int, default=5)\nassert container.config.timeout() == 5\n```\n\n----------------------------------------\n\nTITLE: Argument Passing and Priority in Chained Factories using Dependency Injector\nDESCRIPTION: This snippet demonstrates different strategies for passing arguments through nested Factory providers, highlighting how keyword arguments are propagated and how upper-level arguments can override lower-level ones. It also shows how context-provided arguments have the highest priority. These examples are useful for controlling argument precedence in complex factory chains.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/chained-factories.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n   # 1. Keyword arguments of upper level factory are added to lower level factory\n   chained_dict_factory = providers.Factory(\n       providers.Factory(dict, arg1=1),\n       arg2=2,\n   )\n   print(chained_dict_factory())  # prints: {\"arg1\": 1, \"arg2\": 2}\n\n   # 2. Keyword arguments of upper level factory have priority\n   chained_dict_factory = providers.Factory(\n       providers.Factory(dict, arg1=1),\n       arg1=2,\n   )\n   print(chained_dict_factory())  # prints: {\"arg1\": 2}\n\n   # 3. Keyword arguments provided from context have the most priority\n   chained_dict_factory = providers.Factory(\n       providers.Factory(dict, arg1=1),\n       arg1=2,\n   )\n   print(chained_dict_factory(arg1=3))  # prints: {\"arg1\": 3}\n```\n\n----------------------------------------\n\nTITLE: Defining a Dependency Injection Container in Python\nDESCRIPTION: Reference to the Python code in `example/containers.py`. This file defines a single declarative container using `dependency_injector`. It sets up providers for configuration (read from INI files), AWS Boto3 resources, a database connection, and application services, wiring them together.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Source: examples/miniapps/application-single-container/example/containers.py\n# Defines the dependency injection container using dependency_injector.\n# Configures providers for settings, AWS, database, and services.\n```\n\n----------------------------------------\n\nTITLE: Restricting Provider Types in DynamicContainer (Python)\nDESCRIPTION: Shows how to specialize a DynamicContainer by passing the `provider_type` argument during instantiation. This ensures that any provider assigned to the container later must be a subtype of the specified `ServiceProvider`. Assigning an incompatible provider (like `providers.Factory(dict)`) will raise an error.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/specialization.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# examples/containers/dynamic_provider_type.py\nimport abc\n\nfrom dependency_injector import containers, providers\n\n\n# Define an abstract base class for specific provider types\nclass ServiceProvider(providers.Provider):\n    __metaclass__ = abc.ABCMeta\n\n\n# Concrete provider types inheriting from the base\nclass SingletonServiceProvider(ServiceProvider, providers.Singleton):\n    pass\n\n\nclass FactoryServiceProvider(ServiceProvider, providers.Factory):\n    pass\n\n\n# Example service class\nclass Service:\n    pass\n\n\n# Dynamic container with provider type restriction via argument\ncontainer = containers.DynamicContainer(\n    provider_type=ServiceProvider,  # Enforce provider type\n)\n\ncontainer.provider1 = SingletonServiceProvider(Service)\ncontainer.provider2 = FactoryServiceProvider(Service)\n\n# The following assignment would cause a TypeError\n# container.other_provider = providers.Factory(dict)\n\n\n# --- Usage Example (not shown in original emphasis) ---\n# assert isinstance(container.provider1, SingletonServiceProvider)\n# assert isinstance(container.provider2, FactoryServiceProvider)\n```\n\n----------------------------------------\n\nTITLE: Using Non-String Keys or Special String Keys in Aggregate Provider\nDESCRIPTION: Demonstrates how to use non-string keys or string keys containing periods and dashes with an Aggregate provider by providing a dictionary as a positional argument.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/aggregate.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\naggregate = providers.Aggregate({\n    SomeClass: providers.Factory(...),\n    \"key.with.periods\": providers.Factory(...),\n    \"key-with-dashes\": providers.Factory(...),\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Injection Container in Python\nDESCRIPTION: The container setup defines providers and dependencies for the Django application, facilitating modular injection of services throughout the app. It is located in 'githubnavigator/containers.py' and uses Dependency Injector's container class. This setup enables declarative dependency injection, promoting testability and separation of concerns.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/django.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: ../../examples/miniapps/django/githubnavigator/containers.py\n   :language: python\n```\n\n----------------------------------------\n\nTITLE: Declaring Dependency Injection Container with Python\nDESCRIPTION: Defines a declarative container in the containers.py file leveraging Dependency Injector to manage application dependencies. This container configures service providers, configuration loading, and wiring to inject dependencies into modules such as handlers. Required dependencies include the Dependency Injector library. The container outputs service instances to be injected throughout the Sanic application, facilitating loose coupling and easier testing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/sanic.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nProvided externally in containers.py via literalinclude directive.\n```\n\n----------------------------------------\n\nTITLE: Overriding Async Providers with Non-Awaitable Results\nDESCRIPTION: This snippet illustrates how asynchronous providers are overridden by non-async providers, with the framework wrapping non-awaitable results into awaitables to maintain async behavior consistency during overrides. The code provides an example using the same include syntax with specific lines emphasized.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/async.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/async_overriding.py\n   :language: python\n   :emphasize-lines: 19-24\n   :lines: 3-\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies in Dependency Injector Container (Python)\nDESCRIPTION: This Python snippet demonstrates defining application component dependencies within a Dependency Injector container using `providers.Factory` and `providers.List`. It shows how an `HttpClient` is created as a factory, and two `HttpMonitor` instances depend on this factory and configuration options. A `Dispatcher` is then configured to receive a list of these monitor instances via `providers.List`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n           format=config.log.format,\n       )\n\n       http_client = providers.Factory(http.HttpClient)\n\n       example_monitor = providers.Factory(\n           monitors.HttpMonitor,\n           http_client=http_client,\n           options=config.monitors.example,\n       )\n\n       httpbin_monitor = providers.Factory(\n           monitors.HttpMonitor,\n           http_client=http_client,\n           options=config.monitors.httpbin,\n       )\n\n       dispatcher = providers.Factory(\n           dispatcher.Dispatcher,\n           monitors=providers.List(\n               example_monitor,\n               httpbin_monitor,\n           ),\n       )\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running Main with Dependency Injector in Python\nDESCRIPTION: Defines the main CLI application entrypoint using Dependency Injector's wiring capabilities. The code reads provider switch values from environment variables, sets up dependency injection wiring, and executes 'main()' which prints movies by director and year. Requires 'dependency_injector' and appropriate provider configuration. 'MOVIE_FINDER_TYPE' environment variable selects the storage type ('csv' or 'sqlite'); main expects configured containers, listers and finder providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Main module.\"\"\"\n\nfrom dependency_injector.wiring import Provide, inject\n\nfrom .listers import MovieLister\nfrom .containers import Container\n\n\n@inject\ndef main(lister: MovieLister = Provide[Container.lister]) -> None:\n    print(\"Francis Lawrence movies:\")\n    for movie in lister.movies_directed_by(\"Francis Lawrence\"):\n        print(\"\\t-\", movie)\n\n    print(\"2016 movies:\")\n    for movie in lister.movies_released_in(2016):\n        print(\"\\t-\", movie)\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.config.finder.type.from_env(\"MOVIE_FINDER_TYPE\")\n    container.wire(modules=[sys.modules[__name__]])\n\n    main()\n```\n\n----------------------------------------\n\nTITLE: Testing Daemon Components with Pytest and Mocks (Python)\nDESCRIPTION: This Python snippet contains unit tests for the monitoring daemon components using pytest and `unittest.mock`. It includes a dataclass for mocking HTTP requests, a pytest fixture to provide a Dependency Injector container configured with mock values, and two async test functions (`test_example_monitor` and `test_dispatcher`) that demonstrate overriding specific providers in the container with mock objects to isolate and test components.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nさんも\n\"\"\"Tests module.\"\"\"\n\nimport asyncio\nimport dataclasses\nfrom unittest import mock\n\nimport pytest\n\nfrom .containers import Container\n\n\n@dataclasses.dataclass\nclass RequestStub:\n    status: int\n    content_length: int\n\n\n@pytest.fixture\ndef container():\n    return Container(\n        config={\n            \"log\": {\n                \"level\": \"INFO\",\n                \"formant\": \"[%(asctime)s] [%(levelname)s] [%(name)s]: %(message)s\",\n            },\n            \"monitors\": {\n                \"example\": {\n                    \"method\": \"GET\",\n                    \"url\": \"http://fake-example.com\",\n                    \"timeout\": 1,\n                    \"check_every\": 1,\n                },\n                \"httpbin\": {\n                    \"method\": \"GET\",\n                    \"url\": \"https://fake-httpbin.org/get\",\n                    \"timeout\": 1,\n                    \"check_every\": 1,\n                },\n            },\n        }\n    )\n\n\n@pytest.mark.asyncio\nasync def test_example_monitor(container, caplog):\n    caplog.set_level(\"INFO\")\n\n    http_client_mock = mock.AsyncMock()\n    http_client_mock.request.return_value = RequestStub(\n        status=200,\n        content_length=635,\n    )\n\n    with container.http_client.override(http_client_mock):\n        example_monitor = container.example_monitor()\n        await example_monitor.check()\n\n    assert \"http://fake-example.com\" in caplog.text\n    assert \"response code: 200\" in caplog.text\n    assert \"content length: 635\" in caplog.text\n\n\n@pytest.mark.asyncio\nasync def test_dispatcher(container, caplog, event_loop):\n    caplog.set_level(\"INFO\")\n\n    example_monitor_mock = mock.AsyncMock()\n    httpbin_monitor_mock = mock.AsyncMock()\n\n    with container.override_providers(\n            example_monitor=example_monitor_mock,\n            httpbin_monitor=httpbin_monitor_mock,\n    ):\n        dispatcher = container.dispatcher()\n        event_loop.create_task(dispatcher.start())\n        await asyncio.sleep(0.1)\n        dispatcher.stop()\n\n    assert example_monitor_mock.check.called\n    assert httpbin_monitor_mock.check.called\n```\n\n----------------------------------------\n\nTITLE: Creating the aiohttp Application Factory - Python\nDESCRIPTION: This snippet initializes the aiohttp web application and configures routing and dependency injection. It sets up the container, registers the root endpoint with the index handler, and includes a main block to run the app. Prerequisites include aiohttp and dependency-injector, and it expects the handlers and container modules to be correctly implemented. The output is a running aiohttp server exposed on the configured port.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom aiohttp import web\n\nfrom .containers import Container\nfrom . import handlers\n\n\ndef create_app() -> web.Application:\n    container = Container()\n\n    app = web.Application()\n    app.container = container\n    app.add_routes([\n        web.get(\"/\", handlers.index),\n    ])\n    return app\n\n\nif __name__ == \"__main__\":\n    app = create_app()\n    web.run_app(app)\n```\n\n----------------------------------------\n\nTITLE: Specifying Mandatory Configuration Sources (Python)\nDESCRIPTION: Demonstrates how to mark various configuration sources (YAML file, INI file, dictionary, environment variable) as mandatory using the `required=True` argument in the `from_*` methods. This causes an error to be raised if the specified source does not exist or is undefined.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.from_yaml(\"config.yaml\", required=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.from_ini(\"config.ini\", required=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.from_dict(config_dict, required=True)\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.api_key.from_env(\"API_KEY\", required=True)\n```\n\n----------------------------------------\n\nTITLE: Providing Default Value for Dependency in Python Dependency Injector\nDESCRIPTION: This Python snippet shows how to supply a default value or provider to the Dependency provider using the default argument. If the default is a standard value, the Dependency provider wraps it in an Object provider. This example demonstrates both basic usage and how the provider resolves dependencies to the default when not otherwise overridden. It depends on dependency_injector.providers and works for any type that can be wrapped as an object.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/dependency.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    dependency = providers.Dependency(default=42)\n\ncontainer = Container()\nvalue = container.dependency()\nprint(value)  # Output: 42\n\n```\n\n----------------------------------------\n\nTITLE: Aggregating Factory Providers with Non-string Keys with FactoryAggregate (Python)\nDESCRIPTION: This snippet explains providing a dictionary to FactoryAggregate to support non-string or special string keys (such as keys containing . or -). It enhances flexibility in mapping classes or complex names to specific factories. Dependencies are as in the main FactoryAggregate usage; constraints include key uniqueness and support for various key types, with dictionary access required for non-standard keys.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_aggregate_non_string_keys.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 30-33,39-40\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating the Object Provider in Python\nDESCRIPTION: This Python example showcases the Object provider from the dependency_injector library. It demonstrates how to create an Object provider initialized with a specific object (e.g., sys.stdout) and retrieve that same object instance using the provider. It depends on the 'dependency_injector' library.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/object.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# example based on the description and literalinclude directive\n\nimport sys\nimport dependency_injector.providers as providers\n\n# The Object provider returns the provided object \"as is\"\nstdout_provider = providers.Object(sys.stdout)\n\n# Retrieving the object from the provider\nstdout_instance = stdout_provider()\n\n# Verifying that the retrieved instance is the original object\nassert stdout_instance is sys.stdout\n\nprint(f\"Successfully retrieved object: {stdout_instance}\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Automatic Wiring with DeclarativeContainer in Python\nDESCRIPTION: Shows how to define a wiring configuration in a container class to automatically wire modules and packages when the container is instantiated.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    wiring_config = containers.WiringConfiguration(\n        modules=[\n            \"yourapp.module1\",\n            \"yourapp.module2\",\n        ],\n        packages=[\n            \"yourapp.package1\",\n            \"yourapp.package2\",\n        ],\n    )\n\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()  # container.wire() is called automatically\n    ...\n```\n\n----------------------------------------\n\nTITLE: Writing Pytest Tests with Dependency Overriding - Python\nDESCRIPTION: This Python snippet contains `pytest` test code for the Flask application's views. It includes a fixture `app` to create and yield the Flask application instance, ensuring the Dependency Injector container is unwired afterwards. The test functions (`test_index`, `test_index_no_results`) demonstrate how to mock external dependencies (specifically the `Github` client) using `unittest.mock` and override the corresponding provider in the Dependency Injector container for testing purposes. Assertions check the response status code and content.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Tests module.\"\"\"\n\nfrom unittest import mock\n\nimport pytest\nfrom github import Github\nfrom flask import url_for\n\nfrom .application import create_app\n\n\n@pytest.fixture\ndef app():\n    app = create_app()\n    yield app\n    app.container.unwire()\n\n\ndef test_index(client, app):\n    github_client_mock = mock.Mock(spec=Github)\n    github_client_mock.search_repositories.return_value = [\n        mock.Mock(\n            html_url=\"repo1-url\",\n            name=\"repo1-name\",\n            owner=mock.Mock(\n                login=\"owner1-login\",\n                html_url=\"owner1-url\",\n                avatar_url=\"owner1-avatar-url\",\n            ),\n            get_commits=mock.Mock(return_value=[mock.Mock()]),\n        ),\n        mock.Mock(\n            html_url=\"repo2-url\",\n            name=\"repo2-name\",\n            owner=mock.Mock(\n                login=\"owner2-login\",\n                html_url=\"owner2-url\",\n                avatar_url=\"owner2-avatar-url\",\n            ),\n            get_commits=mock.Mock(return_value=[mock.Mock()]),\n        ),\n    ]\n\n    with app.container.github_client.override(github_client_mock):\n        response = client.get(url_for(\"index\"))\n\n    assert response.status_code == 200\n    assert b\"Results found: 2\" in response.data\n\n    assert b\"repo1-url\" in response.data\n    assert b\"repo1-name\" in response.data\n    assert b\"owner1-login\" in response.data\n    assert b\"owner1-url\" in response.data\n    assert b\"owner1-avatar-url\" in response.data\n\n    assert b\"repo2-url\" in response.data\n    assert b\"repo2-name\" in response.data\n    assert b\"owner2-login\" in response.data\n    assert b\"owner2-url\" in response.data\n    assert b\"owner2-avatar-url\" in response.data\n\n\ndef test_index_no_results(client, app):\n    github_client_mock = mock.Mock(spec=Github)\n    github_client_mock.search_repositories.return_value = []\n\n    with app.container.github_client.override(github_client_mock):\n        response = client.get(url_for(\"index\"))\n\n    assert response.status_code == 200\n    assert b\"Results found: 0\" in response.data\n```\n\n----------------------------------------\n\nTITLE: Defining Analytics Package Container in Python\nDESCRIPTION: Defines the container for the 'analytics' package using Dependency Injector. It declares dependencies on the `UserRepository` and `PhotoRepository` from other packages using `providers.Dependency`. It provides an `AnalyticsService` factory that utilizes these repositories, demonstrating inter-package dependency injection.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Content of example/analytics/containers.py\n# Defines the AnalyticsContainer, declaring dependencies on 'user_repository'\n# and 'photo_repository' from other packages, and providing an AnalyticsService factory.\n\nfrom dependency_injector import containers, providers\n\nfrom . import services\n\n\nclass AnalyticsContainer(containers.DeclarativeContainer):\n\n    user_repository = providers.Dependency()\n    photo_repository = providers.Dependency()\n\n    service = providers.Factory(\n        services.AnalyticsService,\n        user_repository=user_repository,\n        photo_repository=photo_repository,\n    )\n```\n\n----------------------------------------\n\nTITLE: Enhanced DI Container with Both Finders\nDESCRIPTION: Updates the Container class to support both CSV and SQLite finders, defaulting to the SQLite implementation.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import finders, listers, entities\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    movie = providers.Factory(entities.Movie)\n\n    csv_finder = providers.Singleton(\n        finders.CsvMovieFinder,\n        movie_factory=movie.provider,\n        path=config.finder.csv.path,\n        delimiter=config.finder.csv.delimiter,\n    )\n\n    sqlite_finder = providers.Singleton(\n        finders.SqliteMovieFinder,\n        movie_factory=movie.provider,\n        path=config.finder.sqlite.path,\n    )\n\n    lister = providers.Factory(\n        listers.MovieLister,\n        movie_finder=sqlite_finder,\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Creating Aiohttp Application Factory with Dependency Injection in Python\nDESCRIPTION: This Python code defines a `create_app` function that acts as an application factory. It initializes the dependency container, wires the container to the `handlers` module to enable automatic dependency injection, creates the `aiohttp.web.Application` instance, and sets up the routes, associating the `/` path with the `index` handler.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/aiohttp.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom aiohttp import web\n\nfrom . import handlers\nfrom .containers import Container\n\n\ndef create_app() -> web.Application:\n    container = Container()\n    container.wire(modules=[handlers])\n\n    app = web.Application()\n    app.container = container\n    app.add_routes([\n        web.get(\"/\", handlers.index),\n    ])\n    return app\n\n```\n\n----------------------------------------\n\nTITLE: Overriding Strict Mode Behavior with `required=False` (Python)\nDESCRIPTION: Shows how to load optional configuration files even when the Configuration provider is in strict mode by explicitly setting `required=False` in the `from_yaml` method call.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(strict=True)\n\n\nif __name__ == \"__main__\":\n    container = Container()\n\n    container.config.from_yaml(\"config.yml\")\n    container.config.from_yaml(\"config.local.yml\", required=False)\n```\n\n----------------------------------------\n\nTITLE: Resource Subclass without Return Value in Python\nDESCRIPTION: Demonstrates a resource subclass implementation that doesn't return a resource object. The shutdown method will still be called with None as the first argument.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import resources\n\n\nclass MyResource(resources.Resource):\n\n    def init(self, argument1=..., argument2=...) -> None:\n        # initialization\n        ...\n\n    def shutdown(self, _: None) -> None:\n        # shutdown\n        ...\n```\n\n----------------------------------------\n\nTITLE: Build Docker Image using Docker Compose\nDESCRIPTION: This command builds the Docker image for the application as defined in the `docker-compose.yml` file. It prepares the container environment needed to run the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose build\n```\n\n----------------------------------------\n\nTITLE: Implementing Aiohttp Handlers with Injected Dependencies in Python\nDESCRIPTION: This Python snippet demonstrates Aiohttp request handlers (`index`). Dependencies like the `SearchService` and configuration values (`results_per_page`) are injected into the handler functions using the `@inject` decorator and `Provide` markers from the `dependency_injector.wiring` module. The handler searches for GIFs based on a query parameter and renders a template.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/aiohttp.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Handlers module.\"\"\"\n\nfrom aiohttp import web\nfrom dependency_injector.wiring import inject, Provide\n\nfrom .containers import Container\nfrom .services import SearchService\n\n\n@inject\nasync def index(\n        request: web.Request,\n        search_service: SearchService = Provide[Container.search_service],\n        default_query: str = Provide[Container.config.default.query],\n        results_per_page: int = Provide[Container.config.default.results_per_page],\n) -> web.Response:\n    query = request.query.get(\"query\", default_query)\n    gifs = await search_service.search(query, results_per_page)\n    return web.json_response({\n        \"query\": query,\n        \"gifs\": gifs,\n    })\n\n```\n\n----------------------------------------\n\nTITLE: Implementing `HttpMonitor` for HTTP Availability Checks\nDESCRIPTION: Defines an `HttpMonitor` class inheriting from `Monitor`, utilizing `HttpClient` to send GET requests to specified URLs. It records response status, content length, and request duration, logging detailed info. The monitor is instantiated with options dicts containing HTTP method, URL, timeout, and check interval, supporting asynchronous health checks.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Monitors module.\"\"\"\n\nimport logging\nimport time\nfrom typing import Dict, Any\n\nfrom .http import HttpClient\n\n\nclass Monitor:\n\n    def __init__(self, check_every: int) -> None:\n        self.check_every = check_every\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    async def check(self) -> None:\n        raise NotImplementedError()\n\n\nclass HttpMonitor(Monitor):\n\n    def __init__(\n            self,\n            http_client: HttpClient,\n            options: Dict[str, Any],\n    ) -> None:\n        self._client = http_client\n        self._method = options.pop(\"method\")\n        self._url = options.pop(\"url\")\n        self._timeout = options.pop(\"timeout\")\n        super().__init__(check_every=options.pop(\"check_every\"))\n\n    async def check(self) -> None:\n        time_start = time.time()\n\n        response = await self._client.request(\n            method=self._method,\n            url=self._url,\n            timeout=self._timeout,\n        )\n\n        time_end = time.time()\n        time_took = time_end - time_start\n\n        self.logger.info(\n            \"Check\\n\"\n            \"    %s %s\\n\"\n            \"    response code: %s\\n\"\n            \"    content length: %s\\n\"\n            \"    request took: %s seconds\",\n            self._method,\n            self._url,\n            response.status,\n            response.content_length,\n            round(time_took, 3)\n        )\n```\n\n----------------------------------------\n\nTITLE: Adding SearchService to Container and Setting Up Wiring\nDESCRIPTION: Updates the container to include the SearchService and configures automatic wiring with the views module. This allows for dependency injection into the view functions.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\nfrom github import Github\n\nfrom . import services\n\n\nclass Container(containers.DeclarativeContainer):\n\n    wiring_config = containers.WiringConfiguration(modules=[\".views\"])\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    github_client = providers.Factory(\n        Github,\n        login_or_token=config.github.auth_token,\n        timeout=config.github.request_timeout,\n    )\n\n    search_service = providers.Factory(\n        services.SearchService,\n        github_client=github_client,\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Movie Finders with CSV and SQLite Support\nDESCRIPTION: Defines abstract MovieFinder interface and two concrete implementations: CsvMovieFinder and SqliteMovieFinder for different data sources.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Movie finders module.\"\"\"\n\nimport csv\nimport sqlite3\nfrom typing import Callable, List\n\nfrom .entities import Movie\n\n\nclass MovieFinder:\n\n    def __init__(self, movie_factory: Callable[..., Movie]) -> None:\n        self._movie_factory = movie_factory\n\n    def find_all(self) -> List[Movie]:\n        raise NotImplementedError()\n\n\nclass CsvMovieFinder(MovieFinder):\n\n    def __init__(\n            self,\n            movie_factory: Callable[..., Movie],\n            path: str,\n            delimiter: str,\n    ) -> None:\n        self._csv_file_path = path\n        self._delimiter = delimiter\n        super().__init__(movie_factory)\n\n    def find_all(self) -> List[Movie]:\n        with open(self._csv_file_path) as csv_file:\n            csv_reader = csv.reader(csv_file, delimiter=self._delimiter)\n            return [self._movie_factory(*row) for row in csv_reader]\n\n\nclass SqliteMovieFinder(MovieFinder):\n\n    def __init__(\n            self,\n            movie_factory: Callable[..., Movie],\n            path: str,\n    ) -> None:\n        self._database = sqlite3.connect(path)\n        super().__init__(movie_factory)\n\n    def find_all(self) -> List[Movie]:\n        with self._database as db:\n            rows = db.execute(\"SELECT title, year, director FROM movies\")\n            return [self._movie_factory(*row) for row in rows]\n\n```\n\n----------------------------------------\n\nTITLE: Example Test Execution and Coverage Output\nDESCRIPTION: Shows the expected console output when running the test command. This includes pytest status information (platform, plugins, number of tests collected and passed) followed by a detailed code coverage report table.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/README.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /code\nplugins: cov-6.0.0, anyio-4.7.0\ncollected 7 items\n\nwebapp/tests.py .......                                         [100%]\n\n---------- coverage: platform linux, python 3.10.0-final-0 ----------\nName                     Stmts   Miss  Cover\n--------------------------------------------\nwebapp/__init__.py           0      0   100%\nwebapp/application.py       12      0   100%\nwebapp/containers.py        10      0   100%\nwebapp/database.py          24      8    67%\nwebapp/endpoints.py         32      0   100%\nwebapp/models.py            10      1    90%\nwebapp/repositories.py      36     20    44%\nwebapp/services.py          16      0   100%\nwebapp/tests.py             59      0   100%\n--------------------------------------------\nTOTAL                      199     29    85%\n```\n\n----------------------------------------\n\nTITLE: Defining DeclarativeContainer with Providers in Python\nDESCRIPTION: This snippet illustrates how to create a declarative container class by subclassing DeclarativeContainer and defining providers as class attributes. This approach requires creating the container instance to access providers properly. It emphasizes that providers should not be accessed or modified on the class-level after instantiation to avoid affecting all container instances.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    foo = providers.Factory(Foo)\n    bar = providers.Singleton(Bar)\n```\n\n----------------------------------------\n\nTITLE: Specifying Configuration Value Types (Python)\nDESCRIPTION: Illustrates how to explicitly specify the data type of a configuration value using helper methods like `.as_int()` and `.as_float()`. This is particularly useful when reading values from INI files or environment variables which are typically strings.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_type.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 19\n```\n\n----------------------------------------\n\nTITLE: Resetting Singleton with Full Reset Method in Python\nDESCRIPTION: This snippet shows how to perform a full reset of the singleton, including dependent providers, using the `full_reset()` method. It supports the context manager pattern to automatically manage the reset within a defined scope.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwith container.service.full_reset():\n    # All dependent singleton objects are reset here\n    pass\n```\n\n----------------------------------------\n\nTITLE: Basic Resource Provider Implementation in Python\nDESCRIPTION: Demonstrates how to implement a resource provider for thread pool management. The resource provider initializes a thread pool with a specified number of workers and manages its lifecycle.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    thread_pool = providers.Resource(\n        init_thread_pool,\n        max_workers=config.max_workers,\n    )\n\n    dispatcher = providers.Factory(\n        TaskDispatcher,\n        executor=thread_pool,\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing the Asynchronous Dispatcher for Monitors - Python\nDESCRIPTION: Defines the dispatcher.py module, which provides the Dispatcher class to orchestrate and supervise multiple Monitor instances. The Dispatcher schedules and runs monitor checks concurrently using asyncio, and handles graceful shutdown on SIGTERM or SIGINT signals. Key parameters include a list of Monitor objects. Limitations: cancellation and shutdown logic does not handle errors during monitor execution, and requires event loop signal support (not available on Windows).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Dispatcher module.\"\"\"\n\nimport asyncio\nimport logging\nimport signal\nimport time\nfrom typing import List\n\nfrom .monitors import Monitor\n\n\nclass Dispatcher:\n\n    def __init__(self, monitors: List[Monitor]) -> None:\n        self._monitors = monitors\n        self._monitor_tasks: List[asyncio.Task] = []\n        self._logger = logging.getLogger(self.__class__.__name__)\n        self._stopping = False\n\n    def run(self) -> None:\n        asyncio.run(self.start())\n\n    async def start(self) -> None:\n        self._logger.info(\"Starting up\")\n\n        for monitor in self._monitors:\n            self._monitor_tasks.append(\n                asyncio.create_task(self._run_monitor(monitor)),\n            )\n\n        asyncio.get_event_loop().add_signal_handler(signal.SIGTERM, self.stop)\n        asyncio.get_event_loop().add_signal_handler(signal.SIGINT, self.stop)\n\n        await asyncio.gather(*self._monitor_tasks, return_exceptions=True)\n\n        self.stop()\n\n    def stop(self) -> None:\n        if self._stopping:\n            return\n\n        self._stopping = True\n\n        self._logger.info(\"Shutting down\")\n        for task, monitor in zip(self._monitor_tasks, self._monitors):\n            task.cancel()\n        self._monitor_tasks.clear()\n        self._logger.info(\"Shutdown finished successfully\")\n```\n\n----------------------------------------\n\nTITLE: Running the Aiohttp Application in Bash\nDESCRIPTION: This Bash command executes the application module, starting the aiohttp web server. Ensure you are in the project's root directory and have activated your virtual environment if using one.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\npython -m giphynavigator.application\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from Python Dictionary Using Dependency Injector in Python\nDESCRIPTION: Illustration of loading configuration from an in-memory Python dictionary using from_dict method on the Configuration provider. Enables dynamic programmatic configuration setup without external files.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Example usage (content omitted for brevity)\ncontainer.config.from_dict({...})\n```\n\n----------------------------------------\n\nTITLE: Listing Django Views with Dependency Injection\nDESCRIPTION: The views in 'web/views.py' utilize dependencies such as search services injected via wiring, enabling decoupled and testable request handlers. This code demonstrates how to annotate and wire dependencies into Django views, thus integrating dependency injection with Django's request handling system.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/django.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: ../../examples/miniapps/django/web/views.py\n   :language: python\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Argument Priority in Factory of Factories Pattern\nDESCRIPTION: Shows how argument priority works in nested factories. Demonstrates the precedence rules for keyword arguments in upper level factories, lower level factories, and context arguments.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/factory-of-factories.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# 1. Keyword arguments of upper level factory are added to lower level factory\nfactory_of_dict_factories = providers.Factory(\n    providers.Factory,\n    dict,\n    arg1=1,\n)\ndict_factory = factory_of_dict_factories(arg2=2)\nprint(dict_factory())  # prints: {\"arg1\": 1, \"arg2\": 2}\n\n# 2. Keyword arguments of upper level factory have priority\nfactory_of_dict_factories = providers.Factory(\n    providers.Factory,\n    dict,\n    arg1=1,\n)\ndict_factory = factory_of_dict_factories(arg1=2)\nprint(dict_factory())  # prints: {\"arg1\": 2}\n\n# 3. Keyword arguments provided from context have the most priority\nfactory_of_dict_factories = providers.Factory(\n    providers.Factory,\n    dict,\n    arg1=1,\n)\ndict_factory = factory_of_dict_factories(arg1=2)\nprint(dict_factory(arg1=3))  # prints: {\"arg1\": 3}\n```\n\n----------------------------------------\n\nTITLE: Container Resource Management in Python\nDESCRIPTION: Shows how to initialize and shutdown all resources in a container at once. This pattern is useful for managing multiple resources with a single command.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\ncontainer.init_resources()\ncontainer.shutdown_resources()\n```\n\n----------------------------------------\n\nTITLE: Running the Python CLI App with Environment Variable\nDESCRIPTION: Shows bash commands to run the Python CLI app by setting the 'MOVIE_FINDER_TYPE' environment variable to specify which storage provider ('csv' or 'sqlite') to use. Requires the Python application, and the 'movies' module must be importable as a module. Input is environment variable; output is printed movie lists.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nMOVIE_FINDER_TYPE=csv python -m movies\nMOVIE_FINDER_TYPE=sqlite python -m movies\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Aggregate Provider in Python\nDESCRIPTION: Demonstrates how to create and use an Aggregate provider to group different configuration readers under a single access point. The example shows a Container class with YAML and JSON configuration readers aggregated under a config_readers provider.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/aggregate.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Code referenced from the documentation but not directly shown\n```\n\n----------------------------------------\n\nTITLE: Implementing User Service Logic in Python\nDESCRIPTION: Contains the business logic for user-related operations encapsulated in a service class. This module depends on the user repository to interact with persistent storage and provides higher-level abstractions used by API endpoints.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/services.py with user service implementation\n```\n\n----------------------------------------\n\nTITLE: Implementing and Using Selector Provider in Python\nDESCRIPTION: This code demonstrates how to instantiate and utilize the Selector provider from the dependency_injector framework. It shows setting up a selector callable, passing provider options as keyword arguments, and delegating work based on dynamic selection keys. Dependencies include the dependency_injector.providers module; the main parameters are the selector callable and provider mappings. The snippet enables flexible provider selection, facilitating polymorphism and configuration-based dependency management.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/selector.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/selector.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 16-20\n```\n\n----------------------------------------\n\nTITLE: Configuring Container Wiring for Handlers Module in Python\nDESCRIPTION: This Python snippet updates the dependency container definition to include `WiringConfiguration`. This configuration tells the container to automatically inject dependencies into functions and classes decorated with `@inject` within the specified modules, like the 'handlers' module.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import giphy, services\n\n\nclass Container(containers.DeclarativeContainer):\n\n    wiring_config = containers.WiringConfiguration(modules=[\".handlers\"])\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    giphy_client = providers.Factory(\n        giphy.GiphyClient,\n        api_key=config.giphy.api_key,\n        timeout=config.giphy.request_timeout,\n    )\n\n    search_service = providers.Factory(\n        services.SearchService,\n        giphy_client=giphy_client,\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Pytest Fixtures and Tests with Mocking in Python\nDESCRIPTION: This Python snippet provides example tests for the aiohttp application handler using pytest and unittest.mock. It includes fixtures for setting up the application and test client, and tests that use dependency overriding to mock the `GiphyClient` for isolated testing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Tests module.\"\"\"\n\nfrom unittest import mock\n\nimport pytest\n\nfrom giphynavigator.application import create_app\nfrom giphynavigator.giphy import GiphyClient\n\n\n@pytest.fixture\ndef app():\n    app = create_app()\n    yield app\n    app.container.unwire()\n\n\n@pytest.fixture\ndef client(app, aiohttp_client, loop):\n    return loop.run_until_complete(aiohttp_client(app))\n\n\nasync def test_index(client, app):\n    giphy_client_mock = mock.AsyncMock(spec=GiphyClient)\n    giphy_client_mock.search.return_value = {\n        \"data\": [\n            {\"url\": \"https://giphy.com/gif1.gif\"},\n            {\"url\": \"https://giphy.com/gif2.gif\"},\n        ],\n    }\n\n    with app.container.giphy_client.override(giphy_client_mock):\n        response = await client.get(\n            \"/\",\n            params={\n                \"query\": \"test\",\n                \"limit\": 10,\n            },\n        )\n\n    assert response.status == 200\n    data = await response.json()\n    assert data == {\n        \"query\": \"test\",\n        \"limit\": 10,\n        \"gifs\": [\n            {\"url\": \"https://giphy.com/gif1.gif\"},\n            {\"url\": \"https://giphy.com/gif2.gif\"},\n        ],\n    }\n\n\nasync def test_index_no_data(client, app):\n    giphy_client_mock = mock.AsyncMock(spec=GiphyClient)\n    giphy_client_mock.search.return_value = {\n        \"data\": [],\n    }\n\n    with app.container.giphy_client.override(giphy_client_mock):\n        response = await client.get(\"/\")\n\n    assert response.status == 200\n    data = await response.json()\n    assert data[\"gifs\"] == []\n\n\nasync def test_index_default_params(client, app):\n    giphy_client_mock = mock.AsyncMock(spec=GiphyClient)\n    giphy_client_mock.search.return_value = {\n        \"data\": [],\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing GitHub Search Service with Repository Formatting\nDESCRIPTION: Creates a service class for searching GitHub repositories that formats the search results including repository details and latest commit information. This service uses the GitHub API client.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Services module.\"\"\"\n\nfrom github import Github\nfrom github.Repository import Repository\nfrom github.Commit import Commit\n\n\nclass SearchService:\n    \"\"\"Search service performs search on Github.\"\"\"\n\n    def __init__(self, github_client: Github):\n        self._github_client = github_client\n\n    def search_repositories(self, query, limit):\n        \"\"\"Search for repositories and return formatted data.\"\"\"\n        repositories = self._github_client.search_repositories(\n            query=query,\n            **{\"in\": \"name\"},\n        )\n        return [\n            self._format_repo(repository)\n            for repository in repositories[:limit]\n        ]\n\n    def _format_repo(self, repository: Repository):\n        commits = repository.get_commits()\n        return {\n            \"url\": repository.html_url,\n            \"name\": repository.name,\n            \"owner\": {\n                \"login\": repository.owner.login,\n                \"url\": repository.owner.html_url,\n                \"avatar_url\": repository.owner.avatar_url,\n            },\n            \"latest_commit\": self._format_commit(commits[0]) if commits else {},\n        }\n\n    def _format_commit(self, commit: Commit):\n        return {\n            \"sha\": commit.sha,\n            \"url\": commit.html_url,\n            \"message\": commit.commit.message,\n            \"author_name\": commit.commit.author.name,\n        }\n```\n\n----------------------------------------\n\nTITLE: Implementing Factory of Factories Pattern with Python-Dependency-Injector\nDESCRIPTION: Creates a base factory that instantiates another factory provider and passes additional arguments. The concrete factory then uses the base factory with extra arguments to create instances.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/factory-of-factories.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nbase_factory = providers.Factory(\n    providers.Factory\n    SomeClass,\n    base_argument=1,\n)\n\nconcrete_factory = providers.Factory(\n    OtherClass,\n    instance=base_factory(extra_argument=1),\n)\n\n\nif __name__ == \"__main__\":\n    instance = concrete_factory()\n    # Same as: # instance = SomeClass(base_argument=1, extra_argument=2)\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Giphy Timeout in YAML\nDESCRIPTION: This YAML snippet defines the basic configuration structure for the Giphy API client, including a request timeout setting. This configuration will be loaded by the application's dependency injection container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\ngiphy:\n  request_timeout: 10\n```\n\n----------------------------------------\n\nTITLE: Setting Giphy API Key Environment Variable in Bash\nDESCRIPTION: This Bash command sets the 'GIPHY_API_KEY' environment variable, which is required by the application to authenticate with the Giphy API. Replace the example key with your actual API key.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport GIPHY_API_KEY=wBJ2wZG7SRqfrU9nPgPiWvORmloDyuL0\n```\n\n----------------------------------------\n\nTITLE: Adding `HttpClient` to Dependency Injection Container\nDESCRIPTION: Extends the container configuration to include a factory provider for `HttpClient`, enabling dependency injection into monitor classes. This setup allows `HttpMonitor` instances to utilize a shared, configurable HTTP client for performing web requests asynchronously.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nimport logging\nimport sys\n\nfrom dependency_injector import containers, providers\n\nfrom . import http, dispatcher\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    logging = providers.Resource(\n        logging.basicConfig,\n        stream=sys.stdout,\n        level=config.log.level,\n        format=config.log.format,\n    )\n\n    http_client = providers.Factory(http.HttpClient)\n\n    dispatcher = providers.Factory(\n        dispatcher.Dispatcher,\n        monitors=providers.List(\n            # TODO: add monitors\n        ),\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Password Hashing with Callable Provider (Python)\nDESCRIPTION: This Python code, included from '../../examples/miniapps/password-hashing/example.py', demonstrates setting up a dependency injection container to provide a password hashing function using the `Callable` provider. It showcases how to configure and utilize the injected callable within an application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/password-hashing.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Source code included from:\n# ../../examples/miniapps/password-hashing/example.py\n# (Content not available directly in this document)\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from Multiple Sources with Recursive Merge Using Dependency Injector in Python\nDESCRIPTION: Illustrates how the Configuration provider supports loading configuration data from multiple sources sequentially, merging them recursively into one combined configuration state. This feature allows layering configuration from base files and environment-specific overrides or local files.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# Example usage (content omitted for brevity)\ncontainer.config.from_yaml(\"config.yml\")\ncontainer.config.from_yaml(\"config.local.yml\")\n```\n\n----------------------------------------\n\nTITLE: Application Entry Point with Container Wiring in `__main__.py`\nDESCRIPTION: Implements an entry point function `main` that injects the dispatcher from the container and calls its `run()` method. The script initializes the dependency injection container, allocates resources, wires modules for injection, and executes `main`. This setup facilitates decoupling and easy configuration management in an asynchronous environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Main module.\"\"\"\n\nfrom dependency_injector.wiring import Provide, inject\n\nfrom .dispatcher import Dispatcher\nfrom .containers import Container\n\n\n@inject\ndef main(dispatcher: Dispatcher = Provide[Container.dispatcher]) -> None:\n    dispatcher.run()\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.init_resources()\n    container.wire(modules=[__name__])\n\n    main()\n```\n\n----------------------------------------\n\nTITLE: Defining Photo Package Container in Python\nDESCRIPTION: Defines the container for the 'photo' package using Dependency Injector. It declares dependencies on a database client ('db') and an AWS S3 client ('s3') using `providers.Dependency`. It provides a `PhotoRepository` factory that requires both external dependencies, encapsulating the package's needs.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Content of example/photo/containers.py\n# Defines the PhotoContainer, declaring dependencies on 'db' and 's3'\n# and providing a PhotoRepository factory.\n\nfrom dependency_injector import containers, providers\n\nfrom . import repositories\n\n\nclass PhotoContainer(containers.DeclarativeContainer):\n\n    db = providers.Dependency()\n    s3 = providers.Dependency()\n\n    repository = providers.Factory(\n        repositories.PhotoRepository,\n        db=db,\n        s3=s3,\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Application Entry Point in Python\nDESCRIPTION: The main execution script (`__main__.py`) for the application. It initializes the `ApplicationContainer`, loads configuration from 'config.ini', wires the container's modules to enable dependency injection, retrieves the `AnalyticsService` from the container, and executes its main logic, demonstrating the application's startup sequence.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Content of example/__main__.py\n# Application entry point. Initializes the ApplicationContainer, loads configuration,\n# wires dependencies, retrieves the AnalyticsService, and runs the main logic.\n\nfrom .containers import ApplicationContainer\n\n\ndef main(container: ApplicationContainer): # type: ignore\n    # Example usage:\n    analytics_service = container.analytics_package.service()\n    # result = analytics_service.calculate_stats()\n    # print(result)\n    print('Application finished.')\n\n\nif __name__ == '__main__':\n    container = ApplicationContainer()\n    container.config.from_ini('config.ini')\n    # Wire the container to the main module and any other modules where injection is needed.\n    container.wire(modules=[__name__])\n\n    main(container=container) # Injected!\n```\n\n----------------------------------------\n\nTITLE: Inheriting Declarative Containers in Python\nDESCRIPTION: This snippet demonstrates defining a declarative container that inherits from another container class. It shows how inherited providers are accessible alongside newly declared providers, enabling reuse and extension of provider configurations.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass BaseContainer(containers.DeclarativeContainer):\n    foo = providers.Factory(Foo)\n\nclass Container(BaseContainer):\n    bar = providers.Singleton(Bar)\n```\n\n----------------------------------------\n\nTITLE: Initializing Dependency Injection Container with Logging - Python\nDESCRIPTION: Implements the main containers.py module that defines a dependency injection container using the dependency-injector library. It provides a YAML-based configuration provider and a resource provider to configure logging using settings from config.yml. Python dependencies required: dependency-injector, PyYAML. Key parameters include logging settings and the config.yml path; config must contain log.level and log.format fields.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nimport logging\nimport sys\n\nfrom dependency_injector import containers, providers\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    logging = providers.Resource(\n        logging.basicConfig,\n        stream=sys.stdout,\n        level=config.log.level,\n        format=config.log.format,\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider Class in Dependency Injector (Python)\nDESCRIPTION: This snippet demonstrates how to implement a custom provider by subclassing the Provider class from the dependency_injector.providers module. It includes the necessary overrides: the _provide() method to define provision logic, the __deepcopy__() method to ensure correct copying behavior using the module's deepcopy mechanism, and the related property to expose internal providers. The __init__() should always call the parent class initializer. The implementation highlights the importance of properly handling arguments, overrides, and copying to ensure reliable IoC integration and maintain expected behaviors when the provider is used or extended.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/custom.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector.providers import Provider, deepcopy\n\nclass CustomProvider(Provider):\n    __slots__ = ('_args', '_kwargs', '_overrides')\n\n    def __init__(self, *args, **kwargs):\n        super().__init__()\n        self._args = args\n        self._kwargs = kwargs\n        self._overrides = []\n\n    def _provide(self, args, kwargs):\n        # Provide some object using self._args and self._kwargs\n        return (self._args, self._kwargs, args, kwargs)\n\n    def __deepcopy__(self, memo):\n        try:\n            cls = self.__class__\n            copy = cls(*deepcopy(self._args, memo), **deepcopy(self._kwargs, memo))\n            copy._copy_overriding(self)\n            return copy\n        except Exception as error:\n            raise error\n\n    @property\n    def related(self):\n        yield from super().related\n        # If this provider stores other providers, yield them here\n\n# Usage example\ncustom_provider = CustomProvider(1, 2, key='value')\nprovided = custom_provider()\nprint(provided)\n\n```\n\n----------------------------------------\n\nTITLE: Fixtures module for creating CSV and SQLite sample data (Python)\nDESCRIPTION: Defines sample movie data and functions to generate CSV and SQLite database files used for testing and development. These fixtures ensure reproducible test data for the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Fixtures module.\"\"\"\n\nimport csv\nimport sqlite3\nimport pathlib\n\n\nSAMPLE_DATA = [\n    (\"The Hunger Games: Mockingjay - Part 2\", 2015, \"Francis Lawrence\"),\n    (\"Rogue One: A Star Wars Story\", 2016, \"Gareth Edwards\"),\n    (\"The Jungle Book\", 2016, \"Jon Favreau\"),\n]\n\nFILE = pathlib.Path(__file__)\nDIR = FILE.parent\nCSV_FILE = DIR / \"movies.csv\"\nSQLITE_FILE = DIR / \"movies.db\"\n\n\ndef create_csv(movies_data, path):\n    with open(path, \"w\") as opened_file:\n        writer = csv.writer(opened_file)\n        for row in movies_data:\n            writer.writerow(row)\n\n\ndef create_sqlite(movies_data, path):\n    with sqlite3.connect(path) as db:\n        db.execute(\n            \"CREATE TABLE IF NOT EXISTS movies \"\n            \"(title text, year int, director text)\"\n        )\n        db.execute(\"DELETE FROM movies\")\n        db.executemany(\"INSERT INTO movies VALUES (?,?,?)\", movies_data)\n\n\ndef main():\n    create_csv(SAMPLE_DATA, CSV_FILE)\n    create_sqlite(SAMPLE_DATA, SQLITE_FILE)\n    print(\"OK\")\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n----------------------------------------\n\nTITLE: Creating Sanic Application Factory with Dependency Injection in Python\nDESCRIPTION: Constructs the Sanic application instance in application.py by creating and wiring the container with handler modules, setting up routes, and configuring middleware or other application-level settings. This factory pattern allows for centralized app initialization and dependency resolution before the server runs. Dependencies like the container and handlers are utilized here. The snippet requires Sanic and Dependency Injector libraries.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/sanic.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nProvided externally in application.py via literalinclude directive.\n```\n\n----------------------------------------\n\nTITLE: Application Entry Point (__main__.py)\nDESCRIPTION: This referenced Python file (`example/__main__.py`) serves as the main execution script. It typically parses command-line arguments, configures the DI container based on the environment (e.g., 'test' or 'prod'), resolves dependencies, and triggers the primary use case. The actual code is external.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Asynchronous Function Initializer in Python\nDESCRIPTION: Implements a resource provider with an asynchronous function initializer. This is useful for resources that require asynchronous initialization like database connections.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nasync def init_async_resource(argument1=..., argument2=...):\n    return await connect()\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        init_resource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining User Package Container in Python\nDESCRIPTION: Defines the container for the 'user' package using Dependency Injector. It declares a dependency on a database client using `providers.Dependency` and provides a `UserRepository` that requires this database client. This isolates the package's database dependency, allowing it to be provided externally.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Content of example/user/containers.py\n# Defines the UserContainer, declaring a dependency on 'db'\n# and providing a UserRepository factory.\n\nfrom dependency_injector import containers, providers\n\nfrom . import repositories\n\n\nclass UserContainer(containers.DeclarativeContainer):\n\n    db = providers.Dependency()\n\n    repository = providers.Factory(\n        repositories.UserRepository,\n        db=db,\n    )\n```\n\n----------------------------------------\n\nTITLE: Custom YAML Loader Usage with Dependency Injector Configuration Provider in Python\nDESCRIPTION: Demonstrates how to use a custom YAML loader by passing the loader argument (e.g., yaml.UnsafeLoader) to the from_yaml method. This allows users to control YAML parsing behavior beyond the default SafeLoader. PyYAML must be installed for YAML loading.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport yaml\n\n\ncontainer.config.from_yaml(\"config.yml\", loader=yaml.UnsafeLoader)\n```\n\n----------------------------------------\n\nTITLE: YAML File Example with Environment Variable Interpolation\nDESCRIPTION: Example of YAML configuration syntax supporting environment variables. Variables appear as ${ENV_VAR} with optional default values using ${ENV_VAR:default} to enable safe substitution during configuration loading.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\nsection:\n  option1: ${ENV_VAR}\n  option2: ${ENV_VAR}/path\n  option3: ${ENV_VAR:default}\n```\n\n----------------------------------------\n\nTITLE: Initializing Container Instance in Django Module\nDESCRIPTION: This snippet creates an instance of the dependency container in 'githubnavigator/__init__.py', making it accessible application-wide. It allows the app to leverage the configured providers defined in the container, supporting dependency wiring and injection throughout the Django project.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/django.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: ../../examples/miniapps/django/githubnavigator/__init__.py\n   :language: python\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependency Injection Container with CSV Finder\nDESCRIPTION: Updates the Container class to register movie finders and listers with their dependencies, including configuration from a YAML file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import finders, listers, entities\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    movie = providers.Factory(entities.Movie)\n\n    csv_finder = providers.Singleton(\n        finders.CsvMovieFinder,\n        movie_factory=movie.provider,\n        path=config.finder.csv.path,\n        delimiter=config.finder.csv.delimiter,\n    )\n\n    lister = providers.Factory(\n        listers.MovieLister,\n        movie_finder=csv_finder,\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Example Test Execution Output (Bash)\nDESCRIPTION: This snippet displays the expected output when running the tests using the provided Docker Compose command. It shows pytest collecting and running the tests, confirming that 2 items were collected and both tests passed ('..'). It also includes the coverage report generated by the `--cov` flag.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\nplatform linux -- Python 3.13.1, pytest-8.3.4, pluggy-1.5.0\nrootdir: /code\nplugins: cov-6.0.0, asyncio-0.24.0\nasyncio: mode=Mode.STRICT, default_loop_scope=None\ncollected 2 items\n\nmonitoringdaemon/tests.py ..                                    [100%]\n\n---------- coverage: platform linux, python 3.10.0-final-0 -----------\nName                             Stmts   Miss  Cover\n----------------------------------------------------\nmonitoringdaemon/__init__.py         0      0   100%\nmonitoringdaemon/__main__.py        11     11     0%\nmonitoringdaemon/containers.py      11      0   100%\nmonitoringdaemon/dispatcher.py      45      5    89%\nmonitoringdaemon/http.py             6      3    50%\nmonitoringdaemon/monitors.py        23      1    96%\nmonitoringdaemon/tests.py           35      0   100%\n----------------------------------------------------\nTOTAL                              131     20    85%\n```\n\n----------------------------------------\n\nTITLE: Running the Example Application with Command-line Arguments\nDESCRIPTION: Command to run the example application using the Python module with three arguments: an email address, password, and a filename.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-multiple-containers/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m example user@example.com secret photo.jpg\n```\n\n----------------------------------------\n\nTITLE: Implementing Aiohttp Handler with Injected Service in Python\nDESCRIPTION: This Python function defines an aiohttp request handler using `@inject` and `Provide` from dependency-injector to receive the `SearchService` instance. It retrieves search parameters from the request and uses the injected service to fetch Giphy data.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Handlers module.\"\"\"\n\nfrom aiohttp import web\nfrom dependency_injector.wiring import Provide, inject\n\nfrom .services import SearchService\nfrom .containers import Container\n\n\n@inject\nasync def index(\n        request: web.Request,\n        search_service: SearchService = Provide[Container.search_service],\n) -> web.Response:\n    query = request.query.get(\"query\", \"Dependency Injector\")\n    limit = int(request.query.get(\"limit\", 10))\n\n    gifs = await search_service.search(query, limit)\n\n    return web.json_response(\n        {\n            \"query\": query,\n            \"limit\": limit,\n            \"gifs\": gifs,\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Settings in INI\nDESCRIPTION: Provides example configuration settings in INI format (`config.ini`). It includes sections for database connection details (DSN) and AWS credentials (access key ID, secret access key) required by the application container to initialize external services like SQLite and S3.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_6\n\nLANGUAGE: ini\nCODE:\n```\n# Content of config.ini\n# Configuration file for the application.\n\n[database]\ndsn = :memory:\n\n[aws]\naccess_key_id = KEY\nsecret_access_key = SECRET\n```\n\n----------------------------------------\n\nTITLE: Implementing Selector Pattern for Dynamic Finder Selection\nDESCRIPTION: Enhances the Container with a Selector provider to dynamically choose between CSV and SQLite finders based on configuration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers, providers\n\nfrom . import finders, listers, entities\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    movie = providers.Factory(entities.Movie)\n\n    csv_finder = providers.Singleton(\n        finders.CsvMovieFinder,\n        movie_factory=movie.provider,\n        path=config.finder.csv.path,\n        delimiter=config.finder.csv.delimiter,\n    )\n\n    sqlite_finder = providers.Singleton(\n        finders.SqliteMovieFinder,\n        movie_factory=movie.provider,\n        path=config.finder.sqlite.path,\n    )\n\n    finder = providers.Selector(\n        config.finder.type,\n        csv=csv_finder,\n        sqlite=sqlite_finder,\n    )\n\n    lister = providers.Factory(\n        listers.MovieLister,\n        movie_finder=finder,\n\n```\n\n----------------------------------------\n\nTITLE: Using Generic Provider Type Hinting with Mypy in Python\nDESCRIPTION: Illustrates using `providers.Provider[Animal]` as a generic type hint for a provider variable. This informs mypy that the provider will return an instance compatible with the `Animal` type (like `Cat`), allowing for more flexible type checking, especially when passing providers to functions or methods.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/typing_mypy.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import providers\n\n\nclass Animal:\n    ...\n\n\nclass Cat(Animal):\n    ...\n\n\nprovider: providers.Provider[Animal] = providers.Factory(Cat)\n\n\nif __name__ == \"__main__\":\n    animal = provider()  # mypy knows that animal is of type \"Animal\"\n```\n\n----------------------------------------\n\nTITLE: Bootstrapping the Monitoring Daemon Application - Python\nDESCRIPTION: Provides the application entry point in __main__.py, responsible for creating the DI container, initializing resources (including logging and configuration parsing), and launching the main program logic. No external input is expected, and execution starts if the script is run as __main__. All resource initialization is handled prior to entering main(). Dependencies: the containers.py module must be available.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Main module.\"\"\"\n\nfrom .containers import Container\n\n\ndef main() -> None:\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.init_resources()\n\n    main()\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Resource Subclass in Python\nDESCRIPTION: Implements an asynchronous resource subclass for managing connection resources. This approach provides explicit async methods for initialization and shutdown.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import resources\n\n\nclass AsyncConnection(resources.AsyncResource):\n\n    async def init(self, argument1=..., argument2=...):\n        yield await connect()\n\n    async def shutdown(self, connection):\n        await connection.close()\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        AsyncConnection,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Verifying Installed Version of Dependency Injector\nDESCRIPTION: This snippet shows how to verify the installed version of Dependency Injector by importing the package and printing its __version__ attribute. It helps ensure the correct version is installed, which is crucial for compatibility.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/installation.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n>>> import dependency_injector\n>>> dependency_injector.__version__\n'4.39.0'\n```\n\n----------------------------------------\n\nTITLE: Defining the Monitor Base Class for Periodic Checks - Python\nDESCRIPTION: Implements the monitors.py module, which defines the base Monitor class for asynchronous monitoring tasks. Each Monitor has a configurable interval (check_every) and a dedicated logger. Subclasses must implement the async check() method. Python's logging standard library is used for structured logging. Requires Python 3.7+ for async/await syntax.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Monitors module.\"\"\"\n\nimport logging\n\n\nclass Monitor:\n\n    def __init__(self, check_every: int) -> None:\n        self.check_every = check_every\n        self.logger = logging.getLogger(self.__class__.__name__)\n\n    async def check(self) -> None:\n        raise NotImplementedError()\n```\n\n----------------------------------------\n\nTITLE: Using Relative Imports in Wiring Configuration in Python\nDESCRIPTION: Demonstrates how to use relative imports in wiring configuration, which are resolved relative to the container's module.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# In module \"yourapp.container\":\n\nclass Container(containers.DeclarativeContainer):\n\n    wiring_config = containers.WiringConfiguration(\n        modules=[\n           \".module1\",  # Resolved to: \"yourapp.module1\"\n           \".module2\",  # Resolved to: \"yourapp.module2\"\n        ],\n    )\n)\n\n\n# In module \"yourapp.foo.bar.main\":\n\nif __name__ == \"__main__\":\n    container = Container()  # wire to \"yourapp.module1\" and \"yourapp.module2\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Configuration for External Monitoring Settings `config.yml`\nDESCRIPTION: Specifies logging level and format, along with monitor parameters such as HTTP method, URL, timeout, and check interval. These settings enable customizable and scalable health checks for external resources like `http://example.com`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_17\n\nLANGUAGE: YAML\nCODE:\n```\nlog:\n  level: \"INFO\"\n  format: \"[%(asctime)s] [%(levelname)s] [%(name)s]: %(message)s\"\n\nmonitors:\n\n  example:\n    method: \"GET\"\n    url: \"http://example.com\"\n    timeout: 5\n    check_every: 5\n```\n\n----------------------------------------\n\nTITLE: CSV Movie Finder class for reading movies from a CSV file (Python)\nDESCRIPTION: Implements the CsvMovieFinder class inheriting from MovieFinder, responsible for reading movie data from a CSV file using the specified delimiter, and creating Movie instances via a factory function. It encapsulates CSV parsing logic for movie data.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Movie finders module.\"\"\"\n\nimport csv\nfrom typing import Callable, List\n\nfrom .entities import Movie\n\n\nclass MovieFinder:\n\n    def __init__(self, movie_factory: Callable[..., Movie]) -> None:\n        self._movie_factory = movie_factory\n\n    def find_all(self) -> List[Movie]:\n        raise NotImplementedError()\n\n\nclass CsvMovieFinder(MovieFinder):\n\n    def __init__(\n            self,\n            movie_factory: Callable[..., Movie],\n            path: str,\n            delimiter: str,\n    ) -> None:\n        self._csv_file_path = path\n        self._delimiter = delimiter\n        super().__init__(movie_factory)\n\n    def find_all(self) -> List[Movie]:\n        with open(self._csv_file_path) as csv_file:\n            csv_reader = csv.reader(csv_file, delimiter=self._delimiter)\n            return [self._movie_factory(*row) for row in csv_reader]\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging Format and Level - YAML\nDESCRIPTION: Defines log configuration in YAML format for use by the Python application. The 'level' sets the logging severity (e.g., INFO), and 'format' provides the message layout. This file must be present at config.yml and referenced by the dependency injection setup. Only two fields are specified and both are required by the logging configuration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nlog:\n  level: \"INFO\"\n  format: \"[%(asctime)s] [%(levelname)s] [%(name)s]: %(message)s\"\n```\n\n----------------------------------------\n\nTITLE: Main application entry point (Python)\nDESCRIPTION: Contains the main function that initializes the dependency injection container and starts the CLI application. Currently, the main() function does nothing but can be extended to run the app.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Main module.\"\"\"\n\nfrom .containers import Container\n\n\ndef main() -> None:\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()\n\n    main()\n```\n\n----------------------------------------\n\nTITLE: Injecting Invariant Configuration Options (ItemSelector) (Python)\nDESCRIPTION: Shows how to inject different configuration sections based on the value of another configuration option (the 'switch'). This uses the item access syntax `config.options[config.switch]`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_itemselector.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 15,30-31,38\n```\n\n----------------------------------------\n\nTITLE: Listing Python Project Dependencies\nDESCRIPTION: This text lists the Python packages required for the 'ets-labs/python-dependency-injector' project. It includes libraries for dependency injection (dependency-injector), web framework (fastapi with standard extras, uvicorn ASGI server), configuration/data serialization (pyyaml), database ORM (sqlalchemy), testing (pytest, pytest-cov for coverage), and making HTTP requests (requests). These dependencies are typically installed using a package manager like pip, often from a requirements.txt file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/requirements.txt#_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\ndependency-injector\nfastapi[standard]\nuvicorn\npyyaml\nsqlalchemy\npytest\nrequests\npytest-cov\n```\n\n----------------------------------------\n\nTITLE: Writing Tests with Provider Overriding in Dependency Injector for Python\nDESCRIPTION: Demonstrates test cases in tests.py that override the giphy client provider with a mock implementation using Dependency Injector's provider-overriding feature. This method allows isolating external service dependencies to enable reliable and repeatable testing of application logic. The test suite ensures API correctness without relying on live external services. It requires testing libraries, Dependency Injector, and mock dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/sanic.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nProvided externally in tests.py via literalinclude directive with emphasized lines on mocking and overriding.\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Coverage for Django Application\nDESCRIPTION: Command to run the unit tests with coverage analysis, showing the test results and the code coverage report for the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncoverage run --source='.' manage.py test && coverage report\n```\n\n----------------------------------------\n\nTITLE: Function Initializer for Resource Provider in Python\nDESCRIPTION: Implements a resource provider using a function initializer. The function can return a resource object or configure a global resource without returning anything.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef init_resource(argument1=..., argument2=...):\n    return SomeResource()\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        init_resource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Flask View in Python\nDESCRIPTION: Defines a simple Flask view function `index` in `views.py`. This function returns the string \"Hello, World!\" and serves as the initial endpoint for the web application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Views module.\"\"\"\n\n\ndef index():\n    return \"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Updating Handler to Use Configured Defaults in Python\nDESCRIPTION: This Python snippet refactors the index handler to fetch default search query and limit values from the injected application configuration instead of hardcoding them. This improves maintainability and configurability.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Handlers module.\"\"\"\n\nfrom aiohttp import web\nfrom dependency_injector.wiring import Provide, inject\n\nfrom .services import SearchService\nfrom .containers import Container\n\n\n@inject\nasync def index(\n        request: web.Request,\n        search_service: SearchService = Provide[Container.search_service],\n        default_query: str = Provide[Container.config.default.query],\n        default_limit: int = Provide[Container.config.default.limit.as_int()],\n) -> web.Response:\n    query = request.query.get(\"query\", default_query)\n    limit = int(request.query.get(\"limit\", default_limit))\n\n    gifs = await search_service.search(query, limit)\n\n    return web.json_response(\n        {\n            \"query\": query,\n            \"limit\": limit,\n            \"gifs\": gifs,\n        },\n    )\n```\n\n----------------------------------------\n\nTITLE: Extended YAML Configuration for Multiple Data Sources\nDESCRIPTION: Updates configuration to include path settings for both CSV and SQLite data sources.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_11\n\nLANGUAGE: yaml\nCODE:\n```\nfinder:\n\n  csv:\n    path: \"data/movies.csv\"\n    delimiter: \",\"\n\n  sqlite:\n    path: \"data/movies.db\"\n\n```\n\n----------------------------------------\n\nTITLE: Specializing Factory Providers by Provided Type in dependency_injector (Python)\nDESCRIPTION: This snippet shows how to create a Factory provider subclass that only provides instantiations of a specific type using the provided_type class attribute. It ensures type consistency and enforces constraints on the output type of the Factory. Requires subclassing dependency_injector.providers.Factory and setting provided_type. Useful in large codebases or strict type requirements.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_provided_type.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 12-14\n\n```\n\n----------------------------------------\n\nTITLE: Structuring Application Directories in Bash\nDESCRIPTION: Shows the directory structure for a Python application using multiple containers. The structure includes the main package, containers, services, configuration, and requirements files.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-multiple-containers.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── example/\n│   ├── __init__.py\n│   ├── __main__.py\n│   ├── containers.py\n│   └── services.py\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Declaring and Using Dependency Provider in Python Dependency Injector\nDESCRIPTION: This Python snippet demonstrates how to declare a Dependency provider using the instance_of argument to enforce type constraints. It shows the process of specifying expected dependency types and setting up the provider within a Dependency Injector container. The code relies on the dependency_injector.providers module and requires that the referenced class be defined elsewhere. When a dependency is not provided or overridden, attempts to access the provider will raise an error.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/dependency.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass SomeClass:\n    ...\n\nclass Container(containers.DeclarativeContainer):\n    dependency = providers.Dependency(instance_of=SomeClass)\n\ncontainer = Container()\n# Attempting to call dependency() without override will raise an error\n\n```\n\n----------------------------------------\n\nTITLE: Creating Flask Application Factory in Python\nDESCRIPTION: Defines the `create_app` factory function in `application.py`. This function initializes the `Container`, creates the Flask application instance (`app`), associates the container with the app (`app.container`), maps the root URL ('/') route to the `views.index` function, and returns the configured Flask app object.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom flask import Flask\n\nfrom .containers import Container\nfrom . import views\n\n\ndef create_app() -> Flask:\n    container = Container()\n\n    app = Flask(__name__)\n    app.container = container\n    app.add_url_rule(\"/\", \"index\", views.index)\n\n    return app\n```\n\n----------------------------------------\n\nTITLE: Basic Provider Type Inference with Mypy in Python\nDESCRIPTION: Demonstrates how mypy can automatically infer the concrete type (`Cat`) returned by a `dependency_injector.providers.Factory`. When `provider()` is called, mypy correctly identifies the type of the `animal` variable as `Cat` due to the included typing stubs.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/typing_mypy.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import providers\n\n\nclass Animal:\n    ...\n\n\nclass Cat(Animal):\n    ...\n\n\nprovider = providers.Factory(Cat)\n\n\nif __name__ == \"__main__\":\n    animal = provider()  # mypy knows that animal is of type \"Cat\"\n```\n\n----------------------------------------\n\nTITLE: Defining Application Directory Structure in Bash\nDESCRIPTION: Illustrates the directory structure for the example decoupled application. It shows separate directories for 'user', 'photo', and 'analytics' packages, each containing its own container definition, along with a main application container, entry point (__main__.py), configuration file (config.ini), and requirements.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/decoupled-packages.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── example/\n│   ├── analytics/\n│   │   ├── __init__.py\n│   │   ├── containers.py\n│   │   └── services.py\n│   ├── photo/\n│   │   ├── __init__.py\n│   │   ├── containers.py\n│   │   ├── entities.py\n│   │   └── repositories.py\n│   ├── user/\n│   │   ├── __init__.py\n│   │   ├── containers.py\n│   │   ├── entities.py\n│   │   └── repositories.py\n│   ├── __init__.py\n│   ├── __main__.py\n│   └── containers.py\n├── config.ini\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Logging with Resource Provider in Python\nDESCRIPTION: Shows how to use a resource provider to configure global logging. This example demonstrates a function initializer that doesn't return a value but configures a global resource.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport logging.config\n\n\nclass Container(containers.DeclarativeContainer):\n\n    configure_logging = providers.Resource(\n        logging.config.fileConfig,\n        fname=\"logging.ini\",\n    )\n```\n\n----------------------------------------\n\nTITLE: Adding Default Search Parameters to Config in YAML\nDESCRIPTION: This YAML snippet updates the configuration file to include default values for the search query and limit. These values are now available via the dependency injection container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_17\n\nLANGUAGE: yaml\nCODE:\n```\ngiphy:\n  request_timeout: 10\ndefault:\n  query: \"Dependency Injector\"\n  limit: 10\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies using Bash\nDESCRIPTION: Command to install the necessary Python packages listed in the `requirements.txt` file using `pip`. This should be run after activating the virtual environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Disabling Environment Variable Interpolation (YAML/Python)\nDESCRIPTION: Shows how to disable environment variable interpolation entirely by passing `envs_required=None` when loading configuration. A sample YAML file and a Python snippet demonstrate that the variable placeholder remains unchanged after loading.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_15\n\nLANGUAGE: yaml\nCODE:\n```\ntemplate_string: 'Hello, ${name}!'\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> container.config.from_yaml(\"templates.yml\", envs_required=None)\n>>> container.config.template_string()\n'Hello, ${name}!'\n```\n\n----------------------------------------\n\nTITLE: Displaying FastAPI Example File Structure - Bash\nDESCRIPTION: Provides the directory structure of the example application, showing the organization of Python modules within the `giphynavigator` package, configuration file (`config.yml`), and dependency requirements file (`requirements.txt`). This structure is typical for small to medium Python projects.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── giphynavigator/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── endpoints.py\n│   ├── giphy.py\n│   ├── services.py\n│   └── tests.py\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Sample Output of the Python CLI Movie App\nDESCRIPTION: Provides sample plain text output from running the movie lister application, showing movies directed by 'Francis Lawrence' and movies released in 2016. Output is purely illustrative and not code to be executed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_15\n\nLANGUAGE: plain\nCODE:\n```\nFrancis Lawrence movies:\n    - Movie(title='The Hunger Games: Mockingjay - Part 2', year=2015, director='Francis Lawrence')\n2016 movies:\n    - Movie(title='Rogue One: A Star Wars Story', year=2016, director='Gareth Edwards')\n    - Movie(title='The Jungle Book', year=2016, director='Jon Favreau')\n```\n\n----------------------------------------\n\nTITLE: Using List Provider with Dependency Injector in Python\nDESCRIPTION: Demonstrates how to utilize the List provider from the dependency_injector.providers module to create an injectable list of dependencies. Requires the dependency-injector library to be installed and imported, and the List provider must be imported from dependency_injector.providers. This code constructs a list provider using positional arguments, and does not support keyword arguments due to provider limitations. The expected output is a Python list containing the provided dependencies. Limitations include the lack of keyword argument support and compatibility only with objects provided via positional parameters.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/list.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom dependency_injector import providers\n\nnumbers = providers.List(\n    1,\n    2,\n    3,\n)\n\nprint(numbers())\n# Output: [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Running Coverage Report for pytest in a Python aiohttp Project\nDESCRIPTION: This snippet provides a bash command to execute pytest with coverage measurement on the giphynavigator tests. It shows the command syntax used for running tests with coverage and the expected output indicating how much of the code is covered by tests, aiding in assessing test completeness.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\n   py.test giphynavigator/tests.py --cov=giphynavigator\n```\n\n----------------------------------------\n\nTITLE: Setting Up Configuration for GitHub API\nDESCRIPTION: Creates a YAML configuration file for the application that specifies GitHub API settings, particularly the request timeout value. This configuration will be loaded by the container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_16\n\nLANGUAGE: yaml\nCODE:\n```\ngithub:\n  request_timeout: 10\n```\n\n----------------------------------------\n\nTITLE: Creating Base HTML Layout with Bootstrap Integration\nDESCRIPTION: Defines the base HTML structure (`base.html`) using Jinja2 templating. It includes standard HTML5 boilerplate, responsive viewport meta tag, incorporates Bootstrap CSS and JS via `Bootstrap-Flask` helpers (`bootstrap.load_css()`, `bootstrap.load_js()`), and defines Jinja2 blocks (`head`, `styles`, `title`, `content`, `scripts`) for content extension by child templates.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_12\n\nLANGUAGE: HTML\nCODE:\n```\n<!doctype html>\n<html lang=\"en\">\n    <head>\n        {% block head %}\n        <!-- Required meta tags -->\n        <meta charset=\"utf-8\">\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\">\n\n        {% block styles %}\n            <!-- Bootstrap CSS -->\n            {{ bootstrap.load_css() }}\n        {% endblock %}\n\n        <title>{% block title %}{% endblock %}</title>\n        {% endblock %}\n    </head>\n    <body>\n        <!-- Your page content -->\n        {% block content %}{% endblock %}\n\n        {% block scripts %}\n            <!-- Optional JavaScript -->\n            {{ bootstrap.load_js() }}\n        {% endblock %}\n    </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Using Closing Marker with Asynchronous Resources in Python\nDESCRIPTION: Shows how to use the Closing marker with asynchronous Resource providers to ensure proper cleanup of resources.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def main(\n    db: Database = Closing[Provide[Container.db]],\n    cache: Cache = Closing[Provide[Container.cache]],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies for AWS Integration\nDESCRIPTION: A requirements file listing the dependency-injector package for dependency injection and boto3 for AWS service integration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/decoupled-packages/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndependency-injector\nboto3\n```\n\n----------------------------------------\n\nTITLE: Configuring Dict Provider for Dependency Injection in Python\nDESCRIPTION: This snippet illustrates how to initialize and use the Dict provider from dependency_injector.providers to inject a dictionary of dependencies in Python. It demonstrates creating a Dict provider using keyword arguments, allowing dependencies to be referenced by their keys when injected. This setup assumes dependency_injector is installed and that the referenced providers (e.g., providers.Factory) are properly configured. The key output is a provider that returns a dictionary mapping keys to constructed dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/dict.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import providers\n\ndict_provider = providers.Dict(\n    dependency1=providers.Factory(SomeClass1),\n    dependency2=providers.Factory(SomeClass2),\n)\n\n```\n\n----------------------------------------\n\nTITLE: Listing Project Dependencies - Bash\nDESCRIPTION: This Bash snippet displays the contents of the `requirements.txt` file. It lists the Python packages required for the project, including core dependencies like `dependency-injector`, `flask`, and `pygithub`, as well as testing dependencies like `pytest-flask` and `pytest-cov`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\ndependency-injector\nflask\nbootstrap-flask\npygithub\npyyaml\npytest-flask\npytest-cov\n```\n\n----------------------------------------\n\nTITLE: Adding a `HttpMonitor` Instance for `http://example.com` in Container\nDESCRIPTION: Configures the dependency injection container to include a factory provider `example_monitor` for `HttpMonitor`, passing HTTP method, URL, timeout, and check interval from configuration. This monitor is injected into the dispatcher’s monitor list for periodic health checks on `http://example.com`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nimport logging\nimport sys\n\nfrom dependency_injector import containers, providers\n\nfrom . import http, monitors, dispatcher\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    logging = providers.Resource(\n        logging.basicConfig,\n        stream=sys.stdout,\n        level=config.log.level,\n        format=config.log.format,\n    )\n\n    http_client = providers.Factory(http.HttpClient)\n\n    example_monitor = providers.Factory(\n        monitors.HttpMonitor,\n        http_client=http_client,\n        options=config.monitors.example,\n    )\n\n    dispatcher = providers.Factory(\n        dispatcher.Dispatcher,\n        monitors=providers.List(\n            example_monitor,\n        ),\n    )\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from YAML File Using Dependency Injector in Python\nDESCRIPTION: Shows how to load configuration from a YAML file using the from_yaml method of the Configuration provider. Supports environment variable interpolation within YAML configuration files. Users can specify a custom YAML loader with the loader argument. YAML loading depends on the PyYAML package, which must be installed separately or via the dependency-injector[yaml] extra.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"./config.yml\"])\n\n\nif __name__ == \"__main__\":\n    container = Container()  # Config is loaded from ./config.yml\n```\n\n----------------------------------------\n\nTITLE: Initializing Dict Provider with Non-String and Special Character Keys in Python\nDESCRIPTION: This Python snippet shows how to initialize the Dict provider using a dictionary passed as a positional argument, enabling the use of non-string keys and string keys that contain periods or dashes. This approach is necessary when dictionary keys do not conform to standard Python identifier rules. Usage requires the dependency_injector library and pre-defined provider objects for constructing dependencies. The result is a provider that handles diverse keys for flexible dependency injection.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/dict.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nproviders.Dict({\n    SomeClass: providers.Factory(...),\n    \"key.with.periods\": providers.Factory(...),\n    \"key-with-dashes\": providers.Factory(...),\n})\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: flake8-pyproject (Python)\nDESCRIPTION: Includes 'flake8-pyproject', a plugin that allows flake8 configuration to be read from the pyproject.toml file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_7\n\nLANGUAGE: Python requirements\nCODE:\n```\nflake8-pyproject\n```\n\n----------------------------------------\n\nTITLE: Running the Python Dependency Injector Example Application\nDESCRIPTION: Command to execute the example application with parameters for user email, authentication token, and photo file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-single-container/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m example user@example.com secret photo.jpg\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from JSON File Using Dependency Injector in Python\nDESCRIPTION: Demonstrates loading configuration from a JSON file with from_json method of the Configuration provider. Supports environment variable interpolation inside JSON string values. JSON file paths can also be passed during container provider declaration for automatic loading.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(json_files=[\"./config.json\"])\n\n\nif __name__ == \"__main__\":\n    container = Container()  # Config is loaded from ./config.json\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging using INI\nDESCRIPTION: Reference to the INI file `logging.ini`. This file configures Python's standard logging framework, defining loggers, handlers, and formatters, typically loaded via `logging.config.fileConfig()`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n# Source: examples/miniapps/application-single-container/logging.ini\n# Defines logging configuration using standard INI format.\n# [loggers]\n# keys=root,example\n# [handlers]\n# keys=consoleHandler\n# ...\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Coverage Using pytest in Bash\nDESCRIPTION: This snippet shows the command to run unit tests for the application using pytest with coverage measurement enabled for the giphynavigator module. The command triggers test discovery and execution, generating a code coverage report to assess test completeness. It requires pytest and pytest-cov to be installed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npy.test giphynavigator/tests.py --cov=giphynavigator\n```\n\n----------------------------------------\n\nTITLE: Run Flask Development Server - Bash\nDESCRIPTION: Sets the necessary environment variables `FLASK_APP` to point to the application entry point and `FLASK_ENV` to 'development' for debugging. It then starts the Flask development server, making the application accessible locally.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport FLASK_APP=githubnavigator.application\nexport FLASK_ENV=development\nflask run\n```\n\n----------------------------------------\n\nTITLE: Example Successful API Response in JSON\nDESCRIPTION: This JSON snippet shows the expected response body from a successful request to the application's root endpoint. It includes the query parameters and a list of retrieved Giphy URLs.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Length: 492\nContent-Type: application/json; charset=utf-8\nDate: Fri, 09 Oct 2020 01:35:48 GMT\nServer: Python/3.10 aiohttp/3.6.2\n\n{\n    \"gifs\": [\n        {\n            \"url\": \"https://giphy.com/gifs/dollyparton-3xIVVMnZfG3KQ9v4Ye\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/tennistv-unbelievable-disbelief-cant-believe-UWWJnhHHbpGvZOapEh\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/discoverychannel-nugget-gold-rush-rick-ness-KGGPIlnC4hr4u2s3pY\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/soulpancake-wow-work-xUe4HVXTPi0wQ2OAJC\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/readingrainbow-teamwork-levar-burton-reading-rainbow-3o7qE1EaTWLQGDSabK\"\n        }\n    ],\n    \"limit\": 5,\n    \"query\": \"wow,it works\"\n}\n```\n\n----------------------------------------\n\nTITLE: Python Package Dependencies\nDESCRIPTION: This snippet lists the required Python packages. It includes 'dependency-injector' (the core library), 'aiohttp' (for asynchronous web tasks), 'pyyaml' (for YAML configuration), and several 'pytest' related packages ('pytest', 'pytest-asyncio', 'pytest-cov') used for testing the project.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/asyncio-daemon/requirements.txt#_snippet_0\n\nLANGUAGE: Configuration\nCODE:\n```\ndependency-injector\naiohttp\npyyaml\npytest\npytest-asyncio\npytest-cov\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pyyaml (Python)\nDESCRIPTION: Adds 'pyyaml', a YAML parser and emitter for Python. It's used for reading and writing data in the YAML format.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_12\n\nLANGUAGE: Python requirements\nCODE:\n```\npyyaml\n```\n\n----------------------------------------\n\nTITLE: Restricting Provider Types in DeclarativeContainer (Python)\nDESCRIPTION: Demonstrates how to specialize a DeclarativeContainer by setting the `provider_type` class attribute. This enforces that all providers defined within the container must be subtypes of the specified `ServiceProvider`. An attempt to define a provider of an incompatible type (like `providers.Factory(dict)`) will result in an error.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/specialization.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# examples/containers/declarative_provider_type.py\nimport abc\n\nfrom dependency_injector import containers, providers\n\n\n# Define an abstract base class for specific provider types\nclass ServiceProvider(providers.Provider):\n    __metaclass__ = abc.ABCMeta\n\n\n# Concrete provider types inheriting from the base\nclass SingletonServiceProvider(ServiceProvider, providers.Singleton):\n    pass\n\n\nclass FactoryServiceProvider(ServiceProvider, providers.Factory):\n    pass\n\n\n# Example service class\nclass Service:\n    pass\n\n\n# Declarative container with provider type restriction\nclass Container(containers.DeclarativeContainer):\n\n    provider_type = ServiceProvider  # Enforce provider type\n\n    provider1 = SingletonServiceProvider(Service)\n    provider2 = FactoryServiceProvider(Service)\n\n    # The following line, if added, would cause a TypeError\n    # other_provider = providers.Factory(dict)\n\n\n# --- Usage Example (not shown in original emphasis) ---\n# container = Container()\n# assert isinstance(container.provider1, SingletonServiceProvider)\n# assert isinstance(container.provider2, FactoryServiceProvider)\n```\n\n----------------------------------------\n\nTITLE: Implementing Callable Provider for Dependency Injection in Python\nDESCRIPTION: This code demonstrates how to create and use a Callable provider that manages dependency injection by calling functions, methods, or other callables. The example illustrates the provider's setup and usage, emphasizing its similarity to factory providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/callable.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport dependency_injector.providers as providers\n\n# Creating a Callable provider that injects dependencies into a function\ndef my_function(dep):\n    print(f\"Dependency value: {dep}\")\n\ncallable_provider = providers.Callable(my_function, dep='Injected Dependency')\n\n# Calling the provider executes the function with injected dependencies\ncallable_provider()\n```\n\n----------------------------------------\n\nTITLE: Creating Coroutine Providers with Dependency Injector in Python\nDESCRIPTION: Demonstrates how to define and use a Coroutine provider from the dependency_injector.providers module to create and manage asynchronous functions in Python. Suitable for Python 3.7+ due to its native support for async/await syntax, this snippet ensures injected dependencies are handled similarly to factory providers. Requires dependency-injector and asyncio library. Inputs should be async-compatible, outputs are async coroutine results; loop.run_until_complete() may be needed for Python versions earlier than 3.7.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/coroutine.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Example from ../../examples/providers/coroutine.py\nimport asyncio\nfrom dependency_injector import providers, containers\n\nasync def example_coroutine(service):\n    result = await service.run_async()\n    return result\n\nclass Service:\n    async def run_async(self):\n        await asyncio.sleep(1)\n        return 'done'\n\nclass Container(containers.DeclarativeContainer):\n    service = providers.Singleton(Service)\n    coroutine = providers.Coroutine(example_coroutine, service)\n\nif __name__ == '__main__':\n    container = Container()\n    loop = asyncio.get_event_loop()\n    # For Python 3.7+\n    result = loop.run_until_complete(container.coroutine())\n    print(result)\n\n```\n\n----------------------------------------\n\nTITLE: Defining Dependency Injection Containers (containers.py)\nDESCRIPTION: This referenced Python file (`example/containers.py`) defines the dependency injection containers using `python-dependency-injector`. It likely includes an `Adapters` container and an `Application` container which uses `DependenciesContainer` to link adapters to use cases, enabling loose coupling. The actual code is external.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Specifying Dependency: fastapi (Python)\nDESCRIPTION: Adds 'fastapi', a modern, fast (high-performance) web framework for building APIs with Python 3.7+ based on standard Python type hints.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_14\n\nLANGUAGE: Python requirements\nCODE:\n```\nfastapi\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: scipy (Python)\nDESCRIPTION: Adds 'scipy', a library used for scientific and technical computing. It builds on NumPy and provides modules for optimization, linear algebra, integration, etc.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_17\n\nLANGUAGE: Python requirements\nCODE:\n```\nscipy\n```\n\n----------------------------------------\n\nTITLE: Generator Initializer for Resource Provider in Python\nDESCRIPTION: Implements a resource provider using a generator function for 2-step initialization and shutdown. The first yield statement marks the end of initialization and can return a resource object.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef init_resource(argument1=..., argument2=...):\n    resource = SomeResource()  # initialization\n\n    yield resource\n\n    # shutdown\n    ...\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        init_resource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Set Github Personal Access Token - Bash\nDESCRIPTION: Sets the `GITHUB_TOKEN` environment variable to a personal access token generated on Github. This token is used by the application to authenticate with the Github API, significantly increasing the hourly request rate limit from 60 to 5000 for authenticated requests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport GITHUB_TOKEN=<your token>\n```\n\n----------------------------------------\n\nTITLE: Creating Search Service File in Bash\nDESCRIPTION: This snippet shows the project structure and highlights the creation of a new file, 'services.py', where the SearchService class will be defined. This file will contain the business logic for performing Giphy searches.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── giphynavigator/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── giphy.py\n│   ├── handlers.py\n│   └── services.py\n├── venv/\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Aggregating Multiple Factory Providers with FactoryAggregate (Python)\nDESCRIPTION: This snippet demonstrates the aggregation of multiple factories under a single FactoryAggregate provider. Factories can be registered with string or non-string keys, and the aggregate can be called with a specific key to select the factory at runtime. The aggregation enables modular assembly, dictionary-like provider access, and attribute access to aggregated factories. Dependencies include dependency_injector, with the aggregate pattern facilitating selection by key and extended dictionary operations.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_aggregate.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 33-37,47\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Async Giphy API Client - Python\nDESCRIPTION: Defines an asynchronous GiphyClient class that interacts with the Giphy API using aiohttp. The client is initialized with an API key and request timeout, and exposes a search method to perform GIF searches. Dependencies are aiohttp.ClientSession and an external API key. Input parameters include the search query and result limit. The output is the raw JSON response from the Giphy API, and errors are raised if the response is unsuccessful.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Giphy client module.\"\"\"\n\nfrom aiohttp import ClientSession, ClientTimeout\n\n\nclass GiphyClient:\n\n    API_URL = \"https://api.giphy.com/v1\"\n\n    def __init__(self, api_key, timeout):\n        self._api_key = api_key\n        self._timeout = ClientTimeout(timeout)\n\n    async def search(self, query, limit):\n        \"\"\"Make search API call and return result.\"\"\"\n        url = f\"{self.API_URL}/gifs/search\"\n        params = {\n            \"q\": query,\n            \"api_key\": self._api_key,\n            \"limit\": limit,\n        }\n        async with ClientSession(timeout=self._timeout) as session:\n            async with session.get(url, params=params) as response:\n                if response.status != 200:\n                    response.raise_for_status()\n                return await response.json()\n```\n\n----------------------------------------\n\nTITLE: Installing Requirements from requirements.txt\nDESCRIPTION: Command to install the required dependencies for the example application using pip and the requirements.txt file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-multiple-containers/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment Using Bash - Python\nDESCRIPTION: Creates a Python virtual environment for dependency isolation using the 'virtualenv' tool and activates it. Required dependency: virtualenv must be installed. 'venv' is the environment folder, and the activation step ensures all subsequent package installations are local to this environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/aiohttp/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies (Bash)\nDESCRIPTION: Uses the `pip` package installer to install Python dependencies listed in the `requirements.txt` file into the currently active virtual environment. This command assumes a `requirements.txt` file exists in the current directory.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/starlette-lifespan/README.rst#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies - Bash\nDESCRIPTION: This Bash command instructs the user to install the Python packages listed in the `requirements.txt` file using the `pip` package installer.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Implementing Chained Factories Pattern with Dependency Injector in Python\nDESCRIPTION: This snippet illustrates how to create a chain of Factory providers that wraps a class constructor, adding additional arguments through nested factories. It demonstrates wrapping a class with a base factory, then wrapping that factory to inject more arguments, simulating the Chained Factories pattern.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/chained-factories.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n   base_factory = providers.Factory(\n       SomeClass,\n       base_argument=1,\n   )\n\n   concrete_factory = providers.Factory(\n       base_factory,\n       extra_argument=2,\n   )\n\n\n   if __name__ == \"__main__\":\n       instance = concrete_factory()\n       # Same as: # instance = SomeClass(base_argument=1, extra_argument=2)\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Python Virtual Environment (Bash)\nDESCRIPTION: Provides shell commands to create an isolated Python virtual environment named 'env' using the built-in `venv` module and then activate it for the current shell session. This is a standard prerequisite for managing project dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/starlette-lifespan/README.rst#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\npython -m venv env\n. env/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Running Pytest Unit Tests with Coverage (Bash)\nDESCRIPTION: This command executes the unit tests located in `githubnavigator/tests.py` using the `pytest` framework. The `--cov=githubnavigator` flag is used with the `pytest-cov` plugin to measure and report code coverage for the `githubnavigator` package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npy.test githubnavigator/tests.py --cov=githubnavigator\n```\n\n----------------------------------------\n\nTITLE: Pinning Dependency Injector Version in Requirements Files\nDESCRIPTION: This snippet advises on pinning the Dependency Injector version in project dependency files such as pyproject.toml or requirements.txt. It recommends restricting updates to major versions to avoid incompatibility issues in future releases.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/installation.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndependency-injector>=4.0,<5.0\n```\n\n----------------------------------------\n\nTITLE: Setting Up the Dependency Injector Container - Python\nDESCRIPTION: This code defines the application's IoC container using the dependency-injector framework. The container is currently empty but serves as the foundation for registering providers and managing dependencies. The class extends DeclarativeContainer. There are no required inputs at this stage, and no constraints other than requiring dependency_injector to be installed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers\n\n\nclass Container(containers.DeclarativeContainer):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Running the Sanic Application with Environment Variable in Bash\nDESCRIPTION: This snippet illustrates how to set the required GIPHY_API_KEY environment variable and run the Sanic application via command line. Setting the environment variable ensures the application can authenticate API requests to Giphy. The Sanic command launches the application factory create_app within the giphynavigator.application module, exposing the REST API.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport GIPHY_API_KEY=wBJ2wZG7SRqfrU9nPgPiWvORmloDyuL0\nsanic giphynavigator.application:create_app\n```\n\n----------------------------------------\n\nTITLE: Creating a Virtual Environment in Bash\nDESCRIPTION: Commands to create and activate a Python virtual environment for isolating the application dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-multiple-containers/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Implementing Movie Lister Class in Python\nDESCRIPTION: Defines a MovieLister class that depends on a MovieFinder to retrieve and filter movies by director or release year.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Movie listers module.\"\"\"\n\nfrom .finders import MovieFinder\n\n\nclass MovieLister:\n\n    def __init__(self, movie_finder: MovieFinder):\n        self._movie_finder = movie_finder\n\n    def movies_directed_by(self, director):\n        return [\n            movie for movie in self._movie_finder.find_all()\n            if movie.director == director\n        ]\n\n    def movies_released_in(self, year):\n        return [\n            movie for movie in self._movie_finder.find_all()\n            if movie.year == year\n        ]\n\n```\n\n----------------------------------------\n\nTITLE: Defining Application Configuration - YAML\nDESCRIPTION: This YAML snippet shows a sample `config.yml` file used for application configuration. It defines settings like the `request_timeout` for GitHub API calls and default values (`query`, `limit`) that are injected into the Flask views via the Dependency Injector container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_23\n\nLANGUAGE: yaml\nCODE:\n```\ngithub:\n  request_timeout: 10\ndefault:\n  query: \"Dependency Injector\"\n  limit: 10\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Interpolation Example (INI/Python)\nDESCRIPTION: Illustrates how environment variable interpolation happens before parsing. An INI configuration file with an environment variable placeholder is shown before and after interpolation when the variable is undefined. A Python snippet demonstrates that the resulting value after YAML parsing is `None`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_14\n\nLANGUAGE: ini\nCODE:\n```\nsection:\n  option: ${ENV_NAME}\n```\n\nLANGUAGE: ini\nCODE:\n```\nsection:\n  option:\n```\n\nLANGUAGE: python\nCODE:\n```\nassert container.config.section.option() is None\n```\n\n----------------------------------------\n\nTITLE: Displaying Flask Application Structure using Bash\nDESCRIPTION: This Bash snippet outlines the directory and file structure for the example Flask application (`githubnavigator`). It shows the organization of templates, source files (application, containers, services, views, tests), configuration (`config.yml`), and dependencies (`requirements.txt`).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/flask.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── githubnavigator/\n│   ├── templates\n│   │   ├── base.html\n│   │   └── index.py\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── services.py\n│   ├── tests.py\n│   └── views.py\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Example Pytest Test Output\nDESCRIPTION: Sample console output generated after running the unit tests with `pytest` and the coverage plugin. It shows the test execution progress (passing tests indicated by '...') and concludes with a coverage summary table, listing the percentage of code covered by tests for each module in the `giphynavigator` package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nplatform linux -- Python 3.12.3, pytest-8.3.2, pluggy-1.5.0\nplugins: cov-6.0.0, anyio-4.4.0, asyncio-0.24.0, aiohttp-1.0.5\nasyncio: mode=Mode.STRICT, default_loop_scope=None\n\ngiphynavigator/tests.py ...                                     [100%]\n\n---------- coverage: platform darwin, python 3.10.0-final-0 ----------\nName                            Stmts   Miss  Cover\n---------------------------------------------------\ngiphynavigator/__init__.py          0      0   100%\ngiphynavigator/application.py      11      0   100%\ngiphynavigator/containers.py        7      0   100%\ngiphynavigator/endpoints.py        20      0   100%\ngiphynavigator/giphy.py            14      9    36%\ngiphynavigator/services.py          9      1    89%\ngiphynavigator/tests.py            37      0   100%\n---------------------------------------------------\nTOTAL                              98     10    90%\n```\n\n----------------------------------------\n\nTITLE: Defining Database Utilities with SQLAlchemy Declarative Base and Session Factory in Python\nDESCRIPTION: Sets up the SQLAlchemy declarative base class, engine creation, and session factory encapsulated in a utility class. This module handles low-level database configuration and session management needed throughout the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/database.py defining base, engine, and sessions\n```\n\n----------------------------------------\n\nTITLE: Displaying Aiohttp Project Structure in Bash\nDESCRIPTION: This Bash snippet shows the directory and file layout for the example Giphy Navigator Aiohttp application. It illustrates the organization of components like containers, handlers, services, configuration, and tests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/aiohttp.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── giphynavigator/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── giphy.py\n│   ├── handlers.py\n│   ├── services.py\n│   └── tests.py\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment for Python Dependency Injector Example\nDESCRIPTION: Commands to create and activate a Python virtual environment for isolating the application dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-single-container/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Expected Pytest Output with Coverage - Text\nDESCRIPTION: Displays the typical console output when unit tests are run successfully using `pytest` with the coverage plugin. It shows the test execution progress (e.g., '..'), the test results summary, and a detailed coverage report showing the percentage of code covered per file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\nplatform linux -- Python 3.12.3, pytest-8.3.2, pluggy-1.5.0\nplugins: cov-6.0.0, flask-1.3.0\nasyncio: mode=Mode.STRICT, default_loop_scope=None\ncollected 2 items\n\ngithubnavigator/tests.py ..                                     [100%]\n\n---------- coverage: platform darwin, python 3.10.0-final-0 ----------\nName                             Stmts   Miss  Cover\n----------------------------------------------------\ngithubnavigator/__init__.py          0      0   100%\ngithubnavigator/application.py      13      0   100%\ngithubnavigator/containers.py        8      0   100%\ngithubnavigator/services.py         14      0   100%\ngithubnavigator/tests.py            34      0   100%\ngithubnavigator/views.py            10      0   100%\n----------------------------------------------------\nTOTAL                               79      0   100%\n```\n\n----------------------------------------\n\nTITLE: Creating a Dockerfile for the Monitoring Daemon - Bash\nDESCRIPTION: Defines a Dockerfile to build the monitoring daemon container using the official Python 3.13 image. It sets the working directory, copies source code, installs dependencies listed in requirements.txt, and configures the container to launch the monitoring daemon as a module. Dependencies: Docker must be installed; the requirements.txt file and the monitoringdaemon package must exist. The resulting container is ready to run the monitoring service.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nFROM python:3.13-bookworm\n\nENV PYTHONUNBUFFERED=1\n\nWORKDIR /code\nCOPY . /code/\n\nRUN apt-get install openssl \\\n && pip install --upgrade pip \\\n && pip install -r requirements.txt \\\n && rm -rf ~/.cache\n\nCMD [\"python\", \"-m\", \"monitoringdaemon\"]\n```\n\n----------------------------------------\n\nTITLE: Listing Application Directory Structure in Bash\nDESCRIPTION: Shows the file and directory layout of the Sanic example application using a bash code block. This structure defines the organization of the app into modules such as containers.py, handlers.py, services.py, and tests.py, plus configuration and requirements files. Understanding this structure is essential for navigating and extending the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/sanic.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── giphynavigator/\n│   ├── __init__.py\n│   ├── __main__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── giphy.py\n│   ├── handlers.py\n│   ├── services.py\n│   └── tests.py\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Running the Example Script - Bash\nDESCRIPTION: Executes the main example script using the Python interpreter associated with the activated virtual environment. This runs the code demonstrating the decoupled packages.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/decoupled-packages/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython -m example\n```\n\n----------------------------------------\n\nTITLE: Attribute Injection with Factory Provider in dependency_injector (Python)\nDESCRIPTION: This snippet covers using the add_attributes() method with Factory providers to inject attributes into created objects. Attribute injections complement constructor arguments, allowing finer-grained dependency placement post-instantiation. Requires Python and dependency_injector; supports attribute key-value pairs for additional configuration. Dependencies can be any values or providers that resolve at creation time.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_attribute_injections.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 18-18\n\n```\n\n----------------------------------------\n\nTITLE: Setting Up Basic YAML Configuration\nDESCRIPTION: Defines configuration values for the CSV movie finder, including file path and delimiter settings.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_7\n\nLANGUAGE: yaml\nCODE:\n```\nfinder:\n\n  csv:\n    path: \"data/movies.csv\"\n    delimiter: \",\"\n\n```\n\n----------------------------------------\n\nTITLE: Running the Password Hashing Example with Python\nDESCRIPTION: Command to execute the password hashing example application that demonstrates Callable provider injection using dependency-injector. The example is contained in example.py.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/password-hashing/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython example.py\n```\n\n----------------------------------------\n\nTITLE: Checking Docker and Docker Compose Versions - Bash\nDESCRIPTION: Checks that required versions of Docker and Docker Compose are installed by running command-line queries. These commands should be executed in a terminal before proceeding with the tutorial to ensure that containerization prerequisites are satisfied. Docker and Docker Compose must be installed and accessible via the command line for proper setup.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker --version\ndocker compose version\n```\n\n----------------------------------------\n\nTITLE: Main container class for dependency injection setup (Python)\nDESCRIPTION: Defines a declarative dependency injection container using the 'dependency-injector' library, which will hold all application components, such as factories and singletons, to manage dependencies centrally.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers\n\n\nclass Container(containers.DeclarativeContainer):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Running the Password Hashing Example (Bash)\nDESCRIPTION: This command executes the Python script containing the password hashing example. Running this command will demonstrate the functionality implemented in 'example.py'.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/password-hashing.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython example.py\n```\n\n----------------------------------------\n\nTITLE: Activating Python Virtual Environment (Bash)\nDESCRIPTION: This command sources the activation script for the 'venv' virtual environment. Activating the environment modifies the shell's PATH so that commands like `python` and `pip` refer to the executables within the virtual environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Defining an Asynchronous Service with Redis Dependency in Python\nDESCRIPTION: Implements an example `Service` class in `services.py` that depends on an `aioredis.Redis` connection pool, injected during initialization. It provides asynchronous methods `process` to set a key-value pair in Redis and `get` to retrieve the value associated with a key.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n\"Services module.\"\n\nimport uuid\n\nimport aioredis\n\n\nclass Service:\n    \"\"\"Service that works with redis.\n\n    Service has a dependency on redis connection pool. It uses it for\n    setting and getting a key asynchronously.\n    \"\"\"\n\n    def __init__(self, redis: aioredis.Redis) -> None:\n        \"\"\"Initialize service.\n\n        Args:\n            redis (aioredis.Redis): Redis connection pool.\n        \"\"\"\n        self.redis = redis\n\n    async def process(self) -> str:\n        \"\"\"Set key in redis.\n\n        Returns:\n            str: Value of the key that was set.\n        \"\"\"\n        key = str(uuid.uuid4())\n        value = str(uuid.uuid4())\n        await self.redis.set(key, value, expire=60)\n        return value\n\n    async def get(self, key: str) -> str | None:\n        \"\"\"Get key from redis.\n\n        Args:\n            key (str): Key to get.\n\n        Returns:\n            str | None: Value of the key or None if key does not exist.\n        \"\"\"\n        return await self.redis.get(key)\n\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies in requirements.txt\nDESCRIPTION: Lists required Python packages for the application including Dependency Injector, Flask, Bootstrap-Flask, PyGithub, and PyYAML for configuration parsing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\ndependency-injector\nflask\nbootstrap-flask\npygithub\npyyaml\n```\n\n----------------------------------------\n\nTITLE: Running the Starlette Example Application (Bash)\nDESCRIPTION: Shows two alternative commands to run the Starlette application defined in `example.py`. The first command runs the script directly using Python, which might include custom logging configuration. The second uses `uvicorn`, a common ASGI server, with the `--factory` option to dynamically load the application instance (presumably `container.app`) from the `example` module.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/starlette-lifespan/README.rst#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\npython example.py\n# or (logging won't be configured):\nuvicorn --factory example:container.app\n```\n\n----------------------------------------\n\nTITLE: Creating Application Entry Point with Dependency Injection\nDESCRIPTION: Implements the main module with dependency wiring to inject the MovieLister from the container into the main function.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Main module.\"\"\"\n\nfrom dependency_injector.wiring import Provide, inject\n\nfrom .listers import MovieLister\nfrom .containers import Container\n\n\n@inject\ndef main(lister: MovieLister = Provide[Container.lister]) -> None:\n    print(\"Francis Lawrence movies:\")\n    for movie in lister.movies_directed_by(\"Francis Lawrence\"):\n        print(\"\\t-\", movie)\n\n    print(\"2016 movies:\")\n    for movie in lister.movies_released_in(2016):\n        print(\"\\t-\", movie)\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.wire(modules=[__name__])\n\n    main()\n\n```\n\n----------------------------------------\n\nTITLE: Sample pytest Output with Coverage Report\nDESCRIPTION: This snippet presents example output from running the pytest command with coverage, showing testing environment details, test collection and execution status (3 tests passed), and a coverage summary of individual files and overall project coverage percentage. It helps verify test success and coverage metrics.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_6\n\nLANGUAGE: \nCODE:\n```\nplatform linux -- Python 3.12.3, pytest-8.3.2, pluggy-1.5.0\nplugins: cov-6.0.0, anyio-4.4.0, asyncio-0.24.0\nasyncio: mode=Mode.STRICT, default_loop_scope=None\ncollected 3 items\n\ngiphynavigator/tests.py ...                                     [100%]\n\n---------- coverage: platform darwin, python 3.10.0-final-0 ----------\nName                            Stmts   Miss  Cover\n---------------------------------------------------\ngiphynavigator/__init__.py          0      0   100%\ngiphynavigator/__main__.py          4      4     0%\ngiphynavigator/application.py      10      0   100%\ngiphynavigator/containers.py        7      0   100%\ngiphynavigator/giphy.py            14      9    36%\ngiphynavigator/handlers.py         11      0   100%\ngiphynavigator/services.py          9      1    89%\ngiphynavigator/tests.py            39      0   100%\n---------------------------------------------------\nTOTAL                              94     14    85%\n```\n\n----------------------------------------\n\nTITLE: Disabling Automatic Wiring in Python\nDESCRIPTION: Shows how to configure wiring but disable the automatic wiring behavior, requiring manual calling of the wire() method.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    wiring_config = containers.WiringConfiguration(\n        modules=[\"yourapp.module1\"],\n        auto_wire=False,\n    )\n\n\nif __name__ == \"__main__\":\n    container = Container()  # container.wire() is NOT called automatically\n    container.wire()         # wire to \"yourapp.module1\"\n    ...\n```\n\n----------------------------------------\n\nTITLE: Initializing Dependency Injector Container in Python\nDESCRIPTION: Creates an initial, empty dependency injection container class `Container` in `containers.py`, inheriting from `dependency_injector.containers.DeclarativeContainer`. This container will later hold application components and manage their dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nfrom dependency_injector import containers\n\n\nclass Container(containers.DeclarativeContainer):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Example Daemon Log Output (Bash)\nDESCRIPTION: This snippet shows sample log output from the running monitoring daemon container. It demonstrates the dispatcher starting up and the HttpMonitors performing checks against configured URLs, including response codes, content lengths, and request times.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nStarting asyncio-daemon-tutorial_monitor_1 ... done\nAttaching to asyncio-daemon-tutorial_monitor_1\nmonitor_1  | [2020-08-08 18:09:08,540] [INFO] [Dispatcher]: Starting up\nmonitor_1  | [2020-08-08 18:09:08,618] [INFO] [HttpMonitor]: Check\nmonitor_1  |     GET http://example.com\nmonitor_1  |     response code: 200\nmonitor_1  |     content length: 648\nmonitor_1  |     request took: 0.077 seconds\nmonitor_1  | [2020-08-08 18:09:08,722] [INFO] [HttpMonitor]: Check\nmonitor_1  |     GET https://httpbin.org/get\nmonitor_1  |     response code: 200\nmonitor_1  |     content length: 310\nmonitor_1  |     request took: 0.18 seconds\nmonitor_1  | [2020-08-08 18:09:13,619] [INFO] [HttpMonitor]: Check\nmonitor_1  |     GET http://example.com\nmonitor_1  |     response code: 200\nmonitor_1  |     content length: 648\nmonitor_1  |     request took: 0.066 seconds\nmonitor_1  | [2020-08-08 18:09:13,681] [INFO] [HttpMonitor]: Check\nmonitor_1  |     GET https://httpbin.org/get\nmonitor_1  |     response code: 200\nmonitor_1  |     content length: 310\nmonitor_1  |     request took: 0.126 seconds\n```\n\n----------------------------------------\n\nTITLE: Creating Abstract Factory Providers in dependency_injector (Python)\nDESCRIPTION: This snippet illustrates using AbstractFactory providers for cases when the concrete implementation of a base class is not determined at container definition. An AbstractFactory restricts provided objects to a specified type and requires explicit override before use. It is based on Factory and has a usage pattern requiring dependency_injector. Dependencies include a base type, with the override pattern for dynamic binding.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/abstract_factory.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 34\n\n```\n\n----------------------------------------\n\nTITLE: Injecting Initialization Arguments with Factory Provider in dependency_injector (Python)\nDESCRIPTION: This snippet shows how Factory providers can manage complex object graphs by injecting dependencies at construction and passing context-specific arguments. It illustrates context argument appending, keyword argument precedence, and how to deeply nest dependencies for layered assembly. Requires Python and dependency_injector; suitable for scenarios where objects need runtime-specific values or differential parameterization at instantiation.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/factory.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/factory_init_injections.py\n   :language: python\n   :lines: 3-\n\n```\n\n----------------------------------------\n\nTITLE: Integrating with Flask using Dependency Injector in Python\nDESCRIPTION: Example showing how to integrate Python Dependency Injector with the Flask web framework by wiring container providers to Flask view functions.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\nfrom dependency_injector.wiring import inject, Provide\nfrom flask import Flask, request\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    api_client = providers.Singleton(\n        ApiClient,\n        api_key=config.api_key,\n        timeout=config.timeout,\n    )\n\n\napp = Flask(__name__)\ncontainer = Container()\ncontainer.config.api_key.from_env(\"API_KEY\", required=True)\ncontainer.config.timeout.from_env(\"TIMEOUT\", as_=int, default=5)\ncontainer.wire(modules=[__name__])\n\n\n@app.route(\"/\")\n@inject\ndef index(api_client: ApiClient = Provide[Container.api_client]):\n    query = request.args.get(\"query\", \"\")\n    return api_client.search(query=query)\n\n\nif __name__ == \"__main__\":\n    app.run()\n```\n\n----------------------------------------\n\nTITLE: Installing Project Requirements for Django + Dependency Injector\nDESCRIPTION: Command to install all the required Python packages listed in the requirements.txt file, including Django and Dependency Injector.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: flake8 (Python)\nDESCRIPTION: Adds 'flake8', a command-line utility for enforcing style guide compliance. It wraps PyFlakes, pycodestyle, and McCabe.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_6\n\nLANGUAGE: Python requirements\nCODE:\n```\nflake8\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Monitors (YAML)\nDESCRIPTION: This YAML snippet provides example configuration for the monitoring daemon. It defines logging format and level, and configuration sections for two specific monitors (`example` and `httpbin`). Each monitor's configuration includes the HTTP method, URL, timeout, and check interval.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_20\n\nLANGUAGE: yaml\nCODE:\n```\nlog:\n  level: \"INFO\"\n  format: \"[%(asctime)s] [%(levelname)s] [%(name)s]: %(message)s\"\n\nmonitors:\n\n  example:\n    method: \"GET\"\n    url: \"http://example.com\"\n    timeout: 5\n    check_every: 5\n\n  httpbin:\n    method: \"GET\"\n    url: \"https://httpbin.org/get\"\n    timeout: 5\n    check_every: 5\n```\n\n----------------------------------------\n\nTITLE: Resetting Singletons in Sub-Containers with Python Dependency Injector\nDESCRIPTION: This snippet illustrates resetting singletons not only in the main container but also in nested sub-containers such as providers.Container and providers.DependenciesContainer using the .reset_singletons() method. It shows the hierarchical effect of the reset operation, ensuring all singleton instances within nested containers are cleared. Requires Dependency Injector and container structure with sub-containers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/reset_singletons.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Subcontainer(containers.DeclarativeContainer):\n    sub_service = providers.Singleton(object)\n\nclass Container(containers.DeclarativeContainer):\n    subcontainer = providers.Container(Subcontainer)\n\ncontainer = Container()\ncontainer.subcontainer().sub_service()\ncontainer.reset_singletons()  # Resets all singletons including those in subcontainers\n```\n\n----------------------------------------\n\nTITLE: Overriding Dependency Injector Providers Declaratively with Decorator in Python\nDESCRIPTION: Shows how to use the @containers.override decorator to declaratively override providers in a Dependency Injector container. The decorator takes a target container as an argument, enabling providers in the decorated container to override those with matching names in the target. This approach is ideal for modular applications or extensions, as it allows dynamic behavior changes by importing modules without modifying application code. Requires dependency_injector and Python decorators knowledge. Providers are replaced by name and must match across containers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/overriding.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\n\nclass Service:\n    ...\n\nclass ExtensionService(Service):\n    ...\n\nclass MainContainer(containers.DeclarativeContainer):\n    service = providers.Singleton(Service)\n\n@containers.override(MainContainer)\nclass ExtensionContainer(containers.DeclarativeContainer):\n    service = providers.Singleton(ExtensionService)\n\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating Virtual Environment for Django Project\nDESCRIPTION: Commands to create a virtual environment named 'venv' and activate it for the Django application. This isolates the project dependencies from the system Python installation.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Setting Github Personal Access Token (Bash)\nDESCRIPTION: This command sets the `GITHUB_TOKEN` environment variable to your personal access token. This is necessary for authenticated requests to the Github API, significantly increasing the hourly rate limit compared to unauthenticated requests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nexport GITHUB_TOKEN=<your token>\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: tox (Python)\nDESCRIPTION: Adds 'tox', a generic virtual environment management and test automation tool. It's often used for checking packages in different Python environments.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_4\n\nLANGUAGE: Python requirements\nCODE:\n```\ntox\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Strict Mode (Python)\nDESCRIPTION: Illustrates how the `from_*` methods behave in strict mode, raising exceptions (`FileNotFoundError`, `ValueError`) if configuration files do not exist or required data (like environment variables or dictionary keys) is undefined.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(strict=True)\n\n\nif __name__ == \"__main__\":\n    container = Container()\n\n    try:\n        container.config.from_yaml(\"does-not_exist.yml\")  # raise exception\n    except FileNotFoundError:\n        ...\n\n    try:\n        container.config.from_ini(\"does-not_exist.ini\")  # raise exception\n    except FileNotFoundError:\n        ...\n\n    try:\n        container.config.from_pydantic(EmptySettings())  # raise exception\n    except ValueError:\n        ...\n\n    try:\n        container.config.from_env(\"UNDEFINED_ENV_VAR\")  # raise exception\n    except ValueError:\n        ...\n\n    try:\n        container.config.from_dict({})  # raise exception\n    except ValueError:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Expected Sanic Application Startup Log Output\nDESCRIPTION: This snippet shows a sample log output from starting the Sanic application, indicating the server is running and listening on http://0.0.0.0:8000, and the worker process has started successfully. It is an info-level log useful for confirming proper launch of the server.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_3\n\nLANGUAGE: \nCODE:\n```\n[2020-09-23 18:16:31 -0400] [48258] [INFO] Goin' Fast @ http://0.0.0.0:8000\n[2020-09-23 18:16:31 -0400] [48258] [INFO] Starting worker [48258]\n```\n\n----------------------------------------\n\nTITLE: Defining Project Dependencies in requirements.txt\nDESCRIPTION: Specifies the initial Python package dependencies (`dependency-injector` and `flask`) required for the project in the `requirements.txt` file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\ndependency-injector\nflask\n```\n\n----------------------------------------\n\nTITLE: Testing FastAPI Endpoints Using Provider Overriding - Python\nDESCRIPTION: Illustrates how to write tests for the FastAPI application using `pytest`. It specifically demonstrates `dependency_injector`'s provider overriding feature, showing how to use a context manager (`with container.provider.override(...)`) to replace production dependencies (like the `GiphyClient`) with mock objects during testing, ensuring isolated and predictable test execution.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Code included from ../../examples/miniapps/fastapi/giphynavigator/tests.py\n# Emphasized lines 29, 57, 72 likely highlight points of provider overriding or test setup.\n```\n\n----------------------------------------\n\nTITLE: Using Dependency Injector Framework in Python\nDESCRIPTION: Demonstrates how to use the Dependency Injector framework to manage dependencies. It creates a container with configuration and providers for ApiClient and Service, and uses the @inject decorator to automatically inject dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/di_in_python.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\nfrom dependency_injector.wiring import Provide, inject\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration()\n\n    api_client = providers.Singleton(\n        ApiClient,\n        api_key=config.api_key,\n        timeout=config.timeout,\n    )\n\n    service = providers.Factory(\n        Service,\n        api_client=api_client,\n    )\n\n\n@inject\ndef main(service: Service = Provide[Container.service]) -> None:\n    ...\n\n\nif __name__ == \"__main__\":\n    container = Container()\n    container.config.api_key.from_env(\"API_KEY\", required=True)\n    container.config.timeout.from_env(\"TIMEOUT\", as_=int, default=5)\n    container.wire(modules=[__name__])\n\n    main()  # <-- dependency is injected automatically\n\n    with container.api_client.override(mock.Mock()):\n        main()  # <-- overridden dependency is injected automatically\n```\n\n----------------------------------------\n\nTITLE: Using .reset_singletons() with a Context Manager in Python Dependency Injector\nDESCRIPTION: This snippet presents usage of the .reset_singletons() method within a Python context manager. It ensures singleton instances are reset both on entering and exiting the context, providing a scoped and controlled reset of singletons during a block of code execution. This pattern helps isolate singleton state changes to specific code segments. Requires Dependency Injector and container with singleton providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/reset_singletons.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import containers, providers\nfrom contextlib import contextmanager\n\nclass Container(containers.DeclarativeContainer):\n    service = providers.Singleton(object)\n\ncontainer = Container()\n\n@contextmanager\ndef reset_singletons_context(container):\n    container.reset_singletons()\n    try:\n        yield\n    finally:\n        container.reset_singletons()\n\nwith reset_singletons_context(container):\n    container.service()  # Singletons reset on enter and exit\n```\n\n----------------------------------------\n\nTITLE: Setting up Virtual Environment - Bash\nDESCRIPTION: Creates a standard Python virtual environment named 'venv' in the current directory and activates it. This isolates project dependencies from the system Python installation.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/decoupled-packages/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Error Handling for Undefined Environment Variables (INI/Python)\nDESCRIPTION: Demonstrates that in strict mode, environment variable interpolation raises a `ValueError` if it encounters an undefined variable without a default value within a configuration file (e.g., INI).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_21\n\nLANGUAGE: ini\nCODE:\n```\nsection:\n  option: ${UNDEFINED}\n```\n\nLANGUAGE: python\nCODE:\n```\n    try:\n        container.config.from_yaml(\"undefined_env.yml\")  # raise exception\n    except ValueError:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Defining Python Dependencies for Runtime and Testing\nDESCRIPTION: Specifies the necessary Python libraries for the project, typically used in a `requirements.txt` file. Runtime dependencies include `dependency-injector`, `fastapi`, `uvicorn`, and `redis` (version 4.2 or higher). Testing dependencies, marked by a comment, include `pytest`, `pytest-asyncio`, `pytest-cov`, and `httpx`. These packages can be installed using pip.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-redis/requirements.txt#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\ndependency-injector\nfastapi\nuvicorn\nredis>=4.2\n\n# For testing:\npytest\npytest-asyncio\npytest-cov\nhttpx\n```\n\n----------------------------------------\n\nTITLE: Blueprint View with Dependency Injection in Python\nDESCRIPTION: Implements a Flask blueprint that has dependencies on a search service and configuration options, injected via Wiring to facilitate separation of concerns and testability. This module defines HTTP route handlers using injected dependencies to process requests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/flask-blueprints.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Content of githubnavigator/blueprints/example.py\n# Defines Flask blueprint with dependency injection for search service and configs\nfrom flask import Blueprint, render_template, request\nfrom dependency_injector.wiring import inject, Provide\n\nexample_bp = Blueprint('example', __name__)\n\n@inject\n@example_bp.route('/', methods=['GET'])\ndef index(search_service=Provide['github_service'], config=Provide['config']):\n    query = request.args.get('q', '')\n    results = search_service.search_repositories(query) if query else []\n    return render_template('index.html', results=results, config=config)\n\n```\n\n----------------------------------------\n\nTITLE: Setting up Virtual Environment with Bash\nDESCRIPTION: This snippet demonstrates how to create and activate a Python virtual environment for isolating project dependencies using bash commands. It requires having virtualenv installed. The commands create a new virtual environment named \"venv\" and activate it for use in the current shell session. This prepares the environment for consistent dependency installation and package management.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: boto3 (Python)\nDESCRIPTION: Includes 'boto3', the Amazon Web Services (AWS) SDK for Python. It allows Python developers to write software that makes use of AWS services like S3, EC2, etc.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_18\n\nLANGUAGE: Python requirements\nCODE:\n```\nboto3\n```\n\n----------------------------------------\n\nTITLE: Extending Monitoring to `https://httpbin.org`\nDESCRIPTION: Adds configuration and container factory provider for a monitor targeting `https://httpbin.org`. The section updates the container setup to include a new monitor for HTTPS endpoint verification, leveraging the same `HttpMonitor` class and custom options. The configuration supports easy extension for additional URLs.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_18\n\nLANGUAGE: YAML\nCODE:\n```\nmonitors:\n\n  # Existing monitor settings\n\n  # New monitor for https://httpbin.org\n  httpbin:\n    method: \"GET\"\n    url: \"https://httpbin.org\"\n    timeout: 5\n    check_every: 5\n```\n\n----------------------------------------\n\nTITLE: Running the Example Application with Environment Variable - Python\nDESCRIPTION: Sets the environment variable 'GIPHY_API_KEY' and launches the 'giphynavigator.application' module as the main application. Dependencies: Python environment with required packages installed, Giphy API key (obtainable from Giphy documentation). Output: The REST API server listens for HTTP requests at http://0.0.0.0:8080/.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/aiohttp/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport GIPHY_API_KEY=wBJ2wZG7SRqfrU9nPgPiWvORmloDyuL0\npython -m giphynavigator.application\n```\n\n----------------------------------------\n\nTITLE: Expected Flask Startup Output - Text\nDESCRIPTION: This snippet shows the typical console output when the Flask development server successfully starts. It confirms the application file being served, the environment mode, debug status, and the local address where the application is running (http://127.0.0.1:5000/).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n* Serving Flask app \"githubnavigator.application\" (lazy loading)\n* Environment: development\n* Debug mode: on\n* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n* Restarting with fsevents reloader\n* Debugger is active!\n* Debugger PIN: 473-587-859\n```\n\n----------------------------------------\n\nTITLE: Resource Provider with Wiring and Closing in Flask Application\nDESCRIPTION: Integrates resource provider with wiring to implement per-function execution scope in a Flask application. The Closing marker ensures that the resource is shutdown after each function execution.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# This is a partial code snippet highlighted in the documentation\n# The full implementation would include Flask setup and more components\n@app.route(\"/\")\n@inject\ndef index(service: Closing[Service] = Provide[Container.service]):\n    return \"Hello, World!\"\n```\n\n----------------------------------------\n\nTITLE: Movie entity class representing a movie object (Python)\nDESCRIPTION: Defines the Movie class with attributes for title, year, and director, including a custom __repr__ method for readable string representations. This class models the core movie data used throughout the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Movie entities module.\"\"\"\n\n\nclass Movie:\n\n    def __init__(self, title: str, year: int, director: str):\n        self.title = str(title)\n        self.year = int(year)\n        self.director = str(director)\n\n    def __repr__(self):\n        return \"{0}(title={1}, year={2}, director={3})\".format(\n            self.__class__.__name__,\n            repr(self.title),\n            repr(self.year),\n            repr(self.director),\n        )\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pip (Python)\nDESCRIPTION: Adds 'pip', the standard package installer for Python. While usually available by default, explicitly listing it ensures a specific version or presence.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_10\n\nLANGUAGE: Python requirements\nCODE:\n```\npip\n```\n\n----------------------------------------\n\nTITLE: Creating Python Virtual Environment (Bash)\nDESCRIPTION: This command uses `virtualenv` to create a new, isolated Python environment named 'venv' in the current directory. This practice helps manage project-specific dependencies without conflicts with the system Python installation.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from INI File Using Dependency Injector in Python\nDESCRIPTION: Illustrates how to load configuration data from an INI file using the Configuration provider's from_ini method. Supports environment variable interpolation within the INI file for dynamic values. Alternatively, INI file paths can be passed when declaring the Configuration provider in a container to load configuration automatically.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(ini_files=[\"./config.ini\"])\n\n\nif __name__ == \"__main__\":\n    container = Container()  # Config is loaded from ./config.ini\n```\n\n----------------------------------------\n\nTITLE: Resource Subclass Initializer in Python\nDESCRIPTION: Creates a custom resource initializer by subclassing resources.Resource. This approach provides explicit init and shutdown methods for more complex resource management.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom dependency_injector import resources\n\n\nclass MyResource(resources.Resource):\n\n    def init(self, argument1=..., argument2=...) -> SomeResource:\n        return SomeResource()\n\n    def shutdown(self, resource: SomeResource) -> None:\n        # shutdown\n        ...\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        MyResource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Basic Module Import and Function Call in Python\nDESCRIPTION: Demonstrates a simple relative import of a module and calling a function from it.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/wiring.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom . import module\n\nmodule.fn()\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Environment Variables in Configuration (Python)\nDESCRIPTION: Demonstrates the default behavior of the Configuration provider where undefined environment variables without defaults are replaced with empty strings during interpolation. Also shows how to enforce variable existence by setting `envs_required=True` when loading configuration from a YAML file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_env_interpolation_os_default.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 12\n```\n\nLANGUAGE: python\nCODE:\n```\ncontainer.config.from_yaml(\"config.yml\", envs_required=True)\n```\n\n----------------------------------------\n\nTITLE: Container Definition in Python for Dependency Injection\nDESCRIPTION: Defines a declarative container in Python using Dependency Injector, outlining dependencies for the Flask application components such as services and configuration. This container manages dependency wiring, facilitating component injections across the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/flask-blueprints.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Content of githubnavigator/containers.py\n# Defines dependency injection container for the Flask app components\nimport dependency_injector.containers as containers\nimport dependency_injector.providers as providers\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    github_service = providers.Singleton(\n        GithubService,  # Presumed service class for GitHub interactions\n        token=config.github_token\n    )\n    app_settings = providers.Configuration()\n    # Additional dependencies can be wired here\n\n```\n\n----------------------------------------\n\nTITLE: Using ThreadSafeSingleton for Thread-Safe Singleton in Python\nDESCRIPTION: This snippet introduces `ThreadSafeSingleton` as a thread-safe variant of the singleton provider, suitable for multi-threaded environments, avoiding race conditions by ensuring only one instance is created per container. The code demonstrates its declaration and typical usage.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndependency_injector.providers.ThreadSafeSingleton\n\nthread_safe_singleton = dependency_injector.providers.ThreadSafeSingleton(SomeClass)\n\n# Inject and use in multi-threaded environment\ncontainer = dependency_injector.containers.Container()\ncontainer.thread_safe_service = thread_safe_singleton\n```\n\n----------------------------------------\n\nTITLE: Defining Application Structure for FastAPI-Redis Example in Bash\nDESCRIPTION: Displays the directory and file structure for the example FastAPI application using Redis and Dependency Injector. This layout organizes the project into distinct modules for the main application, container configuration, Redis utilities, services, and tests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-redis.rst#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n./\n├── fastapiredis/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── redis.py\n│   ├── services.py\n│   └── tests.py\n├── docker-compose.yml\n├── Dockerfile\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Resetting the Singleton Instance in Python\nDESCRIPTION: This code snippet explains how to reset a memorized singleton object by invoking its `reset()` method. Resetting clears the reference, allowing a fresh instance upon next access. The reset operation is also demonstrated within a context manager to automatically reset on entering and exiting the scope.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/singleton.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwith container.service.reset():\n    # The singleton instance is reset here\n    pass\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers Using override_providers() Method in Python\nDESCRIPTION: This snippet showcases how to override providers on an existing container instance using the override_providers() method, which accepts keyword arguments mapping provider names to alternative implementations. This dynamic override allows the container to return mock or substituted objects at runtime.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/declarative.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\n\ncontainer.override_providers(foo=mock.Mock(Foo), bar=mock.Mock(Bar))\n\nassert isinstance(container.foo(), mock.Mock)\nassert isinstance(container.bar(), mock.Mock)\n```\n\n----------------------------------------\n\nTITLE: Implementing Flask View with Dependency Injection - Python\nDESCRIPTION: This Python snippet defines a Flask view function `index` that demonstrates dependency injection using the `dependency_injector.wiring.inject` decorator and `dependency_injector.providers.Provide` provider. It injects a `SearchService` instance and configuration values (`default_query`, `default_limit`) from the application's Dependency Injector container. The view retrieves 'query' and 'limit' parameters from the request arguments, falling back to injected defaults, uses the search service to find repositories, and renders an HTML template ('index.html') with the results.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom .containers import Container\n\n\n@inject\ndef index(\n        search_service: SearchService = Provide[Container.search_service],\n        default_query: str = Provide[Container.config.default.query],\n        default_limit: int = Provide[Container.config.default.limit.as_int()],\n):\n    query = request.args.get(\"query\", default_query)\n    limit = request.args.get(\"limit\", default_limit, int)\n\n    repositories = search_service.search_repositories(query, limit)\n\n    return render_template(\n        \"index.html\",\n        query=query,\n        limit=limit,\n        repositories=repositories,\n    )\n```\n\n----------------------------------------\n\nTITLE: Example REST API JSON Response - Giphy Search Endpoint\nDESCRIPTION: Shows a sample JSON response from the REST API after performing a search for GIFs related to 'Dependency Injector'. The response includes query parameters, result limits, and a list of GIF objects containing their URLs. Inputs: HTTP request to the API; Outputs: structured JSON representing search results.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/aiohttp/README.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"query\": \"Dependency Injector\",\n    \"limit\": 10,\n    \"gifs\": [\n        {\n            \"url\": \"https://giphy.com/gifs/boxes-dependent-swbf2-6Eo7KzABxgJMY\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/depends-J56qCcOhk6hKE\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/web-series-ccstudios-bro-dependent-1lhU8KAVwmVVu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/TheBoysTV-friends-friend-weneedeachother-XxR9qcIwcf5Jq404Sx\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/netflix-a-series-of-unfortunate-events-asoue-9rgeQXbwoK53pcxn7f\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/black-and-white-sad-skins-Hs4YzLs2zJuLu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/always-there-for-you-i-am-here-PlayjhCco9jHBYrd9w\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/stream-famous-dollar-YT2dvOByEwXCdoYiA1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/i-love-you-there-for-am-1BhGzgpZXYWwWMAGB1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/life-like-twerk-9hlnWxjHqmH28\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Loading Configuration from a Literal Value Using Dependency Injector in Python\nDESCRIPTION: Example demonstrating usage of from_value method to load a single configuration value directly into the Configuration provider. Useful for injecting constants or simple values not sourced from external files or environment variables.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# Example usage (content omitted for brevity)\ncontainer.config.some_option.from_value(value)\n```\n\n----------------------------------------\n\nTITLE: Installing Dependency Injector via pip\nDESCRIPTION: This snippet demonstrates installing the Dependency Injector package from PyPI using pip, including handling of pre-compiled wheels for various operating systems and Python versions. It notes the compilation requirements if wheels are unavailable.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/introduction/installation.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install dependency-injector\n```\n\n----------------------------------------\n\nTITLE: Configuring Application with Container Wiring in Django App\nDESCRIPTION: In 'web/apps.py', the container is wired to the application's views module, enabling automatic injection of dependencies into view functions or classes. This configuration ensures that dependencies are properly injected according to the wiring rules, facilitating modular dependency management.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/django.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n.. literalinclude:: ../../examples/miniapps/django/web/apps.py\n   :language: python\n   :emphasize-lines: 13\n```\n\n----------------------------------------\n\nTITLE: Running Pytest for Coverage Reporting\nDESCRIPTION: Shows the bash command to run pytest over the movies/tests.py file and generate a coverage report for the movies package. Requires pytest and coverage to be installed and the test file located at 'movies/tests.py'. Inputs are test cases; output is coverage summary printed to terminal.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/cli.rst#_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\npytest movies/tests.py --cov=movies\n```\n\n----------------------------------------\n\nTITLE: Run Unit Tests with Coverage using Docker Compose\nDESCRIPTION: This command executes the unit tests located in `webapp/tests.py` using `pytest` within a temporary `webapp` container. It also generates a code coverage report for the `webapp` directory using the `--cov` flag.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose run --rm webapp py.test webapp/tests.py --cov=webapp\n```\n\n----------------------------------------\n\nTITLE: Requiring Specific Configuration Options with `.required()` (Python)\nDESCRIPTION: Demonstrates using the `.required()` modifier during injection to ensure a specific configuration option exists, raising an error if it's undefined. This can be used independently of the global strict mode setting.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_required.py\n   :language: python\n   :lines: 11-20\n   :emphasize-lines: 8-9\n```\n\n----------------------------------------\n\nTITLE: Implementing Giphy Search Service in Python\nDESCRIPTION: This Python class defines the SearchService responsible for executing Giphy searches. It depends on a GiphyClient instance, injected via its constructor, to perform the actual API call and formats the results.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Services module.\"\"\"\n\nfrom .giphy import GiphyClient\n\n\nclass SearchService:\n\n    def __init__(self, giphy_client: GiphyClient):\n        self._giphy_client = giphy_client\n\n    async def search(self, query, limit):\n        \"\"\"Search for gifs and return formatted data.\"\"\"\n        if not query:\n            return []\n\n        result = await self._giphy_client.search(query, limit)\n\n        return [{\"url\": gif[\"url\"]} for gif in result[\"data\"]]\n```\n\n----------------------------------------\n\nTITLE: Showing Test and Coverage Report Output - Bash\nDESCRIPTION: This Bash snippet displays the expected output after running the `pytest` command with coverage. It shows the test collection progress, the results of the tests (two passed), and the coverage report summary, indicating 100% coverage for all tested modules.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nplatform darwin -- Python 3.10.0, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\nplugins: cov-3.0.0, flask-1.2.0\ncollected 2 items\n\ngithubnavigator/tests.py ..                                     [100%]\n\n---------- coverage: platform darwin, python 3.10.0-final-0 ----------\nName                             Stmts   Miss  Cover\n----------------------------------------------------\ngithubnavigator/__init__.py          0      0   100%\ngithubnavigator/application.py      13      0   100%\ngithubnavigator/containers.py        8      0   100%\ngithubnavigator/services.py         14      0   100%\ngithubnavigator/tests.py            34      0   100%\ngithubnavigator/views.py            10      0   100%\n----------------------------------------------------\nTOTAL                               79      0   100%\n```\n\n----------------------------------------\n\nTITLE: Implementing the Application Entry Point in Python\nDESCRIPTION: Reference to the Python script `example/__main__.py`. This file acts as the main entry point, initializes and wires the dependency injection container, retrieves a service instance (`UserService`), and executes its core logic.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Source: examples/miniapps/application-single-container/example/__main__.py\n# Application entry point.\n# Initializes container, wires modules, gets service, runs logic.\n```\n\n----------------------------------------\n\nTITLE: Displaying Application Directory Structure Using Bash\nDESCRIPTION: Shows the overall directory layout of the FastAPI+SQLAlchemy example project, outlining the key modules and configuration files involved in the setup and deployment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── webapp/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── database.py\n│   ├── endpoints.py\n│   ├── models.py\n│   ├── repositories.py\n│   ├── services.py\n│   └── tests.py\n├── config.yml\n├── docker-compose.yml\n├── Dockerfile\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Pytest using Bash\nDESCRIPTION: Command to execute the project's unit tests located in `giphynavigator/tests.py` using the `pytest` framework. The `--cov=giphynavigator` flag is included to generate a code coverage report for the specified package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npy.test giphynavigator/tests.py --cov=giphynavigator\n```\n\n----------------------------------------\n\nTITLE: JSON File Example with Environment Variable Interpolation\nDESCRIPTION: Sample JSON configuration illustrating environment variable substitution with placeholders like \"${ENV_VAR}\" and optional default values \"${ENV_VAR:default}\" used within JSON string values to enable dynamic runtime substitution.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"section\": {\n        \"option1\": \"${ENV_VAR}\",\n        \"option2\": \"${ENV_VAR}/path\",\n        \"option3\": \"${ENV_VAR:default}\"\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Asynchronous `_run_monitor` Method for Monitor Checks\nDESCRIPTION: Defines an asynchronous static method `_run_monitor` that executes periodic monitor checks. It calculates the interval until the next check, runs the monitor's check method, handles exceptions, and waits asynchronously. Dependencies include `asyncio` and `time`. It is intended for scheduling monitor tasks within an asyncio event loop.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n@staticmethod\nasync def _run_monitor(monitor: Monitor) -> None:\n    def _until_next(last: float) -> float:\n        time_took = time.time() - last\n        return monitor.check_every - time_took\n\n    while True:\n        time_start = time.time()\n\n        try:\n            await monitor.check()\n        except asyncio.CancelledError:\n            break\n        except Exception:\n            monitor.logger.exception(\"Error executing monitor check\")\n\n        await asyncio.sleep(_until_next(last=time_start))\n```\n\n----------------------------------------\n\nTITLE: Expected Flask Development Server Output (Text)\nDESCRIPTION: This snippet shows the typical console output when the Flask development server starts successfully. It confirms that the application is running, specifies the environment and debug mode, and provides the local address to access the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n* Serving Flask app \"githubnavigator.application\" (lazy loading)\n* Environment: development\n* Debug mode: on\n* Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n* Restarting with fsevents reloader\n* Debugger is active!\n* Debugger PIN: 473-587-859\n```\n\n----------------------------------------\n\nTITLE: Setup Virtual Environment - Bash\nDESCRIPTION: Creates a Python virtual environment named `venv` in the current directory and then activates it for the current shell session. This isolates project dependencies, preventing conflicts with system-wide packages.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Using Custom Type Conversion for Configuration Values (Python)\nDESCRIPTION: Demonstrates using the `.as_(callback)` method to apply a custom conversion function to a configuration value before injection. The configuration value is passed as the first argument to the callback function.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_type_custom.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 18\n```\n\n----------------------------------------\n\nTITLE: Generator Initializer without Return Value in Python\nDESCRIPTION: Shows how to use a generator initializer without returning a resource object. This pattern is useful when the resource provider only needs to perform initialization and shutdown actions.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef init_resource(argument1=..., argument2=...):\n    # initialization\n    ...\n\n    yield\n\n    # shutdown\n    ...\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        init_resource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Install Project Dependencies - Bash\nDESCRIPTION: Installs all required Python packages listed in the `requirements.txt` file. This command should be executed within the activated virtual environment to ensure dependencies are installed locally.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Visualizing Example Project Structure\nDESCRIPTION: Displays the directory layout of the example application using a bash command representation, illustrating the separation of concerns into different Python modules like `adapters.py`, `containers.py`, and `usecases.py`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n\n./\n└── example/\n    ├── __init__.py\n    ├── __main__.py\n    ├── adapters.py\n    ├── containers.py\n    └── usecases.py\n\n```\n\n----------------------------------------\n\nTITLE: Using Asynchronous Resource Providers in Python\nDESCRIPTION: Demonstrates how to use asynchronous resource providers in an async context. Methods like __call__(), init(), and shutdown() must be awaited when working with async resources.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\n\nclass Container(containers.DeclarativeContainer):\n\n    connection = providers.Resource(init_async_connection)\n\n\nasync def main():\n    container = Container()\n    connection = await container.connection()\n    connection = await container.connection.init()\n    connection = await container.connection.shutdown()\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Creating Configuration Aliases (Python)\nDESCRIPTION: Illustrates how to use the Configuration provider as a context manager (`with container.config.set(...)`) to create temporary aliases for configuration options within a specific code block.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_alias.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 14,22\n```\n\n----------------------------------------\n\nTITLE: Dependency Injector Container for Logger and Dispatcher\nDESCRIPTION: Defines a `Container` class using `dependency_injector` to configure application resources including logging setup and the dispatcher factory. It utilizes configuration from a YAML file and sets up logging to stdout at specified levels and formats. The dispatcher is instantiated through a factory with monitor placeholders, preparing the application for task orchestration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Containers module.\"\"\"\n\nimport logging\nimport sys\n\nfrom dependency_injector import containers, providers\n\nfrom . import dispatcher\n\n\nclass Container(containers.DeclarativeContainer):\n\n    config = providers.Configuration(yaml_files=[\"config.yml\"])\n\n    logging = providers.Resource(\n        logging.basicConfig,\n        stream=sys.stdout,\n        level=config.log.level,\n        format=config.log.format,\n    )\n\n    dispatcher = providers.Factory(\n        dispatcher.Dispatcher,\n        monitors=providers.List(\n            # TODO: add monitors\n        ),\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Service Classes with Dependency Injection in Python\nDESCRIPTION: Defines service classes that receive their dependencies through constructor injection. Shows how to implement domain logic services with dependencies on database and AWS S3 components.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-multiple-containers.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n../../examples/miniapps/application-multiple-containers/example/services.py\n```\n\n----------------------------------------\n\nTITLE: Setting Flask Environment to Development (Bash)\nDESCRIPTION: This command sets the `FLASK_ENV` environment variable to `development`. This enables Flask's development features, such as the debugger and reloader, which are useful during the development phase.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport FLASK_ENV=development\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Generator Initializer in Python\nDESCRIPTION: Creates a resource provider with an asynchronous generator initializer for handling both async initialization and cleanup. This pattern is ideal for managing connection lifecycles.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nasync def init_async_resource(argument1=..., argument2=...):\n    connection = await connect()\n    yield connection\n    await connection.close()\n\n\nclass Container(containers.DeclarativeContainer):\n\n    resource = providers.Resource(\n        init_async_resource,\n        argument1=...,\n        argument2=...,\n    )\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode for Configuration (Python)\nDESCRIPTION: Shows how to initialize the Configuration provider in strict mode (`strict=True`). In strict mode, accessing any undefined configuration option raises an error.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n.. literalinclude:: ../../examples/providers/configuration/configuration_strict.py\n   :language: python\n   :lines: 3-\n   :emphasize-lines: 12\n```\n\n----------------------------------------\n\nTITLE: Installing Application Requirements Using Pip - Python\nDESCRIPTION: Installs all required Python dependencies for the project as specified in 'requirements.txt' using pip. Prerequisite: activate the virtual environment prior to running. Inputs: none (reads from requirements.txt). Output: all packages are installed locally in the virtual environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/aiohttp/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Individual Resource Initialization and Shutdown in Python\nDESCRIPTION: Demonstrates how to initialize and shutdown individual resources using the init() and shutdown() methods. This allows for more granular control over resource lifecycles.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/resource.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\ncontainer.thread_pool.init()\ncontainer.thread_pool.shutdown()\n```\n\n----------------------------------------\n\nTITLE: Calling Aggregated Providers by Key in Python\nDESCRIPTION: Shows how to call an aggregated provider by providing its key as a first argument with additional parameters. This allows accessing specific providers from the aggregate.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/aggregate.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nyaml_reader = container.config_readers(\"yaml\", \"./config.yml\", foo=...)\n```\n\n----------------------------------------\n\nTITLE: Filtering Traversed Providers by Type (Python)\nDESCRIPTION: Illustrates how to use the `types` argument with the `.traverse()` method to iterate only over providers of specific types. This example filters for `providers.Resource` instances within the container and prints them. Assumes `container` is an initialized `dependency_injector.containers.Container` instance and `providers` refers to `dependency_injector.providers`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/containers/traversal.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncontainer = Container()\n\nfor provider in container.traverse(types=[providers.Resource]):\n    print(provider)\n\n # <dependency_injector.providers.Resource(<function init_database at 0x10bd2cb80>) at 0x10d346b40>\n # <dependency_injector.providers.Resource(<function init_cache at 0x10be373a0>) at 0x10d346bc0>\n```\n\n----------------------------------------\n\nTITLE: Defining `HttpClient` for Asynchronous HTTP Requests\nDESCRIPTION: Creates an `HttpClient` class utilizing `aiohttp` to send asynchronous HTTP requests with specified method, URL, and timeout. The `request()` method manages the client session and returns the server response, enabling monitors to perform web resource checks with non-blocking I/O. Dependencies include `aiohttp`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Http client module.\"\"\"\n\nfrom aiohttp import ClientSession, ClientTimeout, ClientResponse\n\n\nclass HttpClient:\n\n    async def request(self, method: str, url: str, timeout: int) -> ClientResponse:\n        async with ClientSession(timeout=ClientTimeout(timeout)) as session:\n            async with session.request(method, url) as response:\n                return response\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies (Bash)\nDESCRIPTION: This command uses `pip`, the Python package installer, to read the list of required libraries from the `requirements.txt` file and install them into the currently active virtual environment. These packages are necessary for the application to function.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Retrieving Aggregated Provider by Attribute Name in Python\nDESCRIPTION: Demonstrates how to retrieve an aggregated provider by using its key as an attribute name, offering a more concise syntax for accessing specific providers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/aggregate.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nyaml_reader = container.config_readers.yaml(\"./config.yml\", foo=...)\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: numpy (Python)\nDESCRIPTION: Includes 'numpy', the fundamental package for scientific computing with Python, providing support for large, multi-dimensional arrays and matrices.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_16\n\nLANGUAGE: Python requirements\nCODE:\n```\nnumpy\n```\n\n----------------------------------------\n\nTITLE: Creating Tests File in Bash\nDESCRIPTION: This snippet shows the project structure and highlights the creation of a new file, 'tests.py', where the application's unit and integration tests will be written.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── giphynavigator/\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── giphy.py\n│   ├── handlers.py\n│   ├── services.py\n│   └── tests.py\n├── venv/\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pytest-asyncio (Python)\nDESCRIPTION: Includes 'pytest-asyncio', a pytest plugin that provides fixtures and markers to make it easier to test asyncio applications.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_3\n\nLANGUAGE: Python requirements\nCODE:\n```\npytest-asyncio\n```\n\n----------------------------------------\n\nTITLE: Setting Flask Application Entry Point (Bash)\nDESCRIPTION: This command sets the `FLASK_APP` environment variable to `githubnavigator.application`. Flask uses this variable to locate the main application instance when executing subcommands like `flask run`.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport FLASK_APP=githubnavigator.application\n```\n\n----------------------------------------\n\nTITLE: Run Unit Tests with Coverage - Bash\nDESCRIPTION: Executes the unit tests located in `githubnavigator/tests.py` using the `pytest` framework. The `--cov=githubnavigator` flag also enables code coverage analysis, measuring how much of the code in the `githubnavigator` package is exercised by the tests.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npy.test githubnavigator/tests.py --cov=githubnavigator\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies for Python Application\nDESCRIPTION: Command to install all the project dependencies specified in the requirements.txt file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-single-container/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pydocstyle (Python)\nDESCRIPTION: Adds 'pydocstyle', a static analysis tool for checking compliance of Python docstrings against style conventions.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_8\n\nLANGUAGE: Python requirements\nCODE:\n```\npydocstyle\n```\n\n----------------------------------------\n\nTITLE: Running Pytest Tests and Coverage - Bash\nDESCRIPTION: This Bash command executes the `pytest` tests located in `githubnavigator/tests.py`. The `--cov=githubnavigator` flag enables code coverage reporting using `pytest-cov`, targeting the `githubnavigator` package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\npy.test githubnavigator/tests.py --cov=githubnavigator\n```\n\n----------------------------------------\n\nTITLE: Creating SQLAlchemy User Model in Python\nDESCRIPTION: Declares an SQLAlchemy ORM model for user entities including attributes like ID and other relevant fields. This model defines the database table schema and serves as the base for data operations performed by the repository.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/fastapi-sqlalchemy.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nContents of webapp/models.py with user model definition\n```\n\n----------------------------------------\n\nTITLE: Creating Index Page Template Extending Base Layout\nDESCRIPTION: Defines the index page (`index.html`) which extends `base.html`. It sets the page title, creates a Bootstrap container, adds a heading, and includes a form with input fields for search query and limit. It uses Jinja2 templating for dynamic content like pre-filling the search query (`{{ query }}`), setting the selected limit (`{{ limit }}`), displaying the result count (`{{ repositories|length }}`), and iterating through `repositories` (though the loop body is incomplete) to display search results in a table.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_13\n\nLANGUAGE: HTML\nCODE:\n```\n{% extends \"base.html\" %}\n\n{% block title %}Github Navigator{% endblock %}\n\n{% block content %}\n<div class=\"container\">\n    <h1 class=\"mb-4\">Github Navigator</h1>\n\n    <form>\n        <div class=\"form-group form-row\">\n            <div class=\"col-10\">\n                <label for=\"search_query\" class=\"col-form-label\">\n                    Search for:\n                </label>\n                <input class=\"form-control\" type=\"text\" id=\"search_query\"\n                       placeholder=\"Type something to search on the GitHub\"\n                       name=\"query\"\n                       value=\"{{ query if query }}\">\n            </div>\n            <div class=\"col\">\n                <label for=\"search_limit\" class=\"col-form-label\">\n                    Limit:\n                </label>\n                <select class=\"form-control\" id=\"search_limit\" name=\"limit\">\n                    {% for value in [5, 10, 20] %}\n                    <option {% if value == limit %}selected{% endif %}>\n                        {{ value }}\n                    </option>\n                    {% endfor %}\n                </select>\n            </div>\n        </div>\n    </form>\n\n    <p><small>Results found: {{ repositories|length }}</small></p>\n\n    <table class=\"table table-striped\">\n        <thead>\n            <tr>\n                <th>#</th>\n                <th>Repository</th>\n                <th class=\"text-nowrap\">Repository owner</th>\n                <th class=\"text-nowrap\">Last commit</th>\n            </tr>\n        </thead>\n        <tbody>\n        {% for repository in repositories %} {{n}}\n            <tr>\n              <th>{{ loop.index }}</th>\n              <td><a href=\"{{ repository.url }}\">\n                  {{ repository.name }}</a>\n              </td>\n              <td><a href=\"{{ repository.owner.url }}\">\n                  <img src=\"{{ repository.owner.avatar_url }}\"\n                       alt=\"avatar\" height=\"24\" width=\"24\"/></a>\n                  <a href=\"{{ repository.owner.url }}\">\n                      {{ repository.owner.login }}</a>\n              </td>\n```\n\n----------------------------------------\n\nTITLE: Executing Dependency Injector Example via CLI\nDESCRIPTION: These commands illustrate how to run the provided example script (`example`) as a Python module from the command line. They pass environment arguments (`prod` or `test`) and an email address to the script, demonstrating different execution contexts or configurations handled by the dependency injection setup.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/use-cases/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m example prod example@example.com\n```\n\nLANGUAGE: bash\nCODE:\n```\npython -m example test example@example.com\n```\n\n----------------------------------------\n\nTITLE: Starting the Application with Docker Compose\nDESCRIPTION: Provides terminal commands and expected logs to start the application using `docker compose up`. The logs indicate startup, shutdown, and the dispatcher activity, confirming that the application skeleton operates correctly with the dispatcher starting and exiting gracefully due to no active monitoring tasks.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_12\n\nLANGUAGE: Bash\nCODE:\n```\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Running Flask Development Server (Bash)\nDESCRIPTION: This command starts the built-in Flask development server. It hosts the web application, making it accessible locally, typically at `http://127.0.0.1:5000/` by default.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nflask run\n```\n\n----------------------------------------\n\nTITLE: Implementation of Adapters (adapters.py)\nDESCRIPTION: This referenced Python module (`example/adapters.py`) contains concrete implementations of interfaces or abstract classes defined elsewhere (likely used by use cases). It provides different adapter sets, possibly for 'test' and 'prod' modes, handling external interactions like database access or sending emails. These adapters are intended to be injected via the DI container. The actual code is external.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Setting GitHub Personal Access Token as Environment Variable\nDESCRIPTION: Command to set a GitHub personal access token as an environment variable to increase the API rate limit from 60 to 5000 requests per hour.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nexport GITHUB_TOKEN=<your token>\n```\n\n----------------------------------------\n\nTITLE: Creating Flask View Function for GitHub Repository Search\nDESCRIPTION: Defines the index view function to handle search requests, retrieve query parameters, and render the index template with search results. This view will be the main entry point for the web application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"Views module.\"\"\"\n\nfrom flask import request, render_template\n\n\ndef index():\n    query = request.args.get(\"query\", \"Dependency Injector\")\n    limit = request.args.get(\"limit\", 10, int)\n\n    repositories = []\n\n    return render_template(\n        \"index.html\",\n        query=query,\n        limit=limit,\n        repositories=repositories,\n    )\n```\n\n----------------------------------------\n\nTITLE: Defining Application Services in Python\nDESCRIPTION: Reference to the Python module `example/services.py`. This file defines the application's services (`UserService`, `AuthService`), which receive dependencies like database connections and other services via their constructors (dependency injection).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Source: examples/miniapps/application-single-container/example/services.py\n# Contains service layer classes (e.g., UserService, AuthService).\n# Demonstrates dependency injection in constructors.\n```\n\n----------------------------------------\n\nTITLE: Implementation of Business Use Cases (usecases.py)\nDESCRIPTION: This referenced Python file (`example/usecases.py`) encapsulates the core business logic of the application. It defines classes or functions representing specific operations (like user signup), which depend on abstract interfaces (like database or email service adapters) provided through dependency injection at runtime. The actual code is external.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Integrating Bootstrap-Flask into Application Factory in Python\nDESCRIPTION: Modifies the `create_app` function in `application.py` to integrate the `Bootstrap-Flask` extension. It imports `Bootstrap` from `flask_bootstrap`, initializes it, and then calls `bootstrap.init_app(app)` to register the extension with the Flask application, enabling Bootstrap features.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\n\"\"\"Application module.\"\"\"\n\nfrom flask import Flask\nfrom flask_bootstrap import Bootstrap\n\nfrom .containers import Container\nfrom . import views\n\n\ndef create_app() -> Flask:\n    container = Container()\n\n    app = Flask(__name__)\n    app.container = container\n    app.add_url_rule(\"/\", \"index\", views.index)\n\n    bootstrap = Bootstrap()\n    bootstrap.init_app(app)\n\n    return app\n```\n\n----------------------------------------\n\nTITLE: Making a Test API Request using HTTPie in Bash\nDESCRIPTION: This Bash command uses the `httpie` tool to send a GET request to the running aiohttp application's root endpoint ('/'). It includes query parameters for search query and limit.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nhttp http://0.0.0.0:8080/ query==\"wow,it works\" limit==5\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Docker Compose and Pytest (Bash)\nDESCRIPTION: This Bash command executes the test suite for the monitoring daemon within the Docker environment using `docker compose run`. It runs the `pytest` command on the `monitoringdaemon/tests.py` file and includes the `--cov` flag to generate a test coverage report for the `monitoringdaemon` package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose run --rm monitor py.test monitoringdaemon/tests.py --cov=monitoringdaemon\n```\n\n----------------------------------------\n\nTITLE: INI File Example with Environment Variable Interpolation\nDESCRIPTION: Sample INI configuration implementing environment variable interpolation with placeholders like ${ENV_VAR}, ${ENV_VAR}/path, and ${ENV_VAR:default} formats to enable substitution from environment variables or fallback to defaults at runtime.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/configuration.rst#_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[section]\noption1 = ${ENV_VAR}\noption2 = ${ENV_VAR}/path\noption3 = ${ENV_VAR:default}\n```\n\n----------------------------------------\n\nTITLE: Run Application with Docker Compose\nDESCRIPTION: This command starts the application services defined in the `docker-compose.yml` file in the foreground, attaching to the container logs. It typically launches the web server and any dependent services like databases.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Configuring Application Settings using INI\nDESCRIPTION: Reference to the INI file `config.ini`. This file provides configuration values for the application, such as database connection details and AWS settings, read by the dependency injection container.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\n# Source: examples/miniapps/application-single-container/config.ini\n# Contains application configuration in INI format.\n# [database]\n# host = ...\n# [aws]\n# access_key_id = ...\n```\n\n----------------------------------------\n\nTITLE: Visualizing Provider Dependency Tree - Bash Syntax\nDESCRIPTION: This diagram, formatted as a bash code block, visualizes the dependency graph among various providers within the dependency_injector framework. While presented in bash-marked syntax, it represents an abstract tree rather than an executable shell script. No external dependencies are required; the primary purpose is to illustrate that calling one provider can cascade into the instantiation of dependencies via other providers. Inputs and outputs are logical relationships, not code execution. The snippet is intended strictly for conceptual demonstration and does not perform any real operations.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/providers/index.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nprovider1()\n│\n├──> provider2()\n│\n├──> provider3()\n│    │\n│    └──> provider4()\n│\n└──> provider5()\n     │\n     └──> provider6()\n```\n\n----------------------------------------\n\nTITLE: Running the FastAPI Application using Bash\nDESCRIPTION: Commands to start the FastAPI web application. It first sets the required `GIPHY_API_KEY` environment variable and then uses `uvicorn` to serve the application defined in `giphynavigator.application:app`, enabling auto-reload for development.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nexport GIPHY_API_KEY=wBJ2wZG7SRqfrU9nPgPiWvORmloDyuL0\nuvicorn giphynavigator.application:app --reload\n```\n\n----------------------------------------\n\nTITLE: Running the Flask Development Server in Bash\nDESCRIPTION: Sets environment variables `FLASK_APP` (specifying the application module `githubnavigator.application`) and `FLASK_ENV` (enabling development mode with debugging and auto-reloading), then starts the Flask development server using the `flask run` command.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_8\n\nLANGUAGE: Bash\nCODE:\n```\nexport FLASK_APP=githubnavigator.application\nexport FLASK_ENV=development\nflask run\n```\n\n----------------------------------------\n\nTITLE: Starting Django Development Server\nDESCRIPTION: Command to run the Django development server, which makes the GitHub navigator application accessible at http://127.0.0.1:8000/.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython manage.py runserver\n```\n\n----------------------------------------\n\nTITLE: Configuring Application with YAML\nDESCRIPTION: Provides a YAML configuration file for the application that defines database connection parameters and AWS credentials. The configuration will be loaded and injected into the containers.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-multiple-containers.rst#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\n../../examples/miniapps/application-multiple-containers/config.yml\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Coverage Using py.test - Python\nDESCRIPTION: Executes the test suite for the application using pytest, targeting the 'giphynavigator/tests.py' file and measuring code coverage for the 'giphynavigator' package. Dependencies: pytest and pytest-cov must be installed, and the virtual environment should be active. Output: detailed test results and code coverage statistics.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/aiohttp/README.rst#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\npy.test giphynavigator/tests.py --cov=giphynavigator\n```\n\n----------------------------------------\n\nTITLE: Configuring Docker Compose for Daemon - YAML\nDESCRIPTION: Defines a docker-compose.yml configuration to build and run the monitoring daemon in a container. It builds the image from the local Dockerfile and mounts the project directory to the /code path within the container for hot reload or development convenience. Docker Compose must be installed, and the Dockerfile and source files should be present.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nservices:\n\n  monitor:\n    build: ./\n    image: monitoring-daemon\n    volumes:\n      - \"./:/code\"\n```\n\n----------------------------------------\n\nTITLE: Running the Example Application via Command Line\nDESCRIPTION: Shows how to execute the application script (`run.py`) using the Python interpreter. Command-line arguments specify the operational mode ('test' or 'prod') and an example email, demonstrating how to pass runtime configuration.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples-other/use-cases.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npython run.py test example@example.com\n```\n\nLANGUAGE: bash\nCODE:\n```\npython run.py prod example@example.com\n```\n\n----------------------------------------\n\nTITLE: Expected Pytest Test Run Output (Text)\nDESCRIPTION: This snippet displays the expected console output when running the unit tests with coverage. It indicates test collection, test execution results ('.'), and a summary table of the code coverage report.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/flask-blueprints/README.rst#_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nplatform linux -- Python 3.12.3, pytest-8.3.2, pluggy-1.5.0\nplugins: cov-6.0.0, flask-1.3.0\nasyncio: mode=Mode.STRICT, default_loop_scope=None\ncollected 2 items\n\ngithubnavigator/tests.py ..                                     [100%]\n\n---------- coverage: platform darwin, python 3.10.0-final-0 ----------\nName                                     Stmts   Miss  Cover\n------------------------------------------------------------\ngithubnavigator/__init__.py                  0      0   100%\ngithubnavigator/application.py              13      0   100%\ngithubnavigator/blueprints/__init__.py       0      0   100%\ngithubnavigator/blueprints/example.py       12      0   100%\ngithubnavigator/containers.py                8      0   100%\ngithubnavigator/services.py                 14      0   100%\ngithubnavigator/tests.py                    34      0   100%\n------------------------------------------------------------\nTOTAL                                       81      0   100%\n```\n\n----------------------------------------\n\nTITLE: Example Application Startup Log Output\nDESCRIPTION: Shows the expected console output when running `docker compose up`. This includes SQLAlchemy engine logs (database connection tests, table creation) and Uvicorn server startup messages indicating the application is running and accessible.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi-sqlalchemy/README.rst#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nStarting fastapi-sqlalchemy_webapp_1 ... done\nAttaching to fastapi-sqlalchemy_webapp_1\nwebapp_1  | 2022-02-04 22:07:19,804 INFO sqlalchemy.engine.base.Engine SELECT CAST('test plain returns' AS VARCHAR(60)) AS anon_1\nwebapp_1  | 2022-02-04 22:07:19,804 INFO sqlalchemy.engine.base.Engine ()\nwebapp_1  | 2022-02-04 22:07:19,804 INFO sqlalchemy.engine.base.Engine SELECT CAST('test unicode returns' AS VARCHAR(60)) AS anon_1\nwebapp_1  | 2022-02-04 22:07:19,804 INFO sqlalchemy.engine.base.Engine ()\nwebapp_1  | 2022-02-04 22:07:19,805 INFO sqlalchemy.engine.base.Engine PRAGMA main.table_info(\"users\")\nwebapp_1  | 2022-02-04 22:07:19,805 INFO sqlalchemy.engine.base.Engine ()\nwebapp_1  | 2022-02-04 22:07:19,808 INFO sqlalchemy.engine.base.Engine PRAGMA temp.table_info(\"users\")\nwebapp_1  | 2022-02-04 22:07:19,808 INFO sqlalchemy.engine.base.Engine ()\nwebapp_1  | 2022-02-04 22:07:19,809 INFO sqlalchemy.engine.base.Engine \nwebapp_1  | CREATE TABLE users (\nwebapp_1  | \tid INTEGER NOT NULL, \nwebapp_1  | \temail VARCHAR, \nwebapp_1  | \thashed_password VARCHAR, \nwebapp_1  | \tis_active BOOLEAN, \nwebapp_1  | \tPRIMARY KEY (id), \nwebapp_1  | \tUNIQUE (email), \nwebapp_1  | \tCHECK (is_active IN (0, 1))\nwebapp_1  | )\nwebapp_1  | \nwebapp_1  | \nwebapp_1  | 2022-02-04 22:07:19,810 INFO sqlalchemy.engine.base.Engine ()\nwebapp_1  | 2022-02-04 22:07:19,821 INFO sqlalchemy.engine.base.Engine COMMIT\nwebapp_1  | INFO:     Started server process [8]\nwebapp_1  | INFO:     Waiting for application startup.\nwebapp_1  | INFO:     Application startup complete.\nwebapp_1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)\n```\n\n----------------------------------------\n\nTITLE: Running Django Migrations\nDESCRIPTION: Command to apply database migrations for the Django project, ensuring the database schema is properly set up before running the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/django/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython manage.py migrate\n```\n\n----------------------------------------\n\nTITLE: Expected Output from the Python Dependency Injector Example\nDESCRIPTION: The expected console output showing debug logs from the application's services: UserService finding the user, AuthService authenticating the user, and PhotoService uploading the photo.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-single-container/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[2020-10-06 15:32:33,195] [DEBUG] [example.services.UserService]: User user@example.com has been found in database\n[2020-10-06 15:32:33,195] [DEBUG] [example.services.AuthService]: User user@example.com has been successfully authenticated\n[2020-10-06 15:32:33,195] [DEBUG] [example.services.PhotoService]: Photo photo.jpg has been successfully uploaded by user user@example.com\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Pytest via Docker Compose (Bash)\nDESCRIPTION: Executes the unit tests located in 'monitoringdaemon/tests.py' using pytest within a temporary Docker container for the 'monitor' service. The '--rm' flag ensures the container is removed after the tests run, and '--cov' generates a test coverage report for the 'monitoringdaemon' package. Requires Docker and Docker Compose installed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/asyncio-daemon/README.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose run --rm monitor py.test monitoringdaemon/tests.py --cov=monitoringdaemon\n```\n\n----------------------------------------\n\nTITLE: Running the Example Application (Bash)\nDESCRIPTION: This command executes the main application module ('application') using the Python interpreter. It's the standard way to run a Python package or module directly from the command line, assuming 'application.py' or an '__main__.py' within an 'application' directory exists in the Python path.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/commands-and-handlers/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -m application\n```\n\n----------------------------------------\n\nTITLE: Sample Coverage Report Output for Python Package\nDESCRIPTION: This snippet displays the coverage report output generated after running pytest with coverage. It details the number of statements, missed statements, and overall coverage percentage for each module, helping identify untested code areas.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/aiohttp.rst#_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\n   platform darwin -- Python 3.10.0, pytest-6.2.5, py-1.10.0, pluggy-1.0.0\n   plugins: asyncio-0.16.0, anyio-3.3.4, aiohttp-0.3.0, cov-3.0.0\n   collected 3 items\n\n   giphynavigator/tests.py ...                                     [100%]\n\n   ---------- coverage: platform darwin, python 3.10.0-final-0 ----------\n   Name                            Stmts   Miss  Cover\n   ---------------------------------------------------\n   giphynavigator/__init__.py          0      0   100%\n   giphynavigator/application.py      13      2    85%\n   giphynavigator/containers.py        7      0   100%\n   giphynavigator/giphy.py            14      9    36%\n   giphynavigator/handlers.py         10      0   100%\n   giphynavigator/services.py          9      1    89%\n   giphynavigator/tests.py            37      0   100%\n   ---------------------------------------------------\n   TOTAL                              90     12    87%\n```\n\n----------------------------------------\n\nTITLE: Creating Virtual Environment using Bash\nDESCRIPTION: Commands to create a new Python virtual environment named 'venv' using the `virtualenv` tool and activate it within the current bash session. This step isolates project dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nvirtualenv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies with pip in Bash\nDESCRIPTION: Installs the Python packages listed in the `requirements.txt` file using the `pip` package installer within the activated virtual environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies - Bash\nDESCRIPTION: Installs all project dependencies listed in the 'requirements.txt' file using pip. This command should be run within the activated virtual environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/decoupled-packages/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pydantic (Python)\nDESCRIPTION: Pins 'pydantic' to version 1.10.17. Pydantic is a data validation and settings management library using Python type annotations, often used with FastAPI.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_15\n\nLANGUAGE: Python requirements\nCODE:\n```\npydantic==1.10.17\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: coverage (Python)\nDESCRIPTION: Includes 'coverage', a tool for measuring code coverage of Python programs. It monitors your program, notes which parts of the code have been executed, and reports on the results.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_5\n\nLANGUAGE: Python requirements\nCODE:\n```\ncoverage\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: pytest (Python)\nDESCRIPTION: Adds 'pytest', a widely used testing framework for Python. It simplifies writing small tests and scales to support complex functional testing.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_2\n\nLANGUAGE: Python requirements\nCODE:\n```\npytest\n```\n\n----------------------------------------\n\nTITLE: Starting Daemon with Docker Compose (Bash)\nDESCRIPTION: This Bash command initiates the monitoring daemon using Docker Compose. It assumes a `docker-compose.yml` file exists that defines the service named `monitor`. Running this command starts the container(s) specified in the Docker Compose file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: sphinx_autobuild (Python)\nDESCRIPTION: Includes 'sphinx_autobuild', a tool that builds Sphinx documentation automatically on changes, often with a live-reloading web server.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_9\n\nLANGUAGE: Python requirements\nCODE:\n```\nsphinx_autobuild\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: mypy (Python)\nDESCRIPTION: Includes 'mypy', an optional static type checker for Python. It helps find errors in code without running it by checking type hints.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_11\n\nLANGUAGE: Python requirements\nCODE:\n```\nmypy\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: typing_extensions (Python)\nDESCRIPTION: Includes 'typing_extensions', a package that backports new features from Python's 'typing' module to older Python versions, enabling the use of modern type hints.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_20\n\nLANGUAGE: Python requirements\nCODE:\n```\ntyping_extensions\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: setuptools (Python)\nDESCRIPTION: Includes 'setuptools', a library fundamental for packaging Python projects. It provides tools for building, distributing, and installing Python packages.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_1\n\nLANGUAGE: Python requirements\nCODE:\n```\nsetuptools\n```\n\n----------------------------------------\n\nTITLE: Installing Updated Python Dependencies in Bash\nDESCRIPTION: Re-runs the `pip install -r requirements.txt` command to install the newly added `bootstrap-flask` package and any updated versions of existing dependencies specified in the `requirements.txt` file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_10\n\nLANGUAGE: Bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Response of Giphy GIF Search API\nDESCRIPTION: This JSON snippet presents the expected output from calling the Sanic-based GIF search REST API. It shows a search query for \"Dependency Injector\" limited to 10 GIFs, each represented by an object containing a URL to the corresponding GIF on Giphy. This demonstrates the structure of API data returned by the application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"query\": \"Dependency Injector\",\n    \"limit\": 10,\n    \"gifs\": [\n        {\n            \"url\": \"https://giphy.com/gifs/boxes-dependent-swbf2-6Eo7KzABxgJMY\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/depends-J56qCcOhk6hKE\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/web-series-ccstudios-bro-dependent-1lhU8KAVwmVVu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/TheBoysTV-friends-friend-weneedeachother-XxR9qcIwcf5Jq404Sx\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/netflix-a-series-of-unfortunate-events-asoue-9rgeQXbwoK53pcxn7f\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/black-and-white-sad-skins-Hs4YzLs2zJuLu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/always-there-for-you-i-am-here-PlayjhCco9jHBYrd9w\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/stream-famous-dollar-YT2dvOByEwXCdoYiA1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/i-love-you-there-for-am-1BhGzgpZXYWwWMAGB1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/life-like-twerk-9hlnWxjHqmH28\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Verifying Dependency Installation in Bash\nDESCRIPTION: Executes short Python commands via the shell to import `dependency_injector` and `flask` and print their versions, confirming successful installation and availability within the environment.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_4\n\nLANGUAGE: Bash\nCODE:\n```\npython -c \"import dependency_injector; print(dependency_injector.__version__)\"\npython -c \"import flask; print(flask.__version__)\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Application File Structure using Bash\nDESCRIPTION: This Bash snippet shows the directory and file structure of the example Python application. It outlines the layout of the `example` package, configuration files (`config.ini`, `logging.ini`), and the requirements file.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/examples/application-single-container.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── example/\n│   ├── __init__.py\n│   ├── __main__.py\n│   ├── containers.py\n│   └── services.py\n├── config.ini\n├── logging.ini\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Showing Project Directory Structure - Bash\nDESCRIPTION: This Bash snippet illustrates the expected directory structure of the project, showing the location of source files, templates, configuration, requirements, and specifically highlights the new `tests.py` file within the `githubnavigator` package.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── githubnavigator/\n│   ├── templates/\n│   │   ├── base.html\n│   │   └── index.html\n│   ├── __init__.py\n│   ├── application.py\n│   ├── containers.py\n│   ├── services.py\n│   ├── tests.py\n│   └── views.py\n├── venv/\n├── config.yml\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Updating Dependencies with Bootstrap-Flask in requirements.txt\nDESCRIPTION: Updates the `requirements.txt` file to include the `bootstrap-flask` package. This is necessary to add Bootstrap 4 styling and components to the Flask application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_9\n\nLANGUAGE: Bash\nCODE:\n```\ndependency-injector\nflask\nbootstrap-flask\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: httpx (Python)\nDESCRIPTION: Includes 'httpx', a fully featured HTTP client for Python that provides sync and async APIs, and support for HTTP/2.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_13\n\nLANGUAGE: Python requirements\nCODE:\n```\nhttpx\n```\n\n----------------------------------------\n\nTITLE: Listing Project Files (Bash)\nDESCRIPTION: This Bash snippet displays the directory structure of the project, specifically highlighting the location of the `tests.py` file within the `monitoringdaemon` package. It provides context for where the test code snippet should be placed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\n./\n├── monitoringdaemon/\n│   ├── __init__.py\n│   ├── __main__.py\n│   ├── containers.py\n│   ├── dispatcher.py\n│   ├── http.py\n│   ├── monitors.py\n│   └── tests.py\n├── config.yml\n├── docker-compose.yml\n├── Dockerfile\n└── requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies with Bash\nDESCRIPTION: This snippet provides the bash command to install all required Python dependencies listed in the requirements.txt file using pip. It assumes an active virtual environment for isolated package installation relevant to the Sanic + Dependency Injector Giphy API project.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/sanic/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Building Docker Image with Docker Compose (Bash)\nDESCRIPTION: Builds the Docker image required for the example application using the configuration specified in the docker-compose.yml file. Requires Docker and Docker Compose installed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/asyncio-daemon/README.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose build\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Project Requirements - Bash\nDESCRIPTION: Appends required dependencies for the monitoring daemon application to the requirements.txt file using standard Python package names. These packages provide dependency injection, async HTTP client functionality, YAML config parsing, and testing utilities. No arguments are required, and output is written to a file; versions are not pinned.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/asyncio-daemon.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndependency-injector\naiohttp\npyyaml\npytest\npytest-asyncio\npytest-cov\n```\n\n----------------------------------------\n\nTITLE: Setting Up Python Virtual Environment in Bash\nDESCRIPTION: Creates a Python 3 virtual environment named `venv` within the project directory and activates it using the source command. This isolates project dependencies.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\npython3 -m venv venv\n. venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Running Docker Environment with Docker Compose (Bash)\nDESCRIPTION: Starts and runs the application environment defined in the docker-compose.yml file. This command launches the necessary containers, including the asyncio daemon. Requires Docker and Docker Compose installed.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/asyncio-daemon/README.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose up\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: cython (Python)\nDESCRIPTION: Pins the 'cython' package to version 3.0.11. Cython is a programming language that makes writing C extensions for Python as easy as writing Python itself, often used for performance-critical sections.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_0\n\nLANGUAGE: Python requirements\nCODE:\n```\ncython==3.0.11\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependency: mypy_boto3_s3 (Python)\nDESCRIPTION: Adds 'mypy_boto3_s3', a type stub package for the AWS S3 service part of boto3. This provides type hints for static analysis tools like mypy when using S3.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_19\n\nLANGUAGE: Python requirements\nCODE:\n```\nmypy_boto3_s3\n```\n\n----------------------------------------\n\nTITLE: Example API JSON Response\nDESCRIPTION: Sample JSON data returned by the Giphy navigator API endpoint. The response includes the original search query ('Dependency Injector'), the number of results requested (limit: 10), and an array of 'gifs', each containing a URL pointing to a GIF on Giphy.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"query\": \"Dependency Injector\",\n    \"limit\": 10,\n    \"gifs\": [\n        {\n            \"url\": \"https://giphy.com/gifs/boxes-dependent-swbf2-6Eo7KzABxgJMY\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/depends-J56qCcOhk6hKE\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/web-series-ccstudios-bro-dependent-1lhU8KAVwmVVu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/TheBoysTV-friends-friend-weneedeachother-XxR9qcIwcf5Jq404Sx\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/netflix-a-series-of-unfortunate-events-asoue-9rgeQXbwoK53pcxn7f\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/black-and-white-sad-skins-Hs4YzLs2zJuLu\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/always-there-for-you-i-am-here-PlayjhCco9jHBYrd9w\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/stream-famous-dollar-YT2dvOByEwXCdoYiA1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/i-love-you-there-for-am-1BhGzgpZXYWwWMAGB1\"\n        },\n        {\n            \"url\": \"https://giphy.com/gifs/life-like-twerk-9hlnWxjHqmH28\"\n        }\n    ]\n}\n```\n\n----------------------------------------\n\nTITLE: Example Uvicorn Server Output\nDESCRIPTION: Illustrative console output displayed when the FastAPI application is successfully started using Uvicorn. It confirms the server is running on the specified address and port (http://127.0.0.1:8000) and indicates that the application startup is complete.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/fastapi/README.rst#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nINFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)\nINFO:     Started reloader process [4795] using watchgod\nINFO:     Started server process [4797]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\n```\n\n----------------------------------------\n\nTITLE: Expected Output of the Example Application\nDESCRIPTION: The expected log output from running the example application, showing debug messages from the UserService, AuthService, and PhotoService components.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/application-multiple-containers/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n[2020-10-06 15:36:55,961] [DEBUG] [example.services.UserService]: User user@example.com has been found in database\n[2020-10-06 15:36:55,961] [DEBUG] [example.services.AuthService]: User user@example.com has been successfully authenticated\n[2020-10-06 15:36:55,961] [DEBUG] [example.services.PhotoService]: Photo photo.jpg has been successfully uploaded by user user@example.com\n```\n\n----------------------------------------\n\nTITLE: Example Script Output - Bash\nDESCRIPTION: Shows the expected output from running the example script. This illustrates the results of the data retrieval and aggregation logic implemented in the decoupled components.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/examples/miniapps/decoupled-packages/README.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nRetrieve user id=1, photos count=5\nRetrieve user id=2, photos count=10\nAggregate analytics from user and photo bundles\n```\n\n----------------------------------------\n\nTITLE: Defining a Pull Sign Unicode Character in reStructuredText Documentation\nDESCRIPTION: This snippet defines a custom reStructuredText substitution named 'pull' that represents a leftwards arrow emoji (⬅️) using Unicode code points U+2B05 (leftwards black arrow) and U+FE0F (variation selector for emoji presentation).\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/README.rst#_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. |pull| unicode:: U+2B05 U+FE0F .. pull sign\n```\n\n----------------------------------------\n\nTITLE: Creating Project Directory in Bash\nDESCRIPTION: Creates the main project directory `ghnav-flask-tutorial` and changes the current working directory into it, preparing the workspace for the Flask application.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/docs/tutorials/flask.rst#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\nmkdir ghnav-flask-tutorial\ncd ghnav-flask-tutorial\n```\n\n----------------------------------------\n\nTITLE: Including External Requirements File (Python)\nDESCRIPTION: Instructs the package installer (like pip) to install all packages listed in the 'requirements-ext.txt' file. This is used to separate different sets of dependencies, such as core dependencies from development or optional ones.\nSOURCE: https://github.com/ets-labs/python-dependency-injector/blob/master/requirements-dev.txt#_snippet_21\n\nLANGUAGE: Python requirements\nCODE:\n```\n-r requirements-ext.txt\n```"
  }
]