[
  {
    "owner": "app-vnext",
    "repo": "polly",
    "content": "TITLE: Executing Code with Timeout Strategy in Polly\nDESCRIPTION: Shows how to execute an HTTP request with a timeout strategy applied. The pipeline will cancel the operation if it doesn't complete within the specified timeout period.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(3))\n    .Build();\n\nHttpResponseMessage httpResponse = await pipeline.ExecuteAsync(\n      async ct =>\n      {\n          // Execute a delegate that takes a CancellationToken as an input parameter.\n          return await httpClient.GetAsync(endpoint, ct);\n      },\n      cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Implementing Circuit Breaker Failure Handling with Polly\nDESCRIPTION: Shows how to handle failures with a circuit breaker strategy by configuring failure thresholds and catching both original exceptions and BrokenCircuitException when the circuit is opened.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new CircuitBreakerStrategyOptions\n    {\n        FailureRatio = 0.1,\n        SamplingDuration = TimeSpan.FromSeconds(1),\n        MinimumThroughput = 3,\n        BreakDuration = TimeSpan.FromSeconds(30),\n        ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>()\n    })\n    .Build();\n\nfor (int i = 0; i < 10; i++)\n{\n    try\n    {\n        pipeline.Execute(() => throw new SomeExceptionType());\n    }\n    catch (SomeExceptionType)\n    {\n        Console.WriteLine(\"Operation failed please try again.\");\n    }\n    catch (BrokenCircuitException)\n    {\n        Console.WriteLine(\"Operation failed too many times please try again later.\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Patterns with Polly in C#\nDESCRIPTION: Demonstrates various configurations of RetryStrategyOptions including default retry, no-delay retry, complex retry with exponential backoff, custom delay generation, result-based delay extraction, retry event handling, and indefinite retry. Shows how to configure retry behavior, handle specific exceptions, implement backoff strategies, and integrate with resilience pipelines.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Retry using the default options.\n// See https://www.pollydocs.org/strategies/retry#defaults for defaults.\nvar optionsDefaults = new RetryStrategyOptions();\n\n// For instant retries with no delay\nvar optionsNoDelay = new RetryStrategyOptions\n{\n    Delay = TimeSpan.Zero\n};\n\n// For advanced control over the retry behavior, including the number of attempts,\n// delay between retries, and the types of exceptions to handle.\nvar optionsComplex = new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    BackoffType = DelayBackoffType.Exponential,\n    UseJitter = true,  // Adds a random factor to the delay\n    MaxRetryAttempts = 4,\n    Delay = TimeSpan.FromSeconds(3),\n};\n\n// To use a custom function to generate the delay for retries\nvar optionsDelayGenerator = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 2,\n    DelayGenerator = static args =>\n    {\n        var delay = args.AttemptNumber switch\n        {\n            0 => TimeSpan.Zero,\n            1 => TimeSpan.FromSeconds(1),\n            _ => TimeSpan.FromSeconds(5)\n        };\n\n        // This example uses a synchronous delay generator,\n        // but the API also supports asynchronous implementations.\n        return new ValueTask<TimeSpan?>(delay);\n    }\n};\n\n// To extract the delay from the result object\nvar optionsExtractDelay = new RetryStrategyOptions<HttpResponseMessage>\n{\n    DelayGenerator = static args =>\n    {\n        if (args.Outcome.Result is HttpResponseMessage responseMessage &&\n            TryGetDelay(responseMessage, out TimeSpan delay))\n        {\n            return new ValueTask<TimeSpan?>(delay);\n        }\n\n        // Returning null means the retry strategy will use its internal delay for this attempt.\n        return new ValueTask<TimeSpan?>((TimeSpan?)null);\n    }\n};\n\n// To get notifications when a retry is performed\nvar optionsOnRetry = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 2,\n    OnRetry = static args =>\n    {\n        Console.WriteLine(\"OnRetry, Attempt: {0}\", args.AttemptNumber);\n\n        // Event handlers can be asynchronous; here, we return an empty ValueTask.\n        return default;\n    }\n};\n\n// To keep retrying indefinitely or until success use int.MaxValue.\nvar optionsIndefiniteRetry = new RetryStrategyOptions\n{\n    MaxRetryAttempts = int.MaxValue,\n};\n\n// Add a retry strategy with a RetryStrategyOptions{<TResult>} instance to the pipeline\nnew ResiliencePipelineBuilder().AddRetry(optionsDefaults);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(optionsExtractDelay);\n```\n\n----------------------------------------\n\nTITLE: Integrating Polly with HttpClient in C#\nDESCRIPTION: This snippet demonstrates how to register a named HttpClient with a resilience pipeline using Polly. It configures the HttpClient with a base address and adds a retry strategy for handling transient errors.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Register a named HttpClient and decorate with a resilience pipeline\nservices.AddHttpClient(HttpClientName)\n        .ConfigureHttpClient(client => client.BaseAddress = BaseAddress)\n        .AddResilienceHandler(\"httpclient_based_pipeline\",\n            builder => builder.AddRetry(GetRetryOptions()));\n\nusing var provider = services.BuildServiceProvider();\n\n// Resolve the named HttpClient\nvar httpClientFactory = provider.GetRequiredService<IHttpClientFactory>();\nvar httpClient = httpClientFactory.CreateClient(HttpClientName);\n\n// Use the HttpClient by making a request\nvar response = await httpClient.GetAsync(\"/408\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Retry Strategy in Polly v8\nDESCRIPTION: Demonstrates various retry configurations in Polly v8 using ResiliencePipelineBuilder, including single retry, multiple retries, retries with callbacks, and infinite retry patterns.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Retry once\n//\n// Because we are adding retries to a non-generic pipeline,\n// we use the non-generic RetryStrategyOptions.\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    // PredicateBuilder is used to simplify the initialization of predicates.\n    // Its API should be familiar to the v7 way of configuring what exceptions to handle.\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = 1,\n    // To disable waiting between retries, set the Delay property to TimeSpan.Zero.\n    Delay = TimeSpan.Zero,\n})\n.Build();\n\n// Retry multiple times\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = 3,\n    Delay = TimeSpan.Zero,\n})\n.Build();\n\n// Retry multiple times with callback\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = 3,\n    Delay = TimeSpan.Zero,\n    OnRetry = static args =>\n    {\n        // Add logic to be executed before each retry, such as logging\n        return default;\n    }\n})\n.Build();\n\n// Retry forever\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    // To retry forever, set the MaxRetryAttempts property to int.MaxValue.\n    MaxRetryAttempts = int.MaxValue,\n    Delay = TimeSpan.Zero,\n})\n.Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Polly with Dependency Injection in C#\nDESCRIPTION: Demonstrates how to set up Polly with dependency injection using IServiceCollection. Shows pipeline registration, retrieval, and execution using both ResiliencePipelineProvider and keyed services.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_3\n\nLANGUAGE: c#\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Define a resilience pipeline with the name \"my-pipeline\"\nservices.AddResiliencePipeline(\"my-pipeline\", builder =>\n{\n    builder\n        .AddRetry(new RetryStrategyOptions())\n        .AddTimeout(TimeSpan.FromSeconds(10));\n});\n\n// Build the service provider\nvar serviceProvider = services.BuildServiceProvider();\n\n// Retrieve a ResiliencePipelineProvider that dynamically creates and caches the resilience pipelines\nvar pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>();\n\n// Retrieve your resilience pipeline using the name it was registered with\nResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-pipeline\");\n\n// Alternatively, you can use keyed services to retrieve the resilience pipeline\npipeline = serviceProvider.GetRequiredKeyedService<ResiliencePipeline>(\"my-pipeline\");\n\n// Execute the pipeline\nawait pipeline.ExecuteAsync(static async token =>\n{\n    // Your custom logic goes here\n});\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Retry Strategies in C#\nDESCRIPTION: Shows how to combine multiple retry strategies with different delay patterns, offering greater flexibility and reusability compared to a single complex strategy.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar slowRetries = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 5,\n    Delay = TimeSpan.FromMinutes(3),\n    BackoffType = DelayBackoffType.Constant\n};\n\nvar quickRetries = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 5,\n    Delay = TimeSpan.FromSeconds(1),\n    UseJitter = true,\n    BackoffType = DelayBackoffType.Exponential\n};\n\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(slowRetries)\n    .AddRetry(quickRetries)\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Correct Circuit Breaker Usage in C#\nDESCRIPTION: This snippet shows the recommended approach for using a Circuit Breaker to reduce thrown exceptions. It uses ExecuteOutcomeAsync to avoid throwing exceptions and allows proper state transitions.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar context = ResilienceContextPool.Shared.Get();\nvar circuitBreaker = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new()\n    {\n        ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(),\n        BreakDuration = TimeSpan.FromSeconds(0.5),\n    })\n    .Build();\n\nOutcome<HttpResponseMessage> outcome = await circuitBreaker.ExecuteOutcomeAsync(static async (ctx, state) =>\n{\n    var response = await IssueRequest();\n    return Outcome.FromResult(response);\n}, context, \"state\");\n\nResilienceContextPool.Shared.Return(context);\n\nif (outcome.Exception is BrokenCircuitException)\n{\n    // The execution was stopped by the circuit breaker\n}\nelse\n{\n    HttpResponseMessage response = outcome.Result!;\n    // Your code goes here to process the response\n}\n```\n\n----------------------------------------\n\nTITLE: Best Practice: Handling Exception Types in ShouldHandle\nDESCRIPTION: Shows the recommended approach for handling specific exception types in retry logic by utilizing the ShouldHandle property. This pattern clearly defines retry conditions without complicated control flow.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = args => ValueTask.FromResult(args.Outcome.Exception is not TimeoutException)\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Polly Pipeline in C#\nDESCRIPTION: Demonstrates how to create a basic resilience pipeline using ResiliencePipelineBuilder with retry and timeout strategies. The pipeline is configured with default retry options and a 10-second timeout.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_0\n\nLANGUAGE: c#\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions()) // Add retry using the default options\n    .AddTimeout(TimeSpan.FromSeconds(10)) // Add 10 seconds timeout\n    .Build(); // Builds the resilience pipeline\n\n// Execute the pipeline asynchronously\nawait pipeline.ExecuteAsync(static async token => { /* Your custom logic goes here */ }, cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Configuring Circuit Breaker Strategies in Polly (C#)\nDESCRIPTION: Shows various configurations for circuit breaker strategies, including default options, complex behavior, dynamic break duration, handling specific HTTP responses, state monitoring, and manual control. It also demonstrates how to add circuit breaker strategies to a resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// Circuit breaker with default options.\n// See https://www.pollydocs.org/strategies/circuit-breaker#defaults for defaults.\nvar optionsDefaults = new CircuitBreakerStrategyOptions();\n\n// Circuit breaker with customized options:\n// The circuit will break if more than 50% of actions result in handled exceptions,\n// within any 10-second sampling duration, and at least 8 actions are processed.\nvar optionsComplex = new CircuitBreakerStrategyOptions\n{\n    FailureRatio = 0.5,\n    SamplingDuration = TimeSpan.FromSeconds(10),\n    MinimumThroughput = 8,\n    BreakDuration = TimeSpan.FromSeconds(30),\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>()\n};\n\n// Circuit breaker using BreakDurationGenerator:\n// The break duration is dynamically determined based on the properties of BreakDurationGeneratorArguments.\nvar optionsBreakDurationGenerator = new CircuitBreakerStrategyOptions\n{\n    FailureRatio = 0.5,\n    SamplingDuration = TimeSpan.FromSeconds(10),\n    MinimumThroughput = 8,\n    BreakDurationGenerator = static args => new ValueTask<TimeSpan>(TimeSpan.FromMinutes(args.FailureCount)),\n};\n\n// Handle specific failed results for HttpResponseMessage:\nvar optionsShouldHandle = new CircuitBreakerStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError)\n};\n\n// Monitor the circuit state, useful for health reporting:\nvar stateProvider = new CircuitBreakerStateProvider();\nvar optionsStateProvider = new CircuitBreakerStrategyOptions<HttpResponseMessage>\n{\n    StateProvider = stateProvider\n};\n\nvar circuitState = stateProvider.CircuitState;\n\n/*\nCircuitState.Closed - Normal operation; actions are executed.\nCircuitState.Open - Circuit is open; actions are blocked.\nCircuitState.HalfOpen - Recovery state after break duration expires; actions are permitted.\nCircuitState.Isolated - Circuit is manually held open; actions are blocked.\n*/\n\n// Manually control the Circuit Breaker state:\nvar manualControl = new CircuitBreakerManualControl();\nvar optionsManualControl = new CircuitBreakerStrategyOptions\n{\n    ManualControl = manualControl\n};\n\n// Manually isolate a circuit, e.g., to isolate a downstream service.\nawait manualControl.IsolateAsync();\n\n// Manually close the circuit to allow actions to be executed again.\nawait manualControl.CloseAsync();\n\n// Add a circuit breaker strategy with a CircuitBreakerStrategyOptions{<TResult>} instance to the pipeline\nnew ResiliencePipelineBuilder().AddCircuitBreaker(optionsDefaults);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddCircuitBreaker(optionsStateProvider);\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout-Retry Pipeline in C#\nDESCRIPTION: Creates a resilience pipeline that combines a timeout strategy as the outer layer with a retry strategy as the inner layer. The timeout is set to 10 seconds and applies to all retry attempts collectively.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(10)) // outer\n    .AddRetry(new()) // inner\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Best Practice: Circuit-Aware Retry with Context\nDESCRIPTION: This code snippet showcases the recommended approach for implementing a circuit-aware retry strategy. It uses the Context to pass information between strategies, reducing coupling and improving maintainability. The circuit breaker shares its break duration through the context, and the retry strategy fetches it dynamically.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar circuitBreaker = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new()\n    {\n        ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(),\n        BreakDuration = TimeSpan.FromSeconds(5),\n        OnOpened = static args =>\n        {\n            args.Context.Properties.Set(SleepDurationKey, args.BreakDuration);\n            return ValueTask.CompletedTask;\n        },\n        OnClosed = args =>\n        {\n            args.Context.Properties.Set(SleepDurationKey, null);\n            return ValueTask.CompletedTask;\n        }\n    })\n    .Build();\n\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder()\n            .Handle<HttpRequestException>()\n            .Handle<BrokenCircuitException>(),\n        DelayGenerator = static args =>\n        {\n            _ = args.Context.Properties.TryGetValue(SleepDurationKey, out var delay);\n            delay ??= TimeSpan.FromSeconds(1);\n            return ValueTask.FromResult(delay);\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Best Practice: Using Named HttpClients with AddResilienceHandler\nDESCRIPTION: This code snippet shows the recommended approach for implementing circuit breakers for multiple endpoints. It uses named HttpClients and the AddResilienceHandler extension from the Microsoft.Extensions.Http.Resilience package. This method integrates the circuit breaker during startup and automatically handles resilience without explicit calls to ExecuteAsync.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nservices\n  .AddHttpClient(\"my-client\")\n  .AddResilienceHandler(\"circuit-breaker\", builder =>\n  {\n      builder.AddCircuitBreaker(new());\n  })\n  .SelectPipelineByAuthority(); // This call ensures that circuit breaker is cached by each URL authority\n```\n\nLANGUAGE: csharp\nCODE:\n```\nHttpClient client = httpClientFactory.CreateClient(\"my-client\");\n\nawait client.GetAsync(new Uri(\"https://downstream1.com/some-path\"));\n```\n\n----------------------------------------\n\nTITLE: Pattern: Chaining Resilience Pipelines in C#\nDESCRIPTION: The proper way to combine multiple resilience strategies using ResiliencePipelineBuilder's chaining capabilities, which automatically handles cancellation token propagation and improves code readability.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddPipeline(timeout)\n    .AddPipeline(fallback)\n    .Build();\n\nreturn await pipeline.ExecuteAsync(CallExternalSystem, CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Creating and Executing a Resilience Pipeline in C#\nDESCRIPTION: This snippet demonstrates how to create a ResiliencePipeline using ResiliencePipelineBuilder, adding retry and timeout strategies, and then executing it asynchronously.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/getting-started.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Create an instance of builder that exposes various extensions for adding resilience strategies\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions()) // Add retry using the default options\n    .AddTimeout(TimeSpan.FromSeconds(10)) // Add 10 seconds timeout\n    .Build(); // Builds the resilience pipeline\n\n// Execute the pipeline asynchronously\nawait pipeline.ExecuteAsync(static async token => { /* Your custom logic goes here */ }, cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Visualizing Dynamic Break Duration Circuit Breaker Behavior\nDESCRIPTION: This sequence diagram demonstrates the behavior of a circuit breaker using a BreakDurationGenerator. It shows how the break duration is dynamically calculated based on specific criteria, such as the number of failures, and how the circuit breaker transitions between states.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant CB as CircuitBreaker\n    participant BDG as BreakDurationGenerator\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Closed state\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    Note over CB: Moves to Open state\n    CB->>+BDG: Calls Generator\n    BDG->>-CB: Returns calculated <br/> duration\n    Note over CB: Break duration start\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB-->>CB: Rejects request\n    CB->>P: Throws <br/>BrokenCircuitException\n    P->>C: Propagates exception\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Break duration end\n    Note over CB: Moves to HalfOpen state\n    CB->>+D: Invokes\n    D->>-CB: Returns result\n    Note over CB: Moves to Closed state\n    CB->>P: Returns result\n    P->>C: Returns result\n```\n\n----------------------------------------\n\nTITLE: Implementing Chained Rate Limiters with Polly in C#\nDESCRIPTION: Demonstrates how to combine multiple rate limiters with different configurations to create a more sophisticated rate limiting strategy. The example creates a chain of sliding window rate limiters that limit requests both per minute and per second.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// Use the user's ID as the partition key.\nvar partitionKey = \"user-id\";\n\nvar firstSlidingWindow = PartitionedRateLimiter.Create<ResilienceContext, string>((context) =>\n{\n    return RateLimitPartition.GetSlidingWindowLimiter(partitionKey, (partitionKey) => new()\n    {\n        PermitLimit = 100,\n        Window = TimeSpan.FromMinutes(1),\n    });\n});\n\nvar secondSlidingWindow = PartitionedRateLimiter.Create<ResilienceContext, string>((context) =>\n{\n    return RateLimitPartition.GetSlidingWindowLimiter(partitionKey, (partitionKey) => new()\n    {\n        PermitLimit = 10,\n        Window = TimeSpan.FromSeconds(1),\n    });\n});\n\n// Create a rate limiter that combines the two sliding windows.\nvar chainedRateLimiter = PartitionedRateLimiter.CreateChained(firstSlidingWindow, secondSlidingWindow);\n\n// Create the pipeline using the rate limiter that chains the windows together.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions\n    {\n        RateLimiter = (context) => chainedRateLimiter.AcquireAsync(context.Context),\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Initializing Basic Resilience Pipeline with Timeout Strategy\nDESCRIPTION: Demonstrates how to create a basic resilience pipeline using a timeout strategy with a 5-second duration limit.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/index.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(new TimeoutStrategyOptions\n    {\n        Timeout = TimeSpan.FromSeconds(5)\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Resilience Strategies in Polly v8\nDESCRIPTION: This snippet shows how to migrate from Polly v7 policies to Polly v8 resilience strategies, using ResiliencePipelineBuilder to configure retry behavior for both synchronous and asynchronous execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Create and use the ResiliencePipeline.\n//\n// Use the ResiliencePipelineBuilder to start building the resilience pipeline\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<Exception>(),\n        Delay = TimeSpan.FromSeconds(1),\n        MaxRetryAttempts = 3,\n        BackoffType = DelayBackoffType.Constant\n    })\n    .Build(); // After all necessary strategies are added, call Build() to create the pipeline.\n\n// Synchronous execution\npipeline.Execute(static () =>\n{\n    // Your code goes here\n});\n\n// Asynchronous execution is also supported with the same pipeline instance\nawait pipeline.ExecuteAsync(static async token =>\n{\n    // Your code goes here\n}, cancellationToken);\n\n// Create and use the ResiliencePipeline<T>.\n//\n// Building of generic resilience pipeline is very similar to non-generic one.\n// Notice the use of generic RetryStrategyOptions<HttpResponseMessage> to configure the strategy.\nResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddRetry(new RetryStrategyOptions<HttpResponseMessage>\n    {\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .Handle<Exception>()\n            .HandleResult(static result => !result.IsSuccessStatusCode),\n        Delay = TimeSpan.FromSeconds(1),\n        MaxRetryAttempts = 3,\n        BackoffType = DelayBackoffType.Constant\n    })\n    .Build();\n\n// Synchronous execution\npipelineT.Execute(static () =>\n{\n    // Your code goes here\n    return GetResponse();\n});\n\n// Asynchronous execution\nawait pipelineT.ExecuteAsync(static async token =>\n{\n    // Your code goes here\n    return await GetResponseAsync(token);\n}, cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Circuit Breaker Strategy in Polly\nDESCRIPTION: Demonstrates various configuration options for the Circuit Breaker strategy including default settings, custom failure thresholds, dynamic break duration, result handling, state monitoring, and manual control.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// Circuit breaker with default options.\n// See https://www.pollydocs.org/strategies/circuit-breaker#defaults for defaults.\nvar optionsDefaults = new CircuitBreakerStrategyOptions();\n\n// Circuit breaker with customized options:\n// The circuit will break if more than 50% of actions result in handled exceptions,\n// within any 10-second sampling duration, and at least 8 actions are processed.\nvar optionsComplex = new CircuitBreakerStrategyOptions\n{\n    FailureRatio = 0.5,\n    SamplingDuration = TimeSpan.FromSeconds(10),\n    MinimumThroughput = 8,\n    BreakDuration = TimeSpan.FromSeconds(30),\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>()\n};\n\n// Circuit breaker using BreakDurationGenerator:\n// The break duration is dynamically determined based on the properties of BreakDurationGeneratorArguments.\nvar optionsBreakDurationGenerator = new CircuitBreakerStrategyOptions\n{\n    FailureRatio = 0.5,\n    SamplingDuration = TimeSpan.FromSeconds(10),\n    MinimumThroughput = 8,\n    BreakDurationGenerator = static args => new ValueTask<TimeSpan>(TimeSpan.FromMinutes(args.FailureCount)),\n};\n\n// Handle specific failed results for HttpResponseMessage:\nvar optionsShouldHandle = new CircuitBreakerStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError)\n};\n\n// Monitor the circuit state, useful for health reporting:\nvar stateProvider = new CircuitBreakerStateProvider();\nvar optionsStateProvider = new CircuitBreakerStrategyOptions<HttpResponseMessage>\n{\n    StateProvider = stateProvider\n};\n\nvar circuitState = stateProvider.CircuitState;\n\n/*\nCircuitState.Closed - Normal operation; actions are executed.\nCircuitState.Open - Circuit is open; actions are blocked.\nCircuitState.HalfOpen - Recovery state after break duration expires; actions are permitted.\nCircuitState.Isolated - Circuit is manually held open; actions are blocked.\n*/\n\n// Manually control the Circuit Breaker state:\nvar manualControl = new CircuitBreakerManualControl();\nvar optionsManualControl = new CircuitBreakerStrategyOptions\n{\n    ManualControl = manualControl\n};\n\n// Manually isolate a circuit, e.g., to isolate a downstream service.\nawait manualControl.IsolateAsync();\n\n// Manually close the circuit to allow actions to be executed again.\nawait manualControl.CloseAsync();\n\n// Add a circuit breaker strategy with a CircuitBreakerStrategyOptions{<TResult>} instance to the pipeline\nnew ResiliencePipelineBuilder().AddCircuitBreaker(optionsDefaults);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddCircuitBreaker(optionsStateProvider);\n```\n\n----------------------------------------\n\nTITLE: Implementing Retry Strategy with Maximum Delay in C#\nDESCRIPTION: Demonstrates how to set up a resilience pipeline with a retry strategy that uses exponential backoff, jitter, and a maximum delay. This is useful for long-running background jobs where extended retries are acceptable but with a capped maximum delay.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        Delay = TimeSpan.FromSeconds(2),\n        MaxRetryAttempts = int.MaxValue,\n        BackoffType = DelayBackoffType.Exponential,\n\n        // Initially, we aim for an exponential backoff, but after a certain number of retries, we set a maximum delay of 15 minutes.\n        MaxDelay = TimeSpan.FromMinutes(15),\n        UseJitter = true\n    })\n    .Build();\n\n// Background processing\nwhile (!cancellationToken.IsCancellationRequested)\n{\n    await pipeline.ExecuteAsync(async token =>\n    {\n        // In the event of a prolonged service outage, we can afford to wait for a successful retry since this is a background task.\n        await SynchronizeDataAsync(token);\n    },\n    cancellationToken);\n\n    await Task.Delay(TimeSpan.FromMinutes(30)); // The sync runs every 30 minutes.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hedging Strategy with Polly in C#\nDESCRIPTION: Demonstrates how to set up and customize a hedging strategy using Polly. It shows default options, complex configurations with custom predicates and action generators, and event subscription. The code also illustrates how to add the strategy to a resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Hedging with default options.\n// See https://www.pollydocs.org/strategies/hedging#defaults for defaults.\nvar optionsDefaults = new HedgingStrategyOptions<HttpResponseMessage>();\n\n// A customized hedging strategy that retries up to 3 times if the execution\n// takes longer than 1 second or if it fails due to an exception or returns an HTTP 500 Internal Server Error.\nvar optionsComplex = new HedgingStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError),\n    MaxHedgedAttempts = 3,\n    Delay = TimeSpan.FromSeconds(1),\n    ActionGenerator = static args =>\n    {\n        Console.WriteLine(\"Preparing to execute hedged action.\");\n\n        // Return a delegate function to invoke the original action with the action context.\n        // Optionally, you can also create a completely new action to be executed.\n        return () => args.Callback(args.ActionContext);\n    }\n};\n\n// Subscribe to hedging events.\nvar optionsOnHedging = new HedgingStrategyOptions<HttpResponseMessage>\n{\n    OnHedging = static args =>\n    {\n        Console.WriteLine($\"OnHedging: Attempt number {args.AttemptNumber}\");\n        return default;\n    }\n};\n\n// Add a hedging strategy with a HedgingStrategyOptions<TResult> instance to the pipeline\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddHedging(optionsDefaults);\n```\n\n----------------------------------------\n\nTITLE: Using Centralized Chaos Manager with Multiple Chaos Strategies in C#\nDESCRIPTION: Shows how to implement multiple chaos strategies (fault and latency) that share the same chaos management logic through an IChaosManager interface. This approach ensures consistent chaos behavior across different chaos strategies in the application.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) =>\n{\n    var chaosManager = context.ServiceProvider.GetRequiredService<IChaosManager>();\n\n    builder\n        .AddChaosFault(new ChaosFaultStrategyOptions\n        {\n            EnabledGenerator = args => chaosManager.IsChaosEnabled(args.Context),\n            InjectionRateGenerator = args => chaosManager.GetInjectionRate(args.Context),\n            FaultGenerator = new FaultGenerator()\n                .AddException<TimeoutException>()\n                .AddException<HttpRequestException>()\n        })\n        .AddChaosLatency(new ChaosLatencyStrategyOptions\n        {\n            EnabledGenerator = args => chaosManager.IsChaosEnabled(args.Context),\n            InjectionRateGenerator = args => chaosManager.GetInjectionRate(args.Context),\n            Latency = TimeSpan.FromSeconds(60)\n        });\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Timeouts with OnTimeout Callback in Polly\nDESCRIPTION: Demonstrates configuring a timeout strategy with an OnTimeout callback that executes when a timeout occurs, allowing for custom handling of timeout events.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar withOnTimeout = new ResiliencePipelineBuilder()\n    .AddTimeout(new TimeoutStrategyOptions\n    {\n        Timeout = TimeSpan.FromSeconds(2),\n        OnTimeout = args =>\n        {\n            Console.WriteLine(\"Timeout limit has been exceeded\");\n            return default;\n        }\n    }).Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Retry Strategy with Efficient Exception Handling in C#\nDESCRIPTION: Demonstrates how to efficiently configure a retry strategy by grouping exceptions and using a simple predicate function instead of overusing Handle methods.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nImmutableArray<Type> networkExceptions =\n[\n    typeof(SocketException),\n    typeof(HttpRequestException),\n];\n\nImmutableArray<Type> strategyExceptions =\n[\n    typeof(TimeoutRejectedException),\n    typeof(BrokenCircuitException),\n    typeof(RateLimitRejectedException),\n];\n\nImmutableArray<Type> retryableExceptions = networkExceptions\n    .Union(strategyExceptions)\n    .ToImmutableArray();\n\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = args =>\n            ValueTask.FromResult(args.Outcome.Exception is not null &&\n            retryableExceptions.Contains(args.Outcome.Exception.GetType())),\n        MaxRetryAttempts = 3,\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Retry Strategies in Polly (C#)\nDESCRIPTION: Demonstrates various configurations for retry strategies, including default options, no delay, complex retry behavior, custom delay generation, delay extraction from response, retry notifications, and indefinite retries. It also shows how to add retry strategies to a resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Retry using the default options.\n// See https://www.pollydocs.org/strategies/retry#defaults for defaults.\nvar optionsDefaults = new RetryStrategyOptions();\n\n// For instant retries with no delay\nvar optionsNoDelay = new RetryStrategyOptions\n{\n    Delay = TimeSpan.Zero\n};\n\n// For advanced control over the retry behavior, including the number of attempts,\n// delay between retries, and the types of exceptions to handle.\nvar optionsComplex = new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    BackoffType = DelayBackoffType.Exponential,\n    UseJitter = true,  // Adds a random factor to the delay\n    MaxRetryAttempts = 4,\n    Delay = TimeSpan.FromSeconds(3),\n};\n\n// To use a custom function to generate the delay for retries\nvar optionsDelayGenerator = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 2,\n    DelayGenerator = static args =>\n    {\n        var delay = args.AttemptNumber switch\n        {\n            0 => TimeSpan.Zero,\n            1 => TimeSpan.FromSeconds(1),\n            _ => TimeSpan.FromSeconds(5)\n        };\n\n        // This example uses a synchronous delay generator,\n        // but the API also supports asynchronous implementations.\n        return new ValueTask<TimeSpan?>(delay);\n    }\n};\n\n// To extract the delay from the result object\nvar optionsExtractDelay = new RetryStrategyOptions<HttpResponseMessage>\n{\n    DelayGenerator = static args =>\n    {\n        if (args.Outcome.Result is HttpResponseMessage responseMessage &&\n            TryGetDelay(responseMessage, out TimeSpan delay))\n        {\n            return new ValueTask<TimeSpan?>(delay);\n        }\n\n        // Returning null means the retry strategy will use its internal delay for this attempt.\n        return new ValueTask<TimeSpan?>((TimeSpan?)null);\n    }\n};\n\n// To get notifications when a retry is performed\nvar optionsOnRetry = new RetryStrategyOptions\n{\n    MaxRetryAttempts = 2,\n    OnRetry = static args =>\n    {\n        Console.WriteLine(\"OnRetry, Attempt: {0}\", args.AttemptNumber);\n\n        // Event handlers can be asynchronous; here, we return an empty ValueTask.\n        return default;\n    }\n};\n\n// To keep retrying indefinitely or until success use int.MaxValue.\nvar optionsIndefiniteRetry = new RetryStrategyOptions\n{\n    MaxRetryAttempts = int.MaxValue,\n};\n\n// Add a retry strategy with a RetryStrategyOptions{<TResult>} instance to the pipeline\nnew ResiliencePipelineBuilder().AddRetry(optionsDefaults);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(optionsExtractDelay);\n```\n\n----------------------------------------\n\nTITLE: Basic ResiliencePipeline Usage Examples in C#\nDESCRIPTION: Demonstrates various ways to execute callbacks using ResiliencePipeline, including synchronous and asynchronous execution, handling return values, and working with custom context data.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Creating a new resilience pipeline\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddConcurrencyLimiter(100)\n    .Build();\n\n// Executing an asynchronous void callback\nawait pipeline.ExecuteAsync(\n    async token => await MyMethodAsync(token),\n    cancellationToken);\n\n// Executing a synchronous void callback\npipeline.Execute(() => MyMethod());\n\n// Executing an asynchronous callback that returns a value\nawait pipeline.ExecuteAsync(\n    async token => await httpClient.GetAsync(endpoint, token),\n    cancellationToken);\n\n// Executing an asynchronous callback without allocating a lambda\nawait pipeline.ExecuteAsync(\n    static async (state, token) => await state.httpClient.GetAsync(state.endpoint, token),\n    (httpClient, endpoint),  // State provided here\n    cancellationToken);\n\n// Executing an asynchronous callback and passing custom data\n\n// 1. Retrieve a context from the shared pool\nResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);\n\n// 2. Add custom data to the context\ncontext.Properties.Set(new ResiliencePropertyKey<string>(\"my-custom-data\"), \"my-custom-data\");\n\n// 3. Execute the callback\nawait pipeline.ExecuteAsync(static async context =>\n{\n    // Retrieve custom data from the context\n    var customData = context.Properties.GetValue(\n        new ResiliencePropertyKey<string>(\"my-custom-data\"),\n        \"default-value\");\n\n    Console.WriteLine(\"Custom Data: {0}\", customData);\n\n    await MyMethodAsync(context.CancellationToken);\n},\ncontext);\n\n// 4. Optionally, return the context to the shared pool\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Executing Operations with Rate Limiter and Handling Rejections in C#\nDESCRIPTION: Shows how to execute operations through a rate-limited resilience pipeline and handle rejections when limits are exceeded. Includes error handling for RateLimiterRejectedException with retry timing information.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder().AddConcurrencyLimiter(100, 50).Build();\n\ntry\n{\n    // Execute an asynchronous text search operation.\n    var result = await pipeline.ExecuteAsync(\n        token => TextSearchAsync(query, token),\n        cancellationToken);\n}\ncatch (RateLimiterRejectedException ex)\n{\n    // Handle RateLimiterRejectedException,\n    // that can optionally contain information about when to retry.\n    if (ex.RetryAfter is TimeSpan retryAfter)\n    {\n        Console.WriteLine($\"Retry After: {retryAfter}\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Cancellation Support in Polly Pipeline\nDESCRIPTION: Shows how to implement cancellation support in Polly's resilience pipeline using CancellationToken. Demonstrates both direct token usage and ResilienceContext approach.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/general.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Execute your code with cancellation support\nawait pipeline.ExecuteAsync(\n    static async token => await MyMethodAsync(token),\n    cancellationToken);\n\n// Use ResilienceContext for more advanced scenarios\nResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken: cancellationToken);\n\nawait pipeline.ExecuteAsync(\n    static async context => await MyMethodAsync(context.CancellationToken),\n    context);\n```\n\n----------------------------------------\n\nTITLE: Integrating Latency Chaos Strategy in a Complex Resilience Pipeline\nDESCRIPTION: Shows how to integrate the latency chaos strategy with other resilience strategies like retry and timeout in a pipeline. The chaos strategies are typically placed as the last ones in the pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/latency.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>(),\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,  // Adds a random factor to the delay\n        MaxRetryAttempts = 4,\n        Delay = TimeSpan.FromSeconds(3),\n    })\n    .AddTimeout(TimeSpan.FromSeconds(5))\n    .AddChaosLatency(new ChaosLatencyStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline\n    {\n        Latency = TimeSpan.FromSeconds(10),\n        InjectionRate = 0.1\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Fallback Strategy Options in C#\nDESCRIPTION: Demonstrates different ways to configure fallback strategy options including static substitutes, dynamic fallback actions, and handling callbacks. Shows how to handle both exceptions and null results with custom predicates.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// A fallback/substitute value if an operation fails.\nvar optionsSubstitute = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args => Outcome.FromResultAsValueTask(UserAvatar.Blank)\n};\n\n// Use a dynamically generated value if an operation fails.\nvar optionsFallbackAction = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args =>\n    {\n        var avatar = UserAvatar.GetRandomAvatar();\n        return Outcome.FromResultAsValueTask(avatar);\n    }\n};\n\n// Use a default or dynamically generated value, and execute an additional action if the fallback is triggered.\nvar optionsOnFallback = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args =>\n    {\n        var avatar = UserAvatar.GetRandomAvatar();\n        return Outcome.FromResultAsValueTask(UserAvatar.Blank);\n    },\n    OnFallback = static args =>\n    {\n        // Add extra logic to be executed when the fallback is triggered, such as logging.\n        return default; // Returns an empty ValueTask\n    }\n};\n\n// Add a fallback strategy with a FallbackStrategyOptions<TResult> instance to the pipeline\nnew ResiliencePipelineBuilder<UserAvatar>().AddFallback(optionsOnFallback);\n```\n\n----------------------------------------\n\nTITLE: Implementing Fallback After Retries Pattern in C#\nDESCRIPTION: Shows how to combine fallback and retry strategies in a resilience pipeline, with shared predicate handling for both HTTP exceptions and error status codes. The fallback acts as a final safety net after retry attempts are exhausted.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Define a common predicates re-used by both fallback and retries\nvar predicateBuilder = new PredicateBuilder<HttpResponseMessage>()\n    .Handle<HttpRequestException>()\n    .HandleResult(r => r.StatusCode == HttpStatusCode.InternalServerError);\n\nvar pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddFallback(new()\n    {\n        ShouldHandle = predicateBuilder,\n        FallbackAction = args =>\n        {\n            // Try to resolve the fallback response\n            HttpResponseMessage fallbackResponse = ResolveFallbackResponse(args.Outcome);\n\n            return Outcome.FromResultAsValueTask(fallbackResponse);\n        }\n    })\n    .AddRetry(new()\n    {\n        ShouldHandle = predicateBuilder,\n        MaxRetryAttempts = 3,\n    })\n    .Build();\n\n// Demonstrative execution that always produces invalid result\npipeline.Execute(() => new HttpResponseMessage(HttpStatusCode.InternalServerError));\n```\n\n----------------------------------------\n\nTITLE: Reusing Resilience Pipeline Instances in Polly (C#)\nDESCRIPTION: Illustrates how to reuse resilience pipeline instances using ResiliencePipelineRegistry<T> to cache pipelines dynamically, which can significantly improve performance by avoiding repeated pipeline creation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/performance.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MyApi\n{\n    private readonly ResiliencePipelineRegistry<string> _registry;\n\n    // Share a single instance of the registry throughout your application.\n    public MyApi(ResiliencePipelineRegistry<string> registry)\n    {\n        _registry = registry;\n    }\n\n    public async Task UpdateData(CancellationToken cancellationToken)\n    {\n        // Get or create the pipeline, and then cache it for subsequent use.\n        // Choose a sufficiently unique key to prevent collisions.\n        var pipeline = _registry.GetOrAddPipeline(\"my-app.my-api\", builder =>\n        {\n            builder.AddRetry(new()\n            {\n                ShouldHandle = new PredicateBuilder()\n                    .Handle<InvalidOperationException>()\n                    .Handle<HttpRequestException>()\n            });\n        });\n\n        await pipeline.ExecuteAsync(async token =>\n        {\n            // Place your logic here\n        },\n        cancellationToken);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiter Strategies in C# with Polly\nDESCRIPTION: Shows different ways to implement rate limiter strategies using Polly's ResiliencePipelineBuilder. Includes examples of using default options, setting concurrency limits, and creating a sliding window rate limiter.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// Add rate limiter with default options.\n// See https://www.pollydocs.org/strategies/rate-limiter#defaults for defaults.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions());\n\n// Create a rate limiter to allow a maximum of 100 concurrent executions and a queue of 50.\nnew ResiliencePipelineBuilder()\n    .AddConcurrencyLimiter(100, 50);\n\n// Create a rate limiter that allows 100 executions per minute.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new SlidingWindowRateLimiter(\n        new SlidingWindowRateLimiterOptions\n        {\n            PermitLimit = 100,\n            SegmentsPerWindow = 4,\n            Window = TimeSpan.FromMinutes(1)\n        }));\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiter Strategies in C#\nDESCRIPTION: Demonstrates three different approaches to implementing rate limiters: using default options, creating a concurrency limiter with specific limits, and configuring a sliding window rate limiter.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// Add rate limiter with default options.\n// See https://www.pollydocs.org/strategies/rate-limiter#defaults for defaults.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions());\n\n// Create a rate limiter to allow a maximum of 100 concurrent executions and a queue of 50.\nnew ResiliencePipelineBuilder()\n    .AddConcurrencyLimiter(100, 50);\n\n// Create a rate limiter that allows 100 executions per minute.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new SlidingWindowRateLimiter(\n        new SlidingWindowRateLimiterOptions\n        {\n            PermitLimit = 100,\n            SegmentsPerWindow = 4,\n            Window = TimeSpan.FromMinutes(1)\n        }));\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Verifying Resilience Pipeline Descriptors in C#\nDESCRIPTION: Demonstrates how to build a resilience pipeline with retry and timeout strategies, retrieve its descriptor, and assert on the pipeline's composition. The example shows verification of strategy count, retry settings, and timeout configuration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Testing/README.md#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n// Build your resilience pipeline.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        MaxRetryAttempts = 4\n    })\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\n// Retrieve the descriptor.\nResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor();\n\n// Check the pipeline's composition with the descriptor.\nAssert.Equal(2, descriptor.Strategies.Count);\n\n// Verify the retry settings.\nvar retryOptions = Assert.IsType<RetryStrategyOptions>(descriptor.Strategies[0].Options);\nAssert.Equal(4, retryOptions.MaxRetryAttempts);\n\n// Confirm the timeout settings.\nvar timeoutOptions = Assert.IsType<TimeoutStrategyOptions>(descriptor.Strategies[1].Options);\nAssert.Equal(TimeSpan.FromSeconds(1), timeoutOptions.Timeout);\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of Cancellation Token in Resilience Pipeline with Timeout\nDESCRIPTION: This example demonstrates the correct pattern where the callback respects the innerToken provided by the pipeline. This allows the timeout strategy to properly cancel the operation after 1 second and throw a TimeoutRejectedException.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\nawait pipeline.ExecuteAsync(\n    static async innerToken => await Task.Delay(TimeSpan.FromSeconds(3), innerToken),\n    outerToken);\n```\n\n----------------------------------------\n\nTITLE: Implementing ChaosOutcome with Retry in a Resilience Pipeline\nDESCRIPTION: Example showing how to combine a ChaosOutcomeStrategy with a RetryStrategy in a resilience pipeline, demonstrating a practical application of chaos engineering with error handling.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddRetry(new RetryStrategyOptions<HttpResponseMessage>\n    {\n        ShouldHandle = static args => args.Outcome switch\n        {\n            { Result.StatusCode: HttpStatusCode.InternalServerError } => PredicateResult.True(),\n            _ => PredicateResult.False()\n        },\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,\n        MaxRetryAttempts = 4,\n        Delay = TimeSpan.FromSeconds(3),\n    })\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage> // Chaos strategies are usually placed as the last ones in the pipeline\n    {\n        OutcomeGenerator = static args =>\n        {\n            var response = new HttpResponseMessage(HttpStatusCode.InternalServerError);\n            return ValueTask.FromResult<Outcome<HttpResponseMessage>?>(Outcome.FromResult(response));\n        },\n        InjectionRate = 0.1\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Handling Result-Based Retries in Polly v8\nDESCRIPTION: Demonstrates how to configure retries based on both exceptions and response results in Polly v8, using both PredicateBuilder and switch expressions for maximum flexibility and performance.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n// Shows how to add a retry strategy that also retries particular results.\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage>\n{\n    // PredicateBuilder is a convenience API that can used to configure the ShouldHandle predicate.\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(static result => result.StatusCode == HttpStatusCode.InternalServerError),\n    MaxRetryAttempts = 3,\n})\n.Build();\n\n// The same as above, but using the switch expressions for best performance.\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddRetry(new RetryStrategyOptions<HttpResponseMessage>\n{\n    // Determine what results to retry using switch expressions.\n    // Note that PredicateResult.True() is just a shortcut for \"new ValueTask<bool>(true)\".\n    ShouldHandle = static args => args.Outcome switch\n    {\n        { Exception: SomeExceptionType } => PredicateResult.True(),\n        { Result: { StatusCode: HttpStatusCode.InternalServerError } } => PredicateResult.True(),\n        _ => PredicateResult.False()\n    },\n    MaxRetryAttempts = 3,\n})\n.Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Chaos Strategies with Simmy in Polly v8\nDESCRIPTION: Demonstrates how to configure a resilience pipeline with chaos engineering strategies using Simmy. The example shows how to add fault injection (2% rate), latency injection (50% of remaining requests), outcome injection (10% of remaining requests), and behavior injection (1% of remaining requests) after regular resilience strategies.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\nvar builder = new ResiliencePipelineBuilder<HttpResponseMessage>();\n\n// First, configure regular resilience strategies\nbuilder\n    .AddConcurrencyLimiter(10, 100)\n    .AddRetry(new RetryStrategyOptions<HttpResponseMessage> { /* configure options */ })\n    .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage> { /* configure options */ })\n    .AddTimeout(TimeSpan.FromSeconds(5));\n\n// Finally, configure chaos strategies if you want to inject chaos.\n// These should come after the regular resilience strategies.\n\n// 2% of all requests will be injected with chaos fault.\nconst double FaultInjectionRate = 0.02;\n// For the remaining 98% of total requests, 50% of them will be injected with latency. Then 49% of total request will be injected with chaos latency.\n// Latency injection does not return early.\nconst double LatencyInjectionRate = 0.50;\n// For the remaining 98% of total requests, 10% of them will be injected with outcome. Then 9.8% of total request will be injected with chaos outcome.\nconst double OutcomeInjectionRate = 0.10;\n// For the remaining 88.2% of total requests, 1% of them will be injected with behavior. Then 0.882% of total request will be injected with chaos behavior.\nconst double BehaviorInjectionRate = 0.01;\n\nbuilder\n    .AddChaosFault(FaultInjectionRate, () => new InvalidOperationException(\"Injected by chaos strategy!\")) // Inject a chaos fault to executions\n    .AddChaosLatency(LatencyInjectionRate, TimeSpan.FromMinutes(1)) // Inject a chaos latency to executions\n    .AddChaosOutcome(OutcomeInjectionRate, () => new HttpResponseMessage(System.Net.HttpStatusCode.InternalServerError)) // Inject a chaos outcome to executions\n    .AddChaosBehavior(BehaviorInjectionRate, cancellationToken => RestartRedisAsync(cancellationToken)); // Inject a chaos behavior to executions\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Timeout-Retry-Timeout Pipeline in C#\nDESCRIPTION: Implements a three-layer resilience pipeline with an outer timeout (10 seconds), middle retry layer that handles timeout exceptions, and inner timeout (1 second) per attempt. This creates a sophisticated error handling structure with timeout boundaries at multiple levels.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(10)) // outer most\n    .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>() })\n    .AddTimeout(TimeSpan.FromSeconds(1)) // inner most\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Rate Limiters with Polly\nDESCRIPTION: This snippet demonstrates three ways to configure rate limiting in Polly: using default options, setting up a concurrency limiter with specific capacity parameters, and creating a sliding window rate limiter that allows a certain number of executions per time window.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.RateLimiting/README.md#2025-04-18_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// Add rate limiter with default options.\n// See https://www.pollydocs.org/strategies/rate-limiter#defaults for defaults.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions());\n\n// Create a rate limiter to allow a maximum of 100 concurrent executions and a queue of 50.\nnew ResiliencePipelineBuilder()\n    .AddConcurrencyLimiter(100, 50);\n\n// Create a rate limiter that allows 100 executions per minute.\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new SlidingWindowRateLimiter(\n        new SlidingWindowRateLimiterOptions\n        {\n            PermitLimit = 100,\n            SegmentsPerWindow = 4,\n            Window = TimeSpan.FromMinutes(1)\n        }));\n```\n\n----------------------------------------\n\nTITLE: Safe Execution with ExecuteOutcomeAsync in Polly v8\nDESCRIPTION: Shows how to use ExecuteOutcomeAsync for safe execution in Polly v8, including handling results, accessing context data, and managing the ResilienceContext lifecycle.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_22\n\nLANGUAGE: cs\nCODE:\n```\nResiliencePipeline<int> pipeline = new ResiliencePipelineBuilder<int>()\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\n// Synchronous execution\n// Polly v8 does not support\n\n// Asynchronous execution\nvar context = ResilienceContextPool.Shared.Get();\nOutcome<int> pipelineResult = await pipeline.ExecuteOutcomeAsync(\n    static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\");\nResilienceContextPool.Shared.Return(context);\n\n// Assess policy result\nif (pipelineResult.Exception is null)\n{\n    int result = pipelineResult.Result;\n\n    // Process result\n}\nelse\n{\n    Exception exception = pipelineResult.Exception;\n\n    // Process failure\n\n    // If needed you can rethrow the exception\n    pipelineResult.ThrowIfException();\n}\n\n// Access context\nResiliencePropertyKey<string> contextKey = new(\"context_key\");\nResiliencePipeline<int> pipelineWithContext = new ResiliencePipelineBuilder<int>()\n    .AddTimeout(new TimeoutStrategyOptions\n    {\n        Timeout = TimeSpan.FromSeconds(1),\n        OnTimeout = args =>\n        {\n            args.Context.Properties.Set(contextKey, \"context_value\");\n            return default;\n        }\n    })\n    .Build();\n\ncontext = ResilienceContextPool.Shared.Get();\npipelineResult = await pipelineWithContext.ExecuteOutcomeAsync(\n    static async (ctx, state) => Outcome.FromResult(await MethodAsync(ctx.CancellationToken)), context, \"state\");\n\ncontext.Properties.TryGetValue(contextKey, out var ctxValue);\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern: Separating ChaosFault and ChaosOutcome Strategies\nDESCRIPTION: The recommended approach separates fault injection from outcome generation, providing better telemetry tracking and more granular control over injection rates and conditions for each strategy type.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosFault(new ChaosFaultStrategyOptions\n    {\n        InjectionRate = 0.1, // Different injection rate for faults\n        EnabledGenerator = static args => ShouldEnableFaults(args.Context), // Different settings might apply to inject faults\n        FaultGenerator = static args =>\n        {\n            Exception? exception = RandomThreshold switch\n            {\n                >= 250 and < 350 => new HttpRequestException(\"Chaos request exception.\"),\n                _ => null\n            };\n\n            return ValueTask.FromResult(exception);\n        },\n        OnFaultInjected = static args =>\n        {\n            Console.WriteLine($\"OnFaultInjected, Exception: {args.Fault.Message}, Operation: {args.Context.OperationKey}.\");\n            return default;\n        }\n    })\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n    {\n        InjectionRate = 0.5, // Different injection rate for outcomes\n        EnabledGenerator = static args => ShouldEnableOutcome(args.Context), // Different settings might apply to inject outcomes\n        OutcomeGenerator = static args =>\n        {\n            HttpStatusCode statusCode = RandomThreshold switch\n            {\n                < 100 => HttpStatusCode.InternalServerError,\n                < 150 => HttpStatusCode.TooManyRequests,\n                < 250 => CreateResultFromContext(args.Context),\n                _ => HttpStatusCode.OK\n            };\n\n            return ValueTask.FromResult<Outcome<HttpResponseMessage>?>(Outcome.FromResult(new HttpResponseMessage(statusCode)));\n        },\n        OnOutcomeInjected = static args =>\n        {\n            Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\");\n            return default;\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Creating a Central Chaos Pipeline in C#\nDESCRIPTION: Defines a central chaos pipeline that adds fault and latency strategies which can be reused across various resilience pipelines. It injects exceptions like TimeoutException and HttpRequestException and adds a 60-second latency.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nservices.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) =>\n{\n    var chaosManager = context.ServiceProvider.GetRequiredService<IChaosManager>();\n\n    builder\n        .AddChaosFault(new ChaosFaultStrategyOptions\n        {\n            FaultGenerator = new FaultGenerator()\n                .AddException<TimeoutException>()\n                .AddException<HttpRequestException>()\n        })\n        .AddChaosLatency(new ChaosLatencyStrategyOptions\n        {\n            Latency = TimeSpan.FromSeconds(60)\n        });\n});\n```\n\n----------------------------------------\n\nTITLE: Pattern: Comprehensive Exception Remapping with Value Tasks in C#\nDESCRIPTION: An extended example showing how to implement exception remapping in a public method that internally calls a private action method, with proper resource management for resilience contexts.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic static async ValueTask<HttpResponseMessage> Action()\n{\n    var context = ResilienceContextPool.Shared.Get();\n    var outcome = await WhateverPipeline.ExecuteOutcomeAsync<HttpResponseMessage, string>(\n        async (ctx, state) =>\n        {\n            var result = await ActionCore();\n            return Outcome.FromResult(result);\n        }, context, \"state\");\n\n    if (outcome.Exception is HttpRequestException requestException)\n    {\n        throw new CustomNetworkException(\"Replace thrown exception\", requestException);\n    }\n\n    ResilienceContextPool.Shared.Return(context);\n    return outcome.Result!;\n}\n\nprivate static ValueTask<HttpResponseMessage> ActionCore()\n{\n    // The core logic\n    return ValueTask.FromResult(new HttpResponseMessage());\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Polly v8 Resilience Pipeline to v7 Policy in C#\nDESCRIPTION: This snippet demonstrates how to create a v8 resilience pipeline with a rate limiter, convert it to both sync and async v7 policies, and use it in a v7 policy wrap. It requires the Polly.RateLimiting package for the AddRateLimiter extension.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\n// First, create a resilience pipeline.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions\n    {\n        Window = TimeSpan.FromSeconds(10),\n        PermitLimit = 100\n    }))\n    .Build();\n\n// Now, convert it to a v7 policy. Note that it can be converted to both sync and async policies.\nISyncPolicy syncPolicy = pipeline.AsSyncPolicy();\nIAsyncPolicy asyncPolicy = pipeline.AsAsyncPolicy();\n\n// Finally, use it in a policy wrap.\nISyncPolicy wrappedPolicy = Policy.Wrap(\n    syncPolicy,\n    Policy.Handle<SomeExceptionType>().Retry(3));\n```\n\n----------------------------------------\n\nTITLE: Customizing Telemetry Event Severity in C#\nDESCRIPTION: This code demonstrates how to customize the severity of telemetry events in Polly API. It shows how to override the default severity for specific events like 'OnRetry' and 'ExecutionAttempt' using a SeverityProvider delegate.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddResiliencePipeline(\"my-strategy\", (builder, context) =>\n{\n    // Create a new instance of telemetry options by using copy-constructor of the global ones.\n    // This ensures that common configuration is preserved.\n    var telemetryOptions = new TelemetryOptions(context.GetOptions<TelemetryOptions>());\n\n    telemetryOptions.SeverityProvider = args => args.Event.EventName switch\n    {\n        // Decrease severity of specific events\n        \"OnRetry\" => ResilienceEventSeverity.Debug,\n        \"ExecutionAttempt\" => ResilienceEventSeverity.Debug,\n        _ => args.Event.Severity\n    };\n\n    builder.AddRetry(new RetryStrategyOptions());\n\n    // Override the telemetry configuration for this pipeline.\n    builder.ConfigureTelemetry(telemetryOptions);\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Rate Limiter with OnRejected Callback in C#\nDESCRIPTION: Demonstrates how to configure a rate limiter with a custom OnRejected callback to handle rejections in-line without try-catch blocks. This approach is useful when composing multiple resilience strategies.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\nvar withOnRejected = new ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions\n    {\n        DefaultRateLimiterOptions = new ConcurrencyLimiterOptions\n        {\n            PermitLimit = 10\n        },\n        OnRejected = args =>\n        {\n            Console.WriteLine(\"Rate limit has been exceeded\");\n            return default;\n        }\n    }).Build();\n```\n\n----------------------------------------\n\nTITLE: Adding Resilience Pipeline to ServiceCollection\nDESCRIPTION: Demonstrates how to register a resilience pipeline in the dependency injection container, configure it with strategies, and then resolve and use it.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Define a resilience pipeline\nservices.AddResiliencePipeline(\"my-key\", builder =>\n{\n    // Add strategies to your pipeline here, timeout for example\n    builder.AddTimeout(TimeSpan.FromSeconds(10));\n});\n\n// You can also access IServiceProvider by using the alternate overload\nservices.AddResiliencePipeline(\"my-key\", (builder, context) =>\n{\n    // Resolve any service from DI\n    var loggerFactory = context.ServiceProvider.GetRequiredService<ILoggerFactory>();\n\n    // Add strategies to your pipeline here\n    builder.AddTimeout(TimeSpan.FromSeconds(10));\n});\n\n// Resolve the resilience pipeline\nServiceProvider serviceProvider = services.BuildServiceProvider();\nResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>();\nResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-key\");\n\n// Use it\nawait pipeline.ExecuteAsync(\n    static async cancellation => await Task.Delay(100, cancellation));\n```\n\n----------------------------------------\n\nTITLE: Integrating Central Chaos Pipeline with Resilience Pipeline in C#\nDESCRIPTION: Shows how to integrate a centrally defined chaos pipeline into a specific resilience pipeline using ResiliencePipelineProvider<T>. The pipeline includes retry and timeout strategies along with the injected chaos pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nservices.AddResiliencePipeline(\"my-pipeline-1\", (builder, context) =>\n{\n    var pipelineProvider = context.ServiceProvider.GetRequiredService<ResiliencePipelineProvider<string>>();\n    var chaosPipeline = pipelineProvider.GetPipeline(\"chaos-pipeline\");\n\n    builder\n        .AddRetry(new RetryStrategyOptions())\n        .AddTimeout(TimeSpan.FromSeconds(5))\n        .AddPipeline(chaosPipeline); // Inject central chaos pipeline\n\n});\n```\n\n----------------------------------------\n\nTITLE: Optimizing Lambda Expressions in Polly Execution (C#)\nDESCRIPTION: Demonstrates how to use static lambdas to avoid allocations when executing resilience pipelines. This approach passes the state as an argument instead of capturing variables from the outer scope.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/performance.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// This call allocates for each invocation since the \"userId\" variable is captured from the outer scope.\nawait resiliencePipeline.ExecuteAsync(\n    cancellationToken => GetMemberAsync(userId, cancellationToken),\n    cancellationToken);\n\n// This approach uses a static lambda, avoiding allocations.\n// The \"userId\" is passed to the execution via the state argument, and the lambda consumes it as the first\n// parameter passed to the GetMemberAsync() method. In this case, userIdAsState and userId are the same value.\nawait resiliencePipeline.ExecuteAsync(\n    static (userIdAsState, cancellationToken) => GetMemberAsync(userIdAsState, cancellationToken),\n    userId,\n    cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Configuring Fallback Strategies in Polly (C#)\nDESCRIPTION: Illustrates different configurations for fallback strategies, including substituting a default value, generating a dynamic fallback value, and executing additional actions when fallback is triggered. It also shows how to add fallback strategies to a resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// A fallback/substitute value if an operation fails.\nvar optionsSubstitute = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args => Outcome.FromResultAsValueTask(UserAvatar.Blank)\n};\n\n// Use a dynamically generated value if an operation fails.\nvar optionsFallbackAction = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args =>\n    {\n        var avatar = UserAvatar.GetRandomAvatar();\n        return Outcome.FromResultAsValueTask(avatar);\n    }\n};\n\n// Use a default or dynamically generated value, and execute an additional action if the fallback is triggered.\nvar optionsOnFallback = new FallbackStrategyOptions<UserAvatar>\n{\n    ShouldHandle = new PredicateBuilder<UserAvatar>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(r => r is null),\n    FallbackAction = static args =>\n    {\n        var avatar = UserAvatar.GetRandomAvatar();\n        return Outcome.FromResultAsValueTask(UserAvatar.Blank);\n    },\n    OnFallback = static args =>\n    {\n        // Add extra logic to be executed when the fallback is triggered, such as logging.\n        return default; // Returns an empty ValueTask\n    }\n};\n\n// Add a fallback strategy with a FallbackStrategyOptions<TResult> instance to the pipeline\nnew ResiliencePipelineBuilder<UserAvatar>().AddFallback(optionsOnFallback);\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Reloads for Resilience Pipelines\nDESCRIPTION: Demonstrates how to enable dynamic reloading of resilience pipelines when the underlying configuration changes, using named options.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nservices\n    .Configure<RetryStrategyOptions>(\"my-retry-options\", configurationSection) // Configure the options\n    .AddResiliencePipeline(\"my-pipeline\", (builder, context) =>\n    {\n        // Enable the reloads whenever the named options change\n        context.EnableReloads<RetryStrategyOptions>(\"my-retry-options\");\n\n        // Utility method to retrieve the named options\n        var retryOptions = context.GetOptions<RetryStrategyOptions>(\"my-retry-options\");\n\n        // Add retries using the resolved options\n        builder.AddRetry(retryOptions);\n    });\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Failure Domains with Separate Strategies in C#\nDESCRIPTION: Illustrates how to handle different failure domains (network calls and deserialization) using separate resilience strategies for improved reliability.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(),\n        MaxRetryAttempts = 3\n    })\n    .Build();\n\nvar stream = await retry.ExecuteAsync(\n    static async (httpClient, ct) =>\n        await httpClient.GetStreamAsync(new Uri(\"endpoint\"), ct),\n    httpClient);\n\nvar timeout = new ResiliencePipelineBuilder<Foo>()\n    .AddTimeout(TimeSpan.FromMinutes(1))\n    .Build();\n\nvar foo = await timeout.ExecuteAsync((ct) => JsonSerializer.DeserializeAsync<Foo>(stream, cancellationToken: ct));\n```\n\n----------------------------------------\n\nTITLE: Outcome-based Execution with ResiliencePipeline in C#\nDESCRIPTION: Demonstrates how to use the ExecuteOutcomeAsync method to handle execution results and exceptions using the Outcome<T> struct for high-performance scenarios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Acquire a ResilienceContext from the pool\nResilienceContext context = ResilienceContextPool.Shared.Get();\n\n// Execute the pipeline and store the result in an Outcome<bool>\nOutcome<bool> outcome = await pipeline.ExecuteOutcomeAsync(\n    static async (context, state) =>\n    {\n        Console.WriteLine(\"State: {0}\", state);\n\n        try\n        {\n            await MyMethodAsync(context.CancellationToken);\n\n            // Use static utility methods from Outcome to easily create an Outcome<T> instance\n            return Outcome.FromResult(true);\n        }\n        catch (Exception e)\n        {\n            // Create an Outcome<T> instance that holds the exception\n            return Outcome.FromException<bool>(e);\n        }\n    },\n    context,\n    \"my-state\");\n\n// Return the acquired ResilienceContext to the pool\nResilienceContextPool.Shared.Return(context);\n\n// Evaluate the outcome\nif (outcome.Exception is not null)\n{\n    Console.WriteLine(\"Execution Failed: {0}\", outcome.Exception.Message);\n}\nelse\n{\n    Console.WriteLine(\"Execution Result: {0}\", outcome.Result);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Hedging Strategies in Polly (C#)\nDESCRIPTION: Demonstrates configurations for hedging strategies, including default options, complex behavior with custom handling and delay, and event subscription. It also shows how to add hedging strategies to a resilience pipeline for HTTP responses.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Hedging with default options.\n// See https://www.pollydocs.org/strategies/hedging#defaults for defaults.\nvar optionsDefaults = new HedgingStrategyOptions<HttpResponseMessage>();\n\n// A customized hedging strategy that retries up to 3 times if the execution\n// takes longer than 1 second or if it fails due to an exception or returns an HTTP 500 Internal Server Error.\nvar optionsComplex = new HedgingStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .Handle<SomeExceptionType>()\n        .HandleResult(response => response.StatusCode == HttpStatusCode.InternalServerError),\n    MaxHedgedAttempts = 3,\n    Delay = TimeSpan.FromSeconds(1),\n    ActionGenerator = static args =>\n    {\n        Console.WriteLine(\"Preparing to execute hedged action.\");\n\n        // Return a delegate function to invoke the original action with the action context.\n        // Optionally, you can also create a completely new action to be executed.\n        return () => args.Callback(args.ActionContext);\n    }\n};\n\n// Subscribe to hedging events.\nvar optionsOnHedging = new HedgingStrategyOptions<HttpResponseMessage>\n{\n    OnHedging = static args =>\n    {\n        Console.WriteLine($\"OnHedging: Attempt number {args.AttemptNumber}\");\n        return default;\n    }\n};\n\n// Add a hedging strategy with a HedgingStrategyOptions<TResult> instance to the pipeline\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddHedging(optionsDefaults);\n```\n\n----------------------------------------\n\nTITLE: Registering and Using Resilience Pipelines in C#\nDESCRIPTION: Demonstrates how to register pipeline builders, fetch pipelines, and handle non-existent pipelines using the ResiliencePipelineRegistry<string>.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar registry = new ResiliencePipelineRegistry<string>();\n\n// Register builder for pipeline \"A\"\nregistry.TryAddBuilder(\"A\", (builder, context) =>\n{\n    // Define your pipeline\n    builder.AddRetry(new RetryStrategyOptions());\n});\n\n// Register generic builder for pipeline \"A\"; you can use the same key\n// because generic and non-generic pipelines are stored separately\nregistry.TryAddBuilder<HttpResponseMessage>(\"A\", (builder, context) =>\n{\n    // Define your pipeline\n    builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>());\n});\n\n// Fetch pipeline \"A\"\nResiliencePipeline pipelineA = registry.GetPipeline(\"A\");\n\n// Fetch generic pipeline \"A\"\nResiliencePipeline<HttpResponseMessage> genericPipelineA = registry.GetPipeline<HttpResponseMessage>(\"A\");\n\n// Returns false since pipeline \"unknown\" isn't registered\nvar doesPipelineExist = registry.TryGetPipeline(\"unknown\", out var pipeline);\n\n// Throws KeyNotFoundException because pipeline \"unknown\" isn't registered\ntry\n{\n    registry.GetPipeline(\"unknown\");\n}\ncatch (KeyNotFoundException)\n{\n    // Handle the exception\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Resource Disposal in ResiliencePipelineRegistry in C#\nDESCRIPTION: Demonstrates how disposing of the registry affects the pipelines it manages and how to handle disposed pipelines.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar registry = new ResiliencePipelineRegistry<string>();\n\n// This instance is valid even after reload.\nResiliencePipeline pipeline = registry\n    .GetOrAddPipeline(\"A\", (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10)));\n\n// Dispose the registry\nregistry.Dispose();\n\ntry\n{\n    pipeline.Execute(() => { });\n}\ncatch (ObjectDisposedException)\n{\n    // Using a pipeline that was disposed by the registry\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Resilience Pipeline in F#\nDESCRIPTION: This snippet demonstrates how to use the Polly ResiliencePipeline in F#. It shows synchronous and asynchronous execution, handling of ValueTask, and the use of the IcedTasks library for easier ValueTask management.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/use-with-fsharp-and-visual-basic.md#2025-04-18_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nopen FSharp.Control\nopen System\nopen System.Threading\nopen System.Threading.Tasks\nopen IcedTasks\nopen Polly\n\nlet getBestFilmAsync token =\n    task {\n        do! Task.Delay(1000, token)\n        return \"https://www.imdb.com/title/tt0080684/\"\n    }\n\nlet demo () =\n    task {\n        // The ResiliencePipelineBuilder creates a ResiliencePipeline\n        // that can be executed synchronously or asynchronously\n        // and for both void and result-returning user-callbacks.\n        let pipeline =\n            ResiliencePipelineBuilder()\n                .AddTimeout(TimeSpan.FromSeconds(5))\n                .Build()\n\n        let token = CancellationToken.None\n\n        // Synchronously\n        pipeline.Execute(fun () -> printfn \"Hello, world!\")\n\n        // Asynchronously\n        // Note that Polly expects a ValueTask to be returned, so the function uses the valueTask builder\n        // from IcedTasks to make it easier to use ValueTask. See https://github.com/TheAngryByrd/IcedTasks.\n        do! pipeline.ExecuteAsync(\n            fun token ->\n                valueTask {\n                    printfn \"Hello, world! Waiting for 2 seconds...\"\n                    do! Task.Delay(1000, token)\n                    printfn \"Wait complete.\"\n                }\n            , token\n        )\n\n        // Synchronously with result\n        let someResult = pipeline.Execute(fun token -> \"some-result\")\n\n        // Asynchronously with result\n        // Note that Polly expects a ValueTask<T> to be returned, so the function uses the valueTask builder\n        // from IcedTasks to make it easier to use ValueTask<T>. See https://github.com/TheAngryByrd/IcedTasks.\n        let! bestFilm = pipeline.ExecuteAsync(\n            fun token ->\n                valueTask {\n                    let! url = getBestFilmAsync(token)\n                    return url\n                }\n            , token\n        )\n\n        printfn $\"Link to the best film: {bestFilm}\"\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiter Disposal in a ResiliencePipeline Registry\nDESCRIPTION: A complete example demonstrating how to properly dispose rate limiters in a Polly resilience pipeline. The code creates a registry adapter that manages multiple types of rate limiters (concurrency, fixed window) and ensures they are properly disposed when the pipeline or registry is disposed.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class Program\n{\n    public static void Main()\n    {\n        using var registryAdapter = new PipelineRegistryAdapter();\n        registryAdapter.GetOrCreateResiliencePipeline(\"Pipeline foo\", 1, 10, 100, 1000);\n        registryAdapter.GetOrCreateResiliencePipeline(\"Pipeline bar\", 2, 20, 200, 2000);\n    }\n}\n\npublic sealed class PipelineRegistryAdapter : IDisposable\n{\n    private readonly ResiliencePipelineRegistry<string> _resiliencePipelineRegistry = new();\n    private bool _disposed;\n\n    public void Dispose()\n    {\n        if (!_disposed)\n        {\n            _resiliencePipelineRegistry.Dispose();\n            _disposed = true;\n        }\n    }\n\n    private static PartitionedRateLimiter<ResilienceContext> CreateConcurrencyLimiter(string partitionKey, int permitLimit) =>\n        PartitionedRateLimiter.Create<ResilienceContext, string>(context =>\n            RateLimitPartition.GetConcurrencyLimiter(\n                partitionKey: partitionKey,\n                factory: partitionKey => new ConcurrencyLimiterOptions { PermitLimit = permitLimit, QueueLimit = 0 }));\n\n    private static PartitionedRateLimiter<ResilienceContext> CreateFixedWindowLimiter(string partitionKey, int permitLimit, TimeSpan window) =>\n        PartitionedRateLimiter.Create<ResilienceContext, string>(context =>\n            RateLimitPartition.GetFixedWindowLimiter(\n                partitionKey: partitionKey,\n                factory: partitionKey => new FixedWindowRateLimiterOptions { PermitLimit = permitLimit, QueueLimit = 0, Window = window }));\n\n    public ResiliencePipeline GetOrCreateResiliencePipeline(string partitionKey, int maximumConcurrentThreads, int sendLimitPerSecond, int sendLimitPerHour, int sendLimitPerDay)\n    {\n        return _resiliencePipelineRegistry.GetOrAddPipeline(partitionKey, (builder, context) =>\n        {\n            PartitionedRateLimiter<ResilienceContext>? threadLimiter = null;\n            PartitionedRateLimiter<ResilienceContext>? requestLimiter = null;\n\n            // outer strategy: limit threads\n            builder.AddRateLimiter(new RateLimiterStrategyOptions\n            {\n                RateLimiter = args =>\n                {\n                    threadLimiter = CreateConcurrencyLimiter(partitionKey, maximumConcurrentThreads);\n                    return threadLimiter.AcquireAsync(args.Context, permitCount: 1, args.Context.CancellationToken);\n                }\n            });\n\n            // inner strategy: limit requests (by second, hour, day)\n            builder.AddRateLimiter(new RateLimiterStrategyOptions\n            {\n                RateLimiter = args =>\n                {\n                    PartitionedRateLimiter<ResilienceContext>[] limiters = [\n                        CreateFixedWindowLimiter(partitionKey, sendLimitPerSecond, TimeSpan.FromSeconds(1)),\n                        CreateFixedWindowLimiter(partitionKey, sendLimitPerHour,   TimeSpan.FromHours(1)),\n                        CreateFixedWindowLimiter(partitionKey, sendLimitPerDay,    TimeSpan.FromDays(1)),\n                    ];\n                    requestLimiter = PartitionedRateLimiter.CreateChained(limiters);\n                    return requestLimiter.AcquireAsync(args.Context, permitCount: 1, args.Context.CancellationToken);\n                }\n            });\n\n            // unlike other strategies, rate limiters disposed manually\n            context.OnPipelineDisposed(() =>\n            {\n                threadLimiter?.Dispose();\n                requestLimiter?.Dispose();\n            });\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing URL-based Retry Logic in C#\nDESCRIPTION: Demonstrates how to implement retry logic based on the request URL using the ShouldHandle clause, which provides better extensibility and readability.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar retry = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddRetry(new()\n    {\n        ShouldHandle = _ => ValueTask.FromResult(IsRetryable(request.RequestUri))\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring Manual Fault Handling Predicates\nDESCRIPTION: Shows how to manually configure fault handling predicates using switch expressions to handle specific exceptions and HTTP response conditions.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/index.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new RetryStrategyOptions<HttpResponseMessage>\n{\n    // For greater flexibility, you can directly use the ShouldHandle delegate with switch expressions.\n    ShouldHandle = args => args.Outcome switch\n    {\n        { Exception: HttpRequestException } => PredicateResult.True(),\n        { Exception: TimeoutRejectedException } => PredicateResult.True(), // You can handle multiple exceptions\n        { Result: HttpResponseMessage response } when !response.IsSuccessStatusCode => PredicateResult.True(),\n        _ => PredicateResult.False()\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Visualizing Complex Unhappy Path Circuit Breaker Behavior\nDESCRIPTION: This sequence diagram illustrates the behavior of a circuit breaker in various states, including Closed, Open, and HalfOpen. It shows how the circuit breaker responds to failures, transitions between states, and handles requests during different phases.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant CB as CircuitBreaker\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Closed state\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    Note over CB: Moves to Open state\n    Note over CB: Break duration start\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB-->>CB: Rejects request\n    CB->>P: Throws <br/>BrokenCircuitException\n    P->>C: Propagates exception\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Break duration end\n    Note over CB: Moves to HalfOpen state\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    Note over CB: Moves to Open state\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n```\n\n----------------------------------------\n\nTITLE: Working with ResiliencePipelineRegistry in Polly v8\nDESCRIPTION: Shows how to create and use a ResiliencePipelineRegistry in Polly v8, including adding pipeline builders and retrieving pipelines.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_24\n\nLANGUAGE: cs\nCODE:\n```\n// Create a registry\nvar registry = new ResiliencePipelineRegistry<string>();\n\n// Add a pipeline using a builder, when the pipeline is retrieved it will be dynamically built and cached\nregistry.TryAddBuilder(PipelineKey, (builder, context) => builder.AddTimeout(TimeSpan.FromSeconds(10)));\n\n// Try get a pipeline\nregistry.TryGetPipeline(PipelineKey, out ResiliencePipeline? pipeline);\n\n// Try get a generic pipeline\nregistry.TryGetPipeline<string>(PipelineKey, out ResiliencePipeline<string>? genericPipeline);\n\n// Get or add pipeline\nregistry.GetOrAddPipeline(PipelineKey, builder => builder.AddTimeout(TimeSpan.FromSeconds(10)));\n```\n\n----------------------------------------\n\nTITLE: Implementing Selective Chaos Injection based on Environment in C#\nDESCRIPTION: Demonstrates how to configure a chaos pipeline that selectively applies fault injection based on the environment (development, staging, production) and specific users or tenants. It shows dynamic adjustment of injection rates and conditional enabling of chaos strategies.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddResiliencePipeline(\"chaos-pipeline\", (builder, context) =>\n{\n    var environment = context.ServiceProvider.GetRequiredService<IHostEnvironment>();\n\n    builder.AddChaosFault(new ChaosFaultStrategyOptions\n    {\n        EnabledGenerator = args =>\n        {\n            // Enable chaos in development and staging environments.\n            if (environment.IsDevelopment() || environment.IsStaging())\n            {\n                return ValueTask.FromResult(true);\n            }\n\n            // Enable chaos for specific users or tenants, even in production environments.\n            if (ShouldEnableChaos(args.Context))\n            {\n                return ValueTask.FromResult(true);\n            }\n\n            return ValueTask.FromResult(false);\n        },\n        InjectionRateGenerator = args =>\n        {\n            if (environment.IsStaging())\n            {\n                // 1% chance of failure on staging environments.\n                return ValueTask.FromResult(0.01);\n            }\n\n            if (environment.IsDevelopment())\n            {\n                // 5% chance of failure on development environments.\n                return ValueTask.FromResult(0.05);\n            }\n\n            // The context can carry information to help determine the injection rate.\n            // For instance, in production environments, you might have certain test users or tenants\n            // for whom you wish to inject chaos.\n            if (ResolveInjectionRate(args.Context, out double injectionRate))\n            {\n                return ValueTask.FromResult(injectionRate);\n            }\n\n            // No chaos on production environments.\n            return ValueTask.FromResult(0.0);\n        },\n        FaultGenerator = new FaultGenerator()\n            .AddException<TimeoutException>()\n            .AddException<HttpRequestException>()\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout Strategy in Polly v8\nDESCRIPTION: Demonstrates how to implement timeout functionality in Polly v8 using ResiliencePipeline, which supports both synchronous and asynchronous executions in a single unified API.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n// Create pipeline with timeout. Because ResiliencePipeline supports both sync and async\n// callbacks, there is no need to define it twice.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(10))\n    .Build();\n\n// Create a generic pipeline with timeout. Because ResiliencePipeline<T> supports both sync and async\n// callbacks, there is no need to define it twice.\nResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddTimeout(TimeSpan.FromSeconds(10))\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern: Using ChaosFaultStrategy for Exception Injection\nDESCRIPTION: The correct approach for injecting exceptions is to use the dedicated ChaosFaultStrategy, which properly tracks faults as distinct from other outcomes and provides better telemetry.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosFault(new ChaosFaultStrategyOptions\n    {\n        FaultGenerator = new FaultGenerator()\n            .AddException<HttpRequestException>(),\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring Fault Chaos Strategy Options in Polly\nDESCRIPTION: Demonstrates different ways to configure ChaosFaultStrategyOptions, including basic exception injection, custom fault generators, and fault injection notifications. Shows how to add fault strategies to a resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/fault.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// 10% of invocations will be randomly affected and one of the exceptions will be thrown (equal probability).\nvar optionsBasic = new ChaosFaultStrategyOptions\n{\n    FaultGenerator = new FaultGenerator()\n        .AddException<InvalidOperationException>() // Uses default constructor\n        .AddException(() => new TimeoutException(\"Chaos timeout injected.\")), // Custom exception generator\n    InjectionRate = 0.1\n};\n\n// To use a custom delegate to generate the fault to be injected\nvar optionsWithFaultGenerator = new ChaosFaultStrategyOptions\n{\n    FaultGenerator = static args =>\n    {\n        Exception? exception = args.Context.OperationKey switch\n        {\n            \"DataLayer\" => new TimeoutException(),\n            \"ApplicationLayer\" => new InvalidOperationException(),\n            // When the fault generator returns null, the strategy won't inject\n            // any fault and just invokes the user's callback.\n            _ => null\n        };\n\n        return new ValueTask<Exception?>(exception);\n    },\n    InjectionRate = 0.1\n};\n\n// To get notifications when a fault is injected\nvar optionsOnFaultInjected = new ChaosFaultStrategyOptions\n{\n    FaultGenerator = new FaultGenerator().AddException<InvalidOperationException>(),\n    InjectionRate = 0.1,\n    OnFaultInjected = static args =>\n    {\n        Console.WriteLine(\"OnFaultInjected, Exception: {0}, Operation: {1}.\", args.Fault.Message, args.Context.OperationKey);\n        return default;\n    }\n};\n\n// Add a fault strategy with a ChaosFaultStrategyOptions instance to the pipeline\nnew ResiliencePipelineBuilder().AddChaosFault(optionsBasic);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosFault(optionsWithFaultGenerator);\n\n// There are also a couple of handy overloads to inject the chaos easily\nnew ResiliencePipelineBuilder().AddChaosFault(0.1, () => new InvalidOperationException(\"Dummy exception\"));\n```\n\n----------------------------------------\n\nTITLE: Configuring Telemetry in Polly\nDESCRIPTION: Example showing how to configure telemetry options, including logging, enrichers, and listeners with the ResiliencePipelineBuilder.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar telemetryOptions = new TelemetryOptions\n{\n    // Configure logging\n    LoggerFactory = LoggerFactory.Create(builder => builder.AddConsole())\n};\n\n// Configure enrichers\ntelemetryOptions.MeteringEnrichers.Add(new MyMeteringEnricher());\n\n// Configure telemetry listeners\ntelemetryOptions.TelemetryListeners.Add(new MyTelemetryListener());\n\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Recommended Pattern: Accessing IServiceProvider in C#\nDESCRIPTION: This snippet shows the recommended approach to access IServiceProvider in AddResiliencePipeline(). It uses an overload that provides access to the already built ServiceProvider, avoiding unnecessary rebuilds.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\nservices.AddResiliencePipeline(\"myFavoriteStrategy\", static (builder, context) =>\n{\n    builder.AddRetry(new()\n    {\n        OnRetry = args =>\n        {\n            var logger = context.ServiceProvider.GetService<ILogger>();\n            // ...\n            return default;\n        }\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Resilience Pipelines\nDESCRIPTION: Shows how to define and use a generic resilience pipeline (ResiliencePipeline<T>) with HTTP response handling, including retry and timeout strategies.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Define a generic resilience pipeline\n// First parameter is the type of key, second one is the type of the results the generic pipeline works with\nservices.AddResiliencePipeline<string, HttpResponseMessage>(\"my-pipeline\", builder =>\n{\n    builder.AddRetry(new()\n    {\n        MaxRetryAttempts = 2,\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .Handle<HttpRequestException>()\n            .Handle<TimeoutRejectedException>()\n            .HandleResult(response => response.StatusCode == System.Net.HttpStatusCode.InternalServerError)\n    })\n    .AddTimeout(TimeSpan.FromSeconds(2));\n});\n\n// Resolve the resilience pipeline\nServiceProvider serviceProvider = services.BuildServiceProvider();\nResiliencePipelineProvider<string> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>();\nResiliencePipeline<HttpResponseMessage> pipeline = pipelineProvider.GetPipeline<HttpResponseMessage>(\"my-key\");\n\n// Use it\nawait pipeline.ExecuteAsync(\n    async cancellation => await client.GetAsync(endpoint, cancellation),\n    cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Retrieving and Verifying ResiliencePipeline Descriptor\nDESCRIPTION: Demonstrates how to use GetPipelineDescriptor to obtain information about a pipeline's composition and verify its settings like retry attempts and timeout values.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/testing.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\n// Build your resilience pipeline.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        MaxRetryAttempts = 4\n    })\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\n// Retrieve the descriptor.\nResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor();\n\n// Check the pipeline's composition with the descriptor.\nAssert.Equal(2, descriptor.Strategies.Count);\n\n// Verify the retry settings.\nvar retryOptions = Assert.IsType<RetryStrategyOptions>(descriptor.Strategies[0].Options);\nAssert.Equal(4, retryOptions.MaxRetryAttempts);\n\n// Confirm the timeout settings.\nvar timeoutOptions = Assert.IsType<TimeoutStrategyOptions>(descriptor.Strategies[1].Options);\nAssert.Equal(TimeSpan.FromSeconds(1), timeoutOptions.Timeout);\n```\n\n----------------------------------------\n\nTITLE: Combining Fault Chaos with Retry Strategy in Polly\nDESCRIPTION: Shows how to integrate a fault chaos strategy with a retry strategy to create a resilient pipeline that can handle injected exceptions. The chaos strategy is placed last in the pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/fault.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<InvalidOperationException>(),\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,  // Adds a random factor to the delay\n        MaxRetryAttempts = 4,\n        Delay = TimeSpan.FromSeconds(3),\n    })\n    .AddChaosFault(new ChaosFaultStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline\n    {\n        FaultGenerator = static args => new ValueTask<Exception?>(new InvalidOperationException(\"Dummy exception\")),\n        InjectionRate = 0.1\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Configuring and Adding Latency Chaos Strategy in C#\nDESCRIPTION: Demonstrates various ways to configure and add the latency chaos strategy to a resilience pipeline. The examples show different configuration options including default options, basic options with fixed latency, custom latency generator, and handling notifications when latency is injected.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/latency.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Latency using the default options.\n// See https://www.pollydocs.org/chaos/latency#defaults for defaults.\nvar optionsDefault = new ChaosLatencyStrategyOptions();\n\n// 10% of invocations will be randomly affected\nvar basicOptions = new ChaosLatencyStrategyOptions\n{\n    Latency = TimeSpan.FromSeconds(30),\n    InjectionRate = 0.1\n};\n\n// To use a custom function to generate the latency to inject\nvar optionsWithLatencyGenerator = new ChaosLatencyStrategyOptions\n{\n    LatencyGenerator = static args =>\n    {\n        TimeSpan latency = args.Context.OperationKey switch\n        {\n            \"DataLayer\" => TimeSpan.FromMilliseconds(500),\n            \"ApplicationLayer\" => TimeSpan.FromSeconds(2),\n            // When the latency generator returns Zero, the strategy\n            // won't inject any delay and just invokes the user's callback.\n            _ => TimeSpan.Zero\n        };\n\n        return new ValueTask<TimeSpan>(latency);\n    },\n    InjectionRate = 0.1\n};\n\n// To get notifications when a delay is injected\nvar optionsOnLatencyInjected = new ChaosLatencyStrategyOptions\n{\n    Latency = TimeSpan.FromSeconds(30),\n    InjectionRate = 0.1,\n    OnLatencyInjected = static args =>\n    {\n        Console.WriteLine($\"OnLatencyInjected, Latency: {args.Latency}, Operation: {args.Context.OperationKey}.\");\n        return default;\n    }\n};\n\n// Add a latency strategy with a ChaosLatencyStrategyOptions instance to the pipeline\nnew ResiliencePipelineBuilder().AddChaosLatency(optionsDefault);\nnew ResiliencePipelineBuilder<HttpStatusCode>().AddChaosLatency(optionsWithLatencyGenerator);\n\n// There are also a handy overload to inject the chaos easily\nnew ResiliencePipelineBuilder().AddChaosLatency(0.1, TimeSpan.FromSeconds(30));\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Telemetry Event Example\nDESCRIPTION: Sample telemetry events showing circuit breaker state transitions including opened, half-opened, and closed states with stack traces and operation details.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_2\n\nLANGUAGE: none\nCODE:\n```\nResilience event occurred. EventName: 'OnCircuitOpened', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: 'Exception of type \\'CustomException\\' was thrown.'\n    CustomException: Exception of type 'CustomException' was thrown.\n        at Program.<>c.<<Main>b__0_1>d.MoveNext()\n        ...\n        at Polly.ResiliencePipeline.<>c__8`1.<<ExecuteAsync>b__8_0>d.MoveNext() in /_/src/Polly.Core/ResiliencePipeline.AsyncT.cs:line 95\n\nResilience event occurred. EventName: 'OnCircuitHalfOpened', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: ''\n\nResilience event occurred. EventName: 'OnCircuitClosed', Source: 'MyPipeline/MyPipelineInstance/MyCircuitBreakerStrategy', Operation Key: 'MyCircuitedOperation', Result: '42'\n```\n\n----------------------------------------\n\nTITLE: Pattern: Proper Exception Handling with ExecuteOutcomeAsync in C#\nDESCRIPTION: The recommended approach for handling exceptions by using ExecuteOutcomeAsync and then evaluating the Exception property, which maintains normal control flow.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar outcome = await WhateverPipeline.ExecuteOutcomeAsync(Action, context, \"state\");\nif (outcome.Exception is HttpRequestException requestException)\n{\n    throw new CustomNetworkException(\"Replace thrown exception\", requestException);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dynamic Hedging Mode in Polly\nDESCRIPTION: This code snippet demonstrates how to configure dynamic hedging behavior using DelayGenerator. It's configured to run the first two executions in parallel mode (TimeSpan.Zero) and then switch to fallback mode (negative TimeSpan) for additional executions.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddHedging(new()\n    {\n        MaxHedgedAttempts = 3,\n        DelayGenerator = args =>\n        {\n            var delay = args.AttemptNumber switch\n            {\n                0 or 1 => TimeSpan.Zero, // Parallel mode\n                _ => TimeSpan.FromSeconds(-1) // switch to Fallback mode\n            };\n\n            return new ValueTask<TimeSpan>(delay);\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Creating Chaos Extension Methods for Resilience Pipelines in C#\nDESCRIPTION: Defines a custom options class and extension method for adding chaos strategies to resilience pipelines. The implementation allows for configurable fault and latency injection with sensible defaults.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_7\n\nLANGUAGE: cs\nCODE:\n```\n// Options that represent the chaos pipeline\npublic sealed class MyChaosOptions\n{\n    public ChaosFaultStrategyOptions Fault { get; set; } = new()\n    {\n        FaultGenerator = new FaultGenerator()\n            .AddException<TimeoutException>()\n            .AddException<HttpRequestException>()\n    };\n\n    public ChaosLatencyStrategyOptions Latency { get; set; } = new()\n    {\n        Latency = TimeSpan.FromSeconds(60)\n    };\n}\n\n// Extension for easy integration of the chaos pipeline\npublic static void AddMyChaos(this ResiliencePipelineBuilder builder, Action<MyChaosOptions>? configure = null)\n{\n    var options = new MyChaosOptions();\n    configure?.Invoke(options);\n\n    builder\n        .AddChaosFault(options.Fault)\n        .AddChaosLatency(options.Latency);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Resilience Pipeline with Dependency Injection in C#\nDESCRIPTION: This snippet shows how to define a resilience pipeline using IServiceCollection, retrieve it using a ResiliencePipelineProvider or keyed services, and execute it. It demonstrates the integration of Polly with dependency injection in .NET.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/getting-started.md#2025-04-18_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Define a resilience pipeline with the name \"my-pipeline\"\nservices.AddResiliencePipeline(\"my-pipeline\", builder =>\n{\n    builder\n        .AddRetry(new RetryStrategyOptions())\n        .AddTimeout(TimeSpan.FromSeconds(10));\n});\n\n// Build the service provider\nvar serviceProvider = services.BuildServiceProvider();\n\n// Retrieve a ResiliencePipelineProvider that dynamically creates and caches the resilience pipelines\nvar pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<string>>();\n\n// Retrieve your resilience pipeline using the name it was registered with\nResiliencePipeline pipeline = pipelineProvider.GetPipeline(\"my-pipeline\");\n\n// Alternatively, you can use keyed services to retrieve the resilience pipeline\npipeline = serviceProvider.GetRequiredKeyedService<ResiliencePipeline>(\"my-pipeline\");\n\n// Execute the pipeline\nawait pipeline.ExecuteAsync(static async token =>\n{\n    // Your custom logic goes here\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing a Parameterized Action Generator for HTTP Requests\nDESCRIPTION: Example of a parameterized action generator that retrieves, modifies, and replaces HTTP request messages in the resilience context. This allows for creating different request variations in hedged actions.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddHedging(new()\n    {\n        ActionGenerator = args =>\n        {\n            if (!args.PrimaryContext.Properties.TryGetValue(ResilienceKeys.RequestMessage, out var request))\n            {\n                throw new InvalidOperationException(\"The request message must be provided.\");\n            }\n\n            // Prepare a new request message for the callback, potentially involving:\n            //\n            // - Cloning the request message\n            // - Providing alternate endpoint URLs\n            request = PrepareRequest(request);\n\n            // Override the request message in the action context\n            args.ActionContext.Properties.Set(ResilienceKeys.RequestMessage, request);\n\n            // Then, execute the original callback\n            return () => args.Callback(args.ActionContext);\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Executing Behavior Chaos Strategy with Retry in C#\nDESCRIPTION: Shows how to build a resilience pipeline that includes a retry strategy and a behavior chaos strategy. The chaos strategy is placed last in the pipeline to simulate Redis restarts.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/behavior.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<RedisConnectionException>(),\n        BackoffType = DelayBackoffType.Exponential,\n        UseJitter = true,  // Adds a random factor to the delay\n        MaxRetryAttempts = 4,\n        Delay = TimeSpan.FromSeconds(3),\n    })\n    .AddChaosBehavior(new ChaosBehaviorStrategyOptions // Chaos strategies are usually placed as the last ones in the pipeline\n    {\n        BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken),\n        InjectionRate = 0.05\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Defining Transient HTTP Error Handling Strategy in C#\nDESCRIPTION: This snippet defines a method to handle transient HTTP errors and creates a retry strategy with exponential backoff. It checks for specific HTTP status codes and HttpRequestException to determine if a retry should be attempted.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nprivate static ValueTask<bool> HandleTransientHttpError(Outcome<HttpResponseMessage> outcome) => outcome switch\n{\n    { Exception: HttpRequestException } => PredicateResult.True(),\n    { Result.StatusCode: HttpStatusCode.RequestTimeout } => PredicateResult.True(),\n    { Result.StatusCode: >= HttpStatusCode.InternalServerError } => PredicateResult.True(),\n    _ => PredicateResult.False()\n};\n\nprivate static RetryStrategyOptions<HttpResponseMessage> GetRetryOptions() =>\nnew()\n{\n    ShouldHandle = args => HandleTransientHttpError(args.Outcome),\n    MaxRetryAttempts = 3,\n    BackoffType = DelayBackoffType.Exponential,\n    Delay = TimeSpan.FromSeconds(2)\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hedging DelegatingHandler for HTTP Requests\nDESCRIPTION: A DelegatingHandler implementation that allows for hedging HTTP requests through a resilience pipeline. It stores and retrieves the request message from the context, enabling request substitution within the pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class HedgingHandler : DelegatingHandler\n{\n    private readonly ResiliencePipeline<HttpResponseMessage> _pipeline;\n\n    public HedgingHandler(ResiliencePipeline<HttpResponseMessage> pipeline)\n    {\n        _pipeline = pipeline;\n    }\n\n    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)\n    {\n        var context = ResilienceContextPool.Shared.Get(cancellationToken);\n\n        // Store the incoming request in the context\n        context.Properties.Set(ResilienceKeys.RequestMessage, request);\n\n        try\n        {\n            return await _pipeline.ExecuteAsync(async cxt =>\n            {\n                // Allow the pipeline to use request message that was stored in the context.\n                // This allows replacing the request message with a new one in the resilience pipeline.\n                request = cxt.Properties.GetValue(ResilienceKeys.RequestMessage, request);\n\n                return await base.SendAsync(request, cxt.CancellationToken);\n            },\n            context);\n        }\n        finally\n        {\n            ResilienceContextPool.Shared.Return(context);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Chaos Extensions in Multiple Resilience Pipelines in C#\nDESCRIPTION: Demonstrates how to use the custom chaos extension method in different resilience pipelines, including an example of overriding default settings for specific pipelines. Shows both basic usage and customized configuration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_8\n\nLANGUAGE: cs\nCODE:\n```\nservices.AddResiliencePipeline(\"my-pipeline-1\", (builder, context) =>\n{\n    builder\n        .AddRetry(new RetryStrategyOptions())\n        .AddTimeout(TimeSpan.FromSeconds(5))\n        .AddMyChaos(); // Use the extension\n});\n\nservices.AddResiliencePipeline(\"my-pipeline-2\", (builder, context) =>\n{\n    builder\n        .AddRetry(new RetryStrategyOptions())\n        .AddTimeout(TimeSpan.FromSeconds(5))\n        .AddMyChaos(options =>\n        {\n            options.Latency.InjectionRate = 0.1; // Override the default injection rate\n            options.Latency.Latency = TimeSpan.FromSeconds(10); // Override the default latency\n        });\n});\n```\n\n----------------------------------------\n\nTITLE: ResiliencePipeline Class Definition in C#\nDESCRIPTION: The abstract ResiliencePipeline class which forms the core of Polly V8 API. It provides various Execute and ExecuteAsync methods to handle synchronous and asynchronous operations with and without return values, unifying what was previously four different policy types in Polly V7.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/README.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic abstract class ResiliencePipeline\n{\n    public void Execute(Action callback);\n\n    public TResult Execute<TResult>(Func<TResult> callback);\n\n    public Task ExecuteAsync(\n        Func<CancellationToken, Task> callback,\n        CancellationToken cancellationToken = default);\n\n    public Task<TResult> ExecuteAsync(\n        Func<CancellationToken, Task<TResult>> callback,\n        CancellationToken cancellationToken = default);\n\n    public ValueTask ExecuteAsync(\n        Func<CancellationToken, ValueTask> callback,\n        CancellationToken cancellationToken = default);\n\n    public ValueTask<TResult> ExecuteAsync(\n        Func<CancellationToken, ValueTask<TResult>> callback,\n        CancellationToken cancellationToken = default);\n\n    // Other methods are omitted for simplicity\n}\n```\n\n----------------------------------------\n\nTITLE: Using ChaosOutcomeStrategy with OutcomeGenerator in C#\nDESCRIPTION: Example of using OutcomeGenerator<T> to register different types of results and exceptions to be injected with equal probability, and setting up notifications when a result is injected.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// To use OutcomeGenerator<T> to register the results and exceptions to be injected (equal probability)\nvar optionsWithResultGenerator = new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n{\n    OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>()\n        .AddResult(() => new HttpResponseMessage(HttpStatusCode.TooManyRequests))\n        .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError))\n        .AddException(() => new HttpRequestException(\"Chaos request exception.\")),\n    InjectionRate = 0.1\n};\n\n// To get notifications when a result is injected\nvar optionsOnBehaviorInjected = new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n{\n    OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>()\n        .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)),\n    InjectionRate = 0.1,\n    OnOutcomeInjected = static args =>\n    {\n        Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\");\n        return default;\n    }\n};\n\n// Add a result strategy with a ChaosOutcomeStrategyOptions{<TResult>} instance to the pipeline\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(optionsWithResultGenerator);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(optionsOnBehaviorInjected);\n\n// There are also a couple of handy overloads to inject the chaos easily\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosOutcome(0.1, () => new HttpResponseMessage(HttpStatusCode.TooManyRequests));\n```\n\n----------------------------------------\n\nTITLE: Configuring Timeout Strategy Options in Polly\nDESCRIPTION: Demonstrates different ways to configure a timeout resilience strategy including setting a fixed timeout duration, using a custom timeout generator function, and adding event handlers for timeout events.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// To add a timeout with a custom TimeSpan duration\nnew ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(3));\n\n// Timeout using the default options.\n// See https://www.pollydocs.org/strategies/timeout#defaults for defaults.\nvar optionsDefaults = new TimeoutStrategyOptions();\n\n// To add a timeout using a custom timeout generator function\nvar optionsTimeoutGenerator = new TimeoutStrategyOptions\n{\n    TimeoutGenerator = static args =>\n    {\n        // Note: the timeout generator supports asynchronous operations\n        return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123));\n    }\n};\n\n// To add a timeout and listen for timeout events\nvar optionsOnTimeout = new TimeoutStrategyOptions\n{\n    TimeoutGenerator = static args =>\n    {\n        // Note: the timeout generator supports asynchronous operations\n        return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123));\n    },\n    OnTimeout = static args =>\n    {\n        Console.WriteLine($\"{args.Context.OperationKey}: Execution timed out after {args.Timeout.TotalSeconds} seconds.\");\n        return default;\n    }\n};\n\n// Add a timeout strategy with a TimeoutStrategyOptions instance to the pipeline\nnew ResiliencePipelineBuilder().AddTimeout(optionsDefaults);\n```\n\n----------------------------------------\n\nTITLE: Using Delegates for Custom Fault Generation in Polly\nDESCRIPTION: Shows how to use custom delegates for more flexible fault generation logic. This approach allows for conditional exception creation based on random factors and supports asynchronous fault generation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/fault.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder()\n    .AddChaosFault(new ChaosFaultStrategyOptions\n    {\n        // The same behavior can be achieved with delegates\n        FaultGenerator = args =>\n        {\n            Exception? exception = Random.Shared.Next(350) switch\n            {\n                < 100 => new InvalidOperationException(),\n                < 200 => new TimeoutException(\"Chaos timeout injected.\"),\n                < 300 => CreateExceptionFromContext(args.Context),\n                < 350 => new TimeoutException(),\n                _ => null\n            };\n\n            return new ValueTask<Exception?>(exception);\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Policy Wrap Implementation in Polly v8\nDESCRIPTION: This snippet shows how policy wrapping is integrated directly into the ResiliencePipelineBuilder in Polly v8, allowing multiple strategies to be chained together naturally through builder methods.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// The \"PolicyWrap\" is integrated directly. The strategies are executed in the following order:\n// 1. Retry <== outer\n// 2. Timeout <== inner\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        MaxRetryAttempts = 3,\n        Delay = TimeSpan.FromSeconds(1),\n        BackoffType = DelayBackoffType.Constant,\n        ShouldHandle = new PredicateBuilder().Handle<Exception>()\n    })\n    .AddTimeout(TimeSpan.FromSeconds(3))\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Executing Callbacks Without Throwing Exceptions in Polly (C#)\nDESCRIPTION: Demonstrates how to use the ExecuteOutcomeAsync API to handle exceptions without throwing them, which can be beneficial for exception-heavy resilience strategies like circuit breakers.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/performance.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Execute GetMemberAsync and handle exceptions externally.\ntry\n{\n    await pipeline.ExecuteAsync(cancellationToken => GetMemberAsync(id, cancellationToken), cancellationToken);\n}\ncatch (Exception e)\n{\n    // Log the exception here.\n    logger.LogWarning(e, \"Failed to get member with id '{id}'.\", id);\n}\n\n// The example above can be restructured as:\n\n// Acquire a context from the pool\nResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);\n\n// Instead of wrapping pipeline execution with try-catch, use ExecuteOutcomeAsync(...).\n// Certain strategies are optimized for this method, returning an exception instance without actually throwing it.\nOutcome<Member> outcome = await pipeline.ExecuteOutcomeAsync(\n    static async (context, state) =>\n    {\n        // The callback for ExecuteOutcomeAsync must return an Outcome<T> instance. Hence, some wrapping is needed.\n        try\n        {\n            return Outcome.FromResult(await GetMemberAsync(state, context.CancellationToken));\n        }\n        catch (Exception e)\n        {\n            return Outcome.FromException<Member>(e);\n        }\n    },\n    context,\n    id);\n\n// Handle exceptions using the Outcome<T> instance instead of try-catch.\nif (outcome.Exception is not null)\n{\n    logger.LogWarning(outcome.Exception, \"Failed to get member with id '{id}'.\", id);\n}\n\n// Release the context back to the pool\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Configuring Partitioned Rate Limiters with Polly in C#\nDESCRIPTION: Shows how to create partitioned rate limiters that apply different limits to different contexts. The example extracts a partition key from the ResilienceContext and configures a ConcurrencyLimiter for each unique partition key.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_6\n\nLANGUAGE: cs\nCODE:\n```\nvar partitionedLimiter = PartitionedRateLimiter.Create<ResilienceContext, string>(context =>\n{\n    // Extract the partition key.\n    string partitionKey = GetPartitionKey(context);\n\n    return RateLimitPartition.GetConcurrencyLimiter(\n        partitionKey,\n        key => new ConcurrencyLimiterOptions\n        {\n            PermitLimit = 100\n        });\n});\n\nnew ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions\n    {\n        // Provide a custom rate limiter delegate.\n        RateLimiter = args =>\n        {\n            return partitionedLimiter.AcquireAsync(args.Context, 1, args.Context.CancellationToken);\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Retry-Timeout Pipeline Configuration in C#\nDESCRIPTION: Example of configuring a ResiliencePipeline with retry and timeout strategies, where retry is timeout-aware and handles TimeoutRejectedException.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new() { ShouldHandle = new PredicateBuilder().Handle<TimeoutRejectedException>() }) // outer\n    .AddTimeout(TimeSpan.FromSeconds(1)) // inner\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Using ResilienceContext with a Resilience Pipeline in C#\nDESCRIPTION: Demonstrates how to retrieve a ResilienceContext from a pool, attach custom data to it, use it with a resilience pipeline that includes a retry strategy, and then return it to the pool.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/resilience-context.md#2025-04-18_snippet_0\n\nLANGUAGE: cs\nCODE:\n```\n// Retrieve a context with a cancellation token\nResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);\n\n// Attach custom data to the context\ncontext.Properties.Set(MyResilienceKeys.Key1, \"my-data\");\ncontext.Properties.Set(MyResilienceKeys.Key2, 123);\n\n// Utilize the context in a resilience pipeline\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        OnRetry = static args =>\n        {\n            // Retrieve custom data from the context, if available\n            if (args.Context.Properties.TryGetValue(MyResilienceKeys.Key1, out var data))\n            {\n                Console.WriteLine(\"OnRetry, Custom Data: {0}\", data);\n            }\n\n            return default;\n        }\n    })\n    .Build();\n\n// Execute the resilience pipeline asynchronously\nawait pipeline.ExecuteAsync(\n    static async context =>\n    {\n        // Insert your execution logic here\n    },\n    context);\n\n// Return the context to the pool\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Example Implementation Using ResiliencePipelineProvider\nDESCRIPTION: Shows a code example of a service class that uses resilience pipelines and its registration with dependency injection.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/testing.md#2025-04-18_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\n// Represents an arbitrary API that needs resilience support\npublic class MyApi\n{\n    private readonly ResiliencePipeline _pipeline;\n\n    // The value of pipelineProvider is injected via dependency injection\n    public MyApi(ResiliencePipelineProvider<string> pipelineProvider)\n    {\n        _pipeline = pipelineProvider.GetPipeline(\"my-pipeline\");\n    }\n\n    public async Task ExecuteAsync(CancellationToken cancellationToken)\n    {\n        await _pipeline.ExecuteAsync(\n            static async token =>\n            {\n                // Add your code here\n            },\n            cancellationToken);\n    }\n}\n\n// Extensions to incorporate MyApi into dependency injection\npublic static class MyApiExtensions\n{\n    public static IServiceCollection AddMyApi(this IServiceCollection services)\n    {\n        return services\n            .AddResiliencePipeline(\"my-pipeline\", builder =>\n            {\n                builder.AddRetry(new RetryStrategyOptions\n                {\n                    MaxRetryAttempts = 4\n                });\n            })\n            .AddSingleton<MyApi>();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Telemetry Listeners and Enrichers\nDESCRIPTION: Implementation of custom telemetry listener and metering enricher classes for handling telemetry events and adding custom tags.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class MyTelemetryListener : TelemetryListener\n{\n    public override void Write<TResult, TArgs>(in TelemetryEventArguments<TResult, TArgs> args)\n    {\n        Console.WriteLine($\"Telemetry event occurred: {args.Event.EventName}\");\n    }\n}\n\ninternal sealed class MyMeteringEnricher : MeteringEnricher\n{\n    public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context)\n    {\n        context.Tags.Add(new(\"my-custom-tag\", \"custom-value\"));\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiting in Polly v8\nDESCRIPTION: Demonstrates how to configure rate limiting in Polly v8 using System.Threading.RateLimiting with SlidingWindowRateLimiter, which replaces the v7 rate limiting functionality.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// The equivalent to Polly v7's RateLimit is the SlidingWindowRateLimiter.\n//\n// Polly exposes just a simple wrapper to the APIs exposed by the System.Threading.RateLimiting APIs.\n// There is no need to create separate instances for sync and async flows as ResiliencePipeline handles both scenarios.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions\n    {\n        PermitLimit = 100,\n        SegmentsPerWindow = 4,\n        Window = TimeSpan.FromMinutes(1),\n    }))\n    .Build();\n\n// The creation of generic pipeline is almost identical.\n//\n// Polly exposes the same set of rate-limiter extensions for both ResiliencePipeline<HttpResponseMessage> and ResiliencePipeline.\nResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions\n    {\n        PermitLimit = 100,\n        SegmentsPerWindow = 4,\n        Window = TimeSpan.FromMinutes(1),\n    }))\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Implementing Reactive Result Reporting Strategy in Polly with C#\nDESCRIPTION: This snippet demonstrates how to add a reactive result reporting strategy to both generic and non-generic ResiliencePipelineBuilder. It shows how to define conditions for handling specific outcomes and implement reporting logic for HTTP responses.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\n// Add reactive strategy to the builder\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddResultReporting(new ResultReportingStrategyOptions<HttpResponseMessage>\n    {\n        // Define what outcomes to handle\n        ShouldHandle = args => args.Outcome switch\n        {\n            { Exception: { } } => PredicateResult.True(),\n            { Result.StatusCode: HttpStatusCode.InternalServerError } => PredicateResult.True(),\n            _ => PredicateResult.False()\n        },\n        OnReportResult = args =>\n        {\n            Console.WriteLine($\"Result: {args.Outcome}\");\n            return default;\n        }\n    });\n\n// You can also use the non-generic ResiliencePipelineBuilder to handle any kind of result.\nnew ResiliencePipelineBuilder()\n    .AddResultReporting(new ResultReportingStrategyOptions\n    {\n        // Define what outcomes to handle\n        ShouldHandle = args => args.Outcome switch\n        {\n            { Exception: { } } => PredicateResult.True(),\n            { Result: HttpResponseMessage message } when message.StatusCode == HttpStatusCode.InternalServerError => PredicateResult.True(),\n            _ => PredicateResult.False()\n        },\n        OnReportResult = args =>\n        {\n            Console.WriteLine($\"Result: {args.Outcome}\");\n            return default;\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Retry Configuration in Polly v7\nDESCRIPTION: This snippet demonstrates different ways to configure retry policies in Polly v7, including single retry, multiple retries, retries with callbacks, and infinite retries for handling various exception scenarios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Retry once\nPolicy\n    .Handle<SomeExceptionType>()\n    .Retry();\n\n// Retry multiple times\nPolicy\n    .Handle<SomeExceptionType>()\n    .Retry(3);\n\n// Retry multiple times with callback\nPolicy\n    .Handle<SomeExceptionType>()\n    .Retry(3, onRetry: (exception, retryCount) =>\n    {\n        // Add logic to be executed before each retry, such as logging\n    });\n\n// Retry forever\nPolicy\n    .Handle<SomeExceptionType>()\n    .RetryForever();\n```\n\n----------------------------------------\n\nTITLE: Visualizing Linear Backoff Strategy with Mermaid\nDESCRIPTION: A flowchart illustrating the decision process for the Linear backoff strategy in Polly's retry implementation. It demonstrates how delay is calculated linearly based on attempt number, with considerations for jitter and max delay.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram-v2\n\n    state if_state_step1 <<choice>>\n    state if_state_step2 <<choice>>\n    state if_state_step3 <<choice>>\n\n    linear: Delay * AttemptNumber\n    linearWJitter: (Delay * AttemptNumber) + Random\n    compare: MaxDelay < BaseDelay\n    setBase: Set BaseDelay\n    setNormalized: Set NormalizedDelay\n    setNext: Set NextDelay\n\n    UseJitter --> if_state_step1\n    if_state_step1 --> linearWJitter:true\n    if_state_step1 --> linear: false\n    linearWJitter --> setBase\n    linear --> setBase\n\n    setBase --> compare\n    compare --> if_state_step2\n    if_state_step2 --> MaxDelay: true\n    if_state_step2 --> BaseDelay: false\n    MaxDelay --> setNormalized\n    BaseDelay --> setNormalized\n\n    setNormalized --> DelayGenerator\n    DelayGenerator --> if_state_step3\n    if_state_step3 --> GeneratedDelay: positive\n    if_state_step3 --> NormalizedDelay: null or negative\n    GeneratedDelay --> setNext\n    NormalizedDelay --> setNext\n    setNext --> [*]\n```\n\n----------------------------------------\n\nTITLE: Timeout Strategy Implementation in C#\nDESCRIPTION: Class definitions and properties for implementing timeout behavior in Polly resilience pipelines. Includes timeout options configuration and exception handling.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Timeout.TimeoutRejectedException.TimeoutRejectedException(System.TimeSpan timeout) -> void\nPolly.Timeout.TimeoutStrategyOptions\nPolly.Timeout.TimeoutStrategyOptions.OnTimeout.get -> System.Func<Polly.Timeout.OnTimeoutArguments, System.Threading.Tasks.ValueTask>?\nPolly.Timeout.TimeoutStrategyOptions.OnTimeout.set -> void\nPolly.Timeout.TimeoutStrategyOptions.Timeout.get -> System.TimeSpan\nPolly.Timeout.TimeoutStrategyOptions.Timeout.set -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing TimingResilienceStrategy in C#\nDESCRIPTION: This code snippet defines the TimingResilienceStrategy class, which tracks execution times of callbacks and reports when they exceed a specified threshold. It inherits from ResilienceStrategy and implements the core execution logic.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/proactive-strategy.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class TimingResilienceStrategy : ResilienceStrategy\n{\n    private readonly TimeSpan _threshold;\n    private readonly Func<OnThresholdExceededArguments, ValueTask>? _onThresholdExceeded;\n    private readonly ResilienceStrategyTelemetry _telemetry;\n\n    public TimingResilienceStrategy(\n        TimeSpan threshold,\n        Func<OnThresholdExceededArguments, ValueTask>? onThresholdExceeded,\n        ResilienceStrategyTelemetry telemetry)\n    {\n        _threshold = threshold;\n        _telemetry = telemetry;\n        _onThresholdExceeded = onThresholdExceeded;\n    }\n\n    protected override async ValueTask<Outcome<TResult>> ExecuteCore<TResult, TState>(\n        Func<ResilienceContext, TState, ValueTask<Outcome<TResult>>> callback,\n        ResilienceContext context,\n        TState state)\n    {\n        var stopwatch = Stopwatch.StartNew();\n\n        // Execute the given callback and adhere to the ContinueOnCapturedContext property value.\n        Outcome<TResult> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext);\n\n        if (stopwatch.Elapsed > _threshold)\n        {\n            // Bundle information about the event into arguments.\n            var args = new OnThresholdExceededArguments(context, _threshold, stopwatch.Elapsed);\n\n            // Report this as a resilience event if the execution took longer than the threshold.\n            _telemetry.Report(\n                new ResilienceEvent(ResilienceEventSeverity.Warning, \"ExecutionThresholdExceeded\"),\n                context,\n                args);\n\n            if (_onThresholdExceeded is not null)\n            {\n                await _onThresholdExceeded(args).ConfigureAwait(context.ContinueOnCapturedContext);\n            }\n        }\n\n        // Return the outcome directly.\n        return outcome;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Timeouts with Try-Catch in Polly\nDESCRIPTION: Shows how to handle timeout exceptions with a traditional try-catch block instead of using the OnTimeout callback, catching the TimeoutRejectedException explicitly.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar withoutOnTimeout = new ResiliencePipelineBuilder()\n    .AddTimeout(new TimeoutStrategyOptions\n    {\n        Timeout = TimeSpan.FromSeconds(2)\n    }).Build();\n\ntry\n{\n    await withoutOnTimeout.ExecuteAsync(UserDelegate, CancellationToken.None);\n}\ncatch (TimeoutRejectedException)\n{\n    Console.WriteLine(\"Timeout limit has been exceeded\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiter Disposal in C# with Polly\nDESCRIPTION: Demonstrates how to properly dispose of rate limiters when using dynamic reloads. This pattern registers a cleanup callback using the OnPipelineDisposed method to ensure resources are properly released when the pipeline is discarded or updated.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_5\n\nLANGUAGE: cs\nCODE:\n```\nservices\n    .AddResiliencePipeline(\"my-pipeline\", (builder, context) =>\n    {\n        var options = context.GetOptions<ConcurrencyLimiterOptions>(\"my-concurrency-options\");\n\n        // This call enables dynamic reloading of the pipeline\n        // when the named ConcurrencyLimiterOptions change.\n        context.EnableReloads<ConcurrencyLimiterOptions>(\"my-concurrency-options\");\n\n        var limiter = new ConcurrencyLimiter(options);\n\n        builder.AddRateLimiter(limiter);\n\n        // Dispose of the limiter when the pipeline is disposed.\n        context.OnPipelineDisposed(() => limiter.Dispose());\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Wait and Retry in Polly v7\nDESCRIPTION: Shows how to configure wait and retry patterns in Polly v7, including multiple retries with fixed wait time, retries with callbacks, and infinite retry scenarios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n// Wait and retry multiple times\nPolicy\n    .Handle<SomeExceptionType>()\n    .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1));\n\n// Wait and retry multiple times with callback\nPolicy\n    .Handle<SomeExceptionType>()\n    .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1), onRetry: (exception, retryCount) =>\n    {\n        // Add logic to be executed before each retry, such as logging\n    });\n\n// Wait and retry forever\nPolicy\n    .Handle<SomeExceptionType>()\n    .WaitAndRetryForever(_ => TimeSpan.FromSeconds(1));\n```\n\n----------------------------------------\n\nTITLE: Complex Circuit Breaker Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing circuit breaker transitions through multiple states including half-open and successful recovery.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant CB as CircuitBreaker\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Closed state\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    Note over CB: Moves to Open state\n    Note over CB: Break duration start\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB-->>CB: Rejects request\n    CB->>P: Throws <br/>BrokenCircuitException\n    P->>C: Propagates exception\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Break duration end\n    Note over CB: Moves to HalfOpen state\n    CB->>+D: Invokes\n    D->>-CB: Returns result\n    Note over CB: Moves to Closed state\n    CB->>P: Returns result\n    P->>C: Returns result\n```\n\n----------------------------------------\n\nTITLE: Presenting Benchmark Results in Markdown Table Format\nDESCRIPTION: This code snippet displays the benchmark results in a markdown table format. It shows the performance metrics for the 'Execute' method with different combinations of telemetry and enrichment settings, including mean execution time, error margin, standard deviation, and memory allocation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.TelemetryBenchmark-report-github.md#2025-04-18_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Method  | Telemetry | Enrichment | Mean      | Error    | StdDev   | Allocated |\n|-------- |---------- |----------- |----------:|---------:|---------:|----------:|\n| **Execute** | **False**     | **False**      |  **60.58 ns** | **0.178 ns** | **0.256 ns** |         **-** |\n| **Execute** | **False**     | **True**       |  **62.53 ns** | **1.442 ns** | **2.159 ns** |         **-** |\n| **Execute** | **True**      | **False**      | **443.92 ns** | **1.736 ns** | **2.434 ns** |         **-** |\n| **Execute** | **True**      | **True**       | **612.90 ns** | **2.974 ns** | **4.359 ns** |         **-** |\n```\n\n----------------------------------------\n\nTITLE: Implementing Concurrency Limiter in Polly v8\nDESCRIPTION: Demonstrates how to create ResiliencePipeline objects with concurrency limiters in Polly v8, replacing the v7 Bulkhead pattern. Requires the Polly.RateLimiting package to use AddConcurrencyLimiter extension.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n// Create pipeline with concurrency limiter. Because ResiliencePipeline supports both sync and async\n// callbacks, there is no need to define it twice.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50)\n    .Build();\n\n// Create a generic pipeline with concurrency limiter. Because ResiliencePipeline<T> supports both sync and async\n// callbacks, there is no need to define it twice.\nResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddConcurrencyLimiter(permitLimit: 100, queueLimit: 50)\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom Action Generator in Hedging Strategy\nDESCRIPTION: Example of implementing a custom ActionGenerator for a hedging resilience pipeline. The generator creates specialized actions for each hedging attempt, with access to both primary and action contexts.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddHedging(new()\n    {\n        ActionGenerator = args =>\n        {\n            // You can access data from the original (primary) context here\n            var customData = args.PrimaryContext.Properties.GetValue(customDataKey, \"default-custom-data\");\n\n            Console.WriteLine($\"Hedging, Attempt: {args.AttemptNumber}, Custom Data: {customData}\");\n\n            // Here, we can access the original callback and return it or return a completely new action\n            var callback = args.Callback;\n\n            // A function that returns a ValueTask<Outcome<HttpResponseMessage>> is required.\n            return async () =>\n            {\n                try\n                {\n                    // A dedicated ActionContext is provided for each hedged action.\n                    // It comes with a separate CancellationToken created specifically for this hedged attempt,\n                    // which can be cancelled later if needed.\n                    //\n                    // Note that the \"MyRemoteCallAsync\" call won't have any additional resilience applied.\n                    // You are responsible for wrapping it with any additional resilience pipeline.\n                    var response = await MyRemoteCallAsync(args.ActionContext.CancellationToken);\n\n                    return Outcome.FromResult(response);\n                }\n                catch (Exception e)\n                {\n                    // Note: All exceptions should be caught and converted to Outcome.\n                    return Outcome.FromException<HttpResponseMessage>(e);\n                }\n            };\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring Resilience Pipeline with Dependency Injection\nDESCRIPTION: Example of configuring a resilience pipeline with telemetry using dependency injection and service collection.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar serviceCollection = new ServiceCollection()\n    .AddLogging(builder => builder.AddConsole())\n    .AddResiliencePipeline(\"my-strategy\", builder => builder.AddTimeout(TimeSpan.FromSeconds(1)))\n    .Configure<TelemetryOptions>(options =>\n    {\n        // Configure enrichers\n        options.MeteringEnrichers.Add(new MyMeteringEnricher());\n\n        // Configure telemetry listeners\n        options.TelemetryListeners.Add(new MyTelemetryListener());\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Wait and Retry in Polly v8\nDESCRIPTION: Demonstrates wait and retry patterns in Polly v8 using RetryStrategyOptions with constant backoff, including multiple retries, retries with callbacks, and infinite retry scenarios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// Wait and retry multiple times\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = 3,\n    Delay = TimeSpan.FromSeconds(1),\n    BackoffType = DelayBackoffType.Constant\n})\n.Build();\n\n// Wait and retry multiple times with callback\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = 3,\n    Delay = TimeSpan.FromSeconds(1),\n    BackoffType = DelayBackoffType.Constant,\n    OnRetry = static args =>\n    {\n        // Add logic to be executed before each retry, such as logging\n        return default;\n    }\n})\n.Build();\n\n// Wait and retry forever\nnew ResiliencePipelineBuilder().AddRetry(new RetryStrategyOptions\n{\n    ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n    MaxRetryAttempts = int.MaxValue,\n    Delay = TimeSpan.FromSeconds(1),\n    BackoffType = DelayBackoffType.Constant\n})\n.Build();\n```\n\n----------------------------------------\n\nTITLE: Dependency Injection Configuration for ResiliencePipeline in C#\nDESCRIPTION: Shows how to configure ResiliencePipeline instances using dependency injection in .NET Core applications, including pipeline registration and retrieval.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/index.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void ConfigureMyPipelines(IServiceCollection services)\n{\n    services.AddResiliencePipeline(\"pipeline-A\", builder => builder.AddConcurrencyLimiter(100));\n    services.AddResiliencePipeline(\"pipeline-B\", builder => builder.AddRetry(new()));\n\n    // Later, resolve the pipeline by name using ResiliencePipelineProvider<string> or ResiliencePipelineRegistry<string>\n    var pipelineProvider = services.BuildServiceProvider().GetRequiredService<ResiliencePipelineProvider<string>>();\n    pipelineProvider.GetPipeline(\"pipeline-A\").Execute(() => { });\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Comparing Polly v7 and v8 Timeout Execution\nDESCRIPTION: Performance benchmark results comparing ExecuteTimeout operations between Polly v7 and v8. The benchmark was run on a 12th Gen Intel Core i7-1280P with .NET 9.0.0. Results show v8 is approximately 7% faster with no memory allocation compared to v7.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.TimeoutBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method            | Mean     | Error   | StdDev  | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|------------------ |---------:|--------:|--------:|------:|--------:|-------:|----------:|------------:|\n| ExecuteTimeout_V7 | 259.3 ns | 4.25 ns | 6.24 ns |  1.00 |    0.03 | 0.0577 |     728 B |        1.00 |\n| ExecuteTimeout_V8 | 241.1 ns | 1.48 ns | 2.17 ns |  0.93 |    0.02 |      - |         - |        0.00 |\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout Strategy in Polly v7\nDESCRIPTION: Shows how to create both synchronous and asynchronous timeout policies in Polly v7, including generic and non-generic variants.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\n// Create sync timeout\nISyncPolicy syncPolicy = Policy.Timeout(TimeSpan.FromSeconds(10));\n\n// Create async timeout\nIAsyncPolicy asyncPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(10));\n\n// Create generic sync timeout\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Timeout<HttpResponseMessage>(TimeSpan.FromSeconds(10));\n\n// Create generic async timeout\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.TimeoutAsync<HttpResponseMessage>(TimeSpan.FromSeconds(10));\n```\n\n----------------------------------------\n\nTITLE: Using ResilienceContextPool in C#\nDESCRIPTION: Demonstrates various ways to retrieve ResilienceContext instances from the pool with different initialization parameters, and the proper pattern for returning contexts to the pool after use.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/resilience-context.md#2025-04-18_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// Retrieve a context with a cancellation token\nResilienceContext context = ResilienceContextPool.Shared.Get(cancellationToken);\n\ntry\n{\n    // Retrieve a context with a specific operation key\n    context = ResilienceContextPool.Shared.Get(\"my-operation-key\", cancellationToken);\n\n    // Retrieve a context with multiple properties\n    context = ResilienceContextPool.Shared.Get(\n        operationKey: \"my-operation-key\",\n        continueOnCapturedContext: true,\n        cancellationToken: cancellationToken);\n\n    // Use the pool here\n}\nfinally\n{\n    // Returning the context back to the pool is recommended, but not required as it reduces the allocations.\n    // It is also OK to not return the context in case of exceptions, if you want to avoid try-catch blocks.\n    ResilienceContextPool.Shared.Return(context);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Reloads for Resilience Pipelines in C#\nDESCRIPTION: Shows how to enable dynamic reloading of cached pipelines using a CancellationToken as a reload trigger.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar registry = new ResiliencePipelineRegistry<string>();\n\nregistry.TryAddBuilder(\"A\", (builder, context) =>\n{\n    // Add the reload token. Tokens that are already canceled are ignored.\n    context.AddReloadToken(cancellationToken);\n\n    // Define the pipeline.\n    builder.AddRetry(new RetryStrategyOptions());\n});\n\n// This instance remains valid even after a reload.\nResiliencePipeline pipeline = registry.GetPipeline(\"A\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Bulkhead Pattern in Polly v7\nDESCRIPTION: Shows how to configure the bulkhead pattern in Polly v7, which limits concurrent executions, for both synchronous and asynchronous variants in generic and non-generic forms.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n// Create sync bulkhead\nISyncPolicy syncPolicy = Policy.Bulkhead(\n    maxParallelization: 100,\n    maxQueuingActions: 50);\n\n// Create async bulkhead\nIAsyncPolicy asyncPolicy = Policy.BulkheadAsync(\n    maxParallelization: 100,\n    maxQueuingActions: 50);\n\n// Create generic sync bulkhead\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.Bulkhead<HttpResponseMessage>(\n    maxParallelization: 100,\n    maxQueuingActions: 50);\n\n// Create generic async bulkhead\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.BulkheadAsync<HttpResponseMessage>(\n    maxParallelization: 100,\n    maxQueuingActions: 50);\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultReportingResilienceStrategy in C#\nDESCRIPTION: This code snippet defines the core ResultReportingResilienceStrategy class, which inherits from ResilienceStrategy<T>. It implements the logic for executing a callback, checking if the outcome should be reported, and calling the reporting function if necessary.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class ResultReportingResilienceStrategy<T> : ResilienceStrategy<T>\n{\n    private readonly Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> _shouldHandle;\n    private readonly Func<OnReportResultArguments<T>, ValueTask> _onReportResult;\n    private readonly ResilienceStrategyTelemetry _telemetry;\n\n    public ResultReportingResilienceStrategy(\n        Func<ResultReportingPredicateArguments<T>, ValueTask<bool>> shouldHandle,\n        Func<OnReportResultArguments<T>, ValueTask> onReportResult,\n        ResilienceStrategyTelemetry telemetry)\n    {\n        _shouldHandle = shouldHandle;\n        _onReportResult = onReportResult;\n        _telemetry = telemetry;\n    }\n\n    protected override async ValueTask<Outcome<T>> ExecuteCore<TState>(\n        Func<ResilienceContext, TState, ValueTask<Outcome<T>>> callback,\n        ResilienceContext context,\n        TState state)\n    {\n        // Execute the given callback and adhere to the ContinueOnCapturedContext property value.\n        Outcome<T> outcome = await callback(context, state).ConfigureAwait(context.ContinueOnCapturedContext);\n\n        // Check if the outcome should be reported using the \"ShouldHandle\" predicate.\n        if (await _shouldHandle(new ResultReportingPredicateArguments<T>(context, outcome)).ConfigureAwait(context.ContinueOnCapturedContext))\n        {\n            // Bundle information about the event into arguments.\n            var args = new OnReportResultArguments<T>(context, outcome);\n\n            // Report this as a resilience event with information severity level to the telemetry infrastructure.\n            _telemetry.Report(\n                new ResilienceEvent(ResilienceEventSeverity.Information, \"ResultReported\"),\n                context,\n                outcome,\n                args);\n\n            // Call the \"OnReportResult\" callback.\n            await _onReportResult(args).ConfigureAwait(context.ContinueOnCapturedContext);\n        }\n\n        return outcome;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Simple Happy Path Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing successful circuit breaker operation with failure ratio below threshold.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant CB as CircuitBreaker\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Closed state\n    Note over CB, D: Sampling start\n    activate CB\n    CB->>+D: Invokes\n    D->>-CB: Returns result\n    CB->>P: Returns result\n    P->>C: Returns result\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB->>+D: Invokes\n    D->>-CB: Returns result\n    CB->>P: Returns result\n    P->>C: Returns result\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    deactivate CB\n    Note over CB, D: Sampling end\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n```\n\n----------------------------------------\n\nTITLE: Defining Keyed Services for Resilience Pipelines\nDESCRIPTION: Shows how to define both regular and generic resilience pipelines that can be later resolved using .NET 8's keyed services feature.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n// Define a resilience pipeline\nservices.AddResiliencePipeline<string, HttpResponseMessage>(\"my-pipeline\", builder =>\n{\n    // Configure the pipeline\n});\n\n// Define a generic resilience pipeline\nservices.AddResiliencePipeline(\"my-pipeline\", builder =>\n{\n    // Configure the pipeline\n});\n```\n\n----------------------------------------\n\nTITLE: Best Practice: Using Latency Chaos Strategy for Delay Injection in C#\nDESCRIPTION: Shows the correct way to inject delays using the ChaosLatencyStrategy, which properly handles synchronous/asynchronous delay executions and cancellations.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/behavior.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddChaosLatency(new ChaosLatencyStrategyOptions\n    {\n        Latency = TimeSpan.FromSeconds(7),\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Visualizing Concurrency Limiter Unhappy Path Flow with Mermaid\nDESCRIPTION: A sequence diagram illustrating how the concurrency limiter handles multiple concurrent requests when limits are exceeded. It shows the interaction between callers, the pipeline, the concurrency limiter, and callbacks, including request queuing and rejection patterns.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor C1 as Caller1\n    actor C2 as Caller2\n    actor C3 as Caller3\n    participant P as Pipeline\n    participant CL as ConcurrencyLimiter\n    participant D as DecoratedUserCallback\n\n    par\n    C1->>P: Calls ExecuteAsync\n    and\n    C2->>P: Calls ExecuteAsync\n    and\n    C3->>P: Calls ExecuteAsync\n    end\n\n    P->>CL: Calls ExecuteCore\n    CL->>+D: Invokes (C1)\n    P->>CL: Calls ExecuteCore\n    CL-->>CL: Queues request (C2)\n    P->>CL: Calls ExecuteCore\n    CL-->>CL: Rejects request (C3)\n    CL->>P: Throws <br/>RateLimiterRejectedException\n    P->>C3: Propagates exception\n\n    D->>-CL: Returns result (C1)\n    CL->>P: Returns result (C1)\n    CL->>+D: Invokes (C2)\n    P->>C1: Returns result\n    D->>-CL: Returns result (C2)\n    CL->>P: Returns result (C2)\n    P->>C2: Returns result\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Circuit Breaker in Polly v7\nDESCRIPTION: Demonstrates how to create advanced circuit breaker policies in Polly v7 with percentage-based failure thresholds, sampling, and manual state control.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\n// Create sync advanced circuit breaker\nISyncPolicy syncPolicy = Policy\n    .Handle<SomeExceptionType>()\n    .AdvancedCircuitBreaker(\n        failureThreshold: 0.5d,\n        samplingDuration: TimeSpan.FromSeconds(5),\n        minimumThroughput: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create async advanced circuit breaker\nIAsyncPolicy asyncPolicy = Policy\n    .Handle<SomeExceptionType>()\n    .AdvancedCircuitBreakerAsync(\n        failureThreshold: 0.5d,\n        samplingDuration: TimeSpan.FromSeconds(5),\n        minimumThroughput: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create generic sync advanced circuit breaker\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage>\n    .Handle<SomeExceptionType>()\n    .AdvancedCircuitBreaker(\n        failureThreshold: 0.5d,\n        samplingDuration: TimeSpan.FromSeconds(5),\n        minimumThroughput: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create generic async advanced circuit breaker\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage>\n    .Handle<SomeExceptionType>()\n    .AdvancedCircuitBreakerAsync(\n        failureThreshold: 0.5d,\n        samplingDuration: TimeSpan.FromSeconds(5),\n        minimumThroughput: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Check circuit state\nICircuitBreakerPolicy cbPolicy = (ICircuitBreakerPolicy)asyncPolicy;\nbool isOpen = cbPolicy.CircuitState == CircuitState.Open || cbPolicy.CircuitState == CircuitState.Isolated;\n\n// Manually control state\ncbPolicy.Isolate(); // Transitions into the Isolated state\ncbPolicy.Reset(); // Transitions into the Closed state\n```\n\n----------------------------------------\n\nTITLE: Using Keyed Services to Resolve Resilience Pipelines\nDESCRIPTION: Demonstrates how to inject resilience pipelines into a class using the .NET 8 keyed services feature with the FromKeyedServices attribute.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class MyApi\n{\n    private readonly ResiliencePipeline _pipeline;\n    private readonly ResiliencePipeline<HttpResponseMessage> _genericPipeline;\n\n    public MyApi(\n        [FromKeyedServices(\"my-pipeline\")]\n        ResiliencePipeline pipeline,\n        [FromKeyedServices(\"my-pipeline\")]\n        ResiliencePipeline<HttpResponseMessage> genericPipeline)\n    {\n        // Although the pipelines are registered with the same key, they are distinct instances.\n        // One is generic, the other is not.\n        _pipeline = pipeline;\n        _genericPipeline = genericPipeline;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Throwing Exception from OnFallback Delegate in C#\nDESCRIPTION: An example of incorrectly throwing custom exceptions from the OnFallback delegate, which can disrupt the normal control flow of the resilience pipeline.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar fallback = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddFallback(new()\n    {\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<HttpRequestException>(),\n        FallbackAction = args => Outcome.FromResultAsValueTask(new HttpResponseMessage()),\n        OnFallback = args => throw new CustomNetworkException(\"Replace thrown exception\", args.Outcome.Exception!)\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Using Custom Delegates for Advanced Outcome Generation\nDESCRIPTION: Shows how to use custom delegates for more flexible outcome generation with Polly's chaos strategy, including random selection between different types of outcomes and support for asynchronous generation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n    {\n        // The same behavior can be achieved with delegates\n        OutcomeGenerator = static args =>\n        {\n            Outcome<HttpResponseMessage>? outcome = Random.Shared.Next(350) switch\n            {\n                < 100 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)),\n                < 150 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)),\n                < 250 => Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))),\n                < 350 => Outcome.FromException<HttpResponseMessage>(new TimeoutException()),\n                _ => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK))\n            };\n\n            return ValueTask.FromResult(outcome);\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Visualizing Exponential Backoff Strategy with Mermaid\nDESCRIPTION: A flowchart illustrating the decision process for the Exponential backoff strategy in Polly's retry implementation. It shows how delay is calculated exponentially, with special handling for jitter using the Decorrelated Jitter Backoff V2 algorithm.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram-v2\n\n    state if_state_step1 <<choice>>\n    state if_state_step2 <<choice>>\n    state if_state_step3 <<choice>>\n\n    exponential: Delay * 2^AttemptNumber\n    exponentialWJitter: Decorrelated Jitter Backoff V2\n    compare: MaxDelay < BaseDelay\n    setBase: Set BaseDelay\n    setNormalized: Set NormalizedDelay\n    setNext: Set NextDelay\n\n    UseJitter --> if_state_step1\n    if_state_step1 --> exponentialWJitter:true\n    if_state_step1 --> exponential: false\n    exponentialWJitter --> setBase\n    exponential --> setBase\n\n    setBase --> compare\n    compare --> if_state_step2\n    if_state_step2 --> MaxDelay: true\n    if_state_step2 --> BaseDelay: false\n    MaxDelay --> setNormalized\n    BaseDelay --> setNormalized\n\n    setNormalized --> DelayGenerator\n    DelayGenerator --> if_state_step3\n    if_state_step3 --> GeneratedDelay: positive\n    if_state_step3 --> NormalizedDelay: null or negative\n    GeneratedDelay --> setNext\n    NormalizedDelay --> setNext\n    setNext --> [*]\n```\n\n----------------------------------------\n\nTITLE: Resilience Pipeline Execution Flow with Chaos Strategies\nDESCRIPTION: Mermaid sequence diagram visualizing the flow of execution through a resilience pipeline with chaos strategies. Shows how fault, latency, outcome, and behavior injection strategies are applied with their respective probabilities and how they affect the execution flow.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor C as Caller\n    participant P as Pipeline\n    participant F as Fault\n    participant L as Latency\n    participant O as Outcome\n    participant B as Behavior\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n\n    P->>F: Calls ExecuteCore\n\n    %% Fault Chaos\n    activate F\n    F-->>F: Determines Injection\n    deactivate F\n\n    alt 2% chance <br/>to inject: 🙈\n        F->>P: Throws injected Fault\n        P->>C: Propagates Exception\n    else 98% chance <br/>to continue: 🐵\n        F->>L: Calls ExecuteCore\n    end\n\n    %% Delay Chaos\n    activate L\n    L-->>L: Determines Injection\n    deactivate L\n\n    alt 50% chance <br/>to inject: 🙈\n        L->>L: Injects delay\n        L->>O: Calls ExecuteCore\n    else 50% chance <br/>to continue: 🐵\n        L->>O: Calls ExecuteCore\n    end\n\n    %% Outcome Chaos\n    activate O \n    O-->>O: Determines Injection\n    deactivate  O\n\n    alt 10% chance <br/>to inject: 🙈\n        O->>O: Injects outcome\n        O->>L: Returns result\n        L->>F: Returns result\n        F->>P: Returns result\n        P->>C: Returns result\n    else 90% chance <br/>to continue: 🐵\n        O->>B: Calls ExecuteCore\n    end\n\n    %% Behavior Chaos\n    activate B\n    B-->>B: Determines Injection\n    deactivate B\n\n    alt 1% chance <br/>to inject: 🙈\n        B->>B: Injects behavior\n        B->>D: Invokes\n    else 99% chance <br/>to continue: 🐵\n        B->>D: Invokes\n    end\n\n    D->>B: Returns result\n    B->>O: Returns result\n    O->>L: Returns result\n    L->>F: Returns result\n    F->>P: Returns result\n    P->>C: Returns result\n```\n\n----------------------------------------\n\nTITLE: Integrating Polly with Flurl in C#\nDESCRIPTION: This snippet shows how to use Polly with Flurl, a URL builder and HTTP client library. It registers a named HttpClient with a resilience pipeline and creates a FlurlClient that uses this decorated HttpClient for making HTTP requests.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Register a named HttpClient and decorate with a resilience pipeline\nservices.AddHttpClient(HttpClientName)\n        .ConfigureHttpClient(client => client.BaseAddress = BaseAddress)\n        .AddResilienceHandler(\"flurl_based_pipeline\",\n            builder => builder.AddRetry(GetRetryOptions()));\n\nusing var provider = services.BuildServiceProvider();\n\n// Resolve the named HttpClient and create a new FlurlClient\nvar httpClientFactory = provider.GetRequiredService<IHttpClientFactory>();\nvar flurlClient = new FlurlClient(httpClientFactory.CreateClient(HttpClientName));\n\n// Use the FlurlClient by making a request\nvar response = await flurlClient.Request(\"/408\").GetAsync();\n```\n\n----------------------------------------\n\nTITLE: Using PredicateBuilder for Simplified Fault Handling\nDESCRIPTION: Shows how to use PredicateBuilder to simplify predicate configuration for handling HTTP responses and exceptions.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/index.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new RetryStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n        .HandleResult(response => !response.IsSuccessStatusCode) // Handle results\n        .Handle<HttpRequestException>() // Or handle exception\n        .Handle<TimeoutRejectedException>() // Chaining is supported\n};\n```\n\n----------------------------------------\n\nTITLE: Incorrect Circuit Breaker Usage in C#\nDESCRIPTION: This snippet demonstrates an anti-pattern for using a Circuit Breaker. It attempts to reduce thrown exceptions by checking the circuit state before execution, but this prevents the circuit from transitioning to a HalfOpen state.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar stateProvider = new CircuitBreakerStateProvider();\nvar circuitBreaker = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new()\n    {\n        ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(),\n        BreakDuration = TimeSpan.FromSeconds(0.5),\n        StateProvider = stateProvider\n    })\n    .Build();\n\nif (stateProvider.CircuitState\n    is not CircuitState.Open\n    and not CircuitState.Isolated)\n{\n    var response = await circuitBreaker.ExecuteAsync(static async ct =>\n    {\n        return await IssueRequest();\n    }, CancellationToken.None);\n\n    // Your code goes here to process response\n}\n```\n\n----------------------------------------\n\nTITLE: Action Generator Sequence Diagram\nDESCRIPTION: A sequence diagram showing the interaction flow between the caller, pipeline, hedging strategy, action generator, and callbacks. It demonstrates how multiple hedged attempts are executed until a successful result is achieved.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant H as Hedging\n    participant AG as ActionGenerator\n    participant UC as UserCallback\n    participant HUC as HedgedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>H: Calls ExecuteCore\n\n    activate H\n    H->>+UC: Invokes (R1)\n    UC-->>UC: Processes R1\n    UC->>-H: Fails (R1)\n    H->>+AG: Invokes\n    AG->>-H: Returns factory\n    H-->>H: Invokes factory\n\n    H->>+HUC: Invokes (R2)\n    HUC-->>HUC: Processes R2\n    HUC->>-H: Fails (R2)\n\n    H-->>H: Invokes factory\n    H->>+HUC: Invokes (R3)\n    HUC-->>HUC: Processes R3\n    HUC->>-H: Returns result (R3)\n    deactivate H\n\n    H->>P: Returns result (R3)\n    P->>C: Returns result (R3)\n```\n\n----------------------------------------\n\nTITLE: Implementing Deferred Pipeline Addition with Configuration\nDESCRIPTION: Shows how to defer the creation of resilience pipelines until the provider is instantiated, allowing access to configuration and other services.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nservices\n    .AddResiliencePipelines<string>((ctx) =>\n    {\n        var config = ctx.ServiceProvider.GetRequiredService<IConfiguration>();\n\n        var configSection = config.GetSection(\"ResiliencePipelines\");\n        if (configSection is not null)\n        {\n            foreach (var pipelineConfig in configSection.GetChildren())\n            {\n                var pipelineName = pipelineConfig.GetValue<string>(\"Name\");\n                if (!string.IsNullOrEmpty(pipelineName))\n                {\n                    ctx.AddResiliencePipeline(pipelineName, (builder, context) =>\n                    {\n                        // Load configuration and configure pipeline...\n                    });\n                }\n            }\n        }\n    });\n```\n\n----------------------------------------\n\nTITLE: Pattern: Proper Fallback Implementation in C#\nDESCRIPTION: The recommended approach for implementing fallback functionality using the dedicated fallback strategy, which executes the target code only once and returns the fallback value directly.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar fallback = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddFallback(new()\n    {\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout),\n        FallbackAction = async args => Outcome.FromResult(await CallSecondary(args.Context.CancellationToken))\n    })\n    .Build();\n\nreturn await fallback.ExecuteAsync(CallPrimary, CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Integrating Polly with Refit in C#\nDESCRIPTION: This snippet demonstrates how to use Polly with Refit, an automatic type-safe REST library. It registers a Refit-generated typed HttpClient with a resilience pipeline and shows how to use the typed client to make an API request.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Register a Refit generated typed HttpClient and decorate with a resilience pipeline\nservices.AddRefitClient<IHttpStatusApi>()\n        .ConfigureHttpClient(client => client.BaseAddress = BaseAddress)\n        .AddResilienceHandler(\"refit_based_pipeline\",\n            builder => builder.AddRetry(GetRetryOptions()));\n\n// Resolve the typed HttpClient\nusing var provider = services.BuildServiceProvider();\nvar apiClient = provider.GetRequiredService<IHttpStatusApi>();\n\n// Use the Refit generated typed HttpClient by making a request\nvar response = await apiClient.GetRequestTimeoutEndpointAsync();\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Metering Enricher in C#\nDESCRIPTION: This code snippet shows how to register a custom metering enricher with the TelemetryOptions and configure it in a resilience pipeline. It demonstrates the setup process for enabling telemetry in the builder.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvar telemetryOptions = new TelemetryOptions();\n\n// Register custom enricher\ntelemetryOptions.MeteringEnrichers.Add(new CustomMeteringEnricher());\n\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions())\n    .ConfigureTelemetry(telemetryOptions) // This method enables telemetry in the builder\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Running tests for the Polly project\nDESCRIPTION: Command to build the solution and run all tests to ensure changes haven't broken functionality.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet test\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiter with Exception Handling in C#\nDESCRIPTION: Shows how to implement a rate limiter without an OnRejected callback, instead using try-catch blocks to handle RateLimiterRejectedException exceptions. This approach is more traditional for error handling.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/rate-limiter.md#2025-04-18_snippet_3\n\nLANGUAGE: cs\nCODE:\n```\nvar withoutOnRejected = new ResiliencePipelineBuilder()\n    .AddRateLimiter(new RateLimiterStrategyOptions\n    {\n        DefaultRateLimiterOptions = new ConcurrencyLimiterOptions\n        {\n            PermitLimit = 10\n        }\n    }).Build();\n\ntry\n{\n    await withoutOnRejected.ExecuteAsync(async ct => await TextSearchAsync(query, ct), CancellationToken.None);\n}\ncatch (RateLimiterRejectedException)\n{\n    Console.WriteLine(\"Rate limit has been exceeded\");\n}\n```\n\n----------------------------------------\n\nTITLE: Managing Resource Disposal in Resilience Pipelines\nDESCRIPTION: Shows how to register callbacks for resource disposal that run when pipelines are discarded, reloaded, or the registry is disposed.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddResiliencePipeline(\"my-pipeline\", (builder, context) =>\n{\n    // Create disposable resource\n    var limiter = new ConcurrencyLimiter(new ConcurrencyLimiterOptions { PermitLimit = 100, QueueLimit = 100 });\n\n    // Use it\n    builder.AddRateLimiter(limiter);\n\n    // Dispose the resource created in the callback when the pipeline is discarded\n    context.OnPipelineDisposed(() => limiter.Dispose());\n});\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing ResilienceContext in Polly v8\nDESCRIPTION: Shows how to work with ResilienceContext in Polly v8, including obtaining a context from the pool, setting type-safe properties, and properly returning the context to the pool when finished.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_20\n\nLANGUAGE: cs\nCODE:\n```\n// Create context\nResilienceContext context = ResilienceContextPool.Shared.Get();\n\n// Create context with operation key\ncontext = ResilienceContextPool.Shared.Get(\"my-operation-key\");\n\n// Attach custom properties\nResiliencePropertyKey<string> propertyKey1 = new(Key1);\ncontext.Properties.Set(propertyKey1, \"value-1\");\n\nResiliencePropertyKey<int> propertyKey2 = new(Key2);\ncontext.Properties.Set(propertyKey2, 100);\n\n// Bulk attach\ncontext.Properties.SetProperties(new Dictionary<string, object?>\n{\n    { Key1 , \"value-1\" },\n    { Key2 , 100 }\n}, out var oldProperties);\n\n// Retrieve custom properties\nstring value1 = context.Properties.GetValue(propertyKey1, \"default\");\nint value2 = context.Properties.GetValue(propertyKey2, 0);\n\n// Return the context to the pool\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Implementing Registry Components in Polly\nDESCRIPTION: Classes for managing resilience pipelines in a registry. Provides methods for creating, retrieving, and configuring named pipelines with support for pipeline disposal and reloading.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Registry.ConfigureBuilderContext<TKey>\nPolly.Registry.ConfigureBuilderContext<TKey>.AddReloadToken(System.Threading.CancellationToken cancellationToken) -> void\nPolly.Registry.ConfigureBuilderContext<TKey>.OnPipelineDisposed(System.Action! callback) -> void\nPolly.Registry.ConfigureBuilderContext<TKey>.PipelineKey.get -> TKey\n\nPolly.Registry.ResiliencePipelineProvider<TKey>\nPolly.Registry.ResiliencePipelineProvider<TKey>.ResiliencePipelineProvider() -> void\n\nPolly.Registry.ResiliencePipelineRegistry<TKey>\nPolly.Registry.ResiliencePipelineRegistry<TKey>.Dispose() -> void\nPolly.Registry.ResiliencePipelineRegistry<TKey>.DisposeAsync() -> System.Threading.Tasks.ValueTask\nPolly.Registry.ResiliencePipelineRegistry<TKey>.GetOrAddPipeline(TKey key, System.Action<Polly.ResiliencePipelineBuilder!, Polly.Registry.ConfigureBuilderContext<TKey>!>! configure) -> Polly.ResiliencePipeline!\nPolly.Registry.ResiliencePipelineRegistry<TKey>.GetOrAddPipeline(TKey key, System.Action<Polly.ResiliencePipelineBuilder!>! configure) -> Polly.ResiliencePipeline!\nPolly.Registry.ResiliencePipelineRegistry<TKey>.GetOrAddPipeline<TResult>(TKey key, System.Action<Polly.ResiliencePipelineBuilder<TResult>!, Polly.Registry.ConfigureBuilderContext<TKey>!>! configure) -> Polly.ResiliencePipeline<TResult>!\nPolly.Registry.ResiliencePipelineRegistry<TKey>.GetOrAddPipeline<TResult>(TKey key, System.Action<Polly.ResiliencePipelineBuilder<TResult>!>! configure) -> Polly.ResiliencePipeline<TResult>!\nPolly.Registry.ResiliencePipelineRegistry<TKey>.ResiliencePipelineRegistry() -> void\nPolly.Registry.ResiliencePipelineRegistry<TKey>.ResiliencePipelineRegistry(Polly.Registry.ResiliencePipelineRegistryOptions<TKey>! options) -> void\nPolly.Registry.ResiliencePipelineRegistry<TKey>.TryAddBuilder(TKey key, System.Action<Polly.ResiliencePipelineBuilder!, Polly.Registry.ConfigureBuilderContext<TKey>!>! configure) -> bool\nPolly.Registry.ResiliencePipelineRegistry<TKey>.TryAddBuilder<TResult>(TKey key, System.Action<Polly.ResiliencePipelineBuilder<TResult>!, Polly.Registry.ConfigureBuilderContext<TKey>!>! configure) -> bool\n\nPolly.Registry.ResiliencePipelineRegistryOptions<TKey>\n```\n\n----------------------------------------\n\nTITLE: Handling Result-Based Retries in Polly v7\nDESCRIPTION: Shows how to configure retries based on both exceptions and response results in Polly v7, specifically for HTTP responses with error status codes.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// Wait and retry with result handling\nPolicy\n    .Handle<SomeExceptionType>()\n    .OrResult<HttpResponseMessage>(result => result.StatusCode == HttpStatusCode.InternalServerError)\n    .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1));\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Policies in Polly v7\nDESCRIPTION: This snippet demonstrates how to create and use different types of policies in Polly v7, including synchronous and asynchronous policies with and without generic type parameters.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Create and use the ISyncPolicy.\nISyncPolicy syncPolicy = Policy\n    .Handle<Exception>()\n    .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1));\n\nsyncPolicy.Execute(() =>\n{\n    // Your code goes here\n});\n\n// Create and use the IAsyncPolicy\nIAsyncPolicy asyncPolicy = Policy\n    .Handle<Exception>()\n    .WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));\nawait asyncPolicy.ExecuteAsync(async token =>\n{\n    // Your code goes here\n}, cancellationToken);\n\n// Create and use the ISyncPolicy<T>\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage>\n    .HandleResult(result => !result.IsSuccessStatusCode)\n    .WaitAndRetry(3, _ => TimeSpan.FromSeconds(1));\n\nsyncPolicyT.Execute(() =>\n{\n    // Your code goes here\n    return GetResponse();\n});\n\n// Create and use the IAsyncPolicy<T>\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage>\n    .HandleResult(result => !result.IsSuccessStatusCode)\n    .WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));\n\nawait asyncPolicyT.ExecuteAsync(async token =>\n{\n    // Your code goes here\n    return await GetResponseAsync(token);\n}, cancellationToken);\n```\n\n----------------------------------------\n\nTITLE: Configuring ResiliencePipelineRegistry Options in C#\nDESCRIPTION: Demonstrates how to configure various options for the ResiliencePipelineRegistry<string> using ResiliencePipelineRegistryOptions<string>.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new ResiliencePipelineRegistryOptions<string>\n{\n    BuilderComparer = StringComparer.OrdinalIgnoreCase,\n    PipelineComparer = StringComparer.OrdinalIgnoreCase,\n    BuilderFactory = () => new ResiliencePipelineBuilder\n    {\n        InstanceName = \"lets change the default of InstanceName\",\n        Name = \"lets change the default of Name\",\n    },\n    BuilderNameFormatter = key => $\"key:{key}\",\n    InstanceNameFormatter = key => $\"instance-key:{key}\",\n};\n\nvar registry = new ResiliencePipelineRegistry<string>();\n```\n\n----------------------------------------\n\nTITLE: Implementing PredicateBuilder in Polly\nDESCRIPTION: A fluent builder for creating predicates that determine which exceptions or results should be handled by resilience strategies. Supports handling specific exception types and filtering by result values.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nPolly.PredicateBuilder\nPolly.PredicateBuilder.PredicateBuilder() -> void\n\nPolly.PredicateBuilder<TResult>\nPolly.PredicateBuilder<TResult>.Build() -> System.Predicate<Polly.Outcome<TResult>>!\nPolly.PredicateBuilder<TResult>.Handle<TException>() -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.Handle<TException>(System.Func<TException!, bool>! predicate) -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.HandleInner<TException>() -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.HandleInner<TException>(System.Func<TException!, bool>! predicate) -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.HandleResult(System.Func<TResult, bool>! predicate) -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.HandleResult(TResult result, System.Collections.Generic.IEqualityComparer<TResult>? comparer = null) -> Polly.PredicateBuilder<TResult>!\nPolly.PredicateBuilder<TResult>.PredicateBuilder() -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Hedging Strategy Components in Polly\nDESCRIPTION: Classes for implementing hedging resilience strategies that execute multiple operations in parallel or sequentially as fallbacks. Includes generator arguments, predicates, and configuration options.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_6\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.ActionContext.get -> Polly.ResilienceContext!\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.AttemptNumber.get -> int\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.Callback.get -> System.Func<Polly.ResilienceContext!, System.Threading.Tasks.ValueTask<Polly.Outcome<TResult>>>!\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.HedgingActionGeneratorArguments() -> void\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.HedgingActionGeneratorArguments(Polly.ResilienceContext! primaryContext, Polly.ResilienceContext! actionContext, int attemptNumber, System.Func<Polly.ResilienceContext!, System.Threading.Tasks.ValueTask<Polly.Outcome<TResult>>>! callback) -> void\nPolly.Hedging.HedgingActionGeneratorArguments<TResult>.PrimaryContext.get -> Polly.ResilienceContext!\n\nPolly.Hedging.HedgingDelayGeneratorArguments\nPolly.Hedging.HedgingDelayGeneratorArguments.AttemptNumber.get -> int\nPolly.Hedging.HedgingDelayGeneratorArguments.Context.get -> Polly.ResilienceContext!\nPolly.Hedging.HedgingDelayGeneratorArguments.HedgingDelayGeneratorArguments() -> void\nPolly.Hedging.HedgingDelayGeneratorArguments.HedgingDelayGeneratorArguments(Polly.ResilienceContext! context, int attemptNumber) -> void\n\nPolly.Hedging.HedgingPredicateArguments<TResult>\nPolly.Hedging.HedgingPredicateArguments<TResult>.Context.get -> Polly.ResilienceContext!\nPolly.Hedging.HedgingPredicateArguments<TResult>.HedgingPredicateArguments() -> void\nPolly.Hedging.HedgingPredicateArguments<TResult>.HedgingPredicateArguments(Polly.ResilienceContext! context, Polly.Outcome<TResult> outcome) -> void\nPolly.Hedging.HedgingPredicateArguments<TResult>.Outcome.get -> Polly.Outcome<TResult>\n\nPolly.Hedging.HedgingStrategyOptions<TResult>\nPolly.Hedging.HedgingStrategyOptions<TResult>.ActionGenerator.get -> System.Func<Polly.Hedging.HedgingActionGeneratorArguments<TResult>, System.Func<System.Threading.Tasks.ValueTask<Polly.Outcome<TResult>>>?>!\nPolly.Hedging.HedgingStrategyOptions<TResult>.ActionGenerator.set -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.Delay.get -> System.TimeSpan\nPolly.Hedging.HedgingStrategyOptions<TResult>.Delay.set -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.DelayGenerator.get -> System.Func<Polly.Hedging.HedgingDelayGeneratorArguments, System.Threading.Tasks.ValueTask<System.TimeSpan>>?\nPolly.Hedging.HedgingStrategyOptions<TResult>.DelayGenerator.set -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.HedgingStrategyOptions() -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.MaxHedgedAttempts.get -> int\nPolly.Hedging.HedgingStrategyOptions<TResult>.MaxHedgedAttempts.set -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.OnHedging.get -> System.Func<Polly.Hedging.OnHedgingArguments<TResult>, System.Threading.Tasks.ValueTask>?\nPolly.Hedging.HedgingStrategyOptions<TResult>.OnHedging.set -> void\nPolly.Hedging.HedgingStrategyOptions<TResult>.ShouldHandle.get -> System.Func<Polly.Hedging.HedgingPredicateArguments<TResult>, System.Threading.Tasks.ValueTask<bool>>!\nPolly.Hedging.HedgingStrategyOptions<TResult>.ShouldHandle.set -> void\n\nPolly.Hedging.OnHedgingArguments<TResult>\nPolly.Hedging.OnHedgingArguments<TResult>.ActionContext.get -> Polly.ResilienceContext!\nPolly.Hedging.OnHedgingArguments<TResult>.AttemptNumber.get -> int\nPolly.Hedging.OnHedgingArguments<TResult>.OnHedgingArguments() -> void\nPolly.Hedging.OnHedgingArguments<TResult>.OnHedgingArguments(Polly.ResilienceContext! primaryContext, Polly.ResilienceContext! actionContext, int attemptNumber) -> void\nPolly.Hedging.OnHedgingArguments<TResult>.PrimaryContext.get -> Polly.ResilienceContext!\n```\n\n----------------------------------------\n\nTITLE: Implementing TimingResilienceStrategyBuilderExtensions in C#\nDESCRIPTION: This code snippet defines extension methods for ResiliencePipelineBuilderBase to add the Timing resilience strategy. It includes a method that accepts TimingStrategyOptions and creates a new TimingResilienceStrategy instance.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/proactive-strategy.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class TimingResilienceStrategyBuilderExtensions\n{\n    // The extensions should return the builder to support a fluent API.\n    // For proactive strategies, we can target both \"ResiliencePipelineBuilderBase\" and \"ResiliencePipelineBuilder<T>\"\n    // using generic constraints.\n    public static TBuilder AddTiming<TBuilder>(this TBuilder builder, TimingStrategyOptions options)\n        where TBuilder : ResiliencePipelineBuilderBase\n    {\n        // Add the strategy through the AddStrategy method. This method accepts a factory delegate\n        // and automatically validates the options.\n        return builder.AddStrategy(\n            context =>\n            {\n                // The \"context\" provides various properties for the strategy's use.\n                // In this case, we simply use the \"Telemetry\" property and pass it to the strategy.\n                // The Threshold and OnThresholdExceeded values are sourced from the options.\n                var strategy = new TimingResilienceStrategy(\n                    options.Threshold!.Value,\n                    options.OnThresholdExceeded,\n                    context.Telemetry);\n\n                return strategy;\n            },\n            options);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Policy Wrap Implementation in Polly v7\nDESCRIPTION: This code demonstrates how to combine multiple policies using the Policy.WrapAsync method in Polly v7, creating a policy chain where one policy wraps another.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nIAsyncPolicy retryPolicy = Policy.Handle<Exception>().WaitAndRetryAsync(3, _ => TimeSpan.FromSeconds(1));\n\nIAsyncPolicy timeoutPolicy = Policy.TimeoutAsync(TimeSpan.FromSeconds(3));\n\n// Wrap the policies. The policies are executed in the following order:\n// 1. Retry <== outer\n// 2. Timeout <== inner\nIAsyncPolicy wrappedPolicy = Policy.WrapAsync(retryPolicy, timeoutPolicy);\n```\n\n----------------------------------------\n\nTITLE: Registering Resilience Pipeline with Complex Key in C#\nDESCRIPTION: This snippet shows how to register a resilience pipeline using a complex key. It adds a circuit breaker strategy to the pipeline builder.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nservices.AddResiliencePipeline(new MyPipelineKey(\"my-pipeline\", string.Empty), builder =>\n{\n    // Circuit breaker is a stateful strategy. To isolate the builder across different pipelines,\n    // we must use multiple instances.\n    builder.AddCircuitBreaker(new CircuitBreakerStrategyOptions());\n});\n```\n\n----------------------------------------\n\nTITLE: Using FaultGenerator Class for Exception Injection in Polly\nDESCRIPTION: Demonstrates how to use the FaultGenerator class to register different types of exceptions with optional weights. This approach provides a convenient API for configuring fault injection.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/fault.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder()\n    .AddChaosFault(new ChaosFaultStrategyOptions\n    {\n        // Use FaultGenerator to register exceptions to be injected\n        FaultGenerator = new FaultGenerator()\n            .AddException<InvalidOperationException>() // Uses default constructor\n            .AddException(() => new TimeoutException(\"Chaos timeout injected.\")) // Custom exception generator\n            .AddException(context => CreateExceptionFromContext(context)) // Access the ResilienceContext\n            .AddException<TimeoutException>(weight: 50), // Assign weight to the exception, default is 100\n    });\n```\n\n----------------------------------------\n\nTITLE: Chaos Engineering Extensions in C#\nDESCRIPTION: Extension methods for implementing chaos engineering patterns including fault injection, latency simulation, and behavior modification.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.Simmy.ChaosBehaviorPipelineBuilderExtensions.AddChaosBehavior<TBuilder>(this TBuilder! builder, double injectionRate, System.Func<System.Threading.CancellationToken, System.Threading.Tasks.ValueTask>! behavior) -> TBuilder!\nstatic Polly.Simmy.ChaosFaultPipelineBuilderExtensions.AddChaosFault<TBuilder>(this TBuilder! builder, double injectionRate, System.Func<System.Exception?>! faultGenerator) -> TBuilder!\nstatic Polly.Simmy.ChaosLatencyPipelineBuilderExtensions.AddChaosLatency<TBuilder>(this TBuilder! builder, double injectionRate, System.TimeSpan latency) -> TBuilder!\n```\n\n----------------------------------------\n\nTITLE: Using Switch Expressions for Predicates in Polly (C#)\nDESCRIPTION: Shows how to use switch expressions instead of PredicateBuilder for configuring exception handling in retry strategies. This approach can bypass the overhead of iterating through a list of predicates.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/performance.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// Here, PredicateBuilder is used to configure which exceptions the retry strategy should handle.\nnew ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder()\n            .Handle<SomeExceptionType>()\n            .Handle<InvalidOperationException>()\n            .Handle<HttpRequestException>()\n    })\n    .Build();\n\n// For optimal performance, it's recommended to use switch expressions instead of PredicateBuilder.\nnew ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = args => args.Outcome.Exception switch\n        {\n            SomeExceptionType => PredicateResult.True(),\n            InvalidOperationException => PredicateResult.True(),\n            HttpRequestException => PredicateResult.True(),\n            _ => PredicateResult.False()\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Using ResiliencePipelineProvider with Complex Keys in C#\nDESCRIPTION: This snippet shows how to use ResiliencePipelineProvider<MyPipelineKey> to dynamically create and cache multiple instances of the same pipeline with different instance names.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nResiliencePipelineProvider<MyPipelineKey> pipelineProvider = serviceProvider.GetRequiredService<ResiliencePipelineProvider<MyPipelineKey>>();\n\n// The registry dynamically creates and caches instance-A using the associated builder action\nResiliencePipeline instanceA = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-A\"));\n\n// The registry creates and caches instance-B\nResiliencePipeline instanceB = pipelineProvider.GetPipeline(new MyPipelineKey(\"my-pipeline\", \"instance-B\"));\n```\n\n----------------------------------------\n\nTITLE: Setting up Telemetry Tags in Polly\nDESCRIPTION: Demonstration of how to set up and configure telemetry tags for pipeline name, instance name, strategy name, and operation key.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar builder = new ResiliencePipelineBuilder();\nbuilder.Name = \"my-name\";\nbuilder.InstanceName = \"my-instance-name\";\n\nbuilder.AddRetry(new RetryStrategyOptions\n{\n    // The default value is \"Retry\"\n    Name = \"my-retry-name\"\n});\n\nResiliencePipeline pipeline = builder.Build();\n\n// Create resilience context with operation key\nResilienceContext resilienceContext = ResilienceContextPool.Shared.Get(\"my-operation-key\");\n\n// Execute the pipeline with the context\npipeline.Execute(\n    context =>\n    {\n        // Your code comes here\n    },\n    resilienceContext);\n```\n\n----------------------------------------\n\nTITLE: Configuring Resilience Pipelines with Dependency Injection in C#\nDESCRIPTION: Static extension methods for adding resilience pipelines to a service collection. These methods enable registration of typed resilience pipelines with dependency injection containers.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipeline<TKey, TResult>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, TKey key, System.Action<Polly.ResiliencePipelineBuilder<TResult>!, Polly.DependencyInjection.AddResiliencePipelineContext<TKey>!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipeline<TKey, TResult>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, TKey key, System.Action<Polly.ResiliencePipelineBuilder<TResult>!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipeline<TKey>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, TKey key, System.Action<Polly.ResiliencePipelineBuilder!, Polly.DependencyInjection.AddResiliencePipelineContext<TKey>!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipeline<TKey>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, TKey key, System.Action<Polly.ResiliencePipelineBuilder!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Accessing IServiceCollection in C#\nDESCRIPTION: This snippet demonstrates an anti-pattern where IServiceCollection is captured inside AddResiliencePipeline(). This approach builds a new ServiceProvider before each retry attempt unnecessarily.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\nservices.AddResiliencePipeline(\"myFavoriteStrategy\", builder =>\n{\n    builder.AddRetry(new()\n    {\n        OnRetry = args =>\n        {\n            var serviceProvider = services.BuildServiceProvider();\n            var logger = serviceProvider.GetService<ILogger>();\n            // ...\n            return default;\n        }\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Circuit Breaker in Polly v8\nDESCRIPTION: Shows how to create circuit breaker strategies in Polly v8 using CircuitBreakerStrategyOptions, with support for state monitoring and manual control through separate provider objects.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// Create pipeline with circuit breaker. Because ResiliencePipeline supports both sync and async\n// callbacks, there is no need to define it twice.\nResiliencePipeline pipeline = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new CircuitBreakerStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n        FailureRatio = 0.5d,\n        SamplingDuration = TimeSpan.FromSeconds(5),\n        MinimumThroughput = 2,\n        BreakDuration = TimeSpan.FromSeconds(1)\n    })\n    .Build();\n\n// Create a generic pipeline with circuit breaker. Because ResiliencePipeline<T> supports both sync and async\n// callbacks, there is also no need to define it twice.\nResiliencePipeline<HttpResponseMessage> pipelineT = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddCircuitBreaker(new CircuitBreakerStrategyOptions<HttpResponseMessage>\n    {\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>().Handle<SomeExceptionType>(),\n        FailureRatio = 0.5d,\n        SamplingDuration = TimeSpan.FromSeconds(5),\n        MinimumThroughput = 2,\n        BreakDuration = TimeSpan.FromSeconds(1)\n    })\n    .Build();\n\n// Check circuit state\nCircuitBreakerStateProvider stateProvider = new();\n// Manually control state\nCircuitBreakerManualControl manualControl = new();\n\nResiliencePipeline pipelineState = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new CircuitBreakerStrategyOptions\n    {\n        ShouldHandle = new PredicateBuilder().Handle<SomeExceptionType>(),\n        FailureRatio = 0.5d,\n        SamplingDuration = TimeSpan.FromSeconds(5),\n        MinimumThroughput = 2,\n        BreakDuration = TimeSpan.FromSeconds(1),\n        StateProvider = stateProvider,\n        ManualControl = manualControl\n    })\n    .Build();\n\n// Check circuit state\nbool isOpen = stateProvider.CircuitState == CircuitState.Open || stateProvider.CircuitState == CircuitState.Isolated;\n\n// Manually control state\nawait manualControl.IsolateAsync(); // Transitions into the Isolated state\nawait manualControl.CloseAsync(); // Transitions into the Closed state\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker State Diagram\nDESCRIPTION: Mermaid diagram showing the possible state transitions in the circuit breaker, including Closed, Open, and HalfOpen states.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram-v2\ndirection LR\n    [*] --> Closed\n    Closed --> Open: Exceeds threshold\n    Open --> HalfOpen: Elapses break duration\n    HalfOpen --> Closed: Passes the probe\n    HalfOpen --> Open: Fails the probe\n```\n\n----------------------------------------\n\nTITLE: Visualizing Unhappy Path Retry Sequence with Mermaid\nDESCRIPTION: A sequence diagram illustrating the unhappy path flow of a retry strategy with a maximum of 2 retry attempts. It demonstrates the interaction between components when all retry attempts fail, resulting in the propagation of the failure to the caller.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor C as Caller\n    participant P as Pipeline\n    participant R as Retry\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>R: Calls ExecuteCore\n    Note over R,D: Initial attempt\n    R->>+D: Invokes\n    D->>-R: Fails\n    R-->>R: Sleeps\n    Note over R,D: 1st retry attempt\n    R->>+D: Invokes\n    D->>-R: Fails\n    R-->>R: Sleeps\n    Note over R,D: 2nd retry attempt\n    R->>+D: Invokes\n    D->>-R: Fails\n    R->>P: Propagates failure\n    P->>C: Propagates failure\n```\n\n----------------------------------------\n\nTITLE: Integrating Polly with RestSharp in C#\nDESCRIPTION: This snippet shows how to use Polly with RestSharp, a simple REST and HTTP API Client. It registers a named HttpClient with a resilience pipeline and creates a RestClient that uses this decorated HttpClient for making HTTP requests.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar services = new ServiceCollection();\n\n// Register a named HttpClient and decorate with a resilience pipeline\nservices.AddHttpClient(HttpClientName)\n        .ConfigureHttpClient(client => client.BaseAddress = BaseAddress)\n        .AddResilienceHandler(\"restsharp_based_pipeline\",\n            builder => builder.AddRetry(GetRetryOptions()));\n\nusing var provider = services.BuildServiceProvider();\n\n// Resolve the named HttpClient and create a RestClient\nvar httpClientFactory = provider.GetRequiredService<IHttpClientFactory>();\nvar restClient = new RestClient(httpClientFactory.CreateClient(HttpClientName));\n\n// Use the RestClient by making a request\nvar request = new RestRequest(\"/408\", Method.Get);\nvar response = await restClient.ExecuteAsync(request);\n```\n\n----------------------------------------\n\nTITLE: Configuring Resilience Pipeline Registry in C#\nDESCRIPTION: This snippet demonstrates how to configure the resilience pipeline registry. It sets the BuilderComparer, InstanceNameFormatter, and BuilderNameFormatter properties.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nservices\n    .AddResiliencePipelineRegistry<MyPipelineKey>(options =>\n    {\n        options.BuilderComparer = new PipelineNameComparer();\n\n        options.InstanceNameFormatter = key => key.InstanceName;\n\n        options.BuilderNameFormatter = key => key.PipelineName;\n    });\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Fault Handling Predicates\nDESCRIPTION: Demonstrates implementation of asynchronous fault handling predicates for advanced scenarios like retrying based on response body content.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/index.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new RetryStrategyOptions<HttpResponseMessage>\n{\n    ShouldHandle = async args =>\n    {\n        if (args.Outcome.Exception is not null)\n        {\n            return args.Outcome.Exception switch\n            {\n                HttpRequestException => true,\n                TimeoutRejectedException => true,\n                _ => false\n            };\n        }\n\n        // Determine whether to retry asynchronously or not based on the result.\n        return await ShouldRetryAsync(args.Outcome.Result!, args.Context.CancellationToken);\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Metering Enricher in C#\nDESCRIPTION: This snippet demonstrates how to create a custom metering enricher by deriving from the MeteringEnricher class. It shows how to add extra tags to resilience events, specifically for retry attempts.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\ninternal sealed class CustomMeteringEnricher : MeteringEnricher\n{\n    public override void Enrich<TResult, TArgs>(in EnrichmentContext<TResult, TArgs> context)\n    {\n        // You can read additional details from any resilience event and use it to enrich the telemetry\n        if (context.TelemetryEvent.Arguments is OnRetryArguments<TResult> retryArgs)\n        {\n            // See https://github.com/open-telemetry/semantic-conventions/blob/main/docs/general/metrics.md for more details\n            // on how to name the tags.\n            context.Tags.Add(new(\"retry.attempt\", retryArgs.AttemptNumber));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-Generic ResultReportingStrategyOptions in C#\nDESCRIPTION: This code defines a non-generic version of ResultReportingStrategyOptions, which derives from the generic version using 'object' as the result type. This allows the strategy to manage all result types.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Simply derive from the generic options, using 'object' as the result type.\n// This allows the strategy to manage all results.\npublic class ResultReportingStrategyOptions : ResultReportingStrategyOptions<object>\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple Resilience Pipelines in C#\nDESCRIPTION: Extension method for adding multiple resilience pipelines with a shared configuration context. This allows for bulk configuration of multiple related resilience pipelines.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipelines<TKey>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Polly.DependencyInjection.AddResiliencePipelinesContext<TKey>!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Defining Complex Pipeline Key in C#\nDESCRIPTION: This snippet demonstrates how to define a complex pipeline key using a C# record struct. The key contains two string properties: PipelineName and InstanceName.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\npublic record struct MyPipelineKey(string PipelineName, string InstanceName)\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Actions Before Each Retry Attempt in C#\nDESCRIPTION: Shows the correct way to execute an action before each retry attempt by grouping the calls within the ExecuteAsync method, ensuring consistent execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new())\n    .Build();\n\nawait retry.ExecuteAsync(ct =>\n{\n    BeforeEachAttempt();\n    return DoSomething(ct);\n});\n```\n\n----------------------------------------\n\nTITLE: Using TimingResilienceStrategy in C#\nDESCRIPTION: This code snippet demonstrates how to use the Timing resilience strategy by adding it to a ResiliencePipelineBuilder. It sets a threshold of 1 second and defines a callback for when the threshold is exceeded.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/proactive-strategy.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// Add the proactive strategy to the builder\nvar pipeline = new ResiliencePipelineBuilder()\n    // This is custom extension defined in this sample\n    .AddTiming(new TimingStrategyOptions\n    {\n        Threshold = TimeSpan.FromSeconds(1),\n        OnThresholdExceeded = args =>\n        {\n            Console.WriteLine(\"Execution threshold exceeded!\");\n            return default;\n        },\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Visualizing Component Interactions with Mermaid Diagram\nDESCRIPTION: A flowchart diagram showing how built-in Polly types interact with custom-built resilience strategy components, including options, builder extensions, strategy implementations, and event arguments.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/index.md#2025-04-18_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart\n    options[XYZStrategyOptions]\n    builder[XYZResilienceStrategyBuilderExtensions]\n    strategy[XYZResilienceStrategy]\n    args[XYZEventArguments]\n\n    telemetry{{ResilienceStrategyTelemetry}}\n    pipeline{{ResiliencePipeline}}\n\n    options -- is passed to AddXYZ  --> builder\n    builder -- registers a strategy --> pipeline\n    options -- configures behavior --> strategy\n\n    pipeline -- calls the execution --> strategy\n\n    strategy -- creates for events --> args\n    strategy -- uses for reporting --> telemetry\n\n    %% a workaround to add note (currently only sequence diagram supports notes)\n    %% https://github.com/mermaid-js/mermaid/issues/821\n    args -.- note(The strategy calls<br/>the OnXYZ delegate of<br/> the options with this object.)\n```\n\n----------------------------------------\n\nTITLE: Configuring Telemetry for Resilience Pipelines in C#\nDESCRIPTION: Extension methods for configuring telemetry capabilities of resilience pipelines. These methods support setting up logging and telemetry options for monitoring pipeline execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(this TBuilder! builder, Microsoft.Extensions.Logging.ILoggerFactory! loggerFactory) -> TBuilder!\nstatic Polly.TelemetryResiliencePipelineBuilderExtensions.ConfigureTelemetry<TBuilder>(this TBuilder! builder, Polly.Telemetry.TelemetryOptions! options) -> TBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining a Chaos Manager Interface in C#\nDESCRIPTION: Defines an interface for centralizing chaos-related decisions across the application. This interface provides methods to determine if chaos should be enabled and what injection rate to use for a given resilience context.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/index.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IChaosManager\n{\n    ValueTask<bool> IsChaosEnabled(ResilienceContext context);\n\n    ValueTask<double> GetInjectionRate(ResilienceContext context);\n}\n```\n\n----------------------------------------\n\nTITLE: Mocking ResiliencePipelineProvider for Unit Testing\nDESCRIPTION: Demonstrates how to mock the ResiliencePipelineProvider using NSubstitute for unit testing, returning an empty pipeline to simplify test execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/testing.md#2025-04-18_snippet_4\n\nLANGUAGE: cs\nCODE:\n```\nResiliencePipelineProvider<string> pipelineProvider = Substitute.For<ResiliencePipelineProvider<string>>();\n\n// Mock the pipeline provider to return an empty pipeline for testing\npipelineProvider\n    .GetPipeline(\"my-pipeline\")\n    .Returns(ResiliencePipeline.Empty);\n\n// Use the mocked pipeline provider in your code\nvar api = new MyApi(pipelineProvider);\n\n// You can now test the api\n```\n\n----------------------------------------\n\nTITLE: Configuring Behavior Chaos Strategy Options in C#\nDESCRIPTION: Demonstrates how to configure ChaosBehaviorStrategyOptions with custom behavior generators and injection notifications. It also shows how to add the strategy to a ResiliencePipelineBuilder.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/behavior.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// To use a custom delegated for injected behavior\nvar optionsWithBehaviorGenerator = new ChaosBehaviorStrategyOptions\n{\n    BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken),\n    InjectionRate = 0.05\n};\n\n// To get notifications when a behavior is injected\nvar optionsOnBehaviorInjected = new ChaosBehaviorStrategyOptions\n{\n    BehaviorGenerator = static args => RestartRedisAsync(args.Context.CancellationToken),\n    InjectionRate = 0.05,\n    OnBehaviorInjected = static args =>\n    {\n        Console.WriteLine(\"OnBehaviorInjected, Operation: {0}.\", args.Context.OperationKey);\n        return default;\n    }\n};\n\n// Add a behavior strategy with a ChaosBehaviorStrategyOptions instance to the pipeline\nnew ResiliencePipelineBuilder().AddChaosBehavior(optionsWithBehaviorGenerator);\nnew ResiliencePipelineBuilder<HttpResponseMessage>().AddChaosBehavior(optionsOnBehaviorInjected);\n\n// There are also a handy overload to inject the chaos easily\nnew ResiliencePipelineBuilder().AddChaosBehavior(0.05, RestartRedisAsync);\n```\n\n----------------------------------------\n\nTITLE: Registering Resilience Pipeline Registry in C#\nDESCRIPTION: Extension methods for adding a resilience pipeline registry to a service collection. These methods support registering a typed registry with optional configuration options.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipelineRegistry<TKey>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\nstatic Polly.PollyServiceCollectionExtensions.AddResiliencePipelineRegistry<TKey>(this Microsoft.Extensions.DependencyInjection.IServiceCollection! services, System.Action<Polly.Registry.ResiliencePipelineRegistryOptions<TKey>!>! configure) -> Microsoft.Extensions.DependencyInjection.IServiceCollection!\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Reloads with Resource Disposal in C#\nDESCRIPTION: Shows how to combine dynamic reloads with proper resource disposal using OnPipelineDisposed callback.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar registry = new ResiliencePipelineRegistry<string>();\n\nregistry.TryAddBuilder(\"A\", (builder, context) =>\n{\n    var cancellation = new CancellationTokenSource();\n\n    // Register the source for potential external triggering\n    RegisterCancellationSource(cancellation);\n\n    // Add the reload token; note that an already cancelled token is disregarded\n    context.AddReloadToken(cancellation.Token);\n\n    // Configure your pipeline\n    builder.AddRetry(new RetryStrategyOptions());\n\n    context.OnPipelineDisposed(() => cancellation.Dispose());\n});\n```\n\n----------------------------------------\n\nTITLE: Using OutcomeGenerator<T> Class for Flexible Outcome Generation\nDESCRIPTION: Demonstrates how to use the OutcomeGenerator<T> class to register various results and exceptions with different weights for chaos testing, providing a convenient API for outcome configuration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n    {\n        // Use OutcomeGenerator<T> to register the results and exceptions to be injected\n        OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>()\n            .AddResult(() => new HttpResponseMessage(HttpStatusCode.InternalServerError)) // Result generator\n            .AddResult(() => new HttpResponseMessage(HttpStatusCode.TooManyRequests), weight: 50) // Result generator with weight\n            .AddResult(context => new HttpResponseMessage(CreateResultFromContext(context))) // Access the ResilienceContext to create result\n            .AddException<HttpRequestException>(), // You can also register exceptions\n    });\n```\n\n----------------------------------------\n\nTITLE: Configuring SynchronizationContext in Polly Pipeline\nDESCRIPTION: Demonstrates how to configure and use SynchronizationContext with Polly's ResilienceContext. Shows pooling pattern for context management and proper async/await configuration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/general.md#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n// Retrieve an instance of ResilienceContext from the pool\n// with the ContinueOnCapturedContext property set to true\nResilienceContext context = ResilienceContextPool.Shared.Get(continueOnCapturedContext: true);\n\nawait pipeline.ExecuteAsync(\n    static async context =>\n    {\n        // Execute your code, honoring the ContinueOnCapturedContext setting\n        await MyMethodAsync(context.CancellationToken).ConfigureAwait(context.ContinueOnCapturedContext);\n    },\n    context);\n\n// Optionally, return the ResilienceContext instance back to the pool\n// to minimize allocations and enhance performance\nResilienceContextPool.Shared.Return(context);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Creation of Resilience Pipelines in C#\nDESCRIPTION: Shows how to dynamically retrieve or create resilience pipelines without pre-registering builders using the GetOrAddPipeline method.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/pipelines/resilience-pipeline-registry.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar registry = new ResiliencePipelineRegistry<string>();\n\n// Dynamically retrieve or create pipeline \"A\"\nResiliencePipeline pipeline = registry.GetOrAddPipeline(\"A\", (builder, context) =>\n{\n    // Define your pipeline\n    builder.AddRetry(new RetryStrategyOptions());\n});\n\n// Dynamically retrieve or create generic pipeline \"A\"\nResiliencePipeline<HttpResponseMessage> genericPipeline = registry.GetOrAddPipeline<HttpResponseMessage>(\"A\", (builder, context) =>\n{\n    // Define your pipeline\n    builder.AddRetry(new RetryStrategyOptions<HttpResponseMessage>());\n});\n```\n\n----------------------------------------\n\nTITLE: Polly API Log Format Examples\nDESCRIPTION: This snippet provides examples of log formats used by the Polly API. It includes logs for resilience events, pipeline execution, and execution attempts, along with their respective Event IDs.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n// This log is recorded whenever a resilience event occurs. EventId = 0\nResilience event occurred. EventName: '{EventName}', Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}'\n\n// This log is recorded when a resilience pipeline begins executing. EventId = 1\nResilience pipeline executing. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}'\n\n// This log is recorded when a resilience pipeline finishes execution. EventId = 2\nResilience pipeline executed. Source: '{PipelineName}/{PipelineInstance}', Operation Key: '{OperationKey}', Result: '{Result}', Execution Health: '{ExecutionHealth}', Execution Time: {ExecutionTime}ms\n\n// This log is recorded upon the completion of every execution attempt. EventId = 3\nExecution attempt. Source: '{PipelineName}/{PipelineInstance}/{StrategyName}', Operation Key: '{OperationKey}', Result: '{Result}', Handled: '{Handled}', Attempt: '{Attempt}', Execution Time: '{ExecutionTime}ms'\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Strategy Options\nDESCRIPTION: Configuration options class for circuit breaker behavior including break duration, failure ratios, and event callbacks.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic class CircuitBreakerStrategyOptions<TResult>\n{\n    public TimeSpan BreakDuration { get; set; }\n    public double FailureRatio { get; set; }\n    public int MinimumThroughput { get; set; }\n    public TimeSpan SamplingDuration { get; set; }\n    public CircuitBreakerStateProvider StateProvider { get; set; }\n    public CircuitBreakerManualControl ManualControl { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Resilience Property Keys in C#\nDESCRIPTION: Shows how to define a static class containing type-safe resilience property keys that can be used with the ResilienceContext's Properties collection for better discoverability and maintainability.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/resilience-context.md#2025-04-18_snippet_1\n\nLANGUAGE: cs\nCODE:\n```\npublic static class MyResilienceKeys\n{\n    public static readonly ResiliencePropertyKey<string> Key1 = new(\"my-key-1\");\n\n    public static readonly ResiliencePropertyKey<int> Key2 = new(\"my-key-2\");\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for Polly Hedging Strategies\nDESCRIPTION: Benchmark results showing performance metrics for different hedging strategies in Polly. The table compares primary and secondary hedging approaches with both synchronous and asynchronous workloads, displaying execution time, error margins, standard deviation, allocation size, and performance ratios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.HedgingBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                      | Mean       | Error     | StdDev    | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|---------------------------- |-----------:|----------:|----------:|------:|--------:|-------:|----------:|------------:|\n| Hedging_Primary             |   684.6 ns |  25.04 ns |  36.71 ns |  1.00 |    0.07 |      - |         - |          NA |\n| Hedging_Secondary           | 1,192.5 ns |  24.41 ns |  34.21 ns |  1.75 |    0.10 | 0.0191 |     240 B |          NA |\n| Hedging_Primary_AsyncWork   | 5,504.3 ns | 313.47 ns | 449.58 ns |  8.06 |    0.77 | 0.1831 |    2338 B |          NA |\n| Hedging_Secondary_AsyncWork | 6,123.1 ns |  98.34 ns | 144.15 ns |  8.97 |    0.50 | 0.2060 |    2577 B |          NA |\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Misusing Retry for Fallback Functionality in C#\nDESCRIPTION: An incorrect approach that uses retry strategy to implement fallback functionality, which causes unnecessary repeated execution and complex state management.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar fallback = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder<HttpResponseMessage>()\n            .HandleResult(res => res.StatusCode == HttpStatusCode.RequestTimeout),\n        MaxRetryAttempts = 1,\n        OnRetry = async args =>\n        {\n            args.Context.Properties.Set(fallbackKey, await CallSecondary(args.Context.CancellationToken));\n        }\n    })\n    .Build();\n\nvar context = ResilienceContextPool.Shared.Get();\nvar outcome = await fallback.ExecuteOutcomeAsync<HttpResponseMessage, string>(\n    async (ctx, state) =>\n    {\n        var result = await CallPrimary(ctx.CancellationToken);\n        return Outcome.FromResult(result);\n    }, context, \"none\");\n\nvar result = outcome.Result is not null\n    ? outcome.Result\n    : context.Properties.GetValue(fallbackKey, default);\n\nResilienceContextPool.Shared.Return(context);\n\nreturn result;\n```\n\n----------------------------------------\n\nTITLE: Implementing Resilience Pipeline in Visual Basic\nDESCRIPTION: This snippet shows how to use the Polly ResiliencePipeline in Visual Basic. It demonstrates synchronous and asynchronous execution, handling of ValueTask, and the use of AsTask() method to convert ValueTask to Task for awaiting.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/use-with-fsharp-and-visual-basic.md#2025-04-18_snippet_1\n\nLANGUAGE: vbnet\nCODE:\n```\nImports System.Threading\nImports Polly\n\nModule Program\n    Sub Main()\n        Demo().Wait()\n    End Sub\n\n    Async Function Demo() As Task\n        ' The ResiliencePipelineBuilder creates a ResiliencePipeline\n        ' that can be executed synchronously or asynchronously\n        ' and for both void and result-returning user-callbacks.\n        Dim pipeline = New ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(5)).Build()\n\n        ' Synchronously\n        pipeline.Execute(Sub()\n                             Console.WriteLine(\"Hello, world!\")\n                         End Sub)\n\n        ' Asynchronously\n        ' Note that the function is wrapped in a ValueTask for Polly to use as VB.NET cannot\n        ' await ValueTask directly, and AsTask() is used to convert the ValueTask returned by\n        ' ExecuteAsync() to a Task so it can be awaited.\n        Await pipeline.ExecuteAsync(Function(token)\n                                        Return New ValueTask(GreetAndWaitAsync(token))\n                                    End Function,\n                                    CancellationToken.None).AsTask()\n\n        ' Synchronously with result\n        Dim someResult = pipeline.Execute(Function(token)\n                                              Return \"some-result\"\n                                          End Function)\n\n        ' Asynchronously with result\n        ' Note that the function is wrapped in a ValueTask(Of String) for Polly to use as VB.NET cannot\n        ' await ValueTask directly, and AsTask() is used to convert the ValueTask(Of String) returned by\n        ' ExecuteAsync() to a Task(Of String) so it can be awaited.\n        Dim bestFilm = Await pipeline.ExecuteAsync(Function(token)\n                                                       Return New ValueTask(Of String)(GetBestFilmAsync(token))\n                                                   End Function,\n                                    CancellationToken.None).AsTask()\n\n        Console.WriteLine(\"Link to the best film: {0}\", bestFilm)\n\n    End Function\n\n    Async Function GreetAndWaitAsync(token As CancellationToken) As Task\n        Console.WriteLine(\"Hello, world! Waiting for 1 second...\")\n        Await Task.Delay(1000, token)\n    End Function\n\n    Async Function GetBestFilmAsync(token As CancellationToken) As Task(Of String)\n        Await Task.Delay(1000, token)\n        Return \"https://www.imdb.com/title/tt0080684/\"\n    End Function\nEnd Module\n```\n\n----------------------------------------\n\nTITLE: Defining Fallback Strategy Components in Polly\nDESCRIPTION: Classes and interfaces for implementing fallback resilience strategies. Includes argument types for fallback actions, predicates, and configuration options.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_5\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Fallback.FallbackActionArguments<TResult>\nPolly.Fallback.FallbackActionArguments<TResult>.Context.get -> Polly.ResilienceContext!\nPolly.Fallback.FallbackActionArguments<TResult>.FallbackActionArguments() -> void\nPolly.Fallback.FallbackActionArguments<TResult>.FallbackActionArguments(Polly.ResilienceContext! context, Polly.Outcome<TResult> outcome) -> void\nPolly.Fallback.FallbackActionArguments<TResult>.Outcome.get -> Polly.Outcome<TResult>\n\nPolly.Fallback.FallbackPredicateArguments<TResult>\nPolly.Fallback.FallbackPredicateArguments<TResult>.Context.get -> Polly.ResilienceContext!\nPolly.Fallback.FallbackPredicateArguments<TResult>.FallbackPredicateArguments() -> void\nPolly.Fallback.FallbackPredicateArguments<TResult>.FallbackPredicateArguments(Polly.ResilienceContext! context, Polly.Outcome<TResult> outcome) -> void\nPolly.Fallback.FallbackPredicateArguments<TResult>.Outcome.get -> Polly.Outcome<TResult>\n\nPolly.Fallback.FallbackStrategyOptions<TResult>\nPolly.Fallback.FallbackStrategyOptions<TResult>.FallbackAction.get -> System.Func<Polly.Fallback.FallbackActionArguments<TResult>, System.Threading.Tasks.ValueTask<Polly.Outcome<TResult>>>?\nPolly.Fallback.FallbackStrategyOptions<TResult>.FallbackAction.set -> void\nPolly.Fallback.FallbackStrategyOptions<TResult>.FallbackStrategyOptions() -> void\nPolly.Fallback.FallbackStrategyOptions<TResult>.OnFallback.get -> System.Func<Polly.Fallback.OnFallbackArguments<TResult>, System.Threading.Tasks.ValueTask>?\nPolly.Fallback.FallbackStrategyOptions<TResult>.OnFallback.set -> void\nPolly.Fallback.FallbackStrategyOptions<TResult>.ShouldHandle.get -> System.Func<Polly.Fallback.FallbackPredicateArguments<TResult>, System.Threading.Tasks.ValueTask<bool>>!\nPolly.Fallback.FallbackStrategyOptions<TResult>.ShouldHandle.set -> void\n\nPolly.Fallback.OnFallbackArguments<TResult>\nPolly.Fallback.OnFallbackArguments<TResult>.Context.get -> Polly.ResilienceContext!\nPolly.Fallback.OnFallbackArguments<TResult>.OnFallbackArguments() -> void\nPolly.Fallback.OnFallbackArguments<TResult>.OnFallbackArguments(Polly.ResilienceContext! context, Polly.Outcome<TResult> outcome) -> void\nPolly.Fallback.OnFallbackArguments<TResult>.Outcome.get -> Polly.Outcome<TResult>\n```\n\n----------------------------------------\n\nTITLE: Defining TimingStrategyOptions Class in C#\nDESCRIPTION: This code snippet defines the TimingStrategyOptions class, which represents the public configuration options for the Timing resilience strategy. It includes properties for setting the threshold and a callback for when the threshold is exceeded.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/proactive-strategy.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class TimingStrategyOptions : ResilienceStrategyOptions\n{\n    public TimingStrategyOptions()\n    {\n        // Assign a default name to the options for more detailed telemetry insights.\n        Name = \"Timing\";\n    }\n\n    // Apply validation attributes to guarantee the options' validity.\n    // The pipeline will handle validation automatically during its construction.\n    [Range(typeof(TimeSpan), \"00:00:00\", \"1.00:00:00\")]\n    [Required]\n    public TimeSpan? Threshold { get; set; }\n\n    // Provide the delegate to be called when the threshold is surpassed.\n    // Ideally, arguments should share the delegate's name, but with an \"Arguments\" suffix.\n    public Func<OnThresholdExceededArguments, ValueTask>? OnThresholdExceeded { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Using ChaosOutcomeStrategy for Exception-Only Injection\nDESCRIPTION: This demonstrates another anti-pattern where ChaosOutcomeStrategy is used solely for injecting exceptions, which should be avoided in favor of ChaosFaultStrategy.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n    {\n        OutcomeGenerator = new OutcomeGenerator<HttpResponseMessage>()\n            .AddException<HttpRequestException>(),  // ⚠️ Avoid this ⚠️\n    });\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Context in Polly v7\nDESCRIPTION: Demonstrates how to create a Context object in Polly v7, including initialization with operation keys and attaching custom properties both individually and in bulk.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_19\n\nLANGUAGE: cs\nCODE:\n```\n// Create context\nContext context = new Context();\n\n// Create context with operation key\ncontext = new Context(\"my-operation-key\");\n\n// Attach custom properties\ncontext[Key1] = \"value-1\";\ncontext[Key2] = 100;\n\n// Retrieve custom properties\nstring value1 = (string)context[Key1];\nint value2 = (int)context[Key2];\n\n// Bulk attach\ncontext = new Context(\"my-operation-key\", new Dictionary<string, object>\n{\n    { Key1 , \"value-1\" },\n    { Key2 , 100 }\n});\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Wrapping Each Endpoint with a Circuit Breaker\nDESCRIPTION: This code snippet demonstrates an anti-pattern where each endpoint is wrapped with a separate circuit breaker. This approach requires manual management of circuit breakers and explicit calls to ExecuteAsync, making the code more complex and error-prone.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\n// Defined in a common place\nvar uriToCbMappings = new Dictionary<Uri, ResiliencePipeline>\n{\n    [new Uri(\"https://downstream1.com\")] = GetCircuitBreaker(),\n    // ...\n    [new Uri(\"https://downstreamN.com\")] = GetCircuitBreaker()\n};\n\n// Used in the downstream 1 client\nvar downstream1Uri = new Uri(\"https://downstream1.com\");\nawait uriToCbMappings[downstream1Uri].ExecuteAsync(CallXYZOnDownstream1, CancellationToken.None);\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultReportingStrategyOptions in C#\nDESCRIPTION: This snippet defines the ResultReportingStrategyOptions<TResult> class, which configures the strategy. It includes properties for ShouldHandle and OnReportResult delegates, with a default implementation for ShouldHandle.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ResultReportingStrategyOptions<TResult> : ResilienceStrategyOptions\n{\n    public ResultReportingStrategyOptions()\n    {\n        // Assign a default name to the options for more detailed telemetry insights.\n        Name = \"ResultReporting\";\n    }\n\n    // Options for reactive strategies should always include a \"ShouldHandle\" delegate.\n    // Set a sensible default when possible. Here, we handle all exceptions.\n    public Func<ResultReportingPredicateArguments<TResult>, ValueTask<bool>> ShouldHandle { get; set; } = args =>\n    {\n        return new ValueTask<bool>(args.Outcome.Exception is not null);\n    };\n\n    // This illustrates an event delegate. Note that the arguments struct carries the same name as the delegate but with an \"Arguments\" suffix.\n    // The event follows the async convention and must be set by the user.\n    //\n    // The [Required] attribute enforces the consumer to specify this property, used when some properties do not have sensible defaults and are required.\n    [Required]\n    public Func<OnReportResultArguments<TResult>, ValueTask>? OnReportResult { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ResultReportingPredicateArguments in C#\nDESCRIPTION: This snippet defines the ResultReportingPredicateArguments struct used in the ShouldHandle predicate. It contains the ResilienceContext and Outcome properties, which are essential for reactive arguments.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic readonly struct ResultReportingPredicateArguments<TResult>\n{\n    public ResultReportingPredicateArguments(ResilienceContext context, Outcome<TResult> outcome)\n    {\n        Context = context;\n        Outcome = outcome;\n    }\n\n    // Always include the \"Context\" property in the arguments.\n    public ResilienceContext Context { get; }\n\n    // Always have the \"Outcome\" property in reactive arguments.\n    public Outcome<TResult> Outcome { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Arguments Structure for Proactive Strategy in C#\nDESCRIPTION: Example showing how to create an arguments structure for proactive resilience strategies that encapsulates event information and follows the convention of including a Context property.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/index.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Structs for arguments encapsulate details about specific events within the resilience strategy.\n// Relevant properties to the event can be exposed. In this event, the actual execution time and the exceeded threshold are included.\npublic readonly struct OnThresholdExceededArguments\n{\n    public OnThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration)\n    {\n        Context = context;\n        Threshold = threshold;\n        Duration = duration;\n    }\n\n    public TimeSpan Threshold { get; }\n\n    public TimeSpan Duration { get; }\n\n    // As per convention, all arguments should provide a \"Context\" property.\n    public ResilienceContext Context { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RetryStrategyOptions in C#\nDESCRIPTION: Defines the RetryStrategyOptions class with properties for configuring retry behavior, including delay settings, backoff types, and custom handlers.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Retry.RetryStrategyOptions<TResult>\nPolly.Retry.RetryStrategyOptions<TResult>.BackoffType.get -> Polly.DelayBackoffType\nPolly.Retry.RetryStrategyOptions<TResult>.BackoffType.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.Delay.get -> System.TimeSpan\nPolly.Retry.RetryStrategyOptions<TResult>.Delay.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.DelayGenerator.get -> System.Func<Polly.Retry.RetryDelayGeneratorArguments<TResult>, System.Threading.Tasks.ValueTask<System.TimeSpan?>>\nPolly.Retry.RetryStrategyOptions<TResult>.DelayGenerator.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.MaxDelay.get -> System.TimeSpan?\nPolly.Retry.RetryStrategyOptions<TResult>.MaxDelay.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.MaxRetryAttempts.get -> int\nPolly.Retry.RetryStrategyOptions<TResult>.MaxRetryAttempts.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.OnRetry.get -> System.Func<Polly.Retry.OnRetryArguments<TResult>, System.Threading.Tasks.ValueTask>?\nPolly.Retry.RetryStrategyOptions<TResult>.OnRetry.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.Randomizer.get -> System.Func<double>!\nPolly.Retry.RetryStrategyOptions<TResult>.Randomizer.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.RetryStrategyOptions() -> void\nPolly.Retry.RetryStrategyOptions<TResult>.ShouldHandle.get -> System.Func<Polly.Retry.RetryPredicateArguments<TResult>, System.Threading.Tasks.ValueTask<bool>>!\nPolly.Retry.RetryStrategyOptions<TResult>.ShouldHandle.set -> void\nPolly.Retry.RetryStrategyOptions<TResult>.UseJitter.get -> bool\nPolly.Retry.RetryStrategyOptions<TResult>.UseJitter.set -> void\n```\n\n----------------------------------------\n\nTITLE: Working with Policy Registries in Polly v7\nDESCRIPTION: Demonstrates how to create, add, retrieve, and update policies in a PolicyRegistry in Polly v7.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_23\n\nLANGUAGE: cs\nCODE:\n```\n// Create a registry\nvar registry = new PolicyRegistry();\n\n// Add a policy\nregistry.Add(PolicyKey, Policy.Timeout(TimeSpan.FromSeconds(10)));\n\n// Try get a policy\nregistry.TryGet<IAsyncPolicy>(PolicyKey, out IAsyncPolicy? policy);\n\n// Try get a generic policy\nregistry.TryGet<IAsyncPolicy<string>>(PolicyKey, out IAsyncPolicy<string>? genericPolicy);\n\n// Update a policy\nregistry.AddOrUpdate(\n    PolicyKey,\n    Policy.Timeout(TimeSpan.FromSeconds(10)),\n    (key, previous) => Policy.Timeout(TimeSpan.FromSeconds(10)));\n```\n\n----------------------------------------\n\nTITLE: Visualizing Constant Backoff Strategy with Mermaid\nDESCRIPTION: A flowchart illustrating the decision process for the Constant backoff strategy in Polly's retry implementation. It shows how delay is calculated based on jitter, max delay, and delay generator settings.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nstateDiagram-v2\n\n    state if_state_step1 <<choice>>\n    state if_state_step2 <<choice>>\n    state if_state_step3 <<choice>>\n\n    constant: Delay\n    constantWJitter: Delay + Random\n    compare: MaxDelay < BaseDelay\n    setBase: Set BaseDelay\n    setNormalized: Set NormalizedDelay\n    setNext: Set NextDelay\n\n    UseJitter --> if_state_step1\n    if_state_step1 --> constantWJitter:true\n    if_state_step1 --> constant: false\n    constantWJitter --> setBase\n    constant --> setBase\n\n    setBase --> compare\n    compare --> if_state_step2\n    if_state_step2 --> MaxDelay: true\n    if_state_step2 --> BaseDelay: false\n    MaxDelay --> setNormalized\n    BaseDelay --> setNormalized\n\n    setNormalized --> DelayGenerator\n    DelayGenerator --> if_state_step3\n    if_state_step3 --> GeneratedDelay: positive\n    if_state_step3 --> NormalizedDelay: null or negative\n    GeneratedDelay --> setNext\n    NormalizedDelay --> setNext\n    setNext --> [*]\n```\n\n----------------------------------------\n\nTITLE: Implementing ResultReportingResilienceStrategyBuilderExtensions in C#\nDESCRIPTION: This snippet defines extension methods for ResiliencePipelineBuilder<T> and ResiliencePipelineBuilder to add the ResultReportingResilienceStrategy. It includes methods for both generic and non-generic builders.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\npublic static class ResultReportingResilienceStrategyBuilderExtensions\n{\n    // Add extensions for the generic builder.\n    // Extensions should return the builder to support a fluent API.\n    public static ResiliencePipelineBuilder<TResult> AddResultReporting<TResult>(\n        this ResiliencePipelineBuilder<TResult> builder,\n        ResultReportingStrategyOptions<TResult> options)\n    {\n        // Add the strategy through the AddStrategy method. This method accepts a factory delegate\n        // and automatically validates the options.\n        return builder.AddStrategy(\n            context =>\n            {\n                // The \"context\" provides various properties for the strategy's use.\n                // In this case, we simply use the \"Telemetry\" property and pass it to the strategy.\n                // The ShouldHandle and OnReportResult values are sourced from the options.\n                var strategy = new ResultReportingResilienceStrategy<TResult>(\n                    options.ShouldHandle,\n                    options.OnReportResult!,\n                    context.Telemetry);\n\n                return strategy;\n            },\n            options);\n    }\n\n    // Optionally, if suitable for the strategy, add support for non-generic builders.\n    // Observe the use of the non-generic ResultReportingStrategyOptions.\n    public static ResiliencePipelineBuilder AddResultReporting(\n        this ResiliencePipelineBuilder builder,\n        ResultReportingStrategyOptions options)\n    {\n        return builder.AddStrategy(\n            context =>\n            {\n                var strategy = new ResultReportingResilienceStrategy<object>(\n                    options.ShouldHandle,\n                    options.OnReportResult!,\n                    context.Telemetry);\n\n                return strategy;\n            },\n            options);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Event Arguments\nDESCRIPTION: Event argument classes for circuit state changes and predicates.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\npublic class BreakDurationGeneratorArguments\n{\n    public double FailureRate { get; }\n    public int FailureCount { get; }\n    public ResilienceContext Context { get; }\n    public int HalfOpenAttempts { get; }\n}\n\npublic class CircuitBreakerPredicateArguments<TResult>\n{\n    public ResilienceContext Context { get; }\n    public Outcome<TResult> Outcome { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RateLimiterStrategyOptions Class in C#\nDESCRIPTION: This class defines options for configuring rate limiter strategies. It includes properties for default rate limiter options, rejection handling, and custom rate limiter implementation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.RateLimiting/PublicAPI.Shipped.txt#2025-04-18_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nPolly.RateLimiting.RateLimiterStrategyOptions\nPolly.RateLimiting.RateLimiterStrategyOptions.DefaultRateLimiterOptions.get -> System.Threading.RateLimiting.ConcurrencyLimiterOptions!\nPolly.RateLimiting.RateLimiterStrategyOptions.DefaultRateLimiterOptions.set -> void\nPolly.RateLimiting.RateLimiterStrategyOptions.OnRejected.get -> System.Func<Polly.RateLimiting.OnRateLimiterRejectedArguments, System.Threading.Tasks.ValueTask>?\nPolly.RateLimiting.RateLimiterStrategyOptions.OnRejected.set -> void\nPolly.RateLimiting.RateLimiterStrategyOptions.RateLimiter.get -> System.Func<Polly.RateLimiting.RateLimiterArguments, System.Threading.Tasks.ValueTask<System.Threading.RateLimiting.RateLimitLease!>>?\nPolly.RateLimiting.RateLimiterStrategyOptions.RateLimiter.set -> void\nPolly.RateLimiting.RateLimiterStrategyOptions.RateLimiterStrategyOptions() -> void\n```\n\n----------------------------------------\n\nTITLE: Implementing ResiliencePipelineExtensions Methods in C#\nDESCRIPTION: Extension methods for obtaining pipeline descriptors from ResiliencePipeline instances, including generic and non-generic variants.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Testing/PublicAPI.Shipped.txt#2025-04-18_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.Testing.ResiliencePipelineExtensions.GetPipelineDescriptor(this Polly.ResiliencePipeline! pipeline) -> Polly.Testing.ResiliencePipelineDescriptor!\nstatic Polly.Testing.ResiliencePipelineExtensions.GetPipelineDescriptor<TResult>(this Polly.ResiliencePipeline<TResult>! pipeline) -> Polly.Testing.ResiliencePipelineDescriptor!\n```\n\n----------------------------------------\n\nTITLE: Implementing ExecutionRejectedException in Polly\nDESCRIPTION: Exception that is thrown when a resilience policy rejects execution. Provides three constructor overloads for different exception creation scenarios.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nPolly.ExecutionRejectedException\nPolly.ExecutionRejectedException.ExecutionRejectedException() -> void\nPolly.ExecutionRejectedException.ExecutionRejectedException(string! message) -> void\nPolly.ExecutionRejectedException.ExecutionRejectedException(string! message, System.Exception! inner) -> void\n```\n\n----------------------------------------\n\nTITLE: Enabling Configuration Reloads for Resilience Pipelines in C#\nDESCRIPTION: Extension method for enabling configuration reloading for resilience pipelines. This allows pipelines to update their behavior when configuration changes.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_4\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.Registry.ConfigureBuilderContextExtensions.EnableReloads<TKey, TOptions>(this Polly.Registry.ConfigureBuilderContext<TKey>! context, Microsoft.Extensions.Options.IOptionsMonitor<TOptions>! optionsMonitor, string? name = null) -> void\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Extension Methods in C#\nDESCRIPTION: Extension methods for adding circuit breaker functionality to resilience pipelines. Supports both generic and non-generic implementations.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker(this Polly.ResiliencePipelineBuilder! builder, Polly.CircuitBreaker.CircuitBreakerStrategyOptions! options) -> Polly.ResiliencePipelineBuilder!\nstatic Polly.CircuitBreakerResiliencePipelineBuilderExtensions.AddCircuitBreaker<TResult>(this Polly.ResiliencePipelineBuilder<TResult>! builder, Polly.CircuitBreaker.CircuitBreakerStrategyOptions<TResult>! options) -> Polly.ResiliencePipelineBuilder<TResult>!\n```\n\n----------------------------------------\n\nTITLE: Defining OnThresholdExceededArguments Struct in C#\nDESCRIPTION: This code snippet defines the OnThresholdExceededArguments struct, which encapsulates details about specific events within the resilience strategy. It includes properties for the threshold, actual duration, and the resilience context.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/proactive-strategy.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic readonly struct OnThresholdExceededArguments\n{\n    public OnThresholdExceededArguments(ResilienceContext context, TimeSpan threshold, TimeSpan duration)\n    {\n        Context = context;\n        Threshold = threshold;\n        Duration = duration;\n    }\n\n    public TimeSpan Threshold { get; }\n\n    public TimeSpan Duration { get; }\n\n    // As per convention, all arguments should provide a \"Context\" property.\n    public ResilienceContext Context { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Polly.Testing Package with dotnet CLI\nDESCRIPTION: Shows how to add the Polly.Testing package to a test project using the dotnet CLI.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/testing.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Polly.Testing\n```\n\n----------------------------------------\n\nTITLE: Safe Execution with ExecuteAndCapture in Polly v7\nDESCRIPTION: Demonstrates how to use ExecuteAndCapture and ExecuteAndCaptureAsync to safely execute code in Polly v7, including handling results and accessing context data.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_21\n\nLANGUAGE: cs\nCODE:\n```\n// Synchronous execution\nISyncPolicy<int> syncPolicy = Policy.Timeout<int>(TimeSpan.FromSeconds(1));\nPolicyResult<int> policyResult = syncPolicy.ExecuteAndCapture(Method);\n\n// Asynchronous execution\nIAsyncPolicy<int> asyncPolicy = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(1));\nPolicyResult<int> asyncPolicyResult = await asyncPolicy.ExecuteAndCaptureAsync(MethodAsync, CancellationToken.None);\n\n// Assess policy result\nif (policyResult.Outcome == OutcomeType.Successful)\n{\n    int result = policyResult.Result;\n\n    // Process result\n}\nelse\n{\n    Exception exception = policyResult.FinalException;\n    FaultType faultType = policyResult.FaultType!.Value;\n    ExceptionType exceptionType = policyResult.ExceptionType!.Value;\n\n    // Process failure\n}\n\n// Access context\nconst string Key = \"context_key\";\nIAsyncPolicy<int> asyncPolicyWithContext = Policy.TimeoutAsync<int>(TimeSpan.FromSeconds(10),\n    onTimeoutAsync: (ctx, ts, task) =>\n    {\n        ctx[Key] = \"context_value\";\n        return Task.CompletedTask;\n    });\n\nasyncPolicyResult = await asyncPolicyWithContext.ExecuteAndCaptureAsync((ctx, token) => MethodAsync(token), new Context(), CancellationToken.None);\nstring? ctxValue = asyncPolicyResult.Context.GetValueOrDefault(Key) as string;\n```\n\n----------------------------------------\n\nTITLE: Simple Unhappy Path Sequence Diagram\nDESCRIPTION: Mermaid sequence diagram showing circuit breaker operation when failure ratio meets threshold.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    actor C as Caller\n    participant P as Pipeline\n    participant CB as CircuitBreaker\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    Note over CB: Closed state\n    Note over CB, D: Sampling start\n    activate CB\n    CB->>+D: Invokes\n    D->>-CB: Returns result\n    CB->>P: Returns result\n    P->>C: Returns result\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB->>+D: Invokes\n    D->>-CB: Fails\n    Note over CB: Moves to Open state\n    CB->>P: Propagates failure\n    P->>C: Propagates failure\n\n    C->>P: Calls ExecuteAsync\n    P->>CB: Calls ExecuteCore\n    CB-->>CB: Rejects request\n    CB->>P: Throws <br/>BrokenCircuitException\n    P->>C: Propagates exception\n    deactivate CB\n    Note over CB, D: Sampling end\n```\n\n----------------------------------------\n\nTITLE: Implementing ChaosStrategyOptions in C#\nDESCRIPTION: Defines the ChaosStrategyOptions class with properties for configuring chaos engineering strategies, including injection rates and randomization.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Simmy.ChaosStrategyOptions\nPolly.Simmy.ChaosStrategyOptions.ChaosStrategyOptions() -> void\nPolly.Simmy.ChaosStrategyOptions.Enabled.get -> bool\nPolly.Simmy.ChaosStrategyOptions.Enabled.set -> void\nPolly.Simmy.ChaosStrategyOptions.EnabledGenerator.get -> System.Func<Polly.Simmy.EnabledGeneratorArguments, System.Threading.Tasks.ValueTask<bool>>?\nPolly.Simmy.ChaosStrategyOptions.EnabledGenerator.set -> void\nPolly.Simmy.ChaosStrategyOptions.InjectionRate.get -> double\nPolly.Simmy.ChaosStrategyOptions.InjectionRate.set -> void\nPolly.Simmy.ChaosStrategyOptions.InjectionRateGenerator.get -> System.Func<Polly.Simmy.InjectionRateGeneratorArguments, System.Threading.Tasks.ValueTask<double>>?\nPolly.Simmy.ChaosStrategyOptions.InjectionRateGenerator.set -> void\nPolly.Simmy.ChaosStrategyOptions.Randomizer.get -> System.Func<double>!\nPolly.Simmy.ChaosStrategyOptions.Randomizer.set -> void\n```\n\n----------------------------------------\n\nTITLE: Defining Refit API Interface in C#\nDESCRIPTION: This snippet defines an interface for a Refit API client. It specifies a method for making a GET request to a specific endpoint that returns an HttpResponseMessage.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/http-client-integrations.md#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IHttpStatusApi\n{\n    [Get(\"/408\")]\n    Task<HttpResponseMessage> GetRequestTimeoutEndpointAsync();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Polly.Extensions Package via .NET CLI\nDESCRIPTION: This command adds the Polly.Extensions NuGet package to your project, which is required for dependency injection integration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/getting-started.md#2025-04-18_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Polly.Extensions\n```\n\n----------------------------------------\n\nTITLE: Defining ResilienceStrategyDescriptor Class Members in C#\nDESCRIPTION: Properties for ResilienceStrategyDescriptor that provide access to strategy options and instances.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Testing/PublicAPI.Shipped.txt#2025-04-18_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Testing.ResilienceStrategyDescriptor.Options.get -> Polly.ResilienceStrategyOptions?\nPolly.Testing.ResilienceStrategyDescriptor.StrategyInstance.get -> object!\n```\n\n----------------------------------------\n\nTITLE: Hedging Context and Callback Sequence Diagram\nDESCRIPTION: A sequence diagram illustrating the flow of contexts and callbacks in the hedging strategy. It shows how the primary context is cloned, action contexts are created, and contexts are merged after execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    autonumber\n    participant P as Pipeline\n    participant H as Hedging\n    participant AG as ActionGenerator\n    participant OH as OnHedging\n    participant UC as UserCallback\n    participant HUC as HedgedUserCallback\n\n    P->>H: Calls ExecuteCore <br/>with Primary Context\n    H-->>H: Deep clones <br/>Primary Context\n\n    H->>+UC: Invokes <br/>with Action Context\n    UC-->>UC: Processes <br/>+ Modifies Context\n    UC->>-H: Fails\n\n    H-->>H: Deep clones <br/>Primary Context\n    H->>+AG: Invokes <br/>with both Contexts\n    AG-->>AG: Executes callback <br/>+ Modifies Primary <br/> and / or Action Context\n    AG->>-H: Returns factory\n\n    H->>+OH: Invokes <br/>with both Contexts\n    OH-->>OH: Executes callback <br/>+ Modifies Primary <br/> and / or Action Context\n    OH->>-H: Finishes\n\n    H-->>H: Invokes factory\n    H->>+HUC: Invokes <br/>with Action Context\n    HUC-->>HUC: Processes <br/>+ Modifies Context\n    HUC->>-H: Fails\n\n    H-->>H: Merges Action Context <br/>onto Primary Context\n    H->>P: Propagates failure <br/>with Primary Context\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Output\nDESCRIPTION: Performance benchmark results showing execution metrics for a CompositeComponent method. Running on Windows 11 with Intel i7-1280P CPU and .NET 9.0 runtime.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.CompositeComponentBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                         | Mean     | Error    | StdDev   | Allocated |\n|------------------------------- |---------:|---------:|---------:|----------:|\n| CompositeComponent_ExecuteCore | 40.70 ns | 0.574 ns | 0.823 ns |         - |\n```\n\n----------------------------------------\n\nTITLE: Defining Resilience Property Keys for HTTP Requests\nDESCRIPTION: Definition of a static class containing property keys used for storing HTTP request messages in resilience contexts. These keys enable sharing request information between pipeline components.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/hedging.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\ninternal static class ResilienceKeys\n{\n    public static readonly ResiliencePropertyKey<HttpRequestMessage> RequestMessage = new(\"MyFeature.RequestMessage\");\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Polly Extensions Package via .NET CLI\nDESCRIPTION: Shows the command to install the Polly.Extensions NuGet package using the .NET CLI.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Polly.Extensions\n```\n\n----------------------------------------\n\nTITLE: Defining DelayBackoffType Enum in Polly\nDESCRIPTION: Enumeration defining different backoff strategies for delay-based resilience mechanisms. Includes Constant (0), Linear (1), and Exponential (2) backoff types.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_3\n\nLANGUAGE: C#\nCODE:\n```\nPolly.DelayBackoffType.Constant = 0 -> Polly.DelayBackoffType\nPolly.DelayBackoffType.Linear = 1 -> Polly.DelayBackoffType\nPolly.DelayBackoffType.Exponential = 2 -> Polly.DelayBackoffType\n```\n\n----------------------------------------\n\nTITLE: Replacing DateTime.Now with TimeProvider in C#\nDESCRIPTION: Use TimeProvider.GetLocalNow().DateTime instead of System.DateTime.Now to get the current local date and time.\nSOURCE: https://github.com/app-vnext/polly/blob/main/eng/analyzers/BannedSymbols.txt#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nTimeProvider.GetLocalNow().DateTime\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate Limiting in Polly v7\nDESCRIPTION: Shows how to configure rate limiting in Polly v7, including synchronous and asynchronous variants for both generic and non-generic policies.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n// Create sync rate limiter\nISyncPolicy syncPolicy = Policy.RateLimit(\n    numberOfExecutions: 100,\n    perTimeSpan: TimeSpan.FromMinutes(1));\n\n// Create async rate limiter\nIAsyncPolicy asyncPolicy = Policy.RateLimitAsync(\n    numberOfExecutions: 100,\n    perTimeSpan: TimeSpan.FromMinutes(1));\n\n// Create generic sync rate limiter\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy.RateLimit<HttpResponseMessage>(\n    numberOfExecutions: 100,\n    perTimeSpan: TimeSpan.FromMinutes(1));\n\n// Create generic async rate limiter\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy.RateLimitAsync<HttpResponseMessage>(\n    numberOfExecutions: 100,\n    perTimeSpan: TimeSpan.FromMinutes(1));\n```\n\n----------------------------------------\n\nTITLE: Defining OnReportResultArguments in C#\nDESCRIPTION: This code defines the OnReportResultArguments struct used for reporting outcomes. It includes the Context and Outcome properties, which are standard for reactive arguments.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/reactive-strategy.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic readonly struct OnReportResultArguments<TResult>\n{\n    public OnReportResultArguments(ResilienceContext context, Outcome<TResult> outcome)\n    {\n        Context = context;\n        Outcome = outcome;\n    }\n\n    // Always include the \"Context\" property in the arguments.\n    public ResilienceContext Context { get; }\n\n    // Always have the \"Outcome\" property in reactive arguments.\n    public Outcome<TResult> Outcome { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Polly Core Package via .NET CLI\nDESCRIPTION: Shows the command to install the Polly.Core NuGet package using the .NET CLI.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Polly.Core\n```\n\n----------------------------------------\n\nTITLE: Defining RateLimiterRejectedException Class in C#\nDESCRIPTION: This class represents an exception thrown when a rate limiter rejects a request. It includes constructors for various scenarios and a property for retry duration.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.RateLimiting/PublicAPI.Shipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nPolly.RateLimiting.RateLimiterRejectedException\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException() -> void\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException(string! message) -> void\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException(string! message, System.Exception! inner) -> void\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException(string! message, System.TimeSpan retryAfter) -> void\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException(string! message, System.TimeSpan retryAfter, System.Exception! inner) -> void\nPolly.RateLimiting.RateLimiterRejectedException.RateLimiterRejectedException(System.TimeSpan retryAfter) -> void\nPolly.RateLimiting.RateLimiterRejectedException.RetryAfter.get -> System.TimeSpan?\n```\n\n----------------------------------------\n\nTITLE: Replacing DateTime.Today with TimeProvider in C#\nDESCRIPTION: Use TimeProvider.GetLocalNow().DateTime.Date instead of System.DateTime.Today to get the current local date.\nSOURCE: https://github.com/app-vnext/polly/blob/main/eng/analyzers/BannedSymbols.txt#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nTimeProvider.GetLocalNow().DateTime.Date\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results for Polly Operations in Markdown\nDESCRIPTION: This code snippet shows the benchmark results for two Polly operations: NoOpAsync and NullResiliencePipeline. It includes metrics such as mean execution time, error margin, standard deviation, ratio comparisons, memory allocation, and generation 0 garbage collection.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.BridgeBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n```\n| Method                 | Mean      | Error    | StdDev    | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|----------------------- |----------:|---------:|----------:|------:|--------:|-------:|----------:|------------:|\n| NoOpAsync              |  84.05 ns | 4.660 ns |  6.830 ns |  1.01 |    0.11 | 0.0242 |     304 B |        1.00 |\n| NullResiliencePipeline | 241.69 ns | 8.178 ns | 12.240 ns |  2.89 |    0.27 | 0.0296 |     376 B |        1.24 |\n```\n\n----------------------------------------\n\nTITLE: Defining ResiliencePipelineDescriptor Class Members in C#\nDESCRIPTION: Class members and properties for ResiliencePipelineDescriptor that provide access to resilience strategy information and pipeline configuration details.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Testing/PublicAPI.Shipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Testing.ResiliencePipelineDescriptor.FirstStrategy.get -> Polly.Testing.ResilienceStrategyDescriptor!\nPolly.Testing.ResiliencePipelineDescriptor.IsReloadable.get -> bool\nPolly.Testing.ResiliencePipelineDescriptor.Strategies.get -> System.Collections.Generic.IReadOnlyList<Polly.Testing.ResilienceStrategyDescriptor!>!\n```\n\n----------------------------------------\n\nTITLE: Defining ResilienceProperties Class in C#\nDESCRIPTION: Defines the ResilienceProperties class with methods for getting and setting resilience property values. It includes generic methods for handling different value types.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nPolly.ResilienceProperties\nPolly.ResilienceProperties.GetValue<TValue>(Polly.ResiliencePropertyKey<TValue> key, TValue defaultValue) -> TValue\nPolly.ResilienceProperties.ResilienceProperties() -> void\nPolly.ResilienceProperties.Set<TValue>(Polly.ResiliencePropertyKey<TValue> key, TValue value) -> void\nPolly.ResilienceProperties.TryGetValue<TValue>(Polly.ResiliencePropertyKey<TValue> key, out TValue value) -> bool\n```\n\n----------------------------------------\n\nTITLE: Retrieving Descriptor for Generic ResiliencePipeline\nDESCRIPTION: Shows how to obtain a descriptor for a generic ResiliencePipeline<T> to examine its composition.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/testing.md#2025-04-18_snippet_2\n\nLANGUAGE: cs\nCODE:\n```\n// Construct your resilience pipeline.\nResiliencePipeline<string> pipeline = new ResiliencePipelineBuilder<string>()\n    .AddRetry(new RetryStrategyOptions<string>\n    {\n        MaxRetryAttempts = 4\n    })\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\n// Obtain the descriptor.\nResiliencePipelineDescriptor descriptor = pipeline.GetPipelineDescriptor();\n\n// Check the pipeline's composition with the descriptor.\n// ...\n```\n\n----------------------------------------\n\nTITLE: Anti-pattern: Nesting ExecuteAsync Calls in C#\nDESCRIPTION: An example of incorrectly nesting ExecuteAsync calls, which creates a 'pyramid of doom' and increases the risk of incorrectly referencing CancellationToken parameters.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/fallback.md#2025-04-18_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar result = await fallback.ExecuteAsync(async (CancellationToken outerCT) =>\n{\n    return await timeout.ExecuteAsync(static async (CancellationToken innerCT) =>\n    {\n        return await CallExternalSystem(innerCT);\n    }, outerCT);\n}, CancellationToken.None);\n\nreturn result;\n```\n\n----------------------------------------\n\nTITLE: Displaying Markdown Links in Contributing Guidelines\nDESCRIPTION: This snippet shows the markdown syntax for creating links to the Slack channel in the contributing guidelines document.\nSOURCE: https://github.com/app-vnext/polly/blob/main/CONTRIBUTING.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n[slack]: https://pollytalk.slack.com\n```\n\n----------------------------------------\n\nTITLE: Implementing PipelineNameComparer in C#\nDESCRIPTION: This snippet defines a PipelineNameComparer class that implements IEqualityComparer<MyPipelineKey>. It compares pipeline keys based on their PipelineName property.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class PipelineNameComparer : IEqualityComparer<MyPipelineKey>\n{\n    public bool Equals(MyPipelineKey x, MyPipelineKey y) => x.PipelineName == y.PipelineName;\n\n    public int GetHashCode(MyPipelineKey obj) => obj.PipelineName.GetHashCode(StringComparison.Ordinal);\n}\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for Resilience Strategy Execution Methods\nDESCRIPTION: Performance benchmark results showing execution times for different resilience strategy methods. The results compare synchronous and asynchronous execution patterns with various parameter combinations, indicating ExecuteOutcomeAsync as the fastest method.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.ResiliencePipelineBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                                         | Mean     | Error    | StdDev   | Ratio | RatioSD | Allocated | Alloc Ratio |\n|----------------------------------------------- |---------:|---------:|---------:|------:|--------:|----------:|------------:|\n| ExecuteOutcomeAsync                            | 45.69 ns | 0.443 ns | 0.635 ns |  1.00 |    0.02 |         - |          NA |\n| ExecuteAsync_ResilienceContextAndState         | 80.17 ns | 0.672 ns | 1.006 ns |  1.76 |    0.03 |         - |          NA |\n| ExecuteAsync_CancellationToken                 | 84.26 ns | 0.285 ns | 0.381 ns |  1.84 |    0.03 |         - |          NA |\n| ExecuteAsync_GenericStrategy_CancellationToken | 87.55 ns | 3.675 ns | 5.030 ns |  1.92 |    0.11 |         - |          NA |\n| Execute_ResilienceContextAndState              | 59.59 ns | 0.610 ns | 0.894 ns |  1.30 |    0.03 |         - |          NA |\n| Execute_CancellationToken                      | 66.67 ns | 0.542 ns | 0.794 ns |  1.46 |    0.03 |         - |          NA |\n| Execute_GenericStrategy_CancellationToken      | 67.05 ns | 0.632 ns | 0.906 ns |  1.47 |    0.03 |         - |          NA |\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Using ChaosOutcomeStrategy to Inject Exceptions\nDESCRIPTION: This demonstrates an anti-pattern where exceptions are injected using ChaosOutcomeStrategy, which can cause telemetry issues and lack of separate control for faults versus outcomes.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/outcome.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder<HttpResponseMessage>()\n    .AddChaosOutcome(new ChaosOutcomeStrategyOptions<HttpResponseMessage>\n    {\n        InjectionRate = 0.5, // Same injection rate for both fault and outcome\n        OutcomeGenerator = static args =>\n        {\n            Outcome<HttpResponseMessage>? outcome = Random.Shared.Next(350) switch\n            {\n                < 100 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.InternalServerError)),\n                < 150 => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.TooManyRequests)),\n                < 250 => Outcome.FromResult(new HttpResponseMessage(CreateResultFromContext(args.Context))),\n                < 350 => Outcome.FromException<HttpResponseMessage>(new HttpRequestException(\"Chaos request exception.\")), // ⚠️ Avoid this ⚠️\n                _ => Outcome.FromResult(new HttpResponseMessage(HttpStatusCode.OK))\n            };\n\n            return ValueTask.FromResult(outcome);\n        },\n        OnOutcomeInjected = static args =>\n        {\n            // You might have to put some logic here to determine what kind of output was injected. 😕\n            if (args.Outcome.Exception != null)\n            {\n                Console.WriteLine($\"OnBehaviorInjected, Exception: {args.Outcome.Exception.Message}, Operation: {args.Context.OperationKey}.\");\n            }\n            else\n            {\n                Console.WriteLine($\"OnBehaviorInjected, Outcome: {args.Outcome.Result}, Operation: {args.Context.OperationKey}.\");\n            }\n\n            return default;\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Performance Benchmark Results in BenchmarkDotNet\nDESCRIPTION: Benchmark results comparing ExecuteCircuitBreaker_V7 and ExecuteCircuitBreaker_V8 showing execution time, error margins, standard deviation, performance ratios, and memory allocation. The v7 implementation is faster but allocates memory, while v8 is slower but has no allocations.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.CircuitBreakerBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                   | Mean     | Error   | StdDev  | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|------------------------- |---------:|--------:|--------:|------:|--------:|-------:|----------:|------------:|\n| ExecuteCircuitBreaker_V7 | 207.1 ns | 3.68 ns | 5.50 ns |  1.00 |    0.04 | 0.0370 |     464 B |        1.00 |\n| ExecuteCircuitBreaker_V8 | 335.3 ns | 6.30 ns | 9.43 ns |  1.62 |    0.06 |      - |         - |        0.00 |\n```\n\n----------------------------------------\n\nTITLE: Installing Polly.Extensions Package\nDESCRIPTION: Command to add the Polly.Extensions NuGet package to your project, which enables the dependency injection features.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/dependency-injection.md#2025-04-18_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet add package Polly.Extensions\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for Polly ExecutePipeline Performance Comparison\nDESCRIPTION: Benchmark results showing the performance comparison between ExecutePipeline_V7 and ExecutePipeline_V8 with varying component counts. V8 shows significant improvements in performance and memory allocation, with up to 51% faster execution for 5 components and no memory allocation compared to V7.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.PipelineBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method             | Components | Mean      | Error    | StdDev    | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|------------------- |----------- |----------:|---------:|----------:|------:|--------:|-------:|----------:|------------:|\n| **ExecutePipeline_V7** | **1**          |  **69.79 ns** | **0.588 ns** |  **0.880 ns** |  **1.00** |    **0.02** | **0.0242** |     **304 B** |        **1.00** |\n| ExecutePipeline_V8 | 1          |  69.75 ns | 0.290 ns |  0.406 ns |  1.00 |    0.01 |      - |         - |        0.00 |\n|                    |            |           |          |           |       |         |        |           |             |\n| **ExecutePipeline_V7** | **2**          | **151.17 ns** | **1.092 ns** |  **1.566 ns** |  **1.00** |    **0.01** | **0.0439** |     **552 B** |        **1.00** |\n| ExecutePipeline_V8 | 2          |  99.85 ns | 0.617 ns |  0.884 ns |  0.66 |    0.01 |      - |         - |        0.00 |\n|                    |            |           |          |           |       |         |        |           |             |\n| **ExecutePipeline_V7** | **5**          | **409.27 ns** | **3.791 ns** |  **5.314 ns** |  **1.00** |    **0.02** | **0.1030** |    **1296 B** |        **1.00** |\n| ExecutePipeline_V8 | 5          | 208.08 ns | 0.874 ns |  1.280 ns |  0.51 |    0.01 |      - |         - |        0.00 |\n|                    |            |           |          |           |       |         |        |           |             |\n| **ExecutePipeline_V7** | **10**         | **822.12 ns** | **6.901 ns** | **10.115 ns** |  **1.00** |    **0.02** | **0.2012** |    **2536 B** |        **1.00** |\n| ExecutePipeline_V8 | 10         | 399.00 ns | 1.668 ns |  2.393 ns |  0.49 |    0.01 |      - |         - |        0.00 |\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Polly Strategy Pipeline Execution with BenchmarkDotNet\nDESCRIPTION: This benchmark compares execution performance and memory allocation between Polly v7 and v8 strategy pipeline implementations. Version 8 shows significant memory allocation improvements (40B vs 2744B) with varying execution times for different strategy types including generic, non-generic, and telemetry-enabled variants.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.MultipleStrategiesBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                                         | Mean     | Error     | StdDev    | Median   | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|----------------------------------------------- |---------:|----------:|----------:|---------:|------:|--------:|-------:|----------:|------------:|\n| ExecuteStrategyPipeline_Generic_V7             | 1.180 μs | 0.0082 μs | 0.0122 μs | 1.179 μs |  1.00 |    0.01 | 0.2174 |    2744 B |        1.00 |\n| ExecuteStrategyPipeline_Generic_V8             | 1.082 μs | 0.0128 μs | 0.0180 μs | 1.078 μs |  0.92 |    0.02 | 0.0019 |      40 B |        0.01 |\n| ExecuteStrategyPipeline_GenericTelemetry_V8    | 1.566 μs | 0.0178 μs | 0.0255 μs | 1.552 μs |  1.33 |    0.03 | 0.0019 |      40 B |        0.01 |\n| ExecuteStrategyPipeline_NonGeneric_V8          | 1.150 μs | 0.0052 μs | 0.0075 μs | 1.148 μs |  0.97 |    0.01 | 0.0019 |      40 B |        0.01 |\n| ExecuteStrategyPipeline_NonGenericTelemetry_V8 | 1.672 μs | 0.0075 μs | 0.0110 μs | 1.672 μs |  1.42 |    0.02 | 0.0019 |      40 B |        0.01 |\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Injecting Delay with Behavior Chaos in C#\nDESCRIPTION: Demonstrates an anti-pattern where a behavior strategy is incorrectly used to inject delays. This approach is not recommended.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/chaos/behavior.md#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddChaosBehavior(new ChaosBehaviorStrategyOptions\n    {\n        BehaviorGenerator = static async args =>\n        {\n            await Task.Delay(TimeSpan.FromSeconds(7), args.Context.CancellationToken);\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Output\nDESCRIPTION: Raw benchmark output comparing ExecuteRetry performance between Polly v7 and v8. Shows that v8 is about 43% slower but eliminates memory allocations compared to v7. Run on .NET 9.0 with Intel i7-1280P CPU.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.RetryBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for Polly Fallback Implementation\nDESCRIPTION: Performance benchmark results showing that Fallback_V7 performs significantly better than Fallback_V8, with lower execution time (63.30ns vs 2,689.59ns) and memory allocation (384B vs 5136B). Test ran on Windows 11 with Intel i7-1280P using .NET 9.0.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.CreationBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method      | Mean        | Error     | StdDev    | Gen0   | Allocated |\n|------------ |------------:|----------:|----------:|-------:|----------:|\n| Fallback_V7 |    63.30 ns |  1.058 ns |  1.583 ns | 0.0305 |     384 B |\n| Fallback_V8 | 2,689.59 ns | 34.384 ns | 50.400 ns | 0.4082 |    5136 B |\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results for Polly ExecuteAsync Methods\nDESCRIPTION: This code snippet shows the benchmark results for ExecuteAsync_Generic and ExecuteAsync_NonGeneric methods. It includes details about the test environment, benchmark parameters, and performance metrics such as mean execution time, error, standard deviation, and memory allocation.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.GenericOverheadBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n```\n| Method                  | Mean     | Error    | StdDev   | Ratio | RatioSD | Allocated | Alloc Ratio |\n|------------------------ |---------:|---------:|---------:|------:|--------:|----------:|------------:|\n| ExecuteAsync_Generic    | 14.67 ns | 0.266 ns | 0.390 ns |  1.00 |    0.04 |         - |          NA |\n| ExecuteAsync_NonGeneric | 24.89 ns | 0.581 ns | 0.870 ns |  1.70 |    0.07 |         - |          NA |\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Performance Results Table for Polly Pipeline Retrieval Methods\nDESCRIPTION: A markdown table showing benchmark results comparing GetPipeline_Ok and GetPipeline_Generic_Ok methods. The non-generic version executes in about 11.51 ns while the generic version takes approximately 43.64 ns, making the non-generic version about 3.8 times faster. Neither method allocates memory during execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.ResiliencePipelineProviderBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Method                 | Mean     | Error    | StdDev   | Allocated |\n|----------------------- |---------:|---------:|---------:|----------:|\n| GetPipeline_Ok         | 11.51 ns | 0.046 ns | 0.068 ns |         - |\n| GetPipeline_Generic_Ok | 43.64 ns | 0.146 ns | 0.214 ns |         - |\n```\n\n----------------------------------------\n\nTITLE: Incorrect Usage of Cancellation Token in Resilience Pipeline with Timeout\nDESCRIPTION: This example shows the incorrect pattern where the callback ignores the innerToken passed from the pipeline and instead uses outerToken. This prevents the timeout strategy from properly cancelling the operation after the specified timeout period.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/timeout.md#2025-04-18_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvar pipeline = new ResiliencePipelineBuilder()\n    .AddTimeout(TimeSpan.FromSeconds(1))\n    .Build();\n\nawait pipeline.ExecuteAsync(\n    async innerToken => await Task.Delay(TimeSpan.FromSeconds(3), outerToken), // The delay call should use innerToken\n    outerToken);\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results for DelegatingComponent ExecuteCore Performance\nDESCRIPTION: Benchmark results comparing JIT and AOT execution modes of DelegatingComponent's ExecuteCore method, showing execution time, error margins, and memory allocation metrics. The AOT version is approximately 1.49x slower and allocates 24 bytes while the JIT version allocates no memory.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.DelegatingComponentBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                              | Mean     | Error    | StdDev   | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|------------------------------------ |---------:|---------:|---------:|------:|--------:|-------:|----------:|------------:|\n| DelegatingComponent_ExecuteCore_Jit | 29.17 ns | 0.613 ns | 0.899 ns |  1.00 |    0.04 |      - |         - |          NA |\n| DelegatingComponent_ExecuteCore_Aot | 43.48 ns | 0.584 ns | 0.873 ns |  1.49 |    0.05 | 0.0019 |      24 B |          NA |\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Table for Predicate Implementation Comparison\nDESCRIPTION: Benchmark results comparing Predicate_SwitchExpression versus Predicate_PredicateBuilder methods. The SwitchExpression approach executes in nearly half the time (11.82 ns) compared to the PredicateBuilder approach (21.52 ns), with neither method having memory allocations.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.PredicateBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                     | Mean     | Error    | StdDev   | Median   | Ratio | RatioSD | Allocated | Alloc Ratio |\n|--------------------------- |---------:|---------:|---------:|---------:|------:|--------:|----------:|------------:|\n| Predicate_SwitchExpression | 11.82 ns | 0.234 ns | 0.343 ns | 12.08 ns |  1.00 |    0.04 |         - |          NA |\n| Predicate_PredicateBuilder | 21.52 ns | 0.077 ns | 0.108 ns | 21.51 ns |  1.82 |    0.05 |         - |          NA |\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types for AWS Polly Project\nDESCRIPTION: This directive enables nullable reference types, a C# feature that helps prevent null reference exceptions by making nullability part of the type system. When enabled, reference types like string are non-nullable by default.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Testing/PublicAPI.Unshipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: BenchmarkDotNet Results Output\nDESCRIPTION: Benchmark results showing performance metrics for two rate limiter implementations. Tests were run on Windows 11 with Intel i7-1280P CPU using .NET 9.0 runtime. Comparison shows execution time, error margins, and memory allocation differences between V7 and V8 implementations.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.RateLimiterBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n| Method                | Mean     | Error   | StdDev  | Ratio | Gen0   | Allocated | Alloc Ratio |\n|---------------------- |---------:|--------:|--------:|------:|-------:|----------:|------------:|\n| ExecuteRateLimiter_V7 | 178.3 ns | 0.79 ns | 1.16 ns |  1.00 | 0.0298 |     376 B |        1.00 |\n| ExecuteRateLimiter_V8 | 188.2 ns | 0.89 ns | 1.34 ns |  1.06 | 0.0031 |      40 B |        0.11 |\n```\n\n----------------------------------------\n\nTITLE: Circuit Breaker Core Classes\nDESCRIPTION: Core class definitions for circuit breaker implementation, including state enums and exception classes.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic enum CircuitState\n{\n    Closed = 0,\n    Open = 1,\n    HalfOpen = 2,\n    Isolated = 3\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying BenchmarkDotNet Configuration and System Information\nDESCRIPTION: This code block shows the configuration of BenchmarkDotNet and the system specifications on which the benchmark was run. It includes details about the .NET version, CPU, and benchmark parameters.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.TelemetryBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n```\n\n----------------------------------------\n\nTITLE: ResilienceContext Class Definition in C#\nDESCRIPTION: The sealed ResilienceContext class that contains contextual information for resilience operations. It includes properties for operation identification, cancellation token, continuation context behavior, and custom properties collection.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/README.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic sealed class ResilienceContext\n{\n    public string? OperationKey { get; }\n    public CancellationToken CancellationToken { get; }\n    public bool ContinueOnCapturedContext { get; }\n    public ResilienceProperties Properties { get; }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Polly Chaos Engineering Example\nDESCRIPTION: Instructions for running and testing the Polly chaos engineering example application. It involves using the dotnet CLI to run the app and accessing the root endpoint to observe chaos injection and mitigation in the console logs.\nSOURCE: https://github.com/app-vnext/polly/blob/main/samples/Chaos/README.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Run the app using the `dotnet run` command.\n- Access the root endpoint `https://localhost:62683` and refresh it multiple times.\n- Observe the logs in out console window. You should see chaos injection and also mitigation of chaos by resilience strategies.\n```\n\n----------------------------------------\n\nTITLE: Displaying Benchmark Results for ExecuteAsync Methods using BenchmarkDotNet\nDESCRIPTION: This code snippet shows the output of a BenchmarkDotNet performance test comparing different versions of ExecuteAsync methods. It includes system information, test parameters, and a table of results showing mean execution time, error margins, standard deviation, ratios, and memory allocation metrics.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/BenchmarkDotNet.Artifacts/results/Polly.Core.Benchmarks.CircuitBreakerOpenedBenchmark-report-github.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n\nBenchmarkDotNet v0.14.0, Windows 11 (10.0.22631.4602/23H2/2023Update/SunValley3)\n12th Gen Intel Core i7-1280P, 1 CPU, 20 logical and 14 physical cores\n.NET SDK 9.0.101\n  [Host] : .NET 9.0.0 (9.0.24.52809), X64 RyuJIT AVX2\n\nJob=MediumRun  Toolchain=InProcessEmitToolchain  IterationCount=15  \nLaunchCount=2  WarmupCount=10  \n\n```\n| Method                    | Mean        | Error     | StdDev    | Ratio | RatioSD | Gen0   | Allocated | Alloc Ratio |\n|-------------------------- |------------:|----------:|----------:|------:|--------:|-------:|----------:|------------:|\n| ExecuteAsync_Exception_V7 | 14,295.0 ns | 418.44 ns | 600.11 ns | 27.37 |    1.33 | 0.1526 |    2056 B |       10.28 |\n| ExecuteAsync_Exception_V8 |  9,178.8 ns | 114.83 ns | 171.88 ns | 17.57 |    0.55 | 0.0916 |    1312 B |        6.56 |\n| ExecuteAsync_Outcome_V8   |    522.6 ns |   9.15 ns |  13.70 ns |  1.00 |    0.04 | 0.0153 |     200 B |        1.00 |\n```\n\n----------------------------------------\n\nTITLE: Installing Polly.Core Package via .NET CLI\nDESCRIPTION: This command adds the Polly.Core NuGet package to your project, which is required to use Polly's core functionality.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/getting-started.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Polly.Core\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Entry for Version 8.0.0-beta.1\nDESCRIPTION: Details of changes included in the 8.0.0-beta.1 release, including API finalization and pipeline disposal improvements.\nSOURCE: https://github.com/app-vnext/polly/blob/main/CHANGELOG.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 8.0.0-beta.1\n\n* Updates for alpha.9\n* Finalize the API review\n* Disposing pipeline should not dispose external inner pipeline\n* Clean duplications around disposing the pipelines\n```\n\n----------------------------------------\n\nTITLE: Implementing Outcome<TResult> in Polly\nDESCRIPTION: A class representing the outcome of a resilience operation, which can be either a successful result or an exception. Provides methods to access the result or exception and to throw the exception if present.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Shipped.txt#2025-04-18_snippet_7\n\nLANGUAGE: C#\nCODE:\n```\nPolly.Outcome\nPolly.Outcome<TResult>\nPolly.Outcome<TResult>.Exception.get -> System.Exception?\nPolly.Outcome<TResult>.Outcome() -> void\nPolly.Outcome<TResult>.Result.get -> TResult?\nPolly.Outcome<TResult>.ThrowIfException() -> void\n```\n\n----------------------------------------\n\nTITLE: Markdown Project Structure Documentation\nDESCRIPTION: Markdown documentation outlining the structure and contents of the Polly samples repository, including descriptions of each major component and section.\nSOURCE: https://github.com/app-vnext/polly/blob/main/samples/README.md#2025-04-18_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Polly Samples\n\nThis repository contains a solution with basic examples demonstrating the creation and utilization of Polly strategies.\n\n- [`Intro`](./Intro) - This section serves as an introduction to Polly. It demonstrates how to use `ResiliencePipelineBuilder` to create a `ResiliencePipeline`, which can be used to execute various user-provided callbacks.\n- [`GenericPipelines`](./GenericPipelines) - This example showcases how to use `ResiliencePipelineBuilder<T>` to create a generic `ResiliencePipeline<T>`.\n- [`Retries`](./Retries) - This part explains how to configure a retry resilience strategy.\n- [`Extensibility`](./Extensibility) - In this part, you can learn how Polly can be extended with custom resilience strategies.\n- [`DependencyInjection`](./DependencyInjection) - This section demonstrates the integration of Polly with `IServiceCollection`.\n- [`Chaos`](./Chaos) - Simple web application that communicates with an external service using HTTP client. It uses chaos strategies to inject chaos into HTTP client calls.\n```\n\n----------------------------------------\n\nTITLE: Running Polly Benchmarks with PowerShell\nDESCRIPTION: Commands for running benchmarks for the Polly project. The script allows running all benchmarks or selecting specific ones through an interactive mode. Benchmark results are stored in the BenchmarkDotNet.Artifacts/results folder.\nSOURCE: https://github.com/app-vnext/polly/blob/main/bench/README.md#2025-04-18_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n# Run all benchmarks\n./benchmarks.ps1\n\n# Pick benchmarks to run\n./benchmarks.ps1 -Interactive\n```\n\n----------------------------------------\n\nTITLE: Installing Polly Extensions Package\nDESCRIPTION: Command to add the Polly.Extensions package to enable telemetry functionality.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/advanced/telemetry.md#2025-04-18_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndotnet add package Polly.Extensions\n```\n\n----------------------------------------\n\nTITLE: Updating Documentation Snippets with MarkdownSnippets in PowerShell\nDESCRIPTION: Command to run in the root directory to update code snippets in documentation files using MarkdownSnippets tool.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Snippets/README.md#2025-04-18_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet mdsnippets\n```\n\n----------------------------------------\n\nTITLE: Defining RateLimiterResiliencePipelineBuilderExtensions Class in C#\nDESCRIPTION: This static class provides extension methods for adding concurrency limiters and rate limiters to resilience pipeline builders. It includes methods for different configuration options.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.RateLimiting/PublicAPI.Shipped.txt#2025-04-18_snippet_2\n\nLANGUAGE: C#\nCODE:\n```\nstatic Polly.RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(this TBuilder! builder, int permitLimit, int queueLimit = 0) -> TBuilder!\nstatic Polly.RateLimiterResiliencePipelineBuilderExtensions.AddConcurrencyLimiter<TBuilder>(this TBuilder! builder, System.Threading.RateLimiting.ConcurrencyLimiterOptions! options) -> TBuilder!\nstatic Polly.RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(this TBuilder! builder, Polly.RateLimiting.RateLimiterStrategyOptions! options) -> TBuilder!\nstatic Polly.RateLimiterResiliencePipelineBuilderExtensions.AddRateLimiter<TBuilder>(this TBuilder! builder, System.Threading.RateLimiting.RateLimiter! limiter) -> TBuilder!\n```\n\n----------------------------------------\n\nTITLE: Defining MeteringEnricher Abstract Method in C#\nDESCRIPTION: Abstract method definition for enriching telemetry data in Polly's telemetry system. This method allows custom enrichment of telemetry events with additional metadata.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Shipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nabstract Polly.Telemetry.MeteringEnricher.Enrich<TResult, TArgs>(in Polly.Telemetry.EnrichmentContext<TResult, TArgs> context) -> void\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Circuit-Aware Retry with Closure\nDESCRIPTION: This code snippet demonstrates an anti-pattern where the retry strategy's delay generator uses a closure to access the circuit breaker's state. This approach couples the strategies and makes the code more fragile and harder to maintain.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/circuit-breaker.md#2025-04-18_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nvar stateProvider = new CircuitBreakerStateProvider();\nvar circuitBreaker = new ResiliencePipelineBuilder()\n    .AddCircuitBreaker(new()\n    {\n        ShouldHandle = new PredicateBuilder().Handle<HttpRequestException>(),\n        BreakDuration = TimeSpan.FromSeconds(5),\n        StateProvider = stateProvider\n    })\n    .Build();\n\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        ShouldHandle = new PredicateBuilder()\n            .Handle<HttpRequestException>()\n            .Handle<BrokenCircuitException>(),\n        DelayGenerator = args =>\n        {\n            TimeSpan? delay = TimeSpan.FromSeconds(1);\n            if (stateProvider.CircuitState == CircuitState.Open)\n            {\n                delay = TimeSpan.FromSeconds(5);\n            }\n\n            return ValueTask.FromResult(delay);\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Replacing DateTimeOffset.Today with TimeProvider in C#\nDESCRIPTION: Use TimeProvider.GetLocalNow().Date instead of System.DateTimeOffset.Today to get the current local date with offset.\nSOURCE: https://github.com/app-vnext/polly/blob/main/eng/analyzers/BannedSymbols.txt#2025-04-18_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nTimeProvider.GetLocalNow().Date\n```\n\n----------------------------------------\n\nTITLE: Creating Code Snippets for Polly Documentation in C#\nDESCRIPTION: Example of how to define a code snippet region in a C# file for use in Polly documentation. The snippet is enclosed between #region and #endregion tags with a descriptive name.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Snippets/README.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic static void MySnippet()\n{\n    #region my-snippet\n\n    // Your code here\n\n    #endregion\n}\n```\n\n----------------------------------------\n\nTITLE: Anti-Pattern: Cancelling Retry Using OnRetry Delegate\nDESCRIPTION: Demonstrates an incorrect approach where retry cancellation logic is embedded within the OnRetry delegate. This pattern adds unnecessary complexity by handling TimeoutException through cancellation tokens.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nvar ctsKey = new ResiliencePropertyKey<CancellationTokenSource>(\"cts\");\nvar retry = new ResiliencePipelineBuilder()\n    .AddRetry(new()\n    {\n        OnRetry = async args =>\n        {\n            if (args.Outcome.Exception is TimeoutException)\n            {\n                if (args.Context.Properties.TryGetValue(ctsKey, out var cts))\n                {\n                    await cts.CancelAsync();\n                }\n            }\n        }\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Checking out the main branch\nDESCRIPTION: Command to switch to the main branch of the repository.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\n```\n\n----------------------------------------\n\nTITLE: Replacing DateTimeOffset.Now with TimeProvider in C#\nDESCRIPTION: Use TimeProvider.GetLocalNow() instead of System.DateTimeOffset.Now to get the current local date and time with offset.\nSOURCE: https://github.com/app-vnext/polly/blob/main/eng/analyzers/BannedSymbols.txt#2025-04-18_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nTimeProvider.GetLocalNow()\n```\n\n----------------------------------------\n\nTITLE: Pushing branch to GitHub\nDESCRIPTION: Command to push the local feature branch to the remote repository on GitHub.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit push origin my-branch\n```\n\n----------------------------------------\n\nTITLE: Configuring upstream remote for Polly repository\nDESCRIPTION: Command to add the original Polly repository as an upstream remote to track changes from the main project.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit remote add upstream https://github.com/App-vNext/Polly.git\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C# Project\nDESCRIPTION: This directive enables C# nullable reference type annotations, allowing for better null-safety checking during compilation. When enabled, reference types are non-nullable by default and require explicit annotation to be nullable.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Core/PublicAPI.Unshipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Enabling Nullable Reference Types in C#\nDESCRIPTION: This directive enables nullable reference types for the entire file, improving null-safety in the codebase.\nSOURCE: https://github.com/app-vnext/polly/blob/main/src/Polly.Extensions/PublicAPI.Unshipped.txt#2025-04-18_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\n#nullable enable\n```\n\n----------------------------------------\n\nTITLE: Implementing Timeout Strategies in C# with Polly\nDESCRIPTION: Demonstrates various ways to implement timeout strategies using Polly's ResiliencePipelineBuilder. Includes examples of setting custom timeouts, using default options, implementing a custom timeout generator, and handling timeout events.\nSOURCE: https://github.com/app-vnext/polly/blob/main/README.md#2025-04-18_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n// To add a timeout with a custom TimeSpan duration\nnew ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(3));\n\n// Timeout using the default options.\n// See https://www.pollydocs.org/strategies/timeout#defaults for defaults.\nvar optionsDefaults = new TimeoutStrategyOptions();\n\n// To add a timeout using a custom timeout generator function\nvar optionsTimeoutGenerator = new TimeoutStrategyOptions\n{\n    TimeoutGenerator = static args =>\n    {\n        // Note: the timeout generator supports asynchronous operations\n        return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123));\n    }\n};\n\n// To add a timeout and listen for timeout events\nvar optionsOnTimeout = new TimeoutStrategyOptions\n{\n    TimeoutGenerator = static args =>\n    {\n        // Note: the timeout generator supports asynchronous operations\n        return new ValueTask<TimeSpan>(TimeSpan.FromSeconds(123));\n    },\n    OnTimeout = static args =>\n    {\n        Console.WriteLine($\"{args.Context.OperationKey}: Execution timed out after {args.Timeout.TotalSeconds} seconds.\");\n        return default;\n    }\n};\n\n// Add a timeout strategy with a TimeoutStrategyOptions instance to the pipeline\nnew ResiliencePipelineBuilder().AddTimeout(optionsDefaults);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Delegate Usage for Retry Strategy in C#\nDESCRIPTION: Code examples showing how to use delegates with resilience strategies, including predicates for handling different result types in both generic and non-generic pipelines.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/extensibility/index.md#2025-04-18_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nnew ResiliencePipelineBuilder()\n    .AddRetry(new RetryStrategyOptions\n    {\n        // Non-Generic predicate for multiple result types\n        ShouldHandle = args => args.Outcome switch\n        {\n            { Exception: InvalidOperationException } => PredicateResult.True(),\n            { Result: string result } when result == \"Failure\" => PredicateResult.True(),\n            { Result: int result } when result == -1 => PredicateResult.True(),\n            _ => PredicateResult.False()\n        },\n    })\n    .Build();\n\nnew ResiliencePipelineBuilder<string>()\n    .AddRetry(new RetryStrategyOptions<string>\n    {\n        // Generic predicate for a single result type\n        ShouldHandle = args => args.Outcome switch\n        {\n            { Exception: InvalidOperationException } => PredicateResult.True(),\n            { Result: { } result } when result == \"Failure\" => PredicateResult.True(),\n            _ => PredicateResult.False()\n        },\n    })\n    .Build();\n```\n\n----------------------------------------\n\nTITLE: Implementing Circuit Breaker in Polly v7\nDESCRIPTION: Shows how to create standard circuit breaker policies in Polly v7, handling both synchronous and asynchronous operations with generic and non-generic variants.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/migration-v8.md#2025-04-18_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\n// Create sync circuit breaker\nISyncPolicy syncPolicy = Policy\n    .Handle<SomeExceptionType>()\n    .CircuitBreaker(\n        exceptionsAllowedBeforeBreaking: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create async circuit breaker\nIAsyncPolicy asyncPolicy = Policy\n    .Handle<SomeExceptionType>()\n    .CircuitBreakerAsync(\n        exceptionsAllowedBeforeBreaking: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create generic sync circuit breaker\nISyncPolicy<HttpResponseMessage> syncPolicyT = Policy<HttpResponseMessage>\n    .Handle<SomeExceptionType>()\n    .CircuitBreaker(\n        handledEventsAllowedBeforeBreaking: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n\n// Create generic async circuit breaker\nIAsyncPolicy<HttpResponseMessage> asyncPolicyT = Policy<HttpResponseMessage>\n    .Handle<SomeExceptionType>()\n    .CircuitBreakerAsync(\n        handledEventsAllowedBeforeBreaking: 2,\n        durationOfBreak: TimeSpan.FromSeconds(1));\n```\n\n----------------------------------------\n\nTITLE: Visualizing Happy Path Retry Sequence with Mermaid\nDESCRIPTION: A sequence diagram illustrating the happy path flow of a retry strategy with a maximum of 2 retry attempts. It shows the interaction between the caller, pipeline, retry strategy, and the decorated user callback, resulting in a successful execution.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/strategies/retry.md#2025-04-18_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    actor C as Caller\n    participant P as Pipeline\n    participant R as Retry\n    participant D as DecoratedUserCallback\n\n    C->>P: Calls ExecuteAsync\n    P->>R: Calls ExecuteCore\n    Note over R,D: Initial attempt\n    R->>+D: Invokes\n    D->>-R: Fails\n    R-->>R: Sleeps\n    Note over R,D: 1st retry attempt\n    R->>+D: Invokes\n    D->>-R: Returns result\n    R->>P: Returns result\n    P->>C: Returns result\n```\n\n----------------------------------------\n\nTITLE: Handling updates from the main branch\nDESCRIPTION: Series of commands to update a feature branch with the latest changes from the main branch while maintaining a clean commit history.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\ngit pull upstream main\ngit checkout my-branch\ngit rebase main\n```\n\n----------------------------------------\n\nTITLE: Creating a new feature branch\nDESCRIPTION: Command to create and switch to a new branch for working on changes.\nSOURCE: https://github.com/app-vnext/polly/blob/main/docs/community/git-workflow.md#2025-04-18_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b my-branch\n```"
  }
]