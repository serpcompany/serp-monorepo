[
  {
    "owner": "oi-wiki",
    "repo": "oi-wiki",
    "content": "TITLE: Basic C++ Program Structure\nDESCRIPTION: A minimal C++ program structure with main function and include statements. This serves as a starting point for beginners.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/basic.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <iostream>\n\nint main() {\n  // do something...\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Input/Output using cin and cout in C++\nDESCRIPTION: Demonstrates basic input and output operations using cin and cout from the iostream library. It reads two integers and outputs them in reverse order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/basic.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nint main() {\n  int x, y;                          // 声明变量\n  std::cin >> x >> y;                // 读入 x 和 y\n  std::cout << y << std::endl << x;  // 输出 y，换行，再输出 x\n  return 0;                          // 结束主函数\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Search in C++\nDESCRIPTION: A basic implementation of the binary search algorithm to find a specific element in a sorted array. The function returns the index of the found element or -1 if the element is not found.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/binary.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint binary_search(int start, int end, int key) {\n  int ret = -1;  // 未搜索到数据返回-1下标\n  int mid;\n  while (start <= end) {\n    mid = start + ((end - start) >> 1);  // 直接平均可能会溢出，所以用这个算法\n    if (arr[mid] < key)\n      start = mid + 1;\n    else if (arr[mid] > key)\n      end = mid - 1;\n    else {  // 最后检测相等是因为多数搜索情况不是大于就是小于\n      ret = mid;\n      break;\n    }\n  }\n  return ret;  // 单一出口\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Sort with Divide and Conquer in C++\nDESCRIPTION: This recursive implementation of merge sort divides the array into halves, sorts each half separately, and then merges them. It demonstrates the classic divide-and-conquer approach with half-open intervals [l, r).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid merge_sort(int *a, int l, int r) {\n  if (r - l <= 1) return;\n  // 分解\n  int mid = l + ((r - l) >> 1);\n  merge_sort(a, l, mid), merge_sort(a, mid, r);\n  // 合并\n  int tmp[1024] = {};  // 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用\n                       // vector；先将合并的结果放在 tmp 里，再返回到数组 a\n  merge(a + l, a + mid, a + mid, a + r, tmp + l);  // pointer-style merge\n  for (int i = l; i < r; ++i) a[i] = tmp[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Binary Exponentiation in C++\nDESCRIPTION: Recursive implementation of binary exponentiation algorithm to calculate a^b efficiently in O(log n) time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nlong long binpow(long long a, long long b) {\n  if (b == 0) return 1;\n  long long res = binpow(a, b / 2);\n  if (b % 2)\n    return res * res * a;\n  else\n    return res * res;\n}\n```\n\n----------------------------------------\n\nTITLE: Strict Secondary MST Implementation in C++\nDESCRIPTION: Implementation of an algorithm to find the strict secondary minimum spanning tree using Kruskal's algorithm, binary lifting for LCA, and path maximum/second maximum edge weight queries. The code uses a tree structure to maintain ancestor information and edge weights, with a complexity of O(m log m).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <iostream>\n\nconstexpr int INF = 0x3fffffff;\nconstexpr long long INF64 = 0x3fffffffffffffffLL;\n\nstruct Edge {\n  int u, v, val;\n\n  bool operator<(const Edge &other) const { return val < other.val; }\n};\n\nEdge e[300010];\nbool used[300010];\n\nint n, m;\nlong long sum;\n\nclass Tr {\n private:\n  struct Edge {\n    int to, nxt, val;\n  } e[600010];\n\n  int cnt, head[100010];\n\n  int pnt[100010][22];\n  int dpth[100010];\n  int maxx[100010][22];\n  int minn[100010][22];\n\n public:\n  void addedge(int u, int v, int val) {\n    e[++cnt] = Edge{v, head[u], val};\n    head[u] = cnt;\n  }\n\n  void insedge(int u, int v, int val) {\n    addedge(u, v, val);\n    addedge(v, u, val);\n  }\n\n  void dfs(int now, int fa) {\n    dpth[now] = dpth[fa] + 1;\n    pnt[now][0] = fa;\n    minn[now][0] = -INF;\n    for (int i = 1; (1 << i) <= dpth[now]; i++) {\n      pnt[now][i] = pnt[pnt[now][i - 1]][i - 1];\n      int kk[4] = {maxx[now][i - 1], maxx[pnt[now][i - 1]][i - 1],\n                   minn[now][i - 1], minn[pnt[now][i - 1]][i - 1]};\n      std::sort(kk, kk + 4);\n      maxx[now][i] = kk[3];\n      int ptr = 2;\n      while (ptr >= 0 && kk[ptr] == kk[3]) ptr--;\n      minn[now][i] = (ptr == -1 ? -INF : kk[ptr]);\n    }\n\n    for (int i = head[now]; i; i = e[i].nxt) {\n      if (e[i].to != fa) {\n        maxx[e[i].to][0] = e[i].val;\n        dfs(e[i].to, now);\n      }\n    }\n  }\n\n  int lca(int a, int b) {\n    if (dpth[a] < dpth[b]) std::swap(a, b);\n\n    for (int i = 21; i >= 0; i--)\n      if (dpth[pnt[a][i]] >= dpth[b]) a = pnt[a][i];\n\n    if (a == b) return a;\n\n    for (int i = 21; i >= 0; i--) {\n      if (pnt[a][i] != pnt[b][i]) {\n        a = pnt[a][i];\n        b = pnt[b][i];\n      }\n    }\n    return pnt[a][0];\n  }\n\n  int query(int a, int b, int val) {\n    int res = -INF;\n    for (int i = 21; i >= 0; i--) {\n      if (dpth[pnt[a][i]] >= dpth[b]) {\n        if (val != maxx[a][i])\n          res = std::max(res, maxx[a][i]);\n        else\n          res = std::max(res, minn[a][i]);\n        a = pnt[a][i];\n      }\n    }\n    return res;\n  }\n} tr;\n\nint fa[100010];\n\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n\nvoid Kruskal() {\n  int tot = 0;\n  std::sort(e + 1, e + m + 1);\n  for (int i = 1; i <= n; i++) fa[i] = i;\n\n  for (int i = 1; i <= m; i++) {\n    int a = find(e[i].u);\n    int b = find(e[i].v);\n    if (a != b) {\n      fa[a] = b;\n      tot++;\n      tr.insedge(e[i].u, e[i].v, e[i].val);\n      sum += e[i].val;\n      used[i] = true;\n    }\n    if (tot == n - 1) break;\n  }\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n\n  std::cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    int u, v, val;\n    std::cin >> u >> v >> val;\n    e[i] = Edge{u, v, val};\n  }\n\n  Kruskal();\n  long long ans = INF64;\n  tr.dfs(1, 0);\n\n  for (int i = 1; i <= m; i++) {\n    if (!used[i]) {\n      int _lca = tr.lca(e[i].u, e[i].v);\n      long long tmpa = tr.query(e[i].u, _lca, e[i].val);\n      long long tmpb = tr.query(e[i].v, _lca, e[i].val);\n      if (std::max(tmpa, tmpb) > -INF)\n        ans = std::min(ans, sum - std::max(tmpa, tmpb) + e[i].val);\n    }\n  }\n  std::cout << (ans == INF64 ? -1 : ans) << '\\n';\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Splay Tree Implementation for Sequence Operations in C++\nDESCRIPTION: This is a full implementation of a Splay tree for sequence operations, including building the tree, performing interval reversals, and managing lazy propagation. It solves the 'Literary Balanced Tree' problem.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/splay.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/splay/splay-2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Vector Construction Examples in C++\nDESCRIPTION: Examples showing different ways to construct std::vector objects including empty vectors, pre-sized vectors, copy construction and move construction.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/sequence-container.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// 1. 创建空vector; 常数复杂度\nvector<int> v0;\n// 1+. 这句代码可以使得向vector中插入前3个元素时，保证常数时间复杂度\nv0.reserve(3);\n// 2. 创建一个初始空间为3的vector，其元素的默认值是0; 线性复杂度\nvector<int> v1(3);\n// 3. 创建一个初始空间为3的vector，其元素的默认值是2; 线性复杂度\nvector<int> v2(3, 2);\n// 4. 创建一个初始空间为3的vector，其元素的默认值是1，\n// 并且使用v2的空间配置器; 线性复杂度\nvector<int> v3(3, 1, v2.get_allocator());\n// 5. 创建一个v2的拷贝vector v4， 其内容元素和v2一样; 线性复杂度\nvector<int> v4(v2);\n// 6. 创建一个v4的拷贝vector v5，其内容是{v4[1], v4[2]}; 线性复杂度\nvector<int> v5(v4.begin() + 1, v4.begin() + 3);\n// 7. 移动v2到新创建的vector v6，不发生拷贝; 常数复杂度; 需要 C++11\nvector<int> v6(std::move(v2));  // 或者 v6 = std::move(v2);\n```\n\n----------------------------------------\n\nTITLE: Implementing Radix Sort for Integer Array in C++\nDESCRIPTION: This code implements radix sort for an array of integers. It uses bit manipulation and counting sort as a subroutine, demonstrating the algorithm on a problem from Luogu (P1177).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/radix-sort.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <iostream>\n#include <utility>\n\nvoid radix_sort(int n, int a[]) {\n  int *b = new int[n];  // 临时空间\n  int *cnt = new int[1 << 8];\n  int mask = (1 << 8) - 1;\n  int *x = a, *y = b;\n  for (int i = 0; i < 32; i += 8) {\n    for (int j = 0; j != (1 << 8); ++j) cnt[j] = 0;\n    for (int j = 0; j != n; ++j) ++cnt[x[j] >> i & mask];\n    for (int sum = 0, j = 0; j != (1 << 8); ++j) {\n      // 等价于 std::exclusive_scan(cnt, cnt + (1 << 8), cnt, 0);\n      sum += cnt[j], cnt[j] = sum - cnt[j];\n    }\n    for (int j = 0; j != n; ++j) y[cnt[x[j] >> i & mask]++] = x[j];\n    std::swap(x, y);\n  }\n  delete[] cnt;\n  delete[] b;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  int n;\n  std::cin >> n;\n  int *a = new int[n];\n  for (int i = 0; i < n; ++i) std::cin >> a[i];\n  radix_sort(n, a);\n  for (int i = 0; i < n; ++i) std::cout << a[i] << ' ';\n  delete[] a;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Heap Sort in C++\nDESCRIPTION: Complete implementation of heap sort in C++, including the sift_down function for maintaining the heap property and the main heap_sort function that builds the heap and sorts the array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/heap-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid sift_down(int arr[], int start, int end) {\n  // 计算父结点和子结点的下标\n  int parent = start;\n  int child = parent * 2 + 1;\n  while (child <= end) {  // 子结点下标在范围内才做比较\n    // 先比较两个子结点大小，选择最大的\n    if (child + 1 <= end && arr[child] < arr[child + 1]) child++;\n    // 如果父结点比子结点大，代表调整完毕，直接跳出函数\n    if (arr[parent] >= arr[child])\n      return;\n    else {  // 否则交换父子内容，子结点再和孙结点比较\n      swap(arr[parent], arr[child]);\n      parent = child;\n      child = parent * 2 + 1;\n    }\n  }\n}\n\nvoid heap_sort(int arr[], int len) {\n  // 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)\n  for (int i = (len - 1 - 1) / 2; i >= 0; i--) sift_down(arr, i, len - 1);\n  // 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕\n  for (int i = len - 1; i > 0; i--) {\n    swap(arr[0], arr[i]);\n    sift_down(arr, 0, i - 1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Inorder Traversal of Binary Search Tree in C++\nDESCRIPTION: A recursive implementation for traversing a Binary Search Tree in inorder sequence, which produces a non-decreasing sequence of values. The traversal visits left subtree, root node, then right subtree with O(n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\nvoid inorderTraversal(TreeNode* root) {\n  if (root == nullptr) {\n    return;\n  }\n  inorderTraversal(root->left);\n  std::cout << root->key << \" \";\n  inorderTraversal(root->right);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Uniqueness of Minimum Spanning Tree in C++\nDESCRIPTION: This code checks if the minimum spanning tree of a graph is unique. It uses Kruskal's algorithm and checks if there are multiple edges with the same weight that could be used to form different minimum spanning trees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/mst/mst_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Complete Skip List Implementation in C++\nDESCRIPTION: This is a full implementation of a Skip List as a map in C++. It includes the SkipListNode structure, the SkipList class with all operations (insert, erase, find, count), and a main function for testing and comparison with std::map.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/skiplist.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <cassert>\n#include <climits>\n#include <ctime>\n#include <iostream>\n#include <map>\nusing namespace std;\n\ntemplate <typename K, typename V>\nstruct SkipListNode {\n  int level;\n  K key;\n  V value;\n  SkipListNode **forward;\n\n  SkipListNode() {}\n\n  SkipListNode(K k, V v, int l, SkipListNode *nxt = NULL) {\n    key = k;\n    value = v;\n    level = l;\n    forward = new SkipListNode *[l + 1];\n    for (int i = 0; i <= l; ++i) forward[i] = nxt;\n  }\n\n  ~SkipListNode() {\n    if (forward != NULL) delete[] forward;\n  }\n};\n\ntemplate <typename K, typename V>\nstruct SkipList {\n  static constexpr int MAXL = 32;\n  static constexpr int P = 4;\n  static constexpr int S = 0xFFFF;\n  static constexpr int PS = S / P;\n  static constexpr int INVALID = INT_MAX;\n\n  SkipListNode<K, V> *head, *tail;\n  int length;\n  int level;\n\n  SkipList() {\n    srand(time(nullptr));\n\n    level = length = 0;\n    tail = new SkipListNode<K, V>(INVALID, 0, 0);\n    head = new SkipListNode<K, V>(INVALID, 0, MAXL, tail);\n  }\n\n  ~SkipList() {\n    delete head;\n    delete tail;\n  }\n\n  int randomLevel() {\n    int lv = 1;\n    while ((rand() & S) < PS) ++lv;\n    return MAXL > lv ? lv : MAXL;\n  }\n\n  void insert(const K &key, const V &value) {\n    SkipListNode<K, V> *update[MAXL + 1];\n\n    SkipListNode<K, V> *p = head;\n    for (int i = level; i >= 0; --i) {\n      while (p->forward[i]->key < key) {\n        p = p->forward[i];\n      }\n      update[i] = p;\n    }\n    p = p->forward[0];\n\n    if (p->key == key) {\n      p->value = value;\n      return;\n    }\n\n    int lv = randomLevel();\n    if (lv > level) {\n      lv = ++level;\n      update[lv] = head;\n    }\n\n    SkipListNode<K, V> *newNode = new SkipListNode<K, V>(key, value, lv);\n    for (int i = lv; i >= 0; --i) {\n      p = update[i];\n      newNode->forward[i] = p->forward[i];\n      p->forward[i] = newNode;\n    }\n\n    ++length;\n  }\n\n  bool erase(const K &key) {\n    SkipListNode<K, V> *update[MAXL + 1];\n    SkipListNode<K, V> *p = head;\n\n    for (int i = level; i >= 0; --i) {\n      while (p->forward[i]->key < key) {\n        p = p->forward[i];\n      }\n      update[i] = p;\n    }\n    p = p->forward[0];\n\n    if (p->key != key) return false;\n\n    for (int i = 0; i <= level; ++i) {\n      if (update[i]->forward[i] != p) {\n        break;\n      }\n      update[i]->forward[i] = p->forward[i];\n    }\n\n    delete p;\n\n    while (level > 0 && head->forward[level] == tail) --level;\n    --length;\n    return true;\n  }\n\n  V &operator[](const K &key) {\n    V v = find(key);\n    if (v == tail->value) insert(key, 0);\n    return find(key);\n  }\n\n  V &find(const K &key) {\n    SkipListNode<K, V> *p = head;\n    for (int i = level; i >= 0; --i) {\n      while (p->forward[i]->key < key) {\n        p = p->forward[i];\n      }\n    }\n    p = p->forward[0];\n    if (p->key == key) return p->value;\n    return tail->value;\n  }\n\n  bool count(const K &key) { return find(key) != tail->value; }\n};\n\nint main() {\n  SkipList<int, int> L;\n  map<int, int> M;\n\n  clock_t s = clock();\n\n  for (int i = 0; i < 1e5; ++i) {\n    int key = rand(), value = rand();\n    L[key] = value;\n    M[key] = value;\n  }\n\n  for (int i = 0; i < 1e5; ++i) {\n    int key = rand();\n    if (i & 1) {\n      L.erase(key);\n      M.erase(key);\n    } else {\n      int r1 = L.count(key) ? L[key] : 0;\n      int r2 = M.count(key) ? M[key] : 0;\n      assert(r1 == r2);\n    }\n  }\n\n  clock_t e = clock();\n  cout << \"Time elapsed: \" << (double)(e - s) / CLOCKS_PER_SEC << endl;\n  // about 0.2s\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Segment Tree Range Query in C++\nDESCRIPTION: Implementation of dynamic segment tree range query operation that handles empty nodes during traversal. Returns sum of elements in given range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nint query(int p, int s, int t, int l, int r) {\n  if (!p) return 0;\n  if (s >= l && t <= r) return sum[p];\n  int m = s + ((t - s) >> 1), ans = 0;\n  if (l <= m) ans += query(ls[p], s, m, l, r);\n  if (r > m) ans += query(rs[p], m + 1, t, l, r);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Integer Writing Function Using Recursion in C++\nDESCRIPTION: A fast recursive implementation for outputting integers using putchar(). This function converts integers to characters digit by digit and handles negative numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvoid write(int x) {\n  if (x < 0) {  // 判负 + 输出负号 + 变原数为正数\n    x = -x;\n    putchar('-');\n  }\n  if (x > 9) write(x / 10);  // 递归，将除最后一位外的其他部分放到递归中输出\n  putchar(x % 10 + '0');  // 已经输出（递归）完 x 末位前的所有数字，输出末位\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Through Set Container (C++)\nDESCRIPTION: Demonstrates how to iterate through all elements in a set container using both traditional iterator and C++11 range-based for loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/associative-container.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nset<int> s;\nusing si = set<int>::iterator;\nfor (si it = s.begin(); it != s.end(); it++) cout << *it << endl;\n\n// C++11 range-based for loop\nfor (auto x : s) cout << x << endl;\n```\n\n----------------------------------------\n\nTITLE: Implementing Heap Sort in Python\nDESCRIPTION: Complete implementation of heap sort in Python, including the sift_down function for maintaining the heap property and the main heap_sort function that builds the heap and sorts the array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/heap-sort.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef sift_down(arr, start, end):\n    # 计算父结点和子结点的下标\n    parent = int(start)\n    child = int(parent * 2 + 1)\n    while child <= end:  # 子结点下标在范围内才做比较\n        # 先比较两个子结点大小，选择最大的\n        if child + 1 <= end and arr[child] < arr[child + 1]:\n            child += 1\n        # 如果父结点比子结点大，代表调整完毕，直接跳出函数\n        if arr[parent] >= arr[child]:\n            return\n        else:  # 否则交换父子内容，子结点再和孙结点比较\n            arr[parent], arr[child] = arr[child], arr[parent]\n            parent = child\n            child = int(parent * 2 + 1)\n\n\ndef heap_sort(arr, len):\n    # 从最后一个节点的父节点开始 sift down 以完成堆化 (heapify)\n    i = (len - 1 - 1) / 2\n    while i >= 0:\n        sift_down(arr, i, len - 1)\n        i -= 1\n    # 先将第一个元素和已经排好的元素前一位做交换，再重新调整（刚调整的元素之前的元素），直到排序完毕\n    i = len - 1\n    while i > 0:\n        arr[0], arr[i] = arr[i], arr[0]\n        sift_down(arr, 0, i - 1)\n        i -= 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive DFS in C++\nDESCRIPTION: This snippet demonstrates a recursive implementation of Depth First Search in C++. It uses an adjacency list to represent the graph and a boolean vector to track visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvector<vector<int>> adj;  // 邻接表\nvector<bool> vis;         // 记录节点是否已经遍历\n\nvoid dfs(const int u) {\n  vis[u] = true;\n  for (int v : adj[u])\n    if (!vis[v]) dfs(v)\n}\n```\n\n----------------------------------------\n\nTITLE: O(n) Binary Indexed Tree Construction in Python\nDESCRIPTION: This Python function implements the same O(n) Binary Indexed Tree construction algorithm as the C++ version, efficiently building the tree by updating parent nodes directly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_15\n\nLANGUAGE: Python\nCODE:\n```\ndef init():\n    for i in range(1, n + 1):\n        t[i] = t[i] + a[i]\n        j = i + lowbit(i)\n        if j <= n:\n            t[j] = t[j] + t[i]\n```\n\n----------------------------------------\n\nTITLE: Removing an Element from BST in C++\nDESCRIPTION: A recursive implementation for deleting a node from a Binary Search Tree. It handles three cases: decreasing count for duplicates, removing leaf/single-child nodes directly, or replacing with successor for nodes with two children. Time complexity is O(h).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_5\n\nLANGUAGE: c++\nCODE:\n```\n// 此处返回值为删除 value 后的新 root\nTreeNode* remove(TreeNode* root, int value) {\n  if (root == nullptr) {\n    return root;\n  }\n  if (value < root->key) {\n    root->left = remove(root->left, value);\n  } else if (value > root->key) {\n    root->right = remove(root->right, value);\n  } else {\n    if (root->count > 1) {\n      root->count--;  // 节点重复数量大于1，减少重复数量\n    } else {\n      if (root->left == nullptr) {\n        TreeNode* temp = root->right;\n        delete root;\n        return temp;\n      } else if (root->right == nullptr) {\n        TreeNode* temp = root->left;\n        delete root;\n        return temp;\n      } else {\n        TreeNode* successor = findMinNode(root->right);\n        root->key = successor->key;\n        root->count = successor->count;  // 更新重复数量\n        // 当 successor->count > 1时，也应该删除该节点，否则\n        // 后续的删除只会减少重复数量\n        successor->count = 1;\n        root->right = remove(root->right, successor->key);\n      }\n    }\n  }\n  // 继续维护size，不写成 --root->size;\n  // 是因为value可能不在树中，从而可能未发生删除\n  root->size = root->count + (root->left ? root->left->size : 0) +\n               (root->right ? root->right->size : 0);\n  return root;\n}\n\n// 此处以右子树的最小值为例\nTreeNode* findMinNode(TreeNode* root) {\n  while (root->left != nullptr) {\n    root = root->left;\n  }\n  return root;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Augmenting Path Algorithm for Bipartite Matching in C++\nDESCRIPTION: This code implements the augmenting path algorithm to find the maximum matching in a bipartite graph. It uses depth-first search to find augmenting paths and updates the matching accordingly. The time complexity is O(nm) where n is the number of vertices and m is the number of edges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/bigraph-match.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstruct augment_path {\n  vector<vector<int>> g;\n  vector<int> pa;  // 匹配\n  vector<int> pb;\n  vector<int> vis;  // 访问\n  int n, m;         // 两个点集中的顶点数量\n  int dfn;          // 时间戳记\n  int res;          // 匹配数\n\n  augment_path(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    vis = vector<int>(n);\n    g.resize(n);\n    res = 0;\n    dfn = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    vis[v] = dfn;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pb[u] = v;\n        pa[v] = u;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (vis[pb[u]] != dfn && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      dfn++;\n      int cnt = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          cnt++;\n        }\n      }\n      if (cnt == 0) {\n        break;\n      }\n      res += cnt;\n    }\n    return res;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic High-Precision Calculator in C++\nDESCRIPTION: A calculator program that handles high-precision arithmetic operations (addition, subtraction, multiplication, division) on large numbers stored as arrays of digits. Includes input/output handling and core arithmetic implementations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <cstring>\n\nconstexpr int LEN = 1004;\n\nint a[LEN], b[LEN], c[LEN], d[LEN];\n\nvoid clear(int a[]) {\n  for (int i = 0; i < LEN; ++i) a[i] = 0;\n}\n\nvoid read(int a[]) {\n  static char s[LEN + 1];\n  scanf(\"%s\", s);\n\n  clear(a);\n\n  int len = strlen(s);\n  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';\n}\n\nvoid print(int a[]) {\n  int i;\n  for (i = LEN - 1; i >= 1; --i)\n    if (a[i] != 0) break;\n  for (; i >= 0; --i) putchar(a[i] + '0');\n  putchar('\\n');\n}\n\nvoid add(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] + b[i];\n    if (c[i] >= 10) {\n      c[i + 1] += 1;\n      c[i] -= 10;\n    }\n  }\n}\n\nvoid sub(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] - b[i];\n    if (c[i] < 0) {\n      c[i + 1] -= 1;\n      c[i] += 10;\n    }\n  }\n}\n\nvoid mul(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];\n\n    if (c[i] >= 10) {\n      c[i + 1] += c[i] / 10;\n      c[i] %= 10;\n    }\n  }\n}\n\nbool greater_eq(int a[], int b[], int last_dg, int len) {\n  if (a[last_dg + len] != 0) return true;\n  for (int i = len - 1; i >= 0; --i) {\n    if (a[last_dg + i] > b[i]) return true;\n    if (a[last_dg + i] < b[i]) return false;\n  }\n  return true;\n}\n\nvoid div(int a[], int b[], int c[], int d[]) {\n  clear(c);\n  clear(d);\n\n  int la, lb;\n  for (la = LEN - 1; la > 0; --la)\n    if (a[la - 1] != 0) break;\n  for (lb = LEN - 1; lb > 0; --lb)\n    if (b[lb - 1] != 0) break;\n  if (lb == 0) {\n    puts(\"> <\");\n    return;\n  }\n\n  for (int i = 0; i < la; ++i) d[i] = a[i];\n  for (int i = la - lb; i >= 0; --i) {\n    while (greater_eq(d, b, i, lb)) {\n      for (int j = 0; j < lb; ++j) {\n        d[i + j] -= b[j];\n        if (d[i + j] < 0) {\n          d[i + j + 1] -= 1;\n          d[i + j] += 10;\n        }\n      }\n      c[i] += 1;\n    }\n  }\n}\n\nint main() {\n  read(a);\n\n  char op[4];\n  scanf(\"%s\", op);\n\n  read(b);\n\n  switch (op[0]) {\n    case '+':\n      add(a, b, c);\n      print(c);\n      break;\n    case '-':\n      sub(a, b, c);\n      print(c);\n      break;\n    case '*':\n      mul(a, b, c);\n      print(c);\n      break;\n    case '/':\n      div(a, b, c, d);\n      print(c);\n      print(d);\n      break;\n    default:\n      puts(\"> <\");\n  }\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Point Update for Tree Array in C++\nDESCRIPTION: This function adds a value k to the element at index x in the tree array, updating all necessary parent nodes. It maintains the sum property of the tree array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid add(int x, int k) {\n  while (x <= n) {  // 不能越界\n    c[x] = c[x] + k;\n    x = x + lowbit(x);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 多条回路覆盖问题完整实现 (C++)\nDESCRIPTION: 多条回路覆盖问题的完整解决方案，计算用若干条回路覆盖N×M棋盘的方案数。使用轮廓线DP和哈希表优化，处理带障碍的棋盘情况。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/plug/plug_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Iterating through pb_ds containers using C++ iterators\nDESCRIPTION: Demonstrates how to use begin() and end() methods to obtain iterators for traversing pb_ds containers. This is a common pattern for iterating through STL-like containers in C++.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/index.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbegin()\n```\n\nLANGUAGE: C++\nCODE:\n```\nend()\n```\n\n----------------------------------------\n\nTITLE: Implementing Longest Increasing Subsequence (O(n^2)) in C++\nDESCRIPTION: This function implements a quadratic time algorithm for finding the length of the longest increasing subsequence in an array. It uses dynamic programming with a 1D array to store intermediate results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/basic.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint a[MAXN], d[MAXN];\n\nint dp() {\n  d[1] = 1;\n  int ans = 1;\n  for (int i = 2; i <= n; i++) {\n    d[i] = 1;\n    for (int j = 1; j < i; j++)\n      if (a[j] <= a[i]) {\n        d[i] = max(d[i], d[j] + 1);\n        ans = max(ans, d[i]);\n      }\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing prefix sum query in Tree Array using Python\nDESCRIPTION: Python implementation of the prefix sum query function for tree arrays/Fenwick trees. This function computes the sum of elements from a[1] to a[x] by traversing the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef getsum(x):  # a[1]..a[x]的和\n    ans = 0\n    while x > 0:\n        ans = ans + c[x]\n        x = x - lowbit(x)\n    return ans\n```\n\n----------------------------------------\n\nTITLE: Using Lvalue References for Function Parameters in C++\nDESCRIPTION: This example demonstrates using lvalue references as function parameters to avoid unnecessary copying. The function modifies the string passed by reference and returns a reference to a character within it.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <string>\n\n// 参数中的 s 是引用，在调用函数时不会发生拷贝\nchar& char_number(std::string& s, std::size_t n) {\n  s += s;  // 's' 与 main() 的 'str'\n         // 是同一对象，此处还说明左值也是可以放在等号右侧的\n  return s.at(n);  // string::at() 返回 char 的引用\n}\n\nint main() {\n  std::string str = \"Test\";\n  char_number(str, 1) = 'a';  // 函数返回是左值，可被赋值\n  std::cout << str << '\\n';   // 此处输出 \"TastTest\"\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trie Data Structure in Python\nDESCRIPTION: Python implementation of trie data structure with insertion and search operations. Uses nested lists to store child node pointers and boolean flags to mark string endings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/trie.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass trie:\n    def __init__(self):\n        self.nex = [[0 for i in range(26)] for j in range(100000)]\n        self.cnt = 0\n        self.exist = [False] * 100000  # 该结点结尾的字符串是否存在\n\n    def insert(self, s):  # 插入字符串\n        p = 0\n        for i in s:\n            c = ord(i) - ord(\"a\")\n            if not self.nex[p][c]:\n                self.cnt += 1\n                self.nex[p][c] = self.cnt  # 如果没有，就添加结点\n            p = self.nex[p][c]\n        self.exist[p] = True\n\n    def find(self, s):  # 查找字符串\n        p = 0\n        for i in s:\n            c = ord(i) - ord(\"a\")\n            if not self.nex[p][c]:\n                return False\n            p = self.nex[p][c]\n        return self.exist[p]\n```\n\n----------------------------------------\n\nTITLE: 2D Knapsack Implementation\nDESCRIPTION: Implementation of 2D knapsack problem with both time and money constraints in C++ and Python.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nfor (int k = 1; k <= n; k++)\n  for (int i = m; i >= mi; i--)    // 对经费进行一层枚举\n    for (int j = t; j >= ti; j--)  // 对时间进行一层枚举\n      dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1);\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor k in range(1, n + 1):\n    for i in range(m, mi - 1, -1):  # 对经费进行一层枚举\n        for j in range(t, ti - 1, -1):  # 对时间进行一层枚举\n            dp[i][j] = max(dp[i][j], dp[i - mi][j - ti] + 1)\n```\n\n----------------------------------------\n\nTITLE: Implementing Shell Sort in C++\nDESCRIPTION: A C++ template function that implements the Shell sort algorithm. It uses a dynamic gap sequence and performs in-place sorting of the input array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/shell-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nvoid shell_sort(T array[], int length) {\n  int h = 1;\n  while (h < length / 3) {\n    h = 3 * h + 1;\n  }\n  while (h >= 1) {\n    for (int i = h; i < length; i++) {\n      for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {\n        std::swap(array[j], array[j - h]);\n      }\n    }\n    h = h / 3;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bellman-Ford Algorithm Implementation\nDESCRIPTION: Implementation of Bellman-Ford algorithm for finding single-source shortest paths with negative edge weights. Includes negative cycle detection.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct Edge {\n  int u, v, w;\n};\n\nvector<Edge> edge;\n\nint dis[MAXN], u, v, w;\nconstexpr int INF = 0x3f3f3f3f;\n\nbool bellmanford(int n, int s) {\n  memset(dis, 0x3f, (n + 1) * sizeof(int));\n  dis[s] = 0;\n  bool flag = false;\n  for (int i = 1; i <= n; i++) {\n    flag = false;\n    for (int j = 0; j < edge.size(); j++) {\n      u = edge[j].u, v = edge[j].v, w = edge[j].w;\n      if (dis[u] == INF) continue;\n      if (dis[v] > dis[u] + w) {\n        dis[v] = dis[u] + w;\n        flag = true;\n      }\n    }\n    if (!flag) break;\n  }\n  return flag;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nclass Edge:\n    def __init__(self, u=0, v=0, w=0):\n        self.u = u\n        self.v = v\n        self.w = w\n\nINF = 0x3F3F3F3F\nedge = []\n\ndef bellmanford(n, s):\n    dis = [INF] * (n + 1)\n    dis[s] = 0\n    for i in range(1, n + 1):\n        flag = False\n        for e in edge:\n            u, v, w = e.u, e.v, e.w\n            if dis[u] == INF:\n                continue\n            if dis[v] > dis[u] + w:\n                dis[v] = dis[u] + w\n                flag = True\n        if not flag:\n            break\n    return flag\n```\n\n----------------------------------------\n\nTITLE: Implementing Dijkstra's Algorithm with Priority Queue in Python\nDESCRIPTION: A Python implementation of Dijkstra's algorithm using a heap-based priority queue from the heapq module. This implementation efficiently finds the shortest paths from a source vertex to all other vertices in a non-negative weight graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef dijkstra(e, s):\n    \"\"\"\n    输入：\n    e:邻接表\n    s:起点\n    返回：\n    dis:从s到每个顶点的最短路长度\n    \"\"\"\n    dis = defaultdict(lambda: float(\"inf\"))\n    dis[s] = 0\n    q = [(0, s)]\n    vis = set()\n    while q:\n        _, u = heapq.heappop(q)\n        if u in vis:\n            continue\n        vis.add(u)\n        for v, w in e[u]:\n            if dis[v] > dis[u] + w:\n                dis[v] = dis[u] + w\n                heapq.heappush(q, (dis[v], v))\n    return dis\n```\n\n----------------------------------------\n\nTITLE: Input/Output using scanf and printf in C++\nDESCRIPTION: Shows how to use scanf and printf functions from C for input and output in C++. These functions are often faster than cin/cout and offer more control over formatting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/basic.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n\nint main() {\n  int x, y;\n  scanf(\"%d%d\", &x, &y);   // 读入 x 和 y\n  printf(\"%d\\n%d\", y, x);  // 输出 y，换行，再输出 x\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Recursive Function Template in C++\nDESCRIPTION: A template for writing recursive functions in C++, showing the fundamental structure with termination conditions and self-calls.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint func(传入数值) {\n  if (终止条件) return 最小子问题解;\n  return func(缩小规模);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Set in Greedy Algorithms (C++)\nDESCRIPTION: Demonstrates how to use a set to find and remove the smallest element greater than or equal to a given value, which is a common operation in greedy algorithms.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/associative-container.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// 现存可用的元素\nset<int> available;\n// 需要大于等于的值\nint x;\n\n// 查找最小的大于等于x的元素\nset<int>::iterator it = available.lower_bound(x);\nif (it == available.end()) {\n  // 不存在这样的元素，则进行相应操作……\n} else {\n  // 找到了这样的元素，将其从现存可用元素中移除\n  available.erase(it);\n  // 进行相应操作……\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling C++ Code from Command Line\nDESCRIPTION: Example of compiling a C++ program using g++ from the command line. The -lm flag links the math library, and -o specifies the output filename.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/helloworld.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ng++ test.cpp -o test -lm\n```\n\n----------------------------------------\n\nTITLE: Dynamic Range K-th Number Query with Segment and Fenwick Trees - C++\nDESCRIPTION: Complete implementation for solving the dynamic range k-th number problem. Uses a combination of segment trees and Fenwick trees with dynamic allocation. Supports point updates and range k-th number queries with O(log^2 n) time complexity and O(n log^2 n) space complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-in-bit.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <set>\n#define LC o << 1\n#define RC o << 1 | 1\nusing namespace std;\nconstexpr int MAXN = 1000010;\nint n, m, a[MAXN], u[MAXN], x[MAXN], l[MAXN], r[MAXN], k[MAXN], cur, cur1, cur2,\n    q1[MAXN], q2[MAXN], v[MAXN];\nchar op[MAXN];\nset<int> ST;\nmap<int, int> mp;\n\nstruct segment_tree  // 封装的动态开点权值线段树\n{\n  int cur, rt[MAXN * 4], sum[MAXN * 60], lc[MAXN * 60], rc[MAXN * 60];\n\n  void build(int& o) { o = ++cur; }\n\n  void print(int o, int l, int r) {\n    if (!o) return;\n    if (l == r && sum[o]) printf(\"%d \", l);\n    int mid = (l + r) >> 1;\n    print(lc[o], l, mid);\n    print(rc[o], mid + 1, r);\n  }\n\n  void update(int& o, int l, int r, int x, int v) {\n    if (!o) o = ++cur;\n    sum[o] += v;\n    if (l == r) return;\n    int mid = (l + r) >> 1;\n    if (x <= mid)\n      update(lc[o], l, mid, x, v);\n    else\n      update(rc[o], mid + 1, r, x, v);\n  }\n} st;\n\n// 树状数组实现\nnamepace fenwick_impl {\n  int lowbit(int o) { return (o & (-o)); }\n\n  void upd(int o, int x, int v) {\n    for (; o <= n; o += lowbit(o)) st.update(st.rt[o], 1, n, x, v);\n  }\n\n  void gtv(int o, int* A, int& p) {\n    p = 0;\n    for (; o; o -= lowbit(o)) A[++p] = st.rt[o];\n  }\n\n  int qry(int l, int r, int k) {\n    if (l == r) return l;\n    int mid = (l + r) >> 1, siz = 0;\n    for (int i = 1; i <= cur1; i++) siz += st.sum[st.lc[q1[i]]];\n    for (int i = 1; i <= cur2; i++) siz -= st.sum[st.lc[q2[i]]];\n    if (siz >= k) {\n      for (int i = 1; i <= cur1; i++) q1[i] = st.lc[q1[i]];\n      for (int i = 1; i <= cur2; i++) q2[i] = st.lc[q2[i]];\n      return qry(l, mid, k);\n    } else {\n      for (int i = 1; i <= cur1; i++) q1[i] = st.rc[q1[i]];\n      for (int i = 1; i <= cur2; i++) q2[i] = st.rc[q2[i]];\n      return qry(mid + 1, r, k - siz);\n    }\n  }\n}\nusing namespace fenwick_impl;\n\nnamespace segtree_impl {\nvoid build(int o, int l, int r) {\n  st.build(st.rt[o]);\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  build(LC, l, mid);\n  build(RC, mid + 1, r);\n}\n\nvoid print(int o, int l, int r) {\n  printf(\"%d %d:\", l, r);\n  st.print(st.rt[o], 1, n);\n  printf(\"\\n\");\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  print(LC, l, mid);\n  print(RC, mid + 1, r);\n}\n\nvoid update(int o, int l, int r, int q, int x, int v) {\n  st.update(st.rt[o], 1, n, x, v);\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  if (q <= mid)\n    update(LC, l, mid, q, x, v);\n  else\n    update(RC, mid + 1, r, q, x, v);\n}\n\nvoid getval(int o, int l, int r, int ql, int qr) {\n  if (l > qr || r < ql) return;\n  if (ql <= l && r <= qr) {\n    q[++cur] = st.rt[o];\n    return;\n  }\n  int mid = (l + r) >> 1;\n  getval(LC, l, mid, ql, qr);\n  getval(RC, mid + 1, r, ql, qr);\n}\n\nint query(int l, int r, int k) {\n  if (l == r) return l;\n  int mid = (l + r) >> 1, siz = 0;\n  for (int i = 1; i <= cur; i++) siz += st.sum[st.lc[q[i]]];\n  if (siz >= k) {\n    for (int i = 1; i <= cur; i++) q[i] = st.lc[q[i]];\n    return query(l, mid, k);\n  } else {\n    for (int i = 1; i <= cur; i++) q[i] = st.rc[q[i]];\n    return query(mid + 1, r, k - siz);\n  }\n}\n}  // namespace segtree_impl\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", a + i), ST.insert(a[i]);\n  for (int i = 1; i <= m; i++) {\n    scanf(\" %c\", op + i);\n    if (op[i] == 'C')\n      scanf(\"%d%d\", u + i, x + i), ST.insert(x[i]);\n    else\n      scanf(\"%d%d%d\", l + i, r + i, k + i);\n  }\n  for (set<int>::iterator it = ST.begin(); it != ST.end(); it++)\n    mp[*it] = ++cur, v[cur] = *it;\n  for (int i = 1; i <= n; i++) a[i] = mp[a[i]];\n  for (int i = 1; i <= m; i++)\n    if (op[i] == 'C') x[i] = mp[x[i]];\n  n += m;\n  for (int i = 1; i <= n; i++) upd(i, a[i], 1);\n  for (int i = 1; i <= m; i++) {\n    if (op[i] == 'C') {\n      upd(u[i], a[u[i]], -1);\n      upd(u[i], x[i], 1);\n      a[u[i]] = x[i];\n    } else {\n      gtv(r[i], q1, cur1);\n      gtv(l[i] - 1, q2, cur2);\n      printf(\"%d\\n\", v[qry(1, n, k[i])]);\n    }\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kattio Class for Faster I/O in Java\nDESCRIPTION: A custom Kattio class that extends PrintWriter to provide faster input/output operations. This implementation combines BufferedReader with StringTokenizer for efficient parsing and wraps PrintWriter for output operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nclass Kattio extends PrintWriter {\n    private BufferedReader r;\n    private StringTokenizer st;\n    // 标准 IO\n    public Kattio() { this(System.in, System.out); }\n    public Kattio(InputStream i, OutputStream o) {\n        super(o);\n        r = new BufferedReader(new InputStreamReader(i));\n    }\n    // 文件 IO\n    public Kattio(String intput, String output) throws IOException {\n        super(output);\n        r = new BufferedReader(new FileReader(intput));\n    }\n    // 在没有其他输入时返回 null\n    public String next() {\n        try {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(r.readLine());\n            return st.nextToken();\n        } catch (Exception e) {}\n        return null;\n    }\n    public int nextInt() { return Integer.parseInt(next()); }\n    public double nextDouble() { return Double.parseDouble(next()); }\n    public long nextLong() { return Long.parseLong(next()); }\n}\n```\n\n----------------------------------------\n\nTITLE: Tarjan's Algorithm Implementation for LCA\nDESCRIPTION: Implementation of Tarjan's offline algorithm for finding LCA using disjoint sets. The code handles preprocessing, DFS traversal and query processing with complexity O(m α(m+n, n) + n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/lca.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/graph/code/lca/lca_tarjan.cpp\"\n```\n\n----------------------------------------\n\nTITLE: BFS Implementation with Path Tracking - C++\nDESCRIPTION: C++ implementation of BFS with additional features for tracking distances and reconstructing paths.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/bfs.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid bfs(int u) {\n  while (!Q.empty()) Q.pop();\n  Q.push(u);\n  vis[u] = 1;\n  d[u] = 0;\n  p[u] = -1;\n  while (!Q.empty()) {\n    u = Q.front();\n    Q.pop();\n    for (int i = head[u]; i; i = e[i].nxt) {\n      if (!vis[e[i].to]) {\n        Q.push(e[i].to);\n        vis[e[i].to] = 1;\n        d[e[i].to] = d[u] + 1;\n        p[e[i].to] = u;\n      }\n    }\n  }\n}\n\nvoid restore(int x) {\n  vector<int> res;\n  for (int v = x; v != -1; v = p[v]) {\n    res.push_back(v);\n  }\n  std::reverse(res.begin(), res.end());\n  for (int i = 0; i < res.size(); ++i) printf(\"%d\", res[i]);\n  puts(\"\");\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Nodes in Link-Cut Tree with Subtree Update (C++)\nDESCRIPTION: This code snippet shows how to connect two nodes in the Link-Cut Tree while updating the subtree size information. It uses makeroot operations and updates the siz2 array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nst.makeroot(x);\nst.makeroot(y);\nst.fa[x] = y;\nst.siz2[y] += st.siz[x];\n```\n\n----------------------------------------\n\nTITLE: High-Precision Subtraction in C++\nDESCRIPTION: Implementation of subtraction for large numbers using array-based storage. Handles borrowing when result would be negative at any position.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid sub(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] - b[i];\n    if (c[i] < 0) {\n      c[i + 1] -= 1;\n      c[i] += 10;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Linear Time Z Function Implementation in Python\nDESCRIPTION: An efficient O(n) implementation of the Z function algorithm in Python. It uses a sliding window technique to avoid redundant comparisons.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/z-func.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef z_function(s):\n    n = len(s)\n    z = [0] * n\n    l, r = 0, 0\n    for i in range(1, n):\n        if i <= r and z[i - l] < r - i + 1:\n            z[i] = z[i - l]\n        else:\n            z[i] = max(0, r - i + 1)\n            while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n                z[i] += 1\n        if i + z[i] - 1 > r:\n            l = i\n            r = i + z[i] - 1\n    return z\n```\n\n----------------------------------------\n\nTITLE: Building a Segment Tree in Python\nDESCRIPTION: This Python function recursively constructs a segment tree from an array. It sets leaf nodes to array values and internal nodes to the sum of their children.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef build(s, t, p):\n    # 对 [s,t] 区间建立线段树,当前根的编号为 p\n    if s == t:\n        d[p] = a[s]\n        return\n    m = s + ((t - s) >> 1)\n    # 移位运算符的优先级小于加减法，所以加上括号\n    # 如果写成 (s + t) >> 1 可能会超出 int 范围\n    build(s, m, p * 2)\n    build(m + 1, t, p * 2 + 1)\n    # 递归对左右区间建树\n    d[p] = d[p * 2] + d[(p * 2) + 1]\n```\n\n----------------------------------------\n\nTITLE: C++ STL队列使用示例\nDESCRIPTION: 演示了如何使用C++ STL中的queue容器，包括创建队列、插入元素、赋值操作和访问队首元素。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/queue.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::queue<int> q1, q2;\n\n// 向 q1 的队尾插入 1\nq1.push(1);\n\n// 将 q1 赋值给 q2\nq2 = q1;\n\n// 输出 q2 的队首元素\nstd::cout << q2.front() << std::endl;\n// 输出: 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Shell Sort in Python\nDESCRIPTION: A Python function that implements the Shell sort algorithm. It uses the same dynamic gap sequence as the C++ version and performs in-place sorting of the input array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/shell-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef shell_sort(array, length):\n    h = 1\n    while h < length / 3:\n        h = int(3 * h + 1)\n    while h >= 1:\n        for i in range(h, length):\n            j = i\n            while j >= h and array[j] < array[j - h]:\n                array[j], array[j - h] = array[j - h], array[j]\n                j -= h\n        h = int(h / 3)\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS using Stack in Python\nDESCRIPTION: This snippet shows how to implement Depth First Search using a list as a stack in Python. It uses an adjacency list to represent the graph and a boolean list to track visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# adj : List[List[int]] 邻接表\n# vis : List[bool] 记录节点是否已经遍历\n\n\ndef dfs(s: int) -> None:\n    stack = [s]  # 用列表来模拟栈，把起点加入栈中\n    vis[s] = True  # 起点被遍历\n\n    while stack:  # 当栈非空时继续执行\n        u = (\n            stack.pop()\n        )  # 拿取并丢弃掉最后一个元素（栈顶的元素），可以理解为走到u这个元素\n\n        for v in adj[u]:  # 对于与u相邻的每个元素v\n            if not vis[v]:  # 如果v在此前没有走过\n                vis[v] = True  # 确保栈里没有重复元素\n                stack.append(v)  # 把v加入栈中\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Tree Theorem in C++\nDESCRIPTION: This C++ code implements the Matrix Tree Theorem to count spanning trees using Gaussian elimination on the Laplacian matrix. It includes a matrix class with methods for initialization, Gaussian elimination, and printing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/matrix-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nconstexpr int MOD = 100000007;\nconstexpr double eps = 1e-7;\n\nstruct matrix {\n  static constexpr int MAXN = 20;\n  int n, m;\n  double mat[MAXN][MAXN];\n\n  matrix() { memset(mat, 0, sizeof(mat)); }\n\n  void print() {\n    cout << \"MATRIX \" << n << \" \" << m << endl;\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        cout << mat[i][j] << \"\\t\";\n      }\n      cout << endl;\n    }\n  }\n\n  void random(int n) {\n    this->n = n;\n    this->m = n;\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++) mat[i][j] = rand() % 100;\n  }\n\n  void initSquare() {\n    this->n = 4;\n    this->m = 4;\n    memset(mat, 0, sizeof(mat));\n    mat[0][1] = mat[0][3] = 1;\n    mat[1][0] = mat[1][2] = 1;\n    mat[2][1] = mat[2][3] = 1;\n    mat[3][0] = mat[3][2] = 1;\n    mat[0][0] = mat[1][1] = mat[2][2] = mat[3][3] = -2;\n    this->n--;  // 去一行\n    this->m--;  // 去一列\n  }\n\n  double gauss() {\n    double ans = 1;\n    for (int i = 0; i < n; i++) {\n      int sid = -1;\n      for (int j = i; j < n; j++)\n        if (abs(mat[j][i]) > eps) {\n          sid = j;\n          break;\n        }\n      if (sid == -1) continue;\n      if (sid != i) {\n        for (int j = 0; j < n; j++) {\n          swap(mat[sid][j], mat[i][j]);\n          ans = -ans;\n        }\n      }\n      for (int j = i + 1; j < n; j++) {\n        double ratio = mat[j][i] / mat[i][i];\n        for (int k = 0; k < n; k++) {\n          mat[j][k] -= mat[i][k] * ratio;\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) ans *= mat[i][i];\n    return abs(ans);\n  }\n};\n\nint main() {\n  srand(1);\n  matrix T;\n  // T.random(2);\n  T.initSquare();\n  T.print();\n  double ans = T.gauss();\n  T.print();\n  cout << ans << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Euclidean Algorithm for GCD in Java\nDESCRIPTION: Two implementations of the Euclidean algorithm for finding the greatest common divisor (GCD) of two integers in Java. This uses the recursive relation gcd(a,b) = gcd(b, a mod b) until b equals zero.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\n// Version 1\npublic int gcd(int a, int b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n// Version 2\npublic int gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying kth Smallest Element with Binary Indexed Tree in C++\nDESCRIPTION: This function uses a Binary Indexed Tree to find the kth smallest element in a range. It employs a power-of-two jumping technique to optimize the search, reducing time complexity to O(log n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nint kth(int k) {\n  int sum = 0, x = 0;\n  for (int i = log2(n); ~i; --i) {\n    x += 1 << i;                    // 尝试扩展\n    if (x >= n || sum + t[x] >= k)  // 如果扩展失败\n      x -= 1 << i;\n    else\n      sum += t[x];\n  }\n  return x + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Matching and Blossom Tracking Variables in C++\nDESCRIPTION: Declares variables used for tracking matching, slack, blossom membership, and other algorithm-specific information. These variables are crucial for implementing the blossom algorithm efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint lab[MAXN * 2 + 1];\n// lab[u]用来记录z_u, lab[b]用来记录z_B\nint match[MAXN * 2 + 1], slack[MAXN * 2 + 1], st[MAXN * 2 + 1],\n    pa[MAXN * 2 + 1];\n// match[x]=y表示(x,y)是匹配，这里x、y可能是花\n// slack[x]=u表示z(x,u)是所有和x相邻的边中最小的那条边\n// 表示节点 x 所在的花是 b。如果 x=b 且 b<=n，则表示 x\n// 是一个普通节点（不属于任何花） 表示在交错树中，节点 v 的父节点是 u\nint flower_from[MAXN * 2 + 1][MAXN + 1], S[MAXN * 2 + 1], vis[MAXN * 2 + 1];\n/*\nflower_from[b][x]=xs表示最大的包含x的b的子花是xs\nx是b里面的一个点，xs是b里面的一朵花或一个点，同时x=xs或x是xs的其中一个点\n*/\n// S[u]={-1:没走过 0:偶点 1:奇点}\n// vis只用在找lca的时候检查是不是走过了\nqueue<int> q;\n// BFS找增广路用的queue\n```\n\n----------------------------------------\n\nTITLE: Implementing Extended Euclidean Algorithm in C++\nDESCRIPTION: Implementation of the Extended Euclidean algorithm (EXGCD) in C++. This algorithm finds integers x and y such that ax + by = gcd(a,b) and returns the greatest common divisor.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nint Exgcd(int a, int b, int &x, int &y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  int d = Exgcd(b, a % b, x, y);\n  int t = x;\n  x = y;\n  y = t - (a / b) * y;\n  return d;\n}\n```\n\n----------------------------------------\n\nTITLE: 一条路径问题完整实现 (C++)\nDESCRIPTION: 一条路径问题的完整解决方案，在N×M棋盘上寻找一条权值最大的路径。处理独立插头的生成与消失，跟踪事件发生次数，适用于求解最大化路径覆盖格点权值和的问题。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/plug/plug_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Pointer-based Treap in C++\nDESCRIPTION: This code snippet demonstrates a comprehensive pointer-based implementation of a Treap data structure. It includes node structure, tree rotations, and operations like insertion, deletion, and various queries (rank, value, predecessor, successor). The implementation uses randomized priorities for balancing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\n// author: (ttzytt)[ttzytt.com]\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n\nstruct Node {\n  Node *ch[2];\n  int val, rank;\n  int rep_cnt;\n  int siz;\n\n  Node(int val) : val(val), rep_cnt(1), siz(1) {\n    ch[0] = ch[1] = nullptr;\n    rank = rand();\n  }\n\n  void upd_siz() {\n    siz = rep_cnt;\n    if (ch[0] != nullptr) siz += ch[0]->siz;\n    if (ch[1] != nullptr) siz += ch[1]->siz;\n  }\n};\n\nclass Treap {\n private:\n  Node *root;\n\n  constexpr static int NIL = -1;  // 用于表示查询的值不存在\n\n  enum rot_type { LF = 1, RT = 0 };\n\n  int q_prev_tmp = 0, q_nex_tmp = 0;\n\n  void _rotate(Node *&cur, rot_type dir) {  // 0为右旋，1为左旋\n    Node *tmp = cur->ch[dir];\n    cur->ch[dir] = tmp->ch[!dir];\n    tmp->ch[!dir] = cur;\n    cur->upd_siz(), tmp->upd_siz();\n    cur = tmp;\n  }\n\n  void _insert(Node *&cur, int val) {\n    if (cur == nullptr) {\n      cur = new Node(val);\n      return;\n    } else if (val == cur->val) {\n      cur->rep_cnt++;\n      cur->siz++;\n    } else if (val < cur->val) {\n      _insert(cur->ch[0], val);\n      if (cur->ch[0]->rank < cur->rank) {\n        _rotate(cur, RT);\n      }\n      cur->upd_siz();\n    } else {\n      _insert(cur->ch[1], val);\n      if (cur->ch[1]->rank < cur->rank) {\n        _rotate(cur, LF);\n      }\n      cur->upd_siz();\n    }\n  }\n\n  void _del(Node *&cur, int val) {\n    if (val > cur->val) {\n      _del(cur->ch[1], val);\n      cur->upd_siz();\n    } else if (val < cur->val) {\n      _del(cur->ch[0], val);\n      cur->upd_siz();\n    } else {\n      if (cur->rep_cnt > 1) {\n        cur->rep_cnt--, cur->siz--;\n        return;\n      }\n      uint8_t state = 0;\n      state |= (cur->ch[0] != nullptr);\n      state |= ((cur->ch[1] != nullptr) << 1);\n      // 00都无，01有左无右，10，无左有右，11都有\n      Node *tmp = cur;\n      switch (state) {\n        case 0:\n          delete cur;\n          cur = nullptr;\n          break;\n        case 1:  // 有左无右\n          cur = tmp->ch[0];\n          delete tmp;\n          break;\n        case 2:  // 有右无左\n          cur = tmp->ch[1];\n          delete tmp;\n          break;\n        case 3:\n          rot_type dir = cur->ch[0]->rank < cur->ch[1]->rank ? RT : LF;\n          _rotate(cur, dir);\n          _del(cur->ch[!dir], val);\n          cur->upd_siz();\n          break;\n      }\n    }\n  }\n\n  int _query_rank(Node *cur, int val) {\n    int less_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n    if (val == cur->val)\n      return less_siz + 1;\n    else if (val < cur->val) {\n      if (cur->ch[0] != nullptr)\n        return _query_rank(cur->ch[0], val);\n      else\n        return 1;\n    } else {\n      if (cur->ch[1] != nullptr)\n        return less_siz + cur->rep_cnt + _query_rank(cur->ch[1], val);\n      else\n        return cur->siz + 1;\n    }\n  }\n\n  int _query_val(Node *cur, int rank) {\n    int less_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n    if (rank <= less_siz)\n      return _query_val(cur->ch[0], rank);\n    else if (rank <= less_siz + cur->rep_cnt)\n      return cur->val;\n    else\n      return _query_val(cur->ch[1], rank - less_siz - cur->rep_cnt);\n  }\n\n  int _query_prev(Node *cur, int val) {\n    if (val <= cur->val) {\n      if (cur->ch[0] != nullptr) return _query_prev(cur->ch[0], val);\n    } else {\n      q_prev_tmp = cur->val;\n      if (cur->ch[1] != nullptr) _query_prev(cur->ch[1], val);\n      return q_prev_tmp;\n    }\n    return NIL;\n  }\n\n  int _query_nex(Node *cur, int val) {\n    if (val >= cur->val) {\n      if (cur->ch[1] != nullptr) return _query_nex(cur->ch[1], val);\n    } else {\n      q_nex_tmp = cur->val;\n      if (cur->ch[0] != nullptr) _query_nex(cur->ch[0], val);\n      return q_nex_tmp;\n    }\n    return NIL;\n  }\n\n public:\n  void insert(int val) { _insert(root, val); }\n\n  void del(int val) { _del(root, val); }\n\n  int query_rank(int val) { return _query_rank(root, val); }\n\n  int query_val(int rank) { return _query_val(root, rank); }\n\n  int query_prev(int val) { return _query_prev(root, val); }\n\n  int query_nex(int val) { return _query_nex(root, val); }\n};\n\nTreap tr;\n\nint main() {\n  srand(0);\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int mode;\n    int num;\n    scanf(\"%d%d\", &mode, &num);\n    switch (mode) {\n      case 1:\n        tr.insert(num);\n        break;\n      case 2:\n        tr.del(num);\n        break;\n      case 3:\n        printf(\"%d\\n\", tr.query_rank(num));\n        break;\n      case 4:\n        printf(\"%d\\n\", tr.query_val(num));\n        break;\n      case 5:\n        printf(\"%d\\n\", tr.query_prev(num));\n        break;\n      case 6:\n        printf(\"%d\\n\", tr.query_nex(num));\n        break;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 0-1 Knapsack Correct Implementation\nDESCRIPTION: Shows the correct implementation of 0-1 knapsack with proper item ordering to prevent multiple use of items. Includes both C++ and Python versions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 1; i <= n; i++)\n  for (int l = W; l >= w[i]; l--) f[l] = max(f[l], f[l - w[i]] + v[i]);\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1, n + 1):\n    for l in range(W, w[i] - 1, -1):\n        f[l] = max(f[l], f[l - w[i]] + v[i])\n```\n\n----------------------------------------\n\nTITLE: Implementing Dijkstra's Algorithm with Naive Approach in Python\nDESCRIPTION: A Python implementation of Dijkstra's algorithm using the naive O(n²) approach. This implementation iteratively finds the unvisited vertex with the minimum distance and relaxes its adjacent edges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nclass Edge:\n    def __init(self, v=0, w=0):\n        self.v = v\n        self.w = w\n\n\ne = [[Edge() for i in range(MAXN)] for j in range(MAXN)]\nINF = 0x3F3F3F3F\n\n\ndef dijkstra(n, s):\n    dis = [INF] * (n + 1)\n    vis = [0] * (n + 1)\n\n    dis[s] = 0\n    for i in range(1, n + 1):\n        u = 0\n        mind = INF\n        for j in range(1, n + 1):\n            if not vis[j] and dis[j] < mind:\n                u = j\n                mind = dis[j]\n        vis[u] = True\n        for ed in e[u]:\n            v, w = ed.v, ed.w\n            if dis[v] > dis[u] + w:\n                dis[v] = dis[u] + w\n```\n\n----------------------------------------\n\nTITLE: Querying Rank by Value in Treap (C++)\nDESCRIPTION: This function queries the rank of a given value in the treap. It uses splitting to find the number of nodes with values less than the given value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nint qrank_by_val(Node* cur, int val) {\n  auto temp = split(cur, val - 1);\n  int ret = (temp.first == nullptr ? 0 : temp.first->siz) + 1;  // 根据定义 + 1\n  root = merge(temp.first, temp.second);  // 拆好了再粘回去\n  return ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Memory Allocation in C++\nDESCRIPTION: Shows how to dynamically allocate memory for an integer and an object using the new operator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint* p = new int(1234);\n/* ... */\ndelete p;\n```\n\nLANGUAGE: C++\nCODE:\n```\nclass A {\n  int a;\n\n public:\n  A(int a_) : a(a_) {}\n};\n\nint main() {\n  A* p = new A(1234);\n  /* ... */\n  delete p;\n}\n```\n\n----------------------------------------\n\nTITLE: Splitting Treap by Value (C++)\nDESCRIPTION: This function splits a treap into two parts based on a given key value. It recursively traverses the tree, creating two separate treaps where all nodes in the first treap have values less than or equal to the key.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\npair<Node *, Node *> split(Node *cur, int key) {\n  if (cur == nullptr) return {nullptr, nullptr};\n  if (cur->val <= key) {\n    // cur 以及它的左子树一定属于分裂后的第一个树\n    auto temp = split(cur->ch[1], key);\n    // 但是它可能有部分右子树也比 key 小\n    cur->ch[1] = temp.first;\n    // 我们把小于 key 的那部分拿出来，作为 cur 的右子树，这样整个 cur 都是小于\n    // key 的 剩下的那部分右子树成为分裂后的第二个 treap\n    cur->upd_siz();\n    // 分裂过后树的大小会变化，需要更新\n    return {cur, temp.second};\n  } else {\n    // 同上\n    auto temp = split(cur->ch[0], key);\n    cur->ch[0] = temp.second;\n    cur->upd_siz();\n    return {temp.first, cur};\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Group Knapsack Implementation\nDESCRIPTION: Implementation of group knapsack where items are grouped and only one item can be selected from each group.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nfor (int k = 1; k <= ts; k++)          // 循环每一组\n  for (int i = m; i >= 0; i--)         // 循环背包容量\n    for (int j = 1; j <= cnt[k]; j++)  // 循环该组的每一个物品\n      if (i >= w[t[k][j]])             // 背包容量充足\n        dp[i] = max(dp[i],\n                    dp[i - w[t[k][j]]] + c[t[k][j]]);  // 像0-1背包一样状态转移\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor k in range(1, ts + 1):  # 循环每一组\n    for i in range(m, -1, -1):  # 循环背包容量\n        for j in range(1, cnt[k] + 1):  # 循环该组的每一个物品\n            if i >= w[t[k][j]]:  # 背包容量充足\n                dp[i] = max(\n                    dp[i], dp[i - w[t[k][j]]] + c[t[k][j]]\n                )  # 像0-1背包一样状态转移\n```\n\n----------------------------------------\n\nTITLE: String Automaton Construction\nDESCRIPTION: Implementation of an automaton builder for string pattern matching. Creates a transition table based on prefix function values to efficiently process pattern searches.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid compute_automaton(string s, vector<vector<int>>& aut) {\n  s += '#';\n  int n = s.size();\n  vector<int> pi = prefix_function(s);\n  aut.assign(n, vector<int>(26));\n  for (int i = 0; i < n; i++) {\n    for (int c = 0; c < 26; c++) {\n      if (i > 0 && 'a' + c != s[i])\n        aut[i][c] = aut[pi[i - 1]][c];\n      else\n        aut[i][c] = i + ('a' + c == s[i]);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modular Exponentiation in C++\nDESCRIPTION: Calculate x^n mod m efficiently using binary exponentiation. Useful for calculating modular multiplicative inverses.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nlong long binpow(long long a, long long b, long long m) {\n  a %= m;\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % m;\n    a = a * a % m;\n    b >>= 1;\n  }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Floyd-Warshall Algorithm Basic Implementation\nDESCRIPTION: Basic implementation of Floyd-Warshall algorithm for finding all-pairs shortest paths in a graph using a 3D array approach. The algorithm has O(N^3) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor (k = 1; k <= n; k++) {\n  for (x = 1; x <= n; x++) {\n    for (y = 1; y <= n; y++) {\n      f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y]);\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor k in range(1, n + 1):\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            f[k][x][y] = min(f[k - 1][x][y], f[k - 1][x][k] + f[k - 1][k][y])\n```\n\n----------------------------------------\n\nTITLE: Parameter Passing with References in C++\nDESCRIPTION: Implementation of swap function using references in C++, which is a more modern and safer alternative to pointers for parameter passing that allows modification of passed variables.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\n// 使用引用的代码\n#include <iostream>\n\nvoid swap(int& x, int& y) {\n  int temp;\n  temp = x;\n  x = y;\n  y = temp;\n}\n\nint main(int argc, char const* argv[]) {\n  int a = 10, b = 20;\n  swap(a, b);\n  std::cout << a << \" \" << b;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hungarian Algorithm in C++\nDESCRIPTION: A C++ implementation of the Hungarian/KM algorithm for finding maximum weight perfect matching in bipartite graphs. The code uses feasible labeling and equality subgraphs to iteratively find augmenting paths.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/bigraph-weight-match.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nstruct hungarian {\n  int n;\n  vector<int> matchx;\n  vector<int> matchy;\n  vector<int> pre;\n  vector<bool> visx;\n  vector<bool> visy;\n  vector<T> lx;\n  vector<T> ly;\n  vector<vector<T>> g;\n  vector<T> slack;\n  T inf;\n  T res;\n  queue<int> q;\n  int org_n;\n  int org_m;\n\n  hungarian(int _n, int _m) {\n    org_n = _n;\n    org_m = _m;\n    n = max(_n, _m);\n    inf = numeric_limits<T>::max();\n    res = 0;\n    g = vector<vector<T>>(n, vector<T>(n));\n    matchx = vector<int>(n, -1);\n    matchy = vector<int>(n, -1);\n    pre = vector<int>(n);\n    visx = vector<bool>(n);\n    visy = vector<bool>(n);\n    lx = vector<T>(n, -inf);\n    ly = vector<T>(n);\n    slack = vector<T>(n);\n  }\n\n  void addEdge(int u, int v, int w) {\n    g[u][v] = max(w, 0);\n  }\n\n  bool check(int v) {\n    visy[v] = true;\n    if (matchy[v] != -1) {\n      q.push(matchy[v]);\n      visx[matchy[v]] = true;\n      return false;\n    }\n    while (v != -1) {\n      matchy[v] = pre[v];\n      swap(v, matchx[pre[v]]);\n    }\n    return true;\n  }\n\n  void bfs(int i) {\n    while (!q.empty()) {\n      q.pop();\n    }\n    q.push(i);\n    visx[i] = true;\n    while (true) {\n      while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v = 0; v < n; v++) {\n          if (!visy[v]) {\n            T delta = lx[u] + ly[v] - g[u][v];\n            if (slack[v] >= delta) {\n              pre[v] = u;\n              if (delta) {\n                slack[v] = delta;\n              } else if (check(v)) {\n                return;\n              }\n            }\n          }\n        }\n      }\n      T a = inf;\n      for (int j = 0; j < n; j++) {\n        if (!visy[j]) {\n          a = min(a, slack[j]);\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        if (visx[j]) {\n          lx[j] -= a;\n        }\n        if (visy[j]) {\n          ly[j] += a;\n        } else {\n          slack[j] -= a;\n        }\n      }\n      for (int j = 0; j < n; j++) {\n        if (!visy[j] && slack[j] == 0 && check(j)) {\n          return;\n        }\n      }\n    }\n  }\n\n  void solve() {\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        lx[i] = max(lx[i], g[i][j]);\n      }\n    }\n\n    for (int i = 0; i < n; i++) {\n      fill(slack.begin(), slack.end(), inf);\n      fill(visx.begin(), visx.end(), false);\n      fill(visy.begin(), visy.end(), false);\n      bfs(i);\n    }\n\n    for (int i = 0; i < n; i++) {\n      if (g[i][matchx[i]] > 0) {\n        res += g[i][matchx[i]];\n      } else {\n        matchx[i] = -1;\n      }\n    }\n    cout << res << \"\\n\";\n    for (int i = 0; i < org_n; i++) {\n      cout << matchx[i] + 1 << \" \";\n    }\n    cout << \"\\n\";\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing a General Suffix Automaton in C++\nDESCRIPTION: This code snippet defines the General Suffix Automaton structure and its construction method. It builds upon the Trie structure and implements the SAM insertion algorithm with modifications for handling multiple strings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/general-sam.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct GSA {\n  int len[MAXN];             // 节点长度\n  int link[MAXN];            // 后缀链接，link\n  int next[MAXN][CHAR_NUM];  // 转移\n  int tot;                   // 节点总数：[0, tot)\n\n  int insertSAM(int last, int c) {\n    int cur = next[last][c];\n    len[cur] = len[last] + 1;\n    int p = link[last];\n    while (p != -1) {\n      if (!next[p][c])\n        next[p][c] = cur;\n      else\n        break;\n      p = link[p];\n    }\n    if (p == -1) {\n      link[cur] = 0;\n      return cur;\n    }\n    int q = next[p][c];\n    if (len[p] + 1 == len[q]) {\n      link[cur] = q;\n      return cur;\n    }\n    int clone = tot++;\n    for (int i = 0; i < CHAR_NUM; ++i)\n      next[clone][i] = len[next[q][i]] != 0 ? next[q][i] : 0;\n    len[clone] = len[p] + 1;\n    while (p != -1 && next[p][c] == q) {\n      next[p][c] = clone;\n      p = link[p];\n    }\n    link[clone] = link[q];\n    link[cur] = clone;\n    link[q] = clone;\n    return cur;\n  }\n\n  void build() {\n    queue<pair<int, int>> q;\n    for (int i = 0; i < 26; ++i)\n      if (next[0][i]) q.push({i, 0});\n    while (!q.empty()) {\n      auto item = q.front();\n      q.pop();\n      auto last = insertSAM(item.second, item.first);\n      for (int i = 0; i < 26; ++i)\n        if (next[last][i]) q.push({i, last});\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bucket Sort in C++\nDESCRIPTION: This C++ implementation of bucket sort includes an insertion sort function for sorting individual buckets. It uses a vector of vectors to represent the buckets and handles the sorting process step by step.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/bucket-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int N = 100010;\n\nint n, w, a[N];\nvector<int> bucket[N];\n\nvoid insertion_sort(vector<int>& A) {\n  for (int i = 1; i < A.size(); ++i) {\n    int key = A[i];\n    int j = i - 1;\n    while (j >= 0 && A[j] > key) {\n      A[j + 1] = A[j];\n      --j;\n    }\n    A[j + 1] = key;\n  }\n}\n\nvoid bucket_sort() {\n  int bucket_size = w / n + 1;\n  for (int i = 0; i < n; ++i) {\n    bucket[i].clear();\n  }\n  for (int i = 1; i <= n; ++i) {\n    bucket[a[i] / bucket_size].push_back(a[i]);\n  }\n  int p = 0;\n  for (int i = 0; i < n; ++i) {\n    insertion_sort(bucket[i]);\n    for (int j = 0; j < bucket[i].size(); ++j) {\n      a[++p] = bucket[i][j];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kahn's Algorithm for Topological Sorting in C++\nDESCRIPTION: This code snippet demonstrates the implementation of Kahn's algorithm for topological sorting. It uses a queue to maintain vertices with no incoming edges and processes them to generate a topological order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/topo.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint n, m;\nvector<int> G[MAXN];\nint in[MAXN];  // 存储每个结点的入度\n\nbool toposort() {\n  vector<int> L;\n  queue<int> S;\n  for (int i = 1; i <= n; i++)\n    if (in[i] == 0) S.push(i);\n  while (!S.empty()) {\n    int u = S.front();\n    S.pop();\n    L.push_back(u);\n    for (auto v : G[u]) {\n      if (--in[v] == 0) {\n        S.push(v);\n      }\n    }\n  }\n  if (L.size() == n) {\n    for (auto i : L) cout << i << ' ';\n    return true;\n  }\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Sort with Divide and Conquer in Python\nDESCRIPTION: A recursive Python implementation of merge sort that follows the divide-and-conquer paradigm. It splits the array, sorts the halves recursively, and then combines them using the merge function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef merge_sort(a, ll, rr):\n    if rr - ll <= 1:\n        return\n    # 分解\n    mid = (rr + ll) // 2\n    merge_sort(a, ll, mid)\n    merge_sort(a, mid, rr)\n    # 合并\n    a[ll:rr] = merge(a[ll:mid], a[mid:rr])\n```\n\n----------------------------------------\n\nTITLE: Optimized LCS Calculation in C++\nDESCRIPTION: An optimized approach to calculate the Longest Common Subsequence (LCS) of two strings A and B. It redefines the state to reduce time complexity from O(nm) to O(m^2 + 26n), where n and m are the lengths of A and B respectively.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/state.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nf_{i,j} = \\begin{cases}\n\\max(f_{i-1,j},f_{i,j-1}) & ,A_i \\neq B_j \\\\\nf_{i-1,j-1}+1 & ,A_i = B_j \n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Implementing CDQ Divide and Conquer for 3D Partial Order Problem in C++\nDESCRIPTION: This code snippet demonstrates how to use CDQ divide and conquer to solve a 3D partial order problem. It sorts points by one dimension, then uses a binary indexed tree to efficiently count points satisfying the other two dimensions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/cdq-divide.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/cdq-divide/cdq-divide_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Linear Time Josephus Problem Solution in C++\nDESCRIPTION: A linear time implementation of the Josephus problem using modular arithmetic. Uses a recursive formula J(n,k) = (J(n-1,k) + k) mod n to calculate the position of the last remaining person.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/josephus.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint josephus(int n, int k) {\n  int res = 0;\n  for (int i = 1; i <= n; ++i) res = (res + k) % i;\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Query with State Compression in AC Automaton\nDESCRIPTION: Optimized query implementation using state compression to eliminate the need for fail pointer traversal. It uses bitwise operations to efficiently track possible match lengths.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nint query(const char t[]) {\n  int u = 0, mx = 0;\n  unsigned st = 1;\n  for (int i = 1; t[i]; i++) {\n    u = tr[u].son[t[i] - 'a'];\n    st <<= 1;  // 往下跳了一位每一位的长度都+1\n    if (tr[u].stat & st) st |= 1, mx = i;\n  }\n  return mx;\n}\n```\n\n----------------------------------------\n\nTITLE: If-Else Statement in C++\nDESCRIPTION: Shows the structure of an if-else statement in C++. It executes one block of code if the condition is true, and another if it's false.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nif (条件) {\n  主体1;\n} else {\n  主体2;\n}\n```\n\n----------------------------------------\n\nTITLE: Building a Segment Tree in C++\nDESCRIPTION: This function recursively builds a segment tree from an array. It initializes leaf nodes with array values and internal nodes with the sum of their children.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid build(int s, int t, int p) {\n  // 对 [s,t] 区间建立线段树,当前根的编号为 p\n  if (s == t) {\n    d[p] = a[s];\n    return;\n  }\n  int m = s + ((t - s) >> 1);\n  // 移位运算符的优先级小于加减法，所以加上括号\n  // 如果写成 (s + t) >> 1 可能会超出 int 范围\n  build(s, m, p * 2), build(m + 1, t, p * 2 + 1);\n  // 递归对左右区间建树\n  d[p] = d[p * 2] + d[(p * 2) + 1];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing lowbit function for Tree Array in C++\nDESCRIPTION: Function to calculate the lowbit of an integer, which is the lowest set bit (1) and all trailing zeros in the binary representation of the number. This is a crucial operation in tree array/Fenwick tree operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint lowbit(int x) {\n  // x 的二进制中，最低位的 1 以及后面所有 0 组成的数。\n  // lowbit(0b01011000) == 0b00001000\n  //          ~~~~^~~~\n  // lowbit(0b01110010) == 0b00000010\n  //          ~~~~~~^~\n  return x & -x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Loser Tree in C++\nDESCRIPTION: This code snippet provides a complete implementation of a loser tree in C++. It includes the tree structure, initialization, adjustment, and functions for merging multiple sorted sequences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/loser-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/ds/code/loser-tree/loser-tree_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Counting Optimal Solutions in 0-1 Knapsack C++\nDESCRIPTION: Implementation for counting the number of optimal solutions in 0-1 knapsack problem. Uses dynamic programming to track both maximum value and count of solutions achieving that value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i = 0; i < N; i++) {\n  for (int j = V; j >= v[i]; j--) {\n    int tmp = std::max(dp[j], dp[j - v[i]] + w[i]);\n    int c = 0;\n    if (tmp == dp[j]) c += cnt[j];                       // 如果从dp[j]转移\n    if (tmp == dp[j - v[i]] + w[i]) c += cnt[j - v[i]];  // 如果从dp[j-v[i]]转移\n    dp[j] = tmp;\n    cnt[j] = c;\n  }\n}\nint max = 0;  // 寻找最优解\nfor (int i = 0; i <= V; i++) {\n  max = std::max(max, dp[i]);\n}\nint res = 0;\nfor (int i = 0; i <= V; i++) {\n  if (dp[i] == max) {\n    res += cnt[i];  // 求和最优解方案数\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterative Binary Exponentiation in Python\nDESCRIPTION: Iterative implementation of binary exponentiation algorithm to calculate a^b efficiently in O(log n) time. Typically faster than recursive version in practice.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef binpow(a, b):\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a\n        a = a * a\n        b >>= 1\n    return res\n```\n\n----------------------------------------\n\nTITLE: Implementing Longest Increasing Subsequence (O(n log n)) in C++\nDESCRIPTION: This function implements an efficient O(n log n) algorithm for finding the length of the longest increasing subsequence using binary search. It maintains an array of potential subsequence endings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/basic.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 0; i < n; ++i) scanf(\"%d\", a + i);\nmemset(dp, 0x1f, sizeof dp);\nmx = dp[0];\nfor (int i = 0; i < n; ++i) {\n  *std::upper_bound(dp, dp + n, a[i]) = a[i];\n}\nans = 0;\nwhile (dp[ans] != mx) ++ans;\n```\n\n----------------------------------------\n\nTITLE: Optimized Pollard-Rho with Brent Cycle Detection in Python\nDESCRIPTION: Python implementation of Pollard-Rho with Brent's cycle detection and multiplication accumulation optimization. This version performs fewer GCD operations by accumulating products and checking periodically.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom random import randint\nfrom math import gcd\n\n\ndef Pollard_Rho(x):\n    c = randint(1, x - 1)\n    s = t = f(0, c, x)\n    goal = val = 1\n    while True:\n        for step in range(1, goal + 1):\n            t = f(t, c, x)\n            val = val * abs(t - s) % x\n            if val == 0:\n                return x  # 如果 val 为 0，退出重新分解\n            if step % 127 == 0:\n                d = gcd(val, x)\n                if d > 1:\n                    return d\n        d = gcd(val, x)\n        if d > 1:\n            return d\n        s = t\n        goal <<= 1\n        val = 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Function with Arrays in C++\nDESCRIPTION: This function merges two sorted arrays into a single sorted array. It compares elements from both arrays, selects the smaller one, and ensures stability by choosing the element from the first array when equal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid merge(const int *a, size_t aLen, const int *b, size_t bLen, int *c) {\n  size_t i = 0, j = 0, k = 0;\n  while (i < aLen && j < bLen) {\n    if (b[j] < a[i]) {  // <!> 先判断 b[j] < a[i]，保证稳定性\n      c[k] = b[j];\n      ++j;\n    } else {\n      c[k] = a[i];\n      ++i;\n    }\n    ++k;\n  }\n  // 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中\n  for (; i < aLen; ++i, ++k) c[k] = a[i];\n  for (; j < bLen; ++j, ++k) c[k] = b[j];\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Memory Allocation in C++\nDESCRIPTION: Demonstrates dynamic memory allocation using new and delete operators for both single elements and arrays.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nlong *pVar = new long; MyClass *ptr = new MyClass(args);\nlong *array = new long[n];\ndelete pVar;\ndelete [] array;\n```\n\n----------------------------------------\n\nTITLE: Implementing Eratosthenes Sieve in C++ and Python\nDESCRIPTION: This code demonstrates the basic implementation of the Eratosthenes Sieve algorithm for finding prime numbers up to a given limit n. The algorithm marks multiples of each prime as composite, leaving unmarked numbers as prime.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) {\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; ++i) is_prime[i] = true;\n  for (int i = 2; i <= n; ++i) {\n    if (is_prime[i]) {\n      prime.push_back(i);\n      if ((long long)i * i > n) continue;\n      for (int j = i * i; j <= n; j += i)\n        // 因为从 2 到 i - 1 的倍数我们之前筛过了，这里直接从 i\n        // 的倍数开始，提高了运行速度\n        is_prime[j] = false;  // 是 i 的倍数的均不是素数\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nprime = []\nis_prime = [False] * N\n\n\ndef Eratosthenes(n):\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, n + 1):\n        is_prime[i] = True\n    for i in range(2, n + 1):\n        if is_prime[i]:\n            prime.append(i)\n            if i * i > n:\n                continue\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n```\n\n----------------------------------------\n\nTITLE: N-ary Tree Traversal Using Recursion in C++\nDESCRIPTION: Recursive function to traverse an N-ary tree, demonstrating how the same recursive pattern can be applied to trees with any number of children per node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  for (auto child : root->children) traverse(child);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kruskal's Algorithm for Minimum Spanning Tree in Python\nDESCRIPTION: This code implements Kruskal's algorithm to find the minimum spanning tree of a graph in Python. It uses a union-find data structure to detect cycles and sorts edges by weight.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n--8<-- \"docs/graph/code/mst/mst_3.py\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Edmonds-Karp Maximum Flow Algorithm in C++\nDESCRIPTION: Implementation of the Edmonds-Karp algorithm for finding maximum flow in a network. Uses BFS to find augmenting paths. Includes edge structure and main algorithm with time complexity O(VE^2).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow/max-flow.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int MAXN = 250;\nconstexpr int INF = 0x3f3f3f3f;\n\nstruct Edge {\n  int from, to, cap, flow;\n\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct EK {\n  int n, m;             // n：点数，m：边数\n  vector<Edge> edges;   // edges：所有边的集合\n  vector<int> G[MAXN];  // G：点 x -> x 的所有边在 edges 中的下标\n  int a[MAXN], p[MAXN];  // a：点 x -> BFS 过程中最近接近点 x 的边给它的最大流\n                         // p：点 x -> BFS 过程中最近接近点 x 的边\n\n  void init(int n) {\n    for (int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  }\n\n  int Maxflow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n      memset(a, 0, sizeof(a));\n      queue<int> Q;\n      Q.push(s);\n      a[s] = INF;\n      while (!Q.empty()) {\n        int x = Q.front();\n        Q.pop();\n        for (int i = 0; i < G[x].size(); i++) {  // 遍历以 x 作为起点的边\n          Edge& e = edges[G[x][i]];\n          if (!a[e.to] && e.cap > e.flow) {\n            p[e.to] = G[x][i];  // G[x][i] 是最近接近点 e.to 的边\n            a[e.to] =\n                min(a[x], e.cap - e.flow);  // 最近接近点 e.to 的边赋给它的流\n            Q.push(e.to);\n          }\n        }\n        if (a[t]) break;  // 如果汇点接受到了流，就退出 BFS\n      }\n      if (!a[t])\n        break;  // 如果汇点没有接受到流，说明源点和汇点不在同一个连通分量上\n      for (int u = t; u != s;\n           u = edges[p[u]].from) {  // 通过 u 追寻 BFS 过程中 s -> t 的路径\n        edges[p[u]].flow += a[t];      // 增加路径上边的 flow 值\n        edges[p[u] ^ 1].flow -= a[t];  // 减小反向路径的 flow 值\n      }\n      flow += a[t];\n    }\n    return flow;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Kth Element Query in Scapegoat Tree in C++\nDESCRIPTION: Finds the kth smallest element in the scapegoat tree. Traverses the tree using the size information stored in each node, handling potential empty nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint getkth(int x, int k) {\n  if (!x) return 0;\n  if (sz[lc[x]] >= k) return getkth(lc[x], k);\n  if (sz[lc[x]] + cnt[x] >= k) return val[x];\n  return getkth(rc[x], k - sz[lc[x]] - cnt[x]);\n}\n\nint kth(int k) { return getkth(rt, k); }\n```\n\n----------------------------------------\n\nTITLE: Divide-and-Conquer Merge Sort Template in C++\nDESCRIPTION: A template showing the structure of the divide-and-conquer approach applied to merge sort, with the three key steps: divide, conquer, and combine.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid merge_sort(一个数组) {\n  if (可以很容易处理) return;\n  merge_sort(左半个数组);\n  merge_sort(右半个数组);\n  merge(左半个数组, 右半个数组);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Trie Node Merging in C++\nDESCRIPTION: Function that merges two trie nodes by combining their weights, XOR values, and recursively merging their children. Handles edge cases where either node is null.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/trie.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nint merge(int a, int b) {\n  if (!a) return b;  // 如果 a 没有这个位置上的结点，返回 b\n  if (!b) return a;  // 如果 b 没有这个位置上的结点，返回 a\n  /*\n    如果 `a`, `b` 都存在，\n    那就把 `b` 的信息合并到 `a` 上。\n  */\n  w[a] = w[a] + w[b];\n  xorv[a] ^= xorv[b];\n  /* 不要使用 maintain()，\n    maintain() 是合并a的两个儿子的信息\n    而这里需要 a b 两个节点进行信息合并\n   */\n  ch[a][0] = merge(ch[a][0], ch[b][0]);\n  ch[a][1] = merge(ch[a][1], ch[b][1]);\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Search with lower_bound and upper_bound in C++\nDESCRIPTION: Demonstrates using lower_bound and upper_bound to find the boundaries of elements equal to a given value in a sorted array. This example shows how to determine ranges of elements less than, equal to, and greater than a specific value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint N = 10, a[] = {1, 1, 2, 4, 5, 5, 7, 7, 9, 9}, x = 5;\nint i = lower_bound(a, a + N, x) - a, j = upper_bound(a, a + N, x) - a;\n// a[0] ~ a[i - 1] 为小于x的元素， a[i] ~ a[j - 1] 为等于x的元素，\n// a[j] ~ a[N - 1] 为大于x的元素\ncout << i << \" \" << j << endl;\n```\n\n----------------------------------------\n\nTITLE: Implementing Simultaneous Bidirectional BFS in Pseudocode\nDESCRIPTION: Pseudocode for implementing a simultaneous bidirectional breadth-first search algorithm. It starts from both the start and end nodes, expanding until the two searches meet.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/bidirectional.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n将开始结点和目标结点加入队列 q\n标记开始结点为 1\n标记目标结点为 2\nwhile (队列 q 不为空)\n{\n  从 q.front() 扩展出新的 s 个结点\n  \n  如果 新扩展出的结点已经被其他数字标记过\n    那么 表示搜索的两端碰撞\n    那么 循环结束\n  \n  如果 新的 s 个结点是从开始结点扩展来的\n    那么 将这个 s 个结点标记为 1 并且入队 q \n    \n  如果 新的 s 个结点是从目标结点扩展来的\n    那么 将这个 s 个结点标记为 2 并且入队 q\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS using Stack in C++\nDESCRIPTION: This snippet demonstrates how to implement Depth First Search using a stack data structure in C++. It uses an adjacency list to represent the graph and a boolean vector to keep track of visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<vector<int>> adj;  // 邻接表\nvector<bool> vis;         // 记录节点是否已经遍历\n\nvoid dfs(int s) {\n  stack<int> st;\n  st.push(s);\n  vis[s] = true;\n\n  while (!st.empty()) {\n    int u = st.top();\n    st.pop();\n\n    for (int v : adj[u]) {\n      if (!vis[v]) {\n        vis[v] = true;  // 确保栈里没有重复元素\n        st.push(v);\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modular Exponentiation in Python\nDESCRIPTION: Calculate x^n mod m efficiently using binary exponentiation. Useful for calculating modular multiplicative inverses.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef binpow(a, b, m):\n    a = a % m\n    res = 1\n    while b > 0:\n        if b & 1:\n            res = res * a % m\n        a = a * a % m\n        b >>= 1\n    return res\n```\n\n----------------------------------------\n\nTITLE: Optimized Integer Reading Function in C++\nDESCRIPTION: An implementation of a fast integer reading function using character-by-character processing with getchar(). This function handles both positive and negative integers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint read() {\n  int x = 0, w = 1;\n  char ch = 0;\n  while (ch < '0' || ch > '9') {  // ch 不是数字时\n    if (ch == '-') w = -1;        // 判断是否为负\n    ch = getchar();               // 继续读入\n  }\n  while (ch >= '0' && ch <= '9') {  // ch 是数字时\n    x = x * 10 + (ch - '0');  // 将新读入的数字「加」在 x 的后面\n    // x 是 int 类型，char 类型的 ch 和 '0' 会被自动转为其对应的\n    // ASCII 码，相当于将 ch 转化为对应数字\n    // 此处也可以使用 (x<<3)+(x<<1) 的写法来代替 x*10\n    ch = getchar();  // 继续读入\n  }\n  return x * w;  // 数字 * 正负号 = 实际数值\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Knapsack DP for Course Selection in C++\nDESCRIPTION: This solution implements a tree knapsack algorithm for a course selection problem where courses have prerequisites. It builds a tree structure based on course dependencies and uses dynamic programming to maximize the total credits while selecting at most m courses.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/tree.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/tree/tree_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Dijkstra's Algorithm with Priority Queue in C++\nDESCRIPTION: An optimized implementation of Dijkstra's algorithm using a priority queue with O(m log m) time complexity. This approach maintains vertices in a priority queue ordered by their current distance from the source.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstruct edge {\n  int v, w;\n};\n\nstruct node {\n  int dis, u;\n\n  bool operator>(const node& a) const { return dis > a.dis; }\n};\n\nvector<edge> e[MAXN];\nint dis[MAXN], vis[MAXN];\npriority_queue<node, vector<node>, greater<node>> q;\n\nvoid dijkstra(int n, int s) {\n  memset(dis, 0x3f, (n + 1) * sizeof(int));\n  memset(vis, 0, (n + 1) * sizeof(int));\n  dis[s] = 0;\n  q.push({0, s});\n  while (!q.empty()) {\n    int u = q.top().u;\n    q.pop();\n    if (vis[u]) continue;\n    vis[u] = 1;\n    for (auto ed : e[u]) {\n      int v = ed.v, w = ed.w;\n      if (dis[v] > dis[u] + w) {\n        dis[v] = dis[u] + w;\n        q.push({dis[v], v});\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Modulo Operation for Powers of Two in C++\nDESCRIPTION: Function that efficiently computes the remainder when dividing by a power of 2 using bit manipulation. This operation is equivalent to taking the last few bits of a number's binary representation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint modPowerOfTwo(int x, int mod) { return x & (mod - 1); }\n```\n\n----------------------------------------\n\nTITLE: Implementing PAM for Palindrome Partition Problem\nDESCRIPTION: This code uses a Palindromic Tree to solve the problem of counting the number of ways to partition a string into palindromes, with additional constraints on the partition structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/pam.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e6 + 5, P = 1e9 + 7;\nchar a[N], s[N << 1];\nint n, last, tot, pos;\nstruct PAM {\n  int len, fail, next[26];\n} t[N << 1];\nlong long dp[N], sum[N << 1], g[N << 1];\nint diff[N << 1], slink[N << 1];\nvoid pam_init() {\n  s[0] = -1;\n  s[1] = -2;\n  t[0].fail = 1;\n  t[1].len = -1;\n  tot = 1;\n}\nvoid extend(int c, int i) {\n  int p = last;\n  while (s[i - t[p].len - 1] != s[i]) p = t[p].fail;\n  if (!t[p].next[c]) {\n    int q = ++tot, f = t[p].fail;\n    t[q].len = t[p].len + 2;\n    while (s[i - t[f].len - 1] != s[i]) f = t[f].fail;\n    t[q].fail = t[f].next[c];\n    t[p].next[c] = q;\n    diff[q] = t[q].len - t[t[q].fail].len;\n    if (diff[q] == diff[t[q].fail])\n      slink[q] = slink[t[q].fail];\n    else\n      slink[q] = t[q].fail;\n  }\n  last = t[p].next[c];\n}\nint solve() {\n  dp[0] = 1;\n  for (int i = 2; i <= n; i += 2) {\n    pos++;\n    extend(s[i] - 'a', i);\n    g[last] = 0;\n    for (int p = last; p > 1; p = slink[p]) {\n      g[p] = (g[p] + dp[pos - (t[slink[p]].len + diff[p]) / 2]) % P;\n      sum[p] = (sum[p] + g[p]) % P;\n      int to = (t[p].len & 1) ? p : t[p].fail;\n      dp[pos] = (dp[pos] + sum[to]) % P;\n    }\n  }\n  return dp[pos];\n}\nint main() {\n  scanf(\"%s\", a + 1);\n  n = strlen(a + 1);\n  for (int i = 1; i <= n; i++) {\n    s[n - i + 1] = s[n + i] = a[i];\n  }\n  n = 2 * n + 1;\n  pam_init();\n  printf(\"%d\\n\", solve());\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Merges Operation for Pairing Heap in C++\nDESCRIPTION: Merges all siblings of a node in a pairing heap using a two-pass method to maintain amortized complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nNode* merges(Node* x) {\n  if (x == nullptr || x->sibling == nullptr)\n    return x;  // 如果该树为空或他没有下一个兄弟，就不需要合并了，return。\n  Node* y = x->sibling;                // y 为 x 的下一个兄弟\n  Node* c = y->sibling;                // c 是再下一个兄弟\n  x->sibling = y->sibling = nullptr;   // 拆散\n  return meld(merges(c), meld(x, y));  // 核心部分\n}\n```\n\n----------------------------------------\n\nTITLE: Cut Vertices Detection Example Implementation\nDESCRIPTION: Example implementation from Luogu P3388 template problem for finding cut vertices in an undirected graph using Tarjan's algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/cut.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/cut/cut_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Function in Python\nDESCRIPTION: A Python implementation of the merge function that combines two sorted lists into a single sorted list. It handles edge cases and uses Python's list operations for efficiency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef merge(a, b):\n    i, j = 0, 0\n    c = []\n    while i < len(a) and j < len(b):\n        # <!> 先判断 b[j] < a[i]，保证稳定性\n        if b[j] < a[i]:\n            c.append(b[j])\n            j += 1\n        else:\n            c.append(a[i])\n            i += 1\n    # 此时一个数组已空，另一个数组非空，将非空的数组并入 c 中\n    c.extend(a[i:])\n    c.extend(b[j:])\n    return c\n```\n\n----------------------------------------\n\nTITLE: Linear Time Z Function Implementation in C++\nDESCRIPTION: An efficient O(n) implementation of the Z function algorithm in C++. It uses a sliding window technique to avoid redundant comparisons.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/z-func.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> z_function(string s) {\n  int n = (int)s.length();\n  vector<int> z(n);\n  for (int i = 1, l = 0, r = 0; i < n; ++i) {\n    if (i <= r && z[i - l] < r - i + 1) {\n      z[i] = z[i - l];\n    } else {\n      z[i] = max(0, r - i + 1);\n      while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];\n    }\n    if (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;\n  }\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Time Complexity in Python\nDESCRIPTION: Illustrates the same concept of constant time complexity as the C++ example, using a fixed loop count in Python.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nN = 100000\nfor i in range(0, N):\n    print(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: Counting Connected 4-Edge Subgraphs in a Graph (C++)\nDESCRIPTION: This code counts the number of connected subgraphs with 4 edges in a graph. It considers various cases such as star graphs, quadrilaterals, triangles with an extra edge, and paths, using a combination of techniques including triangle counting and combinatorics.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/rings-count.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 5, M = 2e5 + 5;\nint n, m;\nll ans;\nint h[N], e[M], ne[M], idx;\nint d[N];\nstruct node {\n  int id, d;\n  bool operator<(const node &t) const {\n    return d == t.d ? id < t.id : d < t.d;\n  }\n} p[N];\nvoid add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(h, -1, sizeof h);\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    add(a, b), add(b, a);\n    d[a]++, d[b]++;\n  }\n  for (int i = 1; i <= n; i++) p[i] = {i, d[i]};\n  sort(p + 1, p + n + 1);\n  ll tri = 0, qua = 0;\n  for (int i = n; i; i--) {\n    int x = p[i].id;\n    for (int j = h[x]; ~j; j = ne[j]) {\n      int y = e[j];\n      if (p[i] < node{y, d[y]}) continue;\n      ll t = 0;\n      for (int k = h[y]; ~k; k = ne[k]) {\n        int z = e[k];\n        if (node{y, d[y]} < node{z, d[z]}) continue;\n        for (int u = h[x]; ~u; u = ne[u])\n          if (e[u] == z) t++;\n      }\n      tri += t;\n      qua += 1ll * t * (t - 1) / 2;\n    }\n  }\n  for (int i = 1; i <= n; i++)\n    if (d[i] >= 4) ans += 1ll * d[i] * (d[i] - 1) * (d[i] - 2) * (d[i] - 3) / 24;\n  ans += qua;\n  ans += tri * 2;\n  for (int i = 1; i <= n; i++)\n    if (d[i] == 2)\n      for (int j = h[i]; ~j; j = ne[j]) {\n        int y = e[j];\n        if (d[y] > 2) ans += 1ll * (d[y] - 1) * (d[y] - 2) / 2;\n      }\n  ans -= tri * 4;\n  ll t = 0;\n  for (int i = 1; i <= n; i++)\n    for (int j = h[i]; ~j; j = ne[j]) {\n      int y = e[j];\n      t += 1ll * (d[i] - 1) * (d[y] - 1);\n    }\n  ans += t / 2 - tri * 3 - qua * 4;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Rank in Range - C++\nDESCRIPTION: Implementation of finding the rank of a value in a given range using segment tree with balanced tree. Returns the count of elements smaller than the target value in the specified range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/balanced-in-seg.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint vec_rank(int k, int l, int r, int x, int y, int t) {\n  if (x <= l && r <= y) {\n    return spy[k].chk_rank(t);\n  }\n  int mid = l + r >> 1;\n  int res = 0;\n  if (x <= mid) res += vec_rank(k << 1, l, mid, x, y, t);\n  if (y > mid) res += vec_rank(k << 1 | 1, mid + 1, r, x, y, t);\n  if (x <= mid && y > mid) res--;\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Logical Operators in C++ Conditionals\nDESCRIPTION: Shows the usage of logical AND and OR operators in conditional statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\nif (conditionA && conditionB) ...\nif (conditionA || conditionB) ...\n```\n\n----------------------------------------\n\nTITLE: Range Sum Query in C++\nDESCRIPTION: Implementation of segment tree range sum query operation that returns the sum of elements in a given range. Handles lazy propagation during query traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nint getsum(int l, int r, int s, int t, int p) {\n  if (l <= s && t <= r) return d[p];\n  int m = s + ((t - s) >> 1);\n  if (b[p]) {\n    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);\n    b[p * 2] += b[p], b[p * 2 + 1] += b[p];\n    b[p] = 0;\n  }\n  int sum = 0;\n  if (l <= m) sum = getsum(l, r, s, m, p * 2);\n  if (r > m) sum += getsum(l, r, m + 1, t, p * 2 + 1);\n  return sum;\n}\n```\n\n----------------------------------------\n\nTITLE: Range Update with Assignment in C++\nDESCRIPTION: Implementation of segment tree range update operation that sets all elements in a given range to a specific value. Uses lazy propagation with an additional flag array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid update(int l, int r, int c, int s, int t, int p) {\n  if (l <= s && t <= r) {\n    d[p] = (t - s + 1) * c, b[p] = c, v[p] = 1;\n    return;\n  }\n  int m = s + ((t - s) >> 1);\n  if (v[p]) {\n    d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m);\n    b[p * 2] = b[p * 2 + 1] = b[p];\n    v[p * 2] = v[p * 2 + 1] = 1;\n    v[p] = 0;\n  }\n  if (l <= m) update(l, r, c, s, m, p * 2);\n  if (r > m) update(l, r, c, m + 1, t, p * 2 + 1);\n  d[p] = d[p * 2] + d[p * 2 + 1];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Du's Sieve for Möbius and Euler Totient Function Prefix Sums in C++\nDESCRIPTION: This code implements Du's sieve algorithm to efficiently calculate prefix sums of the Möbius and Euler totient functions. It uses memoization and number theory techniques to achieve sublinear time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/du.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\n\ntypedef long long ll;\n\nconst int N = 5e6;\n\nint primes[N / 10], cnt;\nbool st[N + 1];\n\nll g[N + 1], sum[N + 1], a[N + 1], b[N + 1];\n\nvoid init() {\n  for (int i = 2; i <= N; ++i) {\n    if (!st[i]) {\n      primes[cnt++] = i;\n      g[i] = -1;\n    }\n    for (int j = 0; primes[j] * i <= N; ++j) {\n      st[primes[j] * i] = true;\n      if (i % primes[j] == 0) {\n        g[i * primes[j]] = g[i];\n        break;\n      }\n      g[i * primes[j]] = -g[i];\n    }\n  }\n  for (int i = 1; i <= N; ++i) {\n    sum[i] = sum[i - 1] + g[i];\n    a[i] = a[i - 1] + i;\n    b[i] = b[i - 1] + 1ll * i * i;\n  }\n}\n\nstd::map<ll, ll> S, P;\n\nll Sum(ll x) {\n  if (x <= N) return sum[x];\n  if (S.count(x)) return S[x];\n  ll res = 1;\n  for (ll l = 2, r; l <= x; l = r + 1) {\n    r = x / (x / l);\n    res -= (r - l + 1) * Sum(x / l);\n  }\n  return S[x] = res;\n}\n\nll Phi(ll x) {\n  if (x <= N) return a[x];\n  if (P.count(x)) return P[x];\n  ll res = x * (x + 1) / 2;\n  for (ll l = 2, r; l <= x; l = r + 1) {\n    r = x / (x / l);\n    res -= (r - l + 1) * Phi(x / l);\n  }\n  return P[x] = res;\n}\n\nint main() {\n  init();\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    ll n;\n    scanf(\"%lld\", &n);\n    printf(\"%lld %lld\\n\", Sum(n), Phi(n));\n  }\n  return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Finding Rank of an Element in BST in C++\nDESCRIPTION: A function to find the rank (position in sorted order) of a value in a Binary Search Tree. It recursively traverses the tree, adding left subtree sizes when moving right. Time complexity is O(h) where h is the tree height.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nint queryRank(TreeNode* root, int v) {\n  if (root == nullptr) return 0;\n  if (root->key == v) return (root->left ? root->left->size : 0) + 1;\n  if (root->key > v) return queryRank(root->left, v);\n  return queryRank(root->right, v) + (root->left ? root->left->size : 0) +\n         root->count;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving 2-SAT TV Show Game Problem with Solution Output in C++\nDESCRIPTION: Implementation of 2-SAT solver using Tarjan's algorithm for a TV show game problem, including output of a feasible solution when one exists.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/2-sat.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/2-sat/2-sat_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Optimal Subarray Calculator with Minimum Value Constraint\nDESCRIPTION: Solution for finding optimal subarray with maximum product of minimum value and length. Implements hoverline method to track expandable boundaries while maintaining minimum value requirements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/hoverline.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/misc/code/hoverline/hoverline_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: String Pattern Matching using KMP\nDESCRIPTION: Implementation of pattern matching in a text string using the KMP algorithm. Returns all occurrences of the pattern in the text.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> find_occurrences(string text, string pattern) {\n  string cur = pattern + '#' + text;\n  int sz1 = text.size(), sz2 = pattern.size();\n  vector<int> v;\n  vector<int> lps = prefix_function(cur);\n  for (int i = sz2 + 1; i <= sz1 + sz2; i++) {\n    if (lps[i] == sz2) v.push_back(i - 2 * sz2);\n  }\n  return v;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef find_occurrences(t, s):\n    cur = s + \"#\" + t\n    sz1, sz2 = len(t), len(s)\n    ret = []\n    lps = prefix_function(cur)\n    for i in range(sz2 + 1, sz1 + sz2 + 1):\n        if lps[i] == sz2:\n            ret.append(i - 2 * sz2)\n    return ret\n```\n\nLANGUAGE: Java\nCODE:\n```\nstatic List<Integer> find_occurrences(String text, String pattern) {\n    String cur = pattern + '#' + text;\n    int sz1 = text.length(), sz2 = pattern.length();\n    List<Integer> v = new ArrayList<>();\n    int[] lps = prefix_function(cur);\n    for (int i = sz2 + 1; i <= sz1 + sz2; i++) {\n\tif (lps[i] == sz2) {\n\t    v.add(i - 2 * sz2);\n\t}\n    }\n    return v;\n}\n```\n\n----------------------------------------\n\nTITLE: High-Precision Square Root Calculation using Newton's Method in Java\nDESCRIPTION: This Java implementation calculates high-precision square roots using Newton's method. It optimizes the initial approximation for large numbers and uses BigInteger for arbitrary-precision arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/newton.md#2025-04-22_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic static BigInteger isqrtNewton(BigInteger n) {\n  BigInteger a = BigInteger.ONE.shiftLeft(n.bitLength() / 2);\n  boolean p_dec = false;\n  for (;;) {\n    BigInteger b = n.divide(a).add(a).shiftRight(1);\n    if (a.compareTo(b) == 0 || a.compareTo(b) < 0 && p_dec)\n      break;\n    p_dec = a.compareTo(b) > 0;\n    a = b;\n  }\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS using Forward Star in C++\nDESCRIPTION: This snippet demonstrates how to implement Depth First Search using a forward star graph representation in C++. It uses a global array to store edges and a boolean array to track visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid dfs(int u) {\n  vis[u] = 1;\n  for (int i = head[u]; i; i = e[i].x) {\n    if (!vis[e[i].t]) {\n      dfs(v);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Longest Increasing Subsequence (O(n log n)) in Python\nDESCRIPTION: This function implements an efficient O(n log n) algorithm for finding the length of the longest increasing subsequence using binary search. It maintains a list of potential subsequence endings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/basic.md#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndp = [0x1F1F1F1F] * MAXN\nmx = dp[0]\nfor i in range(0, n):\n    bisect.insort_left(dp, a[i], 0, len(dp))\nans = 0\nwhile dp[ans] != mx:\n    ans += 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Sieve Algorithms with Different Data Structures in C++\nDESCRIPTION: Benchmark code comparing performance of Eratosthenes and Euler sieve algorithms using C-style arrays, vector<bool>, and bitset. The code tests both versions that store and don't store prime numbers, using Google Benchmark framework.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/bitset.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <benchmark/benchmark.h>\n#include <bits/stdc++.h>\nusing namespace std;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n\n#define ERATOSTHENES_STORAGE_PRIME\n#define ENABLE_EULER\nconstexpr u32 N = 5e7 + 1;\n\n#ifndef ERATOSTHENES_STORAGE_PRIME\n\nvoid Eratosthenes_CArray(benchmark::State &state) {\n  static bool is_prime[N];\n  for (auto _ : state) {\n    fill(is_prime, is_prime + N, true);\n    is_prime[0] = is_prime[1] = false;\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime[j] = false;\n    benchmark::DoNotOptimize(0);\n  }\n}\n\nBENCHMARK(Eratosthenes_CArray);\n\nvoid Eratosthenes_vector(benchmark::State &state) {\n  static vector<bool> is_prime(N);\n  for (auto _ : state) {\n    fill(is_prime.begin(), is_prime.end(), true);\n    is_prime[0] = is_prime[1] = false;\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime[j] = false;\n    benchmark::DoNotOptimize(0);\n  }\n}\n\nBENCHMARK(Eratosthenes_vector);\n\nvoid Eratosthenes_bitset(benchmark::State &state) {\n  static bitset<N> is_prime;\n  for (auto _ : state) {\n    is_prime.set();\n    is_prime.reset(0);\n    is_prime.reset(1);\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime.reset(j);\n    benchmark::DoNotOptimize(0);\n  }\n}\n\nBENCHMARK(Eratosthenes_bitset);\n\n#else\n\nvoid Eratosthenes_CArray_sp(benchmark::State &state) {\n  static bool is_prime[N];\n  for (auto _ : state) {\n    vector<u32> prime;\n    fill(is_prime, is_prime + N, true);\n    is_prime[0] = is_prime[1] = false;\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime[j] = false;\n    for (u32 i = 2; i < N; ++i)\n      if (is_prime[i]) prime.push_back(i);\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Eratosthenes_CArray_sp);\n\nvoid Eratosthenes_vector_sp(benchmark::State &state) {\n  static vector<bool> is_prime(N);\n  for (auto _ : state) {\n    vector<u32> prime;\n    fill(is_prime.begin(), is_prime.end(), true);\n    is_prime[0] = is_prime[1] = false;\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime[j] = false;\n    for (u32 i = 2; i < N; ++i)\n      if (is_prime[i]) prime.push_back(i);\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Eratosthenes_vector_sp);\n\nvoid Eratosthenes_bitset_sp(benchmark::State &state) {\n  static bitset<N> is_prime;\n  for (auto _ : state) {\n    vector<u32> prime;\n    is_prime.set();\n    is_prime.reset(0);\n    is_prime.reset(1);\n    for (u32 i = 2; (u64)i * i < N; ++i)\n      if (is_prime[i])\n        for (u32 j = i * i; j < N; j += i) is_prime.reset(j);\n    for (u32 i = 2; i < N; ++i)\n      if (is_prime[i]) prime.push_back(i);\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Eratosthenes_bitset_sp);\n\n#endif\n\n#ifdef ENABLE_EULER\n\nvoid Euler_CArray(benchmark::State &state) {\n  static bool not_prime[N];\n  for (auto _ : state) {\n    vector<u32> prime;\n    fill(not_prime, not_prime + N, false);\n    not_prime[0] = not_prime[1] = true;\n    for (u32 i = 2; i < N; ++i) {\n      if (!not_prime[i]) prime.push_back(i);\n      for (u32 pri_j : prime) {\n        if (i * pri_j >= N) break;\n        not_prime[i * pri_j] = true;\n        if (i % pri_j == 0) break;\n      }\n    }\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Euler_CArray);\n\nvoid Euler_vector(benchmark::State &state) {\n  static vector<bool> not_prime(N);\n  for (auto _ : state) {\n    vector<u32> prime;\n    fill(not_prime.begin(), not_prime.end(), false);\n    not_prime[0] = not_prime[1] = true;\n    for (u32 i = 2; i < N; ++i) {\n      if (!not_prime[i]) prime.push_back(i);\n      for (u32 pri_j : prime) {\n        if (i * pri_j >= N) break;\n        not_prime[i * pri_j] = true;\n        if (i % pri_j == 0) break;\n      }\n    }\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Euler_vector);\n\nvoid Euler_bitset(benchmark::State &state) {\n  static bitset<N> not_prime;\n  for (auto _ : state) {\n    vector<u32> prime;\n    not_prime.reset();\n    not_prime.set(0);\n    not_prime.set(1);\n    for (u32 i = 2; i < N; ++i) {\n      if (!not_prime[i]) prime.push_back(i);\n      for (u32 pri_j : prime) {\n        if (i * pri_j >= N) break;\n        not_prime.set(i * pri_j);\n        if (i % pri_j == 0) break;\n      }\n    }\n    benchmark::DoNotOptimize(prime);\n  }\n}\n\nBENCHMARK(Euler_bitset);\n\n#endif\n\nstatic void Noop(benchmark::State &state) {\n  for (auto _ : state) benchmark::DoNotOptimize(0);\n}\n\nBENCHMARK(Noop);\nBENCHMARK_MAIN();\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree DP for Employee Party Problem in C++\nDESCRIPTION: This code demonstrates tree DP for solving a problem where we need to maximize happiness by inviting employees to a party, with the constraint that if a manager attends, their direct subordinates cannot attend. The solution uses a two-state DP approach with recursive DFS traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/tree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/tree/tree_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Interval Reversal in Splay Tree using C++\nDESCRIPTION: This function performs an interval reversal operation on a Splay tree. It locates the interval endpoints, isolates the interval as a subtree, applies the reversal, and updates the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/splay.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/splay/splay-2.cpp:69:76\"\n```\n\n----------------------------------------\n\nTITLE: Tree Rotation Operations in C++\nDESCRIPTION: Implementation of left and right rotation operations for balancing Binary Search Trees. These operations maintain the BST property while adjusting tree height. The functions update any necessary height information after rotation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_8\n\nLANGUAGE: c++\nCODE:\n```\nTreeNode* rotateLeft(TreeNode* root) {\n  TreeNode* newRoot = root->right;\n  root->right = newRoot->left;\n  newRoot->left = root;\n  // 更新相关节点的信息\n  updateHeight(root);\n  updateHeight(newRoot);\n  return newRoot;  // 返回新的根节点\n}\n\nTreeNode* rotateRight(TreeNode* root) {\n  TreeNode* newRoot = root->left;\n  root->left = newRoot->right;\n  newRoot->right = root;\n  updateHeight(root);\n  updateHeight(newRoot);\n  return newRoot;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic BigInteger Operations in Java\nDESCRIPTION: This code snippet demonstrates various basic operations using the BigInteger class in Java, including absolute value, negation, addition, subtraction, multiplication, division, remainder, modulus, and exponentiation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static BigInteger a, b;\n\n    static void abs() {\n        out.println(\"abs:\");\n        a = new BigInteger(\"-123\");\n        out.println(a.abs());  // 输出 123 \n        a = new BigInteger(\"123\");\n        out.println(a.abs());  // 输出 123 \n    }\n\n    static void negate() {\n        out.println(\"negate:\");\n        a = new BigInteger(\"-123\");\n        out.println(a.negate());  // 输出 123 \n        a = new BigInteger(\"123\");\n        out.println(a.negate());  // 输出 -123 \n    }\n\n    static void add() {\n        out.println(\"add:\");\n        a = new BigInteger(\"123\");\n        b = new BigInteger(\"123\");\n        out.println(a.add(b));  // 输出 246 \n    }\n\n    static void subtract() {\n        out.println(\"subtract:\");\n        a = new BigInteger(\"123\");\n        b = new BigInteger(\"123\");\n        out.println(a.subtract(b));  // 输出 0 \n    }\n\n    static void multiply() {\n        out.println(\"multiply:\");\n        a = new BigInteger(\"12\");\n        b = new BigInteger(\"12\");\n        out.println(a.multiply(b));  // 输出 144 \n    }\n\n    static void divide() {\n        out.println(\"divide:\");\n        a = new BigInteger(\"12\");\n        b = new BigInteger(\"11\");\n        out.println(a.divide(b));  // 输出 1 \n    }\n\n    static void remainder() {\n        out.println(\"remainder:\");\n        a = new BigInteger(\"12\");\n        b = new BigInteger(\"10\");\n        out.println(a.remainder(b));  // 输出 2 \n        a = new BigInteger(\"-12\");\n        b = new BigInteger(\"10\");\n        out.println(a.remainder(b));  // 输出 -2 \n    }\n\n    static void mod() {\n        out.println(\"mod:\");\n        a = new BigInteger(\"12\");\n        b = new BigInteger(\"10\");\n        out.println(a.mod(b));  // 输出 2 \n        a = new BigInteger(\"-12\");\n        b = new BigInteger(\"10\");\n        out.println(a.mod(b));  // 输出 8 \n    }\n\n    static void pow() {\n        out.println(\"pow:\");\n        a = new BigInteger(\"2\");\n        out.println(a.pow(10));  // 输出 1024 \n    }\n\n    public static void main(String[] args) {\n        abs();\n        negate();\n        add();\n        subtract();\n        multiply();\n        divide();\n        remainder();\n        mod();\n        pow();\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Node from Treap (C++)\nDESCRIPTION: This function deletes a node with a given value from the treap. It uses splitting and merging operations to maintain the treap properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nvoid del(int val) {\n  auto temp = split(root, val);\n  auto l_tr = split(temp.first, val - 1);\n  if (l_tr.second->cnt > 1) {\n    // 如果这个节点的重复次数大于 1，减小即可\n    l_tr.second->cnt--;\n    l_tr.second->upd_siz();\n    l_tr.first = merge(l_tr.first, l_tr.second);\n  } else {\n    if (temp.first == l_tr.second) {\n      // 有可能整个 T_1 只有这个节点，所以也需要把这个点设成 null 来标注已经删除\n      temp.first = nullptr;\n    }\n    delete l_tr.second;\n    l_tr.second = nullptr;\n  }\n  root = merge(l_tr.first, temp.second);\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Trie Operations for Tree Value Processing\nDESCRIPTION: Complete implementation of trie operations including node creation, maintenance, insertion, merging, and traversal for processing tree node values and computing XOR sums\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/trie.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int _ = 526010;\nint n;\nint V[_];\nint debug = 0;\n\nnamespace trie {\nconstexpr int MAXH = 21;\nint ch[_ * (MAXH + 1)][2], w[_ * (MAXH + 1)], xorv[_ * (MAXH + 1)];\nint tot = 0;\n\nint mknode() {\n  ++tot;\n  ch[tot][1] = ch[tot][0] = w[tot] = xorv[tot] = 0;\n  return tot;\n}\n\nvoid maintain(int o) {\n  w[o] = xorv[o] = 0;\n  if (ch[o][0]) {\n    w[o] += w[ch[o][0]];\n    xorv[o] ^= xorv[ch[o][0]] << 1;\n  }\n  if (ch[o][1]) {\n    w[o] += w[ch[o][1]];\n    xorv[o] ^= (xorv[ch[o][1]] << 1) | (w[ch[o][1]] & 1);\n  }\n  w[o] = w[o] & 1;\n}\n\nvoid insert(int &o, int x, int dp) {\n  if (!o) o = mknode();\n  if (dp > MAXH) return (void)(w[o]++);\n  insert(ch[o][x & 1], x >> 1, dp + 1);\n  maintain(o);\n}\n\nint merge(int a, int b) {\n  if (!a) return b;\n  if (!b) return a;\n  w[a] = w[a] + w[b];\n  xorv[a] ^= xorv[b];\n  ch[a][0] = merge(ch[a][0], ch[b][0]);\n  ch[a][1] = merge(ch[a][1], ch[b][1]);\n  return a;\n}\n\nvoid addall(int o) {\n  swap(ch[o][0], ch[o][1]);\n  if (ch[o][0]) addall(ch[o][0]);\n  maintain(o);\n}\n}  // namespace trie\n\nint rt[_];\nlong long Ans = 0;\nvector<int> E[_];\n\nvoid dfs0(int o) {\n  for (int i = 0; i < E[o].size(); i++) {\n    int node = E[o][i];\n    dfs0(node);\n    rt[o] = trie::merge(rt[o], rt[node]);\n  }\n  trie::addall(rt[o]);\n  trie::insert(rt[o], V[o], 0);\n  Ans += trie::xorv[rt[o]];\n}\n\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) V[i] = read();\n  for (int i = 2; i <= n; i++) E[read()].push_back(i);\n  dfs0(1);\n  printf(\"%lld\", Ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Extended Euclidean Algorithm in C++\nDESCRIPTION: This function implements the Extended Euclidean Algorithm iteratively. It computes the greatest common divisor (GCD) of two integers a and b, and finds coefficients x and y such that ax + by = gcd(a,b).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nint gcd(int a, int b, int& x, int& y) {\n  x = 1, y = 0;\n  int x1 = 0, y1 = 1, a1 = a, b1 = b;\n  while (b1) {\n    int q = a1 / b1;\n    tie(x, x1) = make_tuple(x1, x - q * x1);\n    tie(y, y1) = make_tuple(y1, y - q * y1);\n    tie(a1, b1) = make_tuple(b1, a1 - q * b1);\n  }\n  return a1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Euclidean Algorithm for GCD in C++\nDESCRIPTION: Two implementations of the Euclidean algorithm for finding the greatest common divisor (GCD) of two integers in C++. This uses the recursive relation gcd(a,b) = gcd(b, a mod b) until b equals zero.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Version 1\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\n// Version 2\nint gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b); }\n```\n\n----------------------------------------\n\nTITLE: Main Matching Function in General Weighted Matching Algorithm (C++)\nDESCRIPTION: Implements the main matching function that orchestrates the entire general weighted matching algorithm. This function handles the breadth-first search, dual variable updates, and blossom operations to find a maximum weight perfect matching in the graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nbool matching() {\n  memset(S + 1, -1, sizeof(int) * n_x);\n  memset(slack + 1, 0, sizeof(int) * n_x);\n  q = queue<int>();  // 把queue清空\n  for (int x = 1; x <= n_x; ++x) {\n    if (st[x] == x && !match[x]) {\n      // 把所有非匹配点加入queue里面，并设为偶点\n      pa[x] = 0;\n      S[x] = 0;\n      q_push(x);\n    }\n  }\n  if (q.empty()) return false;  // 所有点都有匹配了\n  for (;;) {\n    while (q.size()) {\n      // BFS\n      int u = q.front();\n      q.pop();\n      if (S[st[u]] == 1) continue;\n      for (int v = 1; v <= n; ++v) {\n        if (g[u][v].w > 0 && st[u] != st[v]) {\n          if (e_delta(g[u][v]) == 0) {\n            if (on_found_edge(g[u][v])) return true;\n          } else\n            update_slack(u, st[v]);\n        }\n      }\n    }\n    // 修改lab值\n    int d = INF;\n    for (int u = 1; u <= n; ++u) {\n      // 这是为了防止出现lab<0的情况发生\n      // 只要有任何一个lab[u]=0就结束程序\n      if (S[st[u]] == 0) d = min(d, lab[u]);\n    }\n    for (int b = n + 1; b <= n_x; ++b) {\n      if (st[b] == b && S[b] == 1) d = min(d, lab[b] / 2);\n    }\n    for (int x = 1; x <= n_x; ++x)\n      if (st[x] == x && slack[x]) {\n        if (S[x] == -1)\n          d = min(d, e_delta(g[slack[x]][x]));\n        else if (S[x] == 0)\n          d = min(d, e_delta(g[slack[x]][x]) / 2);\n      }\n    for (int u = 1; u <= n; ++u) {\n      if (S[st[u]] == 0) {\n        if (lab[u] == d) return false;\n        // 如果lab[u]=0就直接结束程序\n        lab[u] -= d;\n      } else if (S[st[u]] == 1)\n        lab[u] += d;\n    }\n    for (int b = n + 1; b <= n_x; ++b) {\n      if (st[b] == b) {\n        if (S[st[b]] == 0)\n          lab[b] += d * 2;\n        else if (S[st[b]] == 1)\n          lab[b] -= d * 2;\n      }\n    }\n    q = queue<int>();  // 把queue清空\n    for (int x = 1; x <= n_x; ++x) {\n      // 检查看看有没有增广路径产生\n      if (st[x] == x && slack[x] && st[slack[x]] != x &&\n          e_delta(g[slack[x]][x]) == 0)\n        if (on_found_edge(g[slack[x]][x])) return true;\n    }\n    for (int b = n + 1; b <= n_x; ++b) {\n      // EXPAND的操作，把所有lab[b]=0的奇花拆开\n      if (st[b] == b && S[b] == 1 && lab[b] == 0) expand_blossom(b);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Histogram Rectangle Area Calculator using Hoverline Method\nDESCRIPTION: Implementation of hoverline method to find largest rectangle area in a histogram. Uses linear time complexity by efficiently tracking left and right expansion boundaries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/hoverline.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/misc/code/hoverline/hoverline_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive FFT in C++\nDESCRIPTION: This snippet shows a recursive implementation of the Fast Fourier Transform algorithm. It uses complex numbers and handles both DFT and IDFT based on the 'rev' parameter.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fft.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <complex>\n\nusing Comp = std::complex<double>;  // STL complex\n\nconstexpr Comp I(0, 1);  // i\nconstexpr int MAX_N = 1 << 20;\n\nComp tmp[MAX_N];\n\n// rev=1,DFT; rev=-1,IDFT\nvoid DFT(Comp* f, int n, int rev) {\n  if (n == 1) return;\n  for (int i = 0; i < n; ++i) tmp[i] = f[i];\n  // 偶数放左边，奇数放右边\n  for (int i = 0; i < n; ++i) {\n    if (i & 1)\n      f[n / 2 + i / 2] = tmp[i];\n    else\n      f[i / 2] = tmp[i];\n  }\n  Comp *g = f, *h = f + n / 2;\n  // 递归 DFT\n  DFT(g, n / 2, rev), DFT(h, n / 2, rev);\n  // cur 是当前单位复根，对于 k = 0 而言，它对应的单位复根 omega^0_n = 1。\n  // step 是两个单位复根的差，即满足 omega^k_n = step*omega^{k-1}*n，\n  // 定义等价于 exp(I*(2*M_PI/n*rev))\n  Comp cur(1, 0), step(cos(2 * M_PI / n), sin(2 * M_PI * rev / n));\n  for (int k = 0; k < n / 2;\n       ++k) {  // F(omega^k_n) = G(omega^k*{n/2}) + omega^k*n\\*H(omega^k*{n/2})\n    tmp[k] = g[k] + cur * h[k];\n    // F(omega^{k+n/2}*n) = G(omega^k*{n/2}) - omega^k_n*H(omega^k\\_{n/2})\n    tmp[k + n / 2] = g[k] - cur * h[k];\n    cur *= step;\n  }\n  for (int i = 0; i < n; ++i) f[i] = tmp[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Matrix Determinant using Gaussian Elimination in C++\nDESCRIPTION: Implementation of determinant calculation using Gaussian elimination with a time complexity of O(n^3). Handles edge cases and includes pivoting for numerical stability.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/gauss.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr double EPS = 1E-9;\nint n;\nvector<vector<double>> a(n, vector<double>(n));\n\ndouble det = 1;\nfor (int i = 0; i < n; ++i) {\n  int k = i;\n  for (int j = i + 1; j < n; ++j)\n    if (abs(a[j][i]) > abs(a[k][i])) k = j;\n  if (abs(a[k][i]) < EPS) {\n    det = 0;\n    break;\n  }\n  swap(a[i], a[k]);\n  if (i != k) det = -det;\n  det *= a[i][i];\n  for (int j = i + 1; j < n; ++j) a[i][j] /= a[i][i];\n  for (int j = 0; j < n; ++j)\n    if (j != i && abs(a[j][i]) > EPS)\n      for (int k = i + 1; k < n; ++k) a[j][k] -= a[i][k] * a[j][i];\n}\n\ncout << det;\n```\n\n----------------------------------------\n\nTITLE: Knuth Optimization Core Implementation\nDESCRIPTION: Core implementation of Knuth's optimization algorithm for interval merging problems with O(n^2) complexity. Shows how to utilize bounded decision space.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int len = 2; len <= n; ++len)  // 枚举区间长度\n  for (int j = 1, i = len; i <= n; ++j, ++i) {\n    // 枚举长度为len的所有区间\n    f[j][i] = INF;\n    for (int k = opt[j][i - 1]; k <= opt[j + 1][i]; ++k)\n      if (f[j][i] > f[j][k] + f[k + 1][i] + w(j, i)) {\n        f[j][i] = f[j][k] + f[k + 1][i] + w(j, i);  // 更新状态值\n        opt[j][i] = k;  // 更新（最小）最优决策点\n      }\n  }\n```\n\nLANGUAGE: python\nCODE:\n```\nfor len in range(2, n + 1):  # 枚举区间长度\n    for i in range(len, n + 1):\n        # 枚举长度为len的所有区间\n        j = i - len + 1\n        f[j][i] = INF\n        for k in range(opt[j][i - 1], opt[j + 1][i] + 1):\n            if f[j][i] > f[j][k] + f[k + 1][i] + w(j, i):\n                f[j][i] = f[j][k] + f[k + 1][i] + w(j, i)  # 更新状态值\n                opt[j][i] = k  # 更新（最小）最优决策点\n```\n\n----------------------------------------\n\nTITLE: Implementing Euler's Totient Function in C++\nDESCRIPTION: Calculates Euler's totient function value for a given number n by finding its prime factors. The function returns the count of numbers less than n that are coprime to n. Uses trial division method for prime factorization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/euler-totient.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n\nint euler_phi(int n) {\n  int ans = n;\n  for (int i = 2; i * i <= n; i++)\n    if (n % i == 0) {\n      ans = ans / i * (i - 1);\n      while (n % i == 0) n /= i;\n    }\n  if (n > 1) ans = ans / n * (n - 1);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Lambda with std::find_if in C++\nDESCRIPTION: This example shows how to use a lambda expression with std::find_if to locate the first element in a vector that is greater than a specific value (3 in this case).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<int> v = {1, 2, 3, 4, 5};\nauto it = std::find_if(v.begin(), v.end(), [](int a) { return a > 3; });\n```\n\n----------------------------------------\n\nTITLE: Implementing Counting Sort Algorithm in C++\nDESCRIPTION: This code snippet demonstrates the implementation of the counting sort algorithm in C++. It takes an input array and sorts it in non-decreasing order using counting sort technique.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/counting-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/basic/code/counting-sort/counting-sort_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Counting Triangles in a Graph using Edge Orientation (C++)\nDESCRIPTION: This code implements an algorithm to count triangles in a graph by orienting edges based on vertex degrees. It iterates through directed edges and checks for the existence of triangles, with a time complexity of O(m√m).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/rings-count.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, M = 2e5 + 5;\nint n, m, ans;\nint h[N], e[M], ne[M], idx;\nint d[N];\nvoid add(int a, int b) {\n  e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(h, -1, sizeof h);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    d[u]++, d[v]++;\n  }\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    if (d[u] < d[v] || (d[u] == d[v] && u < v))\n      add(u, v);\n    else\n      add(v, u);\n  }\n  for (int u = 1; u <= n; u++)\n    for (int i = h[u]; ~i; i = ne[i]) {\n      int v = e[i];\n      for (int j = h[v]; ~j; j = ne[j]) {\n        int w = e[j];\n        for (int k = h[u]; ~k; k = ne[k])\n          if (e[k] == w) ans++;\n      }\n    }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Working with std::tuple in C++\nDESCRIPTION: Demonstrates creating and accessing elements of a std::tuple, which can store multiple values of different types. Shows use of std::get and std::tuple_size.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <tuple>\n#include <vector>\n\nconstexpr auto expr = 1 + 1 * 4 - 5 - 1 + 4;\n\nint main() {\n  std::vector<int> vec = {1, 9, 2, 6, 0};\n  std::tuple<int, int, std::string, std::vector<int>> tup =\n      std::make_tuple(817, 114, \"514\", vec);\n  std::cout\n      << std::tuple_size_v<decltype(tup)> << std::endl;  // Number of types in tuple\n\n  for (auto i : std::get<expr>(tup)) std::cout << i << \" \";\n  // std::get<> requires compile-time constant in angle brackets\n  // expr constant's value is 3, note that tuple's first element is indexed 0,\n  // so we std::get a std::vector<int>\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Ternary Search Implementation in C++\nDESCRIPTION: Implementation of the ternary search algorithm for finding the extremum (minimum or maximum) of a unimodal function. This example uses two points within the interval to narrow down the search range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/binary.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (r - l > eps) {\n  mid = (l + r) / 2;\n  lmid = mid - eps;\n  rmid = mid + eps;\n  if (f(lmid) < f(rmid))\n    r = mid;\n  else\n    l = mid;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Huffman Tree Construction in C++\nDESCRIPTION: Creates a Huffman tree from an array of weights. Uses a forest array to store nodes and iteratively combines the two smallest weights until a single tree remains.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/huffman-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct HNode {\n  int weight;\n  HNode *lchild, *rchild;\n};\n\nusing Htree = HNode*;\n\nHtree createHuffmanTree(int arr[], int n) {\n  Htree forest[N];\n  Htree root = NULL;\n  for (int i = 0; i < n; i++) {\n    Htree temp;\n    temp = (Htree)malloc(sizeof(HNode));\n    temp->weight = arr[i];\n    temp->lchild = temp->rchild = NULL;\n    forest[i] = temp;\n  }\n\n  for (int i = 1; i < n; i++) {\n    int minn = -1, minnSub;\n    for (int j = 0; j < n; j++) {\n      if (forest[j] != NULL && minn == -1) {\n        minn = j;\n        continue;\n      }\n      if (forest[j] != NULL) {\n        minnSub = j;\n        break;\n      }\n    }\n\n    for (int j = minnSub; j < n; j++) {\n      if (forest[j] != NULL) {\n        if (forest[j]->weight < forest[minn]->weight) {\n          minnSub = minn;\n          minn = j;\n        } else if (forest[j]->weight < forest[minnSub]->weight) {\n          minnSub = j;\n        }\n      }\n    }\n\n    root = (Htree)malloc(sizeof(HNode));\n    root->weight = forest[minn]->weight + forest[minnSub]->weight;\n    root->lchild = forest[minn];\n    root->rchild = forest[minnSub];\n\n    forest[minn] = root;\n    forest[minnSub] = NULL;\n  }\n  return root;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Decomposition for Color Queries in C++\nDESCRIPTION: This code implements a tree decomposition technique to efficiently answer color queries on a tree. It uses bitsets to precompute color information for key nodes and optimizes query processing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/tree-decompose.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/tree-decompose/tree-decompose_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Optimized Prefix Function Implementation\nDESCRIPTION: An optimized version of prefix function calculation using the observation that adjacent prefix function values differ by at most 1. Time complexity O(n^2).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++)\n    for (int j = pi[i - 1] + 1; j >= 0; j--)\n      if (s.substr(0, j) == s.substr(i - j + 1, j)) {\n        pi[i] = j;\n        break;\n      }\n  return pi;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        for j in range(pi[i - 1] + 1, -1, -1):\n            if s[0:j] == s[i - j + 1 : i + 1]:\n                pi[i] = j\n                break\n    return pi\n```\n\nLANGUAGE: Java\nCODE:\n```\nstatic int[] prefix_function(String s) {\n    int n = s.length();\n    int[] pi = new int[n];\n    for (int i = 1; i < n; i++) {\n\tfor (int j = pi[i - 1] + 1; j >= 0; j--) {\n\t    if (s.substring(0, j).equals(s.substring(i - j + 1, i + 1))) {\n\t\tpi[i] = j;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return pi;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Absolute Center of Graph in C++\nDESCRIPTION: This code snippet implements the algorithm to find the absolute center of a graph using Floyd-Warshall for all-pairs shortest paths and then checking both nodes and edges for the center position.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mdst.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbool cmp(int a, int b) { return val[a] < val[b]; }\n\nvoid Floyd() {\n  for (int k = 1; k <= n; k++)\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nvoid solve() {\n  Floyd();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      rk[i][j] = j;\n      val[j] = d[i][j];\n    }\n    sort(rk[i] + 1, rk[i] + 1 + n, cmp);\n  }\n  int ans = INF;\n  // 图的绝对中心可能在结点上\n  for (int i = 1; i <= n; i++) ans = min(ans, d[i][rk[i][n]] * 2);\n  // 图的绝对中心可能在边上\n  for (int i = 1; i <= m; i++) {\n    int u = a[i].u, v = a[i].v, w = a[i].w;\n    for (int p = n, i = n - 1; i >= 1; i--) {\n      if (d[v][rk[u][i]] > d[v][rk[u][p]]) {\n        ans = min(ans, d[u][rk[u][i]] + d[v][rk[u][p]] + w);\n        p = i;\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fast Doubling Method for Fibonacci Sequence in C++\nDESCRIPTION: An efficient implementation of the fast doubling method to calculate the nth Fibonacci number in logarithmic time. The function returns a pair containing F(n) and F(n+1), using the properties F(2k) = F(k) * (2F(k+1) - F(k)) and F(2k+1) = F(k+1)^2 + F(k)^2.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/fibonacci.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\npair<int, int> fib(int n) {\n  if (n == 0) return {0, 1};\n  auto p = fib(n >> 1);\n  int c = p.first * (2 * p.second - p.first);\n  int d = p.first * p.first + p.second * p.second;\n  if (n & 1)\n    return {d, c + d};\n  else\n    return {c, d};\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing exLucas Algorithm in C++\nDESCRIPTION: A C++ implementation of the exLucas algorithm for calculating combination numbers modulo a composite number. It uses the Chinese Remainder Theorem to combine results from prime power moduli.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lucas.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll qpow(ll a, ll b, ll mod) {\n  ll res = 1;\n  while (b) {\n    if (b & 1) res = res * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return res;\n}\n\nll exgcd(ll a, ll b, ll& x, ll& y) {\n  if (b == 0) {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  ll d = exgcd(b, a % b, x, y);\n  ll temp = x;\n  x = y;\n  y = temp - a / b * y;\n  return d;\n}\n\nll inv(ll a, ll b) {\n  ll x, y;\n  exgcd(a, b, x, y);\n  return (x % b + b) % b;\n}\n\nll fac(ll n, ll pi, ll pk) {\n  if (!n) return 1;\n  ll res = 1;\n  for (ll i = 2; i <= pk; i++)\n    if (i % pi) (res *= i) %= pk;\n  res = qpow(res, n / pk, pk);\n  for (ll i = 2; i <= n % pk; i++)\n    if (i % pi) (res *= i) %= pk;\n  return res * fac(n / pi, pi, pk) % pk;\n}\n\nll C(ll n, ll m, ll pi, ll pk) {\n  ll up = fac(n, pi, pk), d1 = fac(m, pi, pk), d2 = fac(n - m, pi, pk);\n  ll k = 0;\n  for (ll i = n; i; i /= pi) k += i / pi;\n  for (ll i = m; i; i /= pi) k -= i / pi;\n  for (ll i = n - m; i; i /= pi) k -= i / pi;\n  return up * inv(d1, pk) % pk * inv(d2, pk) % pk * qpow(pi, k, pk) % pk;\n}\n\nll a[100], b[100];\nll CRT(int n) {\n  ll M = 1, res = 0;\n  for (int i = 1; i <= n; i++) M *= b[i];\n  for (int i = 1; i <= n; i++) {\n    ll Mi = M / b[i], Ni = inv(Mi, b[i]);\n    res = (res + a[i] * Mi % M * Ni % M) % M;\n  }\n  return (res + M) % M;\n}\n\nint main() {\n  ll n, m, p, cnt = 0;\n  cin >> n >> m >> p;\n  ll P = p;\n  for (ll i = 2; i * i <= p; i++) {\n    if (P % i == 0) {\n      ll pk = 1;\n      while (P % i == 0) pk *= i, P /= i;\n      b[++cnt] = pk;\n      a[cnt] = C(n, m, i, pk);\n    }\n  }\n  if (P > 1) b[++cnt] = P, a[cnt] = C(n, m, P, P);\n  cout << CRT(cnt) << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Timestamp Optimization for Binary Indexed Tree Operations in Python\nDESCRIPTION: This Python implementation of timestamp optimization for Binary Indexed Tree operations allows efficient handling of multiple datasets. It uses a tag array to track the last update time for each node, avoiding unnecessary clearing of the entire tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_17\n\nLANGUAGE: Python\nCODE:\n```\ntag = [0] * MAXN\nt = [0] * MAXN\nTag = 0\n\n\ndef reset():\n    Tag = Tag + 1\n\n\ndef add(k, v):\n    while k <= n:\n        if tag[k] != Tag:\n            t[k] = 0\n        t[k] = t[k] + v\n        tag[k] = Tag\n        k = k + lowbit(k)\n\n\ndef getsum(k):\n    ret = 0\n    while k:\n        if tag[k] == Tag:\n            ret = ret + t[k]\n        k = k - lowbit(k)\n    return ret\n```\n\n----------------------------------------\n\nTITLE: Matrix Implementation in C++ with Fast Exponentiation\nDESCRIPTION: A complete implementation of a matrix class in C++ with operations for addition, subtraction, multiplication, and fast exponentiation using the binary exponentiation algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstruct mat {\n  LL a[sz][sz];\n\n  mat() { memset(a, 0, sizeof a); }\n\n  mat operator-(const mat& T) const {\n    mat res;\n    for (int i = 0; i < sz; ++i)\n      for (int j = 0; j < sz; ++j) {\n        res.a[i][j] = (a[i][j] - T.a[i][j]) % MOD;\n      }\n    return res;\n  }\n\n  mat operator+(const mat& T) const {\n    mat res;\n    for (int i = 0; i < sz; ++i)\n      for (int j = 0; j < sz; ++j) {\n        res.a[i][j] = (a[i][j] + T.a[i][j]) % MOD;\n      }\n    return res;\n  }\n\n  mat operator*(const mat& T) const {\n    mat res;\n    int r;\n    for (int i = 0; i < sz; ++i)\n      for (int k = 0; k < sz; ++k) {\n        r = a[i][k];\n        for (int j = 0; j < sz; ++j)\n          res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD;\n      }\n    return res;\n  }\n\n  mat operator^(LL x) const {\n    mat res, bas;\n    for (int i = 0; i < sz; ++i) res.a[i][i] = 1;\n    for (int i = 0; i < sz; ++i)\n      for (int j = 0; j < sz; ++j) bas.a[i][j] = a[i][j] % MOD;\n    while (x) {\n      if (x & 1) res = res * bas;\n      bas = bas * bas;\n      x >>= 1;\n    }\n    return res;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Re-rooting DP for Tree Depth Sum Optimization in C++\nDESCRIPTION: This code demonstrates re-rooting DP to find the optimal root node that maximizes the sum of depths for all nodes in a tree. It uses two DFS passes - the first to calculate subtree sizes, and the second to perform the actual re-rooting DP calculations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/tree.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/tree/tree_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Insertion Operation for Treap in C++\nDESCRIPTION: Implements the insertion operation for a Treap. Maintains binary search tree property during insertion and uses rotations to preserve heap property based on random priorities.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid _insert(Node *&cur, int val) {\n  if (cur == nullptr) {\n    // 没这个节点直接新建\n    cur = new Node(val);\n    return;\n  } else if (val == cur->val) {\n    // 如果有这个值相同的节点，就把重复数量加一\n    cur->rep_cnt++;\n    cur->siz++;\n  } else if (val < cur->val) {\n    // 维护搜索树性质，val 比当前节点小就插到左边，反之亦然\n    _insert(cur->ch[0], val);\n    if (cur->ch[0]->rank < cur->rank) {\n      // 小根堆中，上面节点的优先级一定更小\n      // 因为新插的左子节点比父节点小，现在需要让左子节点变成父节点\n      _rotate(cur, RT);  // 注意前面的旋转性质，要把左子节点转上来，需要右旋\n    }\n    cur->upd_siz();  // 插入之后大小会变化，需要更新\n  } else {\n    _insert(cur->ch[1], val);\n    if (cur->ch[1]->rank < cur->rank) {\n      _rotate(cur, LF);\n    }\n    cur->upd_siz();\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Bridge Detection Without Multiple Edges\nDESCRIPTION: Implementation of Tarjan's algorithm for finding bridges in an undirected graph without multiple edges between vertices. Returns bridges as pairs of vertices where isbridge[x] indicates (father[x],x) is a bridge.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/cut.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint low[MAXN], dfn[MAXN], idx;\nbool isbridge[MAXN];\nvector<int> G[MAXN];\nint cnt_bridge;\nint father[MAXN];\n\nvoid tarjan(int u, int fa) {\n  father[u] = fa;\n  low[u] = dfn[u] = ++idx;\n  for (const auto &v : G[u]) {\n    if (!dfn[v]) {\n      tarjan(v, u);\n      low[u] = min(low[u], low[v]);\n      if (low[v] > dfn[u]) {\n        isbridge[v] = true;\n        ++cnt_bridge;\n      }\n    } else if (v != fa) {\n      low[u] = min(low[u], dfn[v]);\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nlow = [0] * MAXN\ndfn = [0] * MAXN\nidx = 0\nisbridge = [False] * MAXN\nG = [[0 for i in range(MAXN)] for j in range(MAXN)]\ncnt_bridge = 0\nfather = [0] * MAXN\n\n\ndef tarjan(u, fa):\n    father[u] = fa\n    idx = idx + 1\n    low[u] = dfn[u] = idx\n    for i in range(0, len(G[u])):\n        v = G[u][i]\n        if dfn[v] == False:\n            tarjan(v, u)\n            low[u] = min(low[u], low[v])\n            if low[v] > dfn[u]:\n                isbridge[v] = True\n                cnt_bridge = cnt_bridge + 1\n        elif v != fa:\n            low[u] = min(low[u], dfn[v])\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression as Function Pointer in C++\nDESCRIPTION: Demonstrates how an empty capture lambda can be implicitly converted to a function pointer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid (*f)(int, int) = [](int, int) -> void {};\n```\n\n----------------------------------------\n\nTITLE: 实现区间DP状态转移 - C++\nDESCRIPTION: 这段代码实现了区间动态规划的状态转移过程。通过三重循环，枚举区间长度len、起始位置i、以及区间内的分割点k，计算将区间[i,j]内的元素合并得到的最大价值f[i][j]。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/interval.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor (len = 2; len <= n; len++)\n  for (i = 1; i <= 2 * n - len; i++) {\n    int j = len + i - 1;\n    for (k = i; k < j; k++)\n      f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1]);\n  }\n```\n\n----------------------------------------\n\nTITLE: Template-Based Fast I/O for Multiple Integer Types in C++\nDESCRIPTION: A generic template-based implementation of fast integer input function that works with different integer types like int, long long, and __int128. This approach reduces code duplication.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// 声明 template 类,要求提供输入的类型T,并以此类型定义内联函数 read()\ntemplate <typename T>\nT read() {\n  T sum = 0, fl = 1;  // 将 sum,fl 和 ch 以输入的类型定义\n  int ch = getchar();\n  for (; !isdigit(ch); ch = getchar())\n    if (ch == '-') fl = -1;\n  for (; isdigit(ch); ch = getchar()) sum = sum * 10 + ch - '0';\n  return sum * fl;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Value by Rank in Treap (C++)\nDESCRIPTION: This function queries the value of the node with a given rank in the treap. It uses splitting by rank to find the node with the specified rank.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nint qval_by_rank(Node *cur, int rk) {\n  Node *l, *mid, *r;\n  tie(l, mid, r) = split_by_rk(cur, rk);\n  int ret = mid->val;\n  root = merge(merge(l, mid), r);\n  return ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Suffix Array using Suffix Balanced Tree in C++\nDESCRIPTION: This code snippet demonstrates how to construct a suffix array using a suffix balanced tree implementation. It uses a size-balanced tree (SGT) to maintain the suffixes in lexicographical order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-bst.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/suffix-bst/suffix-bst_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Building AC Automaton Fail Pointers in C++\nDESCRIPTION: Constructs fail pointers for the Aho-Corasick automaton using BFS traversal. The function builds the failure transitions and modifies the trie structure to create a dictionary graph for efficient pattern matching.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid build() {\n  queue<int> q;\n  for (int i = 0; i < 26; i++)\n    if (tr[0].son[i]) q.push(tr[0].son[i]);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < 26; i++) {\n      if (tr[u].son[i]) {\n        tr[tr[u].son[i]].fail = tr[tr[u].fail].son[i];\n        q.push(tr[u].son[i]);\n      } else\n        tr[u].son[i] = tr[tr[u].fail].son[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: String Compression with Hash Implementation in C++\nDESCRIPTION: Implementation for CF1200E Compress Words problem that uses string hashing to find the longest common prefix-suffix between strings. The solution processes multiple strings sequentially, removing duplicated parts by finding the longest suffix of the answer that matches the prefix of the current string.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/hash.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/hash/hash_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Querying Sum in Segment Tree using Python\nDESCRIPTION: This Python function queries the sum of a range [l,r] in the segment tree. It recursively divides the query range into smaller segments that align with the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef getsum(l, r, s, t, p):\n    # [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号\n    if l <= s and t <= r:\n        return d[p]  # 当前区间为询问区间的子集时直接返回当前区间的和\n    m = s + ((t - s) >> 1)\n    sum = 0\n    if l <= m:\n        sum = sum + getsum(l, r, s, m, p * 2)\n    # 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子\n    if r > m:\n        sum = sum + getsum(l, r, m + 1, t, p * 2 + 1)\n    # 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子\n    return sum\n```\n\n----------------------------------------\n\nTITLE: Implementing Timsort Algorithm in Pseudocode\nDESCRIPTION: Pseudocode implementation of the Timsort algorithm showing the main workflow including run identification, extension, and the merging process. The algorithm processes the array by finding natural runs, extending them if necessary, and merging them using specific rules to maintain stability and efficiency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/tim-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\n\\begin{array}{ll}\n1 & nRemaining \\gets \\text{数组长度} \\\\\n2 & minRun \\gets \\text{选择合适的 MinRun 的值}(nRemaining) \\\\\n3 & startIndex \\gets 0 \\\\\n4 & \\textbf{while } nRemaining > 0 \\ \\textbf{do} \\\\\n5 & \\qquad runLength \\gets \\text{识别 Run }(array, startIndex, nRemaining) \\\\\n6 & \\qquad \\textbf{if } runLength < minRun \\ \\textbf{then} \\\\\n7 & \\qquad \\qquad extendLength \\gets \\min(minRun, nRemaining) \\\\\n8 & \\qquad \\qquad \\text{使用插入排序扩展区间 } [startIndex, startIndex + extendLength - 1]\\\\\n9 & \\qquad \\qquad runLength \\gets extendLength \\\\\n10 & \\qquad \\textbf{end if} \\\\\n11 & \\qquad \\text{将 Run  } (startIndex, runLength) \\text{ 压入栈中} \\\\\n12 & \\qquad \\textbf{调用 } \\text{mergeCollapse(栈)} \\ \\text{检查并合并栈中的 Run } \\\\\n13 & \\qquad startIndex \\gets startIndex + runLength \\ \\text{更新起始位置} \\\\\n14 & \\qquad nRemaining \\gets nRemaining - runLength \\ \\text{更新剩余长度} \\\\\n15 & \\textbf{end while} \\\\\n16 & \\textbf{调用 } \\text{mergeForceCollapse(栈)} \\ \\text{对栈中所有 Run 进行最终的合并} \\\\\n\\end{array}\n```\n\n----------------------------------------\n\nTITLE: Boolean Declaration in C\nDESCRIPTION: Demonstrates different ways to declare boolean variables in C, showing usage both with and without stdbool.h header.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/cpp-other-langs.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nbool x = true;  // 需要引入 stdbool.h\n_Bool x = 1;    // 不需要引入 stdbool.h\n```\n\n----------------------------------------\n\nTITLE: Finding a Key in Skip List in C++\nDESCRIPTION: This function searches for a node with a given key in the Skip List. It starts from the highest level and moves down, skipping unnecessary comparisons. If found, it returns the associated value; otherwise, it returns an invalid value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/skiplist.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nV& find(const K& key) {\n  SkipListNode<K, V>* p = head;\n\n  // Find the last node with key less than the target key at each level\n  for (int i = level; i >= 0; --i) {\n    while (p->forward[i]->key < key) {\n      p = p->forward[i];\n    }\n  }\n  // Move to the next node\n  p = p->forward[0];\n\n  // Return the value if found, otherwise return INVALID\n  if (p->key == key) return p->value;\n  return tail->value;\n}\n```\n\n----------------------------------------\n\nTITLE: Enable Windows Features via PowerShell\nDESCRIPTION: PowerShell commands to enable WSL and Virtual Machine Platform features in Windows\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n# If you only want to use WSL 1 skip this step\nEnable-WindowsOptionalFeature -Online -FeatureName VirtualMachinePlatform\n```\n\n----------------------------------------\n\nTITLE: Implementing Simulated Annealing in C++ for Optimization Problems\nDESCRIPTION: This code snippet demonstrates the implementation of the simulated annealing algorithm in C++ to solve an optimization problem. It includes the main simulated annealing function, random state generation, and energy calculation for a specific problem involving finding the weighted Fermat point of n points.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/simulated-annealing.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/simulated-annealing/simulated-annealing_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Computing Semi-Dominators using Disjoint Sets in C++\nDESCRIPTION: This code snippet implements an algorithm to compute semi-dominators in a graph using depth-first search (DFS) and disjoint set data structures. It performs a DFS traversal, then processes nodes in reverse DFS order to efficiently calculate semi-dominators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dominator-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid dfs(int u) {\n  dfn[u] = ++dfc;\n  pos[dfc] = u;\n  for (int i = h[0][u]; i; i = e[i].x) {\n    int v = e[i].v;\n    if (!dfn[v]) {\n      dfs(v);\n      fth[v] = u;\n    }\n  }\n}\n\nint find(int x) {\n  if (fa[x] == x) {\n    return x;\n  }\n  int tmp = fa[x];\n  fa[x] = find(fa[x]);\n  if (dfn[sdm[mn[tmp]]] < dfn[sdm[mn[x]]]) {\n    mn[x] = mn[tmp];\n  }\n  return fa[x];\n}\n\nvoid getsdom() {\n  dfs(1);\n  for (int i = 1; i <= n; ++i) {\n    mn[i] = fa[i] = sdm[i] = i;\n  }\n  for (int i = dfc; i >= 2; --i) {\n    int u = pos[i], res = INF;\n    for (int j = h[1][u]; j; j = e[j].x) {\n      int v = e[j].v;\n      if (!dfn[v]) {\n        continue;\n      }\n      find(v);\n      if (dfn[v] < dfn[u]) {\n        res = std::min(res, dfn[v]);\n      } else {\n        res = std::min(res, dfn[sdm[mn[v]]]);\n      }\n    }\n    sdm[u] = pos[res];\n    fa[u] = fth[u];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Map Initialization Examples\nDESCRIPTION: Shows different ways to initialize HashMap, LinkedHashMap, and TreeMap with various ordering options.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_18\n\nLANGUAGE: java\nCODE:\n```\nMap<Integer, Integer> map1 = new HashMap<>();\n```\n\nLANGUAGE: java\nCODE:\n```\nMap<Integer, Integer> map2 = new LinkedHashMap<>();\n```\n\nLANGUAGE: java\nCODE:\n```\nMap<Integer, Integer> map3 = new TreeMap<>();\nMap<Integer, Integer> map4 = new TreeMap<>((x, y) -> {return y - x;});  // 降序\n```\n\n----------------------------------------\n\nTITLE: Variadic Function Template Declaration in C++\nDESCRIPTION: Shows how to declare a variadic function template that can accept any number of arguments of any types. This is a powerful feature for creating generic functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename... Values>\nvoid fun(Values... values) {}\n```\n\n----------------------------------------\n\nTITLE: Second Dimension Query Operation in Tree-on-Tree\nDESCRIPTION: Implements a query operation for the second dimension of the tree structure. Takes parameters for tree node, range bounds, and query position, returning the aggregated result from the third dimension.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-in-seg.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint tree_query(int k, int l, int r, int x) {\n  if (k == 0) return 0;\n  if (1 <= l && r <= sec[x].y) return vec_query(ou_root[k], 1, p, 1, sec[x].z);\n  int mid = l + r >> 1, res = 0;\n  if (1 <= mid) res += tree_query(ou_ch[k][0], l, mid, x);\n  if (sec[x].y > mid) res += tree_query(ou_ch[k][1], mid + 1, r, x);\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Exception Handling in Python\nDESCRIPTION: This snippet demonstrates Python's exception handling using try-except blocks. It shows how to catch specific exceptions like ValueError and NameError, and how to use the 'as' keyword to access the exception object.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ns = \"OI-wiki\"\npat = \"NOIP\"\nx = s.find(pat)  # find() 找不到返回 -1\ntry:\n    y = s.index(pat)  # index() 找不到则抛出错误\n    print(y)  # 这句被跳过\nexcept ValueError:\n    print(\"没找到\")\n    try:\n        print(y)  # 此时 y 并没有定义，故又会抛出错误\n    except NameError as e:\n        print(\"无法输出 y\")\n        print(\"原因:\", e)\n```\n\n----------------------------------------\n\nTITLE: Reading from File using ifstream in C++\nDESCRIPTION: Example of opening a file for reading using C++ ifstream class. This approach uses C++ streams for file I/O which provides type safety and is more object-oriented than C-style file operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nifstream fin(\"data.in\");\n// data.in 就是读取文件的相对位置或绝对位置\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum Length Substring Occurring K Times\nDESCRIPTION: Implementation for finding maximum length substring that appears at least k times using suffix arrays and height array. Uses monotonic queue for O(n) solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sa.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ndocs/string/code/sa/sa_2.cpp\n```\n\n----------------------------------------\n\nTITLE: Working with Tuples in Python\nDESCRIPTION: This snippet demonstrates the usage of tuples in Python, including tuple creation, modification of mutable elements within a tuple, and tuple unpacking for multiple variable assignment.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ntup = tuple([[1, 2], 4])  # 由列表得到元组\n# 等同于 tup = ([1,2], 4)\ntup[0].append(3)\nprint(tup)\na, b = 0, \"I-Wiki\"  # 多变量赋值其实是元组拆包\nprint(id(a), id(b))\nb, a = a, b\nprint(id(a), id(b))  # 你应该会看到 a, b 的 id 值现在互换了\n# 这更说明 Python 中，变量更像是名字，赋值只是让其指代对象\n```\n\n----------------------------------------\n\nTITLE: Implementing Prim's Algorithm with Binary Heap in C++\nDESCRIPTION: This code implements Prim's algorithm using a binary heap to efficiently find the minimum spanning tree of a graph. It maintains a priority queue of edges and greedily selects the minimum weight edge to add to the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n// 使用二叉堆优化的 Prim 算法。\n#include <cstring>\n#include <iostream>\n#include <queue>\nusing namespace std;\nconstexpr int N = 5050, M = 2e5 + 10;\n\nstruct E {\n  int v, w, x;\n} e[M * 2];\n\nint n, m, h[N], cnte;\n\nvoid adde(int u, int v, int w) { e[++cnte] = E{v, w, h[u]}, h[u] = cnte; }\n\nstruct S {\n  int u, d;\n};\n\nbool operator<(const S &x, const S &y) { return x.d > y.d; }\n\npriority_queue<S> q;\nint dis[N];\nbool vis[N];\n\nint res = 0, cnt = 0;\n\nvoid Prim() {\n  memset(dis, 0x3f, sizeof(dis));\n  dis[1] = 0;\n  q.push({1, 0});\n  while (!q.empty()) {\n    if (cnt >= n) break;\n    int u = q.top().u, d = q.top().d;\n    q.pop();\n    if (vis[u]) continue;\n    vis[u] = true;\n    ++cnt;\n    res += d;\n    for (int i = h[u]; i; i = e[i].x) {\n      int v = e[i].v, w = e[i].w;\n      if (w < dis[v]) {\n        dis[v] = w, q.push({v, w});\n      }\n    }\n  }\n}\n\nint main() {\n  cin >> n >> m;\n  for (int i = 1, u, v, w; i <= m; ++i) {\n    cin >> u >> v >> w, adde(u, v, w), adde(v, u, w);\n  }\n  Prim();\n  if (cnt == n)\n    cout << res;\n  else\n    cout << \"No MST.\";\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting a Node in Skip List in C++\nDESCRIPTION: This function inserts a new node with given key and value into the Skip List. It first searches for the insertion point, then creates a new node with a random level, and updates the necessary pointers at each level.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/skiplist.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid insert(const K &key, const V &value) {\n  SkipListNode<K, V> *update[MAXL + 1];\n\n  SkipListNode<K, V> *p = head;\n  for (int i = level; i >= 0; --i) {\n    while (p->forward[i]->key < key) {\n      p = p->forward[i];\n    }\n    update[i] = p;\n  }\n  p = p->forward[0];\n\n  if (p->key == key) {\n    p->value = value;\n    return;\n  }\n\n  int lv = randomLevel();\n  if (lv > level) {\n    lv = ++level;\n    update[lv] = head;\n  }\n\n  SkipListNode<K, V> *newNode = new SkipListNode<K, V>(key, value, lv);\n  for (int i = lv; i >= 0; --i) {\n    p = update[i];\n    newNode->forward[i] = p->forward[i];\n    p->forward[i] = newNode;\n  }\n\n  ++length;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Dynamic Inversion Pairs Problem Using Dividing Tree in C++\nDESCRIPTION: An implementation of dividing tree to solve the dynamic inversion pairs problem. It uses dividing tree combined with BIT (Binary Indexed Tree) to efficiently track changes in inversion counts when removing elements from a permutation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/dividing.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#define lson lc, l, mid\n#define rson rc, mid + 1, r\n\nusing namespace std;\n\nconst int MAXN = 100010;\nint A[MAXN], B[MAXN], num[MAXN];\nint tree[20][MAXN];\nbool mark[MAXN];\nint toleft[20][MAXN];\nlong long ans = 0;\nint n, m, a, b;\n\nstring r, l;\n\nvoid build(int dep, int l, int r) {\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  int same = mid - l + 1;\n  for (int i = l; i <= r; i++) {\n    if (tree[dep][i] < num[mid]) same--;\n  }\n  int lpos = l, rpos = mid + 1;\n  for (int i = l; i <= r; i++) {\n    if (tree[dep][i] < num[mid])\n      tree[dep + 1][lpos++] = tree[dep][i];\n    else if (tree[dep][i] == num[mid] && same > 0) {\n      tree[dep + 1][lpos++] = tree[dep][i];\n      same--;\n    } else\n      tree[dep + 1][rpos++] = tree[dep][i];\n    toleft[dep][i] = toleft[dep][l - 1] + lpos - l;\n  }\n  build(dep + 1, l, mid);\n  build(dep + 1, mid + 1, r);\n}\n\nint Get_Ans(int qx, int qy, int k, int dep, int l, int r) {\n  if (l == r) return tree[dep][l];\n  int mid = (l + r) >> 1, cnt = 0;\n  int x = toleft[dep][qx - 1] - toleft[dep][l - 1];\n  int y = toleft[dep][qy] - toleft[dep][l - 1];\n  cnt = y - x;\n  if (cnt >= k) {\n    int newl = l + x;\n    int newr = l + y - 1;\n    return Get_Ans(newl, newr, k, dep + 1, l, mid);\n  } else {\n    int newl = qx - l - x + mid + 1;\n    int newr = qy - l - y + mid + 1;\n    return Get_Ans(newl, newr, k - cnt, dep + 1, mid + 1, r);\n  }\n}\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int pos, int val, int dep, int lev) {\n  for (; pos <= n && lowbit(pos) < (1 << lev); pos += lowbit(pos)) {\n    tree[0][dep + pos] += val;\n  }\n}\n\nint getsum(int pos, int dep, int lev) {\n  int ret = 0;\n  for (; pos > 0 && lowbit(pos) < (1 << lev); pos -= lowbit(pos)) {\n    ret += tree[0][dep + pos];\n  }\n  return ret;\n}\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d\", &A[i]);\n    num[i] = A[i];\n  }\n  sort(num + 1, num + n + 1);\n  for (int i = 1; i <= n; i++) {\n    tree[0][i] = A[i];\n    toleft[0][i] = 0;\n  }\n  int t = 1;\n  while (t <= n) t <<= 1;\n  build(0, 1, n);\n  for (int i = 1; i <= n; i++) {\n    A[i] = lower_bound(num + 1, num + n + 1, A[i]) - num;\n    B[A[i]] = i;\n  }\n  for (int i = 1; i <= n; i++) {\n    for (int j = 0; j < 17; j++) {\n      int Lev = j;\n      int lev = Lev;\n      int lb = i & (1 << lev) - 1;\n      int rb = 1 << lev;\n      if (lb == 0) lb = rb;\n      int dep = i >> lev << lev;\n      int To = i - 1;\n      int Now = B[i];\n      if (A[Now] < A[i])\n        add(i, 1, dep, lev);\n      else if (To - getsum(To, dep, lev) > 0)\n        ans += To - getsum(To, dep, lev);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  for (int i = 1; i <= m; i++) {\n    scanf(\"%d\", &a);\n    mark[a] = 1;\n    ans = 0;\n    for (int j = 0; j < 17; j++) {\n      int Lev = j;\n      int lev = Lev;\n      int lb = a & (1 << lev) - 1;\n      int rb = 1 << lev;\n      if (lb == 0) lb = rb;\n      int dep = a >> lev << lev;\n      if (B[a] > 0) {\n        int To = B[a];\n        int Now = A[To];\n        if (Now < a)\n          add(a, -1, dep, lev);\n        else if (To - getsum(To, dep, lev) > 0)\n          ans -= To - getsum(To, dep, lev);\n      }\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Euler's Totient Function in Python\nDESCRIPTION: Python implementation of Euler's totient function that calculates φ(n) by finding prime factors. Uses the math.isqrt() function for efficient square root calculation and follows the same algorithmic approach as the C++ version.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/euler-totient.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nimport math\n\ndef euler_phi(n):\n    ans = n\n    for i in range(2, math.isqrt(n) + 1):\n        if n % i == 0:\n            ans = ans // i * (i - 1)\n            while n % i == 0:\n                n = n // i\n    if n > 1:\n        ans = ans // n * (n - 1)\n    return ans\n```\n\n----------------------------------------\n\nTITLE: Implementing Dijkstra's Algorithm with Free Passage Tracking in C++\nDESCRIPTION: Implementation of a modified Dijkstra's algorithm that handles k free passages in a graph. The algorithm uses a priority queue with State objects tracking vertex, weight, and free passage count. It maintains a 2D distance array where dis[v][k] represents the shortest distance to vertex v using k free passages.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/node.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstruct State {    // 优先队列的结点结构体\n  int v, w, cnt;  // cnt 表示已经使用多少次免费通行权限\n\n  State() {}\n\n  State(int v, int w, int cnt) : v(v), w(w), cnt(cnt) {}\n\n  bool operator<(const State &rhs) const { return w > rhs.w; }\n};\n\nvoid dijkstra() {\n  memset(dis, 0x3f, sizeof dis);\n  dis[s][0] = 0;\n  pq.push(State(s, 0, 0));  // 到起点不需要使用免费通行权，距离为零\n  while (!pq.empty()) {\n    const State top = pq.top();\n    pq.pop();\n    int u = top.v, nowCnt = top.cnt;\n    if (done[u][nowCnt]) continue;\n    done[u][nowCnt] = true;\n    for (int i = head[u]; i; i = edge[i].next) {\n      int v = edge[i].v, w = edge[i].w;\n      if (nowCnt < k && dis[v][nowCnt + 1] > dis[u][nowCnt]) {  // 可以免费通行\n        dis[v][nowCnt + 1] = dis[u][nowCnt];\n        pq.push(State(v, dis[v][nowCnt + 1], nowCnt + 1));\n      }\n      if (dis[v][nowCnt] > dis[u][nowCnt] + w) {  // 不可以免费通行\n        dis[v][nowCnt] = dis[u][nowCnt] + w;\n        pq.push(State(v, dis[v][nowCnt], nowCnt));\n      }\n    }\n  }\n}\n\nint main() {\n  n = read(), m = read(), k = read();\n  // 笔者习惯从 1 到 n 编号，而这道题是从 0 到 n - 1，所以要处理一下\n  s = read() + 1, t = read() + 1;\n  while (m--) {\n    int u = read() + 1, v = read() + 1, w = read();\n    add(u, v, w), add(v, u, w);  // 这道题是双向边\n  }\n  dijkstra();\n  int ans = std::numeric_limits<int>::max();  // ans 取 int 最大值为初值\n  for (int i = 0; i <= k; ++i)\n    ans = std::min(ans, dis[t][i]);  // 对到达终点的所有情况取最优值\n  println(ans);\n}\n```\n\n----------------------------------------\n\nTITLE: Cat Tree LCA Binary Computation Formula\nDESCRIPTION: Formula for computing Lowest Common Ancestor (LCA) in a Cat Tree using binary operations. The LCA of two nodes x and y can be computed using bitwise operations on their binary representations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/cat-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudo\nCODE:\n```\nlcp(x,y) = x >> log[x^y]\n```\n\n----------------------------------------\n\nTITLE: Full Implementation of Link-Cut Tree with Subtree Maintenance (C++)\nDESCRIPTION: This is a complete implementation of a Link-Cut Tree that maintains subtree information. It includes all necessary operations like splay, access, makeroot, and find, along with the main function demonstrating usage for a specific problem.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconstexpr int MAXN = 100010;\nusing ll = long long;\n\nstruct Splay {\n  int ch[MAXN][2], fa[MAXN], siz[MAXN], siz2[MAXN], tag[MAXN];\n\n  void clear(int x) {\n    ch[x][0] = ch[x][1] = fa[x] = siz[x] = siz2[x] = tag[x] = 0;\n  }\n\n  int getch(int x) { return ch[fa[x]][1] == x; }\n\n  int isroot(int x) { return ch[fa[x]][0] != x && ch[fa[x]][1] != x; }\n\n  void maintain(int x) {\n    clear(0);\n    if (x) siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]] + siz2[x];\n  }\n\n  void pushdown(int x) {\n    if (tag[x]) {\n      if (ch[x][0]) swap(ch[ch[x][0]][0], ch[ch[x][0]][1]), tag[ch[x][0]] ^= 1;\n      if (ch[x][1]) swap(ch[ch[x][1]][0], ch[ch[x][1]][1]), tag[ch[x][1]] ^= 1;\n      tag[x] = 0;\n    }\n  }\n\n  void update(int x) {\n    if (!isroot(x)) update(fa[x]);\n    pushdown(x);\n  }\n\n  void rotate(int x) {\n    int y = fa[x], z = fa[y], chx = getch(x), chy = getch(y);\n    fa[x] = z;\n    if (!isroot(y)) ch[z][chy] = x;\n    ch[y][chx] = ch[x][chx ^ 1];\n    fa[ch[x][chx ^ 1]] = y;\n    ch[x][chx ^ 1] = y;\n    fa[y] = x;\n    maintain(y);\n    maintain(x);\n    maintain(z);\n  }\n\n  void splay(int x) {\n    update(x);\n    for (int f = fa[x]; f = fa[x], !isroot(x); rotate(x))\n      if (!isroot(f)) rotate(getch(x) == getch(f) ? f : x);\n  }\n\n  void access(int x) {\n    for (int f = 0; x; f = x, x = fa[x])\n      splay(x), siz2[x] += siz[ch[x][1]] - siz[f], ch[x][1] = f, maintain(x);\n  }\n\n  void makeroot(int x) {\n    access(x);\n    splay(x);\n    swap(ch[x][0], ch[x][1]);\n    tag[x] ^= 1;\n  }\n\n  int find(int x) {\n    access(x);\n    splay(x);\n    while (ch[x][0]) x = ch[x][0];\n    splay(x);\n    return x;\n  }\n} st;\n\nint n, q, x, y;\nchar op;\n\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  while (q--) {\n    scanf(\" %c%d%d\", &op, &x, &y);\n    if (op == 'A') {\n      st.makeroot(x);\n      st.makeroot(y);\n      st.fa[x] = y;\n      st.siz2[y] += st.siz[x];\n    }\n    if (op == 'Q') {\n      st.makeroot(x);\n      st.access(y);\n      st.splay(y);\n      st.ch[y][0] = st.fa[x] = 0;\n      st.maintain(x);\n      st.makeroot(x);\n      st.makeroot(y);\n      printf(\"%lld\\n\", (ll)(st.siz[x] * st.siz[y]));\n      st.makeroot(x);\n      st.makeroot(y);\n      st.fa[x] = y;\n      st.siz2[y] += st.siz[x];\n    }\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Virtual Tree Using LCA and Sorting in C++\nDESCRIPTION: This function builds a virtual tree by sorting key nodes by DFS order, inserting LCAs, and connecting edges. It uses an array to store the nodes and performs sorting and unique operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/virtual-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint dfn[MAXN];\nint h[MAXN], m, a[MAXN], len;  // 存储关键点\n\nbool cmp(int x, int y) {\n  return dfn[x] < dfn[y];  // 按照 dfs 序排序\n}\n\nvoid build_virtual_tree() {\n  sort(h + 1, h + m + 1, cmp);  // 把关键点按照 dfs 序排序\n  for (int i = 1; i < m; ++i) {\n    a[++len] = h[i];\n    a[++len] = lca(h[i], h[i + 1]);  // 插入 lca\n  }\n  a[++len] = h[m];\n  sort(a + 1, a + len + 1, cmp);  // 把所有虚树上的点按照 dfs 序排序\n  len = unique(a + 1, a + len + 1) - a - 1;  // 去重\n  for (int i = 1, lc; i < len; ++i) {\n    lc = lca(a[i], a[i + 1]);\n    conn(lc, a[i + 1]);  // 连边，如有边权 就是 distance(lc,a[i+1])\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Binary Exponentiation in Python\nDESCRIPTION: Recursive implementation of binary exponentiation algorithm to calculate a^b efficiently in O(log n) time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef binpow(a, b):\n    if b == 0:\n        return 1\n    res = binpow(a, b // 2)\n    if (b % 2) == 1:\n        return res * res * a\n    else:\n        return res * res\n```\n\n----------------------------------------\n\nTITLE: Implementing Bottom-up DP for Herb Collection Problem in C++\nDESCRIPTION: A tabulation (bottom-up) implementation of dynamic programming for the herb collection problem. This approach explicitly defines the processing order for all states, achieving the same time complexity as memoization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint n, t, w[105], v[105], f[105][1005];\n\nint main() {\n  cin >> n >> t;\n  for (int i = 1; i <= n; i++) cin >> w[i] >> v[i];\n  for (int i = 1; i <= n; i++)\n    for (int j = 0; j <= t; j++) {\n      f[i][j] = f[i - 1][j];\n      if (j >= w[i])\n        f[i][j] = max(f[i][j], f[i - 1][j - w[i]] + v[i]);  // 状态转移方程\n    }\n  cout << f[n][t];\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kruskal's Algorithm for Minimum Spanning Tree in Java\nDESCRIPTION: This code implements Kruskal's algorithm to find the minimum spanning tree of a graph in Java. It uses a union-find data structure to detect cycles and sorts edges by weight.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\n--8<-- \"docs/graph/code/mst/mst_3.java\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Lifting for Long Jump Problem in C++\nDESCRIPTION: This code solves a problem where a point jumps around a circular array of length n, k steps at a time, for m iterations. It uses binary lifting to precompute jumps of length 2^i and efficiently calculate the sum of values at each landing point.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/binary-lifting.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\nusing namespace std;\n\nconstexpr int mod = 1000000007;\n\nint modadd(int a, int b) {\n  if (a + b >= mod) return a + b - mod;  // 减法代替取模，加快运算\n  return a + b;\n}\n\nint vi[1000005];\n\nint go[75][1000005];  // 将数组稍微开大以避免越界，小的一维尽量定义在前面\nint sum[75][1000005];\n\nint main() {\n  int n, k;\n  scanf(\"%d%d\", &n, &k);\n  for (int i = 1; i <= n; ++i) {\n    scanf(\"%d\", vi + i);\n  }\n\n  for (int i = 1; i <= n; ++i) {\n    go[0][i] = (i + k) % n + 1;\n    sum[0][i] = vi[i];\n  }\n\n  int logn = 31 - __builtin_clz(n);  // 一个快捷的取对数的方法\n  for (int i = 1; i <= logn; ++i) {\n    for (int j = 1; j <= n; ++j) {\n      go[i][j] = go[i - 1][go[i - 1][j]];\n      sum[i][j] = modadd(sum[i - 1][j], sum[i - 1][go[i - 1][j]]);\n    }\n  }\n\n  long long m;\n  scanf(\"%lld\", &m);\n\n  int ans = 0;\n  int curx = 1;\n  for (int i = 0; m; ++i) {\n    if (m & (1ll << i)) {  // 参见位运算的相关内容，意为 m 的第 i 位是否为 1\n      ans = modadd(ans, sum[i][curx]);\n      curx = go[i][curx];\n      m ^= 1ll << i;  // 将第 i 位置零\n    }\n  }\n\n  printf(\"%d\\n\", ans);\n}\n```\n\n----------------------------------------\n\nTITLE: O(n) Binary Indexed Tree Construction in C++\nDESCRIPTION: This function builds a Binary Indexed Tree in O(n) time by iterating through the array once and updating parent nodes directly. It's an optimization over the naive O(n log n) construction method.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nvoid init() {\n  for (int i = 1; i <= n; ++i) {\n    t[i] += a[i];\n    int j = i + lowbit(i);\n    if (j <= n) t[j] += t[i];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 1D Range Addition and Sum Queries with Binary Indexed Trees in C++\nDESCRIPTION: Uses two binary indexed trees to support range additions and range sum queries on a 1D array. One tree stores the actual values while the other stores values multiplied by their indices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nint t1[MAXN], t2[MAXN], n;\n\nint lowbit(int x) { return x & (-x); }\n\nvoid add(int k, int v) {\n  int v1 = k * v;\n  while (k <= n) {\n    t1[k] += v, t2[k] += v1;\n    k += lowbit(k);\n  }\n}\n\nint getsum(int *t, int k) {\n  int ret = 0;\n  while (k) {\n    ret += t[k];\n    k -= lowbit(k);\n  }\n  return ret;\n}\n\nvoid add1(int l, int r, int v) {\n  add(l, v), add(r + 1, -v);\n}\n\nlong long getsum1(int l, int r) {\n  return (r + 1ll) * getsum(t1, r) - 1ll * l * getsum(t1, l - 1) -\n         (getsum(t2, r) - getsum(t2, l - 1));\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Weight Balanced Leafy Trees in C++\nDESCRIPTION: Function for merging two WBLTs while maintaining balance. This operation is useful for combining two sorted sequences efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint merges(int x, int y) {\n  if (!x || !y) return x + y;\n  if (min(sz[x], sz[y]) >= alpha * (sz[x] + sz[y])) {\n    return merge(x, y);\n  }\n  if (sz[x] >= sz[y]) {\n    if (sz[ls[x]] >= alpha * (sz[x] + sz[y])) {\n      return merges(ls[x], merges(rs[x], y));\n    } else {\n      return merges(merges(ls[x], ls[rs[x]]), merges(rs[rs[x]], y));\n    }\n  } else {\n    if (sz[rs[y]] >= alpha * (sz[x] + sz[y])) {\n      return merges(merges(x, ls[y]), rs[y]);\n    } else {\n      return merges(merges(x, ls[ls[y]]), merges(rs[ls[y]], rs[y]));\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Hamming Weight by Right Shifting in C++\nDESCRIPTION: A function that calculates the Hamming weight (popcount) of an integer by right shifting and counting each set bit, used in algorithms analyzing binary representations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_17\n\nLANGUAGE: C++\nCODE:\n```\n// 求 x 的汉明权重\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt += x & 1;\n        x >>= 1;\n    }\n    return cnt;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Absolute Value with Bitwise Operations in C++\nDESCRIPTION: A function that computes the absolute value of an integer using bitwise operations, which can be more efficient on some machines than the traditional conditional approach.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint Abs(int n) {\n  return (n ^ (n >> 31)) - (n >> 31);\n  /* n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1\n    若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)\n    需要计算 n 和 -1 的补码，然后进行异或运算，\n    结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值 */\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Hashing for UOJ #763 in C++\nDESCRIPTION: This code implements tree hashing to solve UOJ #763, a template problem for tree hashing. It uses a depth-first search starting from root 1 to compute hash values for each subtree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-hash.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/tree-hash/tree-hash_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing IDA* Algorithm in Pascal\nDESCRIPTION: Core implementation of the IDA* algorithm showing the main procedure that combines iterative deepening with A* heuristic search. The algorithm incrementally increases path limit until a solution is found or resource limits are reached.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/idastar.md#2025-04-22_snippet_0\n\nLANGUAGE: Pascal\nCODE:\n```\nProcedure IDA_STAR(StartState)\nBegin\n  PathLimit := H(StartState) - 1;\n  Succes := False;\n  Repeat\n    inc(PathLimit);\n    StartState.g = 0;\n    Push(OpenStack, StartState);\n    Repeat\n      CurrentState := Pop(OpenStack);\n      If Solution(CurrentState) then\n        Success = True\n      Elseif PathLimit >= CurrentState.g + H(CurrentState) then\n        For each Child(CurrentState) do\n          Push(OpenStack, Child(CurrentState));\n    until Success or empty(OpenStack);\n  until Success or ResourceLimtsReached;\nend;\n```\n\n----------------------------------------\n\nTITLE: Range Update with Increment in Python\nDESCRIPTION: Python implementation of segment tree range update operation that adds a value to all elements in a given range. Uses lazy propagation to handle updates efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef update(l, r, c, s, t, p):\n    if l <= s and t <= r:\n        d[p] = d[p] + (t - s + 1) * c\n        b[p] = b[p] + c\n        return\n    m = s + ((t - s) >> 1)\n    if b[p] and s != t:\n        d[p * 2] = d[p * 2] + b[p] * (m - s + 1)\n        d[p * 2 + 1] = d[p * 2 + 1] + b[p] * (t - m)\n        b[p * 2] = b[p * 2] + b[p]\n        b[p * 2 + 1] = b[p * 2 + 1] + b[p]\n        b[p] = 0\n    if l <= m:\n        update(l, r, c, s, m, p * 2)\n    if r > m:\n        update(l, r, c, m + 1, t, p * 2 + 1)\n    d[p] = d[p * 2] + d[p * 2 + 1]\n```\n\n----------------------------------------\n\nTITLE: Generating Random Numbers with mt19937 in C++\nDESCRIPTION: Uses the mt19937 Mersenne Twister algorithm to generate random numbers. Requires the <random> header. Seeds the generator with the current time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <ctime>\n#include <iostream>\n#include <random>\n\nusing namespace std;\n\nint main() {\n  mt19937 myrand(time(nullptr));\n  cout << myrand() << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Template Solution for LCA Problem\nDESCRIPTION: Complete solution for Luogu P3379 LCA template problem implementing efficient LCA computation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/lca.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/graph/code/lca/lca_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Center Algorithm in C++\nDESCRIPTION: This code snippet implements an algorithm to find the center(s) of a tree. It uses depth-first search to calculate the longest and second-longest paths for each node, and then determines the center(s) based on these calculations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-center.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// 这份代码默认节点编号从 1 开始，即 i ∈ [1,n]，使用vector存图\nint d1[N], d2[N], up[N], x, y, mini = 1e9;  // d1,d2对应上文中的len1,len2\n\nstruct node {\n  int to, val;  // to为边指向的节点，val为边权\n};\n\nvector<node> nbr[N];\n\nvoid dfsd(int cur, int fa) {  // 求取len1和len2\n  for (node nxtn : nbr[cur]) {\n    int nxt = nxtn.to, w = nxtn.val;  // nxt为这条边通向的节点，val为边权\n    if (nxt == fa) {\n      continue;\n    }\n    dfsd(nxt, cur);\n    if (d1[nxt] + w > d1[cur]) {  // 可以更新最长链\n      d2[cur] = d1[cur];\n      d1[cur] = d1[nxt] + w;\n    } else if (d1[nxt] + w > d2[cur]) {  // 不能更新最长链，但可更新次长链\n      d2[cur] = d1[nxt] + w;\n    }\n  }\n}\n\nvoid dfsu(int cur, int fa) {\n  for (node nxtn : nbr[cur]) {\n    int nxt = nxtn.to, w = nxtn.val;\n    if (nxt == fa) {\n      continue;\n    }\n    up[nxt] = up[cur] + w;\n    if (d1[nxt] + w != d1[cur]) {  // 如果自己子树里的最长链不在nxt子树里\n      up[nxt] = max(up[nxt], d1[cur] + w);\n    } else {  // 自己子树里的最长链在nxt子树里，只能使用次长链\n      up[nxt] = max(up[nxt], d2[cur] + w);\n    }\n    dfsu(nxt, cur);\n  }\n}\n\nvoid GetTreeCenter() {  // 统计树的中心，记为x和y（若存在）\n  dfsd(1, 0);\n  dfsu(1, 0);\n  for (int i = 1; i <= n; i++) {\n    if (max(d1[i], up[i]) < mini) {  // 找到了当前max(len1[x],up[x])最小点\n      mini = max(d1[i], up[i]);\n      x = i;\n      y = 0;\n    } else if (max(d1[i], up[i]) == mini) {  // 另一个中心\n      y = i;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Sparse Linear Systems using Berlekamp-Massey in C++\nDESCRIPTION: C++ function to solve sparse linear systems Ax = b where A is a full-rank sparse matrix, using the Berlekamp-Massey algorithm. The function takes the sparse matrix A as a list of non-zero entries and the vector b, and returns the solution vector x.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/berlekamp-massey.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvector<int> solve_sparse_equations(const vector<tuple<int, int, int>> &A,\n                                   const vector<int> &b) {\n  int n = (int)b.size();  // 0-based\n\n  vector<vector<int>> f({b});\n\n  for (int i = 1; i < 2 * n; i++) {\n    vector<int> v(n);\n    auto &u = f.back();\n\n    for (auto [x, y, z] : A)  // [x, y, value]\n      v[x] = (v[x] + (long long)u[y] * z) % p;\n\n    f.push_back(v);\n  }\n\n  vector<int> w(n);\n  mt19937 gen;\n  for (auto &x : w) x = uniform_int_distribution<int>(1, p - 1)(gen);\n\n  vector<int> a(2 * n);\n  for (int i = 0; i < 2 * n; i++)\n    for (int j = 0; j < n; j++) a[i] = (a[i] + (long long)f[i][j] * w[j]) % p;\n\n  auto c = berlekamp_massey(a);\n  int m = (int)c.size();\n\n  vector<int> ans(n);\n\n  for (int i = 0; i < m - 1; i++)\n    for (int j = 0; j < n; j++)\n      ans[j] = (ans[j] + (long long)c[m - 2 - i] * f[i][j]) % p;\n\n  int inv = power(p - c[m - 1], p - 2);\n\n  for (int i = 0; i < n; i++) ans[i] = (long long)ans[i] * inv % p;\n\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 3D Convex Hull in C++\nDESCRIPTION: This snippet implements a 3D convex hull algorithm. It uses a point-adding approach, maintaining visible and invisible faces as new points are added to the hull.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/convex-hull.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/geometry/code/3d/3d_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Dictionary Operations in Python\nDESCRIPTION: This code snippet shows various ways to create and manipulate dictionaries in Python, including dictionary comprehensions, inverting key-value pairs, and sorting dictionaries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndic = {\"key\": \"value\"}  # 基本形式\ndic = {chr(i): i for i in range(65, 91)}  # 大写字母到对应 ASCII 码的映射，注意断句\ndic = dict(zip([chr(i) for i in range(65, 91)], range(65, 91)))  # 效果同上\ndic = {dic[k]: k for k in dic}  # 将键值对逆转，for k in dic 迭代其键\ndic = {v: k for k, v in dic.items()}  # 和上行作用相同，dic.items() 以元组存放单个键值对\ndic = {\n    k: v for k, v in sorted(dic.items(), key=lambda x: -x[1])\n}  # 字典按值逆排序，用到了 lambda 表达式\n\nprint(dic[\"A\"])  # 返回 dic 中 以 'A' 为键的项，这里值为65\ndic[\"a\"] = 97  # 将 d[key] 设为 value，字典中原无 key 就是直接插入\nif \"b\" in dic:  # LBYL(Look Before You Leap) 风格\n    print(dic[\"b\"])  # 若字典中无该键则会出错，故先检查\nelse:\n    dic[\"b\"] = 98\n\n# 经典场景 统计出现次数\n# 新键不存在于原字典，需要额外处理\ntry:  # EAFP (Easier to Ask for Forgiveness than Permission) 风格\n    cnter[key] += 1\nexcept KeyError:\n    cnter[key] = 1\n```\n\n----------------------------------------\n\nTITLE: Enabling File I/O for Local Testing in C++\nDESCRIPTION: This code snippet demonstrates how to use conditional compilation to enable file input/output for local testing in C++. It uses the LOCAL macro to conditionally open input and output files.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/devcpp.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#ifdef LOCAL\nfreopen(\"test.in\", \"r\", stdin);\nfreopen(\"test.out\", \"w\", stdout);\n#endif\n```\n\n----------------------------------------\n\nTITLE: Naive Factorization Algorithm in Python\nDESCRIPTION: A Python implementation of the naive factorization algorithm that tests divisibility from 2 to sqrt(N). This function returns a list containing all prime factors of the input number.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef breakdown(N):\n    result = []\n    for i in range(2, int(sqrt(N)) + 1):\n        if N % i == 0:  # 如果 i 能够整除 N，说明 i 为 N 的一个质因子。\n            while N % i == 0:\n                N //= i\n            result.append(i)\n    if N != 1:  # 说明再经过操作之后 N 留下了一个素数\n        result.append(N)\n    return result\n```\n\n----------------------------------------\n\nTITLE: String Slicing in Python\nDESCRIPTION: Demonstrates Python's powerful string slicing operations. Shows how to extract substrings using the [start:end:step] syntax with optional parameters for flexible string manipulation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> s = 'OI-Wiki 感谢你的阅读\\n欢迎参与贡献!'\n>>> s[:8]  # 省略左闭索引则从头开始\n'OI-Wiki '\n>>> s[8:14]  # 左闭右开设计的妙处，长度为 14-8=6，还和上一个字符串无缝衔接\n'感谢你的阅读'\n>>> s[-4:]  # 省略右开索引则直到结尾\n'与贡献!'\n>>> s[8:14:2]  # 步长为2\n'感你阅'\n>>> s[::-1]  # 步长为 -1 时，获得了反转的字符串\n'!献贡与参迎欢\\n读阅的你谢感 ikiW-IO'\n>>> s  # 但原来的字符串并未改变\n'OI-Wiki 感谢你的阅读\\n欢迎参与贡献!'\n```\n\n----------------------------------------\n\nTITLE: Lambda Capture Examples in C++\nDESCRIPTION: Shows various ways to capture variables in lambda expressions, including by value, by reference, and default capture modes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint a = 0;\nauto f0 = []() { return a * 9; };   // Error, 无法访问 'a'\nauto f1 = [a]() { return a * 9; };  // OK, 'a' 被值「捕获」\nauto f2 = [&a]() { return a++; };   // OK, 'a' 被引用「捕获」\nauto f3 = [v = a + 1]() {\n  return v + 1;\n};  // OK, 使用初始化器声明变量 v，类型与 a 相同\n\n// 注意，使用引用捕获时，请保证被调用时 a 没有被销毁\nauto b = f2();  // f2 从捕获列表里获得 a 的值，无需通过参数传入 a\n```\n\n----------------------------------------\n\nTITLE: Implementing Rollback Mo's Algorithm in C++\nDESCRIPTION: This code demonstrates the implementation of Rollback Mo's Algorithm for solving the JOISC 2014 Day1 Historical Research problem. It handles interval queries to find the maximum importance of a number within a given range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/rollback-mo-algo.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/rollback-mo-algo/rollback-mo-algo_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Block-Segmented Fenwick Tree in C++\nDESCRIPTION: This code implements a block-segmented Fenwick tree data structure for efficient 2D range queries and updates. It includes functions for building the structure, adding/removing points, and querying rectangular regions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bit-in-block-array.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <cstdio>\nusing namespace std;\nconstexpr int N = 2e5 + 5;\nconstexpr int M = 447 + 5;  // sqrt(N) + 5\n\nint n, m, pa[N], pb[N];\n\nint nn, block_size, block_cnt, block_id[N], L[N], R[N], T[M][N];\n\nvoid build(int n) {\n  nn = n;\n  block_size = sqrt(nn);\n  block_cnt = nn / block_size;\n  for (int i = 1; i <= block_cnt; ++i) {\n    L[i] = R[i - 1] + 1;\n    R[i] = i * block_size;\n  }\n  if (R[block_cnt] < nn) {\n    ++block_cnt;\n    L[block_cnt] = R[block_cnt - 1] + 1;\n    R[block_cnt] = nn;\n  }\n  for (int j = 1; j <= block_cnt; ++j)\n    for (int i = L[j]; i <= R[j]; ++i) block_id[i] = j;\n}\n\nint lb(int x) { return x & -x; }\n\nvoid add(int p, int v, int d) {\n  for (int i = block_id[p]; i <= block_cnt; i += lb(i))\n    for (int j = v; j <= nn; j += lb(j)) T[i][j] += d;\n}\n\nint getsum(int p, int v) {\n  if (!p) return 0;\n  int res = 0;\n  int id = block_id[p];\n  for (int i = L[id]; i <= p; ++i)\n    if (pb[i] <= v) ++res;\n  for (int i = id - 1; i; i -= lb(i))\n    for (int j = v; j; j -= lb(j)) res += T[i][j];\n  return res;\n}\n\nvoid update(int x, int y) {\n  add(x, pb[x], -1);\n  add(y, pb[y], -1);\n  swap(pb[x], pb[y]);\n  add(x, pb[x], 1);\n  add(y, pb[y], 1);\n}\n\nint query(int la, int ra, int lb, int rb) {\n  int res = getsum(rb, ra) - getsum(rb, la - 1) - getsum(lb - 1, ra) +\n            getsum(lb - 1, la - 1);\n  return res;\n}\n\nint main() {\n  scanf(\"%d %d\", &n, &m);\n  int v;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &v), pa[v] = i;\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &v), pb[i] = pa[v];\n\n  build(n);\n  for (int i = 1; i <= n; ++i) add(i, pb[i], 1);\n\n  int op, la, lb, ra, rb, x, y;\n  for (int i = 1; i <= m; ++i) {\n    scanf(\"%d\", &op);\n    if (op == 1) {\n      scanf(\"%d %d %d %d\", &la, &ra, &lb, &rb);\n      printf(\"%d\\n\", query(la, ra, lb, rb));\n    } else if (op == 2) {\n      scanf(\"%d %d\", &x, &y);\n      update(x, y);\n    }\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Scapegoat Tree Insertion Operation in C++\nDESCRIPTION: Inserts a new value into the scapegoat tree, maintaining balance by potentially triggering a rebuild operation if the tree becomes unbalanced. Tracks depth during insertion to detect imbalance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconst double alpha = 0.75;\n\nvoid insert(int& x, int v, int dep) {\n  if (!x) {\n    x = ++id;\n    lc[x] = rc[x] = 0;\n    val[x] = v;\n    cnt[x] = sz[x] = 1;\n    tot[x] = 1;\n    tot_active++;\n    return;\n  }\n  tot[x]++;\n  if (v == val[x]) {\n    cnt[x]++;\n    sz[x]++;\n    return;\n  }\n  if (v < val[x]) insert(lc[x], v, dep + 1);\n  else insert(rc[x], v, dep + 1);\n  push_up(x);\n  if (dep > log(tot_active) / log(1.0 / alpha)) {\n    rebuild(x);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete C++ Stream Template for File I/O\nDESCRIPTION: A complete template showing how to use C++ stream classes for file I/O. This includes opening files with ifstream and ofstream, performing I/O operations, and properly closing the streams.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n#include <fstream>\nusing namespace std;  // 两个类型都在 std 命名空间里\n\nifstream fin(\"data.in\");\nofstream fout(\"data.out\");\n\nint main(void) {\n  /*\n  中间的代码改变 cin 为 fin ，cout 为 fout 即可\n  */\n  fin.close();\n  fout.close();\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LSD Radix Sort for K-Key Elements in C++\nDESCRIPTION: This code implements the LSD (Least Significant Digit) radix sort algorithm for sorting elements with K keys. It uses counting sort as a subroutine for stable sorting of each key.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/radix-sort.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int N = 100010;\nconstexpr int W = 100010;\nconstexpr int K = 100;\n\nint n, w[K], k, cnt[W];\n\nstruct Element {\n  int key[K];\n\n  bool operator<(const Element& y) const {\n    // 两个元素的比较流程\n    for (int i = 1; i <= k; ++i) {\n      if (key[i] == y.key[i]) continue;\n      return key[i] < y.key[i];\n    }\n    return false;\n  }\n} a[N], b[N];\n\nvoid counting_sort(int p) {\n  memset(cnt, 0, sizeof(cnt));\n  for (int i = 1; i <= n; ++i) ++cnt[a[i].key[p]];\n  for (int i = 1; i <= w[p]; ++i) cnt[i] += cnt[i - 1];\n  // 为保证排序的稳定性，此处循环i应从n到1\n  // 即当两元素关键字的值相同时，原先排在后面的元素在排序后仍应排在后面\n  for (int i = n; i >= 1; --i) b[cnt[a[i].key[p]]--] = a[i];\n  memcpy(a, b, sizeof(a));\n}\n\nvoid radix_sort() {\n  for (int i = k; i >= 1; --i) {\n    // 借助计数排序完成对关键字的排序\n    counting_sort(i);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding k-th Element in BST in C++\nDESCRIPTION: A function to find the k-th smallest element in a Binary Search Tree by using subtree size information. It recursively narrows the search based on left subtree size and node count. Time complexity is O(h) where h is the tree height.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nint querykth(TreeNode* root, int k) {\n  if (root == nullptr) return -1;  // 或者根据需求返回其他合适的值\n  if (root->left) {\n    if (root->left->size >= k) return querykth(root->left, k);\n    if (root->left->size + root->count >= k) return root->key;\n  } else {\n    if (k == 1) return root->key;\n  }\n  return querykth(root->right,\n                  k - (root->left ? root->left->size : 0) - root->count);\n}\n```\n\n----------------------------------------\n\nTITLE: BFS Implementation with Path Tracking - Python\nDESCRIPTION: Python implementation of BFS using Queue class with path tracking and reconstruction functionality.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/bfs.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom queue import Queue\n\n\ndef bfs(u):\n    Q = Queue()\n    Q.put(u)\n    vis[u] = True\n    d[u] = 0\n    p[u] = -1\n    while Q.qsize() != 0:\n        u = Q.get()\n        i = head[u]\n        while i:\n            if vis[e[i].to] == False:\n                Q.put(e[i].to)\n                vis[e[i].to] = True\n                d[e[i].to] = d[u] + 1\n                p[e[i].to] = u\n            i = e[i].nxt\n\n\ndef restore(x):\n    res = []\n    v = x\n    while v != -1:\n        res.append(v)\n        v = p[v]\n    res.reverse()\n    for i in range(0, len(res)):\n        print(res[i])\n```\n\n----------------------------------------\n\nTITLE: Feasibility Pruning DFS Template in C++\nDESCRIPTION: DFS template implementing feasibility pruning to terminate search paths that cannot lead to valid solutions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/opt.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nint ans = 最坏情况, now;\n\nvoid dfs(传入数值) {\n  if (当前解已不可用) return;\n  if (到达目的地) ans = 从当前解与已有解中选最优;\n  for (遍历所有可能性)\n    if (可行) {\n      进行操作;\n      dfs(缩小规模);\n      撤回操作;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Random Level for Skip List Node in C++\nDESCRIPTION: This function generates a random level for a new Skip List node using a probabilistic approach. It uses a constant probability to determine whether to increase the level, with a maximum level limit.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/skiplist.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint randomLevel() {\n  int lv = 1;\n  // MAXL = 32, S = 0xFFFF, PS = S * P, P = 1 / 4\n  while ((rand() & S) < PS) ++lv;\n  return min(MAXL, lv);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Pollard-Rho Implementation for Finding Largest Prime Factor\nDESCRIPTION: A complete implementation of the Pollard-Rho algorithm for finding the largest prime factor of a large number. It combines Miller-Rabin primality testing with optimized Pollard-Rho factorization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/pollard-rho/pollard-rho_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Rebalancing Case 5 After Deletion in Red-Black Tree (C++)\nDESCRIPTION: Handles final rebalancing case when the sibling is black and distant nephew is red after deletion in a red-black tree. Performs rotations and recoloring to restore tree properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nassert(distantNephew->isRed());\n// Step 1\nrotateSameDirection(node->parent, direction);\n// Step 2\nsibling->color = node->parent->color;\nnode->parent->color = Node::BLACK;\n// Step 3\ndistantNephew->color = Node::BLACK;\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Defining BST Node Structure in C++\nDESCRIPTION: A C++ struct implementation for Binary Search Tree nodes, maintaining key values, pointers to left and right children, and additional metadata such as size (subtree node count) and count (duplicate node count).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\nstruct TreeNode {\n  int key;\n  TreeNode* left;\n  TreeNode* right;\n  // 维护其他信息，如高度，节点数量等\n  int size;   // 当前节点为根的子树大小\n  int count;  // 当前节点的重复数量\n\n  TreeNode(int value)\n      : key(value), size(1), count(1), left(nullptr), right(nullptr) {}\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing 2D Point Update and Submatrix Sum Query with Binary Indexed Trees in C++\nDESCRIPTION: Uses a 2D binary indexed tree to support point updates and submatrix sum queries on a 2D array. The add function updates a single point, while the sum function calculates the sum of a submatrix.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid add(int x, int y, int v) {\n  for (int i = x; i <= n; i += lowbit(i)) {\n    for (int j = y; j <= m; j += lowbit(j)) {\n      c[i][j] += v;\n    }\n  }\n}\n```\n\nLANGUAGE: C++\nCODE:\n```\nint sum(int x, int y) {\n  int res = 0;\n  for (int i = x; i > 0; i -= lowbit(i)) {\n    for (int j = y; j > 0; j -= lowbit(j)) {\n      res += c[i][j];\n    }\n  }\n  return res;\n}\n\nint ask(int x1, int y1, int x2, int y2) {\n  return sum(x2, y2) - sum(x2, y1 - 1) - sum(x1 - 1, y2) + sum(x1 - 1, y1 - 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Lambda Expression Syntax in C++\nDESCRIPTION: Shows the general syntax of a lambda expression in C++, including capture clause, parameters, mutable specifier, return type, and function body.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n[capture] (parameters) mutable -> return-type {statement}\n```\n\n----------------------------------------\n\nTITLE: B+ Tree Implementation with Insert and Delete Operations\nDESCRIPTION: Implementation of a B+ Tree data structure with node management, insertion, deletion, and internal balancing operations. The code includes a Node class for tree nodes and a BPTree class that handles tree operations with a maximum node size of 3.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bplus-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <climits>\n#include <fstream>\n#include <iostream>\n#include <sstream>\nusing namespace std;\nint MAX = 3;\n\nclass BPTree;\n\nclass Node {\n  bool IS_LEAF;\n  int *key, size;\n  Node **ptr;\n  friend class BPTree;\n\n public:\n  Node();\n};\n\nclass BPTree {\n  Node *root;\n  void insertInternal(int, Node *, Node *);\n  void removeInternal(int, Node *, Node *);\n  Node *findParent(Node *, Node *);\n\n public:\n  BPTree();\n  void search(int);\n  void insert(int);\n  void remove(int);\n  void display(Node *);\n  Node *getRoot();\n};\n\nNode::Node() {\n  key = new int[MAX];\n  ptr = new Node *[MAX + 1];\n}\n\nBPTree::BPTree() { root = NULL; }\n\nvoid BPTree::insert(int x) {\n  if (root == NULL) {\n    root = new Node;\n    root->key[0] = x;\n    root->IS_LEAF = true;\n    root->size = 1;\n  } else {\n    Node *cursor = root;\n    Node *parent;\n    while (!cursor->IS_LEAF) {\n      parent = cursor;\n      for (int i = 0; i < cursor->size; i++) {\n        if (x < cursor->key[i]) {\n          cursor = cursor->ptr[i];\n          break;\n        }\n        if (i == cursor->size - 1) {\n          cursor = cursor->ptr[i + 1];\n          break;\n        }\n      }\n    }\n    if (cursor->size < MAX) {\n      int i = 0;\n      while (x > cursor->key[i] && i < cursor->size) i++;\n      for (int j = cursor->size; j > i; j--) {\n        cursor->key[j] = cursor->key[j - 1];\n      }\n      cursor->key[i] = x;\n      cursor->size++;\n      cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];\n      cursor->ptr[cursor->size - 1] = NULL;\n    } else {\n      Node *newLeaf = new Node;\n      int virtualNode[MAX + 1];\n      for (int i = 0; i < MAX; i++) {\n        virtualNode[i] = cursor->key[i];\n      }\n      int i = 0, j;\n      while (x > virtualNode[i] && i < MAX) i++;\n      for (int j = MAX + 1; j > i; j--) {\n        virtualNode[j] = virtualNode[j - 1];\n      }\n      virtualNode[i] = x;\n      newLeaf->IS_LEAF = true;\n      cursor->size = (MAX + 1) / 2;\n      newLeaf->size = MAX + 1 - (MAX + 1) / 2;\n      cursor->ptr[cursor->size] = newLeaf;\n      newLeaf->ptr[newLeaf->size] = cursor->ptr[MAX];\n      cursor->ptr[MAX] = NULL;\n      for (i = 0; i < cursor->size; i++) {\n        cursor->key[i] = virtualNode[i];\n      }\n      for (i = 0, j = cursor->size; i < newLeaf->size; i++, j++) {\n        newLeaf->key[i] = virtualNode[j];\n      }\n      if (cursor == root) {\n        Node *newRoot = new Node;\n        newRoot->key[0] = newLeaf->key[0];\n        newRoot->ptr[0] = cursor;\n        newRoot->ptr[1] = newLeaf;\n        newRoot->IS_LEAF = false;\n        newRoot->size = 1;\n        root = newRoot;\n      } else {\n        insertInternal(newLeaf->key[0], parent, newLeaf);\n      }\n    }\n  }\n}\n\nvoid BPTree::insertInternal(int x, Node *cursor, Node *child) {\n  if (cursor->size < MAX) {\n    int i = 0;\n    while (x > cursor->key[i] && i < cursor->size) i++;\n    for (int j = cursor->size; j > i; j--) {\n      cursor->key[j] = cursor->key[j - 1];\n    }\n    for (int j = cursor->size + 1; j > i + 1; j--) {\n      cursor->ptr[j] = cursor->ptr[j - 1];\n    }\n    cursor->key[i] = x;\n    cursor->size++;\n    cursor->ptr[i + 1] = child;\n  } else {\n    Node *newInternal = new Node;\n    int virtualKey[MAX + 1];\n    Node *virtualPtr[MAX + 2];\n    for (int i = 0; i < MAX; i++) {\n      virtualKey[i] = cursor->key[i];\n    }\n    for (int i = 0; i < MAX + 1; i++) {\n      virtualPtr[i] = cursor->ptr[i];\n    }\n    int i = 0, j;\n    while (x > virtualKey[i] && i < MAX) i++;\n    for (int j = MAX + 1; j > i; j--) {\n      virtualKey[j] = virtualKey[j - 1];\n    }\n    virtualKey[i] = x;\n    for (int j = MAX + 2; j > i + 1; j--) {\n      virtualPtr[j] = virtualPtr[j - 1];\n    }\n    virtualPtr[i + 1] = child;\n    newInternal->IS_LEAF = false;\n    cursor->size = (MAX + 1) / 2;\n    newInternal->size = MAX - (MAX + 1) / 2;\n    for (i = 0, j = cursor->size + 1; i < newInternal->size; i++, j++) {\n      newInternal->key[i] = virtualKey[j];\n    }\n    for (i = 0, j = cursor->size + 1; i < newInternal->size + 1; i++, j++) {\n      newInternal->ptr[i] = virtualPtr[j];\n    }\n    if (cursor == root) {\n      Node *newRoot = new Node;\n      newRoot->key[0] = cursor->key[cursor->size];\n      newRoot->ptr[0] = cursor;\n      newRoot->ptr[1] = newInternal;\n      newRoot->IS_LEAF = false;\n      newRoot->size = 1;\n      root = newRoot;\n    } else {\n      insertInternal(cursor->key[cursor->size], findParent(root, cursor),\n                     newInternal);\n    }\n  }\n}\n\nNode *BPTree::findParent(Node *cursor, Node *child) {\n  Node *parent;\n  if (cursor->IS_LEAF || (cursor->ptr[0])->IS_LEAF) {\n    return NULL;\n  }\n  for (int i = 0; i < cursor->size + 1; i++) {\n    if (cursor->ptr[i] == child) {\n      parent = cursor;\n      return parent;\n    } else {\n      parent = findParent(cursor->ptr[i], child);\n      if (parent != NULL) return parent;\n    }\n  }\n  return parent;\n}\n\nvoid BPTree::remove(int x) {\n  if (root == NULL) {\n    cout << \"Tree empty\\n\";\n  } else {\n    Node *cursor = root;\n    Node *parent;\n    int leftSibling, rightSibling;\n    while (!cursor->IS_LEAF) {\n      for (int i = 0; i < cursor->size; i++) {\n        parent = cursor;\n        leftSibling = i - 1;\n        rightSibling = i + 1;\n        if (x < cursor->key[i]) {\n          cursor = cursor->ptr[i];\n          break;\n        }\n        if (i == cursor->size - 1) {\n          leftSibling = i;\n          rightSibling = i + 2;\n          cursor = cursor->ptr[i + 1];\n          break;\n        }\n      }\n    }\n    bool found = false;\n    int pos;\n    for (pos = 0; pos < cursor->size; pos++) {\n      if (cursor->key[pos] == x) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      cout << \"Not found\\n\";\n      return;\n    }\n    for (int i = pos; i < cursor->size; i++) {\n      cursor->key[i] = cursor->key[i + 1];\n    }\n    cursor->size--;\n    if (cursor == root) {\n      for (int i = 0; i < MAX + 1; i++) {\n        cursor->ptr[i] = NULL;\n      }\n      if (cursor->size == 0) {\n        cout << \"Tree died\\n\";\n        delete[] cursor->key;\n        delete[] cursor->ptr;\n        delete cursor;\n        root = NULL;\n      }\n      return;\n    }\n    cursor->ptr[cursor->size] = cursor->ptr[cursor->size + 1];\n    cursor->ptr[cursor->size + 1] = NULL;\n    if (cursor->size >= (MAX + 1) / 2) {\n      return;\n    }\n    if (leftSibling >= 0) {\n      Node *leftNode = parent->ptr[leftSibling];\n      if (leftNode->size >= (MAX + 1) / 2 + 1) {\n        for (int i = cursor->size; i > 0; i--) {\n          cursor->key[i] = cursor->key[i - 1];\n        }\n        cursor->size++;\n        cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];\n        cursor->ptr[cursor->size - 1] = NULL;\n        cursor->key[0] = leftNode->key[leftNode->size - 1];\n        leftNode->size--;\n        leftNode->ptr[leftNode->size] = cursor;\n        leftNode->ptr[leftNode->size + 1] = NULL;\n        parent->key[leftSibling] = cursor->key[0];\n        return;\n      }\n    }\n    if (rightSibling <= parent->size) {\n      Node *rightNode = parent->ptr[rightSibling];\n      if (rightNode->size >= (MAX + 1) / 2 + 1) {\n        cursor->size++;\n        cursor->ptr[cursor->size] = cursor->ptr[cursor->size - 1];\n        cursor->ptr[cursor->size - 1] = NULL;\n        cursor->key[cursor->size - 1] = rightNode->key[0];\n        rightNode->size--;\n        rightNode->ptr[rightNode->size] = rightNode->ptr[rightNode->size + 1];\n        rightNode->ptr[rightNode->size + 1] = NULL;\n        for (int i = 0; i < rightNode->size; i++) {\n          rightNode->key[i] = rightNode->key[i + 1];\n        }\n        parent->key[rightSibling - 1] = rightNode->key[0];\n        return;\n      }\n    }\n    if (leftSibling >= 0) {\n      Node *leftNode = parent->ptr[leftSibling];\n      for (int i = leftNode->size, j = 0; j < cursor->size; i++, j++) {\n        leftNode->key[i] = cursor->key[j];\n      }\n      leftNode->ptr[leftNode->size] = NULL;\n      leftNode->size += cursor->size;\n      leftNode->ptr[leftNode->size] = cursor->ptr[cursor->size];\n      removeInternal(parent->key[leftSibling], parent, cursor);\n      delete[] cursor->key;\n      delete[] cursor->ptr;\n      delete cursor;\n    } else if (rightSibling <= parent->size) {\n      Node *rightNode = parent->ptr[rightSibling];\n      for (int i = cursor->size, j = 0; j < rightNode->size; i++, j++) {\n        cursor->key[i] = rightNode->key[j];\n      }\n```\n\n----------------------------------------\n\nTITLE: Counting Quadrilaterals in a Graph using Vertex Ordering (C++)\nDESCRIPTION: This code implements an algorithm to count quadrilaterals in a graph by ordering vertices based on their degrees. It enumerates potential quadrilaterals and checks for their existence, with a time complexity of O(m√m).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/rings-count.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 5, M = 2e5 + 5;\nint n, m;\nll ans;\nint h[N], e[M], ne[M], idx;\nint d[N];\nbool st[N];\nstruct node {\n  int id, d;\n  bool operator<(const node &t) const {\n    return d == t.d ? id < t.id : d < t.d;\n  }\n} p[N];\nvoid add(int a, int b) { e[idx] = b, ne[idx] = h[a], h[a] = idx++; }\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(h, -1, sizeof h);\n  for (int i = 1; i <= m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    add(a, b), add(b, a);\n    d[a]++, d[b]++;\n  }\n  for (int i = 1; i <= n; i++) p[i] = {i, d[i]};\n  sort(p + 1, p + n + 1);\n  for (int i = n; i; i--) {\n    int x = p[i].id;\n    for (int j = h[x]; ~j; j = ne[j]) {\n      int y = e[j];\n      if (st[y]) continue;\n      for (int k = h[y]; ~k; k = ne[k]) {\n        int z = e[k];\n        if (st[z] || z == x) continue;\n        ans += 1ll * (d[z] - 1) * (d[z] - 2) / 2;\n      }\n    }\n    st[x] = true;\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Answer Search for Tree Cutting Problem\nDESCRIPTION: Implementation of binary search to find the maximum possible height setting for a wood-cutting machine that yields at least M meters of wood. This demonstrates the binary answer search technique for optimization problems.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/binary.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint a[1000005];\nint n, m;\n\nbool check(int k) {  // 检查可行性，k 为锯片高度\n  long long sum = 0;\n  for (int i = 1; i <= n; i++)       // 检查每一棵树\n    if (a[i] > k)                    // 如果树高于锯片高度\n      sum += (long long)(a[i] - k);  // 累加树木长度\n  return sum >= m;                   // 如果满足最少长度代表可行\n}\n\nint find() {\n  int l = 1, r = 1e9 + 1;   // 因为是左闭右开的，所以 10^9 要加 1\n  while (l + 1 < r) {       // 如果两点不相邻\n    int mid = (l + r) / 2;  // 取中间值\n    if (check(mid))         // 如果可行\n      l = mid;              // 升高锯片高度\n    else\n      r = mid;  // 否则降低锯片高度\n  }\n  return l;  // 返回左边值\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MakeRoot Operation in ETT\nDESCRIPTION: Operation to change the root of the tree by splitting and merging sequences. Converts root change operation into sequence operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/ett.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid MakeRoot(int u) {\n  Node* vertex_u = vertices_[u];\n  auto [L1, L2] = Treap::SplitUp2(vertex_u);\n  Treap::Merge(L2, L1);\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling Stream Synchronization in C++\nDESCRIPTION: Code to disable synchronization between C and C++ streams and unbind cin from cout to improve I/O performance. This is a fundamental optimization for competitive programming.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::ios::sync_with_stdio(false);\nstd::cin.tie(nullptr);\n```\n\n----------------------------------------\n\nTITLE: Implementing Longest Increasing Subsequence (O(n^2)) in Python\nDESCRIPTION: This function implements a quadratic time algorithm for finding the length of the longest increasing subsequence in an array. It uses dynamic programming with a list to store intermediate results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/basic.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\na = [0] * MAXN\nd = [0] * MAXN\n\n\ndef dp():\n    d[1] = 1\n    ans = 1\n    for i in range(2, n + 1):\n        for j in range(1, i):\n            if a[j] <= a[i]:\n                d[i] = max(d[i], d[j] + 1)\n                ans = max(ans, d[i])\n    return ans\n```\n\n----------------------------------------\n\nTITLE: Basic For Loop Structure in C++\nDESCRIPTION: The fundamental structure of a for loop in C++, showing the initialization, condition, and update components.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nfor (初始化; 判断条件; 更新) {\n  循环体;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing LCT for Tree Path Operations\nDESCRIPTION: Implementation of Link Cut Tree data structure with support for path operations like addition, multiplication, path sum queries and tree restructuring. Includes Splay tree operations, access paths, and mark propagation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconstexpr long long MAXN = 100010;\nconstexpr long long mod = 51061;\nlong long n, q, u, v, c;\nchar op;\n\nstruct Splay {\n  long long ch[MAXN][2], fa[MAXN], siz[MAXN], val[MAXN], sum[MAXN], rev[MAXN],\n      add[MAXN], mul[MAXN];\n\n  void clear(long long x) {\n    ch[x][0] = ch[x][1] = fa[x] = siz[x] = val[x] = sum[x] = rev[x] = add[x] =\n        0;\n    mul[x] = 1;\n  }\n\n  // Additional implementation...\n} st;\n\nmain() {\n  scanf(\"%lld%lld\", &n, &q);\n  for (long long i = 1; i <= n; i++) st.val[i] = 1, st.maintain(i);\n  // Rest of implementation...\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: String Searching and Manipulation in C++\nDESCRIPTION: Advanced string operations in C++ including finding substrings, extracting substrings, appending, replacing, and inserting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/lib-func.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstring1.find(ch, start);\nstring1.rfind(ch);\nstring1.substr(start, len);\nstring1.append(s);\nstring1.append(s, pos, n);\nstring1.replace(pos, n, s);\nstring1.erase(pos, n);\nstring1.insert(pos, s);\n```\n\n----------------------------------------\n\nTITLE: Calculating Integer Square Root using Newton's Method in C++\nDESCRIPTION: This function calculates the integer square root using a modified Newton's method. It finds the largest integer x such that x^2 <= n, handling edge cases to ensure correct results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/newton.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint isqrt_newton(int n) {\n  int x = 1;\n  bool decreased = false;\n  for (;;) {\n    int nx = (x + n / x) >> 1;\n    if (x == nx || (nx > x && decreased)) break;\n    decreased = nx < x;\n    x = nx;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Fixed-Width Integer Types and std::numeric_limits in C++\nDESCRIPTION: Demonstrates how to use the std::numeric_limits class template to query properties of arithmetic types such as maximum value, minimum value, and machine epsilon for floating-point types.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <cstdint>\n#include <limits>\n\nstd::numeric_limits<int32_t>::max();  // int32_t 的最大值, 2'147'483'647\nstd::numeric_limits<int32_t>::min();  // int32_t 的最小值, -2'147'483'648\n\nstd::numeric_limits<double>::min();  // double 的最小值, 约为 2.22507e-308\nstd::numeric_limits<double>::epsilon();  // 1.0 与 double 的下个可表示值的差,\n                                         // 约为 2.22045e-16\n```\n\n----------------------------------------\n\nTITLE: Defining Single Linked List Node in C++ and Python\nDESCRIPTION: Defines the structure for a node in a single linked list, containing a value and a pointer to the next node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct Node {\n  int value;\n  Node *next;\n};\n```\n\nLANGUAGE: Python\nCODE:\n```\nclass Node:\n    def __init__(self, value=None, next=None):\n        self.value = value\n        self.next = next\n```\n\n----------------------------------------\n\nTITLE: Bridge Detection With Multiple Edges\nDESCRIPTION: Modified implementation of Tarjan's algorithm that correctly handles multiple edges between vertices. Uses a flag to track if a path back to the parent node has already been found.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/cut.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint low[MAXN], dfn[MAXN], idx;\nbool isbridge[MAXN];\nvector<int> G[MAXN];\nint cnt_bridge;\nint father[MAXN];\n\nvoid tarjan(int u, int fa) {\n  bool flag = false;\n  father[u] = fa;\n  low[u] = dfn[u] = ++idx;\n  for (const auto &v : G[u]) {\n    if (!dfn[v]) {\n      tarjan(v, u);\n      low[u] = min(low[u], low[v]);\n      if (low[v] > dfn[u]) {\n        isbridge[v] = true;\n        ++cnt_bridge;\n      }\n    } else {\n      if (v != fa || flag)\n        low[u] = min(low[u], dfn[v]);\n      else\n        flag = true;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using STL List with Vector for Blocked List in C++\nDESCRIPTION: Demonstrates using STL list with vector of characters to implement a blocked list data structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-list.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nlist<vector<char>> orz_list;\n```\n\n----------------------------------------\n\nTITLE: Space-Optimized Boyer-Moore String Search Implementation in Rust\nDESCRIPTION: A space-efficient implementation of Boyer-Moore algorithm (B5S) that uses a Bloom filter for the character set and a simplified delta1 calculation. This implementation balances memory usage and performance by combining approaches from Sunday and Horspool variations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_10\n\nLANGUAGE: rust\nCODE:\n```\npub struct B5SSpacePattern<'a> {\n    pat_bytes: &'a [u8],\n    alphabet: BytesBloomFilter,\n    skip: usize,\n}\n\nimpl<'a> B5SSpacePattern<'a> {\n    pub fn new(pat: &'a str) -> Self {\n        assert_ne!(pat.len(), 0);\n\n        let pat_bytes = pat.as_bytes();\n        let (alphabet, skip) = B5SSpacePattern::build(pat_bytes);\n\n        B5SSpacePattern { pat_bytes, alphabet, skip}\n    }\n\n    fn build(p: &'a [u8]) -> (BytesBloomFilter, usize)  {\n        let mut alphabet = BytesBloomFilter::new();\n        let lastpos = p.len() - 1;\n        let mut skip = p.len();\n\n        for i in 0..p.len()-1 {\n            alphabet.insert(&p[i]);\n\n            if p[i] == p[lastpos] {\n                skip = lastpos - i;\n            }\n        }\n\n        alphabet.insert(&p[lastpos]);\n\n        (alphabet, skip)\n    }\n\n    pub fn find_all(&self, string: &'a str) -> Vec<usize> {\n        let mut result = vec![];\n        let string_bytes = string.as_bytes();\n        let pat_last_pos = self.pat_bytes.len() - 1;\n        let patlen = self.pat_bytes.len();\n        let stringlen = string_bytes.len();\n        let mut string_index = pat_last_pos;\n\n        while string_index < stringlen {\n            if string_bytes[string_index] == self.pat_bytes[pat_last_pos] {\n                if &string_bytes[string_index-pat_last_pos..string_index] == &self.pat_bytes[..patlen-1] {\n                    result.push(string_index-pat_last_pos);\n                }\n\n                if string_index + 1 == stringlen {\n                    break;\n                }\n\n                if !self.alphabet.contains(&string_bytes[string_index+1]) {\n                    string_index += patlen + 1;  // sunday\n                } else {\n                    string_index += self.skip;  // horspool\n                }\n            } else {\n                if string_index + 1 == stringlen {\n                    break;\n                }\n\n                if !self.alphabet.contains(&string_bytes[string_index+1]) {\n                    string_index += patlen + 1;  // sunday\n                } else {\n                    string_index += 1;\n                }\n            }\n\n        }\n\n        result\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array-based Treap in C++\nDESCRIPTION: This code snippet shows an array-based implementation of a Treap data structure. It is referenced from bzoj and provides a more compact representation of the Treap, potentially offering better cache performance in some scenarios.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/ds/code/treap/treap_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Bucket Sort in Python\nDESCRIPTION: This Python implementation of bucket sort includes an insertion sort function for sorting individual buckets. It uses a list of lists to represent the buckets and follows the same sorting process as the C++ version.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/bucket-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nN = 100010\nw = n = 0\na = [0] * N\nbucket = [[] for i in range(N)]\n\n\ndef insertion_sort(A):\n    for i in range(1, len(A)):\n        key = A[i]\n        j = i - 1\n        while j >= 0 and A[j] > key:\n            A[j + 1] = A[j]\n            j -= 1\n        A[j + 1] = key\n\n\ndef bucket_sort():\n    bucket_size = int(w / n + 1)\n    for i in range(0, n):\n        bucket[i].clear()\n    for i in range(1, n + 1):\n        bucket[int(a[i] / bucket_size)].append(a[i])\n    p = 0\n    for i in range(0, n):\n        insertion_sort(bucket[i])\n        for j in range(0, len(bucket[i])):\n            a[p] = bucket[i][j]\n            p += 1\n```\n\n----------------------------------------\n\nTITLE: Generalized Capture in C++14 Lambda Expressions\nDESCRIPTION: Demonstrates the use of generalized capture in C++14, allowing new variables to be declared and initialized in the capture clause.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nauto f1 = [val = 520]() {\n  return val;\n};  // OK, 定义 val 类型为 int，初始值为 520，返回值类型 int\n\nauto f2 = [val = 520LL]() {\n  return val;\n};  // OK, 定义 val 类型为 long long，初始值为 520，返回值类型 long long\n\nauto f3 = [val = \"520\"]() {\n  return val;\n};  // OK, 定义 val 类型为 const char*，初始值为 \"520\"，返回值类型 const char*\n\nauto f4 = [val = \"520\"s]() {\n  return val;\n};  // OK, C++14 起，需要 using namespace std; 或 using namespace std::literals;\n    // 定义 val 类型为 std::string，初始值为 std::string(\"520\")，返回值类型\n    // std::string\n\nauto f5 = [val = std::string(\"520\")]() {\n  return val;\n};  // OK, 定义 val 类型为 std::string，初始值为 std::string(\"520\")，返回值类型\n    // std::string\n\nauto f6 = [val = std::vector<int>(3, 6)]() {\n  return val;\n};  // OK, 定义 val 类型为 std::vector<int>，大小为 3，元素填充 6，返回值类型\n    // std::vector<int>\n\nauto f7 = [val = 520]() -> int {\n  return val;\n};  // OK, 定义 val 类型为 int，初始值为 520，返回值类型 int\n\nauto f8 = [val = 520]() -> long long {\n  return val;\n};  // OK, 定义 val 类型为 int，初始值为 520，返回值类型 long long\n```\n\n----------------------------------------\n\nTITLE: Handling Case 6 in Red-Black Tree Insertion\nDESCRIPTION: Handles the case where the current node is in the same direction as its parent during insertion. Performs a rotation on the grandparent and recolors nodes to maintain red-black tree properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// clang-format off\n// Case 6: Current node is the same direction as parent\n//   Step 1. If node is a LEFT child, perform r-rotate to grandparent;\n//           If node is a RIGHT child, perform l-rotate to grandparent.\n//   Step 2. Paint parent (before rotate) to BLACK;\n//           Paint grandparent (before rotate) to RED.\n//        [G]                 <P>               [P]\n//        / \\    rotate(G)    / \\    repaint    / \\\n//      <P> [U]  ========>  <N> [G]  ======>  <N> <G>\n//      /                         \\                 \\\n//    <N>                         [U]               [U]\n// clang-format on\nassert(node->grandParent() != nullptr);\n\n// Step 1\nif (node->parent->direction() == Direction::LEFT) {\n  rotateRight(node->grandParent());\n} else {\n  rotateLeft(node->grandParent());\n}\n\n// Step 2\nnode->parent->color = Node::BLACK;\nnode->sibling()->color = Node::RED;\n\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Implementing Brute-Force Search for 2-SAT in C++\nDESCRIPTION: A C++ implementation of a brute-force search algorithm to solve 2-SAT problems. It uses depth-first search to explore possible assignments and backtrack when conflicts are found.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/2-sat.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// 来源：刘汝佳白书第 323 页\nstruct Twosat {\n  int n;\n  vector<int> g[MAXN * 2];\n  bool mark[MAXN * 2];\n  int s[MAXN * 2], c;\n\n  bool dfs(int x) {\n    if (mark[x ^ 1]) return false;\n    if (mark[x]) return true;\n    mark[x] = true;\n    s[c++] = x;\n    for (int i = 0; i < (int)g[x].size(); i++)\n      if (!dfs(g[x][i])) return false;\n    return true;\n  }\n\n  void init(int n) {\n    this->n = n;\n    for (int i = 0; i < n * 2; i++) g[i].clear();\n    memset(mark, 0, sizeof(mark));\n  }\n\n  void add_clause(int x, int y) {  // 这个函数随题意变化\n    g[x].push_back(y ^ 1);         // 选了 x 就必须选 y^1\n    g[y].push_back(x ^ 1);\n  }\n\n  bool solve() {\n    for (int i = 0; i < n * 2; i += 2)\n      if (!mark[i] && !mark[i + 1]) {\n        c = 0;\n        if (!dfs(i)) {\n          while (c > 0) mark[s[--c]] = false;\n          if (!dfs(i + 1)) return false;\n        }\n      }\n    return true;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Function with Pointers in C++\nDESCRIPTION: This is a pointer-based implementation of the merge function that combines two sorted arrays. It uses pointer arithmetic to navigate through the arrays and maintain proper ordering.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid merge(const int *aBegin, const int *aEnd, const int *bBegin,\n               const int *bEnd, int *c) {\n  while (aBegin != aEnd && bBegin != bEnd) {\n    if (*bBegin < *aBegin) {\n      *c = *bBegin;\n      ++bBegin;\n    } else {\n      *c = *aBegin;\n      ++aBegin;\n    }\n    ++c;\n  }\n  for (; aBegin != aEnd; ++aBegin, ++c) *c = *aBegin;\n  for (; bBegin != bEnd; ++bBegin, ++c) *c = *bBegin;\n}\n```\n\n----------------------------------------\n\nTITLE: Using std::flush with std::cout in C++\nDESCRIPTION: An example showing how to properly use std::flush with std::cout after disabling synchronization with stdio. This ensures input prompts are displayed before waiting for input.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstd::cout << \"Please input your name: \"\n          << std::flush;  // 或者: std::endl;\n                          // 因为每次调用 std::endl 都会 flush 输出缓冲区，而 \\n\n                          // 则不会。\n// 但请谨慎使用，过多的 flush 会影响程序效率\nstd::cin >> name;\n```\n\n----------------------------------------\n\nTITLE: Evaluating Infix Expressions with Binary Operators in C++\nDESCRIPTION: This code snippet implements a stack-based algorithm for evaluating infix expressions containing binary operators (+, -, *, /) and parentheses. It converts the infix expression to postfix notation implicitly during evaluation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/expression.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbool delim(char c) { return c == ' '; }\n\nbool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/'; }\n\nint priority(char op) {\n  if (op == '+' || op == '-') return 1;\n  if (op == '*' || op == '/') return 2;\n  return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n  int r = st.top();\n  st.pop();\n  int l = st.top();\n  st.pop();\n  switch (op) {\n    case '+':\n      st.push(l + r);\n      break;\n    case '-':\n      st.push(l - r);\n      break;\n    case '*':\n      st.push(l * r);\n      break;\n    case '/':\n      st.push(l / r);\n      break;\n  }\n}\n\nint evaluate(string& s) {\n  stack<int> st;\n  stack<char> op;\n  for (int i = 0; i < (int)s.size(); i++) {\n    if (delim(s[i])) continue;\n\n    if (s[i] == '(') {\n      op.push('(');\n    } else if (s[i] == ')') {\n      while (op.top() != '(') {\n        process_op(st, op.top());\n        op.pop();\n      }\n      op.pop();\n    } else if (is_op(s[i])) {\n      char cur_op = s[i];\n      while (!op.empty() && priority(op.top()) >= priority(cur_op)) {\n        process_op(st, op.top());\n        op.pop();\n      }\n      op.push(cur_op);\n    } else {\n      int number = 0;\n      while (i < (int)s.size() && isalnum(s[i]))\n        number = number * 10 + s[i++] - '0';\n      --i;\n      st.push(number);\n    }\n  }\n\n  while (!op.empty()) {\n    process_op(st, op.top());\n    op.pop();\n  }\n  return st.top();\n}\n```\n\n----------------------------------------\n\nTITLE: Template Parameter Pack Expansion in C++\nDESCRIPTION: Demonstrates expanding parameter packs in template arguments, showing how to use variadic templates in tuple construction at different positions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_18\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <class A, class B, class... C>\nvoid func(A arg1, B arg2, C... arg3) {\n  tuple<A, B, C...>();  // expands to tuple<A, B, E1, E2, E3>()\n  tuple<C..., A, B>();  // expands to tuple<E1, E2, E3, A, B>()\n  tuple<A, C..., B>();  // expands to tuple<A, E1, E2, E3, B>()\n}\n```\n\n----------------------------------------\n\nTITLE: Modular Exponentiation with Precomputation in C++\nDESCRIPTION: Implements fast modular exponentiation by precomputing powers and storing them in two arrays. Uses a split exponent technique where powers are divided into 16-bit chunks for efficient computation. The preproc function initializes the arrays with precomputed values, while query function handles the actual exponentiation calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nint pow1[65536], pow2[65536];\n\nvoid preproc(int a, int mod) {\n  pow1[0] = pow2[0] = 1;\n  for (int i = 1; i < 65536; i++) pow1[i] = 1LL * pow1[i - 1] * a % mod;\n  int pow65536 = 1LL * pow1[65535] * a % mod;\n  for (int i = 1; i < 65536; i++) pow2[i] = 1LL * pow2[i - 1] * pow65536 % mod;\n}\n\nint query(int pows) { return 1LL * pow1[pows & 65535] * pow2[pows >> 16]; }\n```\n\n----------------------------------------\n\nTITLE: Linear (Euler) Sieve in C++ and Python\nDESCRIPTION: This implementation of the Linear Sieve (also known as Euler Sieve) finds all primes up to n with O(n) time complexity by ensuring each composite number is sieved exactly once by its smallest prime factor.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> pri;\nbool not_prime[N];\n\nvoid pre(int n) {\n  for (int i = 2; i <= n; ++i) {\n    if (!not_prime[i]) {\n      pri.push_back(i);\n    }\n    for (int pri_j : pri) {\n      if (i * pri_j > n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) {\n        // i % pri_j == 0\n        // 换言之，i 之前被 pri_j 筛过了\n        // 由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n        // pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break\n        // 掉就好了\n        break;\n      }\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\npri = []\nnot_prime = [False] * N\n\n\ndef pre(n):\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n        for pri_j in pri:\n            if i * pri_j > n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                \"\"\"\n                i % pri_j == 0\n                换言之，i 之前被 pri_j 筛过了\n                由于 pri 里面质数是从小到大的，所以 i 乘上其他的质数的结果一定会被\n                pri_j 的倍数筛掉，就不需要在这里先筛一次，所以这里直接 break\n                掉就好了\n                \"\"\"\n                break\n```\n\n----------------------------------------\n\nTITLE: Optimized AC Automaton Construction with Topological Sort\nDESCRIPTION: Enhanced version of AC automaton construction that includes in-degree counting for topological sort optimization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid build() {\n  queue<int> q;\n  for (int i = 0; i < 26; i++)\n    if (tr[0].son[i]) q.push(tr[0].son[i]);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < 26; i++) {\n      if (tr[u].son[i]) {\n        tr[tr[u].son[i]].fail = tr[tr[u].fail].son[i];\n        tr[tr[tr[u].fail].son[i]].du++;  // in-degree count\n        q.push(tr[u].son[i]);\n      } else\n        tr[u].son[i] = tr[tr[u].fail].son[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Naive Z Function Implementation in C++\nDESCRIPTION: A simple O(n^2) implementation of the Z function algorithm in C++. It calculates the Z array by comparing characters directly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/z-func.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> z_function_trivial(string s) {\n  int n = (int)s.length();\n  vector<int> z(n);\n  for (int i = 1; i < n; ++i)\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];\n  return z;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Weight Graph for Blossom Algorithm in C++\nDESCRIPTION: Initialization function for the weight graph used in the Blossom algorithm. It sets all edges to 0 weight before inputting the actual graph edges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_11\n\nLANGUAGE: c++\nCODE:\n```\nvoid init_weight_graph() {\n  // 在把边输入到图里面前必须要初始化\n  // 因为是最大权匹配所以把不存在的边设为0\n  for (int u = 1; u <= n; ++u)\n    for (int v = 1; v <= n; ++v) g[u][v] = edge(u, v, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Vector for Dynamic Arrays in C++\nDESCRIPTION: Demonstrates how to use the C++ Standard Library's vector container as a dynamic array, showing declaration, insertion, and element access.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n#include <vector>  // 导入 vector 库\n\nint main() {\n  std::vector<int> a;  // 声明 vector a 并定义 a 为空 vector 对象\n  int n;\n\n  std::cin >> n;\n  // 读取 a\n  for (int i = 0; i < n; i++) {\n    int t;\n    std::cin >> t;\n    a.push_back(t);  // 将读入的数字 t，放到 vector a 的末尾；该操作复杂度 O(1)\n    /* 这里不能使用下标访问来赋值，因为声明时，a 大小依然为空，\n    此处使用 `a[i] = t;` 是错误做法。\n    */\n  }\n\n  // 将读入到 a 中的所有数打印出\n  for (int i = 0; i < n; i++) {\n    std::cout << a[i] << \", \";  // !注意，a 中第一个数是 a[0]；\n    // 如果下标越界，它会返回一个未知的值（溢出），而不会报错\n  }\n  std::cout << std::endl;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Block Forest in C++\nDESCRIPTION: This code implements the full algorithm for constructing a block forest from a graph. It uses a modified Tarjan's algorithm to identify biconnected components and build the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/block-forest.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n\nconstexpr int MN = 100005;\n\nint N, M, cnt;\nstd::vector<int> G[MN], T[MN * 2];\n\nint dfn[MN], low[MN], dfc;\nint stk[MN], tp;\n\nvoid Tarjan(int u) {\n  printf(\"  Enter : #%d\\n\", u);\n  low[u] = dfn[u] = ++dfc;                // low 初始化为当前节点 dfn\n  stk[++tp] = u;                          // 加入栈中\n  for (int v : G[u]) {                    // 遍历 u 的相邻节点\n    if (!dfn[v]) {                        // 如果未访问过\n      Tarjan(v);                          // 递归\n      low[u] = std::min(low[u], low[v]);  // 未访问的和 low 取 min\n      if (low[v] == dfn[u]) {  // 标志着找到一个以 u 为根的点双连通分量\n        ++cnt;                 // 增加方点个数\n        printf(\"  Found a New BCC #%d.\\n\", cnt - N);\n        // 将点双中除了 u 的点退栈，并在圆方树中连边\n        for (int x = 0; x != v; --tp) {\n          x = stk[tp];\n          T[cnt].push_back(x);\n          T[x].push_back(cnt);\n          printf(\"    BCC #%d has vertex #%d\\n\", cnt - N, x);\n        }\n        // 注意 u 自身也要连边（但不退栈）\n        T[cnt].push_back(u);\n        T[u].push_back(cnt);\n        printf(\"    BCC #%d has vertex #%d\\n\", cnt - N, u);\n      }\n    } else\n      low[u] = std::min(low[u], dfn[v]);  // 已访问的和 dfn 取 min\n  }\n  printf(\"  Exit : #%d : low = %d\\n\", u, low[u]);\n  printf(\"  Stack:\\n    \");\n  for (int i = 1; i <= tp; ++i) printf(\"%d, \", stk[i]);\n  puts(\"\");\n}\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  cnt = N;  // 点双 / 方点标号从 N 开始\n  for (int i = 1; i <= M; ++i) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    G[u].push_back(v);  // 加双向边\n    G[v].push_back(u);\n  }\n  // 处理非连通图\n  for (int u = 1; u <= N; ++u)\n    if (!dfn[u]) Tarjan(u), --tp;\n  // 注意到退出 Tarjan 时栈中还有一个元素即根，将其退栈\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Node into Treap (C++)\nDESCRIPTION: This function inserts a new node with a given value into the treap. It uses splitting and merging operations to maintain the treap properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nvoid insert(int val) {\n  auto temp = split(root, val);\n  // 根据 val 的值把整个树分成两个\n  // 注意 split 的实现，等于 val 的子树是在左子树的\n  auto l_tr = split(temp.first, val - 1);\n  // l_tr 的左子树 <= val - 1，如果有 = val 的节点，那一定在右子树\n  Node *new_node;\n  if (l_tr.second == nullptr) {\n    // 没有这个节点就新开，否则直接增加重复次数。\n    new_node = new Node(val);\n  } else {\n    l_tr.second->cnt++;\n    l_tr.second->upd_siz();\n  }\n  Node *l_tr_combined =\n      merge(l_tr.first, l_tr.second == nullptr ? new_node : l_tr.second);\n  // 合并 T_1 left 和 T_1 right\n  root = merge(l_tr_combined, temp.second);\n  // 合并 T_1 和 T_2\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Mo's Algorithm Implementation in C++\nDESCRIPTION: Core implementation of Mo's Algorithm showing the main move and solve functions. The move() function updates running answers while solve() processes queries in optimized order based on block indices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid move(int pos, int sign) {\n  // update nowAns\n}\n\nvoid solve() {\n  BLOCK_SIZE = int(ceil(pow(n, 0.5)));\n  sort(querys, querys + m);\n  for (int i = 0; i < m; ++i) {\n    const query &q = querys[i];\n    while (l > q.l) move(--l, 1);\n    while (r < q.r) move(++r, 1);\n    while (l < q.l) move(l++, -1);\n    while (r > q.r) move(r--, -1);\n    ans[q.id] = nowAns;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Modifying and removing elements in pb_ds priority queues\nDESCRIPTION: Shows the usage of increase_key and decrease_key methods for modifying element priorities, and the ability to remove individual elements from pb_ds priority queues. These operations provide more flexibility compared to standard STL priority queues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/index.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nincrease_key\n```\n\nLANGUAGE: C++\nCODE:\n```\ndecrease_key\n```\n\n----------------------------------------\n\nTITLE: List Traversal Methods in Java\nDESCRIPTION: Shows different ways to traverse List collections including basic for loop, enhanced for loop, and iterator approach with complexity analysis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static List<Integer> array = new ArrayList<>();\n    static List<Integer> linked = new LinkedList<>();\n    \n    static void function1() {  // 朴素遍历\n        for (int i = 0; i < array.size(); i++) {\n            out.println(array.get(i));  // 遍历自增数组，复杂度为 O(n)\n        }\n        for (int i = 0; i < linked.size(); i++) {\n            out.println(linked.get(i));  // 遍历双链表，复杂度为 O(n^2)，因为 LinkedList 的 get(i) 复杂度是 O(i)\n        }\n    }\n\n    static void function2() {  // 增强 for 循环遍历 \n        for (int e : array) {\n            out.println(e);\n        }\n        for (int e : linked) {\n            out.println(e);  // 复杂度均为 O(n) \n        }\n    }\n\n    static void function3() {  // 迭代器遍历 \n        Iterator<Integer> iterator1 = array.iterator();\n        Iterator<Integer> iterator2 = linked.iterator();\n        while (iterator1.hasNext()) {\n            out.println(iterator1.next());\n        }\n        while (iterator2.hasNext()) {\n            out.println(iterator2.next());\n        }  // 复杂度均为 O(n) \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Lazy Propagation for Splay Tree in C++\nDESCRIPTION: These functions manage lazy propagation for interval operations in a Splay tree. They include methods to reverse a subtree and push down lazy tags to child nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/splay.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/splay/splay-2.cpp:11:22\"\n```\n\n----------------------------------------\n\nTITLE: Building Splay Tree from Sequence in C++\nDESCRIPTION: This function builds a Splay tree from a given sequence by creating a chain of left children. It adds sentinel nodes at both ends of the sequence for easier interval operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/splay.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/splay/splay-2.cpp:58:67\"\n```\n\n----------------------------------------\n\nTITLE: Range Update with Increment in C++\nDESCRIPTION: Implementation of segment tree range update operation that adds a value to all elements in a given range. Uses lazy propagation to handle updates efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid update(int l, int r, int c, int s, int t, int p) {\n  if (l <= s && t <= r) {\n    d[p] += (t - s + 1) * c, b[p] += c;\n    return;\n  }\n  int m = s + ((t - s) >> 1);\n  if (b[p] && s != t) {\n    d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m);\n    b[p * 2] += b[p], b[p * 2 + 1] += b[p];\n    b[p] = 0;\n  }\n  if (l <= m) update(l, r, c, s, m, p * 2);\n  if (r > m) update(l, r, c, m + 1, t, p * 2 + 1);\n  d[p] = d[p * 2] + d[p * 2 + 1];\n}\n```\n\n----------------------------------------\n\nTITLE: Hash Table Implementation using Open Hashing in Python\nDESCRIPTION: Python implementation of a hash table using the chaining method, featuring Node class and basic hash table operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/hash.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nM = 999997\nSIZE = 1000000\n\n\nclass Node:\n    def __init__(self, next=None, value=None, key=None):\n        self.next = next\n        self.value = value\n        self.key = key\n\n\ndata = [Node() for _ in range(SIZE)]\nhead = [0] * M\nsize = 0\n\n\ndef f(key):\n    return key % M\n\n\ndef get(key):\n    p = head[f(key)]\n    while p:\n        if data[p].key == key:\n            return data[p].value\n        p = data[p].next\n    return -1\n\n\ndef modify(key, value):\n    p = head[f(key)]\n    while p:\n        if data[p].key == key:\n            data[p].value = value\n            return data[p].value\n        p = data[p].next\n\n\ndef add(key, value):\n    if get(key) != -1:\n        return -1\n    size = size + 1\n    data[size] = Node(head[f(key)], value, key)\n    head[f(key)] = size\n    return value\n```\n\n----------------------------------------\n\nTITLE: Numeric Operations in Python\nDESCRIPTION: Shows Python's numeric operations including division, floor division, modulo and scientific notation. Highlights differences between Python and C/C++ in handling division and modulo operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> 5.0 * 6  # 浮点数的运算结果是浮点数\n30.0\n>>> 15 / 3  # 与 C/C++ 不同，除法永远返回浮点 float 类型\n5.0\n>>> 5 / 100000  # 位数太多，结果显示成科学计数法形式\n5e-05\n>>> 5 // 3 # 使用整数除法（地板除）则会向下取整，输出整数类型\n1\n>>> -5 // 3 # 符合向下取整原则，注意这与 C/C++ 不同\n-2\n>>> 5 % 3 # 取模\n2\n>>> -5 % 3 # 负数取模结果一定是非负数，这点也与 C/C++ 不同，不过都满足 (a//b)*b+(a%b)==a \n1\n>>> x = abs(-1e4)  # 求绝对值的内置函数\n>>> x += 1  # 没有自增/自减运算符\n>>> x  # 科学计数法默认为 float\n10001.0\n```\n\n----------------------------------------\n\nTITLE: Implementing Kahan Summation in C++\nDESCRIPTION: This function implements the Kahan summation algorithm in C++. It takes a vector of floats as input and returns the sum with reduced rounding error. The algorithm uses a compensation variable 'c' to accumulate lost low-order bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/kahan-summation.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nfloat kahanSum(vector<float> nums) {\n  float sum = 0.0f;\n  float c = 0.0f;\n  for (auto num : nums) {\n    float y = num - c;\n    float t = sum + y;\n    c = (t - sum) - y;\n    sum = t;\n  }\n  return sum;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Chu-Liu/Edmonds Algorithm for DMST\nDESCRIPTION: A C++ implementation of the Chu-Liu/Edmonds algorithm to find the minimum spanning tree in a directed graph. The algorithm works by iteratively selecting minimum incoming edges and handling cycles through contraction. Time complexity is O(nm).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dmst.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nbool solve() {\n  ans = 0;\n  int u, v, root = 0;\n  for (;;) {\n    f(i, 0, n) in[i] = 1e100;\n    f(i, 0, m) {\n      u = e[i].s;\n      v = e[i].t;\n      if (u != v && e[i].w < in[v]) {\n        in[v] = e[i].w;\n        pre[v] = u;\n      }\n    }\n    f(i, 0, m) if (i != root && in[i] > 1e50) return 0;\n    int tn = 0;\n    memset(id, -1, sizeof id);\n    memset(vis, -1, sizeof vis);\n    in[root] = 0;\n    f(i, 0, n) {\n      ans += in[i];\n      v = i;\n      while (vis[v] != i && id[v] == -1 && v != root) {\n        vis[v] = i;\n        v = pre[v];\n      }\n      if (v != root && id[v] == -1) {\n        for (int u = pre[v]; u != v; u = pre[u]) id[u] = tn;\n        id[v] = tn++;\n      }\n    }\n    if (tn == 0) break;\n    f(i, 0, n) if (id[i] == -1) id[i] = tn++;\n    f(i, 0, m) {\n      u = e[i].s;\n      v = e[i].t;\n      e[i].s = id[u];\n      e[i].t = id[v];\n      if (e[i].s != e[i].t) e[i].w -= in[v];\n    }\n    n = tn;\n    root = id[root];\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving UOJ #78 Bipartite Graph Maximum Matching in C++\nDESCRIPTION: This code solves the UOJ #78 problem, which is a template problem for bipartite graph maximum matching. It uses the augmenting path algorithm implemented in the previous snippet to find the maximum matching and output the result.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/bigraph-match.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct augment_path {\n  vector<vector<int>> g;\n  vector<int> pa;  // 匹配\n  vector<int> pb;\n  vector<int> vis;  // 访问\n  int n, m;         // 顶点和边的数量\n  int dfn;          // 时间戳记\n  int res;          // 匹配数\n\n  augment_path(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    vis = vector<int>(n);\n    g.resize(n);\n    res = 0;\n    dfn = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    vis[v] = dfn;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pb[u] = v;\n        pa[v] = u;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (vis[pb[u]] != dfn && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      dfn++;\n      int cnt = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          cnt++;\n        }\n      }\n      if (cnt == 0) {\n        break;\n      }\n      res += cnt;\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n, m, e;\n  cin >> n >> m >> e;\n  augment_path solver(n, m);\n  int u, v;\n  for (int i = 0; i < e; i++) {\n    cin >> u >> v;\n    u--, v--;\n    solver.add(u, v);\n  }\n  cout << solver.solve() << \"\\n\";\n  for (int i = 0; i < n; i++) {\n    cout << solver.pa[i] + 1 << \" \";\n  }\n  cout << \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Segments in Li Chao Tree\nDESCRIPTION: This function updates the Li Chao tree by inserting a new line segment. It compares the new segment with existing ones and recursively updates child nodes as needed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/li-chao-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr double eps = 1e-9;\n\nint cmp(double x, double y) {  // 因为用到了浮点数，所以会有精度误差\n  if (x - y > eps) return 1;\n  if (y - x > eps) return -1;\n  return 0;\n}\n\n//...\n\nvoid upd(int root, int cl, int cr, int u) {  // 对线段完全覆盖到的区间进行修改\n  int &v = s[root], mid = (cl + cr) >> 1;\n  int bmid = cmp(calc(u, mid), calc(v, mid));\n  if (bmid == 1 || (!bmid && u < v))  // 在此题中记得判线段编号\n    swap(u, v);\n  int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));\n  if (bl == 1 || (!bl && u < v)) upd(root << 1, cl, mid, u);\n  if (br == 1 || (!br && u < v)) upd(root << 1 | 1, mid + 1, cr, u);\n  // 上面两个 if 的条件最多只有一个成立，这保证了李超树的时间复杂度\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Comparator for Set (C++)\nDESCRIPTION: Shows how to define a custom comparator for a set to maintain integers with larger values at the front.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/associative-container.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct cmp {\n  bool operator()(int a, int b) const { return a > b; }\n};\n\nset<int, cmp> s;\n```\n\n----------------------------------------\n\nTITLE: Using Ranges Library with Iota View and Filter in C++20\nDESCRIPTION: Demonstrates using the C++20 ranges library with views::iota to generate a sequence and views::filter to filter elements based on a predicate function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <ranges>\n\nint main() {\n  const auto even = [](int i) { return 0 == i % 2; };\n\n  for (int i : std::views::iota(0, 6) | std::views::filter(even))\n    std::cout << i << ' ';\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boyer-Moore Search with Galil Rule in Rust\nDESCRIPTION: Implementation of Boyer-Moore string search algorithm with Galil Rule optimization for improved worst-case performance. Uses delta1 (bad character) and delta2 (good suffix) tables along with period calculation for linear time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_pointer_width = \"64\")]\nconst LARGE: usize = 10_000_000_000_000_000_000;\n\n#[cfg(not(target_pointer_width = \"64\"))]\nconst LARGE: usize = 2_000_000_000;\n\npub struct BMPattern<'a> {\n    pat_bytes: &'a [u8],\n    delta_1: [usize; 256],\n    delta_2: Vec<usize>,\n    k: usize\n}\n\nimpl<'a> BMPattern<'a> {\n    pub fn find_all(&self, string: &str) -> Vec<usize> {\n        let mut result = vec![];\n        let string_bytes = string.as_bytes();\n        let stringlen = string_bytes.len();\n        let patlen = self.pat_bytes.len();\n        let pat_last_pos = patlen - 1;\n        let mut string_index = pat_last_pos;\n        let mut pat_index;\n        let l0 =  patlen - self.k;\n        let mut l = 0;\n\n        while string_index < stringlen {\n            let old_string_index = string_index;\n\n            while string_index < stringlen {\n                string_index += self.delta0(string_bytes[string_index]);\n            }\n            if string_index < LARGE {\n                break;\n            }\n\n            string_index -= LARGE;\n\n            if old_string_index < string_index {\n                l = 0;\n            }\n\n            pat_index = pat_last_pos;\n\n            while pat_index > l && string_bytes[string_index] == self.pat_bytes[pat_index] {\n                string_index -= 1;\n                pat_index -= 1;\n            }\n\n            if pat_index == l && string_bytes[string_index] == self.pat_bytes[pat_index] {\n                result.push(string_index - l);\n\n                string_index += pat_last_pos - l + self.k;\n                l = l0;\n            } else {\n                l = 0;\n                string_index += max(\n                    self.delta_1[string_bytes[string_index] as usize],\n                    self.delta_2[pat_index],\n                );\n            }\n        }\n\n        result\n    }\n```\n\n----------------------------------------\n\nTITLE: Pulling Changes from Remote Repository in Git\nDESCRIPTION: This command fetches changes from a remote repository and merges them into the current branch. By default, it's equivalent to running 'git fetch' followed by 'git merge FETCH_HEAD'.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/git.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ git pull <remote-name> <branch> # 获取 <remote-name> 的更改，然后将这些更改合并到 HEAD\n```\n\n----------------------------------------\n\nTITLE: Implementing Floyd-Warshall for Minimum Cycle in Python\nDESCRIPTION: This Python implementation of the Floyd-Warshall algorithm finds the minimum cycle in a graph. It initializes the distance matrix, updates the answer by checking cycles through each vertex, and performs the standard Floyd-Warshall updates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/min-cycle.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nval = [[0 for i in range(MAXN + 1)] for j in range(MAXN + 1)]  # 原图的邻接矩阵\n\n\ndef floyd(n):\n    dis = [[0 for i in range(MAXN + 1)] for j in range(MAXN + 1)]  # 最短路矩阵\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            dis[i][j] = val[i][j]  # 初始化最短路矩阵\n    ans = inf\n    for k in range(1, n + 1):\n        for i in range(1, k):\n            for j in range(1, i):\n                ans = min(ans, dis[i][j] + val[i][k] + val[k][j])  # 更新答案\n        for i in range(1, n + 1):\n            for j in range(1, n + 1):\n                dis[i][j] = min(\n                    dis[i][j], dis[i][k] + dis[k][j]\n                )  # 正常的 floyd 更新最短路矩阵\n    return ans\n```\n\n----------------------------------------\n\nTITLE: Pollard-Rho Algorithm with Floyd Cycle Detection in Python\nDESCRIPTION: Python implementation of the Pollard-Rho algorithm using Floyd's cycle detection. The function generates a pseudorandom sequence and attempts to find a cycle, which indicates a factor of the input number.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nimport random\n\ndef Pollard_Rho(N):\n    c = random.randint(1, N - 1)\n    t = f(0, c, N)\n    r = f(f(0, c, N), c, N)\n    while t != r:\n        d = gcd(abs(t - r), N)\n        if d > 1:\n            return d\n        t = f(t, c, N)\n        r = f(f(r, c, N), c, N)\n    return N\n```\n\n----------------------------------------\n\nTITLE: Implementing Meld Operation for Pairing Heap in C++\nDESCRIPTION: Merges two pairing heaps by making the root with the larger value a child of the root with the smaller value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nNode* meld(Node* x, Node* y) {\n  // 若有一个为空则直接返回另一个\n  if (x == nullptr) return y;\n  if (y == nullptr) return x;\n  if (x->v > y->v) std::swap(x, y);  // swap后x为权值小的堆，y为权值大的堆\n  // 将y设为x的儿子\n  y->sibling = x->child;\n  x->child = y;\n  return x;  // 新的根节点为 x\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Tarjan's DMST Algorithm\nDESCRIPTION: A C++ implementation of Tarjan's algorithm for finding minimum spanning trees in directed graphs. Uses Union-Find data structure and leftist heap for efficient processing. Achieves O(m+n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dmst.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nusing ll = long long;\nconstexpr int MAXN = 102;\nconstexpr int INF = 0x3f3f3f3f;\n\nstruct UnionFind {\n  int fa[MAXN << 1];\n\n  UnionFind() { memset(fa, 0, sizeof(fa)); }\n\n  void clear(int n) { memset(fa + 1, 0, sizeof(int) * n); }\n\n  int find(int x) { return fa[x] ? fa[x] = find(fa[x]) : x; }\n\n  int operator[](int x) { return find(x); }\n};\n\nstruct Edge {\n  int u, v, w, w0;\n};\n\nstruct Heap {\n  Edge *e;\n  int rk, constant;\n  Heap *lch, *rch;\n\n  Heap(Edge *_e) : e(_e), rk(1), constant(0), lch(NULL), rch(NULL) {}\n\n  void push() {\n    if (lch) lch->constant += constant;\n    if (rch) rch->constant += constant;\n    e->w += constant;\n    constant = 0;\n  }\n};\n\nHeap *merge(Heap *x, Heap *y) {\n  if (!x) return y;\n  if (!y) return x;\n  if (x->e->w + x->constant > y->e->w + y->constant) swap(x, y);\n  x->push();\n  x->rch = merge(x->rch, y);\n  if (!x->lch || x->lch->rk < x->rch->rk) swap(x->lch, x->rch);\n  if (x->rch)\n    x->rk = x->rch->rk + 1;\n  else\n    x->rk = 1;\n  return x;\n}\n\nEdge *extract(Heap *&x) {\n  Edge *r = x->e;\n  x->push();\n  x = merge(x->lch, x->rch);\n  return r;\n}\n\nvector<Edge> in[MAXN];\nint n, m, fa[MAXN << 1], nxt[MAXN << 1];\nEdge *ed[MAXN << 1];\nHeap *Q[MAXN << 1];\nUnionFind id;\n\nvoid contract() {\n  bool mark[MAXN << 1];\n  for (int i = 1; i <= n; i++) {\n    queue<Heap *> q;\n    for (int j = 0; j < in[i].size(); j++) q.push(new Heap(&in[i][j]));\n    while (q.size() > 1) {\n      Heap *u = q.front();\n      q.pop();\n      Heap *v = q.front();\n      q.pop();\n      q.push(merge(u, v));\n    }\n    Q[i] = q.front();\n  }\n  mark[1] = true;\n  for (int a = 1, b = 1, p; Q[a]; b = a, mark[b] = true) {\n    do {\n      ed[a] = extract(Q[a]);\n      a = id[ed[a]->u];\n    } while (a == b && Q[a]);\n    if (a == b) break;\n    if (!mark[a]) continue;\n    for (a = b, n++; a != n; a = p) {\n      id.fa[a] = fa[a] = n;\n      if (Q[a]) Q[a]->constant -= ed[a]->w;\n      Q[n] = merge(Q[n], Q[a]);\n      p = id[ed[a]->u];\n      nxt[p == n ? b : p] = a;\n    }\n  }\n}\n\nll expand(int x, int r);\n\nll expand_iter(int x) {\n  ll r = 0;\n  for (int u = nxt[x]; u != x; u = nxt[u]) {\n    if (ed[u]->w0 >= INF)\n      return INF;\n    else\n      r += expand(ed[u]->v, u) + ed[u]->w0;\n  }\n  return r;\n}\n\nll expand(int x, int t) {\n  ll r = 0;\n  for (; x != t; x = fa[x]) {\n    r += expand_iter(x);\n    if (r >= INF) return INF;\n  }\n  return r;\n}\n\nvoid link(int u, int v, int w) { in[v].push_back({u, v, w, w}); }\n\nint main() {\n  int rt;\n  scanf(\"%d %d %d\", &n, &m, &rt);\n  for (int i = 0; i < m; i++) {\n    int u, v, w;\n    scanf(\"%d %d %d\", &u, &v, &w);\n    link(u, v, w);\n  }\n  for (int i = 1; i <= n; i++) link(i > 1 ? i - 1 : n, i, INF);\n  contract();\n  ll ans = expand(rt, n);\n  if (ans >= INF)\n    puts(\"-1\");\n  else\n    printf(\"%lld\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Fast I/O Implementation Using fread/fwrite in C++\nDESCRIPTION: A comprehensive implementation of optimized I/O operations using fread and fwrite functions. This approach reads and writes data in blocks for maximum performance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nnamespace IO {\nconstexpr int MAXSIZE = 1 << 20;\nchar buf[MAXSIZE], *p1, *p2;\n#define gc()                                                               \\\n  (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\\n       ? EOF                                                               \\\n       : *p1++)\n\nint rd() {\n  int x = 0, f = 1;\n  char c = gc();\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = gc();\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc();\n  return x * f;\n}\n\nchar pbuf[1 << 20], *pp = pbuf;\n\nvoid push(const char &c) {\n  if (pp - pbuf == 1 << 20) fwrite(pbuf, 1, 1 << 20, stdout), pp = pbuf;\n  *pp++ = c;\n}\n\nvoid write(int x) {\n  static int sta[35];\n  int top = 0;\n  do {\n    sta[top++] = x % 10, x /= 10;\n  } while (x);\n  while (top) push(sta[--top] + '0');\n}\n}  // namespace IO\n```\n\n----------------------------------------\n\nTITLE: DLX Data Structure Initialization in C++\nDESCRIPTION: Declares core data structures for DLX including size arrays, linked list pointers, column/row trackers with a max size constant MS.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int MS = 1e5 + 5;\nint n, m, idx, first[MS], siz[MS];\nint L[MS], R[MS], U[MS], D[MS];\nint col[MS], row[MS];\n```\n\n----------------------------------------\n\nTITLE: Implementing Simplex Algorithm in C++\nDESCRIPTION: This C++ code implements the Simplex algorithm for solving linear programming problems. It includes functions for pivoting, finding the entering and leaving variables, and the main simplex procedure. The code is optimized for performance and handles precision issues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/simplex.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/simplex/simplex_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Initializer Pack Expansion in C++\nDESCRIPTION: Shows how to expand parameter packs in constructor initializers, allowing variadic arguments to be passed to constructors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_17\n\nLANGUAGE: cpp\nCODE:\n```\nClass c1(&args...);  // calls Class::Class(&E1, &E2, &E3)\n```\n\n----------------------------------------\n\nTITLE: Naive Z Function Implementation in Python\nDESCRIPTION: A simple O(n^2) implementation of the Z function algorithm in Python. It calculates the Z array by comparing characters directly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/z-func.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef z_function_trivial(s):\n    n = len(s)\n    z = [0] * n\n    for i in range(1, n):\n        while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n            z[i] += 1\n    return z\n```\n\n----------------------------------------\n\nTITLE: Fermat Primality Test Implementation in C++ and Python\nDESCRIPTION: Basic implementation of the Fermat primality test, a probabilistic algorithm based on Fermat's Little Theorem. It tests if a^(n-1) ≡ 1 (mod n) for randomly selected bases a and performs multiple iterations to reduce false positives.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbool millerRabin(int n) {\n  if (n < 3) return n == 2;\n  // test_time 为测试次数,建议设为不小于 8\n  // 的整数以保证正确率,但也不宜过大,否则会影响效率\n  for (int i = 1; i <= test_time; ++i) {\n    int a = rand() % (n - 2) + 2;\n    if (quickPow(a, n - 1, n) != 1) return false;\n  }\n  return true;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef millerRabin(n):\n    if n < 3:\n        return n == 2\n    # test_time 为测试次数,建议设为不小于 8\n    # 的整数以保证正确率,但也不宜过大,否则会影响效率\n    for i in range(1, test_time + 1):\n        a = random.randint(0, 32767) % (n - 2) + 2\n        if quickPow(a, n - 1, n) != 1:\n            return False\n    return True\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS using Forward Star in Java\nDESCRIPTION: This snippet shows how to implement Depth First Search using a forward star graph representation in Java. It uses a global array to store edges and a boolean array to track visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\npublic void dfs(int u) {\n    vis[u] = true;\n    for (int i = head[u]; i != 0; i = e[i].x) {\n        if (!vis[e[i].t]) {\n            dfs(v);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optimizing Missile Interception Problem using CDQ Divide and Conquer in C++\nDESCRIPTION: This code applies CDQ divide and conquer to optimize a missile interception problem. It calculates the probability of each missile being intercepted based on height and speed constraints.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/cdq-divide.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/cdq-divide/cdq-divide_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Container in C++\nDESCRIPTION: Different ways to define and initialize an STL queue container with various data types and underlying containers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nstd::queue<TypeName> q;  // 使用默认底层容器 deque，数据类型为 TypeName\nstd::queue<TypeName, Container> q;  // 使用 Container 作为底层容器\n\nstd::queue<TypeName> q2(q1);  // 将 s1 复制一份用于构造 q2\n```\n\n----------------------------------------\n\nTITLE: Implementing MSD Radix Sort for Unsigned Integers in C++\nDESCRIPTION: This code implements an iterative MSD radix sort algorithm for sorting unsigned integers. It uses bit manipulation and can be adjusted by changing the W and log2W values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/radix-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/basic/code/radix-sort/radix-sort_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Decrease-Key Operation for Pairing Heap in C++\nDESCRIPTION: Decreases the value of a node in the pairing heap and restructures the heap to maintain the heap property.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nNode *decrease_key(Node *root, Node *x, LL v) {\n  x->v = v;                 // 更新权值\n  if (x == root) return x;  // 如果 x 为根，则直接返回\n  // 把x从fa的子节点中剖出去，这里要分x的位置讨论一下。\n  if (x->father->child == x) {\n    x->father->child = x->sibling;\n  } else {\n    x->father->sibling = x->sibling;\n  }\n  if (x->sibling != nullptr) {\n    x->sibling->father = x->father;\n  }\n  x->sibling = nullptr;\n  x->father = nullptr;\n  return meld(root, x);  // 重新合并 x 和根节点\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rank Query Operation for Treap in C++\nDESCRIPTION: Implements a method to query the rank of a given value in the Treap. Returns the number of nodes with values less than the given value plus one.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint _query_rank(Node *cur, int val) {\n  int less_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n  // 这个树中小于 val 的节点的数量\n  if (val == cur->val)\n    // 如果这个节点就是要查的节点\n    return less_siz + 1;\n  else if (val < cur->val) {\n    if (cur->ch[0] != nullptr)\n      return _query_rank(cur->ch[0], val);\n    else\n      return 1;  // 如果左子树是空的，说比最小的节点还要小，那这个数字就是最小的\n  } else {\n    if (cur->ch[1] != nullptr)\n      // 如果要查的值比这个节点大，那这个节点的左子树以及这个节点自身肯定都比要查的值小\n      // 所以要加上这两个值，再加上往右边找的结果\n      // （以右子树为根的子树中，val 这个值的大小的排名）\n      return less_siz + cur->rep_cnt + _query_rank(cur->ch[1], val);\n    else\n      return cur->siz + 1;\n    // 没有右子树的话直接整个树 + 1 相当于 less_siz + cur->rep_cnt + 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: LCT Connectivity Checking Implementation\nDESCRIPTION: Implementation of Link Cut Tree for checking connectivity between nodes in a dynamic forest. Supports connecting nodes, destroying edges and querying if two nodes are connected.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconstexpr int MAXN = 10010;\n\nstruct Splay {\n  int ch[MAXN][2], fa[MAXN], tag[MAXN];\n\n  void clear(int x) { ch[x][0] = ch[x][1] = fa[x] = tag[x] = 0; }\n\n  int getch(int x) { return ch[fa[x]][1] == x; }\n\n  // Additional implementation...\n} st;\n\nint n, q, x, y;\nchar op[MAXN];\n\nint main() {\n  scanf(\"%d%d\", &n, &q);\n  // Rest of implementation...\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Graham Scan for 2D Convex Hull in C++\nDESCRIPTION: This snippet implements the Graham scan algorithm to compute the 2D convex hull. It first finds the lowest point, sorts other points by polar angle, then builds the hull using a stack.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/convex-hull.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct Point {\n  double x, y, ang;\n\n  Point operator-(const Point& p) const { return {x - p.x, y - p.y, 0}; }\n} p[MAXN];\n\ndouble dis(Point p1, Point p2) {\n  return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\nbool cmp(Point p1, Point p2) {\n  if (p1.ang == p2.ang) {\n    return dis(p1, p[1]) < dis(p2, p[1]);\n  }\n  return p1.ang < p2.ang;\n}\n\ndouble cross(Point p1, Point p2) { return p1.x * p2.y - p1.y * p2.x; }\n\nint main() {\n  for (int i = 2; i <= n; ++i) {\n    if (p[i].y < p[1].y || (p[i].y == p[1].y && p[i].x < p[1].x)) {\n      std::swap(p[1], p[i]);\n    }\n  }\n  for (int i = 2; i <= n; ++i) {\n    p[i].ang = atan2(p[i].y - p[1].y, p[i].x - p[1].x);\n  }\n  std::sort(p + 2, p + n + 1, cmp);\n  sta[++top] = 1;\n  for (int i = 2; i <= n; ++i) {\n    while (top >= 2 &&\n           cross(p[sta[top]] - p[sta[top - 1]], p[i] - p[sta[top]]) < 0) {\n      top--;\n    }\n    sta[++top] = i;\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Continued Fraction-Based Fraction Finding in C++\nDESCRIPTION: An algorithm using continued fractions to find a fraction p/q in a Stern-Brocot tree with O(log min{p,q}) complexity. This method leverages the relationship between continued fractions and paths in the Stern-Brocot tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nstring find(int p, int q) {\n    string path;\n    while (p != 1 || q != 1) {\n        if (p > q) {\n            int t = p / q;\n            path += string(t, 'R');\n            p -= t * q;\n        } else {\n            int t = q / p;\n            path += string(t, 'L');\n            q -= t * p;\n        }\n        if (p == 0) p = 1;\n        if (q == 0) q = 1;\n    }\n    return path;\n}\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Sum of Divisors in Python\nDESCRIPTION: Python implementation of a linear sieve algorithm to calculate the sum of divisors for numbers up to n. It uses auxiliary arrays to handle prime factors and their powers efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\npri = []\nnot_prime = [False] * N\nf = [0] * N\ng = [0] * N\n\n\ndef pre(n):\n    g[1] = f[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            g[i] = i + 1\n            f[i] = i + 1\n        for pri_j in pri:\n            if i * pri_j > n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                g[i * pri_j] = g[i] * pri_j + 1\n                f[i * pri_j] = f[i] // g[i] * g[i * pri_j]\n                break\n            f[i * pri_j] = f[i] * f[pri_j]\n            g[i * pri_j] = 1 + pri_j\n```\n\n----------------------------------------\n\nTITLE: Building a Cartesian Tree Using Stack in C++\nDESCRIPTION: This code constructs a Cartesian Tree in linear time using a stack to maintain the right chain of the tree. It processes elements by index order, ensuring binary search tree properties for indices and heap properties for values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/cartesian-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// stk 维护笛卡尔树中节点对应到序列中的下标\nfor (int i = 1; i <= n; i++) {\n  int k = top;  // top 表示操作前的栈顶，k 表示当前栈顶\n  while (k > 0 && w[stk[k]] > w[i]) k--;  // 维护右链上的节点\n  if (k) rs[stk[k]] = i;  // 栈顶元素.右儿子 := 当前元素\n  if (k < top) ls[i] = stk[k + 1];  // 当前元素.左儿子 := 上一个被弹出的元素\n  stk[++k] = i;                     // 当前元素入栈\n  top = k;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Test Data with Command Line Arguments in C++\nDESCRIPTION: This C++ code uses the testlib library to generate test data based on command line arguments. It creates a random permutation of integers and outputs them in a specific format.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problemsetting.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testlib.h\"\n\nusing namespace std;\n\nint n, m, k;\nvector<int> p;\n\nint main(int argc, char* argv[]) {\n  registerGen(argc, argv, 1);\n\n  int i;\n\n  n = atoi(argv[1]);\n  m = atoi(argv[2]);\n  k = rnd.next(1, n);\n\n  for (i = 1; i <= n; ++i) p.push_back(i);\n\n  shuffle(p.begin(), p.end());\n  // 使用 rnd.next() 进行 shuffle\n\n  printf(\"%d %d %d\\n\", n, m, k);\n  for (i = 0; i < n; ++i) {\n    printf(\"%d%c\", p[i], \" \\n\"[i == n - 1]);\n    // 把字符串当作数组用，中间空格，末尾换行，是一个造数据时常用的技巧\n  }\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Examining Type Objects in Python\nDESCRIPTION: Demonstrates that in Python everything is an object, including types themselves and functions. This illustrates Python's object-oriented nature where even fundamental types are objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> type(int)\n<class 'type'>\n>>> type(pow)  # 求幂次的内置函数，后文会介绍\n<class 'builtin_function_or_method'>\n>>> type(type)  # type() 也是内置函数，但有些特殊，感兴趣可自行查阅\n<class 'type'>\n```\n\n----------------------------------------\n\nTITLE: Building a Weight Balanced Leafy Tree in C++\nDESCRIPTION: Functions for adding nodes, updating node information, and recursively building the tree structure. The build function creates a balanced tree from a sorted array of values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint add(int v) {\n  ++cnt;\n  ls[cnt] = rs[cnt] = 0;\n  sz[cnt] = 1;\n  vl[cnt] = v;\n  return cnt;\n}\n\nvoid pushup(int x) {\n  vl[x] = vl[rs[x]];\n  sz[x] = sz[ls[x]] + sz[rs[x]];\n}\n\nint build(int l, int r) {\n  if (l == r) {\n    return add(a[l]);\n  }\n  int x = add(0);\n  int k = l + ((r - l) >> 1);\n  ls[x] = build(l, k);\n  rs[x] = build(k + 1, r);\n  pushup(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Swapping Two Numbers with XOR Operations in C++\nDESCRIPTION: A function that swaps two integers without using a temporary variable by using XOR operations, showing a classic bit manipulation technique.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid swap(int &a, int &b) { a ^= b ^= a ^= b; }\n```\n\n----------------------------------------\n\nTITLE: Deque Construction Examples in C++\nDESCRIPTION: Examples showing different ways to construct std::deque objects including empty deques, pre-sized deques, copy construction and move construction.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/sequence-container.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// 1. 定义一个int类型的空双端队列 v0\ndeque<int> v0;\n// 2. 定义一个int类型的双端队列 v1，并设置初始大小为10; 线性复杂度\ndeque<int> v1(10);\n// 3. 定义一个int类型的双端队列 v2，并初始化为10个1; 线性复杂度\ndeque<int> v2(10, 1);\n// 4. 复制已有的双端队列 v1; 线性复杂度\ndeque<int> v3(v1);\n// 5. 创建一个v2的拷贝deque v4，其内容是v4[0]至v4[2]; 线性复杂度\ndeque<int> v4(v2.begin(), v2.begin() + 3);\n// 6. 移动v2到新创建的deque v5，不发生拷贝; 常数复杂度; 需要 C++11\ndeque<int> v5(std::move(v2));\n```\n\n----------------------------------------\n\nTITLE: AC Automaton Template 2 for Multiple Pattern Matching\nDESCRIPTION: Extended AC automaton implementation for Luogu P3796 problem, which handles multiple pattern matching and counts occurrences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/ac-automaton/ac-automaton_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Lambda as Predicate for std::sort in C++\nDESCRIPTION: This example demonstrates using a lambda expression as a predicate for the standard library sort algorithm to implement a descending order sort on a vector of integers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nstd::vector<int> v = {1, 2, 3, 4, 5};\nstd::sort(v.begin(), v.end(), [](int a, int b) { return a > b; });\n```\n\n----------------------------------------\n\nTITLE: Finding kth Smallest Unique Value with sort and unique in C++\nDESCRIPTION: Shows how to use sort and unique to find the kth smallest unique value in an array. This approach first sorts the array, then removes duplicates, and finally selects the kth element.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nint N = 10, a[] = {1, 3, 3, 7, 2, 5, 1, 2, 4, 6}, k = 3;\nsort(a, a + N);\n// unique将返回去重之后数组最后一个元素之后的地址，计算出的cnt为去重后数组的长度\nint cnt = unique(a, a + N) - a;\ncout << a[k - 1];\n```\n\n----------------------------------------\n\nTITLE: Using decltype Specifier to Deduce Types in C++\nDESCRIPTION: Shows how to use decltype to determine the type of an expression, which can be used for variable declarations and template arguments. This is useful for generic programming.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <vector>\n\nint main() {\n  int a = 1926;\n  decltype(a) b = a / 2 - 146;         // b is int type\n  std::vector<decltype(b)> vec = {0};  // vec is std::vector <int> type\n  std::cout << a << vec[0] << b << std::endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Huffman Codes in C++\nDESCRIPTION: Generates Huffman codes for each leaf node by traversing the Huffman tree and recording the path (0 for left, 1 for right) to each leaf.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/huffman-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct HNode {\n  int weight;\n  HNode *lchild, *rchild;\n};\n\nusing Htree = HNode*;\n\nvoid huffmanCoding(Htree root, int len, int arr[]) {\n  if (root != NULL) {\n    if (root->lchild == NULL && root->rchild == NULL) {\n      printf(\"结点为 %d 的字符的编码为: \", root->weight);\n      for (int i = 0; i < len; i++) printf(\"%d\", arr[i]);\n      printf(\"\\n\");\n    } else {\n      arr[len] = 0;\n      huffmanCoding(root->lchild, len + 1, arr);\n      arr[len] = 1;\n      huffmanCoding(root->rchild, len + 1, arr);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Inverse Trigonometric Functions of Polynomials in C++\nDESCRIPTION: This set of functions calculates the arcsine, arccosine, and arctangent of polynomials. It uses derivatives and integrals of inverse trigonometric functions, implemented with modular arithmetic for efficiency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/elementary-func.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int MAXN = 262144;\nconstexpr int mod = 998244353;\n\nusing i64 = long long;\nusing poly_t = int[MAXN];\nusing poly = int *const;\n\nvoid derivative(const poly &h, const int n, poly &f) {\n  for (int i = 1; i != n; ++i) f[i - 1] = (i64)h[i] * i % mod;\n  f[n - 1] = 0;\n}\n\nvoid integrate(const poly &h, const int n, poly &f) {\n  for (int i = n - 1; i; --i) f[i] = (i64)h[i - 1] * inv[i] % mod;\n  f[0] = 0; /* C */\n}\n\nvoid polyarcsin(const poly &h, const int n, poly &f) {\n  /* arcsin(f) = ∫ f' / sqrt(1 - f^2) dx  */\n  static poly_t arcsin_t;\n  const int t = n << 1;\n  std::copy(h, h + n, arcsin_t);\n  std::fill(arcsin_t + n, arcsin_t + t, 0);\n\n  DFT(arcsin_t, t);\n  for (int i = 0; i != t; ++i) arcsin_t[i] = sqr(arcsin_t[i]);\n  IDFT(arcsin_t, t);\n\n  arcsin_t[0] = sub(1, arcsin_t[0]);\n  for (int i = 1; i != n; ++i)\n    arcsin_t[i] = arcsin_t[i] ? mod - arcsin_t[i] : 0;\n\n  polysqrt(arcsin_t, n, f);\n  polyinv(f, n, arcsin_t);\n  derivative(h, n, f);\n\n  DFT(f, t);\n  DFT(arcsin_t, t);\n  for (int i = 0; i != t; ++i) arcsin_t[i] = (i64)f[i] * arcsin_t[i] % mod;\n  IDFT(arcsin_t, t);\n\n  integrate(arcsin_t, n, f);\n}\n\nvoid polyarccos(const poly &h, const int n, poly &f) {\n  /* arccos(f) = - ∫ f' / sqrt(1 - f^2) dx  */\n  polyarcsin(h, n, f);\n  for (int i = 0; i != n; ++i) f[i] = f[i] ? mod - f[i] : 0;\n}\n\nvoid polyarctan(const poly &h, const int n, poly &f) {\n  /* arctan(f) = ∫ f' / (1 + f^2) dx  */\n  static poly_t arctan_t;\n  const int t = n << 1;\n  std::copy(h, h + n, arctan_t);\n  std::fill(arctan_t + n, arctan_t + t, 0);\n\n  DFT(arctan_t, t);\n  for (int i = 0; i != t; ++i) arctan_t[i] = sqr(arctan_t[i]);\n  IDFT(arctan_t, t);\n\n  inc(arctan_t[0], 1);\n  std::fill(arctan_t + n, arctan_t + t, 0);\n\n  polyinv(arctan_t, n, f);\n  derivative(h, n, arctan_t);\n\n  DFT(f, t);\n  DFT(arctan_t, t);\n  for (int i = 0; i != t; ++i) arctan_t[i] = (i64)f[i] * arctan_t[i] % mod;\n  IDFT(arctan_t, t);\n\n  integrate(arctan_t, n, f);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Flexible Debugging Macro with Variadic Templates in C++\nDESCRIPTION: This code snippet showcases how to create a flexible debugging macro using variadic templates and parameter pack expansion. It allows for easy printing of multiple variables of different types, including custom types like vectors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_20\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& V) {\n  os << \"[ \";\n  for (const auto& vv : V) os << vv << \", \";\n  os << \"]\";\n  return os;\n}\n\nnamespace var_debug {\nauto print(const char* fmt, const auto& t) {\n  for (; *fmt == ' '; ++fmt);\n  for (; *fmt != ',' && *fmt != '\\0'; ++fmt) cout << *fmt;\n  cout << '=' << t << *(fmt++) << '\\n';\n  return fmt;\n}\n\nvoid print(const char* fmt, const auto&... args) {\n  ((fmt = print(fmt, args)), ...);  // C++17折叠表达式\n}\n}  // namespace var_debug\n\n#define debug(...) var_debug::print(#__VA_ARGS__, __VA_ARGS__)\n\nint main() {\n  int a = 666;\n  vector<int> b({1, 2, 3});\n  string c = \"hello world\";\n\n  // before\n  cout << \"manual cout print\\n\"\n       << \"a=\" << a << \", b=\" << b << \", c=\" << c\n       << '\\n';  // a=666, b=[ 1, 2, 3, ], c=hello world\n  // 如果用printf的话，在只有基本数据类型的时候是比较方便的，然是如果要输出vector等的内容的话，就会比较麻烦\n\n  // after\n  cout << \"vararg template print\\n\";\n  debug(a, b, c);  // a=666, b=[ 1, 2, 3, ], c=hello world\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using std::function to Store and Call Different Callable Objects in C++\nDESCRIPTION: Demonstrates how std::function can store and invoke various callable entities including free functions, lambdas, member functions, and function objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n#include <functional>\n#include <iostream>\n\nstruct Foo {\n  Foo(int num) : num_(num) {}\n\n  void print_add(int i) const { std::cout << num_ + i << '\\n'; }\n\n  int num_;\n};\n\nvoid print_num(int i) { std::cout << i << '\\n'; }\n\nstruct PrintNum {\n  void operator()(int i) const { std::cout << i << '\\n'; }\n};\n\nint main() {\n  // Store free function\n  std::function<void(int)> f_display = print_num;\n  f_display(-9);\n\n  // Store Lambda\n  std::function<void()> f_display_42 = []() { print_num(42); };\n  f_display_42();\n\n  // Store call to member function\n  std::function<void(const Foo&, int)> f_add_display = &Foo::print_add;\n  const Foo foo(314159);\n  f_add_display(foo, 1);\n  f_add_display(314159, 1);\n\n  // Store access to data member\n  std::function<int(Foo const&)> f_num = &Foo::num_;\n  std::cout << \"num_: \" << f_num(foo) << '\\n';\n\n  // Store call to function object\n  std::function<void(int)> f_display_obj = PrintNum();\n  f_display_obj(18);\n}\n```\n\n----------------------------------------\n\nTITLE: Range-Based For Loop Syntax Example in C++\nDESCRIPTION: Shows the basic syntax of a range-based for loop, which simplifies iteration over collections. This construct is commonly used for cleaner code when traversing containers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nfor (range_declaration : range_expression) loop_statement\n```\n\n----------------------------------------\n\nTITLE: Complex Ranges Library Operations with Chunk and Cartesian Product in C++20\nDESCRIPTION: Demonstrates advanced range operations including chunking sequences and creating cartesian products of ranges, showing the composability of range adapters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <ranges>\n\nusing namespace std;\n\nint main() {\n  const auto& inputs = views::iota(0u, 9u);  // Generate integers from 0 to 8\n  const auto& chunks = inputs | views::chunk(3);  // Split sequence into chunks of 3 elements\n  const auto& cartesian_product =\n      views::cartesian_product(chunks, chunks);  // Compute cartesian product of chunks\n\n  for (const auto [l_chunk, r_chunk] : cartesian_product)\n    // Calculate sum of integers in both chunks\n    cout << ranges::fold_left(l_chunk, 0u, plus{}) +\n                ranges::fold_left(r_chunk, 0u, plus{})\n         << ' ';\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized DFS for Herb Collection Problem in Python\nDESCRIPTION: An optimized DFS implementation in Python using memoization to avoid recalculating states. This reduces the time complexity to O(TM) by storing and reusing previously calculated results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ntcost = [0] * 103\nmget = [0] * 103\nmem = [[-1 for i in range(1003)] for j in range(103)]\n\n\ndef dfs(pos, tleft):\n    if mem[pos][tleft] != -1:\n        return mem[pos][tleft]\n    if pos == n + 1:\n        mem[pos][tleft] = 0\n        return mem[pos][tleft]\n    dfs1 = dfs2 = -INF\n    dfs1 = dfs(pos + 1, tleft)\n    if tleft >= tcost[pos]:\n        dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos]\n    mem[pos][tleft] = max(dfs1, dfs2)\n    return mem[pos][tleft]\n\n\nt, n = map(lambda x: int(x), input().split())\nfor i in range(1, n + 1):\n    tcost[i], mget[i] = map(lambda x: int(x), input().split())\nprint(dfs(1, t))\n```\n\n----------------------------------------\n\nTITLE: DSU on Tree Implementation for Color Counting (C++)\nDESCRIPTION: Implements the DSU on Tree algorithm to solve a problem of counting distinct colors in subtrees. It uses heavy-light decomposition and a clever traversal strategy to achieve O(n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dsu-on-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconstexpr int N = 2e5 + 5;\n\nint n;\n\n// g[u]: 存储与 u 相邻的结点\nvector<int> g[N];\n\n// sz: 子树大小\n// big: 重儿子\n// col: 结点颜色\n// L[u]: 结点 u 的 DFS 序\n// R[u]: 结点 u 子树中结点的 DFS 序的最大值\n// Node[i]: DFS 序为 i 的结点\n// ans: 存答案\n// cnt[i]: 颜色为 i 的结点个数\n// totColor: 目前出现过的颜色个数\nint sz[N], big[N], col[N], L[N], R[N], Node[N], totdfn;\nint ans[N], cnt[N], totColor;\n\nvoid add(int u) {\n  if (cnt[col[u]] == 0) ++totColor;\n  cnt[col[u]]++;\n}\n\nvoid del(int u) {\n  cnt[col[u]]--;\n  if (cnt[col[u]] == 0) --totColor;\n}\n\nint getAns() { return totColor; }\n\nvoid dfs0(int u, int p) {\n  L[u] = ++totdfn;\n  Node[totdfn] = u;\n  sz[u] = 1;\n  for (int v : g[u])\n    if (v != p) {\n      dfs0(v, u);\n      sz[u] += sz[v];\n      if (!big[u] || sz[big[u]] < sz[v]) big[u] = v;\n    }\n  R[u] = totdfn;\n}\n\nvoid dfs1(int u, int p, bool keep) {\n  // 计算轻儿子的答案\n  for (int v : g[u])\n    if (v != p && v != big[u]) {\n      dfs1(v, u, false);\n    }\n  // 计算重儿子答案并保留计算过程中的数据（用于继承）\n  if (big[u]) {\n    dfs1(big[u], u, true);\n  }\n  for (int v : g[u])\n    if (v != p && v != big[u]) {\n      // 子树结点的 DFS 序构成一段连续区间，可以直接遍历\n      for (int i = L[v]; i <= R[v]; i++) {\n        add(Node[i]);\n      }\n    }\n  add(u);\n  ans[u] = getAns();\n  if (!keep) {\n    for (int i = L[u]; i <= R[u]; i++) {\n      del(Node[i]);\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &col[i]);\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs0(1, 0);\n  dfs1(1, 0, false);\n  for (int i = 1; i <= n; i++) printf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Kruskal's Algorithm for Minimum Spanning Tree in C++\nDESCRIPTION: This code implements Kruskal's algorithm to find the minimum spanning tree of a graph. It uses a union-find data structure to detect cycles and sorts edges by weight.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mst.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/mst/mst_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Solving Light Switch Problem using Meet in the Middle in C++\nDESCRIPTION: Implementation of the meet in the middle algorithm to solve the USACO09NOV Lights problem. It splits the search space in half, explores both halves separately, and combines results to find the optimal solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/bidirectional.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/search/code/bidirectional/bidirectional_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using Map to Store Complex States (C++)\nDESCRIPTION: Shows how to use a map to store complex states (like coordinates, non-discretizable values, or strings) and their associated answers (like minimum steps to reach the state) in search algorithms.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/associative-container.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n// 存储状态与对应的答案\nmap<string, int> record;\n\n// 新搜索到的状态与对应答案\nstring status;\nint ans;\n// 查找对应的状态是否出现过\nmap<string, int>::iterator it = record.find(status);\nif (it == record.end()) {\n  // 尚未搜索过该状态，将其加入状态记录中\n  record[status] = ans;\n  // 进行相应操作……\n} else {\n  // 已经搜索过该状态，进行相应操作……\n}\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Number of Divisors in Python\nDESCRIPTION: Python implementation of a linear sieve algorithm to calculate the number of divisors for numbers up to n. It uses the divisor count theorem and handles prime and composite numbers separately.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\npri = []\nnot_prime = [False] * N\nd = [0] * N\nnum = [0] * N\n\n\ndef pre(n):\n    d[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            d[i] = 2\n            num[i] = 1\n        for pri_j in pri:\n            if i * pri_j > n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                num[i * pri_j] = num[i] + 1\n                d[i * pri_j] = d[i] // num[i * pri_j] * (num[i * pri_j] + 1)\n                break\n            num[i * pri_j] = 1\n            d[i * pri_j] = d[i] * 2\n```\n\n----------------------------------------\n\nTITLE: High-Precision Short Multiplication in C++\nDESCRIPTION: Multiplication between a high-precision number and a single-precision integer. Handles carries by division and modulo operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid mul_short(int a[], int b, int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] * b;\n    if (c[i] >= 10) {\n      c[i + 1] += c[i] / 10;\n      c[i] %= 10;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving the Largest Rectangle in Histogram Problem using Cartesian Tree\nDESCRIPTION: This is a reference implementation for solving the HDU 1506 problem. It constructs a Cartesian Tree where indices are k-values and heights are w-values, then calculates the maximum rectangle area by performing a DFS on the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/cartesian-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/cartesian-tree/cartesian-tree_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Merging Nodes in a Persistent Leftist Tree (C++)\nDESCRIPTION: This function merges two nodes in a persistent leftist tree. It creates a new node for the merged result, ensuring persistence. The function maintains the leftist property and updates the distance values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent-heap.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint merge(int x, int y) {\n  if (!x || !y) return x + y;\n  if (v[x] > v[y]) swap(x, y);\n  int p = ++cnt;\n  lc[p] = lc[x];\n  v[p] = v[x];\n  rc[p] = merge(rc[x], y);\n  if (dist[lc[p]] < dist[rc[p]]) swap(lc[p], rc[p]);\n  dist[p] = dist[rc[p]] + 1;\n  return p;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Fraction Finding in Stern-Brocot Tree with Python\nDESCRIPTION: Python implementation of the optimized algorithm for finding a fraction in a Stern-Brocot tree. This version processes consecutive movements in the same direction together for improved efficiency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef find(p, q):\n    a, b, c, d = 0, 1, 1, 0\n    path = \"\"\n    while a + c != p or b + d != q:\n        if c * q > d * p:\n            t = (c * q - d * p - 1) // (a * q - b * p) + 1\n            path += \"L\" * t\n            c = t * a + c\n            d = t * b + d\n        else:\n            t = (a * q - b * p - 1) // (c * q - d * p) + 1\n            path += \"R\" * t\n            a = a + t * c\n            b = b + t * d\n    return path\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Möbius Function in C++\nDESCRIPTION: Implementation of a linear sieve algorithm to efficiently calculate the Möbius function values up to n. This function is a multiplicative number-theoretic function used in Möbius inversion formulas.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid getMu() {\n  mu[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!flg[i]) p[++tot] = i, mu[i] = -1;\n    for (int j = 1; j <= tot && i * p[j] <= n; ++j) {\n      flg[i * p[j]] = 1;\n      if (i % p[j] == 0) {\n        mu[i * p[j]] = 0;\n        break;\n      }\n      mu[i * p[j]] = -mu[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Immediate Dominators from Semi-Dominators in C++\nDESCRIPTION: This code snippet builds upon the semi-dominator computation to efficiently calculate immediate dominators in a graph. It uses the computed semi-dominators and additional graph traversals to determine the immediate dominator for each node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dominator-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct E {\n  int v, x;\n} e[MAX * 4];\n\nint h[3][MAX * 2];\n\nint dfc, tot, n, m, u, v;\nint fa[MAX], fth[MAX], pos[MAX], mn[MAX], idm[MAX], sdm[MAX], dfn[MAX],\n    ans[MAX];\n\nvoid add(int x, int u, int v) {\n  e[++tot] = {v, h[x][u]};\n  h[x][u] = tot;\n}\n\nvoid dfs(int u) {\n  dfn[u] = ++dfc;\n  pos[dfc] = u;\n  for (int i = h[0][u]; i; i = e[i].x) {\n    int v = e[i].v;\n    if (!dfn[v]) {\n      dfs(v);\n      fth[v] = u;\n    }\n  }\n}\n\nint find(int x) {\n  if (fa[x] == x) {\n    return x;\n  }\n  int tmp = fa[x];\n  fa[x] = find(fa[x]);\n  if (dfn[sdm[mn[tmp]]] < dfn[sdm[mn[x]]]) {\n    mn[x] = mn[tmp];\n  }\n  return fa[x];\n}\n\nvoid tar(int st) {\n  dfs(st);\n  for (int i = 1; i <= n; ++i) {\n    fa[i] = sdm[i] = mn[i] = i;\n  }\n  for (int i = dfc; i >= 2; --i) {\n    int u = pos[i], res = INF;\n    for (int j = h[1][u]; j; j = e[j].x) {\n      int v = e[j].v;\n      if (!dfn[v]) {\n        continue;\n      }\n      find(v);\n      if (dfn[v] < dfn[u]) {\n        res = std::min(res, dfn[v]);\n      } else {\n        res = std::min(res, dfn[sdm[mn[v]]]);\n      }\n    }\n    sdm[u] = pos[res];\n    fa[u] = fth[u];\n    add(2, sdm[u], u);\n    u = fth[u];\n    for (int j = h[2][u]; j; j = e[j].x) {\n      int v = e[j].v;\n      find(v);\n      if (sdm[mn[v]] == u) {\n        idm[v] = u;\n      } else {\n        idm[v] = mn[v];\n      }\n    }\n    h[2][u] = 0;\n  }\n  for (int i = 2; i <= dfc; ++i) {\n    int u = pos[i];\n    if (idm[u] != sdm[u]) {\n      idm[u] = idm[idm[u]];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Value - C++\nDESCRIPTION: Implementation for replacing a value at a specific location with a new value. Updates all balanced trees containing the target location in the segment tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/balanced-in-seg.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid vec_chg(int k, int l, int r, int loc, int x) {\n  int t = spy[k].find(dat[loc]);\n  spy[k].dele(t);\n  spy[k].insert(x);\n  if (l == r) return;\n  int mid = l + r >> 1;\n  if (loc <= mid) vec_chg(k << 1, l, mid, loc, x);\n  if (loc > mid) vec_chg(k << 1 | 1, mid + 1, r, loc, x);\n}\n```\n\n----------------------------------------\n\nTITLE: Using std::pair with std::map\nDESCRIPTION: Example showing how pair is used with map for key-value pair operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nmap<int, double> m;\nm.insert(make_pair(1, 2.0));\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Query in C++\nDESCRIPTION: Performs pattern matching using the constructed AC automaton. Returns the count of matched patterns in the input text while avoiding duplicate counting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint query(const char t[]) {\n  int u = 0, res = 0;\n  for (int i = 1; t[i]; i++) {\n    u = tr[u].son[t[i] - 'a'];\n    for (int j = u; j && tr[j].cnt != -1; j = tr[j].fail) {\n      res += tr[j].cnt, tr[j].cnt = -1;\n    }\n  }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Euclidean Algorithm for GCD in Python\nDESCRIPTION: Implementation of the Euclidean algorithm for finding the greatest common divisor (GCD) of two integers in Python. This recursive implementation continues until the second number becomes zero.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n```\n\n----------------------------------------\n\nTITLE: Monotonic Queue Implementation for Convex Hull Maintenance\nDESCRIPTION: Algorithm to maintain a lower convex hull using a monotonic queue data structure. This allows for O(n) time complexity by exploiting the monotonicity of slopes in the original problem.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/slope.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n具体地，设 $K(a,b)$ 表示过 $(x_a,y_a)$ 和 $(x_b,y_b)$ 的直线的斜率。考虑队列 $q_l,q_{l+1},\\ldots,q_r$，维护的是下凸壳上的点。也就是说，对于 $l<i<r$，始终有 $K(q_{i-1},q_i) < K(q_i,q_{i+1})$ 成立。\n\n我们维护一个指针 $e$ 来计算 $b_i$ 最小值。我们需要找到一个 $K(q_{e-1},q_e)\\le k_i< K(q_e,q_{e+1})$ 的 $e$（特别地，当 $e=l$ 或者 $e=r$ 时要特别判断），这时就有 $p=q_e$，即 $q_e$ 是 $i$ 的最优决策点。由于 $k_i$ 是单调递增的，因此 $e$ 的移动次数是均摊 $O(1)$ 的。\n\n在插入一个点 $(x_i,y_i)$ 时，我们要判断是否 $K(q_{r-1},q_r)<K(q_r,i)$，如果不等式不成立就将 $q_r$ 弹出，直到等式满足。然后将 $i$ 插入到 $q$ 队尾。\n\n这样我们就将 DP 的复杂度优化到了 $O(n)$。\n```\n\n----------------------------------------\n\nTITLE: Edge Delta Calculation and Slack Update in C++\nDESCRIPTION: Implements functions for calculating edge delta values and updating slack variables. These are key operations in the blossom algorithm for maintaining tight constraints on edge weights.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint e_delta(const edge &e) {\n  // 计算ze，为了方便起见先把所有边的权重乘二\n  // 在花里面直接计算 e_delta 值会导致错误\n  return lab[e.u] + lab[e.v] - g[e.u][e.v].w * 2;\n}\n\nvoid update_slack(int u, int x) {\n  // 以u更新slack[x]的值\n  if (!slack[x] || e_delta(g[u][x]) < e_delta(g[slack[x]][x])) {\n    slack[x] = u;\n  }\n}\n\nvoid set_slack(int x) {\n  // 算出slack[x]的值，slack[x]=0表示x是交错树中的节点\n  slack[x] = 0;\n  for (int u = 1; u <= n; ++u) {\n    if (g[u][x].w > 0 && st[u] != x && S[st[u]] == 0) {\n      update_slack(u, x);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge-Split Tree Data Structure in C++\nDESCRIPTION: This code snippet implements a Merge-Split Tree data structure in C++. It includes RMQ preprocessing, segment tree operations, tree construction, and querying functions. The structure efficiently handles queries on continuous segments in a sequence.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/divide-combine.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconstexpr int N = 200010;\n\nint n, m, a[N], st1[N], st2[N], tp1, tp2, rt;\nint L[N], R[N], M[N], id[N], cnt, typ[N], bin[20], st[N], tp;\n\n// 本篇代码原题应为 CERC2017 Intrinsic Interval\n// a 数组即为原题中对应的排列\n// st1 和 st2 分别两个单调栈，tp1、tp2 为对应的栈顶，rt 为析合树的根\n// L、R 数组表示该析合树节点的左右端点，M 数组的作用在析合树构造时有提到\n// id 存储的是排列中某一位置对应的节点编号，typ 用于标记析点还是合点\n// st 为存储析合树节点编号的栈，tp为其栈顶\nstruct RMQ {  // 预处理 RMQ（Max & Min）\n  int lg[N], mn[N][17], mx[N][17];\n\n  void chkmn(int& x, int y) {\n    if (x > y) x = y;\n  }\n\n  void chkmx(int& x, int y) {\n    if (x < y) x = y;\n  }\n\n  void build() {\n    for (int i = bin[0] = 1; i < 20; ++i) bin[i] = bin[i - 1] << 1;\n    for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;\n    for (int i = 1; i <= n; ++i) mn[i][0] = mx[i][0] = a[i];\n    for (int i = 1; i < 17; ++i)\n      for (int j = 1; j + bin[i] - 1 <= n; ++j)\n        mn[j][i] = min(mn[j][i - 1], mn[j + bin[i - 1]][i - 1]),\n        mx[j][i] = max(mx[j][i - 1], mx[j + bin[i - 1]][i - 1]);\n  }\n\n  int ask_mn(int l, int r) {\n    int t = lg[r - l + 1];\n    return min(mn[l][t], mn[r - bin[t] + 1][t]);\n  }\n\n  int ask_mx(int l, int r) {\n    int t = lg[r - l + 1];\n    return max(mx[l][t], mx[r - bin[t] + 1][t]);\n  }\n} D;\n\n// 维护 L_i\n\nstruct SEG {  // 线段树\n#define ls (k << 1)\n#define rs (k << 1 | 1)\n  int mn[N << 1], ly[N << 1];  // 区间加；区间最小值\n\n  void pushup(int k) { mn[k] = min(mn[ls], mn[rs]); }\n\n  void mfy(int k, int v) { mn[k] += v, ly[k] += v; }\n\n  void pushdown(int k) {\n    if (ly[k]) mfy(ls, ly[k]), mfy(rs, ly[k]), ly[k] = 0;\n  }\n\n  void update(int k, int l, int r, int x, int y, int v) {\n    if (l == x && r == y) {\n      mfy(k, v);\n      return;\n    }\n    pushdown(k);\n    int mid = (l + r) >> 1;\n    if (y <= mid)\n      update(ls, l, mid, x, y, v);\n    else if (x > mid)\n      update(rs, mid + 1, r, x, y, v);\n    else\n      update(ls, l, mid, x, mid, v), update(rs, mid + 1, r, mid + 1, y, v);\n    pushup(k);\n  }\n\n  int query(int k, int l, int r) {  // 询问 0 的位置\n    if (l == r) return l;\n    pushdown(k);\n    int mid = (l + r) >> 1;\n    if (!mn[ls])\n      return query(ls, l, mid);\n    else\n      return query(rs, mid + 1, r);\n    // 如果不存在 0 的位置就会自动返回当前你查询的位置\n  }\n} T;\n\nint o = 1, hd[N], dep[N], fa[N][18];\n\nstruct Edge {\n  int v, nt;\n} E[N << 1];\n\nvoid add(int u, int v) {  // 树结构加边\n  E[o] = Edge{v, hd[u]};\n  hd[u] = o++;\n}\n\nvoid dfs(int u) {\n  for (int i = 1; bin[i] <= dep[u]; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];\n  for (int i = hd[u]; i; i = E[i].nt) {\n    int v = E[i].v;\n    dep[v] = dep[u] + 1;\n    fa[v][0] = u;\n    dfs(v);\n  }\n}\n\nint go(int u, int d) {\n  for (int i = 0; i < 18 && d; ++i)\n    if (bin[i] & d) d ^= bin[i], u = fa[u][i];\n  return u;\n}\n\nint lca(int u, int v) {\n  if (dep[u] < dep[v]) swap(u, v);\n  u = go(u, dep[u] - dep[v]);\n  if (u == v) return u;\n  for (int i = 17; ~i; --i)\n    if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];\n  return fa[u][0];\n}\n\n// 判断当前区间是否为连续段\nbool judge(int l, int r) { return D.ask_mx(l, r) - D.ask_mn(l, r) == r - l; }\n\n// 建树\nvoid build() {\n  for (int i = 1; i <= n; ++i) {\n    // 单调栈\n    // 在区间 [st1[tp1-1]+1,st1[tp1]] 的最小值就是 a[st1[tp1]]\n    // 现在把它出栈，意味着要把多减掉的 Min 加回来。\n    // 线段树的叶结点位置 j 维护的是从 j 到当前的 i 的\n    // Max{j,i}-Min{j,i}-(i-j)\n    // 区间加只是一个 Tag。\n    // 维护单调栈的目的是辅助线段树从 i-1 更新到 i。\n    // 更新到 i 后，只需要查询全局最小值即可知道是否有解\n\n    while (tp1 && a[i] <= a[st1[tp1]])  // 单调递增的栈，维护 Min\n      T.update(1, 1, n, st1[tp1 - 1] + 1, st1[tp1], a[st1[tp1]]), tp1--;\n    while (tp2 && a[i] >= a[st2[tp2]])\n      T.update(1, 1, n, st2[tp2 - 1] + 1, st2[tp2], -a[st2[tp2]]), tp2--;\n\n    T.update(1, 1, n, st1[tp1] + 1, i, -a[i]);\n    st1[++tp1] = i;\n    T.update(1, 1, n, st2[tp2] + 1, i, a[i]);\n    st2[++tp2] = i;\n\n    id[i] = ++cnt;\n    L[cnt] = R[cnt] = i;  // 这里的 L,R 是指节点所对应区间的左右端点\n    int le = T.query(1, 1, n), now = cnt;\n    while (tp && L[st[tp]] >= le) {\n      if (typ[st[tp]] && judge(M[st[tp]], i)) {\n        // 判断是否能成为儿子，如果能就做\n        R[st[tp]] = i, M[st[tp]] = L[now], add(st[tp], now), now = st[tp--];\n      } else if (judge(L[st[tp]], i)) {\n        typ[++cnt] = 1;  // 合点一定是被这样建出来的\n        L[cnt] = L[st[tp]], R[cnt] = i, M[cnt] = L[now];\n        // 这里M数组是记录节点最右面的儿子的左端点，用于上方能否成为儿子的判断\n        add(cnt, st[tp--]), add(cnt, now);\n        now = cnt;\n      } else {\n        add(++cnt, now);  // 新建一个结点，把 now 添加为儿子\n        // 如果从当前结点开始不能构成连续段，就合并。\n        // 直到找到一个结点能构成连续段。而且我们一定能找到这样\n        // 一个结点。\n        do add(cnt, st[tp--]);\n        while (tp && !judge(L[st[tp]], i));\n        L[cnt] = L[st[tp]], R[cnt] = i, add(cnt, st[tp--]);\n        now = cnt;\n      }\n    }\n    st[++tp] = now;  // 增量结束，把当前点压栈\n\n    T.update(1, 1, n, 1, i, -1);  // 因为区间右端点向后移动一格，因此整体 -1\n  }\n\n  rt = st[1];  // 栈中最后剩下的点是根结点\n}\n\n// 分 lca 为析或和，这里把叶子看成析的\nvoid query(int l, int r) {\n  int x = id[l], y = id[r];\n  int z = lca(x, y);\n  if (typ[z] & 1)\n    l = L[go(x, dep[x] - dep[z] - 1)], r = R[go(y, dep[y] - dep[z] - 1)];\n  // 合点这里特判的原因是因为这个合点不一定是最小的包含l，r的连续段.\n  // 因为合点所代表的区间的子区间也都是连续段，而我们只需要其中的一段就够了。\n  else\n    l = L[z], r = R[z];\n  printf(\"%d %d\\n\", l, r);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  D.build();\n  build();\n  dfs(rt);\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; ++i) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    query(x, y);\n  }\n  return 0;\n}\n\n// 20190612\n// 析合树\n```\n\n----------------------------------------\n\nTITLE: Implementing B+ Tree Internal Node Removal in C++\nDESCRIPTION: Method to remove internal nodes from a B+ Tree with rebalancing logic and sibling node adjustments. Handles root changes, node merging, and maintains B+ tree properties during deletion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bplus-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid BPTree::removeInternal(int x, Node *cursor, Node *child) {\n  if (cursor == root) {\n    if (cursor->size == 1) {\n      if (cursor->ptr[1] == child) {\n        delete[] child->key;\n        delete[] child->ptr;\n        delete child;\n        root = cursor->ptr[0];\n        delete[] cursor->key;\n        delete[] cursor->ptr;\n        delete cursor;\n        cout << \"Changed root node\\n\";\n        return;\n      } else if (cursor->ptr[0] == child) {\n        delete[] child->key;\n        delete[] child->ptr;\n        delete child;\n        root = cursor->ptr[1];\n        delete[] cursor->key;\n        delete[] cursor->ptr;\n        delete cursor;\n        cout << \"Changed root node\\n\";\n        return;\n      }\n    }\n  }\n  // ... rest of implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Const Pointer Types and Aliases in C++\nDESCRIPTION: Illustrates different const pointer declarations and demonstrates using type aliases to improve readability.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint* const p1;  // 指针常量，初始化后指向地址不可改，可更改指向的值\nconst int* p2;  // 常量指针，解引用的值不可改，可指向其他 int 变量\nconst int* const p3;  // 常量指针常量，值不可改，指向地址不可改\n\n// 使用别名能更好提高可读性\nusing const_int = const int;\nusing ptr_to_const_int = const_int*;\nusing const_ptr_to_const_int = const ptr_to_const_int;\n```\n\n----------------------------------------\n\nTITLE: Iterative Binary Exponentiation in C++\nDESCRIPTION: Iterative implementation of binary exponentiation algorithm to calculate a^b efficiently in O(log n) time. Typically faster than recursive version in practice.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nlong long binpow(long long a, long long b) {\n  long long res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a;\n    a = a * a;\n    b >>= 1;\n  }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Divide-and-Conquer Optimization with Quadrangle Inequality in Python\nDESCRIPTION: Python implementation of the divide-and-conquer approach for dynamic programming with quadrangle inequality. The algorithm partitions the problem space and utilizes decision monotonicity to optimize computation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef DP(l, r, k_l, k_r):\n    mid = int((l + r) / 2)\n    k = k_l  # 求状态f[mid]的最优决策点\n    for i in range(k_l, min(k_r, mid - 1)):\n        if w(i, mid) < w(k, mid):\n            k = i\n    f[mid] = w(k, mid)  # 根据决策单调性得出左右两部分的决策区间，递归处理\n    if l < mid:\n        DP(l, mid - 1, k_l, k)\n    if r > mid:\n        DP(mid + 1, r, k, k_r)\n```\n\n----------------------------------------\n\nTITLE: Using freopen for File I/O in C/C++\nDESCRIPTION: Declaration of the freopen function which redirects standard streams to files. The function takes a filename, mode string, and a stream pointer as parameters and returns a file pointer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nFILE* freopen(const char* filename, const char* mode, FILE* stream);\n```\n\n----------------------------------------\n\nTITLE: Implementing Scapegoat Tree Deletion Operation in C++\nDESCRIPTION: Performs a lazy deletion by decreasing the count of a node. If the proportion of active nodes falls below a threshold, triggers a full tree rebuild to remove empty nodes and restore balance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool remove(int& x, int v) {\n  if (!x) return false;\n  if (val[x] == v) {\n    if (cnt[x]) {\n      cnt[x]--;\n      sz[x]--;\n      tot_active--;\n      if (!cnt[x]) {\n        if (!lc[x] || !rc[x]) {\n          x = lc[x] + rc[x];\n          return true;\n        }\n        int p = lc[x];\n        while (rc[p]) p = rc[p];\n        val[x] = val[p];\n        cnt[x] = cnt[p];\n        remove(lc[x], val[p]);\n      }\n      return false;\n    }\n    return true;\n  }\n  if (v < val[x]) remove(lc[x], v);\n  else remove(rc[x], v);\n  push_up(x);\n  return false;\n}\n\nvoid erase(int v) {\n  bool flag = remove(rt, v);\n  if (flag) rebuild(rt);\n  if (tot_active < tot[rt] * alpha) rebuild(rt);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Andrew's Algorithm for 2D Convex Hull in Python\nDESCRIPTION: This snippet implements Andrew's algorithm to compute the 2D convex hull of a set of points in Python. It follows the same logic as the C++ version, building lower and upper hulls using a monotone stack.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/convex-hull.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nstk = []  # is integer, storing indices\np = []  # stores vectors or points\ntp = 0  # Initialize stack\np.sort()  # Sort points\ntp = tp + 1\nstk[tp] = 1\n# Add first element to stack without updating used, so that 1 updates monotone stack when closing convex hull\nfor i in range(2, n + 1):\n    while tp >= 2 and (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0:\n        # Next line * operator overloaded as cross product\n        used[stk[tp]] = 0\n        tp = tp - 1\n    used[i] = 1  # used indicates on convex hull\n    tp = tp + 1\n    stk[tp] = i\ntmp = tp  # tmp is size of lower hull\nfor i in range(n - 1, 0, -1):\n    if used[i] == False:\n        #      ↓Computing upper hull without affecting lower hull\n        while tp > tmp and (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0:\n            used[stk[tp]] = 0\n            tp = tp - 1\n        used[i] = 1\n        tp = tp + 1\n        stk[tp] = i\nfor i in range(1, tp + 1):\n    h[i] = p[stk[i]]\nans = tp - 1\n```\n\n----------------------------------------\n\nTITLE: Range Update with Assignment in Python\nDESCRIPTION: Python implementation of segment tree range update operation that sets all elements in a given range to a specific value. Uses lazy propagation with an additional flag array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef update(l, r, c, s, t, p):\n    if l <= s and t <= r:\n        d[p] = (t - s + 1) * c\n        b[p] = c\n        v[p] = 1\n        return\n    m = s + ((t - s) >> 1)\n    if v[p]:\n        d[p * 2] = b[p] * (m - s + 1)\n        d[p * 2 + 1] = b[p] * (t - m)\n        b[p * 2] = b[p * 2 + 1] = b[p]\n        v[p * 2] = v[p * 2 + 1] = 1\n        v[p] = 0\n    if l <= m:\n        update(l, r, c, s, m, p * 2)\n    if r > m:\n        update(l, r, c, m + 1, t, p * 2 + 1)\n    d[p] = d[p * 2] + d[p * 2 + 1]\n```\n\n----------------------------------------\n\nTITLE: Using Break for Cleaner Loop Conditions in C++\nDESCRIPTION: Comparison of for loops with complex conditions versus using break statements, showing how break can clarify the enumeration purpose.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n// for 语句判断条件复杂，没有体现「枚举」的本质\n\nfor (int i = l; i <= r && i % 10 != 0; ++i) {\n  // do something...\n}\n\n// for 语句用于枚举，break 用于「到何时为止」\n\nfor (int i = l; i <= r; ++i) {\n  if (i % 10 == 0) break;\n  // do something...\n}\n```\n\n----------------------------------------\n\nTITLE: Reading n Numbers Using For Loop in C++\nDESCRIPTION: Example of using a for loop to read n numbers into an array, demonstrating a common input pattern.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i = 1; i <= n; ++i) {\n  cin >> a[i];\n}\n```\n\n----------------------------------------\n\nTITLE: SAM Extend Function Implementation\nDESCRIPTION: Main function for extending the SAM by adding a new character, including state creation and clone operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sam.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid sam_extend(char c) {\n  int cur = sz++;\n  st[cur].len = st[last].len + 1;\n  int p = last;\n  while (p != -1 && !st[p].next.count(c)) {\n    st[p].next[c] = cur;\n    p = st[p].link;\n  }\n  if (p == -1) {\n    st[cur].link = 0;\n  } else {\n    int q = st[p].next[c];\n    if (st[p].len + 1 == st[q].len) {\n      st[cur].link = q;\n    } else {\n      int clone = sz++;\n      st[clone].len = st[p].len + 1;\n      st[clone].next = st[q].next;\n      st[clone].link = st[q].link;\n      while (p != -1 && st[p].next[c] == q) {\n        st[p].next[c] = clone;\n        p = st[p].link;\n      }\n      st[q].link = st[cur].link = clone;\n    }\n  }\n  last = cur;\n}\n```\n\n----------------------------------------\n\nTITLE: Java Formatted Output Examples\nDESCRIPTION: Shows how to use System.out.printf() for formatted output of different data types using format specifiers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_7\n\nLANGUAGE: java\nCODE:\n```\nclass Test {\n    public static void main(String[] args) {\n        int a = 12;\n        char b = 'A';\n        double s = 3.14;\n        String str = \"Hello world\";\n        System.out.printf(\"%f\\n\", s);\n        System.out.printf(\"%d\\n\", a);\n        System.out.printf(\"%c\\n\", b);\n        System.out.printf(\"%s\\n\", str);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Count Variables for Optimal Solutions in C++\nDESCRIPTION: Initial setup for counting optimal solutions in 0-1 knapsack problem. Sets initial DP array values and establishes base case where empty knapsack is considered one valid solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nmemset(f, 0x3f3f, sizeof(f));  // 避免没有装满而进行了转移\nf[0] = 0;\ng[0] = 1;  // 什么都不装是一种方案\n```\n\n----------------------------------------\n\nTITLE: Deleting Node from Double Circular Linked List in C++ and Python\nDESCRIPTION: Demonstrates the deletion of a node from a double circular linked list by updating left and right pointers and freeing memory.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid deleteNode(Node *&p) {\n  p->left->right = p->right;\n  p->right->left = p->left;\n  Node *t = p;\n  p = p->right;\n  delete t;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef deleteNode(p):\n    p.left.right = p.right\n    p.right.left = p.left\n    p = p.right\n```\n\n----------------------------------------\n\nTITLE: Implementing Extended Euclidean Algorithm in Python\nDESCRIPTION: Implementation of the Extended Euclidean algorithm (EXGCD) in Python. This algorithm finds integers x and y such that ax + by = gcd(a,b) and returns the greatest common divisor along with x and y.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\ndef Exgcd(a, b):\n    if b == 0:\n        return a, 1, 0\n    d, x, y = Exgcd(b, a % b)\n    return d, y, x - (a // b) * y\n```\n\n----------------------------------------\n\nTITLE: String Operations in Python\nDESCRIPTION: Shows various string operations in Python including concatenation, length, membership checking, and indexing. Demonstrates Unicode support and string immutability.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> s1 = \"O\"  # 单引号和双引号都能包起字符串，有时可节省转义字符\n>>> s1 += 'I-Wiki'  # 为和 C++ 同步建议使用双引号 \n>>> 'OI' in s1  # 检测子串很方便\nTrue\n>>> len(s1)  # 类似 C++ 的 s.length()，但更通用\n7\n>>> s2 = \"\"\" 感谢你的阅读\n... 欢迎参与贡献!\n\"\"\"   # 使用三重引号的字符串可以跨越多行\n>>> s1 + s2 \n'OI-Wiki 感谢你的阅读\\n欢迎参与贡献!'\n>>> print(s1 + s2)  # 这里使用了 print() 函数打印字符串\nOI-Wiki 感谢你的阅读\n欢迎参与贡献!\n>>> s2[2] * 2 + s2[3] + s2[-1]  # 负数索引从右开始计数，加上 len(s)，相当于模 n 的剩余类环\n'谢谢你!'\n>>> s1[0] = 'o'  # str 是不可变类型，不能原地修改，其实 += 也是创建了新的对象\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nTypeError: 'str' object does not support item assignment\n```\n\n----------------------------------------\n\nTITLE: Extended Integer Type Solution\nDESCRIPTION: Shows how to properly implement abs function and stream operators for __int128_t type to fix the issues in the previous example.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cmath>\n#include <iostream>\n\n__int128_t abs(__int128_t n) { return n < 0 ? -n : n; }\n\nstd::ostream &operator<<(std::ostream &os, __uint128_t n) {\n  if (n > 9) os << n / 10;\n  os << (int)(n % 10);\n  return os;\n}\n\nstd::ostream &operator<<(std::ostream &os, __int128_t n) {\n  if (n < 0) {\n    os << '-';\n    n = -n;\n  }\n  return os << (__uint128_t)n;\n}\n\nint f1(int n) { return abs(n); }\n\nint f2(int n) { return std::abs(n); }\n\n__int128_t f3(__int128_t n) { return abs(n); }\n\nint main() {\n  std::cout << \"f1: \" << f1(-42) << std::endl;\n  std::cout << \"f2: \" << f2(-42) << std::endl;\n  std::cout << \"f3: \" << f3(-42) << std::endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Blossom Algorithm for Maximum Unweighted Matching in C++\nDESCRIPTION: Implements the Blossom Algorithm to find the maximum unweighted matching in a general graph. It includes helper functions for finding the lowest common ancestor (LCA), handling blossoms, augmenting paths, and performing a breadth-first search. The algorithm also uses a greedy initial matching for optimization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-match.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename T>\nvector<int> find_max_unweighted_matching(const undirectedgraph<T> &g) {\n  std::mt19937 rng(std::random_device{}());\n  vector<int> match(g.n, -1);   // 匹配\n  vector<int> aux(g.n, -1);     // 时间戳记\n  vector<int> label(g.n);       // 「o」或「i」\n  vector<int> orig(g.n);        // 花根\n  vector<int> parent(g.n, -1);  // 父节点\n  queue<int> q;\n  int aux_time = -1;\n\n  auto lca = [&](int v, int u) {\n    // LCA implementation\n  };\n\n  auto blossom = [&](int v, int u, int a) {\n    // Blossom handling\n  };\n\n  auto augment = [&](int v) {\n    // Path augmentation\n  };\n\n  auto bfs = [&](int root) {\n    // BFS implementation\n  };\n\n  auto greedy = [&]() {\n    // Greedy initial matching\n  };\n\n  greedy();\n  for (int i = 0; i < g.n; i++) {\n    if (match[i] == -1) {\n      bfs(i);\n    }\n  }\n  return match;\n}\n```\n\n----------------------------------------\n\nTITLE: High-Precision Division in C++\nDESCRIPTION: Division implementation using long division algorithm. Includes helper function to compare numbers and handle remainder calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nbool greater_eq(int a[], int b[], int last_dg, int len) {\n  if (a[last_dg + len] != 0) return true;\n  for (int i = len - 1; i >= 0; --i) {\n    if (a[last_dg + i] > b[i]) return true;\n    if (a[last_dg + i] < b[i]) return false;\n  }\n  return true;\n}\n\nvoid div(int a[], int b[], int c[], int d[]) {\n  clear(c);\n  clear(d);\n\n  int la, lb;\n  for (la = LEN - 1; la > 0; --la)\n    if (a[la - 1] != 0) break;\n  for (lb = LEN - 1; lb > 0; --lb)\n    if (b[lb - 1] != 0) break;\n  if (lb == 0) {\n    puts(\"> <\");\n    return;\n  }\n\n  for (int i = 0; i < la; ++i) d[i] = a[i];\n  for (int i = la - lb; i >= 0; --i) {\n    while (greater_eq(d, b, i, lb)) {\n      for (int j = 0; j < lb; ++j) {\n        d[i + j] -= b[j];\n        if (d[i + j] < 0) {\n          d[i + j + 1] -= 1;\n          d[i + j] += 10;\n        }\n      }\n      c[i] += 1;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Monotonic Queue Optimization for Multiple Knapsack Problem in C++\nDESCRIPTION: Implementation of the multiple knapsack problem using monotonic queue optimization. This code reduces the time complexity from O(W∑ki) to O(nW) by transforming the DP state transitions and using a monotonic queue to efficiently compute maximum values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/monotonous-queue-stack.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/opt/monotonous-queue-stack/monotonous-queue-stack_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Auto-Vectorization Example in C++\nDESCRIPTION: A basic loop that adds elements from one array to another. This pattern can be automatically vectorized by compilers to use SIMD instructions, with Clang typically performing more aggressive vectorization than GCC.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// https://godbolt.org/z/h1hx5sWoE\nvoid test(int *a, int *b, int n) {\n  for (int i = 0; i < n; i++) {\n    a[i] += b[i];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting Loser Tree in C++\nDESCRIPTION: This function demonstrates how to adjust a loser tree when a leaf node is updated. It compares and updates nodes along the path from the leaf to the root, ensuring the tree maintains its property of having the minimum (or maximum) element at the root.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/loser-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid adjust(int index) {\n  int parent = get_parent(index);  // 获取该节点的父亲节点\n  while (parent > 0) {\n    // 比较当前节点和父节点的值，选择较小的节点作为胜者，将败者信息存储到父节点\n    if (segments[index].empty() ||\n        segments[index].front() > segments[tree[parent]].front()) {\n      std::swap(index, tree[parent]);\n    }\n    // 更新父亲节点，继续向上调整\n    parent = get_parent(parent)\n  }\n  // 更新根节点\n  tree[0] = index;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Binary Heap Using Up Adjustment in C++\nDESCRIPTION: Method for constructing a binary heap by sequentially applying the up adjustment to each node in BFS order. This approach has O(n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/binary-heap.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid build_heap_1() {\n  for (i = 1; i <= n; i++) up(i);\n}\n```\n\n----------------------------------------\n\nTITLE: Second Dimension Insert Operation in Tree-on-Tree\nDESCRIPTION: Implements an insert operation for the second dimension of the tree structure. Uses dynamic allocation for tree nodes and recursively updates the structure based on the position.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-in-seg.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid tree_insert(int &k, int l, int r, int x) {\n  if (k == 0) k = ++ou_tot;\n  vec_insert(ou_root[k], 1, p, sec[x].z);\n  if (l == r) return;\n  int mid = l + r >> 1;\n  if (sec[x].y <= mid)\n    tree_insert(ou_ch[k][0], l, mid, x);\n  else\n    tree_insert(ou_ch[k][1], mid + 1, r, x);\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplying and Dividing by Powers of Two in C++\nDESCRIPTION: Functions that multiply or divide an integer by a power of two using bitwise shift operations, which is more efficient than standard multiplication or division operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint mulPowerOfTwo(int n, int m) {  // 计算 n*(2^m)\n  return n << m;\n}\nint divPowerOfTwo(int n, int m) {  // 计算 n/(2^m)\n  return n >> m;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum and Minimum Values with Bitwise Operations in C++\nDESCRIPTION: Functions that find the maximum or minimum of two integers using bitwise operations, which can be more efficient on some machines than using conditional statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// 如果 a >= b, (a - b) >> 31 为 0，否则为 -1\nint max(int a, int b) { return (b & ((a - b) >> 31)) | (a & (~(a - b) >> 31)); }\nint min(int a, int b) { return (a & ((a - b) >> 31)) | (b & (~(a - b) >> 31)); }\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Number of Divisors in C++\nDESCRIPTION: Implements a linear sieve algorithm to calculate the number of divisors for numbers up to n. It uses the divisor count theorem and handles prime and composite numbers separately.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> pri;\nbool not_prime[N];\nint d[N], num[N];\n\nvoid pre(int n) {\n  d[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!not_prime[i]) {\n      pri.push_back(i);\n      d[i] = 2;\n      num[i] = 1;\n    }\n    for (int pri_j : pri) {\n      if (i * pri_j > n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) {\n        num[i * pri_j] = num[i] + 1;\n        d[i * pri_j] = d[i] / num[i * pri_j] * (num[i * pri_j] + 1);\n        break;\n      }\n      num[i * pri_j] = 1;\n      d[i * pri_j] = d[i] * 2;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Graph and Undirected Graph Classes in C++\nDESCRIPTION: Defines template classes for representing graphs and undirected graphs. The graph class contains an edge structure and methods for adding edges. The undirected graph class inherits from the graph class and implements the add method for undirected edges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-match.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// graph\ntemplate <typename T>\nclass graph {\n public:\n  struct edge {\n    int from;\n    int to;\n    T cost;\n  };\n\n  vector<edge> edges;\n  vector<vector<int>> g;\n  int n;\n\n  graph(int _n) : n(_n) { g.resize(n); }\n\n  virtual int add(int from, int to, T cost) = 0;\n};\n\n// undirectedgraph\ntemplate <typename T>\nclass undirectedgraph : public graph<T> {\n public:\n  using graph<T>::edges;\n  using graph<T>::g;\n  using graph<T>::n;\n\n  undirectedgraph(int _n) : graph<T>(_n) {}\n\n  int add(int from, int to, T cost = 1) {\n    assert(0 <= from && from < n && 0 <= to && to < n);\n    int id = (int)edges.size();\n    g[from].push_back(id);\n    g[to].push_back(id);\n    edges.push_back({from, to, cost});\n    return id;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Querying Next Value in Treap (C++)\nDESCRIPTION: This function queries the smallest value in the treap that is larger than the given value. It uses splitting and rank querying operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nint qnex(int val) {\n  auto temp = split(root, val);\n  int ret = qval_by_rank(temp.second, 1);\n  // 查询所有大于 val 的子树里面，值最小的那个\n  root = merge(temp.first, temp.second);\n  return ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Edge Weight Management with Link-Cut Trees in C++\nDESCRIPTION: Implementation for maintaining edge weights in a Link-Cut Tree structure. Includes edge splitting technique and operations for finding minimum spanning trees with specific weight constraints. Used to solve a problem finding a spanning tree with minimum difference between maximum and minimum edge weights.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nconstexpr int MAXN = 5000010;\n\nstruct Splay {\n  int ch[MAXN][2], fa[MAXN], tag[MAXN], val[MAXN], minn[MAXN];\n\n  void clear(int x) {\n    ch[x][0] = ch[x][1] = fa[x] = tag[x] = val[x] = minn[x] = 0;\n  }\n\n// ... [rest of second code block]\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS-based Topological Sorting in C++\nDESCRIPTION: This code snippet shows a DFS-based approach to topological sorting. It uses an enum class to track node status and a reverse iterator to build the topological order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/topo.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nusing Graph = vector<vector<int>>;  // 邻接表\n\nstruct TopoSort {\n  enum class Status : uint8_t { to_visit, visiting, visited };\n\n  const Graph& graph;\n  const int n;\n  vector<Status> status;\n  vector<int> order;\n  vector<int>::reverse_iterator it;\n\n  TopoSort(const Graph& graph)\n      : graph(graph),\n        n(graph.size()),\n        status(n, Status::to_visit),\n        order(n),\n        it(order.rbegin()) {}\n\n  bool sort() {\n    for (int i = 0; i < n; ++i) {\n      if (status[i] == Status::to_visit && !dfs(i)) return false;\n    }\n    return true;\n  }\n\n  bool dfs(const int u) {\n    status[u] = Status::visiting;\n    for (const int v : graph[u]) {\n      if (status[v] == Status::visiting) return false;\n      if (status[v] == Status::to_visit && !dfs(v)) return false;\n    }\n    status[u] = Status::visited;\n    *it++ = u;\n    return true;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Du's Sieve Algorithm in C++\nDESCRIPTION: This code snippet implements Du's sieve algorithm to efficiently calculate sums of multiplicative functions. It includes modular arithmetic operations and uses memoization to optimize calculations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/du.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/du/du_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimized Minimum String Representation Algorithm in C++\nDESCRIPTION: This snippet presents an optimized C++ implementation of the minimum string representation algorithm. It improves upon the simple approach by skipping unnecessary comparisons when encountering repeated substrings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/minimal-string.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint k = 0, i = 0, j = 1;\nwhile (k < n && i < n && j < n) {\n  if (sec[(i + k) % n] == sec[(j + k) % n]) {\n    k++;\n  } else {\n    sec[(i + k) % n] > sec[(j + k) % n] ? i = i + k + 1 : j = j + k + 1;\n    if (i == j) i++;\n    k = 0;\n  }\n}\ni = min(i, j);\n```\n\n----------------------------------------\n\nTITLE: Finding Kth Best Solution in 0-1 Knapsack C++\nDESCRIPTION: Implementation for finding the kth best solution in 0-1 knapsack problem using dynamic programming with an additional dimension to track k best values at each state.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nmemset(dp, 0, sizeof(dp));\nint i, j, p, x, y, z;\nscanf(\"%d%d%d\", &n, &m, &K);\nfor (i = 0; i < n; i++) scanf(\"%d\", &w[i]);\nfor (i = 0; i < n; i++) scanf(\"%d\", &c[i]);\nfor (i = 0; i < n; i++) {\n  for (j = m; j >= c[i]; j--) {\n    for (p = 1; p <= K; p++) {\n      a[p] = dp[j - c[i]][p] + w[i];\n      b[p] = dp[j][p];\n    }\n    a[p] = b[p] = -1;\n    x = y = z = 1;\n    while (z <= K && (a[x] != -1 || b[y] != -1)) {\n      if (a[x] > b[y])\n        dp[j][z] = a[x++];\n      else\n        dp[j][z] = b[y++];\n      if (dp[j][z] != dp[j][z - 1]) z++;\n    }\n  }\n}\nprintf(\"%d\\n\", dp[m][K]);\n```\n\n----------------------------------------\n\nTITLE: Cipolla's Algorithm for Square Root in Finite Field\nDESCRIPTION: Implementation of Cipolla's algorithm to find the square root of a quadratic residue modulo a prime p. This algorithm uses field extension to F_p^2 for computation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\ndef cipolla(a, p):\n    if p == 2:\n        return a % 2\n    \n    def mul(x, y, w):\n        return ((x[0]*y[0] + x[1]*y[1]*w) % p,\n                (x[0]*y[1] + x[1]*y[0]) % p)\n    \n    def pow(x, n, w):\n        if n == 0:\n            return (1, 0)\n        if n % 2 == 0:\n            return pow(mul(x, x, w), n // 2, w)\n        return mul(x, pow(x, n-1, w), w)\n    \n    if pow(a, (p-1)//2, p)[0] != 1:\n        return None  # a is not a quadratic residue\n    \n    while True:\n        r = random.randint(0, p-1)\n        w = (r*r - a) % p\n        if pow(w, (p-1)//2, p)[0] != 1:\n            break\n    \n    return pow((r, 1), (p+1)//2, w)[0]\n```\n\n----------------------------------------\n\nTITLE: Implementing Kruskal's Algorithm for Minimum Spanning Tree\nDESCRIPTION: This pseudocode outlines how to implement Kruskal's algorithm to find a minimum spanning tree in a graph. The approach involves sorting edges by weight and greedily selecting edges that don't form cycles.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/matroid.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n使用 Kruskal 算法，将所有边按权值从小到大排序，然后逐步选择边，若加入后不形成环，则将其加入生成树，最终得到的生成树即为最小生成树。\n```\n\n----------------------------------------\n\nTITLE: Getting a Specific Bit from a Number in Python\nDESCRIPTION: A Python function that extracts the value of a specific bit from an integer, useful for checking individual bits in binary representations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_10\n\nLANGUAGE: Python\nCODE:\n```\n# 获取 a 的第 b 位，最低位编号为 0\ndef getBit(a, b):\n    return (a >> b) & 1\n```\n\n----------------------------------------\n\nTITLE: Using Complex Numbers in C++ with <complex>\nDESCRIPTION: Example showing complex number usage in C++ with the <complex> header, including object-oriented approach with member functions, and C++14's literal operators for concise complex number declarations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/complex.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n#include <complex>\n#include <iostream>\n\nint main() {\n    // Create complex numbers\n    std::complex<double> z1(1.0, 2.0);  // 1 + 2i\n    \n    // In C++14 and later, can use literal operators\n    using namespace std::literals::complex_literals;\n    auto z2 = 4.0 + 3.0i;  // 4 + 3i\n    \n    // Member functions\n    double real_part = z1.real();\n    double imag_part = z1.imag();\n    \n    // Non-member functions\n    double magnitude = std::abs(z1);\n    double angle = std::arg(z1);\n    double norm_squared = std::norm(z1);\n    std::complex<double> conjugate = std::conj(z1);\n    \n    // Operations\n    auto sum = z1 + z2;\n    auto product = z1 * z2;\n    auto result = std::exp(z1);\n    \n    std::cout << \"z1 = \" << z1 << std::endl;\n    std::cout << \"z2 = \" << z2 << std::endl;\n    std::cout << \"z1 + z2 = \" << sum << std::endl;\n    \n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing High-Precision Numbers in C++\nDESCRIPTION: Functions to read high-precision numbers from strings and print them. Uses reverse storage where least significant digit is at index 0 for easier alignment and operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid clear(int a[]) {\n  for (int i = 0; i < LEN; ++i) a[i] = 0;\n}\n\nvoid read(int a[]) {\n  static char s[LEN + 1];\n  scanf(\"%s\", s);\n\n  clear(a);\n\n  int len = strlen(s);\n  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';\n}\n\nvoid print(int a[]) {\n  int i;\n  for (i = LEN - 1; i >= 1; --i)\n    if (a[i] != 0) break;\n  for (; i >= 0; --i) putchar(a[i] + '0');\n  putchar('\\n');\n}\n```\n\n----------------------------------------\n\nTITLE: Hash Table Implementation using Open Hashing in C++\nDESCRIPTION: Implementation of a hash table using chaining (open hashing) method in C++. Includes basic operations like get, modify, and add with a modulo hash function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/hash.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int SIZE = 1000000;\nconstexpr int M = 999997;\n\nstruct HashTable {\n  struct Node {\n    int next, value, key;\n  } data[SIZE];\n\n  int head[M], size;\n\n  int f(int key) { return (key % M + M) % M; }\n\n  int get(int key) {\n    for (int p = head[f(key)]; p; p = data[p].next)\n      if (data[p].key == key) return data[p].value;\n    return -1;\n  }\n\n  int modify(int key, int value) {\n    for (int p = head[f(key)]; p; p = data[p].next)\n      if (data[p].key == key) return data[p].value = value;\n  }\n\n  int add(int key, int value) {\n    if (get(key) != -1) return -1;\n    data[++size] = Node{head[f(key)], value, key};\n    head[f(key)] = size;\n    return value;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Range-Based For Loop Implementation with Begin/End Functions in C++\nDESCRIPTION: Demonstrates how to implement custom begin() and end() functions to enable range-based for loops on custom data structures. This example defines iterators for a simple struct.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nstruct C {\n  int a, b, c, d;\n\n  C(int a = 0, int b = 0, int c = 0, int d = 0) : a(a), b(b), c(c), d(d) {}\n};\n\nint* begin(C& p) { return &p.a; }\n\nint* end(C& p) { return &p.d + 1; }\n\nint main() {\n  C n = C(1, 9, 2, 6);\n  for (auto i : n) std::cout << i << \" \";\n  std::cout << std::endl;\n  // The loop below is equivalent to the one above\n  auto&& __range = n;\n  for (auto __begin = begin(n), __end = end(n); __begin != __end; ++__begin) {\n    auto ind = *__begin;\n    std::cout << ind << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the lru_cache Decorator in Python\nDESCRIPTION: This snippet demonstrates the use of the lru_cache decorator from the functools module to implement memoization in a recursive Fibonacci function, improving its performance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@lru_cache(maxsize=None)\ndef fib(n):\n    if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)\n```\n\n----------------------------------------\n\nTITLE: Logarithmic Time Josephus Problem Solution in C++\nDESCRIPTION: An optimized logarithmic time implementation with O(k log n) complexity. Uses recursive approach with position restoration for cases where k is small and n is large.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/josephus.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint josephus(int n, int k) {\n  if (n == 1) return 0;\n  if (k == 1) return n - 1;\n  if (k > n) return (josephus(n - 1, k) + k) % n;  // 线性算法\n  int res = josephus(n - n / k, k);\n  res -= n % k;\n  if (res < 0)\n    res += n;  // mod n\n  else\n    res += res / (k - 1);  // 还原位置\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Permutations with next_permutation in C++\nDESCRIPTION: Shows how to use next_permutation to generate all permutations of numbers 1 to 9. This example demonstrates iterating through permutations until the last one is reached.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint N = 9, a[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\ndo {\n  for (int i = 0; i < N; i++) cout << a[i] << \" \";\n  cout << endl;\n} while (next_permutation(a, a + N));\n```\n\n----------------------------------------\n\nTITLE: Using Logical Operators in C++\nDESCRIPTION: This code snippet demonstrates the three logical operators in C++: AND (&&), OR (||), and NOT (!). It shows how these operators evaluate expressions and assign boolean results based on the truth values of the operands.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nResult = op1 && op2;  // 当 op1 与 op2 都为真时则 Result 为真\n\nResult = op1 || op2;  // 当 op1 或 op2 其中一个为真时则 Result 为真\n\nResult = !op1;  // 当 op1 为假时则 Result 为真\n```\n\n----------------------------------------\n\nTITLE: Early Return Pattern in C++\nDESCRIPTION: Demonstrates how C++ uses return statements for early function termination, whereas Pascal would require an exit statement for the same functionality.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n\nvoid printWarning(int x) {\n  if (x >= 0) {\n    return;  // 该语句在此处相当于 Pascal 中的 `exit;`\n  }\n  std::cout << \"Warning: input a negative number.\";\n}\n\nint main() {\n  int a;\n\n  std::cin >> a;\n  printWarning(a);\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Bear and Prime 100 Interactive Problem in C++\nDESCRIPTION: Solution to CF679A that uses prime number enumeration to determine if a number is prime or composite through limited queries. The code checks numbers up to 50 and their squares within 20 queries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/interaction.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\nconstexpr int prime[] = {2,  3,  4,  5,  7,  9,  11, 13, 17, 19,\n                             23, 25, 29, 31, 37, 41, 43, 47, 49};\nint cnt = 0;\nchar res[5];\n\nint main() {\n  for (int i : prime) {\n    printf(\"%d\\n\", i);\n    fflush(stdout);\n    scanf(\"%s\", res);\n    if (res[0] == 'y' && ++cnt == 2) return printf(\"composite\"), 0;\n  }\n  printf(\"prime\");\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Manhattan Distance in Python\nDESCRIPTION: This Python code calculates the maximum Manhattan distance between a set of points by finding the maximum difference in x+y and x-y coordinates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/distance.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nminx = 0x7FFFFFFF\nmaxx = 0\nminy = 0x7FFFFFFF\nmaxy = 0\nn = int(input())\nfor i in range(1, n + 1):\n    x, y = map(lambda x: int(x), input().split())\n    minx = min(minx, x + y)\n    maxx = max(maxx, x + y)\n    miny = min(miny, x - y)\n    maxy = max(maxy, x - y)\nprint(max(maxx - minx, maxy - miny))\n```\n\n----------------------------------------\n\nTITLE: Final Optimized KMP Implementation\nDESCRIPTION: The final optimized implementation of the Knuth-Morris-Pratt algorithm with linear time complexity O(n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++) {\n    int j = pi[i - 1];\n    while (j > 0 && s[i] != s[j]) j = pi[j - 1];\n    if (s[i] == s[j]) j++;\n    pi[i] = j;\n  }\n  return pi;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        j = pi[i - 1]\n        while j > 0 and s[i] != s[j]:\n            j = pi[j - 1]\n        if s[i] == s[j]:\n            j += 1\n        pi[i] = j\n    return pi\n```\n\nLANGUAGE: Java\nCODE:\n```\nstatic int[] prefix_function(String s) {\n    int n = s.length();\n    int[] pi = new int[n];\n    for (int i = 1; i < n; i++) {\n\tint j = pi[i - 1];\n\twhile (j > 0 && s.charAt(i) != s.charAt(j)) {\n\t    j = pi[j - 1];\n\t}\n\tif (s.charAt(i) == s.charAt(j)) {\n\t    j++;\n\t}\n\tpi[i] = j;\n    }\n    return pi;\n}\n```\n\n----------------------------------------\n\nTITLE: 多项式求逆的C++实现\nDESCRIPTION: 使用倍增法实现多项式求逆,给定多项式h(x),求其模x^n意义下的逆元。时间复杂度O(nlogn)。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/elementary-func.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int MAXN = 262144;\nconstexpr int mod = 998244353;\n\nusing i64 = long long;\nusing poly_t = int[MAXN];\nusing poly = int *const;\n\nvoid polyinv(const poly &h, const int n, poly &f) {\n  /* f = 1 / h = f_0 (2 - f_0 h) */\n  static poly_t inv_t;\n  std::fill(f, f + n + n, 0);\n  f[0] = fpow(h[0], mod - 2);\n  for (int t = 2; t <= n; t <<= 1) {\n    const int t2 = t << 1;\n    std::copy(h, h + t, inv_t);\n    std::fill(inv_t + t, inv_t + t2, 0);\n\n    DFT(f, t2);\n    DFT(inv_t, t2);\n    for (int i = 0; i != t2; ++i)\n      f[i] = (i64)f[i] * sub(2, (i64)f[i] * inv_t[i] % mod) % mod;\n    IDFT(f, t2);\n\n    std::fill(f + t, f + t2, 0);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Building Binary Heap Using Down Adjustment in C++\nDESCRIPTION: Efficient method for constructing a binary heap in O(n) time by sequentially applying the down adjustment to each node in reverse order, starting from the last non-leaf node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/binary-heap.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid build_heap_2() {\n  for (i = n; i >= 1; i--) down(i);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Enumeration in C++\nDESCRIPTION: A simple implementation of enumeration to find number pairs that sum to zero in an array. This version iterates through all possible pairs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n```\n\n----------------------------------------\n\nTITLE: Implementing DAG-based DP Solution for Tower of Babylon Problem in C++\nDESCRIPTION: This C++ implementation solves the Tower of Babylon problem by modeling it as a DAG and finding the longest path. The solution uses dynamic programming with memoization to avoid redundant calculations, where each block is considered in three different orientations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/dag.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/dag/dag_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Counting Distinct Substrings Using General Suffix Automaton in C++\nDESCRIPTION: This code snippet demonstrates how to use the General Suffix Automaton to count the number of distinct substrings across multiple input strings. It builds the GSA and calculates the sum of distinct substrings for each node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/general-sam.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/general-sam/general-sam_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: LeetCode 437: Path Sum III Solution\nDESCRIPTION: Solution to the Path Sum III problem using recursion. Two functions work together: pathSum handles tree traversal while count finds paths starting from each node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nint count(TreeNode *node, int sum) {\n  if (node == nullptr) return 0;\n\n  int isMe = (node->val == sum) ? 1 : 0;\n  int leftNode = count(node->left, sum - node->val);\n  int rightNode = count(node->right, sum - node->val);\n  return isMe + leftNode + rightNode;\n}\n\nint pathSum(TreeNode *root, int sum) {\n  if (root == nullptr) return 0;\n\n  int pathImLeading = count(root, sum);\n  int leftPathSum = pathSum(root->left, sum);\n  int rightPathSum = pathSum(root->right, sum);\n  return leftPathSum + rightPathSum + pathImLeading;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Function in C++\nDESCRIPTION: Demonstrates how to implement a previously declared function. The function takes two integer parameters, performs a calculation, and returns the result. Also shows how code after a return statement is not executed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint some_function(int, int);  // 声明\n\n/* some other code here... */\n\nint some_function(int x, int y) {  // 定义\n  int result = 2 * x + y;\n  return result;\n  result = 3;  // 这条语句不会被执行\n}\n```\n\n----------------------------------------\n\nTITLE: Simulating Dice Rolls with Uniform Distribution in C++\nDESCRIPTION: Simulates rolling a six-sided die using uniform_int_distribution and mt19937 random number generator. Demonstrates how to generate random integers within a specific range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n#include <random>\n\nint main() {\n  std::random_device rd;\n  std::mt19937 gen(rd());\n  std::uniform_int_distribution<> dis(1, 6);\n\n  for (int n = 0; n < 10; ++n)\n    std::cout << dis(gen) << ' ';\n  std::cout << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting an Element in BST in C++\nDESCRIPTION: A recursive function to insert a value into a Binary Search Tree while maintaining size information. If the value already exists, it increments the count field. Time complexity is O(h) where h is the height of the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nTreeNode* insert(TreeNode* root, int value) {\n  if (root == nullptr) {\n    return new TreeNode(value);\n  }\n  if (value < root->key) {\n    root->left = insert(root->left, value);\n  } else if (value > root->key) {\n    root->right = insert(root->right, value);\n  } else {\n    root->count++;  // 节点值相等，增加重复数量\n  }\n  root->size = root->count + (root->left ? root->left->size : 0) +\n               (root->right ? root->right->size : 0);  // 更新节点的子树大小\n  return root;\n}\n```\n\n----------------------------------------\n\nTITLE: Initial Access Operation Implementation\nDESCRIPTION: Implementation of the basic access operation that handles parent-child relationships and rotations in the Top Tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nif (rs(x)) {\n  int y = new_node();\n  setfather(ms(x), y, 0);\n  setfather(rs(x), y, 2);\n  rs(x) = 0;\n  setfather(y, x, 2);\n  pushup(y, 1);\n  pushup(x, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Example of GNU PBDS Priority Queue Operations\nDESCRIPTION: A complete example demonstrating various operations on a priority queue including push, pop, modify, erase, and join operations, showcasing the functionality of the pairing heap implementation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/pq.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <ext/pb_ds/priority_queue.hpp>\n#include <iostream>\nusing namespace __gnu_pbds;\n// 由于面向OIer, 本文以常用堆 : pairing_heap_tag作为范例\n// 为了更好的阅读体验，定义宏如下 ：\nusing pair_heap = __gnu_pbds::priority_queue<int>;\npair_heap q1;  // 大根堆, 配对堆\npair_heap q2;\npair_heap::point_iterator id;  // 一个迭代器\n\nint main() {\n  id = q1.push(1);\n  // 堆中元素 ： [1];\n  for (int i = 2; i <= 5; i++) q1.push(i);\n  // 堆中元素 :  [1, 2, 3, 4, 5];\n  std::cout << q1.top() << std::endl;\n  // 输出结果 : 5;\n  q1.pop();\n  // 堆中元素 : [1, 2, 3, 4];\n  id = q1.push(10);\n  // 堆中元素 : [1, 2, 3, 4, 10];\n  q1.modify(id, 1);\n  // 堆中元素 :  [1, 1, 2, 3, 4];\n  std::cout << q1.top() << std::endl;\n  // 输出结果 : 4;\n  q1.pop();\n  // 堆中元素 : [1, 1, 2, 3];\n  id = q1.push(7);\n  // 堆中元素 : [1, 1, 2, 3, 7];\n  q1.erase(id);\n  // 堆中元素 : [1, 1, 2, 3];\n  q2.push(1), q2.push(3), q2.push(5);\n  // q1中元素 : [1, 1, 2, 3], q2中元素 : [1, 3, 5];\n  q2.join(q1);\n  // q1中无元素，q2中元素 ：[1, 1, 1, 2, 3, 3, 5];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing prefix sum query in Tree Array using C++\nDESCRIPTION: Function to calculate the sum of elements from a[1] to a[x] using a tree array/Fenwick tree. This demonstrates the core query operation that traverses the tree by repeatedly removing the lowest set bit.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint getsum(int x) {  // a[1]..a[x]的和\n  int ans = 0;\n  while (x > 0) {\n    ans = ans + c[x];\n    x = x - lowbit(x);\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized LIS (Longest Increasing Subsequence) in C++\nDESCRIPTION: A memoization implementation for the Longest Increasing Subsequence problem. This demonstrates how to convert a standard DP formulation into a memoized recursive implementation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint dfs(int i) {\n  if (mem[i] != -1) return mem[i];\n  int ret = 1;\n  for (int j = 1; j < i; j++)\n    if (a[j] < a[i]) ret = max(ret, dfs(j) + 1);\n  return mem[i] = ret;\n}\n\nint main() {\n  memset(mem, -1, sizeof(mem));\n  // 读入部分略去\n  int ret = 0;\n  for (int j = 1; j <= n; j++) {\n    ret = max(ret, dfs(j));\n  }\n  cout << ret << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Rebalancing Case 3 After Deletion in Red-Black Tree (C++)\nDESCRIPTION: Handles rebalancing when the sibling, parent, and nephew nodes are all black after deletion in a red-black tree. Colors the sibling red and recursively maintains the parent node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\nsibling->color = Node::RED;\nmaintainAfterRemove(node->parent);\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Implementing Floyd-Warshall for Minimum Cycle in C++\nDESCRIPTION: This code snippet implements the Floyd-Warshall algorithm to find the minimum cycle in a graph. It initializes the distance matrix, updates the answer by checking cycles through each vertex, and performs the standard Floyd-Warshall updates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/min-cycle.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint val[MAXN + 1][MAXN + 1];  // 原图的邻接矩阵\n\nint floyd(const int &n) {\n  static int dis[MAXN + 1][MAXN + 1];  // 最短路矩阵\n  for (int i = 1; i <= n; ++i)\n    for (int j = 1; j <= n; ++j) dis[i][j] = val[i][j];  // 初始化最短路矩阵\n  int ans = inf;\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i < k; ++i)\n      for (int j = 1; j < i; ++j)\n        ans = std::min(ans, dis[i][j] + val[i][k] + val[k][j]);  // 更新答案\n    for (int i = 1; i <= n; ++i)\n      for (int j = 1; j <= n; ++j)\n        dis[i][j] = std::min(\n            dis[i][j], dis[i][k] + dis[k][j]);  // 正常的 floyd 更新最短路矩阵\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Longest Common Subsequence in C++\nDESCRIPTION: This function implements the dynamic programming algorithm for finding the length of the longest common subsequence between two sequences. It uses a 2D array to store intermediate results and has O(nm) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/basic.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint a[MAXN], b[MAXM], f[MAXN][MAXM];\n\nint dp() {\n  for (int i = 1; i <= n; i++)\n    for (int j = 1; j <= m; j++)\n      if (a[i] == b[j])\n        f[i][j] = f[i - 1][j - 1] + 1;\n      else\n        f[i][j] = std::max(f[i - 1][j], f[i][j - 1]);\n  return f[n][m];\n}\n```\n\n----------------------------------------\n\nTITLE: Range Assignment and Count Query Operations for Block Array\nDESCRIPTION: Implements range assignment operations and count queries for elements below a threshold. Uses special value marking for unassigned blocks.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-array.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Sort(int k) {\n  for (int i = st[k]; i <= ed[k]; i++) t[i] = a[i];\n  sort(t + st[k], t + ed[k] + 1);\n}\n\nvoid PushDown(int x) {\n  if (delta[x] != 0x3f3f3f3f3f3f3f3fll)  // 用该值标记块内没有被整体赋值\n    for (int i = st[x]; i <= ed[x]; i++) a[i] = t[i] = delta[x];\n  delta[x] = 0x3f3f3f3f3f3f3f3fll;\n}\n\nvoid Modify(int l, int r, int c) {\n  int x = belong[l], y = belong[r];\n  PushDown(x);\n  if (x == y) {\n    for (int i = l; i <= r; i++) a[i] = c;\n    Sort(x);\n    return;\n  }\n  PushDown(y);\n  for (int i = l; i <= ed[x]; i++) a[i] = c;\n  for (int i = st[y]; i <= r; i++) a[i] = c;\n  Sort(x);\n  Sort(y);\n  for (int i = x + 1; i < y; i++) delta[i] = c;\n}\n\nint Binary_Search(int l, int r, int c) {\n  int ans = l - 1, mid;\n  while (l <= r) {\n    mid = (l + r) / 2;\n    if (t[mid] <= c)\n      ans = mid, l = mid + 1;\n    else\n      r = mid - 1;\n  }\n  return ans;\n}\n\nint Answer(int l, int r, int c) {\n  int ans = 0, x = belong[l], y = belong[r];\n  PushDown(x);\n  if (x == y) {\n    for (int i = l; i <= r; i++)\n      if (a[i] <= c) ans++;\n    return ans;\n  }\n  PushDown(y);\n  for (int i = l; i <= ed[x]; i++)\n    if (a[i] <= c) ans++;\n  for (int i = st[y]; i <= r; i++)\n    if (a[i] <= c) ans++;\n  for (int i = x + 1; i <= y - 1; i++) {\n    if (0x3f3f3f3f3f3f3f3fll == delta[i])\n      ans += Binary_Search(st[i], ed[i], c) - st[i] + 1;\n    else if (delta[i] <= c)\n      ans += size[i];\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Blossom Expansion in General Weighted Matching Algorithm (C++)\nDESCRIPTION: Implements the process of expanding a blossom (odd cycle) in the graph when its dual variable becomes zero. This function handles the de-contraction of a blossom node back into its constituent vertices, updating all relevant data structures.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvoid expand_blossom(int b) {\n  // b是奇花且zB=0时，必须要把b拆开\n  // 因为只拆开b而已，所以如果b里面有包含其他的花\n  // 不需要把他们拆开\n  for (size_t i = 0; i < flower[b].size(); ++i) {\n    set_st(flower[b][i], flower[b][i]);\n    // 先把flower[b]里每个元素所在的花设为自己\n  }\n  int xr = flower_from[b][g[b][pa[b]].u];\n  // xr表示交错路上b的父母节点在flower[b]里的哪朵花上\n  int pr = get_pr(b, xr);  // 找出xr的位置并让0~pr为花里的交替路径\n  for (int i = 0; i < pr; i += 2) {\n    // 把交替路径拆开到交错树中\n    // 并把交替路中的偶点丢到queue里\n    int xs = flower[b][i];\n    int xns = flower[b][i + 1];\n    pa[xs] = g[xns][xs].u;\n    S[xs] = 1;\n    S[xns] = 0;\n    slack[xs] = 0;\n    set_slack(xns);\n    q_push(xns);\n  }\n  S[xr] = 1;  // 这时xr会是奇点或奇花\n  pa[xr] = pa[b];\n  for (size_t i = pr + 1; i < flower[b].size(); ++i) {\n    // 把花中所有不再交替路径上的点设为未走访\n    int xs = flower[b][i];\n    S[xs] = -1;\n    set_slack(xs);\n  }\n  st[b] = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Catalan Numbers in C++\nDESCRIPTION: This code calculates the nth Catalan number using the recursive formula H_n = H_{n-1} * (4n-2) / (n+1). It uses long long to handle larger values and stores results in an array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/catalan.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\nusing namespace std;\nint n;\nlong long f[25];\n\nint main() {\n  f[0] = 1;\n  cin >> n;\n  for (int i = 1; i <= n; i++) f[i] = f[i - 1] * (4 * i - 2) / (i + 1);\n  // 这里用的是常见公式2\n  cout << f[n] << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Substrings in C++ String\nDESCRIPTION: Demonstrates the use of find() function to locate characters or substrings within a std::string, including handling of not found cases.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstring s = \"OI Wiki\", t = \"OI\", u = \"i\";\nint pos = 5;\nprintf(\"字符 I 在 s 的 %lu 位置第一次出现\\n\", s.find('I'));\nprintf(\"字符 a 在 s 的 %lu 位置第一次出现\\n\", s.find('a'));\nprintf(\"字符 a 在 s 的 %d 位置第一次出现\\n\", s.find('a'));\nprintf(\"字符串 t 在 s 的 %lu 位置第一次出现\\n\", s.find(t));\nprintf(\"在 s 中自 pos 位置起字符串 u 第一次出现在 %lu 位置\", s.find(u, pos));\n```\n\n----------------------------------------\n\nTITLE: Flipping a Specific Bit in C++\nDESCRIPTION: A function that toggles (inverts) a specific bit of an integer while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\n// 将 a 的第 b 位取反 ，最低位编号为 0\nint flapBit(int a, int b) { return a ^ (1 << b); }\n```\n\n----------------------------------------\n\nTITLE: Querying Previous Node in Treap (C++)\nDESCRIPTION: This function queries the first node with a value smaller than the given value in a treap. It uses recursion to traverse the tree and a global variable to track the result.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nint _query_prev(Node *cur, int val) {\n  if (val <= cur->val) {\n    // 还是比 val 大，所以往左子树找\n    if (cur->ch[0] != nullptr) return _query_prev(cur->ch[0], val);\n  } else {\n    // 只有能进到这个 else 里，才会更新 q_prev_tmp 的值\n    q_prev_tmp = cur->val;\n    // 当前节点已经比 val，小了，但是不确定是否是最大的，所以要到右子树继续找\n    if (cur->ch[1] != nullptr) _query_prev(cur->ch[1], val);\n    // 接下来的递归可能不会更改 q_prev_tmp\n    // 了，那就直接返回这个值，总之返回的就是最后一次进到 这个 else 中的\n    // cur->val\n    return q_prev_tmp;\n  }\n  return NIL;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Ukkonen's Suffix Tree Algorithm in C++\nDESCRIPTION: This code implements Ukkonen's algorithm for building a suffix tree that supports adding characters to the end of the string. It uses a struct SuffixTree to represent the tree and provides an extend method to add new characters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct SuffixTree {\n  int ch[M + 5][RNG + 1], st[M + 5], len[M + 5], link[M + 5];\n  int s[N + 5];\n  int now{1}, rem{0}, n{0}, tot{1};\n\n  SuffixTree() { len[0] = inf; }\n\n  int new_node(int s, int le) {\n    ++tot;\n    st[tot] = s;\n    len[tot] = le;\n    return tot;\n  }\n\n  void extend(int x) {\n    s[++n] = x;\n    ++rem;\n    for (int lst{1}; rem;) {\n      while (rem > len[ch[now][s[n - rem + 1]]])\n        rem -= len[now = ch[now][s[n - rem + 1]]];\n      int &v{ch[now][s[n - rem + 1]]}, c{s[st[v] + rem - 1]};\n      if (!v || x == c) {\n        lst = link[lst] = now;\n        if (!v)\n          v = new_node(n, inf);\n        else\n          break;\n      } else {\n        int u{new_node(st[v], rem - 1)};\n        ch[u][c] = v;\n        ch[u][x] = new_node(n, inf);\n        st[v] += rem - 1;\n        len[v] -= rem - 1;\n        lst = link[lst] = v = u;\n      }\n      if (now == 1)\n        --rem;\n      else\n        now = link[now];\n    }\n  }\n} Tree;\n```\n\n----------------------------------------\n\nTITLE: Handling Case 5 in Red-Black Tree Insertion\nDESCRIPTION: Handles the case where the current node is in the opposite direction of its parent during insertion. Performs a rotation to transform the tree structure into Case 6.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// clang-format off\n// Case 5: Current node is the opposite direction as parent\n//   Step 1. If node is a LEFT child, perform l-rotate to parent;\n//           If node is a RIGHT child, perform r-rotate to parent.\n//   Step 2. Goto Case 6.\n//      [G]                 [G]\n//      / \\    rotate(P)    / \\\n//    <P> [U]  ========>  <N> [U]\n//      \\                 /\n//      <N>             <P>\n// clang-format on\n\n// Step 1: Rotation\nNodePtr parent = node->parent;\nif (node->direction() == Direction::LEFT) {\n  rotateRight(node->parent);\n} else /* node->direction() == Direction::RIGHT */ {\n  rotateLeft(node->parent);\n}\nnode = parent;\n// Step 2: vvv\n```\n\n----------------------------------------\n\nTITLE: SAM Initialization Function\nDESCRIPTION: Function to initialize the Suffix Automaton with a single initial state.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sam.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid sam_init() {\n  st[0].len = 0;\n  st[0].link = -1;\n  sz++;\n  last = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Stack Usage Example in C++\nDESCRIPTION: Demonstrates basic stack operations including push, pop, size, top, and empty checks.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nstd::stack<int> s1;\ns1.push(2);\ns1.push(1);\nstd::stack<int> s2(s1);\ns1.pop();\nstd::cout << s1.size() << \" \" << s2.size() << std::endl;  // 1 2\nstd::cout << s1.top() << \" \" << s2.top() << std::endl;    // 2 1\ns1.pop();\nstd::cout << s1.empty() << \" \" << s2.empty() << std::endl;  // 1 0\n```\n\n----------------------------------------\n\nTITLE: 多项式对数和指数函数的C++实现\nDESCRIPTION: 使用Newton法实现多项式的ln和exp操作。polyln计算ln h = ∫ h'/h dx,时间复杂度O(nlogn)。polyexp计算exp(h),时间复杂度O(nlogn)。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/elementary-func.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int MAXN = 262144;\nconstexpr int mod = 998244353;\n\nusing i64 = long long;\nusing poly_t = int[MAXN];\nusing poly = int *const;\n\nvoid derivative(const poly &h, const int n, poly &f) {\n  for (int i = 1; i != n; ++i) f[i - 1] = (i64)h[i] * i % mod;\n  f[n - 1] = 0;\n}\n\nvoid integrate(const poly &h, const int n, poly &f) {\n  for (int i = n - 1; i; --i) f[i] = (i64)h[i - 1] * inv[i] % mod;\n  f[0] = 0; /* C */\n}\n\nvoid polyln(const poly &h, const int n, poly &f) {\n  /* f = ln h = ∫ h' / h dx */\n  assert(h[0] == 1);\n  static poly_t ln_t;\n  const int t = n << 1;\n\n  derivative(h, n, ln_t);\n  std::fill(ln_t + n, ln_t + t, 0);\n  polyinv(h, n, f);\n\n  DFT(ln_t, t);\n  DFT(f, t);\n  for (int i = 0; i != t; ++i) ln_t[i] = (i64)ln_t[i] * f[i] % mod;\n  IDFT(ln_t, t);\n\n  integrate(ln_t, n, f);\n}\n\nvoid polyexp(const poly &h, const int n, poly &f) {\n  /* f = exp(h) = f_0 (1 - ln f_0 + h) */\n  assert(h[0] == 0);\n  static poly_t exp_t;\n  std::fill(f, f + n + n, 0);\n  f[0] = 1;\n  for (int t = 2; t <= n; t <<= 1) {\n    const int t2 = t << 1;\n\n    polyln(f, t, exp_t);\n    exp_t[0] = sub(pls(h[0], 1), exp_t[0]);\n    for (int i = 1; i != t; ++i) exp_t[i] = sub(h[i], exp_t[i]);\n    std::fill(exp_t + t, exp_t + t2, 0);\n\n    DFT(f, t2);\n    DFT(exp_t, t2);\n    for (int i = 0; i != t2; ++i) f[i] = (i64)f[i] * exp_t[i] % mod;\n    IDFT(f, t2);\n\n    std::fill(f + t, f + t2, 0);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Break in C++\nDESCRIPTION: Shows the correct usage of break statements in a switch to prevent fall-through behavior. Each case executes only its intended code.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nchar i = 'B';\n\nswitch (i) {\n  case 'A':\n    cout << \"OI\" << endl;\n    break;\n\n  case 'B':\n    cout << \"WIKI\" << endl;\n    break;\n\n  default:\n    cout << \"Hello World\" << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Arrays with Constant and Non-Constant Sizes in C++\nDESCRIPTION: This snippet demonstrates the correct and incorrect ways to declare arrays in C++. It shows that array sizes must be constant expressions at compile-time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/array.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nunsigned int d1 = 42;\nconst int d2 = 42;\nint arr1[d1];  // 错误：d1 不是常量表达式\nint arr2[d2];  // 正确：arr2 是一个长度为 42 的数组\n```\n\n----------------------------------------\n\nTITLE: Finding Parent and Child Nodes in Binary Heap Array\nDESCRIPTION: Formulas for finding the parent node, left child node, and right child node of an element at index i in a binary heap stored as an array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/heap-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\niParent(i) = (i - 1) / 2;\niLeftChild(i) = 2 * i + 1;\niRightChild(i) = 2 * i + 2;\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-recursive FFT in C++ (Method 2)\nDESCRIPTION: This function implements the Fast Fourier Transform (FFT) and its inverse (IFFT) using an alternative method. It supports both DFT (on=1) and IDFT (on=-1) operations, with a different approach for IDFT.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fft.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid fft(Complex y[], int len, int on) {\n  change(y, len);\n  for (int h = 2; h <= len; h <<= 1) {\n    Complex wn(cos(2 * PI / h), sin(2 * PI / h));\n    for (int j = 0; j < len; j += h) {\n      Complex w(1, 0);\n      for (int k = j; k < j + h / 2; k++) {\n        Complex u = y[k];\n        Complex t = w * y[k + h / 2];\n        y[k] = u + t;\n        y[k + h / 2] = u - t;\n        w = w * wn;\n      }\n    }\n  }\n  if (on == -1) {\n    reverse(y + 1, y + len);\n    for (int i = 0; i < len; i++) {\n      y[i].x /= len;\n      y[i].y /= len;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Java Main Method Structure\nDESCRIPTION: Demonstrates the standard entry point method structure for Java programs. Shows the basic class and main method declaration required for executable Java programs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nclass Test {\n    public static void main(String[] args) {\n        // 程序的代码\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Iterative Implementation of Euclidean Algorithm for GCD in C++\nDESCRIPTION: An iterative implementation of the Euclidean algorithm for finding the greatest common divisor in C++. This avoids recursion by using a while loop until b becomes zero.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nint gcd(int a, int b) {\n  while (b != 0) {\n    int tmp = a;\n    a = b;\n    b = tmp % b;\n  }\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Tree Traversal Using Recursion in C++\nDESCRIPTION: A concise recursive function for traversing a binary tree, demonstrating the power of recursive thinking where a function is trusted to perform its task without delving into implementation details.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid traverse(TreeNode* root) {\n  if (root == nullptr) return;\n  traverse(root->left);\n  traverse(root->right);\n}\n```\n\n----------------------------------------\n\nTITLE: 实现带修改的莫队算法解决区间颜色计数问题\nDESCRIPTION: 这段代码实现了带修改的莫队算法来解决区间颜色计数问题。它处理两种操作：修改序列上某一位的数字，以及询问区间内数字的种类数。算法通过维护当前区间的颜色计数和修改操作，实现了高效的查询和修改。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/modifiable-mo-algo.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/modifiable-mo-algo/modifiable-mo-algo_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Solving Difference Constraints System using Bellman-Ford in C++\nDESCRIPTION: This code implements the Bellman-Ford algorithm to detect negative cycles in a graph, which is used to solve difference constraints systems. It iterates through edges, updating distances, and checks for the existence of negative cycles.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/diff-constraints.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbool Bellman_Ford() {\n  for (int i = 0; i < n; i++) {\n    bool jud = false;\n    for (int j = 1; j <= n; j++)\n      for (int k = h[j]; ~k; k = nxt[k])\n        if (dist[j] > dist[p[k]] + w[k])\n          dist[j] = dist[p[k]] + w[k], jud = true;\n    if (!jud) break;\n  }\n  for (int i = 1; i <= n; i++)\n    for (int j = h[i]; ~j; j = nxt[j])\n      if (dist[i] > dist[p[j]] + w[j]) return false;\n  return true;\n}\n```\n\n----------------------------------------\n\nTITLE: Access Operation in Link-Cut Tree with Subtree Maintenance (C++)\nDESCRIPTION: This modified access operation updates the siz2 array to maintain correct subtree sizes when changing the tree structure. It accounts for changes in virtual and real edges during splaying.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid access(int x) {\n  for (int f = 0; x; f = x, x = fa[x])\n    splay(x), siz2[x] += siz[ch[x][1]] - siz[f], ch[x][1] = f, maintain(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Evaluating Infix Expressions with Unary and Binary Operators in C++\nDESCRIPTION: This code snippet extends the previous algorithm to handle both unary and binary operators, including unary plus and minus. It also demonstrates how to handle right-associative operators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/expression.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nbool delim(char c) { return c == ' '; }\n\nbool is_op(char c) { return c == '+' || c == '-' || c == '*' || c == '/'; }\n\nbool is_unary(char c) { return c == '+' || c == '-'; }\n\nint priority(char op) {\n  if (op < 0)  // unary operator\n    return 3;\n  if (op == '+' || op == '-') return 1;\n  if (op == '*' || op == '/') return 2;\n  return -1;\n}\n\nvoid process_op(stack<int>& st, char op) {\n  if (op < 0) {\n    int l = st.top();\n    st.pop();\n    switch (-op) {\n      case '+':\n        st.push(l);\n        break;\n      case '-':\n        st.push(-l);\n        break;\n    }\n  } else {\n    int r = st.top();\n    st.pop();\n    int l = st.top();\n    st.pop();\n    switch (op) {\n      case '+':\n        st.push(l + r);\n        break;\n      case '-':\n        st.push(l - r);\n        break;\n      case '*':\n        st.push(l * r);\n        break;\n      case '/':\n        st.push(l / r);\n        break;\n    }\n  }\n}\n\nint evaluate(string& s) {\n  stack<int> st;\n  stack<char> op;\n  bool may_be_unary = true;\n  for (int i = 0; i < (int)s.size(); i++) {\n    if (delim(s[i])) continue;\n\n    if (s[i] == '(') {\n      op.push('(');\n      may_be_unary = true;\n    } else if (s[i] == ')') {\n      while (op.top() != '(') {\n        process_op(st, op.top());\n        op.pop();\n      }\n      op.pop();\n      may_be_unary = false;\n    } else if (is_op(s[i])) {\n      char cur_op = s[i];\n      if (may_be_unary && is_unary(cur_op)) cur_op = -cur_op;\n      while (!op.empty() &&\n             ((cur_op >= 0 && priority(op.top()) >= priority(cur_op)) ||\n              (cur_op < 0 && priority(op.top()) > priority(cur_op)))) {\n        process_op(st, op.top());\n        op.pop();\n      }\n      op.push(cur_op);\n      may_be_unary = true;\n    } else {\n      int number = 0;\n      while (i < (int)s.size() && isalnum(s[i]))\n        number = number * 10 + s[i++] - '0';\n      --i;\n      st.push(number);\n      may_be_unary = false;\n    }\n  }\n\n  while (!op.empty()) {\n    process_op(st, op.top());\n    op.pop();\n  }\n  return st.top();\n}\n```\n\n----------------------------------------\n\nTITLE: Searching for an Element in BST in C++\nDESCRIPTION: A recursive function to search for a target value in a Binary Search Tree. It compares the target with the current node's key and traverses left or right accordingly. Time complexity is O(h) where h is the tree height.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\nbool search(TreeNode* root, int target) {\n  if (root == nullptr) {\n    return false;\n  }\n  if (root->key == target) {\n    return true;\n  } else if (target < root->key) {\n    return search(root->left, target);\n  } else {\n    return search(root->right, target);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Block Array Structure in C++\nDESCRIPTION: Sets up a block array structure by dividing an array into sqrt(n) sized blocks. Establishes block boundaries and assignments for elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-array.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nnum = sqrt(n);\nfor (int i = 1; i <= num; i++)\n  st[i] = n / num * (i - 1) + 1, ed[i] = n / num * i;\ned[num] = n;\nfor (int i = 1; i <= num; i++) {\n  for (int j = st[i]; j <= ed[i]; j++) {\n    belong[j] = i;\n  }\n  size[i] = ed[i] - st[i] + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Conditional and Assignment Operators in C++\nDESCRIPTION: Demonstrates the ternary conditional operator and various assignment operators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\nint i = a > b ? a : b;\nint a = b;\na += 3;\nb -= 4;\na *= 5;\na /= 2;\na %= 3;\nflags <<= 2;\nflags >>= 2;\nflags &= new_flags;\nflags ^= new_flags;\nflags |= new_flags;\n```\n\n----------------------------------------\n\nTITLE: Basic BFS Algorithm Implementation - Pseudocode\nDESCRIPTION: Basic pseudocode implementation of BFS algorithm showing queue usage and visited node tracking.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/bfs.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nbfs(s) {\n  q = new queue()\n  q.push(s), visited[s] = true\n  while (!q.empty()) {\n    u = q.pop()\n    for each edge(u, v) {\n      if (!visited[v]) {\n        q.push(v)\n        visited[v] = true\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Odd-Even Optimization for Mo's Algorithm in C++\nDESCRIPTION: Implementation of the odd-even optimization technique for Mo's Algorithm using a custom sorting comparator. This optimization reduces pointer movement costs by alternating the sort order of right endpoints based on block parity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint unit; // block size\nstruct node {\n  int l, r, id;\n  bool operator < (const node &x) const {\n    return l / unit == x.l / unit ? (r == x.r ? 0 : ((l / unit) & 1) ^ (r < x.r)) : l < x.l;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Constructing XOR Linear Basis using Gaussian Elimination (C++)\nDESCRIPTION: Implements the Gaussian elimination method to construct an XOR linear basis from a given set of numbers. Also includes a function to query the maximum XOR value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/basis.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/basis/basis_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing lowbit function for Tree Array in Python\nDESCRIPTION: Python implementation of the lowbit function used in tree arrays/Fenwick trees. This function returns the value of the lowest set bit and all trailing zeros in the binary representation of a number.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef lowbit(x):\n    \"\"\"\n    x 的二进制中，最低位的 1 以及后面所有 0 组成的数。\n    lowbit(0b01011000) == 0b00001000\n            ~~~~~^~~\n    lowbit(0b01110010) == 0b00000010\n            ~~~~~~~^~\n    \"\"\"\n    return x & -x\n```\n\n----------------------------------------\n\nTITLE: Implementing Up and Down Adjustments for Binary Heap in C++\nDESCRIPTION: Core operations for maintaining heap property. The 'up' function adjusts a node upward by swapping with its parent when the node's value is greater. The 'down' function adjusts a node downward by swapping with its largest child.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/binary-heap.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid up(int x) {\n  while (x > 1 && h[x] > h[x / 2]) {\n    std::swap(h[x], h[x / 2]);\n    x /= 2;\n  }\n}\n\nvoid down(int x) {\n  while (x * 2 <= n) {\n    t = x * 2;\n    if (t + 1 <= n && h[t + 1] > h[t]) t++;\n    if (h[t] <= h[x]) break;\n    std::swap(h[x], h[t]);\n    x = t;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing std::sort and ranges::sort in C++20\nDESCRIPTION: Compares traditional STL sort with the ranges-based sort from C++20, showing how the ranges version can operate directly on containers and has more intuitive syntax for comparators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  vector<int> vec{4, 2, 5, 3, 1};\n\n  sort(vec.begin(), vec.end());  // {1, 2, 3, 4, 5}\n\n  for (const int i : vec) cout << i << \", \";\n  cout << '\\n';\n\n  ranges::sort(vec, ranges::greater{});  // {5, 4, 3, 2, 1}\n\n  for (const int i : vec) cout << i << \", \";\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Variable Undefined Behavior in C++\nDESCRIPTION: Shows how a compiler might optimize code when an uninitialized variable is used conditionally. Since using uninitialized variables is undefined behavior, the compiler can assume the variable must be initialized and optimize accordingly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nint f(int x) {\n  int a;\n  if (x)  // either x nonzero or UB\n    a = 42;\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Query in Python\nDESCRIPTION: Python implementation of the pattern matching function using AC automaton. Tracks matches through the automaton while following failure links.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef query(t: str) -> int:\n    u, res = 0, 0\n    for c in t:\n        u = tr[u][c - ord(\"a\")]\n        j = u\n        while j and e[j] != -1:\n            res += e[j]\n            e[j] = -1\n            j = fail[j]\n    return res\n```\n\n----------------------------------------\n\nTITLE: Finding Convex Hull Diameter using Rotating Calipers in C++\nDESCRIPTION: This C++ code implements the Rotating Calipers algorithm to find the diameter of a convex hull. It uses a stack to store convex hull points and calculates distances between points to find the maximum distance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/rotating-calipers.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint sta[N], top;  // 将凸包上的节点编号存在栈里，第一个和最后一个节点编号相同\n\nll pf(ll x) { return x * x; }\n\nll dis(int p, int q) { return pf(a[p].x - a[q].x) + pf(a[p].y - a[q].y); }\n\nll sqr(int p, int q, int y) { return abs((a[q] - a[p]) * (a[y] - a[q])); }\n\nll mx;\n\nvoid get_longest() {  // 求凸包直径\n  int j = 3;\n  if (top < 4) {\n    mx = dis(sta[1], sta[2]);\n    return;\n  }\n  for (int i = 1; i < top; ++i) {\n    while (sqr(sta[i], sta[i + 1], sta[j]) <=\n           sqr(sta[i], sta[i + 1], sta[j % top + 1]))\n      j = j % top + 1;\n    mx = max(mx, max(dis(sta[i + 1], sta[j]), dis(sta[i], sta[j])));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Array Creation in C++\nDESCRIPTION: Demonstrates dynamic allocation of a one-dimensional array using new[] and delete[].\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nsize_t element_cnt = 5;\nint *p = new int[element_cnt];\ndelete[] p;\n```\n\n----------------------------------------\n\nTITLE: Basic Pointer Usage in C++\nDESCRIPTION: Demonstrates basic pointer declaration, address-of operator, and dereferencing in C++.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint main() {\n  int a = 123;  // a: 123\n  int* pa = &a;\n  *pa = 321;  // a: 321\n}\n```\n\n----------------------------------------\n\nTITLE: Building Fail Pointers with State Compression in AC Automaton\nDESCRIPTION: Optimized implementation of fail pointer construction with state compression for AC automaton. It maintains a bit state for each node that represents the possible match lengths on its fail chain.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid build() {\n  queue<int> q;\n  for (int i = 0; i < 26; i++)\n    if (tr[0].son[i]) {\n      q.push(tr[0].son[i]);\n      tr[tr[0].son[i]].depth = 1;\n    }\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    int v = tr[u].fail;\n    // 对状态的更新在这里\n    tr[u].stat = tr[v].stat;\n    if (tr[u].idx) tr[u].stat |= 1 << tr[u].depth;\n    for (int i = 0; i < 26; i++) {\n      if (tr[u].son[i]) {\n        tr[tr[u].son[i]].fail = tr[tr[u].fail].son[i];\n        tr[tr[u].son[i]].depth = tr[u].depth + 1;  // 记录深度\n        q.push(tr[u].son[i]);\n      } else\n        tr[u].son[i] = tr[tr[u].fail].son[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fractional Programming with Binary Search in C++\nDESCRIPTION: This code demonstrates how to solve a basic fractional programming problem using binary search. It finds the maximum value of a fraction by iteratively refining the answer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/frac-programming.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint read() {\n  int X = 0, w = 1;\n  char c = getchar();\n  while (c < '0' || c > '9') {\n    if (c == '-') w = -1;\n    c = getchar();\n  }\n  while (c >= '0' && c <= '9') X = X * 10 + c - '0', c = getchar();\n  return X * w;\n}\n\nconstexpr int N = 100000 + 10;\nconstexpr double eps = 1e-6;\n\nint n;\ndouble a[N], b[N];\n\nbool check(double mid) {\n  double s = 0;\n  for (int i = 1; i <= n; ++i)\n    if (a[i] - mid * b[i] > 0)  // 如果权值大于 0\n      s += a[i] - mid * b[i];   // 选这个物品\n  return s > 0;\n}\n\nint main() {\n  // 输入\n  n = read();\n  for (int i = 1; i <= n; ++i) a[i] = read();\n  for (int i = 1; i <= n; ++i) b[i] = read();\n  // 二分\n  double L = 0, R = 1e9;\n  while (R - L > eps) {\n    double mid = (L + R) / 2;\n    if (check(mid))  // mid 可行，答案比 mid 大\n      L = mid;\n    else  // mid 不可行，答案比 mid 小\n      R = mid;\n  }\n  // 输出\n  printf(\"%.6lf\\n\", L);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Treaps (C++)\nDESCRIPTION: This function merges two treaps into a single treap. It maintains the heap property based on node priorities while preserving the binary search tree property based on node values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nNode *merge(Node *u, Node *v) {\n  // 传进来的两个树的内部已经符合搜索树的性质了\n  // 并且 u 内所有节点的值 < v 内所有节点的值\n  // 所以在合并的时候需要维护堆的性质\n  // 这里用的是小根堆\n  if (u == nullptr && v == nullptr) return nullptr;\n  if (u != nullptr && v == nullptr) return u;\n  if (v != nullptr && u == nullptr) return v;\n\n  if (u->prio < v->prio) {\n    // u 的 prio 比较小，u应该作为父节点\n    u->ch[1] = merge(u->ch[1], v);\n    // 因为 v 比 u 大，所以把 v 作为 u 的右子树\n    u->upd_siz();\n    return u;\n  } else {\n    // v 比较小，v应该作为父节点\n    v->ch[0] = merge(u, v->ch[0]);\n    // u 比 v 小，所以递归时的参数是这样的\n    v->upd_siz();\n    return v;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Memoization DFS Template in C++\nDESCRIPTION: DFS template incorporating memoization to avoid redundant computations by storing previously calculated results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/opt.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint g[MAXN];  // 定义记忆化数组\nint ans = 最坏情况, now;\n\nvoid dfs f(传入数值) {\n  if (g[规模] != 无效数值) return;  // 或记录解，视情况而定\n  if (到达目的地) ans = 从当前解与已有解中选最优;  // 输出解，视情况而定\n  for (遍历所有可能性)\n    if (可行) {\n      进行操作;\n      dfs(缩小规模);\n      撤回操作;\n    }\n}\n\nint main() {\n  // ...\n  memset(g, 无效数值, sizeof(g));  // 初始化记忆化数组\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating DFS and Low Numbers in Python\nDESCRIPTION: This function performs a depth-first search to calculate DFS numbers and low numbers for each node in the graph. It is the Python equivalent of the C++ implementation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/block-forest.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef Tarjan(u):\n    low[u] = dfn[u] = dfc  # low 初始化为当前节点 dfn\n    dfc = dfc + 1\n    for v in G[u]:  # 遍历 u 的相邻节点\n        if dfn[v] == False:  # 如果未访问过\n            Tarjan(v)  # 递归\n            low[u] = min(low[u], low[v])  # 未访问的和 low 取 min\n        else:\n            low[u] = min(low[u], dfn[v])  # 已访问的和 dfn 取 min\n```\n\n----------------------------------------\n\nTITLE: Function Using Pointer Parameters in C++\nDESCRIPTION: Defines a swap function that uses pointer parameters to exchange values between two integers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid my_swap(int *a, int *b) {\n  int t;\n  t = *a;\n  *a = *b;\n  *b = t;\n}\n\nint main() {\n  int a = 6, b = 10;\n  my_swap(&a, &b);\n  // After call, a = 10, b = 6\n}\n```\n\n----------------------------------------\n\nTITLE: CDQ Divide-and-Conquer Implementation for Non-Monotonic Cases\nDESCRIPTION: Using CDQ divide-and-conquer technique to handle cases where slope optimization cannot be directly applied due to lack of monotonicity in slope or decision points. This approach achieves O(n log² n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/slope.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n下面介绍一种基于 CDQ 分治的做法。\n\n设 $\\text{CDQ}(l,r)$ 代表计算 $f_i,i\\in [l,r]$。考虑 $\\text{CDQ}(1,n)$：\n\n-   我们先调用 $\\text{CDQ}(1,mid)$ 算出 $f_i,i\\in[1,mid]$。然后我们对 $[1,mid]$ 这个区间内的决策点建凸壳，然后使用这个凸壳去更新 $f_i,i\\in [mid+1,n]$。这时我们决策点集是固定的，不像之前那样边计算 DP 值边加入决策点，那么我们就可以把 $i \\in [mid+1,n]$ 的 $f_i$ 先按照直线的斜率 $k_i$ 排序，然后就可以使用单调队列来计算 DP 值了。当然，也可以在静态凸壳上二分计算 DP 值。\n\n-   对于 $[mid+1,n]$ 中的每个点，如果它的最优决策的位置是在 $[1,mid]$ 这个区间，在这一步操作中他就会被更新成最优答案。当执行完这一步操作时，我们发现 $[1,mid]$ 中的所有点已经发挥了全部的作用，凸壳中他们存不存在已经不影响之后的答案更新。因此我们可以直接舍弃这个区间的决策点，并使用 $\\text{CDQ}(mid+1,n)$ 解决右区间剩下的问题。\n\n时间复杂度 $O(n\\log^2 n)$。\n```\n\n----------------------------------------\n\nTITLE: Illustrating Post-increment Operator in C++ Loop\nDESCRIPTION: Demonstrates the use of the post-increment operator (i++) in a for loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 0; i < 10; i++) cout << i;\n```\n\n----------------------------------------\n\nTITLE: Comparing for Loops in Pascal and C++\nDESCRIPTION: Shows the syntax differences between Pascal and C++ for for loops, highlighting C++'s three-part loop initialization structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_6\n\nLANGUAGE: Pascal\nCODE:\n```\nvar i: integer;\n\nbegin\n    for i:= 1 to 10 do\n        begin\n            write(i, ' ');\n        end;\nend.\n```\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 1; i <= 10; i++) {\n  std::cout << i << \" \";\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boyer-Moore-Horspool Algorithm in Rust\nDESCRIPTION: A simplified version of Boyer-Moore that only uses the bad character rule. This implementation typically performs similarly to the original BM algorithm while being simpler to implement.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\npub struct HorspoolPattern<'a> {\n    pat_bytes: &'a [u8],\n    bm_bc: [usize; 256],\n}\n\nimpl<'a> HorspoolPattern<'a> {\n    pub fn find_all(&self, string: &str) -> Vec<usize> {\n        let mut result = vec![];\n        let string_bytes = string.as_bytes();\n        let stringlen = string_bytes.len();\n        let pat_last_pos = self.pat_bytes.len() - 1;\n        let mut string_index = pat_last_pos;\n\n        while string_index < stringlen {\n            if &string_bytes[string_index-pat_last_pos..string_index+1] == self.pat_bytes {\n                result.push(string_index-pat_last_pos);\n            }\n\n            string_index += self.bm_bc[string_bytes[string_index] as usize];\n        }\n\n        result\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Virtual Machine Platform for WSL2 in Windows\nDESCRIPTION: PowerShell command to enable the Virtual Machine Platform Windows feature required for upgrading to WSL2. Must be run as administrator and requires a system restart afterward.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Calculating Euler's Totient Function in C++ and Python\nDESCRIPTION: This implementation extends the Linear Sieve to calculate Euler's Totient Function (phi) for all numbers up to n. It uses the multiplicative properties of the function and handles cases based on whether a number is divisible by its smallest prime factor.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> pri;\nbool not_prime[N];\nint phi[N];\n\nvoid pre(int n) {\n  phi[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    if (!not_prime[i]) {\n      pri.push_back(i);\n      phi[i] = i - 1;\n    }\n    for (int pri_j : pri) {\n      if (i * pri_j > n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) {\n        phi[i * pri_j] = phi[i] * pri_j;\n        break;\n      }\n      phi[i * pri_j] = phi[i] * phi[pri_j];\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\npri = []\nnot_prime = [False] * N\nphi = [0] * N\n\n\ndef pre(n):\n    phi[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            phi[i] = i - 1\n        for pri_j in pri:\n            if i * pri_j > n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                phi[i * pri_j] = phi[i] * pri_j\n                break\n            phi[i * pri_j] = phi[i] * phi[pri_j]\n```\n\n----------------------------------------\n\nTITLE: Defining SAM State Structure in C++\nDESCRIPTION: Basic structure definition for a state in the Suffix Automaton, containing length, suffix link and transitions map.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sam.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct state {\n  int len, link;\n  std::map<char, int> next;\n};\n```\n\n----------------------------------------\n\nTITLE: Maximum Submatrix Calculator for Character Matrix\nDESCRIPTION: Implementation to find maximum area submatrix containing only 'F' characters. Uses hoverline method to track vertical extensions and calculate maximum possible rectangle areas.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/hoverline.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/misc/code/hoverline/hoverline_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Deleting a Node with One Child in Red-Black Tree (C++)\nDESCRIPTION: Handles deletion of a node with a single child in a red-black tree. Replaces the node with its child and ensures the replacement node is black to maintain tree properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nNodePtr parent = node->parent;\nNodePtr replacement = (node->left != nullptr ? node->left : node->right);\n\nswitch (node->direction()) {\n  case Direction::ROOT:\n    this->root = replacement;\n    break;\n  case Direction::LEFT:\n    parent->left = replacement;\n    break;\n  case Direction::RIGHT:\n    parent->right = replacement;\n    break;\n}\n\nif (!node->isRoot()) {\n  replacement->parent = parent;\n}\n\nnode->color = Node::BLACK;\n```\n\n----------------------------------------\n\nTITLE: Gap Finding Algorithm Implementation in C++\nDESCRIPTION: Solution to UOJ206 that finds maximum gap in a sequence through limited queries. Handles different test cases using binary search and interval-based approaches.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/interaction.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n\n#include \"gap.h\"\n\nlong long findGap(int T, int N) {\n  static long long a[100005] = {}, ans = 0;\n  long long s = 0, t = 1e18, s1, t1;\n  if (T == 1) {\n    int l = 1, r = N;\n    while (l <= r) {\n      MinMax(s, t, &s1, &t1);\n      a[l++] = s1, a[r--] = t1;\n      s = s1 + 1, t = t1 - 1;\n    }\n    for (int i = 2; i <= N; i++) ans = std::max(ans, a[i] - a[i - 1]);\n  } else if (T == 2) {\n    MinMax(s, t, &s1, &t1);\n    ans = (t1 - s1) / (N - 1);\n    long long l = s1 + 1, r = t1, last = s1;\n    for (long long i = l; i <= r;) {\n      MinMax(i, i + ans, &s1, &t1);\n      i += ans + 1;\n      if (s1 != -1) ans = std::max(ans, s1 - last), last = t1;\n    }\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Iterative Implementation of Euclidean Algorithm for GCD in Java\nDESCRIPTION: An iterative implementation of the Euclidean algorithm for finding the greatest common divisor in Java. This avoids recursion by using a while loop until b becomes zero.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_4\n\nLANGUAGE: Java\nCODE:\n```\npublic int gcd(int a, int b) {\n    while(b != 0) {\n        int tmp = a;\n        a = b;\n        b = tmp % b;\n    }\n    return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of Ring Homomorphism\nDESCRIPTION: A formal definition of a homomorphism between rings, which is a mapping that preserves both addition and multiplication operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"环同态\"\n    对于环 $(R,+,\\cdot)$ 和 $(S,\\oplus,\\odot)$，如果 $\\pi$ 保持环的加法和乘法运算，即对所有 $r_1,r_2\\in R$ 都成立 $\\pi(r_1+r_2)=\\pi(r_1)\\oplus\\pi(r_2)$ 和 $\\pi(r_1\\cdot r_2)=\\pi(r_1)\\odot\\pi(r_2)$，则称映射 $\\pi:R\\rightarrow S$ 是自环 $R$ 到环 $S$ 的 **同态**（homomorphism）。\n```\n\n----------------------------------------\n\nTITLE: Template Hash Map Implementation in C++\nDESCRIPTION: Compact C++ hash map template that provides map-like functionality with forward star structure for collision handling.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/hash.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct hash_map {  // 哈希表模板\n\n  struct data {\n    long long u;\n    int v, nex;\n  };  // 前向星结构\n\n  data e[SZ << 1];  // SZ 是 const int 表示大小\n  int h[SZ], cnt;\n\n  int hash(long long u) { return (u % SZ + SZ) % SZ; }\n\n  int& operator[](long long u) {\n    int hu = hash(u);  // 获取头指针\n    for (int i = h[hu]; i; i = e[i].nex)\n      if (e[i].u == u) return e[i].v;\n    return e[++cnt] = data{u, -1, h[hu]}, h[hu] = cnt, e[cnt].v;\n  }\n\n  hash_map() {\n    cnt = 0;\n    memset(h, 0, sizeof(h));\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum and Maximum Values in BST in C++\nDESCRIPTION: Functions to find the minimum and maximum values in a Binary Search Tree by traversing left and right chains respectively. The time complexity is O(h) where h is the height of the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bst.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint findMin(TreeNode* root) {\n  if (root == nullptr) {\n    return -1;\n  }\n  while (root->left != nullptr) {\n    root = root->left;\n  }\n  return root->key;\n}\n\nint findMax(TreeNode* root) {\n  if (root == nullptr) {\n    return -1;\n  }\n  while (root->right != nullptr) {\n    root = root->right;\n  }\n  return root->key;\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Defining __gnu_pbds::tree Container in C++\nDESCRIPTION: Basic template definition for the __gnu_pbds::tree container with its required header files and namespace. This container provides a tree-based ordered data structure with extended functionality compared to standard containers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/tree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <ext/pb_ds/assoc_container.hpp>  // 因为 tree 定义在这里 所以需要包含这个头文件\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n__gnu_pbds::tree<Key, Mapped, Cmp_Fn = std::less<Key>, Tag = rb_tree_tag,\n                 Node_Update = null_tree_node_update,\n                 Allocator = std::allocator<char>>\n```\n\n----------------------------------------\n\nTITLE: Solving Watching Fireworks Problem with Monotonic Queue in C++\nDESCRIPTION: Solution to CF372C Watching Fireworks is Fun problem using monotonic queue optimization. The code efficiently computes the maximum happiness by maintaining a monotonic queue of previous states, reducing the time complexity to O(nm).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/monotonous-queue-stack.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/opt/monotonous-queue-stack/monotonous-queue-stack_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Stein Algorithm for GCD of Large Numbers in C++\nDESCRIPTION: Implementation of the Stein algorithm (binary GCD) for finding the greatest common divisor of large numbers efficiently in C++. This algorithm uses bitwise operations instead of modulo for better performance with large integers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nBig gcd(Big a, Big b) {\n  if (a == 0) return b;\n  if (b == 0) return a;\n  // 记录a和b的公因数2出现次数，countr_zero表示二进制末位0的个数\n  int atimes = countr_zero(a);\n  int btimes = countr_zero(b);\n  int mintimes = min(atimes, btimes);\n  a >>= atimes;\n  for (;;) {\n    // a和b公因数中的2已经计算过了，后面不可能出现a为偶数的情况\n    b >>= btimes;\n    // 确保 a<=b\n    if (a > b) swap(a, b);\n    b -= a;\n    if (b == 0) break;\n    btimes = countr_zero(b);\n  }\n  return a << mintimes;\n}\n```\n\n----------------------------------------\n\nTITLE: AC Automaton Template 1 for Simple Pattern Matching\nDESCRIPTION: Basic AC automaton implementation for Luogu P3808 problem, which handles simple pattern matching scenarios.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/ac-automaton/ac-automaton_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Transition Function for KMP Automaton in Mathematical Notation\nDESCRIPTION: This snippet defines the transition function for a KMP (Knuth-Morris-Pratt) automaton. It specifies how the automaton transitions between states based on the input character and current state.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/automaton.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n$$\n\\delta(i, c)=\n\\begin{cases}\ni+1&s[i+1]=c\\\\\n0&s[1]\\ne c\\land i=0\\\\\n\\delta(\\pi(i),c)&s[i+1]\\ne c\\land i>0\n\\end{cases}\n$$\n```\n\n----------------------------------------\n\nTITLE: Implementing Insertion Sort in C++\nDESCRIPTION: Basic implementation of insertion sort algorithm in C++. The algorithm iterates through an array, moving each element to its correct position in the sorted portion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/insertion-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid insertion_sort(int arr[], int len) {\n  if (len < 2) return;\n  for (int i = 1; i != len; ++i) {\n    int key = arr[i];\n    auto index = upper_bound(arr, arr + i, key) - arr;\n    // 使用 memmove 移动元素，比使用 for 循环速度更快，时间复杂度仍为 O(n)\n    memmove(arr + index + 1, arr + index, (i - index) * sizeof(int));\n    arr[index] = key;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Arrays.sort() Method in Java\nDESCRIPTION: Demonstrates different overloads of the Arrays.sort() method for sorting arrays. Shows examples of sorting entire arrays, specific ranges, and using custom comparators with both traditional syntax and Lambda expressions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_22\n\nLANGUAGE: java\nCODE:\n```\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n    static int[] a = new int[10];\n    static Integer[] b = new Integer[10];\n    static int firstIdx, lastIdx;\n\n    public static void main(String[] args) {\n        Arrays.sort(a);  // 1 \n        Arrays.sort(a, firstIdx, lastIdx);  // 2 \n        Arrays.sort(b, new Comparator<Integer>() {  // 3 \n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n        Arrays.sort(b, firstIdx, lastIdx, new Comparator<Integer>() {  // 4 \n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2 - o1;\n            }\n        });\n        // 由于 Java 8 后有 Lambda 表达式，第三个重载及第四个重载亦可写为 \n        Arrays.sort(b, (x, y) -> {  // 5 \n            return y - x;\n        });\n        Arrays.sort(b, (x, y) -> {  // 6 \n            return y - x;\n        });\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Discretization Using std::pair\nDESCRIPTION: Implementation of discretization algorithm using pair to maintain original values and their positions during sorting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// a为原始数据\npair<int, int> a[MAXN];\n// ai为离散化后的数据\nint ai[MAXN];\nfor (int i = 0; i < n; i++) {\n  // first为原始数据的值，second为原始数据的位置\n  scanf(\"%d\", &a[i].first);\n  a[i].second = i;\n}\n// 排序\nsort(a, a + n);\nfor (int i = 0; i < n; i++) {\n  // 将该值的排名赋给该值原本所在的位置\n  ai[a[i].second] = i;\n}\n```\n\n----------------------------------------\n\nTITLE: Rebalancing Case 4 After Deletion in Red-Black Tree (C++)\nDESCRIPTION: Handles rebalancing when the sibling is black, close nephew is red, and distant nephew is black after deletion in a red-black tree. Performs rotations and recoloring to transition to Case 5.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\n// Step 1\nrotateOppositeDirection(sibling, direction);\n// Step 2\ncloseNephew->color = Node::BLACK;\nsibling->color = Node::RED;\n// Update sibling and nephews after rotation\nsibling = node->sibling();\ncloseNephew = direction == Direction::LEFT ? sibling->left : sibling->right;\ndistantNephew = direction == Direction::LEFT ? sibling->right : sibling->left;\n// Step 3: vvv\n```\n\n----------------------------------------\n\nTITLE: Counting Bracket Sequences on Trees (HDU 6647) in C++\nDESCRIPTION: This code solves HDU 6647 by using tree hashing and dynamic programming to count distinct bracket sequences generated by traversing an unrooted tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-hash.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/tree-hash/tree-hash_4.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Reading Input into an Array in C++\nDESCRIPTION: This code demonstrates how to read a variable number of integers from standard input and store them in an array. It uses a for loop to iterate through array indices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/array.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\nusing namespace std;\n\nint arr[1001];  // 数组 arr 的下标范围是 [0, 1001)\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> arr[i];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving 2-SAT Party Problem using Tarjan's SCC in C++\nDESCRIPTION: Implementation of Tarjan's Strongly Connected Components algorithm to solve a 2-SAT problem involving party invitations and conflicts between guests.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/2-sat.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/2-sat/2-sat_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Basic Const Variable Declaration in C++\nDESCRIPTION: Demonstrates the basic usage of const to create immutable variables in C++.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst int a = 0;  // a 的类型为 const int\n\n// a = 1; // 不能修改常量\n```\n\n----------------------------------------\n\nTITLE: Solving LCM Sum Problem using Number Theory in C++\nDESCRIPTION: Implementation for the SPOJ 5971 LCMSUM problem, which calculates the sum of LCM values using number theory properties and a multiplicative function approach with linear sieve.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/mobius/mobius_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Working with Rvalue References in C++\nDESCRIPTION: This snippet demonstrates rvalue references (T&&) in C++, which bind to rvalues. It shows how rvalue references can be used to extend the lifetime of temporary objects and how they can be modified.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n  string s1 = \"Test\";\n  // string&& r1 = s1; // 错误：不能绑定到左值，需要 std::move 或者 static_cast\n\n  const string& r2 = s1 + s1;  // 可行：到常量的左值引用延长生存期\n  // r2 += \"Test\"; // 错误：不能通过到常量的引用修改\n  cout << r2 << '\\n';\n\n  string&& r3 = s1 + s1;  // 可行：右值引用延长生存期\n  r3 += \"Test\";\n  cout << r3 << '\\n';\n\n  const string& r4 = r3;  // 右值引用可以转换到 const 限定的左值\n  cout << r4 << '\\n';\n\n  string& r5 = r3;  // 右值引用可以转换到左值\n  cout << r5 << '\\n';\n}\n```\n\n----------------------------------------\n\nTITLE: Prefix Occurrence Counter Implementation\nDESCRIPTION: Code to count occurrences of prefixes in a string using prefix function values. Implements a dynamic counting approach that uses the prefix array to track occurrences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> ans(n + 1);\nfor (int i = 0; i < n; i++) ans[pi[i]]++;\nfor (int i = n - 1; i > 0; i--) ans[pi[i - 1]] += ans[i];\nfor (int i = 0; i <= n; i++) ans[i]++;\n```\n\nLANGUAGE: Python\nCODE:\n```\nans = [0] * (n + 1)\nfor i in range(0, n):\n    ans[pi[i]] += 1\nfor i in range(n - 1, 0, -1):\n    ans[pi[i - 1]] += ans[i]\nfor i in range(0, n + 1):\n    ans[i] += 1\n```\n\n----------------------------------------\n\nTITLE: DAG Path Checker - Optimized Implementation\nDESCRIPTION: An improved implementation using a readAns function to avoid code duplication and properly validate both jury and contestant answers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/testlib/checker.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testlib.h\"\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<pair<int, int>, int> edges;\nint n, m, s, t;\n\nint readAns(InStream& stream) {\n  int value = 0;\n  vector<int> path;\n  vector<bool> used(n);\n  int len = stream.readInt(2, n, \"number of vertices\");\n  for (int i = 0; i < len; i++) {\n    int v = stream.readInt(1, n, format(\"path[%d]\", i + 1).c_str());\n    if (used[v - 1]) {\n      stream.quitf(_wa, \"vertex %d was used twice\", v);\n    }\n    used[v - 1] = true;\n    path.push_back(v);\n  }\n  if (path.front() != s)\n    stream.quitf(_wa, \"path doesn't start in s: expected s = %d, found %d\", s, path.front());\n  if (path.back() != t)\n    stream.quitf(_wa, \"path doesn't finish in t: expected t = %d, found %d\", t, path.back());\n  for (int i = 0; i < len - 1; i++) {\n    if (edges.find(make_pair(path[i], path[i + 1])) == edges.end())\n      stream.quitf(_wa, \"there is no edge (%d, %d) in the graph\", path[i], path[i + 1]);\n    value += edges[make_pair(path[i], path[i + 1])];\n  }\n  return value;\n}\n\nint main(int argc, char* argv[]) {\n  registerTestlibCmd(argc, argv);\n  n = inf.readInt();\n  m = inf.readInt();\n  for (int i = 0; i < m; i++) {\n    int a = inf.readInt();\n    int b = inf.readInt();\n    int w = inf.readInt();\n    edges[make_pair(a, b)] = edges[make_pair(b, a)] = w;\n  }\n  int s = inf.readInt();\n  int t = inf.readInt();\n\n  int jans = readAns(ans);\n  int pans = readAns(ouf);\n  if (jans > pans)\n    quitf(_wa, \"jury has the better answer: jans = %d, pans = %d\\n\", jans, pans);\n  else if (jans == pans)\n    quitf(_ok, \"answer = %d\\n\", pans);\n  else\n    quitf(_fail, \":(participant has the better answer: jans = %d, pans = %d\\n\", jans, pans);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Set Class with Left-leaning Red-Black Tree in C++\nDESCRIPTION: This code snippet defines a Set class using a left-leaning red-black tree implementation. It includes methods for inserting, deleting, and searching elements, as well as utility functions for tree manipulation and traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/llrbt.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <memory>\n#include <vector>\n\ntemplate <class Key, class Compare = std::less<Key>>\nclass Set {\n private:\n  enum NodeColor { kBlack = 0, kRed = 1 };\n\n  struct Node {\n    Key key;\n    Node *lc{nullptr}, *rc{nullptr};\n    size_t size{0};\n    NodeColor color;  // the color of the parent link\n\n    Node(Key key, NodeColor color, size_t size)\n        : key(key), color(color), size(size) {}\n\n    Node() = default;\n  };\n\n  void destroyTree(Node *root) const {\n    if (root != nullptr) {\n      destroyTree(root->lc);\n      destroyTree(root->rc);\n      root->lc = root->rc = nullptr;\n      delete root;\n    }\n  }\n\n  bool is_red(const Node *nd) const {\n    return nd == nullptr ? false : nd->color;  // kRed == 1, kBlack == 0\n  }\n\n  size_t size(const Node *nd) const { return nd == nullptr ? 0 : nd->size; }\n\n  Node *rotate_left(Node *node) const {\n    // left rotate a red link\n    //          <1>                   <2>\n    //        /    \\               //    \\\n    //       *      <2>    ==>     <1>     *\n    //             /   \\          /   \\\n    //            *     *        *     *\n    Node *res = node->rc;\n    node->rc = res->lc;\n    res->lc = node;\n    res->color = node->color;\n    node->color = kRed;\n    res->size = node->size;\n    node->size = size(node->lc) + size(node->rc) + 1;\n    return res;\n  }\n\n  Node *rotate_right(Node *node) const {\n    // right rotate a red link\n    //            <1>               <2>\n    //          //    \\           /    \\\\\n    //         <2>     *   ==>   *      <1>\n    //        /   \\                    /   \\\n    //       *     *                  *     *\n    Node *res = node->lc;\n    node->lc = res->rc;\n    res->rc = node;\n    res->color = node->color;\n    node->color = kRed;\n    res->size = node->size;\n    node->size = size(node->lc) + size(node->rc) + 1;\n    return res;\n  }\n\n  NodeColor neg_color(NodeColor n) const { return n == kBlack ? kRed : kBlack; }\n\n  void color_flip(Node *node) const {\n    node->color = neg_color(node->color);\n    node->lc->color = neg_color(node->lc->color);\n    node->rc->color = neg_color(node->rc->color);\n  }\n\n  Node *insert(Node *root, const Key &key) const;\n  Node *delete_arbitrary(Node *root, Key key) const;\n  Node *delete_min(Node *root) const;\n  Node *move_red_right(Node *root) const;\n  Node *move_red_left(Node *root) const;\n  Node *fix_up(Node *root) const;\n  const Key &get_min(Node *root) const;\n  void serialize(Node *root, std::vector<Key> *) const;\n  void print_tree(Set::Node *root, int indent) const;\n  Compare cmp_ = Compare();\n  Node *root_{nullptr};\n\n public:\n  using KeyType = Key;\n  using ValueType = Key;\n  using SizeType = std::size_t;\n  using DifferenceType = std::ptrdiff_t;\n  using KeyCompare = Compare;\n  using ValueCompare = Compare;\n  using Reference = Key &;\n  using ConstReference = const Key &;\n\n  Set() = default;\n\n  Set(Set &) = default;\n\n  Set(Set &&) noexcept = default;\n\n  ~Set() { destroyTree(root_); }\n\n  SizeType size() const;\n\n  SizeType count(const KeyType &key) const;\n\n  SizeType erase(const KeyType &key);\n\n  void clear();\n\n  void insert(const KeyType &key);\n\n  bool empty() const;\n\n  std::vector<Key> serialize() const;\n\n  void print_tree() const;\n};\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::SizeType Set<Key, Compare>::count(\n    ConstReference key) const {\n  Node *x = root_;\n  while (x != nullptr) {\n    if (key == x->key) return 1;\n    if (cmp_(key, x->key))  // if (key < x->key)\n      x = x->lc;\n    else\n      x = x->rc;\n  }\n  return 0;\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::SizeType Set<Key, Compare>::erase(\n    const KeyType &key) {\n  if (count(key) > 0) {\n    if (!is_red(root_->lc) && !(is_red(root_->rc))) root_->color = kRed;\n    root_ = delete_arbitrary(root_, key);\n    if (root_ != nullptr) root_->color = kBlack;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\ntemplate <class Key, class Compare>\nvoid Set<Key, Compare>::clear() {\n  destroyTree(root_);\n  root_ = nullptr;\n}\n\ntemplate <class Key, class Compare>\nvoid Set<Key, Compare>::insert(const KeyType &key) {\n  root_ = insert(root_, key);\n  root_->color = kBlack;\n}\n\ntemplate <class Key, class Compare>\nbool Set<Key, Compare>::empty() const {\n  return size(root_) == 0;\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::insert(\n    Set::Node *root, const Key &key) const {\n  if (root == nullptr) return new Node(key, kRed, 1);\n  if (root->key == key)\n    ;\n  else if (cmp_(key, root->key))  // if (key < root->key)\n    root->lc = insert(root->lc, key);\n  else\n    root->rc = insert(root->rc, key);\n  return fix_up(root);\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::delete_min(\n    Set::Node *root) const {\n  if (root->lc == nullptr) {\n    delete root;\n    return nullptr;\n  }\n  if (!is_red(root->lc) && !is_red(root->lc->lc)) {\n    // make sure either root->lc or root->lc->lc is red\n    // thus make sure we will delete a red node in the end\n    root = move_red_left(root);\n  }\n  root->lc = delete_min(root->lc);\n  return fix_up(root);\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::move_red_right(\n    Set::Node *root) const {\n  color_flip(root);\n  if (is_red(root->lc->lc)) {  // assume that root->lc != nullptr when calling\n                               // this function\n    root = rotate_right(root);\n    color_flip(root);\n  }\n  return root;\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::move_red_left(\n    Set::Node *root) const {\n  color_flip(root);\n  if (is_red(root->rc->lc)) {\n    // assume that root->rc != nullptr when calling this function\n    root->rc = rotate_right(root->rc);\n    root = rotate_left(root);\n    color_flip(root);\n  }\n  return root;\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::fix_up(\n    Set::Node *root) const {\n  if (is_red(root->rc) && !is_red(root->lc))  // fix right leaned red link\n    root = rotate_left(root);\n  if (is_red(root->lc) &&\n      is_red(root->lc->lc))  // fix doubly linked left leaned red link\n    // if (root->lc == nullptr), then the second expr won't be evaluated\n    root = rotate_right(root);\n  if (is_red(root->lc) && is_red(root->rc))\n    // break up 4 node\n    color_flip(root);\n  root->size = size(root->lc) + size(root->rc) + 1;\n  return root;\n}\n\ntemplate <class Key, class Compare>\nconst Key &Set<Key, Compare>::get_min(Set::Node *root) const {\n  Node *x = root;\n  // will crash as intended when root == nullptr\n  for (; x->lc != nullptr; x = x->lc);\n  return x->key;\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::SizeType Set<Key, Compare>::size() const {\n  return size(root_);\n}\n\ntemplate <class Key, class Compare>\ntypename Set<Key, Compare>::Node *Set<Key, Compare>::delete_arbitrary(\n    Set::Node *root, Key key) const {\n  if (cmp_(key, root->key)) {\n    // key < root->key\n    if (!is_red(root->lc) && !(is_red(root->lc->lc)))\n      root = move_red_left(root);\n    // ensure the invariant: either root->lc or root->lc->lc (or root and\n    // root->lc after dive into the function) is red, to ensure we will\n    // eventually delete a red node. therefore we will not break the black\n    // height balance\n    root->lc = delete_arbitrary(root->lc, key);\n  } else {\n    // key >= root->key\n    if (is_red(root->lc)) root = rotate_right(root);\n    if (key == root->key && root->rc == nullptr) {\n      delete root;\n      return nullptr;\n    }\n    if (!is_red(root->rc) && !is_red(root->rc->lc)) root = move_red_right(root);\n    if (key == root->key) {\n      root->key = get_min(root->rc);\n      root->rc = delete_min(root->rc);\n    } else {\n      root->rc = delete_arbitrary(root->rc, key);\n    }\n  }\n  return fix_up(root);\n}\n\ntemplate <class Key, class Compare>\nstd::vector<Key> Set<Key, Compare>::serialize() const {\n  std::vector<int> v;\n  serialize(root_, &v);\n  return v;\n}\n\ntemplate <class Key, class Compare>\nvoid Set<Key, Compare>::serialize(Set::Node *root,\n                                  std::vector<Key> *res) const {\n  if (root == nullptr) return;\n  serialize(root->lc, res);\n  res->push_back(root->key);\n  serialize(root->rc, res);\n}\n\ntemplate <class Key, class Compare>\nvoid Set<Key, Compare>::print_tree(Set::Node *root, int indent) const {\n  if (root == nullptr) return;\n  print_tree(root->lc, indent + 4);\n  std::cout << std::string(indent, '-') << root->key << std::endl;\n  print_tree(root->rc, indent + 4);\n}\n\ntemplate <class Key, class Compare>\nvoid Set<Key, Compare>::print_tree() const {\n  print_tree(root_, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Emacs Configuration Setup\nDESCRIPTION: Essential Emacs configuration including compilation shortcuts, key bindings, and code style settings. Sets up basic editing features like undo, compile, and debugging shortcuts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/emacs.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n;;设置一键编译 可以自行添加参数 难背考场不建议使用 不建议依赖一键编译\n(defun compile-file ()(interactive)(compile (format \"g++ -o %s %s -g -lm -Wall\" (file-name-sans-extension (buffer-name))(buffer-name))))\n(global-set-key [f9] 'compile-file)\n;;;;设置编译快捷键（如果设置了一键编译不要与一键编译冲突）\n;;(global-set-key [f9] 'compile)\n\n(global-set-key (kbd \"C-a\") 'mark-whole-buffer) ;;全选快捷键\n(global-set-key (kbd \"C-z\") 'undo) ;;撤销快捷键\n(global-set-key [f10] 'gud-gdb) ;;GDB调试快捷键\n(global-set-key (kbd \"RET\") 'newline-and-indent) ;;换行自动缩进\n(global-set-key (kbd \"C-s\") 'save-buffer) ;;设置保存快捷键\n(setq-default kill-ring-max 65535) ;;扩大可撤销记录\n\n;;C++ 代码风格 一般控制缩进规则\n;;\"bsd\" 所有大括号换行\n;;\"java\" 所有大括号不换行。else 接在右大括号后面\n;;\"awk\" 只有命名空间旁、定义类、定义函数时的大括号换行。else 接在右大括号后面\n;;\"linux\" 只有命名空间旁、定义类、定义函数时的大括号换行。else 接在右大括号后面。一般来说，这个风格应该有 8 格的空格缩进\n(setq-default c-default-style \"awk\")\n```\n\n----------------------------------------\n\nTITLE: Digit Counting Implementation in C++\nDESCRIPTION: Solution for counting the frequency of each digit in numbers between range [a,b] using dynamic programming. Uses an array dp to store counts for filled positions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/number.md#2025-04-22_snippet_0\n\nLANGUAGE: c++\nCODE:\n```\n#include <cstdio>\nusing namespace std;\nconstexpr int N = 15;\nusing ll = long long;\nll l, r, dp[N], mi[N];\nll ans1[N], ans2[N];\nint a[N];\n\nvoid solve(ll n, ll *ans) {\n  ll tmp = n;\n  int len = 0;\n  while (n) a[++len] = n % 10, n /= 10;\n  for (int i = len; i >= 1; --i) {\n    for (int j = 0; j < 10; j++) ans[j] += dp[i - 1] * a[i];\n    for (int j = 0; j < a[i]; j++) ans[j] += mi[i - 1];\n    tmp -= mi[i - 1] * a[i], ans[a[i]] += tmp + 1;\n    ans[0] -= mi[i - 1];\n  }\n}\n\nint main() {\n  scanf(\"%lld%lld\", &l, &r);\n  mi[0] = 1ll;\n  for (int i = 1; i <= 13; ++i) {\n    dp[i] = dp[i - 1] * 10 + mi[i - 1];\n    mi[i] = 10ll * mi[i - 1];\n  }\n  solve(r, ans1), solve(l - 1, ans2);\n  for (int i = 0; i < 10; ++i) printf(\"%lld \", ans1[i] - ans2[i]);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying PQa Algorithm Results for x^2 - 14y^2 = 1 in Markdown\nDESCRIPTION: A Markdown table showing the step-by-step results of applying the PQa algorithm to solve the Pell equation x^2 - 14y^2 = 1, including intermediate values and the final solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n| $k$ | $P$ | $Q$ | $a$            | $A$ | $B$ | $G$ | $G^2-DB^2$ |\n|:---:|:---:|:---:|:--------------:|:---:|:---:|:---:|:----------:|\n| $0$ | $0$ | $1$ | $3$            | $3$ | $1$ | $3$ | $-5$       |\n| $1$ | $3$ | $5$ |$\\color{red}{1}$| $4$ | $1$ | $4$ | $2$        |\n| $2$ | $2$ | $2$ |$\\color{red}{2}$| $11$| $3$ | $11$| $-5$       |\n| $3$ | $2$ | $5$ |$\\color{red}{1}$| $15$| $4$ | $15$| $1$        |\n| $4$ | $3$ | $1$ |$\\color{red}{6}$|$101$| $27$|$101$| $-5$       |\n| $5$ | $3$ | $5$ | $1$            |$116$| $31$|$116$| $2$        |\n```\n\n----------------------------------------\n\nTITLE: Polynomial Translation Using Divide and Conquer\nDESCRIPTION: Implementation of polynomial translation using a divide and conquer approach, splitting the polynomial into two parts and combining results with binomial coefficients. Achieves O(n log^2 n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/shift.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\nf(x)=f_0(x)+x^{\\left\\lfloor n/2\\right\\rfloor}f_1(x)\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Möbius Function in Python\nDESCRIPTION: Python implementation of a linear sieve algorithm to calculate the Möbius function values up to n. This multiplicative function is key for solving number theory problems involving divisibility.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef getMu():\nmu[1] = 1\nfor i in range(2, n + 1):\n    if flg[i] != 0:\n        p[tot] = i; tot = tot + 1; mu[i] = -1\n    j = 1\n    while j <= tot and i * p[j] <= n:\n        flg[i * p[j]] = 1\n        if i % p[j] == 0:\n            mu[i * p[j]] = 0\n            break\n        mu[i * p[j]] = mu[i * p[j]] - mu[i]\n        j = j + 1\n```\n\n----------------------------------------\n\nTITLE: Defining Double Linked List Node in C++ and Python\nDESCRIPTION: Defines the structure for a node in a double linked list, containing a value and pointers to the left and right nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct Node {\n  int value;\n  Node *left;\n  Node *right;\n};\n```\n\nLANGUAGE: Python\nCODE:\n```\nclass Node:\n    def __init__(self, value=None, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right\n```\n\n----------------------------------------\n\nTITLE: Solving Egyptian Fractions using IDA* in C++\nDESCRIPTION: Implementation of IDA* algorithm to solve the Egyptian Fractions problem, where rational numbers are expressed as sums of distinct unit fractions. The code demonstrates practical usage of IDA* with optimistic heuristic estimation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/idastar.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/search/code/idastar/idastar_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Splitting Treap by Rank (C++)\nDESCRIPTION: This function splits a treap into three parts based on a given rank. It returns three treaps where the first contains nodes with ranks less than the given rank, the second contains a single node with the given rank, and the third contains nodes with ranks greater than the given rank.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\ntuple<Node *, Node *, Node *> split_by_rk(Node *cur, int rk) {\n  if (cur == nullptr) return {nullptr, nullptr, nullptr};\n  int ls_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n  if (rk <= ls_siz) {\n    // 排名和 cur 相等的节点在左子树\n    Node *l, *mid, *r;\n    tie(l, mid, r) = split_by_rk(cur->ch[0], rk);\n    cur->ch[0] = r;  // 返回的第三个 treap 中的排名都大于 rk\n    // cur 的左子树被设成 r 后，整个 cur 中节点的排名都大于 rk\n    cur->upd_siz();\n    return {l, mid, cur};\n  } else if (rk <= ls_siz + cur->cnt) {\n    // 和 cur 相等的就是当前节点\n    Node *lt = cur->ch[0];\n    Node *rt = cur->ch[1];\n    cur->ch[0] = cur->ch[1] = nullptr;\n    // 分裂后第二个 treap 只有一个节点，所有要把它的子树设置为空\n    return {lt, cur, rt};\n  } else {\n    // 排名和 cur 相等的节点在右子树\n    // 递归过程同上\n    Node *l, *mid, *r;\n    tie(l, mid, r) = split_by_rk(cur->ch[1], rk - ls_siz - cur->cnt);\n    cur->ch[1] = l;\n    cur->upd_siz();\n    return {cur, mid, r};\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Encoding State for Grid Coloring Problem in C++\nDESCRIPTION: Implements state encoding for a grid coloring problem. Uses bit manipulation to store color and connectivity information for each position on the grid outline. Includes functions to encode and decode the state.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int Offset = 5, Mask = (1 << Offset) - 1;\nint c[N + 2];\nint b[N + 2], bb[N + 3];\n\nT_state encode() {\n  T_state s = 0;\n  memset(bb, -1, sizeof(bb));\n  int bn = 1;\n  bb[0] = 0;\n  for (int i = m; i >= 0; --i) {\n#define bi bb[b[i]]\n    if (!~bi) bi = bn++;\n    s <<= Offset;\n    s |= (bi << 1) | c[i];\n  }\n  return s;\n}\n\nvoid decode(T_state s) {\n  REP(i, m + 1) {\n    b[i] = s & Mask;\n    c[i] = b[i] & 1;\n    b[i] >>= 1;\n    s >>= Offset;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Labeled Bipartite Graph Counts using Connected Bipartite Graphs in C++\nDESCRIPTION: This code snippet computes the number of labeled bipartite graphs by first calculating connected 2-colorable graphs, then transforming to connected bipartite graphs, and finally to general bipartite graphs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i = 1; i <= n; ++i) {\n  G[i] = 0;\n  for (int j = 0; j < i + 1; ++j) G[i] += binom[i][j] * pow(2, j * (i - j));\n}\nln(B1, G);\nfor (int i = 1; i <= n; ++i) B1[i] /= 2;\nexp(B, B1);\n```\n\n----------------------------------------\n\nTITLE: Factorial Modulo Prime Implementation in C++\nDESCRIPTION: Implementation of a function to calculate n! mod p where p is a prime number. Uses preprocessing to store smaller factorials modulo p for efficiency. Time complexity is O(p + log_p n) with preprocessing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/factorial.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvector<int> fac;\nint calcFactModP(int n, int p) {\n    fac.resize(p);\n    fac[0] = 1;\n    for (int i = 1; i < p; ++i) {\n        fac[i] = 1LL * fac[i - 1] * i % p;\n    }\n    \n    if (n < p) return fac[n];\n    \n    int ans = 1;\n    while (n > 0) {\n        if ((n / p) & 1) ans = p - ans;\n        ans = 1LL * ans * fac[n % p] % p;\n        n /= p;\n    }\n    return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Overall Binary Search Implementation in C++\nDESCRIPTION: Implementation of the overall binary search algorithm to construct a monotonic sequence. The function takes a range [l,r] and value range [ql,qr] as parameters, recursively divides the sequence, and determines optimal values to minimize the total number of operations needed for transformation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/parallel-binsearch.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint a[500005], ans[500005];  // a:原序列 ans:构造的序列\n\nvoid overall_binary(int l, int r, int ql, int qr) {\n  if (l > r) return;\n  if (ql == qr) {\n    for (int i = l; i <= r; i++) ans[i] = ql;\n    return;\n  }\n  int cnt = 0,\n      mid = ql + ((qr - ql) >> 1);  // 默认开始都填 mid+1 全部划分到右区间\n  long long res = 0ll, sum = 0ll;\n  for (int i = l; i <= r; i++) sum += abs(a[i] - (mid + 1));\n  res = sum;\n  for (int i = l; i <= r;\n       i++) {  // 尝试把 [l,i] 从 mid+1 换成 mid 并且划分到左区间\n    sum -= abs(a[i] - (mid + 1));\n    sum += abs(a[i] - mid);\n    if (sum < res) cnt = i - l + 1, res = sum;  // 发现 [l,i] 取 mid 更优,更新\n  }\n  overall_binary(l, l + cnt - 1, ql, mid);\n  overall_binary(l + cnt, r, mid + 1, qr);\n}\n```\n\n----------------------------------------\n\nTITLE: Query Implementation in AC Automaton with DP\nDESCRIPTION: Basic query function that traverses the AC automaton and uses dynamic programming to find matches. It follows fail pointers to check all possible matches at each position in the input string.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nint query(const char t[]) {\n  int u = 0, len = strlen(t + 1);\n  for (int i = 1; i <= len; i++) dp[i] = 0;\n  for (int i = 1; i <= len; i++) {\n    u = tr[u].son[t[i] - 'a'];\n    for (int j = u; j; j = tr[j].fail) {\n      if (tr[j].idx && (dp[i - tr[j].depth] || i - tr[j].depth == 0)) {\n        dp[i] = dp[i - tr[j].depth] + tr[j].depth;\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= len; i++) ans = std::max(ans, dp[i]);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Node Location with Lazy Propagation in Splay Tree using C++\nDESCRIPTION: This function locates a node by rank in a Splay tree while handling lazy propagation. It pushes down lazy tags as it traverses the tree to ensure correct node information.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/splay.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/splay/splay-2.cpp:45:56\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized DFS for Herb Collection Problem in C++\nDESCRIPTION: An optimized DFS implementation using memoization to avoid recalculating states. This reduces the time complexity to O(TM) by storing and reusing previously calculated results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint n, t;\nint tcost[103], mget[103];\nint mem[103][1003];\n\nint dfs(int pos, int tleft) {\n  if (mem[pos][tleft] != -1)\n    return mem[pos][tleft];  // 已经访问过的状态，直接返回之前记录的值\n  if (pos == n + 1) return mem[pos][tleft] = 0;\n  int dfs1, dfs2 = -INF;\n  dfs1 = dfs(pos + 1, tleft);\n  if (tleft >= tcost[pos])\n    dfs2 = dfs(pos + 1, tleft - tcost[pos]) + mget[pos];  // 状态转移\n  return mem[pos][tleft] = max(dfs1, dfs2);  // 最后将当前状态的值存下来\n}\n\nint main() {\n  memset(mem, -1, sizeof(mem));\n  cin >> t >> n;\n  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];\n  cout << dfs(1, t) << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing Suffix Tree via Suffix Automaton in C++\nDESCRIPTION: This code implements a suffix automaton to build a suffix tree that supports adding characters to the front of the string. It uses a struct SuffixAutomaton to represent the automaton and provides an extend method to add new characters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct SuffixAutomaton {\n  int tot, lst;\n  int siz[N << 1];\n  int buc[N], id[N << 1];\n\n  struct Node {\n    int len, link;\n    int ch[26];\n  } st[N << 1];\n\n  SuffixAutomaton() : tot(1), lst(1) {}\n\n  void extend(int ch) {\n    int cur = ++tot, p = lst;\n    lst = cur;\n    siz[cur] = 1, st[cur].len = st[p].len + 1;\n    for (; p && !st[p].ch[ch]; p = st[p].link) st[p].ch[ch] = cur;\n    if (!p)\n      st[cur].link = 1;\n    else {\n      int q = st[p].ch[ch];\n      if (st[q].len == st[p].len + 1)\n        st[cur].link = q;\n      else {\n        int pp = ++tot;\n        st[pp] = st[q];\n        st[pp].len = st[p].len + 1;\n        st[cur].link = st[q].link = pp;\n        for (; p && st[p].ch[ch] == q; p = st[p].link) st[p].ch[ch] = pp;\n      }\n    }\n  }\n} SAM;\n```\n\n----------------------------------------\n\nTITLE: Calculating Square Root using Newton's Method in C++\nDESCRIPTION: This function implements Newton's method to calculate the square root of a given number. It iteratively refines the approximation until the desired precision is reached.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/newton.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ndouble sqrt_newton(double n) {\n  constexpr static double eps = 1E-15;\n  double x = 1;\n  while (true) {\n    double nx = (x + n / x) / 2;\n    if (abs(x - nx) < eps) break;\n    x = nx;\n  }\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MPM (Malhotra, Pramodh-Kumar and Maheshwari) Algorithm for Maximum Flow in C++\nDESCRIPTION: This code implements the MPM algorithm for solving maximum flow problems. It uses a struct to represent flow edges and includes methods for adding edges, performing BFS, pushing flow, and calculating the maximum flow. The algorithm has a time complexity of O(V^3).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow/max-flow.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct MPM {\n  struct FlowEdge {\n    int v, u;\n    long long cap, flow;\n\n    FlowEdge() {}\n\n    FlowEdge(int _v, int _u, long long _cap, long long _flow)\n        : v(_v), u(_u), cap(_cap), flow(_flow) {}\n\n    FlowEdge(int _v, int _u, long long _cap)\n        : v(_v), u(_u), cap(_cap), flow(0ll) {}\n  };\n\n  constexpr static long long flow_inf = 1e18;\n  vector<FlowEdge> edges;\n  vector<char> alive;\n  vector<long long> pin, pout;\n  vector<list<int>> in, out;\n  vector<vector<int>> adj;\n  vector<long long> ex;\n  int n, m = 0;\n  int s, t;\n  vector<int> level;\n  vector<int> q;\n  int qh, qt;\n\n  void resize(int _n) {\n    n = _n;\n    ex.resize(n);\n    q.resize(n);\n    pin.resize(n);\n    pout.resize(n);\n    adj.resize(n);\n    level.resize(n);\n    in.resize(n);\n    out.resize(n);\n  }\n\n  MPM() {}\n\n  MPM(int _n, int _s, int _t) {\n    resize(_n);\n    s = _s;\n    t = _t;\n  }\n\n  void add_edge(int v, int u, long long cap) {\n    edges.push_back(FlowEdge(v, u, cap));\n    edges.push_back(FlowEdge(u, v, 0));\n    adj[v].push_back(m);\n    adj[u].push_back(m + 1);\n    m += 2;\n  }\n\n  bool bfs() {\n    while (qh < qt) {\n      int v = q[qh++];\n      for (int id : adj[v]) {\n        if (edges[id].cap - edges[id].flow < 1) continue;\n        if (level[edges[id].u] != -1) continue;\n        level[edges[id].u] = level[v] + 1;\n        q[qt++] = edges[id].u;\n      }\n    }\n    return level[t] != -1;\n  }\n\n  long long pot(int v) { return min(pin[v], pout[v]); }\n\n  void remove_node(int v) {\n    for (int i : in[v]) {\n      int u = edges[i].v;\n      auto it = find(out[u].begin(), out[u].end(), i);\n      out[u].erase(it);\n      pout[u] -= edges[i].cap - edges[i].flow;\n    }\n    for (int i : out[v]) {\n      int u = edges[i].u;\n      auto it = find(in[u].begin(), in[u].end(), i);\n      in[u].erase(it);\n      pin[u] -= edges[i].cap - edges[i].flow;\n    }\n  }\n\n  void push(int from, int to, long long f, bool forw) {\n    qh = qt = 0;\n    ex.assign(n, 0);\n    ex[from] = f;\n    q[qt++] = from;\n    while (qh < qt) {\n      int v = q[qh++];\n      if (v == to) break;\n      long long must = ex[v];\n      auto it = forw ? out[v].begin() : in[v].begin();\n      while (true) {\n        int u = forw ? edges[*it].u : edges[*it].v;\n        long long pushed = min(must, edges[*it].cap - edges[*it].flow);\n        if (pushed == 0) break;\n        if (forw) {\n          pout[v] -= pushed;\n          pin[u] -= pushed;\n        } else {\n          pin[v] -= pushed;\n          pout[u] -= pushed;\n        }\n        if (ex[u] == 0) q[qt++] = u;\n        ex[u] += pushed;\n        edges[*it].flow += pushed;\n        edges[(*it) ^ 1].flow -= pushed;\n        must -= pushed;\n        if (edges[*it].cap - edges[*it].flow == 0) {\n          auto jt = it;\n          ++jt;\n          if (forw) {\n            in[u].erase(find(in[u].begin(), in[u].end(), *it));\n            out[v].erase(it);\n          } else {\n            out[u].erase(find(out[u].begin(), out[u].end(), *it));\n            in[v].erase(it);\n          }\n          it = jt;\n        } else\n          break;\n        if (!must) break;\n      }\n    }\n  }\n\n  long long flow() {\n    long long ans = 0;\n    while (true) {\n      pin.assign(n, 0);\n      pout.assign(n, 0);\n      level.assign(n, -1);\n      alive.assign(n, true);\n      level[s] = 0;\n      qh = 0;\n      qt = 1;\n      q[0] = s;\n      if (!bfs()) break;\n      for (int i = 0; i < n; i++) {\n        out[i].clear();\n        in[i].clear();\n      }\n      for (int i = 0; i < m; i++) {\n        if (edges[i].cap - edges[i].flow == 0) continue;\n        int v = edges[i].v, u = edges[i].u;\n        if (level[v] + 1 == level[u] && (level[u] < level[t] || u == t)) {\n          in[u].push_back(i);\n          out[v].push_back(i);\n          pin[u] += edges[i].cap - edges[i].flow;\n          pout[v] += edges[i].cap - edges[i].flow;\n        }\n      }\n      pin[s] = pout[t] = flow_inf;\n      while (true) {\n        int v = -1;\n        for (int i = 0; i < n; i++) {\n          if (!alive[i]) continue;\n          if (v == -1 || pot(i) < pot(v)) v = i;\n        }\n        if (v == -1) break;\n        if (pot(v) == 0) {\n          alive[v] = false;\n          remove_node(v);\n          continue;\n        }\n        long long f = pot(v);\n        ans += f;\n        push(v, s, f, false);\n        push(v, t, f, true);\n        alive[v] = false;\n        remove_node(v);\n      }\n    }\n    return ans;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS using Forward Star in Python\nDESCRIPTION: This snippet demonstrates how to implement Depth First Search using a forward star graph representation in Python. It uses global lists to store edges and visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef dfs(u):\n    vis[u] = True\n    i = head[u]\n    while i:\n        if vis[e[i].t] == False:\n            dfs(v)\n        i = e[i].x\n```\n\n----------------------------------------\n\nTITLE: Calculating Distinct Necklace Colorings with Pólya Counting\nDESCRIPTION: Applies the Pólya counting theorem to calculate the number of distinct 4-bead necklace colorings with 2 colors, taking rotational symmetry into account.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n$$\n\\frac{2^4+2^1+2^2+2^1}{4}=6.\n$$\n```\n\n----------------------------------------\n\nTITLE: Checking if a Number is a Power of Two in C++\nDESCRIPTION: Function that determines whether a number is a power of 2 by using a bit manipulation trick. It checks if the number has exactly one bit set to 1 in its binary representation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbool isPowerOfTwo(int n) { return n > 0 && (n & (n - 1)) == 0; }\n```\n\n----------------------------------------\n\nTITLE: Checking If Two Numbers Have Same Sign in C++\nDESCRIPTION: A function that determines if two non-zero integers have the same sign using the XOR bitwise operation, which is more efficient than comparing the signs separately.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nbool isSameSign(int x, int y) {  // 有 0 的情况例外\n  return (x ^ y) >= 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Else-If Chain in C++\nDESCRIPTION: Illustrates an else-if chain in C++, allowing for multiple conditions to be checked sequentially. It's useful for handling multiple mutually exclusive conditions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nif (条件1) {\n  主体1;\n} else if (条件2) {\n  主体2;\n} else if (条件3) {\n  主体3;\n} else {\n  主体4;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing to File using ofstream in C++\nDESCRIPTION: Example of opening a file for writing using C++ ofstream class. Similar to ifstream, this provides C++ stream functionality for output operations to files.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nofstream fout(\"data.out\");\n// data.out 就是输出文件的相对位置或绝对位置\n```\n\n----------------------------------------\n\nTITLE: Finding Convex Hull Diameter using Rotating Calipers in Python\nDESCRIPTION: This Python code implements the Rotating Calipers algorithm to find the diameter of a convex hull. It uses a list to store convex hull points and calculates distances between points to find the maximum distance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/rotating-calipers.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nsta = [0] * N\ntop = 0  # 将凸包上的节点编号存在栈里，第一个和最后一个节点编号相同\n\n\ndef pf(x):\n    return x * x\n\n\ndef dis(p, q):\n    return pf(a[p].x - a[q].x) + pf(a[p].y - a[q].y)\n\n\ndef sqr(p, q, y):\n    return abs((a[q] - a[p]) * (a[y] - a[q]))\n\n\ndef get_longest():  # 求凸包直径\n    j = 3\n    if top < 4:\n        mx = dis(sta[1], sta[2])\n        return\n    for i in range(1, top):\n        while sqr(sta[i], sta[i + 1], sta[j]) <= sqr(\n            sta[i], sta[i + 1], sta[j % top + 1]\n        ):\n            j = j % top + 1\n        mx = max(mx, max(dis(sta[i + 1], sta[j]), dis(sta[i], sta[j])))\n```\n\n----------------------------------------\n\nTITLE: Constructing Virtual Tree Using Monotonic Stack in C++\nDESCRIPTION: This function builds a virtual tree using a monotonic stack approach. It processes key nodes in DFS order, maintaining a stack of nodes and connecting edges as needed. It handles cases where LCA is or isn't in the stack.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/virtual-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nbool cmp(const int x, const int y) { return id[x] < id[y]; }\n\nvoid build() {\n  sort(h + 1, h + k + 1, cmp);\n  sta[top = 1] = 1, g.sz = 0, g.head[1] = -1;\n  // 1 号节点入栈，清空 1 号节点对应的邻接表，设置邻接表边数为 1\n  for (int i = 1, l; i <= k; ++i)\n    if (h[i] != 1) {\n      // 如果 1 号节点是关键节点就不要重复添加\n      l = lca(h[i], sta[top]);\n      // 计算当前节点与栈顶节点的 LCA\n      if (l != sta[top]) {\n        // 如果 LCA 和栈顶元素不同，则说明当前节点不再当前栈所存的链上\n        while (id[l] < id[sta[top - 1]])\n          // 当次大节点的 Dfs 序大于 LCA 的 Dfs 序\n          g.push(sta[top - 1], sta[top]), top--;\n        // 把与当前节点所在的链不重合的链连接掉并且弹出\n        if (id[l] > id[sta[top - 1]])\n          // 如果 LCA 不等于次大节点（这里的大于其实和不等于没有区别）\n          g.head[l] = -1, g.push(l, sta[top]), sta[top] = l;\n        // 说明 LCA 是第一次入栈，清空其邻接表，连边后弹出栈顶元素，并将 LCA\n        // 入栈\n        else\n          g.push(l, sta[top--]);\n        // 说明 LCA 就是次大节点，直接弹出栈顶元素\n      }\n      g.head[h[i]] = -1, sta[++top] = h[i];\n      // 当前节点必然是第一次入栈，清空邻接表并入栈\n    }\n  for (int i = 1; i < top; ++i)\n    g.push(sta[i], sta[i + 1]);  // 剩余的最后一条链连接一下\n  return;\n}\n```\n\n----------------------------------------\n\nTITLE: String Manipulation in C\nDESCRIPTION: Common string operations in C including length calculation, comparison, copying, concatenation, and searching.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/lib-func.md#2025-04-22_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstrlen(const char *str);\nstrcmp(const char *str1, const char *str2);\nstrcpy(char *str, const char *src);\nstrncpy(char *str, const char *src, int cnt);\nstrcat(char *str1, const char *str2);\nstrstr(char *str1, const char *str2);\nstrchr(const char *str, int c);\nstrrchr(const char *str, int c);\n```\n\n----------------------------------------\n\nTITLE: Implementing Bitwise Operations with BigInteger in Java\nDESCRIPTION: This code snippet demonstrates bitwise operations using the BigInteger class in Java, including AND, OR, NOT, XOR, left shift, and right shift operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static BigInteger a, b;\n\n    static void and() {\n        out.println(\"and:\");\n        a = new BigInteger(\"3\");  // 11 \n        b = new BigInteger(\"5\");  // 101 \n        out.println(a.and(b));  // 输出 1 \n    }\n\n    static void or() {\n        out.println(\"or:\");\n        a = new BigInteger(\"2\");  // 10 \n        b = new BigInteger(\"5\");  // 101 \n        out.println(a.or(b));  // 输出 7 \n    }\n\n    static void not() {\n        out.println(\"not:\");\n        a = new BigInteger(\"2147483647\");  // 01111111 11111111 11111111 11111111 \n        out.println(a.not());  // 输出 -2147483648 二进制为：10000000 00000000 00000000 00000000 \n    }\n\n    static void xor() {\n        out.println(\"xor:\");\n        a = new BigInteger(\"6\");  // 110 \n        b = new BigInteger(\"5\");  // 101 \n        out.println(a.xor(b));  // 011 输出 3 \n    }\n\n    static void shiftLeft() {\n        out.println(\"shiftLeft:\");\n        a = new BigInteger(\"1\");\n        out.println(a.shiftLeft(10));  // 输出 1024 \n    }\n\n    static void shiftRight() {\n        out.println(\"shiftRight:\");\n        a = new BigInteger(\"1024\");\n        out.println(a.shiftRight(8));  // 输出 4 \n    }\n\n    public static void main(String[] args) {\n        and();\n        or();\n        not();\n        xor();\n        shiftLeft();\n        shiftRight();\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Core Tree Node Operations\nDESCRIPTION: Core functions for node creation, setting parent-child relationships, and node deletion in the Top Tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nint new_node() {\n  if (top) {\n    top--;\n    return Stack[top + 1];\n  }\n  return ++tot;\n}\n\nvoid setfather(int x, int fa, int type) {\n  if (x) father[x] = fa;\n  son[fa][type] = x;\n}\n\nvoid Delete(int x) {\n  setfather(ms(x), father[x], 1);\n  if (ls(x)) {\n    int p = ls(x);\n    pushdown(p, 1);\n    while (rs(p)) p = rs(p), pushdown(p, 1);\n    splay(p, 1, x);\n    setfather(rs(x), p, 1);\n    setfather(p, father[x], 2);\n    pushup(p, 1);\n    pushup(father[x], 0);\n  } else\n    setfather(rs(x), father[x], 2);\n  Clear(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Increment/Decrement Operators in C++\nDESCRIPTION: This code snippet demonstrates the behavior of prefix and postfix increment/decrement operators in C++. It shows the difference between i++ vs ++i and i-- vs --i, illustrating how the timing of the increment/decrement operation affects the assigned value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ni = 100;\n\nop1 = i++;  // op1 = 100，先 op1 = i，然后 i = i + 1\n\ni = 100;\n\nop2 = ++i;  // op2 = 101，先 i = i + 1，然后赋值 op2\n\ni = 100;\n\nop3 = i--;  // op3 = 100，先赋值 op3，然后 i = i - 1\n\ni = 100;\n\nop4 = --i;  // op4 = 99，先 i = i - 1，然后赋值 op4\n```\n\n----------------------------------------\n\nTITLE: Building AC Automaton Fail Pointers in Python\nDESCRIPTION: Python implementation of fail pointer construction for Aho-Corasick automaton. Uses BFS to traverse the trie and establish failure links between states.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef build():\n    for i in range(0, 26):\n        if tr[0][i] != 0:\n            q.append(tr[0][i])\n    while q:\n        u = q.pop(0)\n        for i in range(0, 26):\n            if tr[u][i] != 0:\n                fail[tr[u][i]] = tr[fail[u]][i]\n                q.append(tr[u][i])\n            else:\n                tr[u][i] = tr[fail[u]][i]\n```\n\n----------------------------------------\n\nTITLE: Relating Zigzag Numbers to Other Sequences in LaTeX\nDESCRIPTION: Presents the relationships between zigzag numbers and other mathematical sequences such as Euler numbers and Bernoulli numbers using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_5\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nA_n=E(n,n)\n$$\n\n$$\nA_n=(-1)^{n/2}E_n\n$$\n\n$$\nA_n=\\frac{(-1)^{(n-1)/2}2^{n+1}(2^{n+1}-1)B_{n+1}}{n+1}\n$$\n```\n\n----------------------------------------\n\nTITLE: Product of Subgroups Theorem Proof in TeX\nDESCRIPTION: Proves that for subgroups A and B of a group G, their product AB is a subgroup if and only if AB=BA.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_4\n\nLANGUAGE: tex\nCODE:\n```\n乘积 $AB$ 是子群，则必然有 $ba=(a^{-1}b^{-1})^{-1}\\in AB$ 对任意 $a\\in A$ 和 $b\\in B$ 都成立，所以 $BA\\subseteq AB$。反过来，如果 $AB=BA$，则对于任意 $a_1,a_2\\in A$ 和 $b_1,b_2\\in B$，都有 $(a_1b_1)(a_2b_2)^{-1}=a_1b_1b_2^{-1}a_2^{-1}\\in a_1BA=a_1AB=AB$，则根据子群判别法，必然有 $AB$ 是子群。\n```\n\n----------------------------------------\n\nTITLE: Finding Longest Common Substring Using General Suffix Automaton in C++\nDESCRIPTION: This code snippet shows how to use the General Suffix Automaton to find the longest common substring among multiple input strings. It builds the GSA, marks nodes for each string, and traverses the automaton to find the longest common substring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/general-sam.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/general-sam/general-sam_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Random Permutation of Integers using shuffle() in C++\nDESCRIPTION: Demonstrates how to create a random permutation of the first 10 positive integers using the shuffle() algorithm and mt19937 random number generator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <random>\n\nint main() {\n  std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n  std::random_device rd;\n  std::mt19937 g(rd());\n\n  std::shuffle(v.begin(), v.end(), g);\n\n  std::copy(v.begin(), v.end(), std::ostream_iterator<int>(std::cout, \" \"));\n  std::cout << \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Unsetting a Specific Bit in Python\nDESCRIPTION: A Python function that sets a specific bit of an integer to 0 while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# 将 a 的第 b 位设置为 0 ，最低位编号为 0\ndef unsetBit(a, b):\n    return a & ~(1 << b)\n```\n\n----------------------------------------\n\nTITLE: Calculating WPL for Existing Huffman Tree in C++\nDESCRIPTION: Recursively calculates the Weighted Path Length (WPL) for an existing Huffman tree by traversing through nodes and accumulating weighted lengths.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/huffman-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstruct HNode {\n  int weight;\n  HNode *lchild, *rchild;\n};\n\nusing Htree = HNode*;\n\nint getWPL(Htree root, int len) {\n  if (root == NULL)\n    return 0;\n  else {\n    if (root->lchild == NULL && root->rchild == NULL)\n      return root->weight * len;\n    else {\n      int left = getWPL(root->lchild, len + 1);\n      int right = getWPL(root->rchild, len + 1);\n      return left + right;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rebalancing Case 1 After Deletion in Red-Black Tree (C++)\nDESCRIPTION: Handles rebalancing when the sibling node is red after deletion in a red-black tree. Performs rotations and recoloring to maintain tree properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nConstNodePtr parent = node->parent;\nassert(parent != nullptr && parent->isBlack());\nassert(sibling->left != nullptr && sibling->left->isBlack());\nassert(sibling->right != nullptr && sibling->right->isBlack());\n// Step 1\nrotateSameDirection(node->parent, direction);\n// Step 2\nsibling->color = Node::BLACK;\nparent->color = Node::RED;\n// Update sibling after rotation\nsibling = node->sibling();\n// Step 3: vvv\n```\n\n----------------------------------------\n\nTITLE: Tree Root Manipulation Functions\nDESCRIPTION: Functions for making nodes the root and exposing paths between nodes in the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid makeroot(int x) {\n  access(x);\n  push_rev(x);\n}\n\nvoid expose(int x, int y) {\n  makeroot(x);\n  access(y);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Example of __gnu_pbds::tree with Key Operations\nDESCRIPTION: Comprehensive example demonstrating the usage of __gnu_pbds::tree container including insertion, deletion, order statistics, splitting and joining trees. This showcases the advanced functionality that makes this container useful for competitive programming.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/tree.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// Common Header Simple over C++11\n#include <iostream>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing pii = pair<int, int>;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n__gnu_pbds::tree<pair<int, int>, __gnu_pbds::null_type, less<pair<int, int>>,\n                 __gnu_pbds::rb_tree_tag,\n                 __gnu_pbds::tree_order_statistics_node_update>\n    trr;\n\nint main() {\n  int cnt = 0;\n  trr.insert(make_pair(1, cnt++));\n  trr.insert(make_pair(5, cnt++));\n  trr.insert(make_pair(4, cnt++));\n  trr.insert(make_pair(3, cnt++));\n  trr.insert(make_pair(2, cnt++));\n  // 树上元素 {(1,0), (2,4), (3,3), (4,2), (5,1)}\n\n  auto it = trr.lower_bound(make_pair(2, 0));\n  trr.erase(it);\n  // 树上元素 {(1,0), (3,3), (4,2), (5,1)}\n\n  // 输出排名 0 1 2 3 中的排名 1 的元素的 first\n  auto it2 = trr.find_by_order(1);\n  cout << (*it2).first << endl;  // 输出：3\n\n  // 输出其排名\n  int pos = trr.order_of_key(*it2);\n  cout << pos << endl;  // 输出：1\n\n  // 按照 it2 分裂 trr\n  decltype(trr) newtr;\n  trr.split(*it2, newtr);\n  for (auto i = newtr.begin(); i != newtr.end(); ++i) {\n    cout << (*i).first << ' ';  // 输出：4 5\n  }\n  cout << endl;\n\n  // 将 newtr 树并入 trr 树，newtr 树被清空。\n  trr.join(newtr);\n  for (auto i = trr.begin(); i != trr.end(); ++i) {\n    cout << (*i).first << ' ';  // 输出：1 3 4 5\n  }\n  cout << endl;\n  cout << newtr.size() << endl;  // 输出：0\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Smith Normal Form Structure\nDESCRIPTION: Matrix representation of the Smith normal form, showing the diagonal structure with invariant factors for lambda matrices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_10\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{pmatrix}\nD(\\lambda) & 0\\\\\n0 & 0\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Deleting Node from Single (Circular) Linked List in C++ and Python\nDESCRIPTION: Demonstrates the deletion of a node from a single or single circular linked list by overwriting its value and updating pointers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid deleteNode(Node *p) {\n  p->value = p->next->value;\n  Node *t = p->next;\n  p->next = p->next->next;\n  delete t;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef deleteNode(p):\n    p.value = p.next.value\n    p.next = p.next.next\n```\n\n----------------------------------------\n\nTITLE: Splitting Segments in Li Chao Tree\nDESCRIPTION: This function recursively splits and updates segments in the Li Chao tree. It locates the intervals completely covered by the new segment and updates them accordingly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/li-chao-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid update(int root, int cl, int cr, int l, int r,\n                int u) {  // 定位插入线段完全覆盖到的区间\n  if (l <= cl && cr <= r) {\n    upd(root, cl, cr, u);  // 完全覆盖当前区间，更新当前区间的标记\n    return;\n  }\n  int mid = (cl + cr) >> 1;\n  if (l <= mid) update(root << 1, cl, mid, l, r, u);  // 递归拆分区间\n  if (mid < r) update(root << 1 | 1, mid + 1, cr, l, r, u);\n}\n```\n\n----------------------------------------\n\nTITLE: 维护区间信息 - 计算乘积小于K的子数组个数 (C++)\nDESCRIPTION: 使用双指针维护一个乘积小于K的滑动窗口,统计满足条件的子数组个数。函数接受一个整数数组和目标值K作为输入,返回满足条件的子数组数量。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/two-pointer.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint numSubarrayProductLessThanK(vector<int>& nums, int k) {\n  long long ji = 1ll, ans = 0;\n  int l = 0;\n  for (int i = 0; i < nums.size(); ++i) {\n    ji *= nums[i];\n    while (l <= i && ji >= k) ji /= nums[l++];\n    ans += i - l + 1;\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Multi-item Knapsack Binary Grouping Implementation\nDESCRIPTION: Shows implementation of binary grouping optimization for multi-item knapsack problem in both C++ and Python.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nindex = 0;\nfor (int i = 1; i <= m; i++) {\n  int c = 1, p, h, k;\n  cin >> p >> h >> k;\n  while (k > c) {\n    k -= c;\n    list[++index].w = c * p;\n    list[index].v = c * h;\n    c *= 2;\n  }\n  list[++index].w = p * k;\n  list[index].v = h * k;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nindex = 0\nfor i in range(1, m + 1):\n    c = 1\n    p, h, k = map(int, input().split())\n    while k > c:\n        k -= c\n        index += 1\n        list[index].w = c * p\n        list[index].v = c * h\n        c *= 2\n    index += 1\n    list[index].w = p * k\n    list[index].v = h * k\n```\n\n----------------------------------------\n\nTITLE: Implementing Rank Query in Scapegoat Tree in C++\nDESCRIPTION: Queries the rank of a given value in the scapegoat tree, accounting for potential empty nodes. Traverses the tree based on binary search tree properties, accumulating counts of smaller elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint getrank(int x, int v) {\n  if (!x) return 0;\n  if (v == val[x]) return sz[lc[x]] + 1;\n  if (v < val[x]) return getrank(lc[x], v);\n  return sz[lc[x]] + cnt[x] + getrank(rc[x], v);\n}\n\nint rank(int v) { return getrank(rt, v); }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Scope in C++\nDESCRIPTION: Illustrates how variable scope works in C++, showing the difference between global and local variables with the same name, where the local variable takes precedence within its scope.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nint g = 20;  // 定义全局变量\n\nint main() {\n  int g = 10;         // 定义局部变量\n  printf(\"%d\\n\", g);  // 输出 g\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: High-Precision Addition in C++\nDESCRIPTION: Implementation of addition for large numbers using array-based storage. Handles carry-over by checking if sum exceeds 10 at each position.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid add(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] + b[i];\n    if (c[i] >= 10) {\n      c[i + 1] += 1;\n      c[i] -= 10;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Closed Hashing Implementation in C++\nDESCRIPTION: Implementation of hash table using closed hashing (linear probing) method with quadratic probing for collision resolution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/hash.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int N = 360007;  // N 是最大可以存储的元素数量\n\nclass Hash {\n private:\n  int keys[N];\n  int values[N];\n\n public:\n  Hash() { memset(values, 0, sizeof(values)); }\n\n  int& operator[](int n) {\n    int idx = (n % N + N) % N, cnt = 1;\n    while (keys[idx] != n && values[idx] != 0) {\n      idx = (idx + cnt * cnt) % N;\n      cnt += 1;\n    }\n    keys[idx] = n;\n    return values[idx];\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Trie Data Structure in Java\nDESCRIPTION: Java implementation of trie data structure with insertion and search operations. Uses 2D arrays to store child node pointers and boolean array to mark string endings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/trie.md#2025-04-22_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\npublic class Trie {\n    \n    int[][] tree = new int[10000][26];\n    int cnt = 0;\n    boolean[] end = new boolean[10000];\n    \n    public void insert(String word) {\n        int p = 0;\n        char[] chars = word.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            int c = chars[i] - 'a';\n            if (tree[p][c] == 0) {\n                tree[p][c] = ++cnt;\n            }\n            p = tree[p][c];\n        }\n        end[p] = true;\n    }\n    \n    public boolean find(String word) {\n        int p = 0;\n        char[] chars = word.toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            int c = chars[i] - 'a';\n            if (tree[p][c] == 0) {\n                return false;\n            }\n            p = tree[p][c];\n        }\n        return end[p];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Complex Numbers in C with <complex.h>\nDESCRIPTION: Example demonstrating complex number operations in C99 standard with the <complex.h> header, including complex number types, arithmetic operations, and special functions for extracting components and calculating properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/complex.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#include <complex.h>\n\n// Examples of complex number operations in C\ndouble complex z = 1.0 + 2.0 * I;  // Create a complex number\ndouble real_part = creal(z);       // Extract real part\ndouble imag_part = cimag(z);       // Extract imaginary part\ndouble magnitude = cabs(z);        // Calculate magnitude\ndouble angle = carg(z);           // Calculate angle (principal value)\n\ndouble complex conjugate = conj(z);  // Calculate conjugate\ndouble complex exponential = cexp(z); // e^z\ndouble complex logarithm = clog(z);   // log(z) (principal value)\ndouble complex sine = csin(z);       // sin(z)\ndouble complex cosine = ccos(z);     // cos(z)\n```\n\n----------------------------------------\n\nTITLE: Counting Unlabeled Simple Graphs with Pólya Enumeration\nDESCRIPTION: Application of the Pólya Enumeration Theorem to count non-isomorphic simple graphs with 4 vertices by analyzing the edge permutation group of S4.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_13\n\nLANGUAGE: latex\nCODE:\n```\nZ(S_4^{(2)})=\\dfrac{1}{24}(t_1^6+9t_1^2t_2^2+8t_3^2+6t_2t_4).\n```\n\n----------------------------------------\n\nTITLE: Implementing Main-Lorentz Algorithm for String Tandem Repetitions in C++\nDESCRIPTION: A complete C++ implementation of the Main-Lorentz algorithm that finds all tandem repetitions in a string. The code includes Z-function calculation, repetition finding logic, and helper functions for converting found patterns into position pairs. The implementation has O(n log n) time complexity for finding repetitions, though outputting all positions takes O(n^2) time in worst case.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/main-lorentz.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> z_function(string const& s) {\n  int n = s.size();\n  vector<int> z(n);\n  for (int i = 1, l = 0, r = 0; i < n; i++) {\n    if (i <= r) z[i] = min(r - i + 1, z[i - l]);\n    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;\n    if (i + z[i] - 1 > r) {\n      l = i;\n      r = i + z[i] - 1;\n    }\n  }\n  return z;\n}\n\nint get_z(vector<int> const& z, int i) {\n  if (0 <= i && i < (int)z.size())\n    return z[i];\n  else\n    return 0;\n}\n\nvector<pair<int, int>> repetitions;\n\nvoid convert_to_repetitions(int shift, bool left, int cntr, int l, int k1,\n                            int k2) {\n  for (int l1 = max(1, l - k2); l1 <= min(l, k1); l1++) {\n    if (left && l1 == l) break;\n    int l2 = l - l1;\n    int pos = shift + (left ? cntr - l1 : cntr - l - l1 + 1);\n    repetitions.emplace_back(pos, pos + 2 * l - 1);\n  }\n}\n\nvoid find_repetitions(string s, int shift = 0) {\n  int n = s.size();\n  if (n == 1) return;\n\n  int nu = n / 2;\n  int nv = n - nu;\n  string u = s.substr(0, nu);\n  string v = s.substr(nu);\n  string ru(u.rbegin(), u.rend());\n  string rv(v.rbegin(), v.rend());\n\n  find_repetitions(u, shift);\n  find_repetitions(v, shift + nu);\n\n  vector<int> z1 = z_function(ru);\n  vector<int> z2 = z_function(v + '#' + u);\n  vector<int> z3 = z_function(ru + '#' + rv);\n  vector<int> z4 = z_function(v);\n\n  for (int cntr = 0; cntr < n; cntr++) {\n    int l, k1, k2;\n    if (cntr < nu) {\n      l = nu - cntr;\n      k1 = get_z(z1, nu - cntr);\n      k2 = get_z(z2, nv + 1 + cntr);\n    } else {\n      l = cntr - nu + 1;\n      k1 = get_z(z3, nu + 1 + nv - 1 - (cntr - nu));\n      k2 = get_z(z4, (cntr - nu) + 1);\n    }\n    if (k1 + k2 >= l) convert_to_repetitions(shift, cntr < nu, cntr, l, k1, k2);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Difference Constraints System using Bellman-Ford in Python\nDESCRIPTION: This Python implementation of the Bellman-Ford algorithm is used to detect negative cycles in a graph for solving difference constraints systems. It updates distances iteratively and checks for the existence of negative cycles.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/diff-constraints.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef Bellman_Ford():\n    for i in range(0, n):\n        jud = False\n        for j in range(1, n + 1):\n            while ~k:\n                k = h[j]\n                if dist[j] > dist[p[k]] + w[k]:\n                    dist[j] = dist[p[k]] + w[k]\n                    jud = True\n                k = nxt[k]\n        if jud == False:\n            break\n    for i in range(1, n + 1):\n        while ~j:\n            j = h[i]\n            if dist[i] > dist[p[j]] + w[j]:\n                return False\n            j = nxt[j]\n    return True\n```\n\n----------------------------------------\n\nTITLE: Using Arithmetic Operators in C++\nDESCRIPTION: Shows the usage of basic arithmetic operators like multiplication, division, and modulus.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nint i = 2 * 4;\nfloat f = 10.0 / 3.0;\nint rem = 4 % 3;\n```\n\n----------------------------------------\n\nTITLE: Using the type() Function to Check Variable Types in Python\nDESCRIPTION: Shows how to use Python's built-in type() function to check the type of variables. This demonstrates Python's dynamic typing system where variables can hold different types of objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> type(x)\n<class 'int'>\n>>> type(f)\n<class 'float'>\n>>> type(s1)  # 请注意，不要给字符串起名为 str，否则 str 对象会被篡改\n<class 'str'>\n>>> type(b)\n<class 'bool'>\n```\n\n----------------------------------------\n\nTITLE: Implementing Binary Queue Optimization for Quadrangle Inequality in C++\nDESCRIPTION: A complete implementation of the binary queue approach for dynamic programming optimization. This algorithm maintains a deque of decision points and their valid problem intervals, using binary search to find optimal decision boundaries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint val(int j, int i);\nint lt[N], rt[N], f[N];\ndeque<int> dq;\n// 初始化队列\ndq.emplace_back(1);\nlt[1] = 1;\nrt[n] = n;\n// 顺次考虑所有问题和决策\nfor (int j = 1; j <= n; ++j) {\n  // 出队\n  while (!dq.empty() && rt[dq.front()] < j) {\n    dq.pop_front();\n  }\n  // 计算\n  f[j] = val(dq.front(), j);\n  // 入队\n  while (!dq.empty() && val(j, lt[dq.back()]) < val(dq.back(), lt[dq.back()])) {\n    dq.pop_back();\n  }\n  if (dq.empty()) {\n    dq.emplace_back(j);\n    lt[j] = j + 1;\n    rt[j] = n;\n  } else if (val(j, rt[dq.back()]) < val(dq.back(), rt[dq.back()])) {\n    if (rt[dq.back()] < n) {\n      dq.emplace_back(j);\n      lt[j] = rt[dq.back()] + 1;\n      rt[j] = n;\n    }\n  } else {\n    int ll = lt[dq.back()];\n    int rr = rt[dq.back()];\n    int i;\n    // 二分\n    while (ll <= rr) {\n      int mm = (ll + rr) / 2;\n      if (val(j, mm) < val(dq.back(), mm)) {\n        i = mm;\n        rr = mm - 1;\n      } else {\n        ll = mm + 1;\n      }\n    }\n    rt[dq.back()] = i - 1;\n    dq.emplace_back(j);\n    lt[j] = i;\n    rt[j] = n;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: TreeSet Methods Demo\nDESCRIPTION: Demonstrates various TreeSet methods including first(), last(), floor(), ceiling(), higher(), lower(), and poll operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_15\n\nLANGUAGE: java\nCODE:\n```\nimport java.util.TreeSet;\n\npublic class Main {\n    static int[] a = {4,7,1,2,3,6};\n\n    public static void main(String[] args) {\n        TreeSet<Integer> set = new TreeSet<>();\n        for(int v:a) {\n            set.add(v);\n        }\n        Integer a2 = set.first();\n        System.out.println(a2); //返回 1\n        Integer a3 = set.last();\n        System.out.println(a3); //返回 7\n        Integer a4 = set.floor(5);\n        System.out.println(a4); //返回 4\n        Integer a5 = set.ceiling(6);\n        System.out.println(a5); //返回 6\n        Integer a6 = set.higher(7);\n        System.out.println(a6); //返回 null\n        Integer a7 = set.lower(2);\n        System.out.println(a7); //返回 1\n        Integer a8 = set.pollFirst();\n        System.out.println(a8); //返回 1\n        Integer a9 = set.pollLast();\n        System.out.println(a9); //返回 7\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Optimized Minimum String Representation Algorithm in Python\nDESCRIPTION: This snippet shows the Python implementation of the optimized minimum string representation algorithm. It uses the same optimization technique as the C++ version to improve efficiency when handling repeated substrings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/minimal-string.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nk, i, j = 0, 0, 1\nwhile k < n and i < n and j < n:\n    if sec[(i + k) % n] == sec[(j + k) % n]:\n        k += 1\n    else:\n        if sec[(i + k) % n] > sec[(j + k) % n]:\n            i = i + k + 1\n        else:\n            j = j + k + 1\n        if i == j:\n            i += 1\n        k = 0\ni = min(i, j)\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda Using Self-Reference Parameter in C++\nDESCRIPTION: This approach passes the lambda itself as a parameter, avoiding the need to capture it. The template parameter auto& self allows for recursion without type inference issues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nint n = 10;\n\n// 参数列表中有参数类型为 auto，则这个 Lambda 类中的 operator()\n// 函数将被定义为模板函数，模板函数可以在稍后被调用时再进行实例化\nauto dfs = [&](auto& self,\n                   int i) -> void  // [&] 只会捕获用到的变量，所以不会捕获 auto dfs\n{\n  if (i == n)\n    return;\n  else\n    self(self, i + 1);  // OK\n};\n\ndfs(dfs, 1);\n```\n\n----------------------------------------\n\nTITLE: Calculating Inversions Using Merge Sort\nDESCRIPTION: Implementation of counting inversions in a permutation using the merge sort algorithm with O(n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/permutation.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/permutation/inversion_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Direct Product of Groups\nDESCRIPTION: This LaTeX snippet defines the direct product operation for two groups G and H, showing how the binary operation is defined componentwise.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_11\n\nLANGUAGE: LaTeX\nCODE:\n```\n(g_1,h_1)\\cdot(g_2,h_2)=(g_1\\cdot_G g_2,h_1\\cdot_H h_2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Unary Operators in C++\nDESCRIPTION: Illustrates the use of various unary operators including logical NOT, bitwise NOT, and address-of operator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nif (!done) …\nflags = ~flags;\nint *intPtr = &data;\n```\n\n----------------------------------------\n\nTITLE: Implementing Rectangle Query in k-D Tree\nDESCRIPTION: Function to query points within a rectangular region in a k-D tree. Handles cases where regions fully contain, partially intersect, or don't intersect with the query rectangle.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/kdt.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint query(int p) {\n  if (!p) return 0;\n  bool flag{false};\n  for (int k : {0, 1}) flag |= (!(l.x[k] <= t[p].L[k] && t[p].R[k] <= h.x[k]));\n  if (!flag) return t[p].sum;\n  for (int k : {0, 1})\n    if (t[p].R[k] < l.x[k] || h.x[k] < t[p].L[k]) return 0;\n  int ans{0};\n  flag = false;\n  for (int k : {0, 1}) flag |= (!(l.x[k] <= t[p].x[k] && t[p].x[k] <= h.x[k]));\n  if (!flag) ans = t[p].v;\n  return ans += query(t[p].l) + query(t[p].r);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 2D Submatrix Addition and Sum Query with Binary Indexed Trees in C++\nDESCRIPTION: Uses four 2D binary indexed trees to support submatrix additions and submatrix sum queries on a 2D array. The trees store different combinations of values and indices to enable efficient range operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nusing ll = long long;\nll t1[N][N], t2[N][N], t3[N][N], t4[N][N];\n\nvoid add(ll x, ll y, ll z) {\n  for (int X = x; X <= n; X += lowbit(X))\n    for (int Y = y; Y <= m; Y += lowbit(Y)) {\n      t1[X][Y] += z;\n      t2[X][Y] += z * x;\n      t3[X][Y] += z * y;\n      t4[X][Y] += z * x * y;\n    }\n}\n\nvoid range_add(ll xa, ll ya, ll xb, ll yb,\n               ll z) {\n  add(xa, ya, z);\n  add(xa, yb + 1, -z);\n  add(xb + 1, ya, -z);\n  add(xb + 1, yb + 1, z);\n}\n\nll ask(ll x, ll y) {\n  ll res = 0;\n  for (int i = x; i; i -= lowbit(i))\n    for (int j = y; j; j -= lowbit(j))\n      res += (x + 1) * (y + 1) * t1[i][j] - (y + 1) * t2[i][j] -\n             (x + 1) * t3[i][j] + t4[i][j];\n  return res;\n}\n\nll range_ask(ll xa, ll ya, ll xb, ll yb) {\n  return ask(xb, yb) - ask(xb, ya - 1) - ask(xa - 1, yb) + ask(xa - 1, ya - 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Specific Bit in C++\nDESCRIPTION: A function that sets a specific bit of an integer to 1 while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\n// 将 a 的第 b 位设置为 1 ，最低位编号为 0\nint setBit(int a, int b) { return a | (1 << b); }\n```\n\n----------------------------------------\n\nTITLE: Tree Preprocessing DFS - First Pass\nDESCRIPTION: First DFS pass to calculate node properties like parent, depth, subtree size and heavy child information\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/hld.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid dfs1(int o) {\n  son[o] = -1;\n  siz[o] = 1;\n  for (int j = h[o]; j; j = nxt[j])\n    if (!dep[p[j]]) {\n      dep[p[j]] = dep[o] + 1;\n      fa[p[j]] = o;\n      dfs1(p[j]);\n      siz[o] += siz[p[j]];\n      if (son[o] == -1 || siz[p[j]] > siz[son[o]]) son[o] = p[j];\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Kth Element - C++\nDESCRIPTION: Binary search implementation to find the kth element in a given range using segment tree with balanced tree. Searches over possible values to find the element with the required rank.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/balanced-in-seg.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint el = 0, er = 100000001, emid;\nwhile (el != er) {\n  emid = el + er >> 1;\n  if (vec_rank(1, 1, n, tl, tr, emid) - 1 < tk)\n    el = emid + 1;\n  else\n    er = emid;\n}\nprintf(\"%d\\n\", el - 1);\n```\n\n----------------------------------------\n\nTITLE: LCA Query Using Heavy-Light Decomposition\nDESCRIPTION: Implementation of Lowest Common Ancestor query using tree decomposition properties\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/hld.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint lca(int u, int v) {\n  while (top[u] != top[v]) {\n    if (dep[top[u]] > dep[top[v]])\n      u = fa[top[u]];\n    else\n      v = fa[top[v]];\n  }\n  return dep[u] > dep[v] ? v : u;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Farey Sequence in Python\nDESCRIPTION: Function to construct the nth order Farey sequence using a recursive approach. It generates fractions with denominators up to n and adds them to a list in sorted order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\ndef farey(n, res, a=0, b=1, c=1, d=1):\n    if b + d > n:\n        return\n    x = (n + b) // d\n    farey(n, res, a, b, x * c - a, x * d - b)\n    res.append((c, d))\n    farey(n, res, c, d, x * c - a, x * d - b)\n\nres = []\nfarey(n, res)\nres = [(0, 1)] + res + [(1, 1)]\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Sum of Divisors in C++\nDESCRIPTION: Implements a linear sieve algorithm to calculate the sum of divisors for numbers up to n. It uses auxiliary arrays to handle prime factors and their powers efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> pri;\nbool not_prime[N];\nint g[N], f[N];\n\nvoid pre(int n) {\n  g[1] = f[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!not_prime[i]) {\n      pri.push_back(i);\n      g[i] = i + 1;\n      f[i] = i + 1;\n    }\n    for (int pri_j : pri) {\n      if (i * pri_j > n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) {\n        g[i * pri_j] = g[i] * pri_j + 1;\n        f[i * pri_j] = f[i] / g[i] * g[i * pri_j];\n        break;\n      }\n      f[i * pri_j] = f[i] * f[pri_j];\n      g[i * pri_j] = 1 + pri_j;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Maximum Cardinality Search Implementation in C++\nDESCRIPTION: Implementation of the MCS algorithm to find a perfect elimination ordering in a chordal graph. The algorithm runs in O(n+m) time complexity and maintains a label count for each vertex.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/chord.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nwhile (cur) {\n  p[cur] = h[nww];\n  rnk[p[cur]] = cur;\n  h[nww] = nxt[h[nww]];\n  lst[h[nww]] = 0;\n  lst[p[cur]] = nxt[p[cur]] = 0;\n  tf[p[cur]] = true;\n  for (vector<int>::iterator it = G[p[cur]].begin(); it != G[p[cur]].end();\n       it++)\n    if (!tf[*it]) {\n      if (h[deg[*it]] == *it) h[deg[*it]] = nxt[*it];\n      nxt[lst[*it]] = nxt[*it];\n      lst[nxt[*it]] = lst[*it];\n      lst[*it] = nxt[*it] = 0;\n      deg[*it]++;\n      nxt[*it] = h[deg[*it]];\n      lst[h[deg[*it]]] = *it;\n      h[deg[*it]] = *it;\n    }\n  cur--;\n  if (h[nww + 1]) nww++;\n  while (nww && !h[nww]) nww--;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Gray Code Back to Binary in C++\nDESCRIPTION: Function that performs reverse Gray code transformation, converting a Gray code number back to its original binary form by iteratively XORing all bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/gray-code.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint rev_g(int g) {\n  int n = 0;\n  for (; g; g >>= 1) n ^= g;\n  return n;\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Left-Leaning Trees in C++\nDESCRIPTION: Implements the core merge operation for left-leaning trees. It recursively combines two heaps while maintaining the left-leaning property.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/leftist-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint merge(int x, int y) {\n  if (!x || !y) return x | y;  // 若一个堆为空则返回另一个堆\n  if (t[x].val > t[y].val) swap(x, y);  // 取值较小的作为根\n  t[x].rs = merge(t[x].rs, y);          // 递归合并右儿子与另一个堆\n  if (t[t[x].rs].d > t[t[x].ls].d)\n    swap(t[x].ls, t[x].rs);   // 若不满足左偏性质则交换左右儿子\n  t[x].d = t[t[x].rs].d + 1;  // 更新dist\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Weight Blossom Function in C++\nDESCRIPTION: The main function of the Blossom algorithm for maximum weight matching. It initializes data structures, performs matching iterations, and calculates the total weight and number of matches.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_10\n\nLANGUAGE: c++\nCODE:\n```\npair<long long, int> weight_blossom() {\n  memset(match + 1, 0, sizeof(int) * n);\n  n_x = n;  // 一开始没有花\n  int n_matches = 0;\n  long long tot_weight = 0;\n  for (int u = 0; u <= n; ++u) {\n    // 先把自己所在的花设为自己\n    st[u] = u;\n    flower[u].clear();\n  }\n  int w_max = 0;\n  for (int u = 1; u <= n; ++u)\n    for (int v = 1; v <= n; ++v) {\n      // u是一个点时，里面所包含的点只有自己\n      flower_from[u][v] = (u == v ? u : 0);\n      w_max = max(w_max, g[u][v].w);\n      // 找出最大的边权\n    }\n  for (int u = 1; u <= n; ++u) lab[u] = w_max;\n  // 让所有的lab=最大的边权\n  // 因为这里实现是用边权乘二来计算ze的值所以不用除以二\n  while (matching()) ++n_matches;\n  for (int u = 1; u <= n; ++u)\n    if (match[u] && match[u] < u) tot_weight += g[u][match[u]].w;\n  return make_pair(tot_weight, n_matches);\n}\n```\n\n----------------------------------------\n\nTITLE: Using input() Function in Python\nDESCRIPTION: Demonstrates Python's input() function which reads an entire line as a string. Shows how to provide a prompt message to the user when collecting input.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> s = input('请输入一串数字: '); s  # 自己调试时可以向 input() 传入字符串作为提示\n请输入一串数字: 1 2 3 4 5 6\n'1 2 3 4 5 6'\n```\n\n----------------------------------------\n\nTITLE: High-Precision Long Multiplication in C++\nDESCRIPTION: Multiplication between two high-precision numbers. Implements vertical multiplication algorithm with deferred carry handling.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid mul(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];\n    if (c[i] >= 10) {\n      c[i + 1] += c[i] / 10;\n      c[i] %= 10;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Trie Data Structure in C++\nDESCRIPTION: C++ implementation of trie data structure with insertion and search operations. Uses arrays to store child node pointers and boolean flags to mark string endings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/trie.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct trie {\n  int nex[100000][26], cnt;\n  bool exist[100000];  // 该结点结尾的字符串是否存在\n\n  void insert(char *s, int l) {  // 插入字符串\n    int p = 0;\n    for (int i = 0; i < l; i++) {\n      int c = s[i] - 'a';\n      if (!nex[p][c]) nex[p][c] = ++cnt;  // 如果没有，就添加结点\n      p = nex[p][c];\n    }\n    exist[p] = true;\n  }\n\n  bool find(char *s, int l) {  // 查找字符串\n    int p = 0;\n    for (int i = 0; i < l; i++) {\n      int c = s[i] - 'a';\n      if (!nex[p][c]) return 0;\n      p = nex[p][c];\n    }\n    return exist[p];\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Counting Sort Algorithm in Python\nDESCRIPTION: This code snippet shows the implementation of the counting sort algorithm in Python. It sorts an input array in non-decreasing order using the counting sort method.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/counting-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n--8<-- \"docs/basic/code/counting-sort/counting-sort_1.py\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Selection Sort in Java\nDESCRIPTION: Java implementation of the selection sort algorithm. This implementation starts array indexing from 1 and repeatedly finds the minimum element from the unsorted part of the array and swaps it with the first unsorted element.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/selection-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\n// arr代码下标从 1 开始索引\nstatic void selection_sort(int[] arr, int n) {\n    for (int i = 1; i < n; i++) {\n        int ith = i;\n        for (int j = i + 1; j <= n; j++) {\n            if (arr[j] < arr[ith]) {\n                ith = j;\n            }\n        }\n        // swap\n        int temp = arr[i];\n        arr[i] = arr[ith];\n        arr[ith] = temp;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Online String Queries using Suffix Balanced Tree in C++\nDESCRIPTION: This code implements a solution for handling online string queries, including inserting characters at the end, deleting characters from the end, and counting occurrences of substrings. It uses a suffix balanced tree to efficiently maintain the string structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-bst.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/suffix-bst/suffix-bst_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Efficient High-Precision Division with Digit Compression in C++\nDESCRIPTION: Advanced implementation of high-precision division using digit compression and double-based quotient estimation for improved performance. Handles large numbers efficiently with base up to 32768.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nBigIntSimple &sub_mul(const BigIntSimple &b, int mul, int offset) {\n  if (mul == 0) return *this;\n  int borrow = 0;\n  for (size_t i = 0; i < b.v.size(); ++i) {\n    borrow += v[i + offset] - b.v[i] * mul - BIGINT_BASE + 1;\n    v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;\n    borrow /= BIGINT_BASE;\n  }\n  for (size_t i = b.v.size(); borrow; ++i) {\n    borrow += v[i + offset] - BIGINT_BASE + 1;\n    v[i + offset] = borrow % BIGINT_BASE + BIGINT_BASE - 1;\n    borrow /= BIGINT_BASE;\n  }\n  return *this;\n}\n\nBigIntSimple div_mod(const BigIntSimple &b, BigIntSimple &r) const {\n  BigIntSimple d;\n  r = *this;\n  if (absless(b)) return d;\n  d.v.resize(v.size() - b.v.size() + 1);\n  double t = (b.get((unsigned)b.v.size() - 2) +\n              (b.get((unsigned)b.v.size() - 3) + 1.0) / BIGINT_BASE);\n  double db = 1.0 / (b.v.back() + t / BIGINT_BASE);\n  for (size_t i = v.size() - 1, j = d.v.size() - 1; j <= v.size();) {\n    int rm = r.get(i + 1) * BIGINT_BASE + r.get(i);\n    int m = std::max((int)(db * rm), r.get(i + 1));\n    r.sub_mul(b, m, j);\n    d.v[j] += m;\n    if (!r.get(i + 1))\n      --i, --j;\n  }\n  r.trim();\n  int carry = 0;\n  while (!r.absless(b)) {\n    r.subtract(b);\n    ++carry;\n  }\n  for (size_t i = 0; i < d.v.size(); ++i) {\n    carry += d.v[i];\n    d.v[i] = carry % BIGINT_BASE;\n    carry /= BIGINT_BASE;\n  }\n  d.trim();\n  d.sign = sign * b.sign;\n  return d;\n}\n\nBigIntSimple operator/(const BigIntSimple &b) const {\n  BigIntSimple r;\n  return div_mod(b, r);\n}\n\nBigIntSimple operator%(const BigIntSimple &b) const {\n  BigIntSimple r;\n  div_mod(b, r);\n  return r;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Comma Operator in C++ For Loop\nDESCRIPTION: Illustrates the use of the comma operator in a for loop initialization and update expressions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nfor (i = 0, j = 0; i < 10; i++, j++) ...\n```\n\n----------------------------------------\n\nTITLE: Calculating Prefix Sums with partial_sum in C++\nDESCRIPTION: Shows how to use partial_sum to calculate prefix sums of elements in a vector. The result is stored in a new vector using a back_inserter iterator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvector<int> src = {1, 2, 3, 4, 5}, dst;\n// 求解src中元素的前缀和，dst[i] = src[0] + ... + src[i]\n// back_inserter 函数作用在 dst 容器上，提供一个迭代器\npartial_sum(src.begin(), src.end(), back_inserter(dst));\nfor (unsigned int i = 0; i < dst.size(); i++) cout << dst[i] << \" \";\n```\n\n----------------------------------------\n\nTITLE: Implementing Divide-and-Conquer Optimization with Quadrangle Inequality in C++\nDESCRIPTION: A core implementation of the divide-and-conquer approach for dynamic programming optimization using decision monotonicity. The algorithm recursively narrows the decision space based on the quadrangle inequality property.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint w(int j, int i);\n\nvoid DP(int l, int r, int k_l, int k_r) {\n  int mid = (l + r) / 2, k = k_l;\n  // 求状态f[mid]的最优决策点\n  for (int j = k_l; j <= min(k_r, mid - 1); ++j)\n    if (w(j, mid) < w(k, mid)) k = j;\n  f[mid] = w(k, mid);\n  // 根据决策单调性得出左右两部分的决策区间，递归处理\n  if (l < mid) DP(l, mid - 1, k_l, k);\n  if (r > mid) DP(mid + 1, r, k, k_r);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Value Query Operation for Treap in C++\nDESCRIPTION: Implements a method to query the value of the node with a given rank in the Treap. Recursively searches the tree based on the size of subtrees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint _query_val(Node *cur, int rank) {\n  // 查询树中第 rank 大的节点的值\n  int less_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n  // less siz 是左子树的大小\n  if (rank <= less_siz)\n    return _query_val(cur->ch[0], rank);\n  else if (rank <= less_siz + cur->rep_cnt)\n    return cur->val;\n  else\n    return _query_val(cur->ch[1], rank - less_siz - cur->rep_cnt);  // 见前文\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Input and Output in Python\nDESCRIPTION: Shows how to use Python's print() function with various parameters to control output formatting. Demonstrates print's flexibility with multiple arguments, custom separators, and end characters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> a = [1,2,3]; print(a[-1])  # 打印时默认末尾换行\n3\n>>> print(ans[0], ans[1])  # 可以输出任意多个变量，默认以空格间隔\n1 2\n>>> print(a[0], a[1], end='')  # 令 end='', 使末尾不换行\n1 2>>>\n>>> print(a[0], a[1], sep=', ')  # 令 sep=', '，改变间隔样式\n1, 2\n>>> print(str(a[0]) + ', ' + str(a[1]))  # 输出同上，但是手动拼接成一整个字符串\n```\n\n----------------------------------------\n\nTITLE: Optimizing Matrix Multiplication in C++\nDESCRIPTION: Demonstrates how to optimize matrix multiplication by reordering loops to improve spatial locality, which provides constant-time performance improvement while maintaining the same time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// Original implementation\nmat operator*(const mat& T) const {\n  mat res;\n  for (int i = 0; i < sz; ++i)\n    for (int j = 0; j < sz; ++j)\n      for (int k = 0; k < sz; ++k) {\n        res.a[i][j] += mul(a[i][k], T.a[k][j]);\n        res.a[i][j] %= MOD;\n      }\n  return res;\n}\n\n// Optimized implementation\nmat operator*(const mat& T) const {\n  mat res;\n  int r;\n  for (int i = 0; i < sz; ++i)\n    for (int k = 0; k < sz; ++k) {\n      r = a[i][k];\n      for (int j = 0; j < sz; ++j)\n        res.a[i][j] += T.a[k][j] * r, res.a[i][j] %= MOD;\n    }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Bloom Filter for Character Set in Rust\nDESCRIPTION: A Bloom filter implementation that uses a 64-bit integer as a bit vector to track character presence. It replaces the full alphabet table in Boyer-Moore algorithm, trading some accuracy for significant space savings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\npub struct BytesBloomFilter {\n    mask: u64,\n}\n\nimpl BytesBloomFilter {\n    pub fn new() -> Self {\n        SimpleBloomFilter {\n            mask: 0,\n        }\n    }\n\n    fn insert(&mut self, byte: &u8) {\n        (self.mask) |= 1u64 << (byte & 63);\n    }\n\n    fn contains(&self, char: &u8) -> bool {\n        (self.mask & (1u64 << (byte & 63))) != 0\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Type Annotations in Python Functions\nDESCRIPTION: This code snippet demonstrates the use of type annotations in Python functions. It shows how to annotate function parameters and return values, which can be useful for documentation and static type checking tools.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef headline(\n    text,  # type: str\n    width=80,  # type: int\n    fill_char=\"-\",  # type: str\n):  # type: (...) -> str\n    return f\"{text.title()}\".center(width, fill_char)\n\n\nprint(headline(\"type comments work\", width=40))\n```\n\n----------------------------------------\n\nTITLE: Implementing Bit-Reversal Permutation in C++ (O(n log n))\nDESCRIPTION: This function performs the bit-reversal permutation required before FFT and IFFT. It swaps elements based on their binary representation, with a time complexity of O(n log n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fft.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid change(Complex y[], int len) {\n  for (int i = 1, j = len / 2, k; i < len - 1; i++) {\n    if (i < j) swap(y[i], y[j]);\n    k = len / 2;\n    while (j >= k) {\n      j = j - k;\n      k = k / 2;\n    }\n    if (j < k) j += k;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: LaTeX Input Format Examples\nDESCRIPTION: Examples of LaTeX formatting for problem input specifications with proper variable ranges and constraints\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problemsetting.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n输入的第一行包含三个正整数 $n$, $m$, $k$ ($1\\le n,m\\le 2\\cdot 10^5$, $1\\le k\\le 100$) — $n$ 表示数列的长度，$m$ 表示操作个数，$k$ 的意义见题目描述。\n\n输入的第二行包含 $n$ 个非负整数 $a_1,a_2,\\ldots,a_n$ ($1\\le a_i\\le 10^9$) — 题目给出的数列。\n```\n\n----------------------------------------\n\nTITLE: LCM-GCD Formula\nDESCRIPTION: Application of min-max inclusion-exclusion to least common multiple and greatest common divisor relationships.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/inclusion-exclusion-principle.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\underset{i\\in S}{\\operatorname{lcm}}{x_i}=\\prod_{T\\subseteq S}{\\left(\\gcd_{j\\in T}{x_j} \\right)^{(-1)^{|T|-1}}}\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Rectangle Cover using Rotating Calipers in C++\nDESCRIPTION: This C++ code implements the Rotating Calipers algorithm to find the minimum rectangle covering all points in a convex hull. It maintains three optimal points and uses dot products and cross products to calculate the minimum area.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/rotating-calipers.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid get_biggest() {\n  int j = 3, l = 2, r = 2;\n  double t1, t2, t3, ans = 2e10;\n  for (int i = 1; i < top; ++i) {\n    while (sqr(sta[i], sta[i + 1], sta[j]) <=\n           sqr(sta[i], sta[i + 1], sta[j % top + 1]))\n      j = j % top + 1;\n    while (dot(sta[i + 1], sta[r % top + 1], sta[i]) >=\n           dot(sta[i + 1], sta[r], sta[i]))\n      r = r % top + 1;\n    if (i == 1) l = r;\n    while (dot(sta[i + 1], sta[l % top + 1], sta[i]) <=\n           dot(sta[i + 1], sta[l], sta[i]))\n      l = l % top + 1;\n    t1 = sqr(sta[i], sta[i + 1], sta[j]);\n    t2 = dot(sta[i + 1], sta[r], sta[i]) + dot(sta[i + 1], sta[l], sta[i]);\n    t3 = dot(sta[i + 1], sta[i + 1], sta[i]);\n    ans = min(ans, t1 * t2 / t3);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Edge Coloring for Bipartite Graphs in C++\nDESCRIPTION: This code demonstrates the constructive proof of Vizing's theorem for bipartite graphs. It colors the edges of a bipartite graph using a greedy algorithm that ensures the number of colors used is equal to the maximum degree of the graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/color.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 505;\nint n, m, t, color[N][N], deg[N];\nvector<int> G[N];\nint main() {\n    scanf(\"%d\", &t);\n    while (t--) {\n        scanf(\"%d%d\", &n, &m);\n        for (int i = 1; i <= n; i++) G[i].clear(), deg[i] = 0;\n        memset(color, 0, sizeof(color));\n        for (int i = 1; i <= m; i++) {\n            int u, v;\n            scanf(\"%d%d\", &u, &v);\n            G[u].push_back(v);\n            G[v].push_back(u);\n            deg[u]++, deg[v]++;\n        }\n        int maxc = 0;\n        for (int x = 1; x <= n; x++)\n            for (auto y : G[x]) {\n                int c = 1;\n                while (color[x][c] || color[y][c]) c++;\n                color[x][c] = y, color[y][c] = x;\n                maxc = max(maxc, c);\n            }\n        printf(\"%d\\n\", maxc);\n        for (int i = 1; i <= n; i++, puts(\"\"))\n            for (int j = 1; j <= maxc; j++)\n                printf(\"%d \", color[i][j]);\n    }\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Slope Optimization Transformation for Toy Box Problem\nDESCRIPTION: Mathematical transformation of the dynamic programming equation to enable slope optimization. This involves expressing the problem in terms of line slopes and intercepts, allowing for convex hull maintenance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/slope.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n考虑简化上面的状态转移方程式：令 $s_i=pre_i+i,L'=L+1$，则 $f_i=\\min_{j<i}\\{f_j+(s_i-s_j-L')^2\\}$。\n\n将与 $j$ 无关的移到外面，我们得到\n\n$$\nf_i - (s_i-L')^2=\\min_{j<i}\\{f_j+s_j^2 + 2s_j(L'-s_i) \\} \n$$\n\n考虑一次函数的斜截式 $y=kx+b$，将其移项得到 $b=y-kx$。我们将与 $j$ 有关的信息表示为 $y$ 的形式，把同时与 $i,j$ 有关的信息表示为 $kx$，把要最小化的信息（与 $i$ 有关的信息）表示为 $b$，也就是截距。具体地，设\n\n$$\n\\begin{aligned}\nx_j&=s_j\\\\\ny_j&=f_j+s_j^2\\\\\nk_i&=-2(L'-s_i)\\\\\nb_i&=f_i-(s_i-L')^2\\\\\n\\end{aligned}\n$$\n\n则转移方程就写作 $b_i = \\min_{j<i}\\{ y_j-k_ix_j \\}$。我们把 $(x_j,y_j)$ 看作二维平面上的点，则 $k_i$ 表示直线斜率，$b_i$ 表示一条过 $(x_j,y_j)$ 的斜率为 $k_i$ 的直线的截距。问题转化为了，选择合适的 $j$（$1\\le j<i$），最小化直线的截距。\n```\n\n----------------------------------------\n\nTITLE: Calculating delta1 function in Boyer-Moore algorithm\nDESCRIPTION: This pseudocode defines the delta1 function used in the Boyer-Moore algorithm. It determines the shift distance based on the presence and position of a character in the pattern string.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nint delta1(char char)\n    if char not in pat || char is last character of pat\n        return patlen\n    else\n        return patlastpos-i  // i is the rightmost position of char in pat\n```\n\n----------------------------------------\n\nTITLE: Floyd-Warshall Algorithm Optimized Implementation\nDESCRIPTION: Space-optimized version of Floyd-Warshall algorithm using 2D array. Reduces space complexity to O(N^2) while maintaining O(N^3) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nfor (k = 1; k <= n; k++) {\n  for (x = 1; x <= n; x++) {\n    for (y = 1; y <= n; y++) {\n      f[x][y] = min(f[x][y], f[x][k] + f[k][y]);\n    }\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor k in range(1, n + 1):\n    for x in range(1, n + 1):\n        for y in range(1, n + 1):\n            f[x][y] = min(f[x][y], f[x][k] + f[k][y])\n```\n\n----------------------------------------\n\nTITLE: Optimized Integer Writing Function Using Stack in C++\nDESCRIPTION: A non-recursive implementation of fast integer output using a stack to store digits. This approach offers better performance than the recursive version by reducing function call overhead.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid write(int x) {\n  static int sta[35];\n  int top = 0;\n  do {\n    sta[top++] = x % 10, x /= 10;\n  } while (x);\n  while (top) putchar(sta[--top] + 48);  // 48 是 '0'\n}\n```\n\n----------------------------------------\n\nTITLE: Function Definition and Parameter Passing in Python\nDESCRIPTION: This code demonstrates function definition in Python, including return of multiple values and the behavior of parameter passing for mutable and immutable objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef add(a, b):\n    return a + b  # 动态类型的优势，a 和 b 也可以是字符串\n\n\ndef add_no_swap(a, b):\n    print(\"in func #1:\", id(a), id(b))\n    a += b\n    b, a = a, b\n    print(\"in func #2:\", id(a), id(b))  # a, b 已交换\n    return a, b  # 返回多个值，其实就是返回元组，可以拆包接收\n\n\nlst1 = [1, 2]\nlst2 = [3, 4]\nprint(\"outside func #1:\", id(lst1), id(lst2))\nadd_no_swap(lst1, lst2)\n# 函数外 lst1, lst2 并未交换\nprint(\"outside func #2:\", id(lst1), id(lst2))\n# 不过值确实已经改变\nprint(lst1, lst2)\n```\n\n----------------------------------------\n\nTITLE: Calculating Trigonometric Functions of Polynomials in C++\nDESCRIPTION: This function calculates the sine and cosine of a polynomial using complex exponentials. It utilizes the relationship between trigonometric functions and exponentials, and implements it using modular arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/elementary-func.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int MAXN = 262144;\nconstexpr int mod = 998244353;\nconstexpr int imgunit = 86583718; /* sqrt(-1) = sqrt(998233452) */\n\nusing i64 = long long;\nusing poly_t = int[MAXN];\nusing poly = int *const;\n\nvoid polytri(const poly &h, const int n, poly &sin_t, poly &cos_t) {\n  /* sin(f) = (exp(i * f) - exp(- i * f)) / 2i */\n  /* cos(f) = (exp(i * f) + exp(- i * f)) / 2 */\n  /* tan(f) = sin(f) / cos(f) */\n  assert(h[0] == 0);\n  static poly_t tri1_t, tri2_t;\n\n  for (int i = 0; i != n; ++i) tri2_t[i] = (i64)h[i] * imgunit % mod;\n  polyexp(tri2_t, n, tri1_t);\n  polyinv(tri1_t, n, tri2_t);\n\n  if (sin_t != nullptr) {\n    const int invi = fpow(pls(imgunit, imgunit), mod - 2);\n    for (int i = 0; i != n; ++i)\n      sin_t[i] = (i64)(tri1_t[i] - tri2_t[i] + mod) * invi % mod;\n  }\n  if (cos_t != nullptr) {\n    for (int i = 0; i != n; ++i) cos_t[i] = div2(pls(tri1_t[i], tri2_t[i]));\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Absolute Value with Bitwise Operations in Python\nDESCRIPTION: A Python function that computes the absolute value of an integer using bitwise operations, which can be more efficient on some machines than the traditional conditional approach.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef Abs(n):\n    return (n ^ (n >> 31)) - (n >> 31)\n    \"\"\"\n    n>>31 取得 n 的符号，若 n 为正数，n>>31 等于 0，若 n 为负数，n>>31 等于 -1\n    若 n 为正数 n^0=n, 数不变，若 n 为负数有 n^(-1)\n    需要计算 n 和 -1 的补码，然后进行异或运算，\n    结果 n 变号并且为 n 的绝对值减 1，再减去 -1 就是绝对值\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: DGF for Multiplicative Functions in LaTeX\nDESCRIPTION: LaTeX formula showing the DGF representation for multiplicative functions using prime powers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/dgf.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\tilde{F}(x) = \\prod_{p\\in \\mathcal{P}} \\left(1 + \\frac{f_p}{p^x} + \\frac{f_{p^2}}{p^{2x}} + \\frac{f_{p^3}}{p^{3x}} + \\cdots \\right)\n$$\n```\n\n----------------------------------------\n\nTITLE: Tree Pointer Movement Functions\nDESCRIPTION: Helper functions for moving pointers in tree-based Mo's algorithm implementation. Handles updating paths between nodes while properly managing LCA nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo-on-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid move(int x, int y) {\n  if (dp[x] < dp[y]) swap(x, y);\n  while (dp[x] > dp[y]) update(x), x = fa[x];\n  while (x != y) update(x), update(y), x = fa[x], y = fa[y];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete-Min Operation for Pairing Heap in C++\nDESCRIPTION: Removes the root (minimum value) node from the pairing heap and merges its children to form a new heap.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nNode* delete_min(Node* x) {\n  Node* t = merges(x->child);\n  delete x;  // 如果需要内存回收\n  return t;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Prefix Function Implementation\nDESCRIPTION: A naive implementation of prefix function calculation using direct string comparison. Time complexity O(n^3).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/kmp.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> prefix_function(string s) {\n  int n = (int)s.length();\n  vector<int> pi(n);\n  for (int i = 1; i < n; i++)\n    for (int j = i; j >= 0; j--)\n      if (s.substr(0, j) == s.substr(i - j + 1, j)) {\n        pi[i] = j;\n        break;\n      }\n  return pi;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef prefix_function(s):\n    n = len(s)\n    pi = [0] * n\n    for i in range(1, n):\n        for j in range(i, -1, -1):\n            if s[0:j] == s[i - j + 1 : i + 1]:\n                pi[i] = j\n                break\n    return pi\n```\n\nLANGUAGE: Java\nCODE:\n```\nstatic int[] prefix_function(String s) {\n    int n = s.length();\n    int[] pi = new int[n];\n    for (int i = 1; i < n; i++) {\n\tfor (int j = i; j >= 0; j--) {\n\t    if (s.substring(0, j).equals(s.substring(i - j + 1, i + 1))) {\n\t\tpi[i] = j;\n\t\tbreak;\n\t    }\n\t}\n    }\n    return pi;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Node Structure for Pairing Heap in C++\nDESCRIPTION: Defines the basic structure of a node in a pairing heap, including the value, child pointer, and sibling pointer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Node {\n  T v;  // T为权值类型\n  Node *child, *sibling;\n  // child 指向该节点第一个儿子，sibling 指向该节点的下一个兄弟。\n  // 若该节点没有儿子/下个兄弟则指针指向 nullptr。\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Andrew's Algorithm for 2D Convex Hull in C++\nDESCRIPTION: This snippet implements Andrew's algorithm to compute the 2D convex hull of a set of points. It sorts the points, then builds the lower and upper hulls using a monotone stack approach.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/convex-hull.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// stk[] is integer, storing indices\n// p[] stores vectors or points\ntp = 0;                       // Initialize stack\nstd::sort(p + 1, p + 1 + n);  // Sort points\nstk[++tp] = 1;\n// Add first element to stack without updating used, so that 1 updates monotone stack when closing convex hull\nfor (int i = 2; i <= n; ++i) {\n  while (tp >= 2  // Next line * operator overloaded as cross product\n         && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n    used[stk[tp--]] = 0;\n  used[i] = 1;  // used indicates on convex hull\n  stk[++tp] = i;\n}\nint tmp = tp;  // tmp is size of lower hull\nfor (int i = n - 1; i > 0; --i)\n  if (!used[i]) {\n    // ↓Computing upper hull without affecting lower hull\n    while (tp > tmp && (p[stk[tp]] - p[stk[tp - 1]]) * (p[i] - p[stk[tp]]) <= 0)\n      used[stk[tp--]] = 0;\n    used[i] = 1;\n    stk[++tp] = i;\n  }\nfor (int i = 1; i <= tp; ++i)  // Copy to new array\n  h[i] = p[stk[i]];\nint ans = tp - 1;\n```\n\n----------------------------------------\n\nTITLE: Uniform Distribution Random Number Generation using random_device in C++\nDESCRIPTION: Uses random_device to generate uniformly distributed random numbers. Demonstrates the usage of random_device and uniform_int_distribution for creating a histogram of generated numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n#include <map>\n#include <random>\n#include <string>\n\nint main() {\n  std::random_device rd;\n  std::map<int, int> hist;\n  std::uniform_int_distribution<int> dist(0, 9);\n  for (int n = 0; n < 20000; ++n) {\n    ++hist[dist(rd)];\n  }\n  for (auto p : hist) {\n    std::cout << p.first << \" : \" << std::string(p.second / 100, '*') << '\\n';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Hamming Weight Increasing Sequence in C++\nDESCRIPTION: Code that generates a sequence of integers in order of increasing Hamming weight in O(n) time, useful for state compression dynamic programming to avoid redundant state enumeration.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 0; (1<<i)-1 <= n; i++) {\n    for (int x = (1<<i)-1, t; x <= n; t = x+(x&-x), x = x ? (t|((((t&-t)/(x&-x))>>1)-1)) : (n+1)) {\n        // 写下需要完成的操作\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Implementation of binarySearch0 Method in Java\nDESCRIPTION: Shows the internal implementation of the binary search algorithm used by Arrays.binarySearch(). The method returns the index of the found element or a negative number if the element is not present.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_25\n\nLANGUAGE: java\nCODE:\n```\n private static int binarySearch0(int[] a, int fromIndex, int toIndex, int key) {\n        int low = fromIndex;\n        int high = toIndex - 1;\n\n        while (low <= high) {\n            int mid = (low + high) >>> 1;\n            int midVal = a[mid];\n\n            if (midVal < key)\n                low = mid + 1;\n            else if (midVal > key)\n                high = mid - 1;\n            else\n                return mid; // key found\n        }\n        return -(low + 1);  // key not found.\n    }\n```\n\n----------------------------------------\n\nTITLE: Solving Steiner Tree Problem with Point Weights in C++\nDESCRIPTION: This code solves a variant of the Steiner tree problem where nodes have weights. It uses dynamic programming with state compression and also reconstructs the optimal path. The solution handles both merging subsets and relaxing edges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/steiner-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nconst int N = 35, M = 1234, S = 1 << 7;\nint n, m, K, root;\nint h[N], e[M], w[M], ne[M], idx;\nint key[N], a[N];\nint f[N][S];\npair<int, int> pre[N][S];\nvoid add(int a, int b, int c) {\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nvoid dfs(int u, int fa, int s) {\n    if (s == 0) return;\n    if (pre[u][s].first == 0) {\n        ans[++cnt] = u;\n        return;\n    }\n    if (pre[u][s].first == -1) {\n        int t = pre[u][s].second;\n        dfs(u, fa, t);\n        dfs(u, fa, s ^ t);\n    } else {\n        int v = pre[u][s].first;\n        dfs(v, u, s);\n        ans[++cnt] = u;\n    }\n}\nint main() {\n    memset(h, -1, sizeof h);\n    memset(f, 0x3f, sizeof f);\n    cin >> n >> K;\n    for (int i = 1; i <= n; i++) cin >> a[i];\n    cin >> m;\n    while (m--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c), add(b, a, c);\n    }\n    for (int i = 1; i <= K; i++) {\n        int x;\n        cin >> x;\n        key[x] = 1;\n    }\n    cin >> root;\n    for (int i = 1; i <= n; i++)\n        if (key[i]) f[i][1 << (i - 1)] = a[i];\n    for (int s = 1; s < 1 << n; s++) {\n        for (int i = 1; i <= n; i++) {\n            for (int s0 = (s - 1) & s; s0; s0 = (s0 - 1) & s)\n                if (f[i][s0] + f[i][s ^ s0] - a[i] < f[i][s]) {\n                    f[i][s] = f[i][s0] + f[i][s ^ s0] - a[i];\n                    pre[i][s] = {-1, s0};\n                }\n            for (int j = h[i]; ~j; j = ne[j]) {\n                int v = e[j];\n                if (f[v][s] + w[j] < f[i][s]) {\n                    f[i][s] = f[v][s] + w[j];\n                    pre[i][s] = {v, 0};\n                }\n            }\n        }\n    }\n    int ans = f[root][(1 << n) - 1];\n    cout << ans << endl;\n    dfs(root, 0, (1 << n) - 1);\n    for (int i = cnt; i; i--) cout << ans[i] << ' ';\n    cout << endl;\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Hamiltonian Cycle Detection in C++\nDESCRIPTION: An optimized approach to detect the existence of a Hamiltonian cycle in a directed graph. It uses bit manipulation to compress the state and adjacency matrix, reducing time complexity from O(n^2 * 2^n) to O((n^2/w) * 2^n), where w is the number of bits in an integer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/state.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nf_{s, i} = \\bigvee_{j\\in s, j\\neq i}f_{s \\setminus \\{i\\}, j}\\wedge g_{j, i} \\left(i\\in s\\right)\n```\n\n----------------------------------------\n\nTITLE: Installing GUIDE on Debian/Ubuntu\nDESCRIPTION: This bash script installs GUIDE 1.0.2 on Debian or Ubuntu systems. It installs required dependencies, downloads the GUIDE package, extracts it, creates a Makefile, and uses checkinstall to create and install a Debian package.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt install -y libpng12 libsm6 libice6 libxi6 libxrender1 libxrandr libfreetype6 libfontconfig1 libxext6 libx11-6 zlib1g libglib2.0-0 libglib2.0-0 libstdc++6 lib32gcc1 libc6\nwget -c http://download.noi.cn/T/noi/GUIDE-1.0.2-ubuntu.tar\ntar -xvf GUIDE-1.0.2-ubuntu.tar\ncd GUIDE-1.0.2-ubuntu\necho \"install:\\n\\tinstall -Dm755 -t /usr/bin GUIDE\\n\\tinstall -Dm644 -t /usr/share/ lang_en.qm\\n\\tmkdir -p /usr/share/apis/ && cp -r apis/* /usr/share/apis/\\n\\tmkdir -p /usr/share/doc/GUIDE/ && mkdir -p /usr/share/doc/GUIDE/html/ && cp -r doc/*  /usr/share/doc/GUIDE/html/\" > Makefile\nsudo apt install -y checkinstall\nsudo checkinstall --pkgname \"GUIDE\" --pkgversion \"1.0.2\" -y\n```\n\n----------------------------------------\n\nTITLE: Complete Solution for Lightning Conductor Problem using Quadrangle Inequality\nDESCRIPTION: Full implementation for solving the POI2011 Lightning Conductor problem using quadrangle inequality optimization. The solution uses the binary queue approach to achieve O(n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/dp/code/opt/quadrangle/quadrangle_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Solving Cyclical Quest Problem with Suffix Tree in C++\nDESCRIPTION: This code solves a problem of finding the total occurrences of all cyclic permutations of query strings in a main string. It uses a suffix tree to efficiently compute these occurrences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/suffix-tree/suffix-tree_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Solution Construction for Grid Coloring Problem in C++\nDESCRIPTION: Implements solution construction for a grid coloring problem. Traverses the hash table to find valid end states, then uses the stored previous states to reconstruct the solution backwards.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nvoid print() {\n  T_key z = 0;\n  int u;\n  REP(i, H1->sz) {\n    decode(H1->state[i]);\n    if (*max_element(b + 1, b + m + 1) <= 2) {\n      z += H1->key[i];\n      u = i;\n    }\n  }\n  cout << z << endl;\n  if (z) {\n    DWN(i, n, 0) {\n      B[i][m] = 0;\n      DWN(j, m, 0) {\n        decode(H[i][j].state[u]);\n        int cc = j == m - 1 ? c[j + 1] : c[j];\n        B[i][j] = cc ? 'o' : '#';\n        u = H[i][j].pre[u];\n      }\n    }\n    REP(i, n) puts(B[i]);\n  }\n  puts(\"\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using atan2 Function for Angle Calculation in C/C++\nDESCRIPTION: A reference to the atan2 function available in the C/C++ math library that calculates the arctangent of y/x with appropriate quadrant determination. This is used for converting from Cartesian to polar coordinates when finding the angle component.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/coordinate.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\natan2(y, x)\n```\n\n----------------------------------------\n\nTITLE: Querying Previous Value in Treap (C++)\nDESCRIPTION: This function queries the largest value in the treap that is smaller than the given value. It uses splitting and rank querying operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nint qprev(int val) {\n  auto temp = split(root, val - 1);\n  // temp.first 就是值小于 val 的子树\n  int ret = qval_by_rank(temp.first, temp.first->siz);\n  // 这里查询的是，所有小于 val 的节点里面，最大的那个的值\n  root = merge(temp.first, temp.second);\n  return ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Using String in C++\nDESCRIPTION: Shows how to use the C++ Standard Library's string class for string manipulation, including declaration and basic input/output operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string s;  // 声明 string s\n\n  std::cin >> s;  // 读入 s；\n  // 读入时会忽略开头所有空格符（空格、换行符、制表符），读入的字串直到下一个空格符为止。\n\n  std::cout << s << std::endl;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Member Access Operators in C++\nDESCRIPTION: Shows the usage of dot (.) and arrow (->) operators for accessing object and pointer members respectively.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nobj.age = 34;\nptr->age = 34;\n```\n\n----------------------------------------\n\nTITLE: Implementing 1D Range Addition and Sum Queries with Binary Indexed Trees in Python\nDESCRIPTION: Python implementation of range additions and range sum queries on a 1D array using two binary indexed trees. One tree stores the actual values while the other stores values multiplied by their indices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nt1 = [0] * MAXN\nt2 = [0] * MAXN\nn = 0\n\n\ndef lowbit(x):\n    return x & (-x)\n\n\ndef add(k, v):\n    v1 = k * v\n    while k <= n:\n        t1[k] = t1[k] + v\n        t2[k] = t2[k] + v1\n        k = k + lowbit(k)\n\n\ndef getsum(t, k):\n    ret = 0\n    while k:\n        ret = ret + t[k]\n        k = k - lowbit(k)\n    return ret\n\n\ndef add1(l, r, v):\n    add(l, v)\n    add(r + 1, -v)\n\n\ndef getsum1(l, r):\n    return (\n        (r) * getsum(t1, r)\n        - l * getsum(t1, l - 1)\n        - (getsum(t2, r) - getsum(t2, l - 1))\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementing Left Rotation in Red-Black Tree\nDESCRIPTION: Performs a left rotation on a given node in the red-black tree. Updates parent pointers and maintains relationships between nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid rotateLeft(ConstNodePtr node) {\n  // clang-format off\n  //     |                       |\n  //     N                       S\n  //    / \\     l-rotate(N)     / \\\n  //   L   S    ==========>    N   R\n  //      / \\                 / \\\n  //     M   R               L   M\n  assert(node != nullptr && node->right != nullptr);\n  // clang-format on\n  NodePtr parent = node->parent;\n  Direction direction = node->direction();\n\n  NodePtr successor = node->right;\n  node->right = successor->left;\n  successor->left = node;\n\n  // 以下的操作用于维护各个节点的`parent`指针\n  // `Direction`的定义以及`maintainRelationship`\n  // 的实现请参照文章末尾的完整示例代码\n  maintainRelationship(node);\n  maintainRelationship(successor);\n\n  switch (direction) {\n    case Direction::ROOT:\n      this->root = successor;\n      break;\n    case Direction::LEFT:\n      parent->left = successor;\n      break;\n    case Direction::RIGHT:\n      parent->right = successor;\n      break;\n  }\n\n  successor->parent = parent;\n}\n```\n\n----------------------------------------\n\nTITLE: Standard Form of Linear Programming in LaTeX\nDESCRIPTION: LaTeX code showing the standard form of a linear programming problem with matrix notation\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/simplex.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\max \\ z = CX\n\nAX = b\n\nX \\geq 0\n\nA = \n\\begin{bmatrix}\na_{11} & a_{12} & \\ldots & a_{1n}\\\\\na_{21} & a_{22} & \\ldots & a_{2n}\\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\na_{m1} & a_{m2} & \\ldots & a_{mn}\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Bitwise Shift Operations in C++\nDESCRIPTION: Demonstrates left and right bitwise shift operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nint flags = 33 << 1;\nint flags = 33 >> 1;\n```\n\n----------------------------------------\n\nTITLE: Implementing a Trie Structure in C++\nDESCRIPTION: This code snippet defines a Trie structure used as a foundation for building the General Suffix Automaton. It includes methods for initializing the Trie, inserting strings, and managing node transitions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/general-sam.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int MAXN = 2000000;\nconstexpr int CHAR_NUM = 30;\n\nstruct Trie {\n  int next[MAXN][CHAR_NUM];  // 转移\n  int tot;                   // 节点总数：[0, tot)\n\n  void init() { tot = 1; }\n\n  int insertTrie(int cur, int c) {\n    if (next[cur][c]) return next[cur][c];\n    return next[cur][c] = tot++;\n  }\n\n  void insert(const string &s) {\n    int root = 0;\n    for (auto ch : s) root = insertTrie(root, ch - 'a');\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Matrix Transformation in Simplex Method\nDESCRIPTION: LaTeX code showing matrix transformation steps in the simplex method\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/simplex.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{bmatrix}\n  {\\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\\\\n  {} & {2} & {1} & {1} & {0} & {12} \\\\\n  {} & {1} & {2} & {0} & {1} & {9} \\\\\n  {\\mathrm{C}} & {1} & {1} & {0} & {0} & {z}\n\\end{bmatrix}\\to\\begin{bmatrix}\n  {\\mathrm{X}} & {x_{1}} & {x_{2}} & {x_{3}} & {x_{4}} & {b} \\\\\n  {} & {\\frac{3}{2}} & {0} & {1} & {-\\frac{1}{2}} & {\\frac{15}{2}} \\\\\n  {} & {\\frac{1}{2}} & {1} & {0} & {\\frac{1}{2}} & {\\frac{9}{2}} \\\\\n  {\\mathrm{C}} & {\\frac{1}{2}} & {0} & {0} & {-\\frac{1}{2}} & {z-\\frac{9}{2}}\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Calculating Inversions Using Fenwick Tree\nDESCRIPTION: Implementation of counting inversions in a permutation using a Fenwick Tree (Binary Indexed Tree) with O(n log n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/permutation.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/permutation/inversion_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: DLX Recover Column Operation Implementation\nDESCRIPTION: Implements the recover() operation that restores a previously removed column and its related elements back into the Dancing Links structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvoid recover(const int &c) {\n  int i, j;\n  IT(i, U, c) IT(j, L, i) U[D[j]] = D[U[j]] = j, ++siz[col[j]];\n  L[R[c]] = R[L[c]] = c;\n}\n```\n\n----------------------------------------\n\nTITLE: File I/O Operations in Python\nDESCRIPTION: This code snippet demonstrates file reading and writing operations in Python using the 'with' statement. It shows how to read data from a file line by line and write data to a file.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\na = []\nwith open(\"in.txt\") as f:\n    N = int(f.readline())  # 读入第一行的 N\n    a[len(a) :] = [[int(x) for x in f.readline().split()] for i in range(N)]\n\nwith open(\"out.txt\", \"w\") as f:\n    f.write(\"1\\n\")\n```\n\n----------------------------------------\n\nTITLE: Using shuffle for Random Permutation in C++\nDESCRIPTION: Demonstrates how to use the shuffle function to randomly permute elements in a container. It uses a Mersenne Twister random number generator seeded with a random device.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// #include <random>\nstd::mt19937 rng(std::random_device{}());\nstd::shuffle(v.begin(), v.end(), rng);\n```\n\n----------------------------------------\n\nTITLE: Basic Fraction Finding in Stern-Brocot Tree with Python\nDESCRIPTION: Python implementation of the naive algorithm for finding a fraction in a Stern-Brocot tree. The algorithm traverses the tree by comparing the target fraction with nodes and moving left or right accordingly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef find(p, q):\n    a, b, c, d = 0, 1, 1, 0\n    path = \"\"\n    while a + c != p or b + d != q:\n        if (a + c) * q < p * (b + d):\n            path += \"R\"\n            a += c\n            b += d\n        else:\n            path += \"L\"\n            c += a\n            d += b\n    return path\n```\n\n----------------------------------------\n\nTITLE: Multiplicative Inverse Coefficient Recursion\nDESCRIPTION: Recursive formula for calculating coefficients of the multiplicative inverse of a power series.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_3\n\nLANGUAGE: Mathematics\nCODE:\n```\nf^{-1}_0=\\dfrac{1}{f_0},f^{-1}_n=\\dfrac{-1}{f_0}\\sum_{k=0}^{n-1}f^{-1}_kf_{n-k}\n```\n\n----------------------------------------\n\nTITLE: Defining Node Structure with Parent Pointer for Pairing Heap in C++\nDESCRIPTION: Extends the basic node structure to include a parent pointer, which is necessary for the decrease-key operation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pairing-heap.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nstruct Node {\n  LL v;\n  int id;\n  Node *child, *sibling;\n  Node *father;  // 新增：父指针，若该节点为根节点则指向空节点 nullptr\n};\n```\n\n----------------------------------------\n\nTITLE: DFT Complex Number Implementation\nDESCRIPTION: Discrete Fourier Transform implementation for complex numbers with bit reversal and butterfly operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid dft_for_complex(std::vector<comp> &f, int n, int b) {\n  static std::vector<comp> w;\n  w.resize(n);\n  for (int i = 0; i < n; ++i)\n    if (i < rev[i]) std::swap(f[i], f[rev[i]]);\n  for (int i = 2; i <= n; i <<= 1) {\n    w[0] = comp(1, 0), w[1] = comp(cos(2 * PI / i), b * sin(2 * PI / i));\n    for (int j = 2; j < i / 2; ++j) w[j] = w[j - 1] * w[1];\n    for (int j = 0; j < n; j += i)\n      for (int k = 0; k < i / 2; ++k) {\n        comp p = f[j + k], q = f[j + k + i / 2] * w[k];\n        f[j + k] = p + q, f[j + k + i / 2] = p - q;\n      }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Slope Optimization Algorithm Template\nDESCRIPTION: A general algorithm template for applying slope optimization to dynamic programming problems. This outlines the steps for maintaining a convex hull and finding the optimal decision points.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/slope.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n概括一下上述斜率优化模板题的算法：\n\n1.  将初始状态入队。\n2.  每次使用一条和 $i$ 相关的直线 $f(i)$ 去切维护的凸包，找到最优决策，更新 $dp_i$。\n3.  加入状态 $dp_i$。如果一个状态（即凸包上的一个点）在 $dp_i$ 加入后不再是凸包上的点，需要在 $dp_i$ 加入前将其剔除。\n```\n\n----------------------------------------\n\nTITLE: Pollard-Rho Algorithm with Floyd Cycle Detection in C++\nDESCRIPTION: Implementation of the Pollard-Rho algorithm with Floyd's cycle detection method. This function attempts to find a non-trivial factor of N by using a pseudorandom function and detecting cycles in the generated sequence.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nll Pollard_Rho(ll N) {\n  ll c = rand() % (N - 1) + 1;\n  ll t = f(0, c, N);\n  ll r = f(f(0, c, N), c, N);\n  while (t != r) {\n    ll d = gcd(abs(t - r), N);\n    if (d > 1) return d;\n    t = f(t, c, N);\n    r = f(f(r, c, N), c, N);\n  }\n  return N;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MSD Radix Sort for Strings in C++\nDESCRIPTION: This code implements an iterative MSD radix sort algorithm for sorting null-terminated byte strings (NTBS) based on lexicographical order. It uses a stack to manage the recursion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/radix-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <stack>\n#include <tuple>\n#include <vector>\n\nusing std::copy;  // from <algorithm>\nusing std::make_tuple;\nusing std::stack;\nusing std::tie;\nusing std::tuple;\nusing std::vector;\n\nusing NTBS = char*;  // 空终止字节字符串\nusing NTBSptr = NTBS*;\n\nvoid MSD_radix_sort(NTBSptr first, NTBSptr last) {\n  static constexpr size_t W = 128;\n  static constexpr size_t logW = 7;\n  static constexpr size_t mask = W - 1;\n\n  NTBSptr tmp = (NTBSptr)calloc(last - first, sizeof(NTBS));\n\n  using node = tuple<NTBSptr, NTBSptr, size_t>;\n  stack<node, vector<node>> s;\n  s.push(make_tuple(first, last, 0));\n\n  while (!s.empty()) {\n    NTBSptr begin, end;\n    size_t index, length;\n\n    tie(begin, end, index) = s.top();\n    length = end - begin;\n    s.pop();\n\n    if (begin + 1 >= end) continue;  // elements <= 1\n\n    // 计数排序\n    size_t cnt[W] = {};\n    auto key = [](const NTBS str, const size_t index) { return str[index]; };\n\n    for (NTBSptr it = begin; it != end; ++it) ++cnt[key(*it, index)];\n    for (char ch = 1; value < W; ++value) cnt[ch] += cnt[ch - 1];\n\n    // 求完前缀和后，计算相同关键字的元素范围\n    // 对于 NTBS，如果此刻末尾的字符是 \\0 则说明这两个字符串相等，不必继续迭代\n    for (char ch = 1; ch < W; ++ch)\n      s.push(make_tuple(begin + cnt[ch - 1], begin + cnt[ch], index + 1));\n\n    NTBSptr it = end;\n    do {\n      --it;\n      --cnt[key(*it, index)];\n      tmp[cnt[key(*it, index)]] = *it;\n    } while (it != begin);\n\n    copy(tmp, tmp + length, begin);\n  }\n\n  free(tmp);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Minimum Steiner Tree Algorithm in C++\nDESCRIPTION: This code implements a dynamic programming solution for finding the minimum Steiner tree in a graph. It uses state compression to represent subsets of vertices and iterates through all possible subsets to find the optimal solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/steiner-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst int N = 510, M = 1e4 + 10;\nint n, m, k;\nint h[N], e[M], ne[M], w[M], idx;\nint f[N][1 << 11], key[N];\nvoid add(int a, int b, int c) {\n    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;\n}\nint main() {\n    memset(h, -1, sizeof h);\n    memset(f, 0x3f, sizeof f);\n    cin >> n >> m >> k;\n    for (int i = 1; i <= k; i++) {\n        int x;\n        cin >> x;\n        key[x] = 1;\n        f[x][1 << (i - 1)] = 0;\n    }\n    while (m--) {\n        int a, b, c;\n        cin >> a >> b >> c;\n        add(a, b, c), add(b, a, c);\n    }\n    for (int s = 1; s < 1 << k; s++) {\n        for (int i = 1; i <= n; i++) {\n            for (int s0 = s; s0; s0 = (s0 - 1) & s)\n                f[i][s] = min(f[i][s], f[i][s0] + f[i][s ^ s0]);\n            for (int j = h[i]; ~j; j = ne[j])\n                f[e[j]][s] = min(f[e[j]][s], f[i][s] + w[j]);\n        }\n    }\n    int ans = 0x3f3f3f3f;\n    for (int i = 1; i <= n; i++) ans = min(ans, f[i][(1 << k) - 1]);\n    cout << ans << endl;\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Schreier-Sims Algorithm Main Procedure (Pseudocode)\nDESCRIPTION: The main procedure of the Schreier-Sims algorithm, which iteratively builds the stabilizer chain by adding generators to the structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_3\n\nLANGUAGE: pseudocode\nCODE:\n```\n\\begin{array}{l}\n\\textbf{Algorithm }\\textrm{SchreierSims}(S):\\\\\n\\textbf{Input. }\\textrm{A generating set }S\\textrm{ for a group }G.\\\\\n\\textbf{Output. }\\textrm{The stabilizer chain }C\\textrm{ for the group }G.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1  & C \\leftarrow []\\\\\n2  & \\textbf{for }s\\in S\\\\\n3  & \\qquad C \\leftarrow \\textrm{Extend}(C,s)\\\\\n4  & \\textbf{end for}\\\\\n5  & \\textbf{return }C\n\\end{array}\n\\end{array}\n```\n\n----------------------------------------\n\nTITLE: Implementing Memoized LIS (Longest Increasing Subsequence) in Python\nDESCRIPTION: A memoization implementation in Python for the Longest Increasing Subsequence problem. This demonstrates the conversion of a DP equation to a memoized recursive function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef dfs(i):\n    if mem[i] != -1:\n        return mem[i]\n    ret = 1\n    for j in range(1, i):\n        if a[j] < a[i]:\n            ret = max(ret, dfs(j) + 1)\n    mem[i] = ret\n    return mem[i]\n```\n\n----------------------------------------\n\nTITLE: Initializing Scapegoat Tree Node Information in C++\nDESCRIPTION: Defines the basic node information needed for a scapegoat tree, including tree structure, node values, and subtree sizes. The push_up function updates node information after changes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint id, rt, lc[N], rc[N], tot[N], tot_active;\nint val[N], cnt[N], sz[N];\n\nvoid push_up(int x) {\n  sz[x] = sz[lc[x]] + cnt[x] + sz[rc[x]];\n  tot[x] = tot[lc[x]] + 1 + tot[rc[x]];\n}\n```\n\n----------------------------------------\n\nTITLE: 一条路径问题状态转移 (C++)\nDESCRIPTION: 一条路径问题的状态转移代码实现。相比回路问题，需额外处理独立插头的生成、合并与消失，并记录这类事件发生的次数，最多不超过两次。包含权值最大化的路径搜索逻辑。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nREP(i, n) {\n  REP(j, m) {\n    checkMax(ans, A[i][j]);  // 需要单独处理一个格子的情况\n    if (!A[i][j]) continue;  // 如果有障碍，则跳过，注意这时状态数组不需要滚动\n    swap(H0, H1);\n    REP(c, 3)\n    H1[c].clear();  // c 表示生成和消失事件发生的总次数，最多不超过 2 次\n    REP(c, 3) REP(ii, H0[c].sz) {\n      decode(H0[c].state[ii]);\n      d = H0[c].key[ii] + A[i][j];\n      int lt = b[j], up = b[j + 1];\n      bool dn = A[i + 1][j], rt = A[i][j + 1];\n      if (lt && up) {\n        if (lt == up) {  // 在一条路径问题中，我们不能合并相同的插头。\n          // Cannot deploy here...\n        } else {  // 有可能参与合并的两者中有独立插头，但是也可以用同样的代码片段处理\n          REP(i, m + 1) if (b[i] == lt) b[i] = up;\n          push(c, j, 0, 0);\n        }\n      } else if (lt || up) {\n        int t = lt | up;\n        if (dn) {\n          push(c, j, t, 0);\n        }\n        if (rt) {\n          push(c, j, 0, t);\n        }\n        // 一个插头消失的情况，如果是独立插头则意味着消失，如果是成对出现的插头则相当于生成了一个独立插头，\n        // 无论哪一类事件都需要将 c + 1。\n        if (c < 2) {\n          push(c + 1, j, 0, 0);\n        }\n      } else {\n        d -= A[i][j];\n        H1[c].push(H0[c].state[ii]);\n        d += A[i][j];    // 跳过插头生成，本题中不要求全部覆盖\n        if (dn && rt) {  // 生成一对插头\n          push(c, j, m, m);\n        }\n        if (c < 2) {  // 生成一个独立插头\n          if (dn) {\n            push(c + 1, j, m, 0);\n          }\n          if (rt) {\n            push(c + 1, j, 0, m);\n          }\n        }\n      }\n    }\n  }\n  REP(c, 3) H1[c].roll();  // 一行结束，调整轮廓线\n}\n```\n\n----------------------------------------\n\nTITLE: Bracket Sequence Mo's Algorithm Implementation\nDESCRIPTION: Complete implementation of Mo's algorithm using bracket sequence encoding for tree traversal. Handles path queries with color values and updates. Uses DFS traversal to convert tree to sequence.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo-on-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nconstexpr int MAXN = 200010;\n\nint f[MAXN], g[MAXN], id[MAXN], head[MAXN], cnt, last[MAXN], dep[MAXN],\n    fa[MAXN][22], v[MAXN], w[MAXN];\nint block, index, n, m, q;\nint pos[MAXN], col[MAXN], app[MAXN];\nbool vis[MAXN];\nlong long ans[MAXN], cur;\n\nstruct edge {\n  int to, nxt;\n} e[MAXN];\n\nint cnt1 = 0, cnt2 = 0;  // timestamps\n\nstruct query {\n  int l, r, t, id;\n\n  bool operator<(const query &b) const {\n    return (pos[l] < pos[b.l]) || (pos[l] == pos[b.l] && pos[r] < pos[b.r]) ||\n           (pos[l] == pos[b.l] && pos[r] == pos[b.r] && t < b.t);\n  }\n} a[MAXN], b[MAXN];\n\n// ... rest of implementation ...\n```\n\n----------------------------------------\n\nTITLE: Using Lambda to Control Variable Lifecycle in C++\nDESCRIPTION: This example demonstrates using a lambda to control the lifecycle of large temporary objects in a solution function. The lambda's scope ensures resources are freed immediately after calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nvoid solution(const vector<int>& input) {\n  int b = [&] {\n    vector<int> large_objects(input.size());\n    int c = 0;\n\n    for (int i = 0; i < large_objects.size(); ++i)\n      large_objects[i] = i + input[i];\n\n    for (int i = 0; i < input.size(); ++i) c += large_objects[input[i]];\n\n    return c;\n  }();\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Passing with Pointers in C++\nDESCRIPTION: Implementation of swap function using pointers in C++, equivalent to Pascal's var parameter. This demonstrates how to modify variables passed to a function using pointer dereferencing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_15\n\nLANGUAGE: Pascal\nCODE:\n```\nvar a, b: integer;\n\nprocedure swap(var x,y:integer);\nvar temp:integer;\nbegin\n    temp := x;\n    x := y;\n    y := temp;\nend;\n\nbegin\n    a := 10; b:= 20;    \n    swap(a, b);\n    writeln(a, ' ', b);\nend.\n```\n\nLANGUAGE: C++\nCODE:\n```\n// 使用指针的代码\n#include <iostream>\n\nvoid swap(int* x, int* y) {\n  int temp;\n  temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nint main() {\n  int a = 10, b = 20;\n  swap(&a, &b);\n  std::cout << a << \" \" << b;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Void Function with Return Statement in C++\nDESCRIPTION: Demonstrates a function with no return value (void) that uses a return statement to exit early. The code after the return statement will not be executed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvoid say_hello() {\n  cout << \"hello!\\n\";\n  cout << \"hello!\\n\";\n  cout << \"hello!\\n\";\n  return;\n  cout << \"hello!\\n\";  // 这条语句不会被执行\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delaunay Triangulation in C++\nDESCRIPTION: A complete C++ implementation of Delaunay triangulation using divide-and-conquer algorithm. Includes point and edge data structures, geometric utilities, and the main Delaunay class with triangulation logic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/triangulation.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <list>\n#include <utility>\n#include <vector>\n\nconstexpr double EPS = 1e-8;\nconstexpr int MAXV = 10000;\n\nstruct Point {\n  double x, y;\n  int id;\n\n  Point(double a = 0, double b = 0, int c = -1) : x(a), y(b), id(c) {}\n\n  bool operator<(const Point &a) const {\n    return x < a.x || (fabs(x - a.x) < EPS && y < a.y);\n  }\n\n  bool operator==(const Point &a) const {\n    return fabs(x - a.x) < EPS && fabs(y - a.y) < EPS;\n  }\n\n  double dist2(const Point &b) {\n    return (x - b.x) * (x - b.x) + (y - b.y) * (y - b.y);\n  }\n};\n\n// ... [Rest of the implementation code] ...\n```\n\n----------------------------------------\n\nTITLE: Implementing a Map using Red-Black Tree in C++\nDESCRIPTION: A complete implementation of a Map data structure using Red-Black Tree as the underlying data structure. This implementation ensures ordered keys with efficient insertion, deletion, and lookup operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/rbtree/RBTreeMap.hpp\"\n```\n\n----------------------------------------\n\nTITLE: Range-Based For Loop Equivalent Code in C++\nDESCRIPTION: Demonstrates the underlying code equivalent to a range-based for loop, using standard iterators. This shows how the syntax sugar is implemented internally.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nauto&& __range = range_expression;\nfor (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) {\n  range_declaration = *__begin;\n  loop_statement\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lucas' Theorem in C++\nDESCRIPTION: A C++ implementation of Lucas' theorem for calculating combination numbers modulo a prime. It preprocesses factorials and their inverses modulo p, allowing O(1) calculation of individual combination numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lucas.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconst int N = 1e6 + 5;\nconst int MOD = 1e9 + 7;\n\nlong long fac[N], inv[N];\n\nlong long qpow(long long a, long long b) {\n  long long res = 1;\n  while (b) {\n    if (b & 1) res = res * a % MOD;\n    a = a * a % MOD;\n    b >>= 1;\n  }\n  return res;\n}\n\nvoid init() {\n  fac[0] = 1;\n  for (int i = 1; i < N; ++i) fac[i] = fac[i - 1] * i % MOD;\n  inv[N - 1] = qpow(fac[N - 1], MOD - 2);\n  for (int i = N - 2; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % MOD;\n}\n\nlong long C(int n, int m) {\n  if (m < 0 || m > n) return 0;\n  return fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\n\nlong long lucas(long long n, long long m) {\n  if (m == 0) return 1;\n  return C(n % MOD, m % MOD) * lucas(n / MOD, m / MOD) % MOD;\n}\n\nint main() {\n  init();\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    long long n, m;\n    scanf(\"%lld%lld\", &n, &m);\n    printf(\"%lld\\n\", lucas(n, m));\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Namespace Usage Example in C++\nDESCRIPTION: Example demonstrating namespace usage in a competitive programming problem solution. Shows how to organize code using namespaces for better readability and debugging.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// NOI 2018 屠龙勇士 40分部分分代码\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nlong long n, m, a[100005], p[100005], aw[100005], atk[100005];\n\nnamespace one_game {\n// 其实namespace里也可以声明变量\nvoid solve() {\n  for (int y = 0;; y++)\n    if ((a[1] + p[1] * y) % atk[1] == 0) {\n      cout << (a[1] + p[1] * y) / atk[1] << endl;\n      return;\n    }\n}\n}  // namespace one_game\n\nnamespace p_1 {\nvoid solve() {\n  if (atk[1] == 1) {  // solve 1-2\n    sort(a + 1, a + n + 1);\n    cout << a[n] << endl;\n    return;\n  } else if (m == 1) {  // solve 3-4\n    long long k = atk[1], kt = ceil(a[1] * 1.0 / k);\n    for (int i = 2; i <= n; i++)\n      k = aw[i - 1], kt = max(kt, (long long)ceil(a[i] * 1.0 / k));\n    cout << k << endl;\n  }\n}\n}  // namespace p_1\n```\n\n----------------------------------------\n\nTITLE: Querying Sum in Segment Tree using C++\nDESCRIPTION: This function queries the sum of a range [l,r] in the segment tree. It recursively breaks down the query range into smaller segments that match the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint getsum(int l, int r, int s, int t, int p) {\n  // [l, r] 为查询区间, [s, t] 为当前节点包含的区间, p 为当前节点的编号\n  if (l <= s && t <= r)\n    return d[p];  // 当前区间为询问区间的子集时直接返回当前区间的和\n  int m = s + ((t - s) >> 1), sum = 0;\n  if (l <= m) sum += getsum(l, r, s, m, p * 2);\n  // 如果左儿子代表的区间 [s, m] 与询问区间有交集, 则递归查询左儿子\n  if (r > m) sum += getsum(l, r, m + 1, t, p * 2 + 1);\n  // 如果右儿子代表的区间 [m + 1, t] 与询问区间有交集, 则递归查询右儿子\n  return sum;\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Next Node in Treap (C++)\nDESCRIPTION: This function queries the first node with a value larger than the given value in a treap. It is similar to the previous function but with reversed comparisons.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nint _query_nex(Node *cur, int val) {\n  if (val >= cur->val) {\n    if (cur->ch[1] != nullptr) return _query_nex(cur->ch[1], val);\n  } else {\n    q_nex_tmp = cur->val;\n    if (cur->ch[0] != nullptr) _query_nex(cur->ch[0], val);\n    return q_nex_tmp;\n  }\n  return NIL;\n}\n```\n\n----------------------------------------\n\nTITLE: Lagrange's Identity for Cross Products\nDESCRIPTION: Lagrange's identity expresses the dot product of two cross products in terms of dot products of the original vectors. This important identity has applications in physics and engineering.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\n(\\boldsymbol a \\times \\boldsymbol b) \\cdot (\\boldsymbol c \\times \\boldsymbol d)=(\\boldsymbol a \\cdot \\boldsymbol c)(\\boldsymbol b \\cdot \\boldsymbol d)-(\\boldsymbol a \\cdot \\boldsymbol d)(\\boldsymbol b \\cdot \\boldsymbol c)\n```\n\n----------------------------------------\n\nTITLE: Definition of a Subring in Ring Theory\nDESCRIPTION: A formal definition of a subring, describing when a subset of a ring also forms a ring with the same operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"子环\"\n    对于环 $(R,+,\\cdot)$ 和它的子集 $S$，如果 $(S,+,\\cdot)$ 也是一个环，则称 $S$ 是 $R$ 的 **子环**（subring）。\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Elements in C++\nDESCRIPTION: Demonstrates how to access and modify array elements using the subscript operator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\narray[4] = 2;\n```\n\n----------------------------------------\n\nTITLE: Binary Tree Root Finding Algorithm in C++\nDESCRIPTION: Solution to CF750F that finds the root of a binary tree through limited queries using DFS and BFS approaches. Handles complex edge cases and query limitations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/interaction.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\nconstexpr int N = 256 + 5;\nint T, h, chance;\nbool ok;\nvector<int> to[N], path;\n\nbool read(int x) {\n  if (to[x].empty()) {\n    printf(\"? %d\\n\", x), fflush(stdout);\n    int k, t;\n    scanf(\"%d\", &k);\n    if (k == 0) exit(0);\n    for (int i = 0; i < k; i++) {\n      scanf(\"%d\", &t);\n      to[x].push_back(t);\n    }\n    if (k == 2) {\n      printf(\"! %d\\n\", x), fflush(stdout);\n      return ok = true;\n    }\n    chance--;\n  }\n  return false;\n}\n\nbool dfs(int x) {\n  if (to[x].empty()) path.push_back(x);\n  if (read(x)) return true;\n  for (int i : to[x])\n    if (to[i].empty()) return dfs(i);\n  return false;\n}\n\nvoid bfs(int s, int k) {\n  queue<int> q;\n  for (int i : to[s])\n    if (to[i].empty()) q.push(i);\n  for (int i = 1; i < k; i++) {\n    int x = q.front();\n    q.pop();\n    if (read(x)) return;\n    for (int j : to[x])\n      if (to[j].empty()) q.push(j);\n  }\n  for (int i = 1; i < k; i++) {\n    int x = q.front();\n    q.pop();\n    if (read(x)) return;\n  }\n  printf(\"! %d\\n\", q.front()), fflush(stdout);\n}\n\nint main() {\n  for (scanf(\"%d\", &T); T--;) {\n    ok = false;\n    for (int i = 0; i < N; i++) to[i].clear();\n    chance = 16;\n    scanf(\"%d\", &h);\n    if (h == 0) exit(0);\n    vector<int> long_path;\n    if (read(1)) continue;\n    int root, dep;\n    if (to[1].size() == 1)\n      root = 1, dep = h;\n    else {\n      for (int i : to[1]) {\n        path.clear();\n        if (dfs(i)) break;\n        if (path.size() > long_path.size()) swap(path, long_path);\n      }\n      if (ok) continue;\n      dep = h - (path.size() + long_path.size()) / 2;\n      root = long_path.at((long_path.size() - (h - dep)) - 1);\n    }\n    while ((1 << (dep - 1)) - 2 > chance) {\n      path.clear();\n      if (dfs(root)) break;\n      dep = h - (h - dep + path.size()) / 2;\n      root = path.at((path.size() - (h - dep)) - 1);\n    }\n    if (!ok) bfs(root, 1 << (dep - 2));\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Minimum Rectangle Cover using Rotating Calipers in Python\nDESCRIPTION: This Python code implements the Rotating Calipers algorithm to find the minimum rectangle covering all points in a convex hull. It maintains three optimal points and uses dot products and cross products to calculate the minimum area.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/rotating-calipers.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef get_biggest():\n    j = 3\n    l = 2\n    r = 2\n    ans = 2e10\n    for i in range(1, top):\n        while sqr(sta[i], sta[i + 1], sta[j]) <= sqr(\n            sta[i], sta[i + 1], sta[j % top + 1]\n        ):\n            j = j % top + 1\n        while dot(sta[i + 1], sta[r % top + 1], sta[i]) >= dot(\n            sta[i + 1], sta[r], sta[i]\n        ):\n            r = r % top + 1\n        if i == 1:\n            l = r\n        while dot(sta[i + 1], sta[l % top + 1], sta[i]) <= dot(\n            sta[i + 1], sta[l], sta[i]\n        ):\n            l = l % top + 1\n        t1 = sqr(sta[i], sta[i + 1], sta[j])\n        t2 = dot(sta[i + 1], sta[r], sta[i]) + dot(sta[i + 1], sta[l], sta[i])\n        t3 = dot(sta[i + 1], sta[i + 1], sta[i])\n        ans = min(ans, t1 * t2 / t3)\n```\n\n----------------------------------------\n\nTITLE: Solving String Substring Problem with Suffix Tree in C++\nDESCRIPTION: This code solves a problem of finding the maximum product of length and occurrence count for substrings occurring more than once in a given string. It uses a suffix tree to efficiently compute this value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/suffix-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/string/code/suffix-tree/suffix-tree_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Building Initial DLX Structure in C++\nDESCRIPTION: Initializes a Dancing Links structure with r rows and c columns. Creates a circular doubly-linked list for column headers and initializes necessary arrays.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid build(const int &r, const int &c) {\n  n = r, m = c;\n  for (int i = 0; i <= c; ++i) {\n    L[i] = i - 1, R[i] = i + 1;\n    U[i] = D[i] = i;\n  }\n  L[0] = c, R[c] = 0, idx = c;\n  memset(first, 0, sizeof(first));\n  memset(siz, 0, sizeof(siz));\n}\n```\n\n----------------------------------------\n\nTITLE: Priority Queue Usage Example in C++\nDESCRIPTION: Demonstrates priority queue operations including push, pop, top, and size with different underlying containers and comparators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nstd::priority_queue<int> q1;\nstd::priority_queue<int, std::vector<int>> q2;\n// C++11 后空格可省略\nstd::priority_queue<int, std::deque<int>, std::greater<int>> q3;\n// q3 为小根堆\nfor (int i = 1; i <= 5; i++) q1.push(i);\n// q1 中元素 :  [1, 2, 3, 4, 5]\nstd::cout << q1.top() << std::endl;\n// 输出结果 : 5\nq1.pop();\n// 堆中元素 : [1, 2, 3, 4]\nstd::cout << q1.size() << std::endl;\n// 输出结果 ：4\nfor (int i = 1; i <= 5; i++) q3.push(i);\n// q3 中元素 :  [1, 2, 3, 4, 5]\nstd::cout << q3.top() << std::endl;\n// 输出结果 : 1\n```\n\n----------------------------------------\n\nTITLE: Java Control Flow Examples\nDESCRIPTION: Comprehensive examples of Java control flow statements including if, if-else, if-else-if, switch-case, for loops, while and do-while loops.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nclass Test {\n    public static void main(String[] args) {\n        if ( /* 判断条件 */ ){\n            // 条件成立时执行这里面的代码\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Boyer-Moore-Sunday Algorithm in Rust\nDESCRIPTION: Implementation of the Sunday variant of Boyer-Moore that looks at the character following the pattern alignment. Generally provides better average performance than both original BM and Horspool variants.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub struct SundayPattern<'a> {\n    pat_bytes: &'a [u8],\n    sunday_bc: [usize; 256],\n}\n\nimpl<'a> SundayPattern<'a> {\n    fn build_sunday_bc(p: &'a [u8]) -> [usize; 256] {\n        let mut sunday_bc_table = [p.len() + 1; 256];\n\n        for i in 0..p.len() {\n            sunday_bc_table[p[i] as usize] = p.len() - i;\n        }\n\n        sunday_bc_table\n    }\n\n    pub fn find_all(&self, string: &str) -> Vec<usize> {\n        let mut result = vec![];\n        let string_bytes = string.as_bytes();\n        let pat_last_pos = self.pat_bytes.len() - 1;\n        let stringlen = string_bytes.len();\n        let mut string_index = pat_last_pos;\n\n        while string_index < stringlen {\n            if &string_bytes[string_index - pat_last_pos..string_index+1] == self.pat_bytes {\n                result.push(string_index - pat_last_pos);\n            }\n\n            if string_index + 1 == stringlen {\n                break;\n            }\n\n            string_index += self.sunday_bc[string_bytes[string_index + 1] as usize];\n        }\n\n        result\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Counting Simple Cycles in a Graph using Dynamic Programming (C++)\nDESCRIPTION: This code implements a dynamic programming approach to count simple cycles in a graph. It uses bitmasks to represent visited node sets and iterates through possible paths, accumulating the count of valid cycles.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/rings-count.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 19;\nint n, m, ans;\nll f[1 << N][N];\nbool e[N][N];\nint main() {\n  cin >> n >> m;\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    e[u][v] = e[v][u] = 1;\n  }\n  for (int i = 0; i < n; i++) f[1 << i][i] = 1;\n  for (int s = 1; s < 1 << n; s++)\n    for (int i = 0; i < n; i++)\n      if (s >> i & 1)\n        for (int j = 0; j < n; j++)\n          if (!(s >> j & 1) && e[i][j]) {\n            f[s | 1 << j][j] += f[s][i];\n            if ((s & -s) == 1 << i && __builtin_popcount(s) > 2)\n              ans += f[s][i];\n          }\n  cout << (ans - m) / 2 << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Pisano Period of Fibonacci Sequence in C++\nDESCRIPTION: Implementation for calculating the Pisano period (cycle length of Fibonacci sequence modulo m). The function decomposes the modulus into prime factors and uses mathematical properties to determine the period. Note that this computes a period, not necessarily the minimal period.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/fibonacci.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstruct prime {\n  unsigned long long p;\n  int times;\n};\n\nstruct prime pp[2048];\nint pptop;\n\nunsigned long long get_cycle_from_mod(\n    unsigned long long mod)  // 这里求解的只是周期，不一定是最小正周期\n{\n  pptop = 0;\n  srand(time(nullptr));\n  while (n != 1) {\n    __int128_t factor = (__int128_t)10000000000 * 10000000000;\n    min_factor(mod, &factor);  // 计算最小素因数\n    struct prime temp;\n    temp.p = factor;\n    for (temp.times = 0; mod % factor == 0; temp.times++) {\n      mod /= factor;\n    }\n    pp[pptop] = temp;\n    pptop++;\n  }\n  unsigned long long m = 1;\n  for (int i = 0; i < pptop; ++i) {\n    int g;\n    if (pp[i].p == 2) {\n      g = 3;\n    } else if (pp[i].p == 5) {\n      g = 20;\n    } else if (pp[i].p % 5 == 1 || pp[i].p % 5 == 4) {\n      g = pp[i].p - 1;\n    } else {\n      g = (pp[i].p + 1) << 1;\n    }\n    m = lcm(m, g * qpow(pp[i].p, pp[i].times - 1));\n  }\n  return m;\n}\n```\n\n----------------------------------------\n\nTITLE: Representing Quadratic Algebraic Numbers in LaTeX\nDESCRIPTION: LaTeX formula for representing quadratic algebraic numbers in the form a + b√d, where a and b are rational numbers and d is an integer with no square factors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quadratic.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\na+b\\sqrt{d}\n```\n\n----------------------------------------\n\nTITLE: List Methods Implementation in Java\nDESCRIPTION: Demonstrates common List operations using ArrayList and LinkedList with time complexity comparisons for add, get, set operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_8\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static List<Integer> array = new ArrayList<>();\n    static List<Integer> linked = new LinkedList<>();\n\n    static void add() {\n        array.add(1);  // 时间复杂度为 O(1) \n        linked.add(1);  // 时间复杂度为 O(1) \n    }\n\n    static void get() {\n        array.get(10);  // 时间复杂度为 O(1) \n        linked.get(10);  // 时间复杂度为 O(11) \n    }\n\n    static void addIdx() {\n        array.add(0, 2);  // 最坏情况下时间复杂度为 O(n)\n        linked.add(0, 2);  // 最坏情况下时间复杂度为 O(n)\n    }\n\n    static void size() {\n        array.size();  // 时间复杂度为 O(1)\n        linked.size();  // 时间复杂度为 O(1)\n    }\n\n    static void set() {  // 该方法返回值为原本该位置元素的值\n        array.set(0, 1);  // 时间复杂度为 O(1)\n        linked.set(0, 1);  // 最坏时间复杂度为 O(n)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting Nodes from Left-Leaning Trees in C++\nDESCRIPTION: Implements node deletion in left-leaning trees by merging the left and right children and updating the dist values upwards in the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/leftist-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }\n\nint merge(int x, int y) {\n  if (!x || !y) return x | y;\n  if (t[x].val < t[y].val) swap(x, y);\n  int& rs_ref = rs(x);\n  rs_ref = merge(rs_ref, y);\n  t[rs_ref].fa = x;\n  t[x].d = t[rs(x)].d + 1;\n  return x;\n}\n\nvoid pushup(int x) {\n  if (!x) return;\n  if (t[x].d != t[rs(x)].d + 1) {\n    t[x].d = t[rs(x)].d + 1;\n    pushup(t[x].fa);\n  }\n}\n\nvoid erase(int x) {\n  int y = merge(t[x].ch[0], t[x].ch[1]);\n  t[y].fa = t[x].fa;\n  if (t[t[x].fa].ch[0] == x)\n    t[t[x].fa].ch[0] = y;\n  else if (t[t[x].fa].ch[1] == x)\n    t[t[x].fa].ch[1] = y;\n  pushup(t[y].fa);\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Hamming Weight using Lowbit in C++\nDESCRIPTION: A function that calculates the Hamming weight (popcount) of an integer using the lowbit operation, useful in tree-based data structures and optimized bit counting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_18\n\nLANGUAGE: C++\nCODE:\n```\n// 求 x 的汉明权重\nint popcount(int x) {\n    int cnt = 0;\n    while (x) {\n        cnt++;\n        x -= x & -x;\n    }\n    return cnt;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dijkstra's Algorithm with Naive Approach in C++\nDESCRIPTION: A naive implementation of Dijkstra's algorithm with O(n²) time complexity. This approach directly searches for the vertex with the minimum distance in the T set after each edge relaxation operation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/shortest-path.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstruct edge {\n  int v, w;\n};\n\nvector<edge> e[MAXN];\nint dis[MAXN], vis[MAXN];\n\nvoid dijkstra(int n, int s) {\n  memset(dis, 0x3f, (n + 1) * sizeof(int));\n  dis[s] = 0;\n  for (int i = 1; i <= n; i++) {\n    int u = 0, mind = 0x3f3f3f3f;\n    for (int j = 1; j <= n; j++)\n      if (!vis[j] && dis[j] < mind) u = j, mind = dis[j];\n    vis[u] = true;\n    for (auto ed : e[u]) {\n      int v = ed.v, w = ed.w;\n      if (dis[v] > dis[u] + w) dis[v] = dis[u] + w;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Augmenting Path and LCA Finding in C++\nDESCRIPTION: Implements functions for augmenting paths in the matching and finding the lowest common ancestor (LCA) of two nodes in the alternating tree. These are core operations in the blossom algorithm for expanding matchings and identifying blossoms.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid augment(int u, int v) {\n  // 把u和u的祖先全部增广，并设(u,v)为匹配边\n  for (;;) {\n    int xnv = st[match[u]];\n    set_match(u, v);\n    if (!xnv) return;\n    set_match(xnv, st[pa[xnv]]);\n    u = st[pa[xnv]];\n    v = xnv;\n  }\n}\n\nint get_lca(int u, int v) {\n  // 找出u,v在交错树上的lca\n  static int t = 0;\n  for (++t; u || v; swap(u, v)) {\n    if (u == 0) continue;\n    if (vis[u] == t) return u;\n    vis[u] = t;  // 这种方法可以不用清空vis数组\n    u = st[match[u]];\n    if (u) u = st[pa[u]];\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive DFS in Python\nDESCRIPTION: This snippet shows a recursive implementation of Depth First Search in Python. It uses an adjacency list to represent the graph and a boolean list to track visited nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dfs.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# adj : List[List[int]] 邻接表\n# vis : List[bool] 记录节点是否已经遍历\n\n\ndef dfs(u: int) -> None:\n    vis[u] = True\n    for v in adj[u]:\n        if not vis[v]:\n            dfs(v)\n```\n\n----------------------------------------\n\nTITLE: Implementing Segment Tree Merge Operation in C++\nDESCRIPTION: Recursive function to merge two segment trees. Takes two tree nodes (a and b) and their range (l to r) as parameters. Returns the merged tree node. Uses dynamic node allocation and handles empty nodes by returning the non-empty counterpart.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-merge-split.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint merge(int a, int b, int l, int r) {\n  if (!a) return b;\n  if (!b) return a;\n  if (l == r) {\n    // do something...\n    return a;\n  }\n  int mid = (l + r) >> 1;\n  tr[a].l = merge(tr[a].l, tr[b].l, l, mid);\n  tr[a].r = merge(tr[a].r, tr[b].r, mid + 1, r);\n  pushup(a);\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: LeetCode 437: Path Sum III Header File\nDESCRIPTION: Header file for the Path Sum III LeetCode problem, defining the TreeNode structure and the pathSum function signature.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstruct TreeNode {\n  int val;\n  TreeNode *left;\n  TreeNode *right;\n  TreeNode() : val(0), left(nullptr), right(nullptr) {}\n  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n  TreeNode(int x, TreeNode *left, TreeNode *right)\n      : val(x), left(left), right(right) {}\n};\n\nint pathSum(TreeNode *root, int sum);\n```\n\n----------------------------------------\n\nTITLE: Calculating Eulerian Numbers Using Recursion in C++\nDESCRIPTION: A recursive implementation for computing Eulerian numbers in C++. The function handles base cases where m ≥ n or n = 0 (returning 0), and m = 0 (returning 1), then applies the recursive formula for other cases.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/eulerian.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint eulerianNumber(int n, int m) {\n  if (m >= n || n == 0) return 0;\n  if (m == 0) return 1;\n  return (((n - m) * eulerianNumber(n - 1, m - 1)) +\n          ((m + 1) * eulerianNumber(n - 1, m)));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SplitUp2 Operation in ETT\nDESCRIPTION: Bottom-up split operation that divides a treap into two parts based on a node position. Returns two treaps where one contains nodes with positions less than or equal to p, and the other contains nodes with positions greater than p.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/ett.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstatic std::pair<Node*, Node*> SplitUp2(Node* p) {\n  Node *a = nullptr, *b = nullptr;\n  b = p->right_;\n  if (b) b->parent_ = nullptr;\n  p->right_ = nullptr;\n\n  bool is_p_left_child_of_parent = false;\n  bool is_from_left_child = false;\n  while (p) {\n    Node* parent = p->parent_;\n\n    if (parent) {\n      is_p_left_child_of_parent = (parent->left_ == p);\n      if (is_p_left_child_of_parent) {\n        parent->left_ = nullptr;\n      } else {\n        parent->right_ = nullptr;\n      }\n      p->parent_ = nullptr;\n    }\n\n    if (!is_from_left_child) {\n      a = Merge(p, a);\n    } else {\n      b = Merge(b, p);\n    }\n\n    is_from_left_child = is_p_left_child_of_parent;\n    p->Maintain();\n    p = parent;\n  }\n\n  return {a, b};\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Sum of LCM Problem using Möbius Inversion in C++\nDESCRIPTION: This code implements a solution to the BZOJ 2154 problem, calculating the sum of LCM(i,j) for 1≤i≤n and 1≤j≤m using Möbius inversion and number-theoretic functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/mobius/mobius_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Handling Case 1 in Red-Black Tree Deletion\nDESCRIPTION: Handles the case where the node to be deleted has both left and right children. Finds the successor, swaps data with the node to be deleted, and proceeds to delete the successor instead.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// clang-format off\n// Case 1: If the node is strictly internal\n//   Step 1. Find the successor S with the smallest key\n//           and its parent P on the right subtree.\n//   Step 2. Swap the data (key and value) of S and N,\n//           S is the node that will be deleted in place of N.\n//   Step 3. N = S, goto Case 2, 3\n//     |                    |\n//     N                    S\n//    / \\                  / \\\n//   L  ..   swap(N, S)   L  ..\n//       |   =========>       |\n//       P                    P\n//      / \\                  / \\\n//     S  ..                N  ..\n// clang-format on\n\n// Step 1\nNodePtr successor = node->right;\nNodePtr parent = node;\nwhile (successor->left != nullptr) {\n  parent = successor;\n  successor = parent->left;\n}\n// Step 2\nswapNode(node, successor);\nmaintainRelationship(parent);\n// Step 3: vvv\n```\n\n----------------------------------------\n\nTITLE: Uninitialized Variable Behavior in C++\nDESCRIPTION: This code demonstrates the unpredictable behavior of uninitialized variables in C++. An uninitialized variable can contain any value and may lead to unexpected results, especially when optimization is enabled.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nint main() {\n  int a;\n  std::cout << std::boolalpha << (a < 0 || a == 0 || a > 0);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting a Specific Bit in Python\nDESCRIPTION: A Python function that sets a specific bit of an integer to 1 while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_14\n\nLANGUAGE: Python\nCODE:\n```\n# 将 a 的第 b 位设置为 1 ，最低位编号为 0\ndef setBit(a, b):\n    return a | (1 << b)\n```\n\n----------------------------------------\n\nTITLE: 0-1 BFS Example Implementation - C++\nDESCRIPTION: Implementation of 0-1 BFS for solving a laser beam problem from Codeforces 173B.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/bfs.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/graph/code/bfs/bfs_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Finding Permutation from Rank\nDESCRIPTION: Algorithm to reconstruct a permutation given its lexicographical rank using Lehmer code and factorial number system.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/permutation.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/permutation/rank_perm.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda Using Function Pointer in C++\nDESCRIPTION: This technique uses a static function pointer for recursion when the lambda doesn't capture any variables. The lambda is converted to a function pointer and can reference itself through the pointer.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nstatic unsigned (*fptr)(unsigned);\n\nstatic const auto lambda = [](const unsigned a) {\n  return a < 2 ? a : (*fptr)(a - 2) + (*fptr)(a - 1);\n};\n\nstatic auto init = [] {\n  fptr = +lambda;\n  // Or\n  // fptr = static_cast<unsigned (*)(unsigned)>(lambda);\n  return 0;\n}();\n\ncout << lambda(10);\n```\n\n----------------------------------------\n\nTITLE: Initializing TreeSet in Java\nDESCRIPTION: Shows how to initialize TreeSet objects with default ascending and custom descending order comparators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_14\n\nLANGUAGE: java\nCODE:\n```\nTreeSet<Integer> s3 = new TreeSet<>();\nTreeSet<Integer> s4 = new TreeSet<>((x, y) -> {return y - x;});  // 降序\n```\n\n----------------------------------------\n\nTITLE: Minimum Diameter Spanning Tree Construction in C++\nDESCRIPTION: This code implements the full algorithm for finding the Minimum Diameter Spanning Tree. It first finds the absolute center of the graph, then constructs the spanning tree using shortest paths from the center.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/mdst.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <climits>\n#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int MAXN = 502;\nusing ll = long long;\nusing pii = pair<int, int>;\nll d[MAXN][MAXN], dd[MAXN][MAXN], rk[MAXN][MAXN], val[MAXN];\nconstexpr ll INF = 1e17;\nint n, m;\n\nbool cmp(int a, int b) { return val[a] < val[b]; }\n\nvoid floyd() {\n  for (int k = 1; k <= n; k++)\n    for (int i = 1; i <= n; i++)\n      for (int j = 1; j <= n; j++) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nstruct node {\n  ll u, v, w;\n} a[MAXN * (MAXN - 1) / 2];\n\nvoid solve() {\n  // 求图的绝对中心\n  floyd();\n  for (int i = 1; i <= n; i++) {\n    for (int j = 1; j <= n; j++) {\n      rk[i][j] = j;\n      val[j] = d[i][j];\n    }\n    sort(rk[i] + 1, rk[i] + 1 + n, cmp);\n  }\n  ll P = 0, ansP = INF;\n  // 在点上\n  for (int i = 1; i <= n; i++) {\n    if (d[i][rk[i][n]] * 2 < ansP) {\n      ansP = d[i][rk[i][n]] * 2;\n      P = i;\n    }\n  }\n  // 在边上\n  int f1 = 0, f2 = 0;\n  ll disu = INT_MIN, disv = INT_MIN, ansL = INF;\n  for (int i = 1; i <= m; i++) {\n    ll u = a[i].u, v = a[i].v, w = a[i].w;\n    for (int p = n, i = n - 1; i >= 1; i--) {\n      if (d[v][rk[u][i]] > d[v][rk[u][p]]) {\n        if (d[u][rk[u][i]] + d[v][rk[u][p]] + w < ansL) {\n          ansL = d[u][rk[u][i]] + d[v][rk[u][p]] + w;\n          f1 = u, f2 = v;\n          disu = (d[u][rk[u][i]] + d[v][rk[u][p]] + w) / 2 - d[u][rk[u][i]];\n          disv = w - disu;\n        }\n        p = i;\n      }\n    }\n  }\n  cout << min(ansP, ansL) / 2 << '\\n';\n  // 最小路径生成树\n  vector<pii> pp;\n  for (int i = 1; i <= 501; ++i)\n    for (int j = 1; j <= 501; ++j) dd[i][j] = INF;\n  for (int i = 1; i <= 501; ++i) dd[i][i] = 0;\n  if (ansP <= ansL) {\n    for (int j = 1; j <= n; j++) {\n      for (int i = 1; i <= m; ++i) {\n        ll u = a[i].u, v = a[i].v, w = a[i].w;\n        if (dd[P][u] + w == d[P][v] && dd[P][u] + w < dd[P][v]) {\n          dd[P][v] = dd[P][u] + w;\n          pp.push_back({u, v});\n        }\n        u = a[i].v, v = a[i].u, w = a[i].w;\n        if (dd[P][u] + w == d[P][v] && dd[P][u] + w < dd[P][v]) {\n          dd[P][v] = dd[P][u] + w;\n          pp.push_back({u, v});\n        }\n      }\n    }\n    for (auto [x, y] : pp) cout << x << ' ' << y << '\\n';\n  } else {\n    d[n + 1][f1] = disu;\n    d[f1][n + 1] = disu;\n    d[n + 1][f2] = disv;\n    d[f2][n + 1] = disv;\n    a[m + 1].u = n + 1, a[m + 1].v = f1, a[m + 1].w = disu;\n    a[m + 2].u = n + 1, a[m + 2].v = f2, a[m + 2].w = disv;\n    n += 1;\n    m += 2;\n    floyd();\n    P = n;\n    for (int j = 1; j <= n; j++) {\n      for (int i = 1; i <= m; ++i) {\n        ll u = a[i].u, v = a[i].v, w = a[i].w;\n        if (dd[P][u] + w == d[P][v] && dd[P][u] + w < dd[P][v]) {\n          dd[P][v] = dd[P][u] + w;\n          pp.push_back({u, v});\n        }\n        u = a[i].v, v = a[i].u, w = a[i].w;\n        if (dd[P][u] + w == d[P][v] && dd[P][u] + w < dd[P][v]) {\n          dd[P][v] = dd[P][u] + w;\n          pp.push_back({u, v});\n        }\n      }\n    }\n    cout << f1 << ' ' << f2 << '\\n';\n    for (auto [x, y] : pp)\n      if (x != n && y != n) cout << x << ' ' << y << '\\n';\n  }\n}\n\nvoid init() {\n  for (int i = 1; i <= 501; ++i)\n    for (int j = 1; j <= 501; ++j) d[i][j] = INF;\n  for (int i = 1; i <= 501; ++i) d[i][i] = 0;\n}\n\nint main() {\n  init();\n  cin >> n >> m;\n  for (int i = 1; i <= m; ++i) {\n    ll u, v, w;\n    cin >> u >> v >> w;\n    w *= 2;\n    d[u][v] = w, d[v][u] = w;\n    a[i].u = u, a[i].v = v, a[i].w = w;\n  }\n  solve();\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Jordan Block Structure\nDESCRIPTION: The structure of a Jordan block, showing the characteristic diagonal of eigenvalues with ones on the superdiagonal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_12\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{pmatrix}\n\\lambda & 1 & 0 & \\cdots & 0 & 0\\\\\n0 & \\lambda & 1 & \\cdots & 0 & 0\\\\\n0 & 0 & \\lambda & \\cdots & 0 & 0\\\\\n\\vdots & \\vdots & \\vdots &  & \\vdots & \\vdots\\\\\n0 & 0 & 0 & \\cdots & \\lambda & 1\\\\\n0 & 0 & 0 & \\cdots & 0 & \\lambda\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Implementing Segment Treap with Interval Operations in C++\nDESCRIPTION: This code snippet implements a segment Treap data structure in C++ that supports interval operations such as range reversal. It uses pointers and includes split and merge operations, as well as a method to handle lazy propagation for interval updates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_20\n\nLANGUAGE: C++\nCODE:\n```\n// author: (ttzytt)[ttzytt.com]\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\nusing namespace std;\n\n// 参考：https://www.cnblogs.com/Equinox-Flower/p/10785292.html\nstruct Node {\n  Node* ch[2];\n  int val, prio;\n  int cnt;\n  int siz;\n  bool to_rev = false;  // 需要把这个子树下的每一个节点都翻转过来\n\n  Node(int _val) : val(_val), cnt(1), siz(1) {\n    ch[0] = ch[1] = nullptr;\n    prio = rand();\n  }\n\n  int upd_siz() {\n    siz = cnt;\n    if (ch[0] != nullptr) siz += ch[0]->siz;\n    if (ch[1] != nullptr) siz += ch[1]->siz;\n    return siz;\n  }\n\n  void pushdown() {\n    swap(ch[0], ch[1]);\n    if (ch[0] != nullptr) ch[0]->to_rev ^= 1;\n    // 如果原来子节点也要翻转，那两次翻转就抵消了，如果子节点不翻转，那这个\n    //  tag 就需要继续被 push 到子节点上\n    if (ch[1] != nullptr) ch[1]->to_rev ^= 1;\n    to_rev = false;\n  }\n\n  void check_tag() {\n    if (to_rev) pushdown();\n  }\n};\n\nstruct Seg_treap {\n  Node* root;\n#define siz(_) (_ == nullptr ? 0 : _->siz)\n\n  pair<Node*, Node*> split(Node* cur, int sz) {\n    // 按照树的大小划分\n    if (cur == nullptr) return {nullptr, nullptr};\n    cur->check_tag();\n    if (sz <= siz(cur->ch[0])) {\n      // 左边的子树就够了\n      auto temp = split(cur->ch[0], sz);\n      // 左边的子树不一定全部需要，temp.second 是不需要的\n      cur->ch[0] = temp.second;\n      cur->upd_siz();\n      return {temp.first, cur};\n    } else {\n      // 左边的加上右边的一部分（当然也包括这个节点本身）\n      auto temp = split(cur->ch[1], sz - siz(cur->ch[0]) - 1);\n      cur->ch[1] = temp.first;\n      cur->upd_siz();\n      return {cur, temp.second};\n    }\n  }\n\n  Node* merge(Node* sm, Node* bg) {\n    // small, big\n    if (sm == nullptr && bg == nullptr) return nullptr;\n    if (sm != nullptr && bg == nullptr) return sm;\n    if (sm == nullptr && bg != nullptr) return bg;\n    sm->check_tag(), bg->check_tag();\n    if (sm->prio < bg->prio) {\n      sm->ch[1] = merge(sm->ch[1], bg);\n      sm->upd_siz();\n      return sm;\n    } else {\n      bg->ch[0] = merge(sm, bg->ch[0]);\n      bg->upd_siz();\n      return bg;\n    }\n  }\n\n  void insert(int val) {\n    auto temp = split(root, val);\n    auto l_tr = split(temp.first, val - 1);\n    Node* new_node;\n    if (l_tr.second == nullptr) new_node = new Node(val);\n    Node* l_tr_combined =\n        merge(l_tr.first, l_tr.second == nullptr ? new_node : l_tr.second);\n    root = merge(l_tr_combined, temp.second);\n  }\n\n  void seg_rev(int l, int r) {\n    // 这里的 less 和 more 是相对于 l 的\n    auto less = split(root, l - 1);\n    // 所有小于等于 l - 1 的会在 less 的左边\n    auto more = split(less.second, r - l + 1);\n    // 拿出从 l 开始的前 r - l + 1 个\n    more.first->to_rev = true;\n    root = merge(less.first, merge(more.first, more.second));\n  }\n\n  void print(Node* cur) {\n    if (cur == nullptr) return;\n    cur->check_tag();\n    print(cur->ch[0]);\n    cout << cur->val << \" \";\n    print(cur->ch[1]);\n  }\n};\n\nSeg_treap tr;\n\nint main() {\n  srand(time(nullptr));\n  int n, m;\n  cin >> n >> m;\n  for (int i = 1; i <= n; i++) tr.insert(i);\n  while (m--) {\n    int l, r;\n    cin >> l >> r;\n    tr.seg_rev(l, r);\n  }\n  tr.print(tr.root);\n}\n```\n\n----------------------------------------\n\nTITLE: Optimality Pruning DFS Template in C++\nDESCRIPTION: DFS template with optimality pruning to skip branches that cannot lead to better solutions than the current best.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/opt.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint ans = 最坏情况, now;\n\nvoid dfs(传入数值) {\n  if (now比ans的答案还要差) return;\n  if (到达目的地) ans = 从当前解与已有解中选最优;\n  for (遍历所有可能性)\n    if (可行) {\n      进行操作;\n      dfs(缩小规模);\n      撤回操作;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting and Deleting in C++ String\nDESCRIPTION: Demonstrates the use of insert() and erase() functions to modify std::string content.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nstring s = \"OI Wiki\", t = \" Wiki\";\nchar u = '!';\ns.erase(2);\nprintf(\"从字符串 s 的第三位开始删去所有字符后得到的字符串是 %s\\n\", s.c_str());\ns.insert(2, t);\nprintf(\"在字符串 s 的第三位处插入字符串 t 后得到的字符串是 %s\\n\", s.c_str());\ns.insert(7, 3, u);\nprintf(\"在字符串 s 的第八位处连续插入 3 次字符串 u 后得到的字符串是 %s\",\n       s.c_str());\n```\n\n----------------------------------------\n\nTITLE: Java Input Handling with Scanner\nDESCRIPTION: Demonstrates how to use Scanner class to handle command-line input for different data types in Java.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_6\n\nLANGUAGE: java\nCODE:\n```\npackage org.oiwiki.tutorial;\n\nimport java.util.Scanner;\n\nclass Test {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in); // System.in 是输入流\n        int a = scan.nextInt();\n        double b = scan.nextDouble();\n        String c = scan.nextLine();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Prime Power Factorial Modulo\nDESCRIPTION: Implementation of factorial calculation modulo prime powers using Wilson's theorem generalization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/factorial.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/factorial/fact-mod-pa.cpp:4:21\"\n```\n\n----------------------------------------\n\nTITLE: File Renaming Commands\nDESCRIPTION: Shell commands for batch renaming files in Windows and Linux environments\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/arbiter.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n# Windows command\nren *.out *.ans\n\n# Linux commands\nsudo apt install rename\nrename 's/\\.out/\\.ans/' *\nrename 's/atmost/test/' *.ans\n```\n\n----------------------------------------\n\nTITLE: Computing Fibonacci Numbers with Matrix Exponentiation in C++\nDESCRIPTION: An implementation that uses matrix exponentiation to efficiently compute the nth Fibonacci number mod 10^9+7, suitable for very large values of n (up to 10^18).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int mod = 1000000007;\n\nstruct Matrix {\n  int a[3][3];\n\n  Matrix() { memset(a, 0, sizeof a); }\n\n  Matrix operator*(const Matrix &b) const {\n    Matrix res;\n    for (int i = 1; i <= 2; ++i)\n      for (int j = 1; j <= 2; ++j)\n        for (int k = 1; k <= 2; ++k)\n          res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;\n    return res;\n  }\n} ans, base;\n\nvoid init() {\n  base.a[1][1] = base.a[1][2] = base.a[2][1] = 1;\n  ans.a[1][1] = ans.a[1][2] = 1;\n}\n\nvoid qpow(int b) {\n  while (b) {\n    if (b & 1) ans = ans * base;\n    base = base * base;\n    b >>= 1;\n  }\n}\n\nint main() {\n  int n = read();\n  if (n <= 2) return puts(\"1\"), 0;\n  init();\n  qpow(n - 2);\n  println(ans.a[1][1] % mod);\n}\n```\n\n----------------------------------------\n\nTITLE: Block Sieve Implementation for Counting Primes in C++\nDESCRIPTION: This implementation uses block sieving to count prime numbers up to n. It divides the range into blocks of size S, which improves cache efficiency and reduces memory usage to O(sqrt(n) + S) while maintaining the same time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint count_primes(int n) {\n  constexpr static int S = 10000;\n  vector<int> primes;\n  int nsqrt = sqrt(n);\n  vector<char> is_prime(nsqrt + 1, true);\n  for (int i = 2; i <= nsqrt; i++) {\n    if (is_prime[i]) {\n      primes.push_back(i);\n      for (int j = i * i; j <= nsqrt; j += i) is_prime[j] = false;\n    }\n  }\n  int result = 0;\n  vector<char> block(S);\n  for (int k = 0; k * S <= n; k++) {\n    fill(block.begin(), block.end(), true);\n    int start = k * S;\n    for (int p : primes) {\n      int start_idx = (start + p - 1) / p;\n      int j = max(start_idx, p) * p - start;\n      for (; j < S; j += p) block[j] = false;\n    }\n    if (k == 0) block[0] = block[1] = false;\n    for (int i = 0; i < S && start + i <= n; i++) {\n      if (block[i]) result++;\n    }\n  }\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Basic Lvalue References in C++\nDESCRIPTION: This snippet demonstrates the basic usage of lvalue references in C++. It shows how references act as aliases to existing objects, allowing modifications through the reference to affect the original object.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string s = \"Ex\";\n  std::string& r1 = s;\n  const std::string& r2 = s;\n\n  r1 += \"ample\";  // 修改 r1，即修改了 s\n  // r2 += \"!\"; // 错误：不能通过到 const 的引用修改\n  std::cout << r2 << '\\n';  // 打印 r2，访问了s，输出 \"Example\"\n}\n```\n\n----------------------------------------\n\nTITLE: Loop Optimization with SCEV in C++\nDESCRIPTION: Demonstrates how the Scalar Evolution (SCEV) analysis can transform a loop into a constant-time mathematical formula. LLVM-based compilers can optimize this summation to O(1) complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint test(int n) {\n  int ans = 1;\n  for (int i = 0; i < n; i++) {\n    ans += i * (i + 1);\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-recursive FFT in C++ (Method 1)\nDESCRIPTION: This function implements the Fast Fourier Transform (FFT) and its inverse (IFFT) using the butterfly operation method. It supports both DFT (on=1) and IDFT (on=-1) operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fft.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid fft(Complex y[], int len, int on) {\n  change(y, len);\n  for (int h = 2; h <= len; h <<= 1) {\n    Complex wn(cos(2 * PI / h), sin(on * 2 * PI / h));\n    for (int j = 0; j < len; j += h) {\n      Complex w(1, 0);\n      for (int k = j; k < j + h / 2; k++) {\n        Complex u = y[k];\n        Complex t = w * y[k + h / 2];\n        y[k] = u + t;\n        y[k + h / 2] = u - t;\n        w = w * wn;\n      }\n    }\n  }\n  if (on == -1) {\n    for (int i = 0; i < len; i++) {\n      y[i].x /= len;\n      y[i].y /= len;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bottom-Up Merge Sort in Python\nDESCRIPTION: An iterative Python implementation of merge sort using the bottom-up approach. It starts with single-element segments and merges adjacent segments, doubling the segment size in each iteration.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef merge_sort(a):\n    seg = 1\n    while seg < len(a):\n        for l1 in range(0, len(a) - seg, seg + seg):\n            r1 = l1 + seg\n            l2 = r1\n            r2 = l2 + seg\n            a[l1:r2] = merge(a[l1:r1], a[l2:r2])\n        seg <<= 1\n```\n\n----------------------------------------\n\nTITLE: Implementing Variadic Max Function with Recursive Expansion in C++\nDESCRIPTION: This snippet demonstrates how to create a variadic max function using recursive parameter pack expansion. It handles any number of arguments greater than or equal to 1, comparing them to find the maximum value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_19\n\nLANGUAGE: cpp\nCODE:\n```\n// 递归终止函数\n// C++20中，使用 auto 也可以定义模板，即「简写函数模板」\nauto max(auto a) { return a; }\n\n// 声明等价于\n// template<typename T>\n// auto max(T);\n\n// 展开参数包的递归函数\nauto max(auto first, auto... rest) {\n  const auto second = max(rest...);\n  return first > second ? first : second;\n}\n\n// 声明等价于\n// template<typename First, typename... Rest>\n// auto max(First, Rest...);\n\n// int b = max(1, \"abc\");         // 编译不通过，没有 > 操作符能接受 int 和\n// const char* 类型\nint c = max(1, 233);              // 233\nint d = max(1, 233, 666, 10086);  // 10086\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Chairman Tree Operations in C++\nDESCRIPTION: Complete implementation of a Chairman Tree including initialization, building, updating, and querying operations. The code demonstrates how to handle range queries for finding the kth smallest element in a given range using persistent segment trees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent-seg.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\nconstexpr int MAXN = 1e5;  // 数据范围\nint tot, n, m;\nint sum[(MAXN << 5) + 10], rt[MAXN + 10], ls[(MAXN << 5) + 10],\n    rs[(MAXN << 5) + 10];\nint a[MAXN + 10], ind[MAXN + 10], len;\n\nint getid(const int &val) {  // 离散化\n  return lower_bound(ind + 1, ind + len + 1, val) - ind;\n}\n\nint build(int l, int r) {  // 建树\n  int root = ++tot;\n  if (l == r) return root;\n  int mid = l + r >> 1;\n  ls[root] = build(l, mid);\n  rs[root] = build(mid + 1, r);\n  return root;  // 返回该子树的根节点\n}\n\nint update(int k, int l, int r, int root) {  // 插入操作\n  int dir = ++tot;\n  ls[dir] = ls[root], rs[dir] = rs[root], sum[dir] = sum[root] + 1;\n  if (l == r) return dir;\n  int mid = l + r >> 1;\n  if (k <= mid)\n    ls[dir] = update(k, l, mid, ls[dir]);\n  else\n    rs[dir] = update(k, mid + 1, r, rs[dir]);\n  return dir;\n}\n\nint query(int u, int v, int l, int r, int k) {  // 查询操作\n  int mid = l + r >> 1,\n      x = sum[ls[v]] - sum[ls[u]];  // 通过区间减法得到左儿子中所存储的数值个数\n  if (l == r) return l;\n  if (k <= x)  // 若 k 小于等于 x ，则说明第 k 小的数字存储在在左儿子中\n    return query(ls[u], ls[v], l, mid, k);\n  else  // 否则说明在右儿子中\n    return query(rs[u], rs[v], mid + 1, r, k - x);\n}\n\nvoid init() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n  memcpy(ind, a, sizeof ind);\n  sort(ind + 1, ind + n + 1);\n  len = unique(ind + 1, ind + n + 1) - ind - 1;\n  rt[0] = build(1, len);\n  for (int i = 1; i <= n; ++i) rt[i] = update(getid(a[i]), 1, len, rt[i - 1]);\n}\n\nint l, r, k;\n\nvoid work() {\n  while (m--) {\n    scanf(\"%d%d%d\", &l, &r, &k);\n    printf(\"%d\\n\", ind[query(rt[l - 1], rt[r], 1, len, k)]);  // 回答询问\n  }\n}\n\nint main() {\n  init();\n  work();\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Constexpr Usage Example in C++\nDESCRIPTION: Shows basic usage of constexpr for compile-time constant expressions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int a = 10;  // 直接定义常量\n\nconstexpr int FivePlus(int x) { return 5 + x; }\n\nvoid test(const int x) {\n  std::array<x> c1;            // 错误，x在编译时不可知\n  std::array<FivePlus(6)> c2;  // 可行，FivePlus编译时可知\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Angle Between Two Lines in 3D Space (LaTeX)\nDESCRIPTION: Provides the formula for calculating the cosine of the angle between two lines in 3D space, given their direction vectors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/3d.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n$$\ncos \\varphi = \\dfrac{\\left | m_1m_2+n_1n_2+p_1p_2 \\right |}{\\sqrt{m_1^2+n_1^2+p_1^2}\\sqrt{m_2^2+n_2^2+p_2^2}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Improved Delta2 Table Builder Implementation in Rust\nDESCRIPTION: An optimized implementation of the delta2 table builder using prefix functions. Has O(n) time complexity and O(n) space complexity. Handles all cases of pattern repetitions correctly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::cmp::PartialEq;\nuse std::cmp::min;\n\npub fn build_delta_2_table_improved_minghu6(p: &[impl PartialEq]) -> Vec<usize> {\n    let patlen = p.len();\n    let lastpos = patlen - 1;\n    let mut delta_2 = Vec::with_capacity(patlen);\n\n    for i in 0..patlen {\n        delta_2.push(lastpos * 2 - i);\n    }\n\n    let pi = compute_pi(p);\n    let mut i = lastpos;\n    let mut last_i = lastpos;\n    while pi[i] > 0 {\n        let start;\n        let end;\n\n        if i == lastpos {\n            start = 0;\n        } else {\n            start = patlen - pi[last_i];\n        }\n\n        end = patlen - pi[i];\n\n        for j in start..end {\n            delta_2[j] = lastpos * 2 - j - pi[i];\n        }\n\n        last_i = i;\n        i = pi[i] - 1;\n    }\n\n    let mut j = lastpos;\n    let mut t = patlen;\n    let mut f = pi;\n    loop {\n        f[j] = t;\n        while t < patlen && p[j] != p[t] {\n            delta_2[t] = min(delta_2[t], lastpos - 1 - j);\n            t = f[t];\n        }\n\n        t -= 1;\n        if j == 0 {\n            break;\n        }\n        j -= 1;\n    }\n\n    delta_2[lastpos] = 0;\n\n    delta_2\n}\n```\n\n----------------------------------------\n\nTITLE: Naive DP Implementation for Toy Box Problem\nDESCRIPTION: A standard dynamic programming approach to solve the toy box packing problem with quadratic cost function. This approach has O(n²) time complexity which is too slow for the given constraints.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/slope.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n令 $f_i$ 表示前 $i$ 个物品，分若干段的最小代价。\n\n状态转移方程：$f_i=\\min_{j<i}\\{f_j+(i-(j+1)+pre_i-pre_j-L)^2\\}=\\min_{j<i}\\{f_j+(pre_i-pre_j+i-j-1-L)^2\\}$。\n\n其中 $pre_i$ 表示前 $i$ 个数的和，即 $\\sum_{j=1}^i c_j$。\n\n该做法的时间复杂度为 $O(n^2)$，无法解决本题。\n```\n\n----------------------------------------\n\nTITLE: Const Parameters in Function Declarations\nDESCRIPTION: Shows how to use const parameters in functions to prevent modifications and improve code safety.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvoid sum(const std::vector<int> &data, int &total) {\n  for (auto iter = data.begin(); iter != data.end(); ++iter)\n    total += *iter;  // iter 是迭代器，解引用后的类型是 const int\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Code for HNOI2004 L Language Problem\nDESCRIPTION: Full implementation of the solution for P2292 [HNOI2004] L Language problem using AC automaton with state compression optimization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/ac-automaton/ac_automaton_luoguP2292.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Ordered Partitions Using Counting DP\nDESCRIPTION: Dynamic programming approach to count the number of ways to partition an integer n into k positive integers, where order matters. The recurrence relation sums over all possible values of the last element.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/count.md#2025-04-22_snippet_0\n\nLANGUAGE: mathematical notation\nCODE:\n```\nf_{n,k} = \\sum_{i=1}^{n-k+1} f_{n-i,k-1}\n```\n\n----------------------------------------\n\nTITLE: Implementing Segment Tree Split Operation in C++\nDESCRIPTION: Function to split a segment tree by extracting a range [l,r]. Takes current node pointers (p,q) and range bounds as parameters. Creates a new tree with the extracted range while removing it from the original tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-merge-split.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid split(int &p, int &q, int s, int t, int l, int r) {\n  if (t < l || r < s) return;\n  if (!p) return;\n  if (l <= s && t <= r) {\n    q = p;\n    p = 0;\n    return;\n  }\n  if (!q) q = New();\n  int m = s + t >> 1;\n  if (l <= m) split(ls[p], ls[q], s, m, l, r);\n  if (m < r) split(rs[p], rs[q], m + 1, t, l, r);\n  push_up(p);\n  push_up(q);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Enumeration in Java\nDESCRIPTION: A simple implementation of enumeration to find number pairs that sum to zero in an array. This version iterates through all possible pairs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nfor (int i = 0; i < n; ++i)\n  for (int j = 0; j < n; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n```\n\n----------------------------------------\n\nTITLE: Inserting and Deleting Nodes in Weight Balanced Leafy Tree in C++\nDESCRIPTION: Functions for inserting a new value into the tree and deleting a value from the tree. These operations maintain the balanced structure of the WBLT.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvoid copynode(int x, int y) {\n  ls[x] = ls[y];\n  rs[x] = rs[y];\n  sz[x] = sz[y];\n  vl[x] = vl[y];\n}\n\nbool leaf(int x) { return !ls[x] || !rs[x]; }\n\nvoid insert(int x, int v) {\n  if (leaf(x)) {\n    ls[x] = add(std::min(v, vl[x]));\n    rs[x] = add(std::max(v, vl[x]));\n    pushup(x);\n    maintain(x);\n    return;\n  }\n  if (vl[ls[x]] >= v) {\n    insert(ls[x], v);\n  } else {\n    insert(rs[x], v);\n  }\n  pushup(x);\n  maintain(x);\n}\n\nvoid delete(int x, int v, int fa) {\n  if (leaf(x)) {\n    if (ls[fa] == x) {\n      copynode(fa, rs[fa]);\n    } else {\n      copynode(fa, ls[fa]);\n    }\n    pushup(fa);\n    return;\n  }\n  if (vl[ls[x]] >= v) {\n    delete (ls[x], v, x);\n  } else {\n    delete (rs[x], v, x);\n  }\n  pushup(x);\n  maintain(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Sum of Projection Transformations\nDESCRIPTION: Equation showing that the sum of all projection transformations equals the identity transformation in the Jordan decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\nT_1+T_2+\\cdots+T_k=T_e\n```\n\n----------------------------------------\n\nTITLE: Defining Treap Node Structure in C++\nDESCRIPTION: Defines the structure for a Treap node, including child pointers, value, rank (priority), count for repeated values, and subtree size. Includes a constructor and method to update size.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct Node {\n  Node *ch[2];  // 两个子节点的地址\n  int val, rank;\n  int rep_cnt;  // 当前这个值（val）重复出现的次数\n  int siz;      // 以当前节点为根的子树大小\n\n  Node(int val) : val(val), rep_cnt(1), siz(1) {\n    ch[0] = ch[1] = nullptr;\n    rank = rand();\n    // 注意初始化的时候，rank 是随机给出的\n  }\n\n  void upd_siz() {\n    // 用于旋转和删除过后，重新计算 siz 的值\n    siz = rep_cnt;\n    if (ch[0] != nullptr) siz += ch[0]->siz;\n    if (ch[1] != nullptr) siz += ch[1]->siz;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Detecting Negative Cycles for HNOI2009 Minimum Circle Problem in C++\nDESCRIPTION: This code snippet shows how to solve the HNOI2009 Minimum Circle problem using fractional programming and negative cycle detection with SPFA algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/frac-programming.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nint SPFA(int u, double mid) {  // 判负环\n  vis[u] = 1;\n  for (int i = head[u]; i; i = e[i].nxt) {\n    int v = e[i].v;\n    double w = e[i].w - mid;\n    if (dis[u] + w < dis[v]) {\n      dis[v] = dis[u] + w;\n      if (vis[v] || SPFA(v, mid)) return 1;\n    }\n  }\n  vis[u] = 0;\n  return 0;\n}\n\nbool check(double mid) {  // 如果有负环返回 true\n  for (int i = 1; i <= n; ++i) dis[i] = 0, vis[i] = 0;\n  for (int i = 1; i <= n; ++i)\n    if (SPFA(i, mid)) return true;\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Persistent Union-Find Implementation Using Chairman Tree\nDESCRIPTION: A code snippet demonstrating how to implement a persistent union-find data structure using Chairman Trees. This implementation allows for maintaining different versions of the union-find structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent-seg.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/ds/code/persistent-seg/persistent-seg_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Maintaining Balance in Weight Balanced Leafy Tree in C++\nDESCRIPTION: Functions for maintaining the balance of the WBLT through rotation operations. This ensures the tree remains balanced after insertions and deletions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr double alpha = 0.25;\n\nint merge(int x, int y) {\n  int z = add(vl[x]);\n  ls[z] = x;\n  rs[z] = y;\n  pushup(z);\n  return z;\n}\n\nvoid rotate(int x, int flag) {\n  if (!flag) {\n    rs[x] = merge(rs[ls[x]], rs[x]);\n    ls[x] = ls[ls[x]];\n  } else {\n    ls[x] = merge(ls[x], ls[rs[x]]);\n    rs[x] = rs[rs[x]];\n  }\n}\n\nvoid maintain(int x) {\n  if (leaf(x)) return;\n  if (sz[ls[x]] > sz[rs[x]]) {\n    if (sz[rs[x]] >= sz[x] * alpha) return;\n    if (sz[rs[ls[x]]] >= sz[ls[x]] * (1 - alpha * 2) / (1 - alpha)) {\n      rotate(ls[x], 1);\n    }\n    rotate(x, 0);\n  } else {\n    if (sz[ls[x]] >= sz[x] * alpha) return;\n    if (sz[ls[rs[x]]] >= sz[rs[x]] * (1 - alpha * 2) / (1 - alpha)) {\n      rotate(rs[x], 0);\n    }\n    rotate(x, 1);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Li Chao Tree\nDESCRIPTION: This function queries the Li Chao tree to find the segment with the maximum value at a given point. It traverses the tree and compares segment values to determine the optimal result.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/li-chao-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\npdi query(int root, int l, int r, int d) {  // 查询\n  if (r < d || d < l) return {0, 0};\n  int mid = (l + r) >> 1;\n  double res = calc(s[root], d);\n  if (l == r) return {res, s[root]};\n  return pmax({res, s[root]}, pmax(query(root << 1, l, mid, d),\n                                   query(root << 1 | 1, mid + 1, r, d)));\n}\n```\n\n----------------------------------------\n\nTITLE: Augmenting Path Detection in General Weighted Matching (C++)\nDESCRIPTION: Implements the process of detecting and handling an augmenting path when a tight edge is found during the breadth-first search. This function is crucial for expanding the matching or identifying new blossoms in the graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nbool on_found_edge(const edge &e) {\n  // BFS时找到一条等边e\n  // 要对它进行以下的处理\n  // 这里u一定是偶点\n  int u = st[e.u], v = st[e.v];\n  if (S[v] == -1) {\n    // v是未走访节点\n    pa[v] = e.u;\n    S[v] = 1;\n    int nu = st[match[v]];\n    slack[v] = 0;\n    slack[nu] = 0;\n    S[nu] = 0;\n    q_push(nu);\n  } else if (S[v] == 0) {\n    // v是偶点\n    int lca = get_lca(u, v);\n    if (!lca) {  // lca=0表示u,v在不同的交错树上，有增广路\n      augment(u, v);\n      augment(v, u);\n      return true;  // 找到增广路\n    } else\n      add_blossom(u, lca, v);\n    // 否则u,v在同棵树上就会是一朵花，要缩花\n  }\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Data Until EOF in C++\nDESCRIPTION: Implementation of reading an unknown quantity of integers until end-of-file is reached, demonstrating how std::cin returns false when it encounters EOF, breaking the loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n\nint main() {\n  int sum = 0, a = 0;\n\n  while (std::cin >> a) {\n    sum += a;\n  }\n  std::cout << sum << std::endl;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Complete C++ Program with Function Call Example\nDESCRIPTION: A complete C++ program showing function declaration, definition, and multiple calls to a function from the main function. The program outputs 'hello!' six times.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// hello_subroutine.cpp\n\n#include <iostream>\n\nvoid say_hello() {\n  std::cout << \"hello!\\n\";\n  std::cout << \"hello!\\n\";\n  std::cout << \"hello!\\n\";\n}\n\nint main() {\n  say_hello();\n  say_hello();\n}\n```\n\n----------------------------------------\n\nTITLE: Missile Interception System Implementation in C++\nDESCRIPTION: Solution for Luogu P1020 problem implementing a missile interception system using Dilworth's theorem and longest non-decreasing subsequence algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/order-theory.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/order-theory/order-theory_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Additional Case: Formula for 4 Divides x-y\nDESCRIPTION: Formula for the power of 2 in x^n-y^n when 4 divides x-y.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_12\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_2\\left(x^n-y^n\\right)=\\nu_2(x-y)+\\nu_2(n)\n```\n\n----------------------------------------\n\nTITLE: Timestamp Optimization for Binary Indexed Tree Operations in C++\nDESCRIPTION: This code snippet demonstrates timestamp optimization for Binary Indexed Tree operations, allowing efficient handling of multiple datasets without clearing the entire tree. It uses a tag array to track the last update time for each node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nint tag[MAXN], t[MAXN], Tag;\n\nvoid reset() { ++Tag; }\n\nvoid add(int k, int v) {\n  while (k <= n) {\n    if (tag[k] != Tag) t[k] = 0;\n    t[k] += v, tag[k] = Tag;\n    k += lowbit(k);\n  }\n}\n\nint getsum(int k) {\n  int ret = 0;\n  while (k) {\n    if (tag[k] == Tag) ret += t[k];\n    k -= lowbit(k);\n  }\n  return ret;\n}\n```\n\n----------------------------------------\n\nTITLE: Inversion Count Formulas for Row and Column Permutations\nDESCRIPTION: Formulas defining the inversion counts for row and column permutations, which determine the sign of terms in a determinant calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\ns=\\pi(i_1i_2\\cdots i_n)\n```\n\nLANGUAGE: latex\nCODE:\n```\nt=\\pi(j_1j_2\\cdots j_n)\n```\n\n----------------------------------------\n\nTITLE: Closing C++ File Streams\nDESCRIPTION: Example of closing file streams opened with ifstream and ofstream. Properly closing streams is important to flush buffers and release system resources.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nfin.close();\nfout.close();\n```\n\n----------------------------------------\n\nTITLE: Finding Smallest Number with Given Number of Divisors in C++\nDESCRIPTION: This code snippet implements a depth-first search algorithm to find the smallest number with a given number of divisors. It uses prime factorization and iterates through prime numbers to construct the result.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nconst int MAX_PRIME = 16;\nint prime[MAX_PRIME] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53};\n\nlong long ans;\nint n;\n\nvoid dfs(long long val, int prime_index, int power, long long mult) {\n    if (mult > n || prime_index == MAX_PRIME) return;\n    if (mult == n && val < ans) ans = val;\n    dfs(val, prime_index + 1, 1, mult * 2);\n    if (power > 1) {\n        if (val <= ans / prime[prime_index]) {\n            dfs(val * prime[prime_index], prime_index, power + 1,\n                mult / power * (power + 1));\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &n) != EOF) {\n        ans = ~0ULL >> 1;\n        dfs(1, 0, 1, 1);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing PAM to Find Maximum Existence Value of Palindrome Substrings\nDESCRIPTION: This code implements a Palindromic Tree to solve the problem of finding the maximum existence value among all palindrome substrings of a given string. The existence value is defined as the product of the substring's length and its frequency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/pam.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconst int N = 300010;\n\nlong long ans;\nchar s[N];\nint len[N], next[N][26], fail[N], cnt[N], num[N], slink[N], diff[N];\nint last, now, tot;\n\nvoid pam_init() {\n  s[0] = -1;\n  fail[0] = 1;\n  len[1] = -1;\n  tot = 1;\n  last = 0;\n}\n\nint get_fail(int x) {\n  while (s[now - len[x] - 1] != s[now]) x = fail[x];\n  return x;\n}\n\nvoid insert(char c) {\n  s[++now] = c;\n  int cur = get_fail(last);\n  if (!next[cur][c - 'a']) {\n    len[++tot] = len[cur] + 2;\n    fail[tot] = next[get_fail(fail[cur])][c - 'a'];\n    next[cur][c - 'a'] = tot;\n    diff[tot] = len[tot] - len[fail[tot]];\n    if (diff[tot] == diff[fail[tot]])\n      slink[tot] = slink[fail[tot]];\n    else\n      slink[tot] = fail[tot];\n  }\n  last = next[cur][c - 'a'];\n  cnt[last]++;\n}\n\nint main() {\n  pam_init();\n  scanf(\"%s\", s + 1);\n  for (int i = 1; s[i]; i++) insert(s[i]);\n  for (int i = tot; i >= 2; i--) {\n    cnt[fail[i]] += cnt[i];\n    ans = max(ans, 1ll * len[i] * cnt[i]);\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Eratosthenes Sieve with Square Root Limit in C++ and Python\nDESCRIPTION: This optimized version of the Eratosthenes Sieve only iterates up to the square root of n when marking multiples. This optimization reduces the number of operations while achieving the same result.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> prime;\nbool is_prime[N];\n\nvoid Eratosthenes(int n) {\n  is_prime[0] = is_prime[1] = false;\n  for (int i = 2; i <= n; ++i) is_prime[i] = true;\n  // i * i <= n 说明 i <= sqrt(n)\n  for (int i = 2; i * i <= n; ++i) {\n    if (is_prime[i])\n      for (int j = i * i; j <= n; j += i) is_prime[j] = false;\n  }\n  for (int i = 2; i <= n; ++i)\n    if (is_prime[i]) prime.push_back(i);\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\nprime = []\nis_prime = [False] * N\n\n\ndef Eratosthenes(n):\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, n + 1):\n        is_prime[i] = True\n    # 让 i 循环到 <= sqrt(n)\n    for i in range(2, isqrt(n) + 1):  # `isqrt` 是 Python 3.8 新增的函数\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    for i in range(2, n + 1):\n        if is_prime[i]:\n            prime.append(i)\n```\n\n----------------------------------------\n\nTITLE: Constructing XOR Linear Basis using Greedy Method (C++)\nDESCRIPTION: Implements the greedy method to construct an XOR linear basis from a given set of numbers. Also includes functions to query the maximum XOR value and check if a number can be XORed from the basis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/basis.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/basis/basis_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Dynamic Hungarian Algorithm Implementation in C++\nDESCRIPTION: Implementation of a dynamic version of the Hungarian algorithm that efficiently handles changes in the weight matrix, including modifications to rows, columns and individual elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/bigraph-weight-match.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/graph-matching/bigraph-weight-match/bigraph-weight-match_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Closing Standard Streams in C/C++\nDESCRIPTION: Example of closing redirected standard input and output streams using fclose. This is important to properly release system resources after file operations are complete.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nfclose(stdin);\nfclose(stdout);\n```\n\n----------------------------------------\n\nTITLE: Determinant Properties with Row or Column Exchange\nDESCRIPTION: Axiomatic property showing that exchanging two rows or columns changes the sign of the determinant.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\n\\det(P_{ij}A) = \\det(AP_{ij}) = -\\det A\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Variable Declarations in C++\nDESCRIPTION: Demonstrates the use of braces in switch cases to allow variable declarations. Each case becomes its own scope, preventing variable naming conflicts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nchar i = 'B';\n\nswitch (i) {\n  case 'A': {\n    int i = 1, j = 2;\n    cout << \"OI\" << endl;\n    ans = i + j;\n    break;\n  }\n\n  case 'B': {\n    int qwq = 3;\n    cout << \"WIKI\" << endl;\n    ans = qwq * qwq;\n    break;\n  }\n\n  default: {\n    cout << \"Hello World\" << endl;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Python Interactive Variable Assignments and Basic Data Types\nDESCRIPTION: Demonstrates variable declaration and basic data type operations in Python's interactive mode. Shows integer, float, string, and boolean type handling with various operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> x = -3  # 语句结尾不用加分号\n>>> x\n-3\n>>> f = 3.1415926535897932384626; f  # 实在想加分号也可以，这里节省了一行\n3.141592653589793\n>>> s1 = \"O\"\n>>> s1  # 在 Python 中双引号和单引号的作用相同\n'O'\n>>> b = 'A' == 65  # 'A' 和 65 不是一个数据类型，所以不相等\n>>> b  # True, False 首字母均大写\nFalse\n>>> True + 1 == 2 and not False != 0  # Python 中的表达式中大多使用单词，但是也支持符号\nTrue\n```\n\n----------------------------------------\n\nTITLE: Equivalence Between For and While Loops in C++\nDESCRIPTION: Demonstration of how for loops can be rewritten as equivalent while loops when there are no continue statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n// for 语句\n\nfor (statement1; statement2; statement3) {\n  statement4;\n}\n\n// while 语句\n\nstatement1;\nwhile (statement2) {\n  statement4;\n  statement3;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Do-While Loop Structure in C++\nDESCRIPTION: The fundamental structure of a do-while loop in C++, showing execution that always runs at least once.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\ndo {\n  循环体;\n} while (判断条件);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Segment Tree Point Update in C++\nDESCRIPTION: Implementation of dynamic segment tree point update operation that creates nodes only when needed. Uses references to manage node creation and updates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nvoid update(int& p, int s, int t, int x, int f) {\n  if (!p) p = ++cnt;\n  if (s == t) {\n    sum[p] += f;\n    return;\n  }\n  int m = s + ((t - s) >> 1);\n  if (x <= m)\n    update(ls[p], s, m, x, f);\n  else\n    update(rs[p], m + 1, t, x, f);\n  sum[p] = sum[ls[p]] + sum[rs[p]];\n}\n```\n\n----------------------------------------\n\nTITLE: Java Final Variable Declaration\nDESCRIPTION: Demonstrates declaring constants using the final keyword in Java, which prevents the variable from being modified after initialization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nfinal double PI = 3.1415926;\n```\n\n----------------------------------------\n\nTITLE: Installing and Compiling Lemon on Ubuntu\nDESCRIPTION: Commands for installing dependencies, cloning the Lemon repository, and compiling the project on Ubuntu. The make command can be adjusted for parallel compilation by modifying the -j parameter.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/lemon.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update\nsudo apt install qt5-default build-essential git -y\ngit clone --depth=1 https://github.com/Menci/Lemon.git\ncd lemon\n# 可以修改 -j 后面的数字来调整 make job 的线程数\n./make -j2\nsudo install -Dm755 -t /usr/bin/ Lemon\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Non-rotational Treap in C++\nDESCRIPTION: This code snippet implements a basic non-rotational Treap data structure in C++. It includes operations for insertion, deletion, rank querying, and predecessor/successor finding. The implementation uses pointers and includes split and merge operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_19\n\nLANGUAGE: C++\nCODE:\n```\n// author: (ttzytt)[ttzytt.com]\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <tuple>\nusing namespace std;\n\nstruct Node {\n  Node *ch[2];\n  int val, prio;\n  int cnt;\n  int siz;\n\n  Node(int _val) : val(_val), cnt(1), siz(1) {\n    ch[0] = ch[1] = nullptr;\n    prio = rand();\n  }\n\n  Node(Node *_node) {\n    val = _node->val, prio = _node->prio, cnt = _node->cnt, siz = _node->siz;\n  }\n\n  void upd_siz() {\n    siz = cnt;\n    if (ch[0] != nullptr) siz += ch[0]->siz;\n    if (ch[1] != nullptr) siz += ch[1]->siz;\n  }\n};\n\nstruct none_rot_treap {\n#define _3 second.second\n#define _2 second.first\n  Node *root;\n\n  pair<Node *, Node *> split(Node *cur, int key) {\n    if (cur == nullptr) return {nullptr, nullptr};\n    if (cur->val <= key) {\n      auto temp = split(cur->ch[1], key);\n      cur->ch[1] = temp.first;\n      cur->upd_siz();\n      return {cur, temp.second};\n    } else {\n      auto temp = split(cur->ch[0], key);\n      cur->ch[0] = temp.second;\n      cur->upd_siz();\n      return {temp.first, cur};\n    }\n  }\n\n  tuple<Node *, Node *, Node *> split_by_rk(Node *cur, int rk) {\n    if (cur == nullptr) return {nullptr, nullptr, nullptr};\n    int ls_siz = cur->ch[0] == nullptr ? 0 : cur->ch[0]->siz;\n    if (rk <= ls_siz) {\n      Node *l, *mid, *r;\n      tie(l, mid, r) = split_by_rk(cur->ch[0], rk);\n      cur->ch[0] = r;\n      cur->upd_siz();\n      return {l, mid, cur};\n    } else if (rk <= ls_siz + cur->cnt) {\n      Node *lt = cur->ch[0];\n      Node *rt = cur->ch[1];\n      cur->ch[0] = cur->ch[1] = nullptr;\n      return {lt, cur, rt};\n    } else {\n      Node *l, *mid, *r;\n      tie(l, mid, r) = split_by_rk(cur->ch[1], rk - ls_siz - cur->cnt);\n      cur->ch[1] = l;\n      cur->upd_siz();\n      return {cur, mid, r};\n    }\n  }\n\n  Node *merge(Node *u, Node *v) {\n    if (u == nullptr && v == nullptr) return nullptr;\n    if (u != nullptr && v == nullptr) return u;\n    if (v != nullptr && u == nullptr) return v;\n    if (u->prio < v->prio) {\n      u->ch[1] = merge(u->ch[1], v);\n      u->upd_siz();\n      return u;\n    } else {\n      v->ch[0] = merge(u, v->ch[0]);\n      v->upd_siz();\n      return v;\n    }\n  }\n\n  void insert(int val) {\n    auto temp = split(root, val);\n    auto l_tr = split(temp.first, val - 1);\n    Node *new_node;\n    if (l_tr.second == nullptr) {\n      new_node = new Node(val);\n    } else {\n      l_tr.second->cnt++;\n      l_tr.second->upd_siz();\n    }\n    Node *l_tr_combined =\n        merge(l_tr.first, l_tr.second == nullptr ? new_node : l_tr.second);\n    root = merge(l_tr_combined, temp.second);\n  }\n\n  void del(int val) {\n    auto temp = split(root, val);\n    auto l_tr = split(temp.first, val - 1);\n    if (l_tr.second->cnt > 1) {\n      l_tr.second->cnt--;\n      l_tr.second->upd_siz();\n      l_tr.first = merge(l_tr.first, l_tr.second);\n    } else {\n      if (temp.first == l_tr.second) {\n        temp.first = nullptr;\n      }\n      delete l_tr.second;\n      l_tr.second = nullptr;\n    }\n    root = merge(l_tr.first, temp.second);\n  }\n\n  int qrank_by_val(Node *cur, int val) {\n    auto temp = split(cur, val - 1);\n    int ret = (temp.first == nullptr ? 0 : temp.first->siz) + 1;\n    root = merge(temp.first, temp.second);\n    return ret;\n  }\n\n  int qval_by_rank(Node *cur, int rk) {\n    Node *l, *mid, *r;\n    tie(l, mid, r) = split_by_rk(cur, rk);\n    int ret = mid->val;\n    root = merge(merge(l, mid), r);\n    return ret;\n  }\n\n  int qprev(int val) {\n    auto temp = split(root, val - 1);\n    int ret = qval_by_rank(temp.first, temp.first->siz);\n    root = merge(temp.first, temp.second);\n    return ret;\n  }\n\n  int qnex(int val) {\n    auto temp = split(root, val);\n    int ret = qval_by_rank(temp.second, 1);\n    root = merge(temp.first, temp.second);\n    return ret;\n  }\n};\n\nnone_rot_treap tr;\n\nint main() {\n  srand(time(nullptr));\n  int t;\n  scanf(\"%d\", &t);\n  while (t--) {\n    int mode;\n    int num;\n    scanf(\"%d%d\", &mode, &num);\n    switch (mode) {\n      case 1:\n        tr.insert(num);\n        break;\n      case 2:\n        tr.del(num);\n        break;\n      case 3:\n        printf(\"%d\\n\", tr.qrank_by_val(tr.root, num));\n        break;\n      case 4:\n        printf(\"%d\\n\", tr.qval_by_rank(tr.root, num));\n        break;\n      case 5:\n        printf(\"%d\\n\", tr.qprev(num));\n        break;\n      case 6:\n        printf(\"%d\\n\", tr.qnex(num));\n        break;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Square Root using Newton's Method in Python\nDESCRIPTION: This function implements Newton's method to calculate the square root of a given number in Python. It uses an iterative approach to refine the approximation until the desired precision is achieved.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/newton.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef sqrt_newton(n):\n    eps = 1e-15\n    x = 1\n    while True:\n        nx = (x + n / x) / 2\n        if abs(x - nx) < eps:\n            break\n        x = nx\n    return x\n```\n\n----------------------------------------\n\nTITLE: 一条回路覆盖问题完整实现 (C++)\nDESCRIPTION: 一条回路覆盖问题的完整解决方案，计算用一条回路覆盖N×M棋盘的方案数。实现了插头的连通性编码和状态转移，确保最终形成单一闭环。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/plug/plug_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Solving Dynamic Inversion Pair Counting with CDQ Divide and Conquer in C++\nDESCRIPTION: This code implements CDQ divide and conquer to solve a dynamic inversion pair counting problem. It handles element deletions from a sequence and calculates the number of inversion pairs after each deletion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/cdq-divide.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/misc/code/cdq-divide/cdq-divide_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Merge Operation in Persistent Treap\nDESCRIPTION: Function that merges two Treaps based on their fix (random priority) values. Maintains persistence by creating new nodes during merging process.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent-balanced.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstatic int _merge(int _x, int _y) {\n  if (_x == 0 || _y == 0)\n    return _x ^ _y;\n  else {\n    if (_trp[_x].fix < _trp[_y].fix) {\n      _trp[_x].leaf[1] = _merge(_trp[_x].leaf[1], _y);\n      _trp[_x]._update();\n      return _x;\n    } else {\n      _trp[_y].leaf[0] = _merge(_x, _trp[_y].leaf[0]);\n      _trp[_y]._update();\n      return _y;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Blossom Position and Matching Operations in C++\nDESCRIPTION: Implements functions for finding positions within blossoms and setting matching edges. These operations are crucial for maintaining the correct structure of blossoms and updating matchings during the algorithm's execution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint get_pr(int b, int xr) {\n  // xr是flower[b]中的一个点，返回值pr是它的位置\n  // 为了方便程序运行，我们让 flower[b][0]~flower[b][pr]为花里的交替路\n  int pr = find(flower[b].begin(), flower[b].end(), xr) - flower[b].begin();\n  if (pr % 2 == 1) {\n    // 检查他在花里的位置，如果 flower[b][0]~flower[b][pr] 不是交替路\n    // 就把整朵花反转，重新计算 pr\n    // 让 flower[b][0]~flower[b][pr] 为花里的交替路\n    reverse(flower[b].begin() + 1, flower[b].end());\n    return (int)flower[b].size() - pr;\n  } else\n    return pr;\n}\n\nvoid set_match(int u, int v) {\n  // 设置u和v为匹配边，u和v有可能是花\n  match[u] = g[u][v].v;\n  if (u > n) {\n    // 如果u是花的话\n    edge e = g[u][v];\n    int xr = flower_from[u][e.u];  // 找出e.u在flower[u]里的哪朵花上\n    int pr = get_pr(u, xr);  // 找出xr的位置并让0~pr为花里的交替路径\n    for (int i = 0; i < pr; ++i) {  // 把花里的交替路上的匹配边和非匹配边反转\n      set_match(flower[u][i], flower[u][i ^ 1]);\n    }\n    set_match(xr, v);  // 设置(xr,v)为匹配边\n    rotate(flower[u].begin(), flower[u].begin() + pr, flower[u].end());\n    // 最后把pr设为花托，因为花的存法是flower[u][0]会是u的花托\n    // 所以要把flower[u][pr] rotate 到最前面\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Extended Integer Type Usage Example\nDESCRIPTION: Demonstrates issues with using extended integer types (__int128_t) with standard library functions and stream operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cmath>\n#include <iostream>\n\nint f1(int n) {\n  return abs(n);  // Good\n}\n\nint f2(int n) {\n  return std::abs(n);  // Good\n}\n\n__int128_t f3(__int128_t n) {\n  return abs(n);  // Bad\n}\n\n// Wrong\n// __int128_t f4(__int128_t n) {\n//   return std::abs(n);\n// }\n\nint main() {\n  std::cout << \"f1: \" << f1(-42) << std::endl;\n  std::cout << \"f2: \" << f2(-42) << std::endl;\n  // std::cout << \"f3: \" << f3(-42) << std::endl; // Wrong\n  // std::cout << \"f4: \" << f4(-42) << std::endl; // Wrong\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Recursive and Non-Recursive Merge Sort in C++\nDESCRIPTION: Implementation of merge sort algorithm in both recursive and non-recursive approaches, demonstrating the clarity and readability advantages of the recursive version.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// 不使用递归的归并排序算法\ntemplate <typename T>\nvoid merge_sort(vector<T> a) {\n  int n = a.size();\n  for (int seg = 1; seg < n; seg = seg + seg)\n    for (int start = 0; start < n - seg; start += seg + seg)\n      merge(a, start, start + seg - 1, std::min(start + seg + seg - 1, n - 1));\n}\n\n// 使用递归的归并排序算法\ntemplate <typename T>\nvoid merge_sort(vector<T> a, int front, int end) {\n  if (front >= end) return;\n  int mid = front + (end - front) / 2;\n  merge_sort(a, front, mid);\n  merge_sort(a, mid + 1, end);\n  merge(a, front, mid, end);\n}\n```\n\n----------------------------------------\n\nTITLE: Edge Biconnected Components Implementation in C++\nDESCRIPTION: Implementation of Link-Cut Tree operations to maintain edge biconnected components. Includes functionality for merging components, Splay tree operations, and path queries. Used to solve a problem involving flight route planning with edge deletions and path queries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\nconstexpr int MAXN = 200010;\nint f[MAXN];\n\nint findp(int x) { return f[x] ? f[x] = findp(f[x]) : x; }\n\nvoid merge(int x, int y) {\n  x = findp(x);\n  y = findp(y);\n  if (x != y) f[x] = y;\n}\n\n// ... [rest of first code block]\n```\n\n----------------------------------------\n\nTITLE: Comparing Recursive and Iterative Linked List Size Calculation in C++\nDESCRIPTION: Comparing two approaches to calculate the length of a linked list: an efficient iterative approach and a less efficient recursive approach that consumes more stack space.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// 典型的递推遍历框架\nint size(Node *head) {\n  int size = 0;\n  for (Node *p = head; p != nullptr; p = p->next) size++;\n  return size;\n}\n\n// 我就是要写递归，递归天下第一\nint size_recursion(Node *head) {\n  if (head == nullptr) return 0;\n  return size_recursion(head->next) + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Getting a Specific Bit from a Number in C++\nDESCRIPTION: A function that extracts the value of a specific bit from an integer, useful for checking individual bits in binary representations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\n// 获取 a 的第 b 位，最低位编号为 0\nint getBit(int a, int b) { return (a >> b) & 1; }\n```\n\n----------------------------------------\n\nTITLE: Sign Determination Formula for Determinant Elements\nDESCRIPTION: Formula for determining the sign of a product term in a determinant when selecting elements from specific rows and columns, based on the inversion counts of row and column permutations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\na_{i_1j_1}a_{i_2j_2}\\cdots a_{i_nj_n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Split Operation in Persistent Treap\nDESCRIPTION: Function that splits a Treap into two trees based on a key value k, creating new nodes for path copying to maintain persistence. Returns a pair containing roots of the resulting trees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent-balanced.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstatic std::pair<int, int> _split(int _x, int k) {\n  if (_x == 0)\n    return std::make_pair(0, 0);\n  else {\n    int _vs = ++_cnt;  // 新建节点（可持久化的精髓）\n    _trp[_vs] = _trp[_x];\n    std::pair<int, int> _y;\n    if (_trp[_vs].key <= k) {\n      _y = _split(_trp[_vs].leaf[1], k);\n      _trp[_vs].leaf[1] = _y.first;\n      _y.first = _vs;\n    } else {\n      _y = _split(_trp[_vs].leaf[0], k);\n      _trp[_vs].leaf[0] = _y.second;\n      _y.second = _vs;\n    }\n    _trp[_vs]._update();\n    return _y;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Hash Table Implementation for DP Memoization in C++\nDESCRIPTION: Implements a custom hash table for memoizing dynamic programming states. Includes functionality to store previous states for solution reconstruction. Uses chaining for collision resolution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int Prime = 9979, MaxSZ = 1 << 20;\n\ntemplate <class T_state, class T_key>\nstruct hashTable {\n  int head[Prime];\n  int next[MaxSZ], sz;\n  T_state state[MaxSZ];\n  T_key key[MaxSZ];\n  int pre[MaxSZ];\n\n  void clear() {\n    sz = 0;\n    memset(head, -1, sizeof(head));\n  }\n\n  void push(T_state s, T_key d, T_state u) {\n    int x = s % Prime;\n    for (int i = head[x]; ~i; i = next[i]) {\n      if (state[i] == s) {\n        key[i] += d;\n        return;\n      }\n    }\n    state[sz] = s, key[sz] = d, pre[sz] = u;\n    next[sz] = head[x], head[x] = sz++;\n  }\n\n  void roll() { REP(ii, sz) state[ii] <<= Offset; }\n};\n\nhashTable<T_state, T_key> _H, H[N][N], *H0, *H1;\n```\n\n----------------------------------------\n\nTITLE: Struct Declaration in C++\nDESCRIPTION: Demonstrates the simplified C++ struct declaration syntax, showing more concise approach compared to C.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/cpp-other-langs.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct Node {\n  Node *next;\n  int key;\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Catalan Numbers in Python\nDESCRIPTION: This Python script calculates the nth Catalan number using the same recursive formula as the C++ version. It uses integer division to avoid floating-point errors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/catalan.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nf = [0] * 25\nf[0] = 1\nn = int(input())\nfor i in range(1, n + 1):\n    f[i] = int(f[i - 1] * (4 * i - 2) // (i + 1))\n    # 这里用的是常见公式2\nprint(f[n])\n```\n\n----------------------------------------\n\nTITLE: Calculating Suffix Array Differences\nDESCRIPTION: Solution for AHOI2013 Difference problem that calculates LCP contributions using monotonic stack. Handles suffix array position differences and height array processing.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sa.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ndocs/string/code/sa/sa_3.cpp\n```\n\n----------------------------------------\n\nTITLE: Solving XOR Equation Systems using Gaussian Elimination in C++\nDESCRIPTION: Optimized implementation for solving systems of XOR equations using bitset operations. Achieves O(n²m/ω) time complexity where ω is typically 32.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/gauss.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nstd::bitset<1010> matrix[2010];  // matrix[1~n]：增广矩阵，0 位置为常数\n\nstd::vector<bool> GaussElimination(\n    int n, int m)  // n 为未知数个数，m 为方程个数，返回方程组的解\n                   // （多解 / 无解返回一个空的 vector）\n{\n  for (int i = 1; i <= n; i++) {\n    int cur = i;\n    while (cur <= m && !matrix[cur].test(i)) cur++;\n    if (cur > m) return std::vector<bool>(0);\n    if (cur != i) swap(matrix[cur], matrix[i]);\n    for (int j = 1; j <= m; j++)\n      if (i != j && matrix[j].test(i)) matrix[j] ^= matrix[i];\n  }\n  std::vector<bool> ans(n + 1);\n  for (int i = 1; i <= n; i++) ans[i] = matrix[i].test(0);\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: C Boolean Type Macros Definition\nDESCRIPTION: Shows the macro definitions for bool, true and false in C's stdbool.h header, which were used before C23 introduced bool as a keyword.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#define bool _Bool\n#define true 1\n#define false 0\n```\n\n----------------------------------------\n\nTITLE: Defining Sum/Direct Sum Operation for Undirected Simple Graphs in LaTeX\nDESCRIPTION: This snippet defines the sum or direct sum operation for two undirected simple graphs G and H, resulting in a new graph that is isomorphic to the union of G and a copy of H with disjoint vertex sets.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\nG + H \\text{ or } G \\oplus H\n```\n\n----------------------------------------\n\nTITLE: Fibonacci Implementation with Const vs Constexpr\nDESCRIPTION: Compares const and constexpr implementations of Fibonacci sequence calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nusing namespace std;\n\nconstexpr unsigned fib0(unsigned n) {\n  return n <= 1 ? 1 : (fib0(n - 1) + fib0(n - 2));\n}\n\nunsigned fib1(unsigned n) { return n <= 1 ? 1 : (fib1(n - 1) + fib1(n - 2)); }\n\nint main() {\n  constexpr auto v0 = fib0(9);\n  const auto v1 = fib1(9);\n\n  cout << v0;\n  cout << ' ';\n  cout << v1;\n}\n```\n\n----------------------------------------\n\nTITLE: SATT Splay Operations Implementation in C++\nDESCRIPTION: Implementation of Splay tree operations for Self-Adjusting Top Tree, including rotation and splaying functions for both Rake and Compress trees. Handles node rotation while preserving middle child relationships.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nbool isroot(int x) { return rs(father[x]) != x && ls(father[x]) != x; }\n\nbool direction(int x) { return rs(father[x]) == x; }\n\nvoid rotate(int x, int type) {\n  int y = father[x], z = father[y], d = direction(x), w = son[x][d ^ 1];\n  if (z) son[z][ms(z) == y ? 2 : direction(y)] = x;\n  son[x][d ^ 1] = y;\n  son[y][d] = w;\n  if (w) father[w] = y;\n  father[y] = x;\n  father[x] = z;\n  pushup(y, type);\n  pushup(x, type);\n  return;\n}\n\nvoid splay(int x, int type, int goal = 0) {\n  pushall(x, ty);\n  for (int y; y = father[x], (!isroot(x)) && y != goal; rotate(x, ty)) {\n    if (father[y] != goal && (!isroot(y))) {\n      rotate(direction(x) ^ diretion(y) ? x : y, type);\n    }\n  }\n  return;\n}\n```\n\n----------------------------------------\n\nTITLE: Checking If Two Numbers Have Same Sign in Python\nDESCRIPTION: A Python function that determines if two non-zero integers have the same sign using the XOR bitwise operation, which is more efficient than comparing the signs separately.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\n# 有 0 的情况例外\ndef isSameSign(x, y):\n    return (x ^ y) >= 0\n```\n\n----------------------------------------\n\nTITLE: PQ Tree Class Implementation in C++\nDESCRIPTION: Complete C++ implementation of a PQ tree class that supports initialization, insertion, and permutation generation. The implementation uses the top-down approach for construction and includes methods for handling P nodes, Q nodes, and node splitting operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/pq-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nclass PQTree {\n public:\n  PQTree() {}\n\n  void Init(int n) {\n    n_ = n, rt_ = tot_ = n + 1;\n    for (int i = 1; i <= n; i++) g_[rt_].emplace_back(i);\n  }\n\n  void Insert(const std::string &s) {\n    s_ = s;\n    Dfs0(rt_);\n    Work(rt_);\n    while (g_[rt_].size() == 1) rt_ = g_[rt_][0];\n    Remove(rt_);\n  }\n\n  std::vector<int> ans() {\n    DfsAns(rt_);\n    return ans_;\n  }\n\n  ~PQTree() {}\n\n private:\n  int n_, rt_, tot_, pool_[100001], top_, typ_[100001], col_[100001];\n  std::vector<int> g_[100001], ans_;\n  std::string s_;\n\n  void Fail() {\n    std::cout << \"NO\\n\";\n    std::exit(0);\n  }\n\n  // Additional implementation methods...\n} T;\n```\n\n----------------------------------------\n\nTITLE: Solving POJ2887 Big String Problem Using Rope in C++\nDESCRIPTION: Demonstrates the use of STL rope to solve a problem involving string operations. Includes input handling, query processing, and output formatting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-list.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/ds/code/block-list/block-list_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Basic Fraction Finding in Stern-Brocot Tree with C++\nDESCRIPTION: A naive algorithm for finding a given fraction p/q in a Stern-Brocot tree. This implementation traverses the tree by comparing the target fraction with the current node and moving left or right accordingly, with a complexity of O(p+q).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid find(int p, int q) {\n    int a = 0, b = 1, c = 1, d = 0;\n    string path;\n    while (a + c != p || b + d != q) {\n        if ((a + c) * q < p * (b + d)) {\n            path += \"R\";\n            a += c;\n            b += d;\n        } else {\n            path += \"L\";\n            c += a;\n            d += b;\n        }\n    }\n    cout << path << \"\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Using Kattio for Efficient I/O in Java\nDESCRIPTION: Demonstration of using the Kattio class for various input/output operations. Shows how to read strings and integers, print output, and properly close the I/O stream.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nclass Test {\n    public static void main(String[] args) {\n        Kattio io = new Kattio();\n        // 字符串输入\n        String str = io.next();\n        // int 输入\n        int num = io.nextInt();\n        // 输出\n        io.println(\"Result\");\n        // 请确保关闭 IO 流以确保输出被正确写入\n        io.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Tree Block Decomposition\nDESCRIPTION: DFS implementation for decomposing a tree into blocks for Mo's algorithm. Uses a stack to track nodes and creates blocks based on subtree sizes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo-on-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint bl[100002], bls = 0;  // block assignment, block count\nunsigned step;            // block size\nint fa[100002], dp[100002], hs[100002] = {0}, sz[100002] = {0};\nstack<int> sta;\n\nvoid dfs1(int x) {\n  sz[x] = 1;\n  unsigned ss = sta.size();\n  for (int i = head[x]; i; i = nxt[i])\n    if (ver[i] != fa[x]) {\n      fa[ver[i]] = x;\n      dp[ver[i]] = dp[x] + 1;\n      dfs1(ver[i]);\n      sz[x] += sz[ver[i]];\n      if (sz[ver[i]] > sz[hs[x]]) hs[x] = ver[i];\n      if (sta.size() - ss >= step) {\n        bls++;\n        while (sta.size() != ss) bl[sta.top()] = bls, sta.pop();\n      }\n    }\n  sta.push(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Trial Division Method for Primality Testing in C++ and Python\nDESCRIPTION: Simple implementation of trial division primality testing that checks divisibility for all numbers from 2 to n-1. This is the most basic but least efficient approach to determine if a number is prime.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nbool isPrime(int a) {\n  if (a < 2) return false;\n  for (int i = 2; i < a; ++i)\n    if (a % i == 0) return false;\n  return true;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef isPrime(a):\n    if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            return False\n    return True\n```\n\n----------------------------------------\n\nTITLE: Deleting a Node from Skip List in C++\nDESCRIPTION: This function removes a node with the given key from the Skip List. It searches for the node, updates the necessary pointers at each level to bypass the node, and then deletes it. It also adjusts the maximum level of the Skip List if needed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/skiplist.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool erase(const K &key) {\n  SkipListNode<K, V> *update[MAXL + 1];\n\n  SkipListNode<K, V> *p = head;\n  for (int i = level; i >= 0; --i) {\n    while (p->forward[i]->key < key) {\n      p = p->forward[i];\n    }\n    update[i] = p;\n  }\n  p = p->forward[0];\n\n  if (p->key != key) return false;\n\n  for (int i = 0; i <= level; ++i) {\n    if (update[i]->forward[i] != p) {\n      break;\n    }\n    update[i]->forward[i] = p->forward[i];\n  }\n\n  delete p;\n\n  while (level > 0 && head->forward[level] == tail) --level;\n\n  --length;\n  return true;\n}\n```\n\n----------------------------------------\n\nTITLE: Python中的双端队列实现\nDESCRIPTION: 展示了如何在Python中使用collections.deque实现双端队列，包括创建队列、在队首和队尾插入元素等操作。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/queue.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom collections import deque\n\n# 新建一个 deque，并初始化内容为 [1, 2, 3]\nqueue = deque([1, 2, 3])\n\n# 在队尾插入元素 4\nqueue.append(4)\n\n# 在队首插入元素 0\nqueue.appendleft(0)\n\n# 访问队列\n# >>> queue\n# deque([0, 1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: Input Handling and Main Function for Suffix Array in Rust\nDESCRIPTION: This code provides the input handling functionality and main function for a suffix array implementation in Rust. It reads input from stdin, processes it with the suffix_array_16 function, and outputs the resulting array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sa-optimal-inplace.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nfn input() -> String {\n    use std::io;\n\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    String::from(input.trim())\n}\n\n\nfn main() {\n    let pat = input();\n\n    let sa_16 = suffix_array_16(pat.as_bytes());\n\n    for i in 1..pat.len() + 1 { print!(\"{} \", sa_16[i] + 1) }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mo's Algorithm on Trees with Time Dimension in C++\nDESCRIPTION: This code solves the 'WC2013 Candy Park' problem using Mo's algorithm extended to trees with a time dimension. It employs heavy-light decomposition for efficient tree traversal, handles path queries between nodes, and processes updates over time. The block size is optimized to n^0.6 to account for the additional time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo-on-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <stack>\nusing namespace std;\n\nint gi() {\n  int x, c, op = 1;\n  while (c = getchar(), c < '0' || c > '9')\n    if (c == '-') op = -op;\n  x = c ^ 48;\n  while (c = getchar(), c >= '0' && c <= '9')\n    x = (x << 3) + (x << 1) + (c ^ 48);\n  return x * op;\n}\n\nint head[100002], nxt[200004], ver[200004], tot = 0;\n\nvoid add(int x, int y) {\n  ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;\n  ver[++tot] = x, nxt[tot] = head[y], head[y] = tot;\n}\n\nint bl[100002], bls = 0;\nunsigned step;\nint fa[100002], dp[100002], hs[100002] = {0}, sz[100002] = {0}, top[100002],\n                            id[100002];\nstack<int> sta;\n\nvoid dfs1(int x) {\n  sz[x] = 1;\n  unsigned ss = sta.size();\n  for (int i = head[x]; i; i = nxt[i])\n    if (ver[i] != fa[x]) {\n      fa[ver[i]] = x, dp[ver[i]] = dp[x] + 1;\n      dfs1(ver[i]);\n      sz[x] += sz[ver[i]];\n      if (sz[ver[i]] > sz[hs[x]]) hs[x] = ver[i];\n      if (sta.size() - ss >= step) {\n        bls++;\n        while (sta.size() != ss) bl[sta.top()] = bls, sta.pop();\n      }\n    }\n  sta.push(x);\n}\n\nint cnt = 0;\n\nvoid dfs2(int x, int hf) {\n  top[x] = hf, id[x] = ++cnt;\n  if (!hs[x]) return;\n  dfs2(hs[x], hf);\n  for (int i = head[x]; i; i = nxt[i])\n    if (ver[i] != fa[x] && ver[i] != hs[x]) dfs2(ver[i], ver[i]);\n}\n\nint lca(int x, int y) {\n  while (top[x] != top[y]) {\n    if (dp[top[x]] < dp[top[y]]) swap(x, y);\n    x = fa[top[x]];\n  }\n  return dp[x] < dp[y] ? x : y;\n}\n\nstruct qu {\n  int x, y, t, id;\n\n  bool operator<(const qu a) const {\n    return bl[x] == bl[a.x] ? (bl[y] == bl[a.y] ? t < a.t : bl[y] < bl[a.y])\n                            : bl[x] < bl[a.x];\n  }\n} q[100001];\n\nint qs = 0;\n\nstruct ch {\n  int x, y, b;\n} upd[100001];\n\nint ups = 0;\nlong long ans[100001];\nint b[100001] = {0};\nint a[100001];\nlong long w[100001];\nlong long v[100001];\nlong long now = 0;\nbool vis[100001] = {false};\n\nvoid back(int t) {\n  if (vis[upd[t].x]) {\n    now -= w[b[upd[t].y]--] * v[upd[t].y];\n    now += w[++b[upd[t].b]] * v[upd[t].b];\n  }\n  a[upd[t].x] = upd[t].b;\n}\n\nvoid change(int t) {\n  if (vis[upd[t].x]) {\n    now -= w[b[upd[t].b]--] * v[upd[t].b];\n    now += w[++b[upd[t].y]] * v[upd[t].y];\n  }\n  a[upd[t].x] = upd[t].y;\n}\n\nvoid update(int x) {\n  if (vis[x])\n    now -= w[b[a[x]]--] * v[a[x]];\n  else\n    now += w[++b[a[x]]] * v[a[x]];\n  vis[x] ^= 1;\n}\n\nvoid move(int x, int y) {\n  if (dp[x] < dp[y]) swap(x, y);\n  while (dp[x] > dp[y]) update(x), x = fa[x];\n  while (x != y) update(x), update(y), x = fa[x], y = fa[y];\n}\n\nint main() {\n  int n = gi(), m = gi(), k = gi();\n  step = (int)pow(n, 0.6);\n  for (int i = 1; i <= m; i++) v[i] = gi();\n  for (int i = 1; i <= n; i++) w[i] = gi();\n  for (int i = 1; i < n; i++) add(gi(), gi());\n  for (int i = 1; i <= n; i++) a[i] = gi();\n  for (int i = 1; i <= k; i++)\n    if (gi())\n      q[++qs].x = gi(), q[qs].y = gi(), q[qs].t = ups, q[qs].id = qs;\n    else\n      upd[++ups].x = gi(), upd[ups].y = gi();\n  for (int i = 1; i <= ups; i++) upd[i].b = a[upd[i].x], a[upd[i].x] = upd[i].y;\n  for (int i = ups; i; i--) back(i);\n  fa[1] = 1;\n  dfs1(1), dfs2(1, 1);\n  if (!sta.empty()) {\n    bls++;\n    while (!sta.empty()) bl[sta.top()] = bls, sta.pop();\n  }\n  for (int i = 1; i <= n; i++)\n    if (id[q[i].x] > id[q[i].y]) swap(q[i].x, q[i].y);\n  sort(q + 1, q + qs + 1);\n  int x = 1, y = 1, t = 0;\n  for (int i = 1; i <= qs; i++) {\n    if (x != q[i].x) move(x, q[i].x), x = q[i].x;\n    if (y != q[i].y) move(y, q[i].y), y = q[i].y;\n    int f = lca(x, y);\n    update(f);\n    while (t < q[i].t) change(++t);\n    while (t > q[i].t) back(t--);\n    ans[q[i].id] = now;\n    update(f);\n  }\n  for (int i = 1; i <= qs; i++) printf(\"%lld\\n\", ans[i]);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Split Operation for Linked List Chtholly Tree in C++\nDESCRIPTION: Implements the split operation for a linked list implementation of the Chtholly Tree. It finds or creates a block with a left endpoint of mid+1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nBlock *split(int mid) {\n  for (Block *b = root; b; b = b->next) {\n    if (b->l == mid + 1) {\n      return b;\n    }\n    if (b->l <= mid && mid + 1 <= b->r) {\n      b->next = new Block(b->next, mid + 1, b->r, b->val);\n      b->r = mid;\n      return b->next;\n    }\n  }\n  return nullptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamTokenizer for Memory-Efficient I/O in Java\nDESCRIPTION: Using StreamTokenizer as an alternative to StringTokenizer for input operations when memory usage is a concern. Includes methods for reading different data types and a usage example.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.*;\npublic class Main {\n    // IO 代码\n    public static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in), 32768));\n    public static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n    public static double nextDouble() throws IOException { in.nextToken(); return in.nval; }\n    public static float nextFloat() throws IOException { in.nextToken(); return (float)in.nval; }\n    public static int nextInt() throws IOException { in.nextToken(); return (int)in.nval; }\n    public static String next() throws IOException { in.nextToken(); return in.sval; }\n    public static long nextLong() throws Exception { in.nextToken(); return (long)in.nval;}\n    \n    // 使用示例\n    public static void main(String[] args) throws Exception {\n        int n = nextInt();\n        out.println(n);\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: 3x+1 Conjecture Verification Using While Loop in C++\nDESCRIPTION: Example implementation of the Collatz conjecture (3x+1 problem) using a while loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (x > 1) {\n  if (x % 2 == 1) {\n    x = 3 * x + 1;\n  } else {\n    x = x / 2;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assign Operation for Chtholly Tree using std::map in C++\nDESCRIPTION: Implements the assign operation for a Chtholly Tree using std::map. It removes all interval start points within [l,r-1] and creates a new interval.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid assign(int l, int r, int v) {\n  split(l);\n  split(r);\n  auto it = mp.find(l);\n  while (it->first != r) {\n    it = mp.erase(it);\n  }\n  mp[l] = v;\n}\n```\n\n----------------------------------------\n\nTITLE: Power Operations and Big Integers in Python\nDESCRIPTION: Demonstrates Python's power operations and its ability to handle arbitrarily large integers. Shows both the ** operator and the pow() function with modulo capability for efficient computation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> 3 ** 4 # 幂运算\n81\n>>> 2 ** 512\n13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096\n>>> pow(2, 512, int(1e4)) # 即 2**512 % 10000 的快速实现, 1e4 是 float 所以要转 int\n4096\n>>> 2048 ** 2048 # 在IDLE里试试大整数？\n>>> 0.1 + 0.1 + 0.1 - 0.3 == 0.  # 和 C/C++ 一样需要注意浮点数不能直接判相等\nFalse\n```\n\n----------------------------------------\n\nTITLE: Querying kth Smallest Element with Binary Indexed Tree in Python\nDESCRIPTION: This Python function implements the same kth smallest element query using a Binary Indexed Tree. It uses the same power-of-two jumping technique as the C++ version for efficient searching.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ndef kth(k):\n    sum = 0\n    x = 0\n    i = int(log2(n))\n    while ~i:\n        x = x + (1 << i)  # 尝试扩展\n        if x >= n or sum + t[x] >= k:  # 如果扩展失败\n            x = x - (1 << i)\n        else:\n            sum = sum + t[x]\n        i = i - 1\n    return x + 1\n```\n\n----------------------------------------\n\nTITLE: Basic Enumeration in Python\nDESCRIPTION: A simple implementation of enumeration to find number pairs that sum to zero in an array. This version iterates through all possible pairs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(n):\n    for j in range(n):\n        if a[i] + a[j] == 0:\n            ans += 1\n```\n\n----------------------------------------\n\nTITLE: Minimal Polynomial Factorization in LaTeX\nDESCRIPTION: Mathematical expression showing the factorization of a minimal polynomial m_A(λ) into powers of linear factors, where λ₁ through λₛ are the distinct eigenvalues with respective multiplicities r₁ through rₛ.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nm_A(\\lambda)={(\\lambda-\\lambda_1)}^{r_1}\\cdots{(\\lambda-\\lambda_S)}^{r_S}\n```\n\n----------------------------------------\n\nTITLE: Generic Lambda in C++14\nDESCRIPTION: Demonstrates the use of auto in lambda parameters to create generic lambdas in C++14.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nauto add = [](auto a, auto b) { return a + b; };\n```\n\n----------------------------------------\n\nTITLE: Function Pointers in C++\nDESCRIPTION: Demonstrates the use of function pointers to dynamically select and call functions based on runtime conditions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n\nint (*binary_int_op)(int, int);\n\nint foo1(int a, int b) { return a * b + b; }\n\nint foo2(int a, int b) { return (a + b) * b; }\n\nint main() {\n  int choice;\n  std::cin >> choice;\n  if (choice == 1) {\n    binary_int_op = foo1;\n  } else {\n    binary_int_op = foo2;\n  }\n\n  int m, n;\n  std::cin >> m >> n;\n  std::cout << binary_int_op(m, n);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Lin-Shie Algorithm for Polynomial Root-Finding in C\nDESCRIPTION: This function implements the Lin-Shie algorithm to find a quadratic factor of a polynomial. It iteratively refines the coefficients p and q of the quadratic factor x^2 + px + q until the desired precision is reached.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fundamental.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nvoid Shie(double a[], int n, double *p, double *q) {\n  memset(b, 0, sizeof(b));\n  memset(c, 0, sizeof(c));\n  *p = 0;\n  *q = 0;\n  double dp = 1;\n  double dq = 1;\n  while (dp > eps || dp < -eps || dq > eps || dq < -eps)\n  {\n    double p0 = p;\n    double q0 = q;\n    b[n - 2] = a[n];\n    c[n - 2] = b[n - 2];\n    b[n - 3] = a[n - 1] - p0 * b[n - 2];\n    c[n - 3] = b[n - 3] - p0 * b[n - 2];\n    int j;\n    for (j = n - 4; j >= 0; j--) {\n      b[j] = a[j + 2] - p0 * b[j + 1] - q0 * b[j + 2];\n      c[j] = b[j] - p0 * c[j + 1] - q0 * c[j + 2];\n    }\n    double r = a[1] - p0 * b[0] - q0 * b[1];\n    double s = a[0] - q0 * b[0];\n    double rp = c[1];\n    double sp = b[0] - q0 * c[2];\n    double rq = c[0];\n    double sq = -q0 * c[1];\n    dp = (rp * s - r * sp) / (rp * sq - rq * sp);\n    dq = (r * sq - rq * s) / (rp * sq - rq * sp);\n    *p += dp;\n    *q += dq;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rotation Operation for Treap in C++\nDESCRIPTION: Implements the rotation operation for a Treap, which is used to maintain heap property while preserving binary search tree property. Supports both left and right rotations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nenum rot_type { LF = 1, RT = 0 };\n\nvoid _rotate(Node *&cur,\n             rot_type dir) {  // dir参数代表旋转的方向 0为右旋，1为左旋\n  // 注意传进来的 cur 是指针的引用，也就是改了这个\n  // cur，变量是跟着一起改的，如果这个 cur 是别的 树的子节点，根据 ch\n  // 找过来的时候，也是会找到这里的\n\n  // 以下的代码解释的均是左旋时的情况\n  Node *tmp = cur->ch[dir];  // 让 C 变成根节点，\n                             // 这里的 tmp\n                             // 是一个临时的节点指针，指向成为新的根节点的节点\n\n  /* 左旋：也就是让右子节点变成根节点\n   *         A                 C\n   *        / \\               / \\\n   *       B  C    ---->     A   E\n   *         / \\            / \\\n   *        D   E          B   D\n   */\n  cur->ch[dir] = tmp->ch[!dir];    // 让 A 的右子节点变成 D\n  tmp->ch[!dir] = cur;             // 让 C 的左子节点变成 A\n  cur->upd_siz(), tmp->upd_siz();  // 更新大小信息\n  cur = tmp;  // 最后把临时储存 C 树的变量赋值到当前根节点上（注意 cur 是引用）\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Luogu P4377 Talent Show with 0/1 Knapsack in C++\nDESCRIPTION: This code demonstrates how to solve the Luogu P4377 problem using fractional programming combined with a 0/1 knapsack approach to handle additional constraints.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/frac-programming.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\ndouble f[1010];\n\nbool check(double mid) {\n  for (int i = 1; i <= W; i++) f[i] = -1e9;\n  for (int i = 1; i <= n; i++)\n    for (int j = W; j >= 0; j--) {\n      int k = min(W, j + b[i]);\n      f[k] = max(f[k], f[j] + a[i] - mid * b[i]);\n    }\n  return f[W] > 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sequence Automaton in C++\nDESCRIPTION: This code snippet demonstrates the implementation of a sequence automaton for solving the 'Shortest Uncommon Substring' problem from HEOI2015. It includes functions for building the automaton and solving various subproblems related to substrings and subsequences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/seq-automaton.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/seq-automaton/seq-automaton_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Traversing All Subsets Including Empty Set in C++\nDESCRIPTION: Code snippet that iterates through all subsets of a binary mask, including the empty subset (represented as 0). It uses a for loop with a manual break condition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n// 降序遍历 m 的子集\nfor (int s = m;; s = (s - 1) & m) {\n  // s 是 m 的一个子集\n  if (s == 0) break;\n}\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 2 of LTE Lemma - Induction for n=p^a\nDESCRIPTION: Mathematical induction step in the proof of the second part of the Lifting the Exponent lemma for the case when n=p^a.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)+a\n```\n\n----------------------------------------\n\nTITLE: Alternative Method for Aligned Equations using amsmath\nDESCRIPTION: Shows a better way to align equations using the align environment from the amsmath package, which avoids spacing issues that can occur with eqnarray.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_6\n\nLANGUAGE: tex\nCODE:\n```\n\\usepackage{amsmath}\n...\n\\begin{align}\n  a & = b + c \\\\\n    & = y - z\n\\end{align}\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Pack Expansion Examples in C++\nDESCRIPTION: Demonstrates various ways to expand parameter packs in variadic templates, including simple expansion, prefix operations, and mixed positions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_16\n\nLANGUAGE: cpp\nCODE:\n```\nf(args...);       // expands to f(E1, E2, E3)\nf(&args...);      // expands to f(&E1, &E2, &E3)\nf(n, ++args...);  // expands to f(n, ++E1, ++E2, ++E3);\nf(++args..., n);  // expands to f(++E1, ++E2, ++E3, n);\n\ntemplate <typename... Ts>\nvoid f(Ts...) {}\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Complexity for Nested Loops in Java\nDESCRIPTION: Illustrates the triple nested loop structure in Java, maintaining the O(n^2 * m) time complexity pattern seen in the C++ and Python examples.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_2\n\nLANGUAGE: Java\nCODE:\n```\nint n, m;\nn = input.nextInt();\nm = input.nextInt();\nfor (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n        for (int k = 0; k < m; ++k) {\n            System.out.println(\"hello world\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Pólya Counting Theorem Statement\nDESCRIPTION: Formal statement of the unweighted version of the Pólya counting theorem for calculating the number of distinct colorings under group symmetries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n$$\n|C^X/G|=\\frac{1}{|G|}\\sum_{g\\in G}m^{c(g)},\n$$\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda Using Class Implementation in C++\nDESCRIPTION: This implementation manually expands the lambda into a class definition, allowing direct recursion through the this pointer. This provides explicit type information and avoids capture issues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nint n = 10;\n\nclass Lambda_1 {\n public:\n  auto operator()(int i) const -> void {\n    if (i == n)\n      return;\n    else\n      (*this)(i + 1);  // OK\n  }\n\n  explicit Lambda_1(int& __n) : n(__n) {}\n\n private:\n  int& n;\n} dfs(n);\n\ndfs(1);\n```\n\n----------------------------------------\n\nTITLE: RMQ-Based LCA Implementation using Euler Tour\nDESCRIPTION: Implementation of LCA using Euler tour sequence and RMQ (Range Minimum Query). Uses sparse table for RMQ processing with O(n log n) preprocessing and O(1) query time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/lca.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint dfn[N << 1], pos[N], tot, st[30][(N << 1) + 2],\n    rev[30][(N << 1) + 2];  // rev表示最小深度对应的节点编号\n\nvoid dfs(int cur, int dep) {\n  dfn[++tot] = cur;\n  depth[tot] = dep;\n  pos[cur] = tot;\n  for (int i = head[t]; i; i = side[i].next) {\n    int v = side[i].to;\n    if (!pos[v]) {\n      dfs(v, dep + 1);\n      dfn[++tot] = cur, depth[tot] = dep;\n    }\n  }\n}\n\nvoid init() {\n  for (int i = 2; i <= tot + 1; ++i)\n    lg[i] = lg[i >> 1] + 1;  // 预处理 lg 代替库函数 log2 来优化常数\n  for (int i = 1; i <= tot; i++) st[0][i] = depth[i], rev[0][i] = dfn[i];\n  for (int i = 1; i <= lg[tot]; i++)\n    for (int j = 1; j + (1 << i) - 1 <= tot; j++)\n      if (st[i - 1][j] < st[i - 1][j + (1 << i - 1)])\n        st[i][j] = st[i - 1][j], rev[i][j] = rev[i - 1][j];\n      else\n        st[i][j] = st[i - 1][j + (1 << i - 1)],\n        rev[i][j] = rev[i - 1][j + (1 << i - 1)];\n}\n\nint query(int l, int r) {\n  int k = lg[r - l + 1];\n  return st[k][l] < st[k][r + 1 - (1 << k)] ? rev[k][l]\n                                            : rev[k][r + 1 - (1 << k)];\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Predecessor and Successor Queries in Scapegoat Tree in C++\nDESCRIPTION: Finds the predecessor (largest element smaller than v) and successor (smallest element larger than v) in the scapegoat tree using rank queries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nint pre(int v) { return kth(rank(v) - 1); }\nint nxt(int v) { return kth(rank(v + 1)); }\n```\n\n----------------------------------------\n\nTITLE: Querying Rank and K-th Element in Weight Balanced Leafy Tree in C++\nDESCRIPTION: Functions for querying the rank of a value and finding the k-th element in the WBLT. These operations use binary search-like traversal of the tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nint rank(int x, int v) {\n  if (leaf(x)) {\n    return 1;\n  }\n  if (vl[ls[x]] >= v) {\n    return rank(ls[x], v);\n  } else {\n    return rank(rs[x], v) + sz[ls[x]];\n  }\n}\n\nint kth(int x, int v) {\n  if (sz[x] == v) {\n    return vl[x];\n  }\n  if (sz[ls[x]] >= v) {\n    return kth(ls[x], v);\n  } else {\n    return kth(rs[x], v - sz[ls[x]]);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmark Test for Lambda Recursion Techniques\nDESCRIPTION: This code compares the performance between std::function and template lambda recursion implementations for calculating Fibonacci numbers. The benchmark shows std::function is significantly slower.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <random>\n\nusing namespace std;\n\nconst auto& nums = [] {\n  random_device rd;\n  mt19937 gen{rd()};\n  array<unsigned, 32> arr{};\n\n  std::iota(arr.begin(), arr.end(), 0u);\n  ranges::shuffle(arr, gen);\n\n  return arr;\n}();\n\nstatic void std_function_fib(benchmark::State& state) {\n  std::function<int(int)> fib;\n\n  fib = [&](int n) { return n <= 2 ? 1 : fib(n - 1) + fib(n - 2); };\n\n  unsigned i = 0;\n\n  for (auto _ : state) {\n    auto res = fib(nums[i]);\n    benchmark::DoNotOptimize(res);\n\n    ++i;\n\n    if (i == nums.size()) i = 0;\n  }\n}\n\nBENCHMARK(std_function_fib);\n\nstatic void template_lambda_fib(benchmark::State& state) {\n  auto n_fibonacci = [](const auto& self, int n) -> int {\n    return n <= 2 ? 1 : self(self, n - 1) + self(self, n - 2);\n  };\n\n  unsigned i = 0;\n\n  for (auto _ : state) {\n    auto res = n_fibonacci(n_fibonacci, nums[i]);\n    benchmark::DoNotOptimize(res);\n\n    ++i;\n\n    if (i == nums.size()) i = 0;\n  }\n}\n\nBENCHMARK(template_lambda_fib);\n```\n\n----------------------------------------\n\nTITLE: Comparing if Statements in Pascal and C++\nDESCRIPTION: Shows the syntax differences between Pascal and C++ for conditional statements, highlighting operator differences and common pitfalls.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_4\n\nLANGUAGE: Pascal\nCODE:\n```\nif (a = b) and (a > 0) and (b > 0) then\n    begin\n        b := a;\n    end\nelse\n    begin\n        a := b;\n    end;\n```\n\nLANGUAGE: C++\nCODE:\n```\nif (a == b && a > 0 && b > 0) {\n  b = a;\n} else {\n  a = b;\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Tree Divide Solution for Hide-and-Seek Problem in C++\nDESCRIPTION: This code implements a solution to the ZJOI2007 Hide-and-Seek problem using dynamic tree divide. It maintains distance information using erasable heaps and handles color flipping operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dynamic-tree-divide.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/dynamic-tree-divide/dynamic-tree-divide_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Calculating DFS and Low Numbers in C++\nDESCRIPTION: This function performs a depth-first search to calculate DFS numbers and low numbers for each node in the graph. It is used as part of constructing the block forest.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/block-forest.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid Tarjan(int u) {\n  low[u] = dfn[u] = ++dfc;                // low 初始化为当前节点 dfn\n  for (int v : G[u]) {                    // 遍历 u 的相邻节点\n    if (!dfn[v]) {                        // 如果未访问过\n      Tarjan(v);                          // 递归\n      low[u] = std::min(low[u], low[v]);  // 未访问的和 low 取 min\n    } else\n      low[u] = std::min(low[u], dfn[v]);  // 已访问的和 dfn 取 min\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Program Testing Framework in C++\nDESCRIPTION: Implementation of a testing framework for comparing outputs of two programs. Uses system commands to generate test data and compare program outputs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <cstdlib>\n\nint main() {\n  // For Windows\n  // 对拍时不开文件输入输出\n  // 当然，这段程序也可以改写成批处理的形式\n  while (true) {\n    system(\"gen > test.in\");  // 数据生成器将生成数据写入输入文件\n    system(\"test1.exe < test.in > a.out\");  // 获取程序1输出\n    system(\"test2.exe < test.in > b.out\");  // 获取程序2输出\n    if (system(\"fc a.out b.out\")) {\n      // 该行语句比对输入输出\n      // fc返回0时表示输出一致，否则表示有不同处\n      system(\"pause\");  // 方便查看不同处\n      return 0;\n      // 该输入数据已经存放在test.in文件中，可以直接利用进行调试\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Scope Resolution Operator in C++\nDESCRIPTION: Shows the usage of the scope resolution operator (::) to access a class member.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nClass::age = 2;\n```\n\n----------------------------------------\n\nTITLE: Range Modification and Query Operations for Block Array\nDESCRIPTION: Implements range addition operations and count queries for elements above a threshold in a block array structure. Uses delta array for lazy updates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-array.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Sort(int k) {\n  for (int i = st[k]; i <= ed[k]; i++) t[i] = a[i];\n  sort(t + st[k], t + ed[k] + 1);\n}\n\nvoid Modify(int l, int r, int c) {\n  int x = belong[l], y = belong[r];\n  if (x == y)  // 区间在一个块内就直接修改\n  {\n    for (int i = l; i <= r; i++) a[i] += c;\n    Sort(x);\n    return;\n  }\n  for (int i = l; i <= ed[x]; i++) a[i] += c;     // 直接修改起始段\n  for (int i = st[y]; i <= r; i++) a[i] += c;     // 直接修改结束段\n  for (int i = x + 1; i < y; i++) delta[i] += c;  // 中间的块整体打上标记\n  Sort(x);\n  Sort(y);\n}\n\nint Answer(int l, int r, int c) {\n  int ans = 0, x = belong[l], y = belong[r];\n  if (x == y) {\n    for (int i = l; i <= r; i++)\n      if (a[i] + delta[x] >= c) ans++;\n    return ans;\n  }\n  for (int i = l; i <= ed[x]; i++)\n    if (a[i] + delta[x] >= c) ans++;\n  for (int i = st[y]; i <= r; i++)\n    if (a[i] + delta[y] >= c) ans++;\n  for (int i = x + 1; i <= y - 1; i++)\n    ans +=\n        ed[i] - (lower_bound(t + st[i], t + ed[i] + 1, c - delta[i]) - t) + 1;\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: 状态最小表示编码实现 (C++)\nDESCRIPTION: 连通性状态的最小表示编码实现，用于在一条回路覆盖问题中区分插头之间的连通性。包含编码和解码函数，将相同状态映射为字典序最小的表示。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint b[M + 1], bb[M + 1];\n\nint encode() {\n  int s = 0;\n  memset(bb, -1, sizeof(bb));\n  int bn = 1;\n  bb[0] = 0;\n  for (int i = m; i >= 0; --i) {\n#define bi bb[b[i]]\n    if (!~bi) bi = bn++;\n    s <<= offset;\n    s |= bi;\n  }\n  return s;\n}\n\nvoid decode(int s) {\n  REP(i, m + 1) {\n    b[i] = s & mask;\n    s >>= offset;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Delete Operation in ETT\nDESCRIPTION: Operation to remove an edge between two vertices by splitting and merging sequences. Handles deletion of edge nodes and sequence reorganization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/ett.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid Delete(int u, int v) {\n  Node* edge_uv = tree_edges_[u][v];\n  Node* edge_vu = tree_edges_[v][u];\n  tree_edges_[u].erase(v);\n  tree_edges_[v].erase(u);\n\n  int position_uv = Treap::GetPosition(edge_uv);\n  int position_vu = Treap::GetPosition(edge_vu);\n  if (position_uv > position_vu) {\n    std::swap(edge_uv, edge_vu);\n    std::swap(position_uv, position_vu);\n  }\n\n  auto [L1, uv, _] = Treap::SplitUp3(edge_uv);\n  auto [L2, vu, L3] = Treap::SplitUp3(edge_vu);\n  Treap::Merge(L1, L3);\n\n  FreeNode(edge_uv);\n  FreeNode(edge_vu);\n}\n```\n\n----------------------------------------\n\nTITLE: Finding Closest Element with lower_bound in C++\nDESCRIPTION: Demonstrates using lower_bound to find the element in a sorted array that is closest to a given value. This example handles edge cases and compares adjacent elements to determine the closest match.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/algorithm.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nint N = 10, a[] = {1, 1, 2, 4, 5, 5, 8, 8, 9, 9}, x = 6;\n// lower_bound将返回a中第一个大于等于x的元素的地址，计算出的i为其下标\nint i = lower_bound(a, a + N, x) - a;\n// 在以下两种情况下，a[i] (a中第一个大于等于x的元素) 即为答案：\n// 1. a中最小的元素都大于等于x；\n// 2. a中存在大于等于x的元素，且第一个大于等于x的元素 (a[i])\n// 相比于第一个小于x的元素 (a[i - 1]) 更接近x；\n// 否则，a[i - 1] (a中第一个小于x的元素) 即为答案\nif (i == 0 || (i < N && a[i] - x < x - a[i - 1]))\n  cout << a[i];\nelse\n  cout << a[i - 1];\n```\n\n----------------------------------------\n\nTITLE: Lemma for Double Cross Product with Same Vector\nDESCRIPTION: This formula shows that the cross product of (a×b) with a can be expressed in terms of dot products and the original vectors. This serves as a foundation for the more general double cross product theorem.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n(\\boldsymbol a \\times \\boldsymbol b)\\times \\boldsymbol a = (\\boldsymbol a \\cdot \\boldsymbol a) \\boldsymbol b - (\\boldsymbol a \\cdot \\boldsymbol b) \\boldsymbol a\n```\n\n----------------------------------------\n\nTITLE: Optimized Pollard-Rho with Brent Cycle Detection in C++\nDESCRIPTION: An optimized implementation of Pollard-Rho using Brent's cycle detection method and a multiplication accumulation technique to reduce GCD calculations. This approach is more efficient for factoring very large numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nll Pollard_Rho(ll x) {\n  ll t = 0;\n  ll c = rand() % (x - 1) + 1;\n  ll s = t;\n  int step = 0, goal = 1;\n  ll val = 1;\n  for (goal = 1;; goal <<= 1, s = t, val = 1) {\n    for (step = 1; step <= goal; ++step) {\n      t = f(t, c, x);\n      val = val * abs(t - s) % x;\n      // 如果 val 为 0，退出重新分解\n      if (!val) return x;\n      if (step % 127 == 0) {\n        ll d = gcd(val, x);\n        if (d > 1) return d;\n      }\n    }\n    ll d = gcd(val, x);\n    if (d > 1) return d;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplying and Dividing by Powers of Two in Python\nDESCRIPTION: Python functions that multiply or divide an integer by a power of two using bitwise shift operations, which is more efficient than standard multiplication or division operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef mulPowerOfTwo(n, m): # 计算 n*(2^m)\n    return n << m\ndef divPowerOfTwo(n, m): # 计算 n/(2^m)\n    return n >> m\n```\n\n----------------------------------------\n\nTITLE: Optimized Fraction Finding in Stern-Brocot Tree with C++\nDESCRIPTION: An optimized algorithm for finding a fraction p/q in a Stern-Brocot tree with O(log(p+q)) complexity. This implementation optimizes the search by handling consecutive movements in the same direction all at once.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nstring find(int p, int q) {\n    int a = 0, b = 1, c = 1, d = 0;\n    string path;\n    while (a + c != p || b + d != q) {\n        if (c * q > d * p) {\n            int t = (c * q - d * p - 1) / (a * q - b * p) + 1;\n            path += string(t, 'L');\n            c = t * a + c;\n            d = t * b + d;\n        } else {\n            int t = (a * q - b * p - 1) / (c * q - d * p) + 1;\n            path += string(t, 'R');\n            a = a + t * c;\n            b = b + t * d;\n        }\n    }\n    return path;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Split Operation for Chtholly Tree in C++\nDESCRIPTION: Implements the split operation, which is core to the Chtholly Tree. It splits an interval containing point x into two intervals and returns an iterator to the right interval.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nauto split(int x) {\n  auto it = odt.lower_bound(Node_t(x, 0, 0));\n  if (it != odt.end() && it->l == x) return it;\n  --it;\n  int l = it->l, r = it->r, v = it->v;\n  odt.erase(it);\n  odt.insert(Node_t(l, x - 1, v));\n  return odt.insert(Node_t(x, r, v)).first;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SPJ with Testlib\nDESCRIPTION: Special Judge implementation using Testlib library to compare floating point answers with a tolerance of 1e-3. Uses Testlib's built-in functions for input/output handling and result reporting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/special-judge.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include \"testlib.h\"\n#include <cmath>\n\nint main(int argc, char *argv[]) {\n  registerTestlibCmd(argc, argv);\n\n  double pans = ouf.readDouble(), jans = ans.readDouble();\n\n  if (abs(pans - jans) < 1e-3)\n    quitf(_ok, \"Good job\\n\");\n  else\n    quitf(_wa, \"Too big or too small, expected %f, found %f\\n\", jans, pans);\n}\n```\n\n----------------------------------------\n\nTITLE: Mo's Algorithm with Bitset Implementation in C++\nDESCRIPTION: Implementation of a solution combining Mo's Algorithm with bitset for handling interval queries. The code includes special adjustments for handling value frequencies and maintaining proper pointer movement order. It handles discrete value tracking and manages memory constraints by processing queries in blocks.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/mo-algo-with-bitset.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/misc/code/mo-algo-with-bitset/mo-algo-with-bitset_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Perfect Elimination Ordering Verification in C++\nDESCRIPTION: Code to verify if a given ordering is a perfect elimination ordering for a graph. Uses optimized O(n+m) approach by checking adjacency of neighbors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/chord.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\njud = true;\nfor (int i = 1; i <= n; i++) {\n  cur = 0;\n  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)\n    if (rnk[p[i]] < rnk[*it]) {\n      s[++cur] = *it;\n      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);\n    }\n  for (int j = 2; j <= cur; j++)\n    if (!st[s[1]].count(s[j])) {\n      jud = false;\n      break;\n    }\n}\nif (!jud)\n  printf(\"Imperfect\\n\");\nelse\n  printf(\"Perfect\\n\");\n```\n\n----------------------------------------\n\nTITLE: Definition of Prime Elements in an Integral Domain\nDESCRIPTION: The definition of prime elements in an integral domain, which are elements whose corresponding principal ideals are prime ideals.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_22\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"素元\"\n    设整环 $R$ 有非零元素 $p\\in R$，如果 $(p)$ 是素理想，也就是说，$p$ 不是可逆元，且 $p\\mid ab$ 总能推出 $p\\mid a$ 或 $p\\mid b$，则称 $p$ 是 **素元**（prime）。\n```\n\n----------------------------------------\n\nTITLE: Implementing SPJ for Lemon OJ\nDESCRIPTION: Special Judge implementation for Lemon Online Judge platform. Handles file I/O and scoring according to Lemon's specifications.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/special-judge.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <cstdio>\n\nint main(int argc, char* argv[]) {\n  FILE* fin = fopen(argv[1], \"r\");\n  FILE* fout = fopen(argv[2], \"r\");\n  FILE* fstd = fopen(argv[3], \"r\");\n  FILE* fscore = fopen(argv[5], \"w\");\n  FILE* freport = fopen(argv[6], \"w\");\n\n  double pans, jans;\n  fscanf(fout, \"%lf\", &pans);\n  fscanf(fstd, \"%lf\", &jans);\n\n  if (abs(pans - jans) < 1e-3) {\n    fprintf(fscore, \"%s\", argv[4]);\n    fprintf(freport, \"Good job\\n\");\n  } else {\n    fprintf(fscore, \"%d\", 0);\n    fprintf(freport, \"Too big or too small, expected %f, found %f\\n\", jans, pans);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Naive DFS for Herb Collection Problem in Python\nDESCRIPTION: A basic depth-first search implementation in Python for the NOIP2005 herb collection problem without memoization. This approach has exponential time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ntcost = [0] * 103\nmget = [0] * 103\nans = 0\n\n\ndef dfs(pos, tleft, tans):\n    global ans\n    if tleft < 0:\n        return\n    if pos == n + 1:\n        ans = max(ans, tans)\n        return\n    dfs(pos + 1, tleft, tans)\n    dfs(pos + 1, tleft - tcost[pos], tans + mget[pos])\n\n\nt, n = map(lambda x: int(x), input().split())\nfor i in range(1, n + 1):\n    tcost[i], mget[i] = map(lambda x: int(x), input().split())\ndfs(1, t, 0)\nprint(ans)\n```\n\n----------------------------------------\n\nTITLE: Pointer Operations with Structs in C++\nDESCRIPTION: Shows how to use pointers with structs, including member access and assignment.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct ThreeInt {\n  int a;\n  int b;\n  int c;\n};\n\nint main() {\n  ThreeInt x{1, 2, 3}, y{6, 7, 8};\n  ThreeInt* px = &x;\n  (*px) = y;    // x: {6,7,8}\n  (*px).a = 4;  // x: {4,7,8}\n  px->b = 5;    // x: {4,5,8}\n}\n```\n\n----------------------------------------\n\nTITLE: Importing STL Rope in C++\nDESCRIPTION: Shows how to import the STL rope data structure, which provides functionality similar to a blocked list but with different time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-list.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <ext/rope>\nusing namespace __gnu_cxx;\n```\n\n----------------------------------------\n\nTITLE: Incorrect Semicolon in Control Flow\nDESCRIPTION: This snippet demonstrates how an accidental semicolon after a while condition creates an infinite loop with an unreachable print statement. The loop body is effectively empty due to the semicolon.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n/* clang-format off */\nwhile (1);\n    printf(\"OI Wiki!\\n\");\n```\n\n----------------------------------------\n\nTITLE: Optimized Recurrence Relation for Unordered Partitions\nDESCRIPTION: An optimized dynamic programming recurrence relation for counting the number of ways to partition an integer n into any number of positive integers, where order doesn't matter. This approach reduces computational complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/count.md#2025-04-22_snippet_1\n\nLANGUAGE: mathematical notation\nCODE:\n```\nf_{n, M} = f_{n, M - 1} + \\begin{cases} f_{n - M, M} & n \\ge M, \\\\ 0 & \\text{otherwise}. \\end{cases}\n```\n\n----------------------------------------\n\nTITLE: AC Automaton Template 3 for Advanced Pattern Matching\nDESCRIPTION: Advanced AC automaton implementation for Luogu P5357 problem, handling more complex pattern matching scenarios.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/ac-automaton.md#2025-04-22_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/string/code/ac-automaton/ac-automaton_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Implicit Deque with Finger Trees in Haskell\nDESCRIPTION: The data structure definition for an Implicit Deque implemented using Finger Trees. This enables efficient double-ended queue operations with amortized constant time complexity for operations at both ends.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/finger-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: haskell\nCODE:\n```\ndata ImplicitDeque a = Empty\n                     | Single a\n                     | Deep (Digit a) (ImplicitDeque (a, a)) (Digit a)\n\ndata Digit a = One a | Two a a | Three a a a\n```\n\n----------------------------------------\n\nTITLE: Defining Outer Product in LaTeX\nDESCRIPTION: LaTeX code for defining the outer product (cross product) of two vectors using a determinant representation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{vmatrix}\n    \\boldsymbol{i} & \\boldsymbol{j} & \\boldsymbol{k} \\\\\n    x_1 & y_1 & z_1  \\\\\n    x_2 & y_2 & z_2\n\\end{vmatrix}\n```\n\n----------------------------------------\n\nTITLE: Boyer-Moore string matching algorithm implementation\nDESCRIPTION: This pseudocode implements the Boyer-Moore string matching algorithm. It uses delta1 and delta2 functions to determine the optimal shift distance when a mismatch occurs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\ni ← patlastpos\nj ← patlastpos\nloop\n    if j < 0\n        return i+1\n    \n    if string[i] = pat[j]\n        j ← j-1\n        i ← i-1\n        continue\n    \n    i ← i + max(delta_1(string[i]), delta_2(j))\n    \n    if i > stringlastpos\n        return false\n    j ← patlastpos\n```\n\n----------------------------------------\n\nTITLE: Linear Congruential Random Number Generator Implementation in C++\nDESCRIPTION: Implements a basic linear congruential random number generator. Demonstrates a simple custom random number generation technique using modular arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\nusing namespace std;\n\nstruct myrand {\n  int A, B, P, x;\n\n  myrand(int A, int B, int P) {\n    this->A = A;\n    this->B = B;\n    this->P = P;\n  }\n\n  int next() { return x = (A * x + B) % P; }\n};\n\nmyrand rnd(3, 5, 97);\n\nint main() {\n  int x = rnd.next();\n  cout << x << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Point Value for Range Maximum with Binary Indexed Tree in C++\nDESCRIPTION: This function updates a single point value in a Binary Indexed Tree maintaining range maximum. It reconstructs the affected intervals to ensure correctness, with a time complexity of O(log^2 n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_13\n\nLANGUAGE: C++\nCODE:\n```\nvoid update(int x, int v) {\n  a[x] = v;\n  for (int i = x; i <= n; i += lowbit(i)) {\n    C[i] = a[i];\n    for (int j = 1; j < lowbit(i); j *= 2) {\n      C[i] = max(C[i], C[i - j]);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Point Dividing Tree Construction Algorithm\nDESCRIPTION: Implementation of point dividing tree construction that transforms a tree into a logarithmic height structure. Uses centroid finding and recursive decomposition to build the new tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-divide.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing IT = vector<int>::iterator;\n\nstruct Edge {\n  int to, nxt, val;\n\n  Edge() {}\n\n  Edge(int to, int nxt, int val) : to(to), nxt(nxt), val(val) {}\n} e[300010];\n\nint head[150010], cnt;\n\nvoid addedge(int u, int v, int val) {\n  e[++cnt] = Edge(v, head[u], val);\n  head[u] = cnt;\n}\n\nint siz[150010], son[150010];\nbool vis[150010];\n\nint tot, lasttot;\nint maxp, root;\n\nvoid getG(int now, int fa) {\n  siz[now] = 1;\n  son[now] = 0;\n  for (int i = head[now]; i; i = e[i].nxt) {\n    int vs = e[i].to;\n    if (vs == fa || vis[vs]) continue;\n    getG(vs, now);\n    siz[now] += siz[vs];\n    son[now] = max(son[now], siz[vs]);\n  }\n  son[now] = max(son[now], tot - siz[now]);\n  if (son[now] < maxp) {\n    maxp = son[now];\n    root = now;\n  }\n}\n\nstruct Node {\n  int fa;\n  vector<int> anc;\n  vector<int> child;\n} nd[150010];\n\nint build(int now, int ntot) {\n  tot = ntot;\n  maxp = 0x7f7f7f7f;\n  getG(now, 0);\n  int g = root;\n  vis[g] = true;\n  for (int i = head[g]; i; i = e[i].nxt) {\n    int vs = e[i].to;\n    if (vis[vs]) continue;\n    int tmp = build(vs, ntot - son[vs]);\n    nd[tmp].fa = now;\n    nd[now].child.push_back(tmp);\n  }\n  return g;\n}\n\nint virtroot;\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i < n; i++) {\n    int u, v, val;\n    cin >> u >> v >> val;\n    addedge(u, v, val);\n    addedge(v, u, val);\n  }\n  virtroot = build(1, n);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing C++ Compiler on Linux\nDESCRIPTION: Command to update package lists and install the g++ compiler on Debian/Ubuntu Linux systems.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/helloworld.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt update && sudo apt install g++\n```\n\n----------------------------------------\n\nTITLE: Set Operations Example\nDESCRIPTION: Demonstrates common Set operations including union, intersection, and difference using HashSet and LinkedHashSet.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_16\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static Set<Integer> s1 = new HashSet<>();\n    static Set<Integer> s2 = new LinkedHashSet<>();\n\n    static void add() {\n        s1.add(1);\n    }\n\n    static void contains() {\n        s1.contains(2);\n    }\n\n    static void test1() {\n        Set<Integer> res = new HashSet<>();\n        res.addAll(s1);\n        res.addAll(s2);\n    }\n\n    static void test2() {\n        Set<Integer> res = new HashSet<>();\n        res.addAll(s1);\n        res.retainAll(s2);\n    }\n\n    static void test3() {\n        Set<Integer> res = new HashSet<>();\n        res.addAll(s1);\n        res.removeAll(s2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using std::pair in Dijkstra's Algorithm\nDESCRIPTION: Example of using pair with priority queue in Dijkstra's algorithm implementation to maintain node distances and indices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\npriority_queue<pair<int, int>, std::vector<pair<int, int>>,\n               std::greater<pair<int, int>>>\n    q;\n... while (!q.empty()) {\n  // dis为入堆时节点到起点的距离，i为节点编号\n  int dis = q.top().first, i = q.top().second;\n  q.pop();\n  ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Red-Black Tree Class in C++\nDESCRIPTION: Defines the RBTreeMap class template for implementing a red-black tree. Includes the Compare function object, Node structure, root pointer, and node count.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <typename Key, typename Value, typename Compare = std::less<Key>>\nclass RBTreeMap {\n  // 排序函数\n  Compare compare = Compare();\n\n  // 节点结构体\n  struct Node {\n    ...\n  };\n\n  // 根节点指针\n  Node* root = nullptr;\n  // 记录红黑树中当前的节点个数\n  size_t count = 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating File Access Between WSL and Windows\nDESCRIPTION: Example showing how files can be accessed and modified between Windows PowerShell and WSL Bash environments using the automatic mount points at /mnt/.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_8\n\nLANGUAGE: console\nCODE:\n```\nPS C:\\Users\\chtholly> bash\n/mnt/c/Users/chtholly$ echo \"Hello world!\" > hello\n/mnt/c/Users/chtholly$ exit\nPS C:\\Users\\chtholly> cat hello\nHello world!\nPS C:\\Users\\chtholly> echo \"Welcome!\" > welcome\nPS C:\\Users\\chtholly> bash\n/mnt/c/Users/chtholly$ cat welcome\nWelcome!\n```\n\n----------------------------------------\n\nTITLE: 子序列匹配 - 查找字典中的最长子序列 (C++)\nDESCRIPTION: 使用双指针判断字典中的字符串是否为给定字符串的子序列,并返回满足条件的最长字符串。函数接受一个字符串和字符串数组作为输入,返回字典中最长的符合条件的字符串。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/two-pointer.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstring findLongestWord(string s, vector<string>& dictionary) {\n  sort(dictionary.begin(), dictionary.end());\n  int mx = 0, r = 0;\n  string ans = \"\";\n  for (int i = dictionary.size() - 1; i >= 0; i--) {\n    r = 0;\n    for (int j = 0; j < s.length(); ++j) {\n      if (s[j] == dictionary[i][r]) r++;\n    }\n    if (r == dictionary[i].length()) {\n      if (r >= mx) {\n        mx = r;\n        ans = dictionary[i];\n      }\n    }\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Linear Congruence for Multiplicative Inverse in F(α)\nDESCRIPTION: Solves a linear congruence equation to find the multiplicative inverse of an element in F(α).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_6\n\nLANGUAGE: LaTeX\nCODE:\n```\n(x^2+x+1)\\xi(x)+(x^3-2x-2)\\nu(x)=1\n```\n\n----------------------------------------\n\nTITLE: Fast Modular Multiplication in C++\nDESCRIPTION: Efficiently multiply two large integers modulo m without using 128-bit integers. Useful for algorithms like Miller-Rabin and Pollard-Rho that require fast modular multiplication.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-exponentiation.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nlong long binmul(long long a, long long b, long long m) {\n  unsigned long long c =\n      (unsigned long long)a * b -\n      (unsigned long long)((long double)a / m * b + 0.5L) * m;\n  if (c < m) return c;\n  return c + m;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Single Point Update for Tree Array in Python\nDESCRIPTION: This function adds a value k to the element at index x in the tree array, updating all necessary parent nodes. It maintains the sum property of the tree array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef add(x, k):\n    while x <= n:  # 不能越界\n        c[x] = c[x] + k\n        x = x + lowbit(x)\n```\n\n----------------------------------------\n\nTITLE: SATT Push Operations Implementation in C++\nDESCRIPTION: Implementation of pushup and pushdown operations for maintaining node information in a Self-Adjusting Top Tree. Handles both Compress and Rake nodes, with support for subtree size maintenance and chain/subtree modifications.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid pushup(int x, int type) {\n  if (type == 0)\n    size[x] = size[rs(x)] + size[ms(x)] + 1;\n  else\n    size[x] = size[rs(x)] + size[ms(x)] + size[ls(x)];\n  return;\n}\n\nvoid pushdown(int x, int type) {\n  if (type == 0) {\n    chain[ls(x)] += chain[x] chain[rs(x)] += chain[x];\n    val[ls(x)] += chain[x];\n    val[rs(x)] += chain[x];\n    subtree[ls(x)] += subtree[x];\n    subtree[rs(x)] += subtree[x];\n    subtree[ms(x)] += subtree[x];\n    val[ls(x)] += subtree[x];\n    val[rs(x)] += subtree[x];\n    val[ms(x)] += subtree[x];\n    subtree[x] = 0;\n  } else {\n    subtree[ls(x)] += subtree[x];\n    subtree[rs(x)] += subtree[x];\n    subtree[ms(x)] += subtree[x];\n    val[ls(x)] += subtree[x];\n    val[rs(x)] += subtree[x];\n    val[ms(x)] += subtree[x];\n    subtree[x] = 0;\n  }\n  return;\n}\n\nvoid pushall(int x, int type) {\n  if (!isroot(x)) pushall(father[x], type);\n  pushdown(x, type);\n  return;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Assign Operation for Chtholly Tree in C++\nDESCRIPTION: Implements the assign operation, which assigns a value v to an interval [l,r]. It uses the split operation to isolate the interval, then erases existing nodes and inserts a new node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid assign(int l, int r, int v) {\n  auto itr = split(r + 1), itl = split(l);\n  odt.erase(itl, itr);\n  odt.insert(Node_t(l, r, v));\n}\n```\n\n----------------------------------------\n\nTITLE: Third Dimension Insert Operation in Tree-on-Tree\nDESCRIPTION: Implements an insert operation for the third dimension of the tree structure. Maintains a counter at each node and uses dynamic allocation for tree expansion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-in-seg.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nvoid vec_insert(int &k, int l, int r, int loc) {\n  if (k == 0) k = ++tot;\n  data[k]++;\n  if (l == r) return;\n  int mid = l + r >> 1;\n  if (loc <= mid) vec_insert(ch[k][0], l, mid, loc);\n  if (loc > mid) vec_insert(ch[k][1], mid + 1, r, loc);\n}\n```\n\n----------------------------------------\n\nTITLE: 利用序列有序性 - 查找有序数组中的两数之和 (C++)\nDESCRIPTION: 在有序数组中使用双指针查找和为目标值的两个数。函数接受一个已排序的整数数组和目标和作为输入,返回满足条件的两个数的索引(从1开始)。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/two-pointer.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvector<int> twoSum(vector<int>& numbers, int target) {\n  int r = numbers.size() - 1, l = 0;\n  vector<int> ans;\n  ans.clear();\n  while (l < r) {\n    if (numbers[l] + numbers[r] > target)\n      r--;\n    else if (numbers[l] + numbers[r] == target) {\n      ans.push_back(l + 1), ans.push_back(r + 1);\n      return ans;\n    } else\n      l++;\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Highly Optimized Enumeration with Bucket in C++\nDESCRIPTION: A highly optimized version using a bucket to record visited numbers, reducing time complexity to O(n). This implementation uses a boolean array to track encountered numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/basic/code/enumerate/enumerate_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Jordan Canonical Form as Matrix Sum\nDESCRIPTION: The expression showing how the Jordan canonical form is constructed as a sum of diagonal and nilpotent components.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_16\n\nLANGUAGE: latex\nCODE:\n```\nB_i=\\begin{pmatrix}\n\\lambda_i &  &  & 0\\\\\n & \\lambda_i &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & \\lambda_i\\\\\n\\end{pmatrix}+\\begin{pmatrix}\nN_{i1} &  &  & 0\\\\\n & N_{i2} &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & N_{is_i}\\\\\n\\end{pmatrix}=\\begin{pmatrix}\nJ_{i1} &  &  & 0\\\\\n & J_{i2} &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & J_{is_i}\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Median of Medians Algorithm Procedure\nDESCRIPTION: Describes the three-step procedure for the Median of Medians algorithm, which is used to find a good pivot element that guarantees linear time complexity for selection algorithms.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/quick-sort.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1.  将整个序列划分为 $\\left \\lfloor \\dfrac{n}{5} \\right \\rfloor$ 组，每组元素数不超过 5 个；\n2.  寻找每组元素的中位数（因为元素个数较少，可以直接使用 [插入排序](./insertion-sort.md) 等算法）。\n3.  找出这 $\\left \\lfloor \\dfrac{n}{5} \\right \\rfloor$ 组元素中位数中的中位数。将该元素作为前述算法中每次划分时的分界值即可。\n```\n\n----------------------------------------\n\nTITLE: Alternative Merge Implementation for Left-Leaning Trees in C++\nDESCRIPTION: Provides an alternative implementation of the merge operation that avoids explicitly swapping left and right children by using a dynamic right child reference.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/leftist-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint& rs(int x) { return t[x].ch[t[t[x].ch[1]].d < t[t[x].ch[0]].d]; }\n\nint merge(int x, int y) {\n  if (!x || !y) return x | y;\n  if (t[x].val < t[y].val) swap(x, y);\n  int& rs_ref = rs(x);\n  rs_ref = merge(rs_ref, y);\n  t[x].d = t[rs(x)].d + 1;\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda with Explicit Object Parameter in C++23\nDESCRIPTION: Shows the use of explicit object parameter in lambda expressions for recursive calls, introduced in C++23.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nauto nth_fibonacci = [](this auto self, unsigned n) -> unsigned {\n  return n < 2 ? n : self(n - 1) + self(n - 2);\n};\n\ncout << nth_fibonacci(10u);\n```\n\n----------------------------------------\n\nTITLE: 实现区间DP状态转移 - Python\nDESCRIPTION: 这段Python代码实现了区间动态规划的状态转移过程。通过三重循环，枚举区间长度len、起始位置i、以及区间内的分割点k，计算将区间[i,j]内的元素合并得到的最大价值f[i][j]。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/interval.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfor len in range(2, n + 1):\n    for i in range(1, 2 * n - len + 1):\n        j = len + i - 1\n        for k in range(i, j):\n            f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + sum[j] - sum[i - 1])\n```\n\n----------------------------------------\n\nTITLE: Miller-Rabin Primality Test Implementation in C++ and Python\nDESCRIPTION: Advanced implementation of the Miller-Rabin primality test that combines Fermat's test with the quadratic detection theorem. It offers better reliability than basic Fermat testing by checking for non-trivial square roots, reducing false positives from Carmichael numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nbool millerRabin(int n) {\n  if (n < 3 || n % 2 == 0) return n == 2;\n  if (n % 3 == 0) return n == 3;\n  int u = n - 1, t = 0;\n  while (u % 2 == 0) u /= 2, ++t;\n  // test_time 为测试次数，建议设为不小于 8\n  // 的整数以保证正确率，但也不宜过大，否则会影响效率\n  for (int i = 0; i < test_time; ++i) {\n    // 0, 1, n-1 可以直接通过测试, a 取值范围 [2, n-2]\n    int a = rand() % (n - 3) + 2, v = quickPow(a, u, n);\n    if (v == 1) continue;\n    int s;\n    for (s = 0; s < t; ++s) {\n      if (v == n - 1) break;  // 得到平凡平方根 n-1，通过此轮测试\n      v = (long long)v * v % n;\n    }\n    // 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t\n    // 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1\n    if (s == t) return 0;\n  }\n  return 1;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef millerRabin(n):\n    if n < 3 or n % 2 == 0:\n        return n == 2\n    if n % 3 == 0:\n        return n == 3\n    u, t = n - 1, 0\n    while u % 2 == 0:\n        u = u // 2\n        t = t + 1\n    # test_time 为测试次数,建议设为不小于 8\n    # 的整数以保证正确率,但也不宜过大,否则会影响效率\n    for i in range(test_time):\n        # 0, 1, n-1 可以直接通过测试, a 取值范围 [2, n-2]\n        a = random.randint(2, n - 2)\n        v = pow(a, u, n)\n        if v == 1:\n            continue\n        s = 0\n        while s < t:\n            if v == n - 1:\n                break\n            v = v * v % n\n            s = s + 1\n        # 如果找到了非平凡平方根，则会由于无法提前 break; 而运行到 s == t\n        # 如果 Fermat 素性测试无法通过，则一直运行到 s == t 前 v 都不会等于 -1\n        if s == t:\n            return False\n    return True\n```\n\n----------------------------------------\n\nTITLE: Inverse of Elementary Matrices in LaTeX\nDESCRIPTION: Formulas showing the inverse matrices for each type of elementary matrix: multiplication, switching, and addition matrices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_4\n\nLANGUAGE: tex\nCODE:\n```\n{D_i(k)}^{-1}=D_i\\left(\\frac{1}{k}\\right)\n```\n\nLANGUAGE: tex\nCODE:\n```\nP_{ij}^{-1}=P_{ij}\n```\n\nLANGUAGE: tex\nCODE:\n```\nT_{ij}(k)^{-1}=T_{ij}(-k)\n```\n\n----------------------------------------\n\nTITLE: Suffix Array Construction Helper Functions in Rust\nDESCRIPTION: This code defines helper functions for constructing a suffix array. It includes _compute_suffix_array_16_1 which handles pattern renaming, LMS character sorting, and induced sorting. The suffix_array_16 function serves as the public API for creating suffix arrays.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sa-optimal-inplace.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nfn _compute_suffix_array_16_1(pat: &mut [usize], sa: &mut [usize]) {\n    rename_pat(pat, sa);\n    let lms_cnt = sort_lms_char(pat, sa);\n    sort_lms_substr(pat, sa);\n    let has_duplicated_char = construct_pat1(pat, sa, lms_cnt);\n    sort_lms_suf(pat, sa, lms_cnt, has_duplicated_char);\n    induced_sort(pat, sa);\n}\n\npub fn suffix_array_16(pat: &[u8]) -> Vec<usize> {\n    let mut pat = pat.into_iter().map(|x| *x as usize).collect::<Vec<usize>>();\n    pat.push(0);\n    let mut sa = vec![0; max(pat.len(), 256) * 1];\n    _compute_suffix_array_16_1(&mut pat[..], &mut sa[..]);\n\n    sa\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Node in Double Circular Linked List in C++ and Python\nDESCRIPTION: Demonstrates the insertion of a new node into a double circular linked list, handling the case when the list is empty and updating both left and right pointers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid insertNode(int i, Node *p) {\n  Node *node = new Node;\n  node->value = i;\n  if (p == NULL) {\n    p = node;\n    node->left = node;\n    node->right = node;\n  } else {\n    node->left = p;\n    node->right = p->right;\n    p->right->left = node;\n    p->right = node;\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef insertNode(i, p):\n    node = Node()\n    node.value = i\n    if p == None:\n        p = node\n        node.left = node\n        node.right = node\n    else:\n        node.left = p\n        node.right = p.right\n        p.right.left = node\n        p.right = node\n```\n\n----------------------------------------\n\nTITLE: Configuring Compilation and Execution Commands for C++ in Notepad++\nDESCRIPTION: Shell commands for setting up compilation, execution, and debugging of C++ programs in Notepad++. Includes options for using ConsolePauser for improved program execution experience.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/npp.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n#编译命令：\ncmd /c g++.exe -o $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH)\n#运行命令：\ncmd /c $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH) & pause\n#调试命令：\ncmd /c gdb $(CURRENT_DIRECTORY)\\$(NAME_PART).exe\n\n#如果下载了ConsolePauser可以使用下列代码获得更好的程序运行体验！（注意添加环境变量！）\n\n#编译命令：\ncmd /c (start ConsolePauser \"g++.exe -o $(CURRENT_DIRECTORY)\\$(NAME_PART).exe $(FULL_CURRENT_PATH)\")\n#运行命令：\ncmd /c (start ConsolePauser \"$(CURRENT_DIRECTORY)\\$(NAME_PART).exe\")\n#调试命令：\ncmd /c (start ConsolePauser \"gdb $(CURRENT_DIRECTORY)\\$(NAME_PART).exe\")\n```\n\n----------------------------------------\n\nTITLE: Definition of Congruence Equation in Number Theory\nDESCRIPTION: Formal mathematical definition of a congruence equation with modulo m where f(x) is a polynomial with integer coefficients and x is in Z_m.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nf(x)\\equiv 0\\pmod m\\tag{1}\n```\n\n----------------------------------------\n\nTITLE: Building a Dividing Tree in Pascal\nDESCRIPTION: This procedure builds a dividing tree recursively by partitioning elements around median values at each level. It uses a 'toleft' array to track how many elements go to the left child at each level.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/dividing.md#2025-04-22_snippet_0\n\nLANGUAGE: pascal\nCODE:\n```\nprocedure Build(left,right,deep:longint); // left,right 表示区间左右端点,deep是第几层\nvar\n  i,mid,same,ls,rs,flag:longint; // 其中 flag 是用来平衡左右两边的数量的\nbegin\n  if left=right then exit; // 到底层了\n  mid:=(left+right) >> 1;\n  same:=mid-left+1;\n  for i:=left to right do \n    if tree[deep,i]<num[mid] then\n      dec(same);\n\n  ls:=left; // 分配到左儿子的第一个指针\n  rs:=mid+1; // 分配到右儿子的第一个指针\n  for i:=left to right do\n  begin\n    flag:=0;\n    if (tree[deep,i]<num[mid])or((tree[deep,i]=num[mid])and(same>0)) then // 分配到左边的条件\n    begin\n      flag:=1; tree[deep+1,ls]:=tree[deep,i]; inc(ls);\n      if tree[deep,i]=num[mid] then // 平衡左右个数\n        dec(same);\n    end\n    else\n    begin\n      tree[deep+1,rs]:=tree[deep,i]; inc(rs);\n    end;\n    toleft[deep,i]:=toleft[deep,i-1]+flag;\n  end;\n  Build(left,mid,deep+1); // 继续\n  Build(mid+1,right,deep+1);\nend;\n```\n\n----------------------------------------\n\nTITLE: Centroid Decomposition Implementation (Example 3)\nDESCRIPTION: C++ implementation of a centroid decomposition solution for a tree color counting problem. Handles path color queries with path-based contributions and maintains subtree information for efficient counting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-divide.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/graph/code/tree-divide/tree-divide_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Finding Maximum and Minimum Values with Bitwise Operations in Python\nDESCRIPTION: Python functions that find the maximum or minimum of two integers using bitwise operations, which can be more efficient on some machines than using conditional statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\n# 如果 a >= b, (a - b) >> 31 为 0，否则为 -1\ndef max(a, b):\n    return b & ((a - b) >> 31) | a & (~(a - b) >> 31)\ndef min(a, b):\n    return a & ((a - b) >> 31) | b & (~(a - b) >> 31)\n```\n\n----------------------------------------\n\nTITLE: Testing Iterator Invalidation Guarantees for Different Heap Types\nDESCRIPTION: Shows how to determine the invalidation guarantee type of different heap implementations. This is important for understanding when iterators remain valid after modifying the container.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/pq.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n#include <cxxabi.h>\n\ntemplate <typename T>\nvoid print_invalidation_guarantee() {\n  using gute = __gnu_pbds::container_traits<T>::invalidation_guarantee;\n  cout << abi::__cxa_demangle(typeid(gute).name(), 0, 0, 0) << endl;\n}\n\nint main() {\n  using pairing =\n      __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag>;\n  using binary = __gnu_pbds::priority_queue<int, greater<int>, binary_heap_tag>;\n  using binomial =\n      __gnu_pbds::priority_queue<int, greater<int>, binomial_heap_tag>;\n  using rc_binomial =\n      __gnu_pbds::priority_queue<int, greater<int>, rc_binomial_heap_tag>;\n  using thin = __gnu_pbds::priority_queue<int, greater<int>, thin_heap_tag>;\n  print_invalidation_guarantee<pairing>();\n  print_invalidation_guarantee<binary>();\n  print_invalidation_guarantee<binomial>();\n  print_invalidation_guarantee<rc_binomial>();\n  print_invalidation_guarantee<thin>();\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop Undefined Behavior Example in C++\nDESCRIPTION: A comprehensive example showing how compilers can optimize based on the assumption that loops without side effects must terminate. This example tries to validate Fermat's Last Theorem but may be optimized incorrectly by the compiler.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nbool fermat() {\n  const int max_value = 1000;\n\n  // Endless loop with no side effects is UB\n  for (int a = 1, b = 1, c = 1; true;) {\n    if (((a * a * a) == ((b * b * b) + (c * c * c))))\n      return true;  // disproved :()\\n    a++;\n    if (a > max_value) {\n      a = 1;\n      b++;\n    }\n    if (b > max_value) {\n      b = 1;\n      c++;\n    }\n    if (c > max_value) c = 1;\n  }\n\n  return false;  // not disproved\n}\n\nint main() {\n  std::cout << \"Fermat's Last Theorem \";\n  fermat() ? std::cout << \"has been disproved!\\n\"\n           : std::cout << \"has not been disproved.\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing Non-Empty Subsets using For Loop in C++\nDESCRIPTION: A more compact implementation for traversing all non-empty subsets of a binary mask in descending order using a for loop. This is useful for subset enumeration in dynamic programming.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// 降序遍历 m 的非空子集\nfor (int s = m; s; s = (s - 1) & m)\n// s 是 m 的一个非空子集\n```\n\n----------------------------------------\n\nTITLE: Declaring STL Containers in C++\nDESCRIPTION: Demonstrates the general syntax for declaring STL containers. The actual number and type of template parameters may vary depending on the specific container.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\ncontainerName<typeName,...> name\n```\n\n----------------------------------------\n\nTITLE: Debug Macro Usage in C++\nDESCRIPTION: Demonstrates how to use preprocessing macros for debugging purposes. Allows for easy toggling of debug code when submitting to online judges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#define DEBUG\n#ifdef DEBUG\n// do something when DEBUG is defined\n#endif\n// or\n#ifndef DEBUG\n// do something when DEBUG isn't defined\n#endif\n```\n\n----------------------------------------\n\nTITLE: Prime Modulo Congruence Equation\nDESCRIPTION: Congruence equation with modulo p where p is a prime number and f(x) is a polynomial with integer coefficients where p does not divide the leading coefficient.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\nf(x)\\equiv 0\\pmod p\\tag{6}\n```\n\n----------------------------------------\n\nTITLE: Implementing Bit-Reversal Permutation in C++ (O(n))\nDESCRIPTION: This function performs the bit-reversal permutation in O(n) time complexity. It uses a recursive formula to calculate the reversed indices efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fft.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid change(Complex y[], int len) {\n  for (int i = 0; i < len; ++i) {\n    rev[i] = rev[i >> 1] >> 1;\n    if (i & 1) {\n      rev[i] |= len >> 1;\n    }\n  }\n  for (int i = 0; i < len; ++i) {\n    if (i < rev[i]) {\n      swap(y[i], y[rev[i]]);\n    }\n  }\n  return;\n}\n```\n\n----------------------------------------\n\nTITLE: Optimized Interval Partition with O(n(n+m)) Complexity\nDESCRIPTION: Implementation of the second optimization method for interval partition with limited number of intervals. Uses bounded search range for decisions based on quadrangle inequality.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/opt/quadrangle/quadrangle_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Alternative Loop Macro in C++\nDESCRIPTION: Another useful loop macro definition that uses inclusive range (<=) instead of exclusive (<).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#define _rep(i, a, b) for (int i = (a); i <= (b); ++i)\n```\n\n----------------------------------------\n\nTITLE: WQS Binary Search Implementation with O(n log n log C) Complexity\nDESCRIPTION: Implementation using WQS binary search technique (Alien's trick) to solve interval partition with limited segments.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/dp/code/opt/quadrangle/quadrangle_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ISAP (Improved Shortest Augmenting Path) Algorithm for Maximum Flow in C++\nDESCRIPTION: This code implements the ISAP algorithm for solving maximum flow problems. It includes an Edge struct and methods for adding edges, performing BFS, augmenting flow, and calculating the maximum flow. The algorithm incorporates optimizations such as the current arc optimization and GAP optimization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow/max-flow.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nstruct Edge {\n  int from, to, cap, flow;\n\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nbool operator<(const Edge& a, const Edge& b) {\n  return a.from < b.from || (a.from == b.from && a.to < b.to);\n}\n\nstruct ISAP {\n  int n, m, s, t;\n  vector<Edge> edges;\n  vector<int> G[MAXN];\n  bool vis[MAXN];\n  int d[MAXN];\n  int cur[MAXN];\n  int p[MAXN];\n  int num[MAXN];\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  }\n\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(t);\n    vis[t] = true;\n    d[t] = 0;\n    while (!Q.empty()) {\n      int x = Q.front();\n      Q.pop();\n      for (int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i] ^ 1];\n        if (!vis[e.from] && e.cap > e.flow) {\n          vis[e.from] = true;\n          d[e.from] = d[x] + 1;\n          Q.push(e.from);\n        }\n      }\n    }\n    return vis[s];\n  }\n\n  void init(int n) {\n    this->n = n;\n    for (int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  int Augment() {\n    int x = t, a = INF;\n    while (x != s) {\n      Edge& e = edges[p[x]];\n      a = min(a, e.cap - e.flow);\n      x = edges[p[x]].from;\n    }\n    x = t;\n    while (x != s) {\n      edges[p[x]].flow += a;\n      edges[p[x] ^ 1].flow -= a;\n      x = edges[p[x]].from;\n    }\n    return a;\n  }\n\n  int Maxflow(int s, int t) {\n    this->s = s;\n    this->t = t;\n    int flow = 0;\n    BFS();\n    memset(num, 0, sizeof(num));\n    for (int i = 0; i < n; i++) num[d[i]]++;\n    int x = s;\n    memset(cur, 0, sizeof(cur));\n    while (d[s] < n) {\n      if (x == t) {\n        flow += Augment();\n        x = s;\n      }\n      int ok = 0;\n      for (int i = cur[x]; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if (e.cap > e.flow && d[x] == d[e.to] + 1) {\n          ok = 1;\n          p[e.to] = G[x][i];\n          cur[x] = i;\n          x = e.to;\n          break;\n        }\n      }\n      if (!ok) {\n        int m = n - 1;\n        for (int i = 0; i < G[x].size(); i++) {\n          Edge& e = edges[G[x][i]];\n          if (e.cap > e.flow) m = min(m, d[e.to]);\n        }\n        if (--num[d[x]] == 0) break;\n        num[d[x] = m + 1]++;\n        cur[x] = 0;\n        if (x != s) x = edges[p[x]].from;\n      }\n    }\n    return flow;\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Highly Optimized Enumeration with Bucket in Python\nDESCRIPTION: A highly optimized version using a bucket to record visited numbers, reducing time complexity to O(n). This implementation uses a boolean list to track encountered numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\nmet = [False] * (MAXN * 2 + 1)\nfor i in range(n):\n    if met[MAXN - a[i]]:\n        ans += 1\n    met[a[i] + MAXN] = True\n```\n\n----------------------------------------\n\nTITLE: Jordan Canonical Form for Nilpotent Matrices in LaTeX\nDESCRIPTION: Mathematical representation of the Jordan canonical form for nilpotent matrices, showing a block diagonal matrix with nilpotent Jordan blocks N_{r_i} of various sizes along the diagonal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\nN=\\begin{pmatrix}\nN_{r_1} &   &   & 0\\\\\n  & N_{r_2} &   &  \\\\\n  &   & \\cdots &  \\\\\n0 &   &   & N_{r_S}\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Basic Unix Terminal Example\nDESCRIPTION: Demonstrates the basic terminal prompt structure in Unix-like systems and command execution\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/cmd.md#2025-04-22_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nchtholly@seniorious:~$ echo \"Hello World!\"\n```\n\n----------------------------------------\n\nTITLE: Inserting Elements into DLX Matrix in C++\nDESCRIPTION: Handles insertion of elements into the DLX matrix at specified row and column positions. Manages both cases of empty and non-empty rows.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid insert(const int &r, const int &c) {\n  row[++idx] = r, col[idx] = c, ++siz[c];\n  U[idx] = c, D[idx] = D[c], U[D[c]] = idx, D[c] = idx;\n  if (!first[r])\n    first[r] = L[idx] = R[idx] = idx;\n  else {\n    L[idx] = first[r], R[idx] = R[first[r]];\n    L[R[first[r]]] = idx, R[first[r]] = idx;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference - Memory Deallocation Issue in C++\nDESCRIPTION: This snippet shows a dangling reference caused by deallocation of memory while a reference to that memory still exists, resulting in undefined behavior when attempting to access the reference.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nint main() {\n  int* ptr = new int(10);\n  int& ref = *ptr;\n  delete ptr;\n\n  std::cout << ref << std::endl;  // 未定义行为\n}\n```\n\n----------------------------------------\n\nTITLE: Continue Statement in Do-While Loop in C++\nDESCRIPTION: Example showing how the continue statement works in a do-while loop, including the equivalent goto implementation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\ndo {\n  // do something...\n  continue;  // 等价于 goto END;\n// do something...\nEND:;\n} while (statement);\n\n```\n\n----------------------------------------\n\nTITLE: Maximum Clique Detection in C++\nDESCRIPTION: Algorithm to find all maximal cliques in a chordal graph by checking neighborhood sets. Runs in O(n+m) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/chord.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 1; i <= n; i++) {\n  cur = 0;\n  for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)\n    if (rnk[p[i]] < rnk[*it]) {\n      s[++cur] = *it;\n      if (rnk[s[cur]] < rnk[s[1]]) swap(s[1], s[cur]);\n    }\n  fst[p[i]] = s[1];\n  N[p[i]] = cur;\n}\nfor (int i = 1; i <= n; i++) {\n  if (!vis[p[i]]) ans++;\n  if (N[p[i]] >= N[fst[p[i]]] + 1) vis[fst[p[i]]] = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deletion Operation for Treap in C++\nDESCRIPTION: Implements the deletion operation for a Treap. Handles different cases based on the number of child nodes and uses rotations to maintain heap property when necessary.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/treap.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid _del(Node *&cur, int val) {\n  if (val > cur->val) {\n    _del(cur->ch[1], val);\n    // 值更大就在右子树，反之亦然\n    cur->upd_siz();\n  } else if (val < cur->val) {\n    _del(cur->ch[0], val);\n    cur->upd_siz();\n  } else {\n    if (cur->rep_cnt > 1) {\n      // 如果要删除的节点是重复的，可以直接把重复值减小\n      cur->rep_cnt--, cur->siz--;\n      return;\n    }\n    uint8_t state = 0;\n    state |= (cur->ch[0] != nullptr);\n    state |= ((cur->ch[1] != nullptr) << 1);\n    // 00都无，01有左无右，10，无左有右，11都有\n    Node *tmp = cur;\n    switch (state) {\n      case 0:\n        delete cur;\n        cur = nullptr;\n        // 没有任何子节点，就直接把这个节点删了\n        break;\n      case 1:  // 有左无右\n        cur = tmp->ch[0];\n        // 把根变成左儿子，然后把原来的根节删了，注意这里的 tmp 是从 cur\n        // 复制的，而 cur 是引用\n        delete tmp;\n        break;\n      case 2:  // 有右无左\n        cur = tmp->ch[1];\n        delete tmp;\n        break;\n      case 3:\n        rot_type dir = cur->ch[0]->rank < cur->ch[1]->rank\n                           ? RT\n                           : LF;  // dir 是 rank 更小的那个儿子\n        _rotate(cur, dir);  // 这里的旋转可以把优先级更小的儿子转上去，rt 是 0，\n                            // 而 lf 是 1，刚好跟实际的子树下标反过来\n        _del(\n            cur->ch[!dir],\n            val);  // 旋转完成后原来的根节点就在旋方向那边，所以需要\n                   // 继续把这个原来的根节点删掉\n                   // 如果说要删的这个节点是在整个树的「上层的」，那我们会一直通过这\n                   // 这里的旋转操作，把它转到没有子树了（或者只有一个），再删掉它。\n        cur->upd_siz();\n        // 删除会造成大小改变\n        break;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Implementation for Labeled Graph Enumeration Problems\nDESCRIPTION: A full C++ implementation for solving various labeled graph enumeration problems, including connected graphs, Euler graphs, and bipartite graphs. Uses polynomial operations for efficient computation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/combinatorics/graph-enumeration/graph-enumeration_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: General Form of Higher-Degree Congruence Equation\nDESCRIPTION: General form of a higher-degree congruence equation after variable substitution to eliminate the x^(n-1) term.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_5\n\nLANGUAGE: math\nCODE:\n```\nx^n+\\sum_{i=0}^{n-2}a_ix^i\\equiv 0\\pmod p\\tag{10}\n```\n\n----------------------------------------\n\nTITLE: Processing L-type and S-type Suffixes in Suffix Array Algorithm in Rust\nDESCRIPTION: This code handles the core algorithm for processing L-type and S-type suffixes in a suffix array construction. It places L-suffixes in the suffix array, removes LMS-suffixes, and places S-suffixes, managing buckets and character types throughout the process.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sa-optimal-inplace.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet patlen = pat.len();\n\n// place L-suff in SA\n// init\nlet mut last_scanned_type = STYPE;\nfor i in (0..patlen - 1).rev() {\n    if pat_char_type(pat[i], pat[i + 1], last_scanned_type) == LTYPE {\n        sa[pat[i]] += 1;  // >= EMPTY\n        last_scanned_type = LTYPE;\n    } else {\n        last_scanned_type = STYPE;\n    }\n}\n//place\nlet mut i = 0;\nwhile i < patlen {\n    if sa[i] < EMPTY && sa[i] > 0 {\n        let j = sa[i] - 1;\n        let mut is_ltype = false;\n        if pat[j] > pat[j + 1] {\n            is_ltype = true;\n        } else if pat[j] == pat[j + 1] {  // 判断sa[i]是否是L后缀的编号\n            let next_i = sa[pat[sa[i]]];\n            if next_i >= MULTI {\n                is_ltype = true;\n            } else if next_i < EMPTY && pat[sa[i]] + 1 < patlen {\n                if sa[pat[sa[i]] + 1] == EMPTY {\n                    is_ltype = true;\n                } else if sa[pat[sa[i]] + 1] < EMPTY {\n                    if pat[sa[pat[sa[i]] + 1]] == pat[sa[i]] {\n                        is_ltype = true;\n                    }\n                }\n            }\n        }\n\n        if is_ltype {\n            if sa[pat[j]] == UNIQUE {\n                sa[pat[j]] = j;\n            } else if sa[pat[j]] >= MULTI && sa[pat[j] + 1] == EMPTY {\n                if sa[pat[j]] - EMPTY > 2 {\n                    sa[pat[j] + 2] = j;\n                    sa[pat[j] + 1] = 1;  // set counter\n                } else {\n                    sa[pat[j]] = j;\n                }\n            } else if sa[pat[j]] >= MULTI && sa[pat[j] + 1] != EMPTY {\n                let e = pat[j];\n                let c = sa[e + 1];\n                let lfp = e + c + 2;\n                if  c + 2 < sa[pat[j]] - EMPTY {  // 没到bucket尾部\n                    sa[lfp] = j;\n                    sa[e + 1] += 1;  // update counter\n                } else {\n                    for k in 1..c + 1 {\n                        sa[e + k - 1] = sa[e + k + 1];\n                    }\n                    sa[e + c] = j;\n                    sa[e + c + 1] = EMPTY;\n                    if i >= e + 2 && i <= e + c + 1 {\n                        i -= 2;\n                    }\n                }\n            } else if sa[pat[j]] < EMPTY {\n                for k in pat[j]..patlen {\n                    if sa[k] == EMPTY {\n                        sa[k] = j;\n                        break;\n                    }\n                }\n            }\n        }\n    } else if sa[i] >= MULTI {\n        i += 1;\n    }\n\n    i += 1;\n}\n\n// remove LMS-suff form SA, 一个桶里可能有多个LMS后缀\nlast_scanned_type = STYPE;\nfor i in (0..pat.len() - 1).rev() {\n    if pat_char_type(pat[i], pat[i + 1], last_scanned_type) == STYPE {\n        last_scanned_type = STYPE;\n    } else {\n        if last_scanned_type == STYPE {  // pat[i + 1] is LMS type\n            if sa[pat[i + 1]] <= EMPTY {\n                sa[pat[i + 1]] = UNIQUE;\n            } else {\n                sa[pat[i + 1]] += 1;\n            }\n        }\n\n        last_scanned_type = LTYPE;\n    }\n}\ni = patlen - 1;\nwhile i > 0 {\n    if sa[i] > EMPTY {\n        let c = sa[i] - EMPTY;\n        for k in 0..c {\n            sa[i - k] = EMPTY;\n        }\n        i -= c - 1;\n    }\n\n    i -= 1;\n}\nsa[0] = pat.len() - 1;\n\n// place S-suff in SA\n// init\nlet mut last_scanned_type = STYPE;\nfor i in (0..patlen - 1).rev() {\n    if pat_char_type(pat[i], pat[i + 1], last_scanned_type) == STYPE {\n        if sa[pat[i]] >= EMPTY {\n            sa[pat[i]] += 1;\n        } else {\n            sa[pat[i]] = UNIQUE;\n        }\n        last_scanned_type = STYPE;\n    } else {\n        last_scanned_type = LTYPE;\n    }\n}\ni = patlen - 1;\nwhile i > 0 {\n    if sa[i] < EMPTY && sa[i] > 0 {\n        let j = sa[i] - 1;\n        let mut is_stype = false;\n        if pat[j] < pat[j + 1] {\n            is_stype = true;\n        } else if pat[j] == pat[j + 1] {  // 判断sa[i]是否是S后缀的编号\n            let next_i = sa[pat[sa[i]]];\n            if next_i >= MULTI {\n                is_stype = true;\n            } else if next_i < EMPTY && pat[sa[i]] - 1 > 0 {\n                if sa[pat[sa[i]] - 1] == EMPTY {\n                    is_stype = true;\n                } else if sa[pat[sa[i]] - 1] < EMPTY {\n                    if pat[sa[pat[sa[i]] - 1]] == pat[sa[i]] {\n                        is_stype = true;\n                    }\n                }\n            }\n        }\n\n        if is_stype {\n            if sa[pat[j]] == UNIQUE {\n                sa[pat[j]] = j;\n            } else if sa[pat[j]] >= MULTI && sa[pat[j] - 1] == EMPTY {\n                if sa[pat[j]] - EMPTY > 2 {\n                    sa[pat[j] - 2] = j;\n                    sa[pat[j] - 1] = 1;  // set counter\n                } else {\n                    sa[pat[j]] = j;\n                }\n            } else if sa[pat[j]] >= MULTI && sa[pat[j] - 1] != EMPTY {\n                let e = pat[j];\n                let c = sa[e - 1];\n                let num = sa[pat[j]] - EMPTY;\n                if c + 2 < num {  // 没到bucket头部\n                    let rfp = e - c - 2;\n                    sa[rfp] = j;\n                    sa[e - 1] += 1;\n                } else {\n                    for k in 1..c + 1 {\n                        sa[e - k + 1] = sa[e - k - 1];\n                    }\n                    sa[e - c] = j;\n                    sa[e - c - 1] = EMPTY;\n                    if i >= e - num + 1 && i <= e - 2 {\n                        i += 2;\n                    }\n                }\n            } else if sa[pat[j]] < EMPTY {\n                for k in (0..pat[j]).rev() {\n                    if sa[k] == EMPTY {\n                        sa[k] = j;\n                        break;\n                    }\n                }\n            }\n        }\n    } else if sa[i] >= MULTI {\n        i -= 1;\n    }\n    i -= 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting Manhattan Distance to Chebyshev Distance in Python\nDESCRIPTION: This Python code converts the problem of finding maximum Manhattan distance to finding maximum Chebyshev distance by transforming coordinates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/distance.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nminx = 0x7FFFFFFF\nmaxx = 0\nminy = 0x7FFFFFFF\nmaxy = 0\nn = int(input())\nfor i in range(1, n + 1):\n    a, b = map(lambda x: int(x), input().split())\n    x = a + b\n    y = a - b\n    minx = min(minx, x)\n    maxx = max(maxx, x)\n    miny = min(miny, y)\n    maxy = max(maxy, y)\nprint(max(maxx - minx, maxy - miny))\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference - Memory Reallocation Issue in C++\nDESCRIPTION: This example demonstrates how memory reallocation in containers like std::string can lead to dangling references, causing undefined behavior when accessing the reference after the original memory has been reallocated.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nint main() {\n  std::string str = \"hello\";\n\n  const char& ref = str.front();\n\n  str.append(\"world\");  // 可能会重新分配内存，导致 ref 指向的内存被释放\n\n  std::cout << ref << std::endl;  // 未定义行为\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Formula for Second Stirling Numbers in LaTeX\nDESCRIPTION: This LaTeX equation represents the recursive formula for Second Stirling Numbers. It shows how to calculate S(n,k) using S(n-1,k-1) and S(n-1,k).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{Bmatrix}n\\\\ k\\end{Bmatrix}=\\begin{Bmatrix}n-1\\\\ k-1\\end{Bmatrix}+k\\begin{Bmatrix}n-1\\\\ k\\end{Bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Implementing Reverse Connected Graph Counting in C++\nDESCRIPTION: This function implements the 'exp' transformation for graph counting, which is the inverse of 'ln'. It transforms connected graph counts C[] into general graph counts G[] using a recursive formula.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid exp(Int G[], Int C[]) {\n  for (int i = 1; i <= n; ++i) {\n    G[i] = C[i];\n    for (int j = 1; j <= i - 1; ++j)\n      G[i] += binom[i - 1][j - 1] * C[j] * G[i - j];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: 骨牌覆盖问题完整实现 (C++)\nDESCRIPTION: 用轮廓线DP解决经典的骨牌覆盖问题。该代码计算在N×M棋盘内铺满1×2或2×1多米诺骨牌的方案数。包含状态编码和转移的完整实现。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <iostream>\nusing namespace std;\nconstexpr int N = 11;\nlong long f[2][1 << N], *f0, *f1;\nint n, m;\n\nint main() {\n  while (cin >> n >> m && n) {\n    f0 = f[0];\n    f1 = f[1];\n    fill(f1, f1 + (1 << m), 0);\n    f1[0] = 1;\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < m; ++j) {\n        swap(f0, f1);\n        fill(f1, f1 + (1 << m), 0);\n#define u f0[s]\n        for (int s = 0; s < 1 << m; ++s)\n          if (u) {\n            if (j != m - 1 && (!(s >> j & 3))) f1[s ^ 1 << j + 1] += u;  // 横放\n            f1[s ^ 1 << j] += u;  // 竖放或不放\n          }\n      }\n    }\n    cout << f1[0] << endl;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Mixed I/O Streams Error in C++\nDESCRIPTION: This example demonstrates the problems that can occur when mixing C-style I/O (printf/scanf) with C++ streams (cout/cin) after disabling synchronization. This leads to output appearing in an unexpected order due to separate buffering.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n// 这个例子将说明关闭与 stdio 的同步后，混用两种 IO 方式的后果\n// 建议单步运行来观察效果\n#include <cstdio>\n#include <iostream>\n\nint main() {\n  // 关闭同步后，cin/cout 将使用独立缓冲区，而不是将输出同步至 scanf/printf\n  // 的缓冲区，从而减少 IO 耗时\n  std::ios::sync_with_stdio(false);\n  // cout 下，使用'\\n'换行时，内容会被缓冲而不会被立刻输出\n  std::cout << \"a\\n\";\n  // printf 的 '\\n' 会刷新 printf 的缓冲区，导致输出错位\n  printf(\"b\\n\");\n  std::cout << \"c\\n\";\n  // 程序结束时，cout 的缓冲区才会被输出\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: String Formatting in C\nDESCRIPTION: Using sscanf and sprintf for string formatting and parsing in C.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/lib-func.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\nsscanf(const char *__source, const char *__format, ...);\nsprintf(char *__stream, const char *__format, ...);\n```\n\n----------------------------------------\n\nTITLE: Using __restrict for Better Auto-Vectorization in C++\nDESCRIPTION: Demonstrates how to use the __restrict keyword to inform the compiler that pointers will never overlap in memory, allowing for better vectorization. This non-standard keyword is supported by most major compilers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid test(int* __restrict a, int* __restrict b, int n) {\n  for (int i = 0; i < n; i++) {\n    a[i] += b[i];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic DFS Template in C++\nDESCRIPTION: A basic template for implementing depth-first search with a generic structure for tracking current and best solutions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/opt.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint ans = 最坏情况, now;  // now 为当前答案\n\nvoid dfs(传入数值) {\n  if (到达目的地) ans = 从当前解与已有解中选最优;\n  for (遍历所有可能性)\n    if (可行) {\n      进行操作;\n      dfs(缩小规模);\n      撤回操作;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: 数组模拟队列的基本操作 (C++)\nDESCRIPTION: 展示了如何使用数组模拟队列的基本操作，包括插入元素、删除元素、访问队首和队尾、清空队列等。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/queue.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint q[SIZE], ql = 1, qr;\n\n// 插入元素\nq[++qr] = x;\n// 删除元素\nql++;\n// 访问队首\nq[ql]\n// 访问队尾\nq[qr]\n// 清空队列\nql = 1; qr = 0;\n```\n\n----------------------------------------\n\nTITLE: Utilizing BigInteger Comparison and Bit Manipulation Methods in Java\nDESCRIPTION: This code snippet demonstrates the use of comparison methods and bit manipulation operations with BigInteger in Java, including max, min, bitCount, bitLength, getLowestSetBit, and compareTo.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_6\n\nLANGUAGE: Java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static BigInteger a, b;\n\n    static void max() {\n        out.println(\"max:\");\n        a = new BigInteger(\"6\");\n        b = new BigInteger(\"5\");\n        out.println(a.max(b));  // 输出 6 \n    }\n\n    static void min() {\n        out.println(\"min:\");\n        a = new BigInteger(\"6\");\n        b = new BigInteger(\"5\");\n        out.println(a.min(b));  // 输出 5 \n    }\n\n    static void bitCount() {\n        out.println(\"bitCount:\");\n        a = new BigInteger(\"6\");  // 110 \n        out.println(a.bitCount());  // 输出 2 \n    }\n\n    static void bitLength() {\n        out.println(\"bitLength:\");\n        a = new BigInteger(\"6\");  // 110 \n        out.println(a.bitLength());  // 输出 3 \n    }\n\n    static void getLowestSetBit() {\n        out.println(\"getLowestSetBit:\");\n        a = new BigInteger(\"8\");  // 1000 \n        out.println(a.getLowestSetBit());  // 输出 3 \n    }\n\n    static void compareTo() {\n        out.println(\"compareTo:\");\n        a = new BigInteger(\"8\");\n        b = new BigInteger(\"9\");\n        out.println(a.compareTo(b));  // 输出 -1 \n        a = new BigInteger(\"8\");\n        b = new BigInteger(\"8\");\n        out.println(a.compareTo(b));  // 输出 0 \n        a = new BigInteger(\"8\");\n        b = new BigInteger(\"7\");\n        out.println(a.compareTo(b));  // 输出 1 \n    }\n\n    static void toStringTest() {\n        out.println(\"toString:\");\n        a = new BigInteger(\"15\");\n        out.println(a.toString());  // 输出 15 \n        out.println(a.toString(16));  // 输出 f \n    }\n\n    public static void main(String[] args) {\n        max();\n        min();\n        bitCount();\n        bitLength();\n        getLowestSetBit();\n        compareTo();\n        toStringTest();\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proving Complete Residue System Composition Theorem\nDESCRIPTION: Mathematical proof that demonstrates how complete residue systems can be composed from smaller moduli systems using specific formulas involving sum products.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/basic.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n只需证明对任意满足 $ax+m_1y\\equiv ax'+m_1y'\\pmod{m_1m_2}$ 的 $x,x'\\in Z_{m_1}$，$y,y'\\in Z_{m_2}$，都有：\n\n$$\nax+m_1y=ax'+m_1y'.\n$$\n\n实际上，由 $m_1\\mid m_1m_2$，我们有 $ax+m_1y\\equiv ax'+m_1y'\\pmod{m_1}$，进而 $ax\\equiv ax'\\pmod{m_1}$，由 $(a,m_1)=1$ 可知 $x\\equiv x'\\pmod{m_1}$，进而有 $x=x'$。\n\n进一步，$m_1y\\equiv m_1y'\\pmod{m_1m_2}$，则 $y\\equiv y'\\pmod{m_2}$，即 $y=y'$。\n\n因此，\n\n$$\nax+m_1y=ax'+m_1y'.\n$$\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Möbius Function in Python\nDESCRIPTION: Python implementation of a linear sieve algorithm to calculate the Möbius function for numbers up to n. It also generates a list of prime numbers and marks composite numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\npri = []\nnot_prime = [False] * N\nmu = [0] * N\n\n\ndef pre(n):\n    mu[1] = 1\n    for i in range(2, n + 1):\n        if not not_prime[i]:\n            pri.append(i)\n            mu[i] = -1\n        for pri_j in pri:\n            if i * pri_j > n:\n                break\n            not_prime[i * pri_j] = True\n            if i % pri_j == 0:\n                mu[i * pri_j] = 0\n                break\n            mu[i * pri_j] = -mu[i]\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Brute-Force Minimum String Representation in C++\nDESCRIPTION: This snippet demonstrates a simple brute-force approach to find the minimum string representation in C++. It compares cyclic permutations of the string, updating pointers based on character comparisons.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/minimal-string.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint k = 0, i = 0, j = 1;\nwhile (k < n && i < n && j < n) {\n  if (sec[(i + k) % n] == sec[(j + k) % n]) {\n    ++k;\n  } else {\n    if (sec[(i + k) % n] > sec[(j + k) % n])\n      ++i;\n    else\n      ++j;\n    k = 0;\n    if (i == j) i++;\n  }\n}\ni = min(i, j);\n```\n\n----------------------------------------\n\nTITLE: Implementing Connected Graph Counting with Recursive Formula in C++\nDESCRIPTION: This function implements the 'connected' transformation for graph counting sequences. Given an array of values for general graphs G[], it calculates the corresponding sequence C[] for connected graphs using a recursive formula.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid ln(Int C[], Int G[]) {\n  for (int i = 1; i <= n; ++i) {\n    C[i] = G[i];\n    for (int j = 1; j <= i - 1; ++j)\n      C[i] -= binom[i - 1][j - 1] * C[j] * G[i - j];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Li Chao Trees\nDESCRIPTION: These functions implement the merging of two Li Chao trees. The upd function is modified to handle dynamic allocation, and the merge function recursively combines two trees into one.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/li-chao-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid upd(int &root, int cl, int cr,\n         int u) {  // 涉及多棵李超线段树合并，使用动态开点。\n  static int idx = 0;\n  if (!root) {\n    s[root = ++idx] = u;\n    return;\n  }\n  int &v = s[root], mid = (cl + cr) >> 1;\n  int bmid = cmp(calc(u, mid), calc(v, mid));\n  if (bmid == 1 || (!bmid && u < v)) swap(u, v);\n  int bl = cmp(calc(u, cl), calc(v, cl)), br = cmp(calc(u, cr), calc(v, cr));\n  if (bl == 1 || (!bl && u < v)) upd(ls[root], cl, mid, u);\n  if (br == 1 || (!br && u < v)) upd(rs[root], mid + 1, cr, u);\n}\n\nint merge(int &u, int &v, int l, int r) {\n  if (!u || !v) {\n    return u + v;\n  }\n  if (l == r) {\n    int b = cmp(calc(s[v], l), calc(s[u], l));\n    if (b == 1 || (!b && s[v] < s[u])) return v;\n    return u;\n  }\n  upd(u, l, r, s[v]);\n  int mid = (l + r) >> 1;\n  ls[u] = merge(ls[u], ls[v], l, mid);\n  rs[u] = merge(rs[u], rs[v], mid + 1, r);\n  return u;\n}\n```\n\n----------------------------------------\n\nTITLE: Permutation Enumeration Using Do-While Loop in C++\nDESCRIPTION: Example of using a do-while loop with std::next_permutation to enumerate through all permutations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\ndo {\n  // do someting...\n} while (next_permutation(a + 1, a + n + 1));\n```\n\n----------------------------------------\n\nTITLE: Implementing DFS-based Topological Sorting in Python\nDESCRIPTION: This Python implementation of topological sorting uses a depth-first search approach. It uses an enum to track node status and returns the topological order or None if a cycle is detected.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/topo.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum, auto\n\n\nclass Status(Enum):\n    to_visit = auto()\n    visiting = auto()\n    visited = auto()\n\n\ndef topo_sort(graph: list[list[int]]) -> list[int] | None:\n    n = len(graph)\n    status = [Status.to_visit] * n\n    order = []\n\n    def dfs(u: int) -> bool:\n        status[u] = Status.visiting\n        for v in graph[u]:\n            if status[v] == Status.visiting:\n                return False\n            if status[v] == Status.to_visit and not dfs(v):\n                return False\n        status[u] = Status.visited\n        order.append(u)\n        return True\n\n    for i in range(n):\n        if status[i] == Status.to_visit and not dfs(i):\n            return None\n\n    return order[::-1]\n```\n\n----------------------------------------\n\nTITLE: Maintaining Node Size in Link-Cut Tree (C++)\nDESCRIPTION: This function updates the size of a node in the Link-Cut Tree, considering both real and virtual children. It's crucial for maintaining accurate subtree information.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/lct.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid maintain(int x) {\n  clear(0);\n  if (x) siz[x] = siz[ch[x][0]] + 1 + siz[ch[x][1]] + siz2[x];\n}\n```\n\n----------------------------------------\n\nTITLE: Divergence Operator LaTeX Definition\nDESCRIPTION: LaTeX code for expressing the divergence operator (div) with proper mathematical formatting\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{\\mathbf{div}}\n```\n\n----------------------------------------\n\nTITLE: Hello World Program in C\nDESCRIPTION: Basic C program that outputs 'Hello, world!' to the console. Uses the stdio.h library and printf function for output operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/helloworld.md#2025-04-22_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#include <stdio.h>  // 引用头文件\n\nint main() {                // 定义 main 函数\n  printf(\"Hello, world!\");  // 输出 Hello, world!\n  return 0;                 // 返回 0，结束 main 函数\n}\n```\n\n----------------------------------------\n\nTITLE: Getting C++ String Length\nDESCRIPTION: Shows multiple ways to obtain the length of a std::string, including size(), length(), and strlen() with c_str().\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nprintf(\"s 的长度为 %zu\", s.size());\nprintf(\"s 的长度为 %zu\", s.length());\nprintf(\"s 的长度为 %zu\", strlen(s.c_str()));\n```\n\n----------------------------------------\n\nTITLE: Implementing Segment Tree with Treap Solution in C++\nDESCRIPTION: Alternative solution using Segment Tree combined with Treap data structure for efficient range queries. This implementation provides a different approach with different performance characteristics.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bit-in-block-array.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <cstdio>\n#include <random>\n#include <vector>\nusing namespace std;\nconstexpr int N = 1e5 + 5;\n\nvector<int> g[N];\nint n, a[N];\n\nmt19937 rng(random_device{}());\n\nstruct Treap {\n  struct node {\n    node *l, *r;\n    unsigned rnd;\n    int sz, v;\n\n    node(int _v) : l(NULL), r(NULL), rnd(rng()), sz(1), v(_v) {}\n  };\n\n  int get_size(node*& p) { return p ? p->sz : 0; }\n\n  void push_up(node*& p) {\n    if (!p) return;\n    p->sz = get_size(p->l) + get_size(p->r) + 1;\n  }\n\n  node* root;\n\n  node* merge(node* a, node* b) {\n    if (!a) return b;\n    if (!b) return a;\n    if (a->rnd < b->rnd) {\n      a->r = merge(a->r, b);\n      push_up(a);\n      return a;\n    } else {\n      b->l = merge(a, b->l);\n      push_up(b);\n      return b;\n    }\n  }\n\n  void split_val(node* p, const int& k, node*& a, node*& b) {\n    if (!p)\n      a = b = NULL;\n    else {\n      if (p->v <= k) {\n        a = p;\n        split_val(p->r, k, a->r, b);\n        push_up(a);\n      } else {\n        b = p;\n        split_val(p->l, k, a, b->l);\n        push_up(b);\n      }\n    }\n  }\n\n  void split_size(node* p, int k, node*& a, node*& b) {\n    if (!p)\n      a = b = NULL;\n    else {\n      if (get_size(p->l) <= k) {\n        a = p;\n        split_size(p->r, k - get_size(p->l), a->r, b);\n        push_up(a);\n      } else {\n        b = p;\n        split_size(p->l, k, a, b->l);\n        push_up(b);\n      }\n    }\n  }\n\n  void insert(int val) {\n    node *a, *b;\n    split_val(root, val, a, b);\n    a = merge(a, new node(val));\n    root = merge(a, b);\n  }\n\n  int query(int val) {\n    node *a, *b;\n    split_val(root, val, a, b);\n    int res = get_size(a);\n    root = merge(a, b);\n    return res;\n  }\n\n  int qry(int l, int r) { return query(r) - query(l - 1); }\n};\n\n// Segment Tree\nTreap T[N << 2];\n\nvoid insert(int x, int l, int r, int p, int val) {\n  T[x].insert(val);\n  if (l == r) return;\n  int mid = (l + r) >> 1;\n  if (p <= mid)\n    insert(x << 1, l, mid, p, val);\n  else\n    insert(x << 1 | 1, mid + 1, r, p, val);\n}\n\nint query(int x, int l, int r, int L, int R, int val) {\n  if (l == L && r == R) return T[x].query(val);\n  int mid = (l + r) >> 1;\n  if (R <= mid) return query(x << 1, l, mid, L, R, val);\n  if (L > mid) return query(x << 1 | 1, mid + 1, r, L, R, val);\n  return query(x << 1, l, mid, L, mid, val) +\n         query(x << 1 | 1, mid + 1, r, mid + 1, R, val);\n}\n\nint query(int l, int r, int val) {\n  if (l > r) return -1;\n  return query(1, 1, n, l, r, val);\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 1; i <= n; ++i) g[a[i]].push_back(i);\n\n  // a_0 和 a_{n+1}为哨兵节点\n  int ans = n + 2, lst, ok;\n  for (int i = 1; i <= n + 1; ++i) {\n    g[i].push_back(n + 1);\n\n    lst = 0;\n    ok = 0;\n    for (int pos : g[i]) {\n      if (query(lst + 1, pos - 1, lst) == i - 1) {\n        ok = 1;\n        break;\n      }\n      lst = pos;\n    }\n\n    if (!ok) {\n      ans = i;\n      break;\n    }\n\n    lst = 0;\n    g[i].pop_back();\n    for (int pos : g[i]) {\n      insert(1, 1, n, pos, lst);\n      lst = pos;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Maximum Independent Set in C++\nDESCRIPTION: Implementation to find maximum independent set in a chordal graph using greedy selection based on perfect elimination ordering.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/chord.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 1; i <= n; i++)\n  if (!vis[p[i]]) {\n    ans++;\n    for (vector<int>::iterator it = G[p[i]].begin(); it != G[p[i]].end(); it++)\n      vis[*it] = true;\n  }\n```\n\n----------------------------------------\n\nTITLE: Handling Case 4 in Red-Black Tree Insertion\nDESCRIPTION: Handles the case where both parent and uncle nodes are red during insertion. Recolors parent, uncle, and grandparent nodes, then recursively maintains the grandparent.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n// clang-format off\n// Case 4: Both parent and uncle are RED\n//   Paint parent and uncle to BLACK;\n//   Paint grandparent to RED.\n//        [G]             <G>\n//        / \\             / \\\n//      <P> <U>  ====>  [P] [U]\n//      /               /\n//    <N>             <N>\n// clang-format on\nassert(node->parent->isRed());\nnode->parent->color = Node::BLACK;\nnode->uncle()->color = Node::BLACK;\nnode->grandParent()->color = Node::RED;\nmaintainAfterInsert(node->grandParent());\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Definition of Left and Right Cosets\nDESCRIPTION: Mathematical definition of left and right cosets for a subgroup H of group G\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\ngH &= \\{gh:h\\in H\\},\\\\\nHg &= \\{hg:h\\in H\\}.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Calculating Integer Square Root using Newton's Method in Python\nDESCRIPTION: This function implements a modified Newton's method to calculate the integer square root in Python. It finds the largest integer x such that x^2 <= n, with optimizations for handling edge cases.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/numerical/newton.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef isqrt_newton(n):\n    x = 1\n    decreased = False\n    while True:\n        nx = (x + n // x) // 2\n        if x == nx or (nx > x and decreased):\n            break\n        decreased = nx < x\n        x = nx\n    return x\n```\n\n----------------------------------------\n\nTITLE: Recursive Lambda Using std::function in C++\nDESCRIPTION: This solution uses std::function to explicitly specify the lambda type, allowing for recursion. However, this approach incurs performance overhead due to type erasure and indirect calls.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nint n = 10;\n\nstd::function<void(int)> dfs = [&](int i) -> void {\n  if (i == n)\n    return;\n  else\n    dfs(i + 1);  // OK\n};\n\ndfs(1);\n```\n\n----------------------------------------\n\nTITLE: Queue Operations Demo in Java\nDESCRIPTION: Examples of Queue operations using LinkedList and PriorityQueue implementations with time complexity analysis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_10\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static Queue<Integer> q1 = new LinkedList<>();\n    static Queue<Integer> q2 = new PriorityQueue<>();\n\n    static void add() {  // add 和 offer 功能上没有差距，区别是是否会抛出异常 \n        q1.add(1);  // 时间复杂度为 O(1) \n        q2.add(1);  // 时间复杂度为 O(logn) \n    }\n\n    static void isEmpty() {\n        q1.isEmpty();  // 时间复杂度为 O(1) \n        q2.isEmpty();  // 空间复杂度为 O(1) \n    }\n\n    static void size() {\n        q1.size();  // 时间复杂度为 O(1) \n        q2.size();  // 返回 q2 的长度 \n    }\n\n    static void peek() {\n        q1.peek();  // 时间复杂度为 O(1) \n        q2.peek();  // 时间复杂度为 O(logn) \n    }\n\n    static void poll() {\n        q1.poll();  // 时间复杂度为 O(1) \n        q2.poll();  // 时间复杂度为 O(logn) \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Geany for Deepin Terminal\nDESCRIPTION: This code snippet shows how to configure Geany to use the Deepin terminal as its virtual terminal. It modifies the terminal command in Geany's preferences to launch Deepin terminal with the appropriate shell execution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/geany.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndeepin-terminal -x \"/bin/sh\" %c\n```\n\n----------------------------------------\n\nTITLE: Counting Overlapping Triangle Pairs in a Graph (C++)\nDESCRIPTION: This code counts the number of pairs of triangles that share an edge in a graph. It first counts triangles using the edge orientation method, then enumerates shared edges to calculate the final count.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/rings-count.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 5, M = 2e5 + 5;\nint n, m;\nll ans;\nint h[N], e[M], ne[M], idx;\nint d[N], cnt[M];\nvoid add(int a, int b) {\n  e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  memset(h, -1, sizeof h);\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    d[u]++, d[v]++;\n  }\n  for (int i = 1; i <= m; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    if (d[u] < d[v] || (d[u] == d[v] && u < v))\n      add(u, v);\n    else\n      add(v, u);\n  }\n  for (int u = 1; u <= n; u++)\n    for (int i = h[u]; ~i; i = ne[i]) {\n      int v = e[i];\n      for (int j = h[v]; ~j; j = ne[j]) {\n        int w = e[j];\n        for (int k = h[u]; ~k; k = ne[k])\n          if (e[k] == w) cnt[i]++, cnt[j]++, cnt[k]++;\n      }\n    }\n  for (int i = 0; i < idx; i++) ans += 1ll * cnt[i] * (cnt[i] - 1) / 2;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Naive DFS for Herb Collection Problem in C++\nDESCRIPTION: A basic depth-first search implementation for the NOIP2005 herb collection problem without memoization. This approach has exponential time complexity due to repeated state evaluations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/memo.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint n, t;\nint tcost[103], mget[103];\nint ans = 0;\n\nvoid dfs(int pos, int tleft, int tans) {\n  if (tleft < 0) return;\n  if (pos == n + 1) {\n    ans = max(ans, tans);\n    return;\n  }\n  dfs(pos + 1, tleft, tans);\n  dfs(pos + 1, tleft - tcost[pos], tans + mget[pos]);\n}\n\nint main() {\n  cin >> t >> n;\n  for (int i = 1; i <= n; i++) cin >> tcost[i] >> mget[i];\n  dfs(1, t, 0);\n  cout << ans << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting C++ String to C-style String\nDESCRIPTION: Demonstrates different methods to convert a std::string to a C-style char array, highlighting the importance of using c_str() for safe conversion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nprintf(\"%s\", s);          // 编译错误\nprintf(\"%s\", s.data());   // 编译通过，但是是 undefined behavior\nprintf(\"%s\", s.c_str());  // 一定能够正确输出\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation of Dynamic Programming Recurrence in Tropical Semiring\nDESCRIPTION: Expresses the dynamic programming recurrence as a matrix multiplication in the tropical semiring, where max is the addition operation and + is the multiplication operation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/basic.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\left(\\begin{matrix}f_{i,1}\\\\f_{i,0}\\end{matrix}\\right)\n=\\left(\\begin{matrix}-\\infty&w_i\\\\0&0\\end{matrix}\\right)\\left(\\begin{matrix}f_{i-1,1}\\\\f_{i-1,0}\\end{matrix}\\right).\n```\n\n----------------------------------------\n\nTITLE: Calculating Eulerian Numbers Using Recursion in Python\nDESCRIPTION: A recursive implementation for computing Eulerian numbers in Python. The function handles base cases where m ≥ n or n = 0 (returning 0), and m = 0 (returning 1), then applies the recursive formula for other cases.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/eulerian.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef eulerianNumber(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return ((n - m) * eulerianNumber(n - 1, m - 1)) + (\n        (m + 1) * eulerianNumber(n - 1, m)\n    )\n```\n\n----------------------------------------\n\nTITLE: Implementation of Pólya Enumeration for Unlabeled Graph Counting\nDESCRIPTION: A C++ implementation using Pólya enumeration theorem to count m-colorings of edges in a complete graph with n vertices. Uses partition enumeration and cycle counting to handle symmetries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/combinatorics/graph-enumeration/graph-enumeration_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Using Collections Methods in Java\nDESCRIPTION: Examples of using Collections.binarySearch() for searching within collections and Collections.swap() for swapping elements in a list.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_27\n\nLANGUAGE: java\nCODE:\n```\nCollections.binarySearch(list, key);\n```\n\nLANGUAGE: java\nCODE:\n```\n Collections.swap(list, i, j);\n```\n\n----------------------------------------\n\nTITLE: Using Auto Type Specifier in C++\nDESCRIPTION: Demonstrates automatic type deduction with the auto keyword. Variables are automatically assigned the correct type based on their initializer expressions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nauto a = 1;        // a is int type\nauto b = a + 0.1;  // b is double type\n```\n\n----------------------------------------\n\nTITLE: Calculating Burnside's Lemma for Necklace Coloring with Constraints\nDESCRIPTION: A mathematical calculation using Burnside's Lemma to count the number of essentially different ways to color a four-bead necklace with exactly two red and two blue beads, considering rotational symmetry.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\frac{6+0+2+0}{4}=2.\n```\n\n----------------------------------------\n\nTITLE: Member Testing in Permutation Groups\nDESCRIPTION: Algorithm to test if a permutation h belongs to a group G given its stabilizer chain C. Returns true if h is a member, false otherwise.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_0\n\nLANGUAGE: pseudocode\nCODE:\n```\nAlgorithm MembershipTest(C,h):\nInput. A stabilizer chain C for a group G and a permutation h.\nOutput. Whether h∈G.\nMethod.\n1  while C is not empty\n2    β ← C.orbit[0]\n3    δ ← β^h\n4    if δ∈C.orbit then\n5      t ← C.transversal[δ]\n6      h ← ht^{-1}\n7    else\n8      return false\n9    end if\n10   C ← C.next\n11 end while\n12 return h=e\n```\n\n----------------------------------------\n\nTITLE: Grid Treasure Collection Implementation in C++\nDESCRIPTION: Solution for TJOI2015 problem using dynamic programming to find minimum paths needed to collect all treasures in a grid, applying Dilworth's theorem on DAGs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/order-theory.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/order-theory/order-theory_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Finding Predecessor - C++\nDESCRIPTION: Implementation for finding the predecessor of a value in a given range. Returns the maximum predecessor value found across all relevant segment tree nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/balanced-in-seg.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nint vec_front(int k, int l, int r, int x, int y, int t) {\n  if (x <= l && r <= y) return spy[k].chk_front(t);\n  int mid = l + r >> 1;\n  int res = 0;\n  if (x <= mid) res = max(res, vec_front(k << 1, l, mid, x, y, t));\n  if (y > mid) res = max(res, vec_front(k << 1 | 1, mid + 1, r, x, y, t));\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Brute-Force Minimum String Representation in Python\nDESCRIPTION: This snippet shows a Python implementation of the simple brute-force approach for finding the minimum string representation. It uses similar logic to the C++ version, comparing cyclic permutations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/minimal-string.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nk, i, j = 0, 0, 1\nwhile k < n and i < n and j < n:\n    if sec[(i + k) % n] == sec[(j + k) % n]:\n        k += 1\n    else:\n        if sec[(i + k) % n] > sec[(j + k) % n]:\n            i += 1\n        else:\n            j += 1\n        k = 0\n        if i == j:\n            i += 1\ni = min(i, j)\n```\n\n----------------------------------------\n\nTITLE: Using #define Macros in C++\nDESCRIPTION: Demonstrates the use of #define preprocessor directive for defining constants and macro functions. Includes examples of potential issues with macro expansion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/basic.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#define n 233\n\nint main() {\n  std::cout << n;  // 输出 233\n  return 0;\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#define sum(x, y) ((x) + (y))\n#define square(x) ((x) * (x))\n\nint main() {\n  std::cout << sum(1, 2) << ' ' << 2 * sum(3, 5) << std::endl;  // 输出 3 16\n}\n```\n\n----------------------------------------\n\nTITLE: Deleting a Leaf Node in Red-Black Tree (C++)\nDESCRIPTION: Handles deletion of a leaf node in a red-black tree. If the node is black, it performs maintenance before unlinking. If red, it simply unlinks the node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nif (node->isBlack()) {\n  maintainAfterRemove(node);\n}\nif (node->direction() == Direction::LEFT) {\n  node->parent->left = nullptr;\n} else /* node->direction() == Direction::RIGHT */ {\n  node->parent->right = nullptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Building Centroid Tree in C++\nDESCRIPTION: This code snippet demonstrates how to build a centroid tree for dynamic tree divide. It calculates subtree sizes, finds centroids, and constructs the centroid tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dynamic-tree-divide.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid calcsiz(int x, int f) {\n  siz[x] = 1;\n  maxx[x] = 0;\n  for (int j = h[x]; j; j = nxt[j])\n    if (p[j] != f && !vis[p[j]]) {\n      calcsiz(p[j], x);\n      siz[x] += siz[p[j]];\n      maxx[x] = max(maxx[x], siz[p[j]]);\n    }\n  maxx[x] =\n      max(maxx[x], sum - siz[x]);  // maxx[x] 表示以 x 为根时的最大子树大小\n  if (maxx[x] < maxx[rt])\n    rt = x;  // 这里不能写 <= ，保证在第二次 calcsiz 时 rt 不改变\n}\n\nvoid pre(int x) {\n  vis[x] = true;  // 表示在之后的过程中不考虑 x 这个点\n  for (int j = h[x]; j; j = nxt[j])\n    if (!vis[p[j]]) {\n      sum = siz[p[j]];\n      rt = 0;\n      maxx[rt] = inf;\n      calcsiz(p[j], -1);\n      calcsiz(rt, -1);  // 计算两次，第二次求出以 rt 为根时的各子树大小\n      fa[rt] = x;\n      pre(rt);  // 记录点分树上的父亲\n    }\n}\n\nint main() {\n  sum = n;\n  rt = 0;\n  maxx[rt] = inf;\n  calcsiz(1, -1);\n  calcsiz(rt, -1);\n  pre(rt);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing C++ Compiler on macOS\nDESCRIPTION: Command to install Xcode command-line tools which includes the C++ compiler on macOS systems.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/helloworld.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nxcode-select --install\n```\n\n----------------------------------------\n\nTITLE: Checking if a Number is a Power of Two in Python\nDESCRIPTION: Python function that verifies if a number is a power of 2 using bitwise operations. It leverages the property that a power of 2 has only one bit set to 1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef isPowerOfTwo(n):\n    return n > 0 and (n & (n - 1)) == 0\n```\n\n----------------------------------------\n\nTITLE: Converting Decimal to Balanced Ternary (Mathematical Notation)\nDESCRIPTION: Demonstrates the process of converting decimal numbers 64 and 237 to balanced ternary representation using mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/balanced-ternary.md#2025-04-22_snippet_0\n\nLANGUAGE: mathematical notation\nCODE:\n```\n\\text 64_{10} = 02101_3\n\n\\texttt {1Z101}=81 \\times 1 +27 \\times (-1) + 9 \\times 1 + 3 \\times 0 + 1 \\times 1 = 64_{10}\n\n\\text 237_{10} = 22210_3\n\n\\texttt{100Z10} = 243 \\cdot 1 + 81 \\cdot 0 + 27 \\cdot 0 + 9 \\cdot (-1) + 3 \\cdot 1 + 1 \\cdot 0 = 237_{10}\n```\n\n----------------------------------------\n\nTITLE: Implementing Minkowski Sum of Convex Hulls in C++\nDESCRIPTION: This snippet implements the Minkowski sum of two convex hulls. It merges the edges of both hulls sorted by polar angle to create the new convex hull.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/convex-hull.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <class T>\nstruct Point {\n  T x, y;\n\n  Point(T x = 0, T y = 0) : x(x), y(y) {}\n\n  friend Point operator+(const Point &a, const Point &b) {\n    return {a.x + b.x, a.y + b.y};\n  }\n\n  friend Point operator-(const Point &a, const Point &b) {\n    return {a.x - b.x, a.y - b.y};\n  }\n\n  // Dot product\n  friend T operator*(const Point &a, const Point &b) {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  // Cross product\n  friend T operator^(const Point &a, const Point &b) {\n    return a.x * b.y - a.y * b.x;\n  }\n};\n\ntemplate <class T>\nvector<Point<T>> minkowski_sum(vector<Point<T>> a, vector<Point<T>> b) {\n  vector<Point<T>> c{a[0] + b[0]};\n  for (usz i = 0; i + 1 < a.size(); ++i) a[i] = a[i + 1] - a[i];\n  for (usz i = 0; i + 1 < b.size(); ++i) b[i] = b[i + 1] - b[i];\n  a.pop_back(), b.pop_back();\n  c.resize(a.size() + b.size() + 1);\n  merge(a.begin(), a.end(), b.begin(), b.end(), c.begin() + 1,\n        [](const Point<i64> &a, const Point<i64> &b) { return (a ^ b) < 0; });\n  for (usz i = 1; i < c.size(); ++i) c[i] = c[i] + c[i - 1];\n  return c;\n}\n```\n\n----------------------------------------\n\nTITLE: Interactive LowerBound Implementation in C++\nDESCRIPTION: Solution to CF843B that uses random sampling and traversal to find elements in a linked list with limited queries. Handles both small and large input cases efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/interaction.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\nconstexpr int N = 50005;\nint n, start, x;\nint a[N];\n\nint main() {\n  scanf(\"%d%d%d\", &n, &start, &x);\n  if (n < 2000) {\n    int ans = 2e9;\n    for (int i = 1; i <= n; i++) {\n      printf(\"? %d\\n\", i), fflush(stdout);\n      int val, next;\n      scanf(\"%d%d\", &val, &next);\n      if (val >= x) ans = std::min(ans, val);\n    }\n    if (ans == 2e9) ans = -1;\n    printf(\"! %d\", ans), fflush(stdout);\n  } else {\n    srand((size_t) new char);\n    int p = start, ans = 0;\n    for (int i = 1; i <= n; i++) a[i] = i;\n    std::random_shuffle(a + 1, a + n + 1);\n    for (int i = 1; i <= 1000; i++) {\n      printf(\"? %d\\n\", a[i]), fflush(stdout);\n      int val, next;\n      scanf(\"%d%d\", &val, &next);\n      if (val < x && val > ans) p = a[i], ans = val;\n    }\n    while (p != -1 && ans < x) {\n      printf(\"? %d\\n\", p), fflush(stdout);\n      int val, next;\n      scanf(\"%d%d\", &val, &next);\n      ans = val;\n      p = next;\n    }\n    if (ans < x) ans = -1;\n    printf(\"! %d\", ans), fflush(stdout);\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: 二维数论分块解决Chain Reaction问题\nDESCRIPTION: 使用二维数论分块解决CF1954E Chain Reaction问题。代码计算对于每个可能的攻击强度k，击杀所有怪兽所需的最小攻击次数。通过积木大赛的技巧和二维数论分块优化，时间复杂度为O(∑√a_i)。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sqrt-decomposition.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nint n, a[N], ans[N];\nvoid solve() {\n  cin >> n;\n  for (int i = 1; i <= n; i++) cin >> a[i];\n  a[0] = 0;\n  for (int i = 1; i <= 100000; i++) ans[i] = 0;\n  for (int i = 1; i <= n; i++) {\n    // 对于a_i和a_{i-1}，有贡献的k必须满足天花板(a_i/k)>天花板(a_{i-1}/k)\n    // 这说明转化后必须有a_i > a_{i-1}才会产生贡献\n    if (a[i] <= a[i - 1]) continue;\n    for (int l = 1, r; l <= a[i]; l = r + 1) {\n      r = min(a[i] / (a[i] / l), (a[i] - 1) / ((a[i] - 1) / l));\n      if (l > a[i - 1]) {\n        // a_{i-1}/k的天花板一定是0\n        ans[l]++, ans[r + 1]--;\n      } else {\n        // 使用二维数论分块将范围缩小\n        r = min(r, a[i - 1]);\n        // 在这个块内，上取整(a_i/k)=上取整(a_{i-1}/k)+1\n        // 所以每个k的贡献都是1\n        ans[l]++, ans[r + 1]--;\n      }\n    }\n  }\n  for (int i = 1; i <= 100000; i++) ans[i] += ans[i - 1];\n  for (int i = 1; i <= 100000; i++) cout << ans[i] << \" \";\n  cout << endl;\n}\nint main() {\n  cin.tie(0)->sync_with_stdio(0);\n  int t = 1;\n  // cin>>t;\n  while (t--) solve();\n}\n```\n\n----------------------------------------\n\nTITLE: Graph and Blossom Data Structures in C++\nDESCRIPTION: Defines the core data structures for representing the graph, edges, and blossoms (flowers) used in the general weighted matching algorithm. It includes structures for edges, adjacency matrix, and arrays to track matching, slack, and blossom information.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int INF = INT_MAX;\nconstexpr int MAXN = 400;\n\nstruct edge {\n  int u, v, w;\n\n  // 表示(u,v)为一条边其权重为w\n  edge() {}\n\n  edge(int u, int v, int w) : u(u), v(v), w(w) {}\n};\n\nint n, n_x;\n// 有n个点，编号为 1 ~ n\n// n_x表示当前点加上花的数量，编号从n+1到n_x为花的节点\nedge g[MAXN * 2 + 1][MAXN * 2 + 1];\n// 图用邻接矩阵存储，因为最多有n-1朵花，所以大小为MAXN*\nvector<int> flower[MAXN * 2 + 1];\n// flower[b]记录了花b中有哪些点\n// 我们记录花中的点的方式是只记录花里面的最外层花\n```\n\n----------------------------------------\n\nTITLE: Optimized Trial Division Method for Primality Testing in C++ and Python\nDESCRIPTION: Improved trial division algorithm that only checks divisibility for numbers from 2 to the square root of n. This optimization significantly reduces the time complexity while maintaining correctness.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nbool isPrime(int a) {\n  if (a < 2) return 0;\n  for (int i = 2; (long long)i * i <= a; ++i)  // 防溢出\n    if (a % i == 0) return 0;\n  return 1;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef isPrime(a):\n    if a < 2:\n        return False\n    for i in range(2, int(sqrt(a)) + 1):\n        if a % i == 0:\n            return False\n    return True\n```\n\n----------------------------------------\n\nTITLE: Defining a Plane Equation in 3D Space (LaTeX)\nDESCRIPTION: Demonstrates the derivation of the general form equation for a plane in 3D space, starting from a point and normal vector representation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/3d.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$\nA(x-x_0)+B(y-y_0)+C(z-z_0)=0\n$$\n\n$$\nAx+By+Cz-(Ax_0+By_0+Cz_0)=0\n$$\n\n$$\nAx+By+Cz+D=0\n$$\n```\n\n----------------------------------------\n\nTITLE: Mathematical Proof of Generalized Pigeonhole Principle\nDESCRIPTION: Mathematical formula and proof showing that when n objects are divided into k groups, at least one group must contain at least ⌈n/k⌉ objects. The proof uses contradiction to demonstrate this property.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/drawer-principle.md#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\n\\left \\lceil \\dfrac{n}{k} \\right \\rceil\n```\n\nLANGUAGE: math\nCODE:\n```\nS\\leq (\\left \\lceil \\dfrac{n}{k} \\right \\rceil -1 ) \\times k=k\\left\\lceil \\dfrac{n}{k} \\right\\rceil-k < k(\\dfrac{n}{k}+1)-k=n\n```\n\n----------------------------------------\n\nTITLE: Orbit and Transversal Computation\nDESCRIPTION: Algorithm to compute the orbit and transversal of a point β under a group G given by generators S. Returns the orbit Δ and transversal T.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nAlgorithm OrbitTransversal(S,β):\nInput. A generating set S for a group G and a point β.\nOutput. The orbit Δ=β^G and the transversal T.\nMethod.\n1  Δ ← [β]\n2  T[β] ← e\n3  for δ∈Δ\n4    for s∈S\n5      γ ← δ^s\n6      if γ∉Δ then\n7        append γ to Δ\n8        T[γ] ← T[δ]·s\n9      end if\n10   end for\n11 end for\n12 return Δ, T\n```\n\n----------------------------------------\n\nTITLE: Solving POJ2976 Dropping Tests with Fractional Programming in C++\nDESCRIPTION: This code snippet shows how to solve the POJ2976 problem using fractional programming. It selects the n-k items with the highest value to maximize the fraction.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/frac-programming.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nbool cmp(double x, double y) { return x > y; }\n\nbool check(double mid) {\n  int s = 0;\n  for (int i = 1; i <= n; ++i) c[i] = a[i] - mid * b[i];\n  sort(c + 1, c + n + 1, cmp);\n  for (int i = 1; i <= n - k; ++i) s += c[i];\n  return s > 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Absolute Value Function Implementation Comparison\nDESCRIPTION: Comparison between Pascal and C++ implementations of an absolute value function, showing differences in function declaration, return statements, and overall syntax.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_11\n\nLANGUAGE: Pascal\nCODE:\n```\nfunction abs(x:integer):integer;\nbegin\n    if x < 0 then\n        begin\n            abs := -x;\n        end\n    else\n        begin\n            abs := x;\n        end;\nend;\n```\n\nLANGUAGE: C++\nCODE:\n```\nint abs(int x) {\n  if (x < 0) {\n    return -x;\n  } else {\n    return x;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of Subspace in Jordan Decomposition\nDESCRIPTION: The definition of the subspace corresponding to each eigenvalue in the Jordan decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_15\n\nLANGUAGE: latex\nCODE:\n```\nV_i=N\\left({(A-\\lambda_i I)}^{r_i}\\right)\n```\n\n----------------------------------------\n\nTITLE: Java Array Declaration\nDESCRIPTION: Shows how to declare and initialize arrays in Java using the new keyword with specified size.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_3\n\nLANGUAGE: java\nCODE:\n```\n// 有十个元素的整数类型数组\n// 其语法格式为 数据类型[] 变量名 = new 数据类型[数组大小]\nint[] ary = new int[10];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Type Conversion in C++\nDESCRIPTION: Shows C++'s automatic type conversion capabilities, including integer to boolean conversion, float-integer conversion, and character-integer conversion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_9\n\nLANGUAGE: C++\nCODE:\n```\nint i = 2;\nif (i) {  // i = 0 会返回 false，其余返回 true\n  std::cout << \"true\";\n} else {\n  std::cout << \"false\";\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Images to LaTeX Documents\nDESCRIPTION: Practical example showing how to add images to a LaTeX document with proper positioning, sizing, and captioning.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_3\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{figure}[h!]\n  \\centering\n  \\includegraphics[width=1\\textwidth]{ImageFilename}\n  \\caption{My test image}\n\\end{figure}\n```\n\n----------------------------------------\n\nTITLE: Using Bitwise Operators in C++\nDESCRIPTION: Demonstrates bitwise AND, XOR, and OR operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_16\n\nLANGUAGE: C++\nCODE:\n```\nflags = flags & 42;\nflags = flags ^ 42;\nflags = flags | 42;\n```\n\n----------------------------------------\n\nTITLE: Digit Pattern Avoidance in C++\nDESCRIPTION: Implementation for finding numbers that avoid specific digit patterns (like 4 and 62) within a given range using dynamic programming with memoization.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/number.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\nint x, y, dp[15][3], p[50];\n\nvoid pre() {\n  memset(dp, 0, sizeof(dp));\n  dp[0][0] = 1;\n  for (int i = 1; i <= 10; i++) {\n    dp[i][0] = dp[i - 1][0] * 9 - dp[i - 1][1];\n    dp[i][1] = dp[i - 1][0];\n    dp[i][2] = dp[i - 1][2] * 10 + dp[i - 1][1] + dp[i - 1][0];\n  }\n}\n\nint cal(int x) {\n  int cnt = 0, ans = 0, tmp = x;\n  while (x) {\n    p[++cnt] = x % 10;\n    x /= 10;\n  }\n  bool flag = false;\n  p[cnt + 1] = 0;\n  for (int i = cnt; i; i--) {\n    ans += p[i] * dp[i - 1][2];\n    if (flag)\n      ans += p[i] * dp[i - 1][0];\n    else {\n      if (p[i] > 4) ans += dp[i - 1][0];\n      if (p[i] > 6) ans += dp[i - 1][1];\n      if (p[i] > 2 && p[i + 1] == 6) ans += dp[i][1];\n      if (p[i] == 4 || (p[i] == 2 && p[i + 1] == 6)) flag = true;\n    }\n  }\n  return tmp - ans;\n}\n\nint main() {\n  pre();\n  while (~scanf(\"%d%d\", &x, &y)) {\n    if (!x && !y) break;\n    x = min(x, y), y = max(x, y);\n    printf(\"%d\\n\", cal(y + 1) - cal(x));\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing Recursive and Non-Recursive Merge Sort in Python\nDESCRIPTION: Python implementation of merge sort using both recursive and non-recursive approaches, showing the same patterns as the C++ version.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/divide-and-conquer.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# 不使用递归的归并排序算法\ndef merge_sort(a):\n    n = len(a)\n    seg, start = 1, 0\n    while seg < n:\n        while start < n - seg:\n            merge(a, start, start + seg - 1, min(start + seg + seg - 1, n - 1))\n            start = start + seg + seg\n        seg = seg + seg\n\n\n# 使用递归的归并排序算法\ndef merge_sort(a, front, end):\n    if front >= end:\n        return\n    mid = front + (end - front) / 2\n    merge_sort(a, front, mid)\n    merge_sort(a, mid + 1, end)\n    merge(a, front, mid, end)\n```\n\n----------------------------------------\n\nTITLE: Validity Check for Grid Coloring Problem in C++\nDESCRIPTION: Implements a validity check for the grid coloring problem. Ensures that no closed color regions are created prematurely and handles special cases for the last row and column.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nbool ok(int i, int j, int cc) {\n  if (cc == c[j + 1]) return true;\n  int up = b[j + 1];\n  if (!up) return true;\n  int c1 = 0, c2 = 0;\n  REP(i, m + 1) if (i != j + 1) {\n    if (b[i] == b[j + 1]) {  // 连通性相同，颜色一定相同\n      assert(c[i] == c[j + 1]);\n    }\n    if (c[i] == c[j + 1] && b[i] == b[j + 1]) ++c1;\n    if (c[i] == c[j + 1]) ++c2;\n  }\n  if (!c1) {               // 如果会生成新的封闭连通块\n    if (c2) return false;  // 如果轮廓线上还有相同的颜色\n    if (i < n - 1 || j < m - 2) return false;\n  }\n  return true;\n}\n```\n\n----------------------------------------\n\nTITLE: DLX Remove Column Operation Implementation\nDESCRIPTION: Implements the remove() operation that eliminates a column and its related rows/columns from the Dancing Links structure while maintaining proper link connectivity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nvoid remove(const int &c) {\n  int i, j;\n  L[R[c]] = L[c], R[L[c]] = R[c];\n  IT(i, D, c)\n  IT(j, R, i)\n  U[D[j]] = U[j], D[U[j]] = D[j], --siz[col[j]];\n}\n```\n\n----------------------------------------\n\nTITLE: 轮廓线DP状态转移方程 (C++)\nDESCRIPTION: 骨牌覆盖问题中轮廓线DP的状态转移方程，展示了如何处理已覆盖和未覆盖的位置，分别考虑横放和竖放骨牌的情况。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nif (s >> j & 1) {       // 如果已被覆盖\n  f1[s ^ 1 << j] += u;  // 不放\n} else {                // 如果未被覆盖\n  if (j != m - 1 && (!(s >> j + 1 & 1))) f1[s ^ 1 << j + 1] += u;  // 横放\n  f1[s ^ 1 << j] += u;                                             // 竖放\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Input from File using freopen in C/C++\nDESCRIPTION: Example of using freopen to redirect stdin to read from a file. This allows standard input functions like scanf and cin to read from the specified file instead of keyboard input.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nfreopen(\"data.in\", \"r\", stdin);\n// data.in 就是读取的文件名，要和可执行文件放在同一目录下\n```\n\n----------------------------------------\n\nTITLE: Defining a Union in C++\nDESCRIPTION: Example of how to define a union named MyUnion with two members: an integer and a long long. This demonstrates the basic syntax for union declaration in C++, similar to struct declarations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/union.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nunion MyUnion {\n  int x;\n  long long y;\n} x;\n```\n\n----------------------------------------\n\nTITLE: Dynamic Tree Divide Solution for Node Value Sum Query in C++\nDESCRIPTION: This code implements a solution to a problem involving node value sum queries within a certain distance using dynamic tree divide. It uses dynamic segment trees to maintain distance information and handle queries and modifications.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dynamic-tree-divide.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/dynamic-tree-divide/dynamic-tree-divide_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Installing GUIDE on openSUSE\nDESCRIPTION: This bash script installs GUIDE 1.0.2 on openSUSE systems. It uses opi to install checkinstall, installs required dependencies, downloads the GUIDE package, extracts it, creates a Makefile, and uses checkinstall to create and install an RPM package.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/guide.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsudo opi checkinstall\nsudo zypper install -n {libpng12-0,libSM6,libICE6,libXi6,libXrender1,libXrandr2,libfreetype6,libfontconfig1,libXext6,libX11-6,libz1,libgthread-2_0-0,libglib2_0-0,libstdc++6,libgcc_s1,glibc}-32bit\nwget -c http://download.noi.cn/T/noi/GUIDE-1.0.2-ubuntu.tar\ntar -xvf GUIDE-1.0.2-ubuntu.tar\ncd GUIDE-1.0.2-ubuntu\necho \"install:\\n\\tinstall -Dm755 -t /usr/bin GUIDE\\n\\tinstall -Dm644 -t /usr/share/ lang_en.qm\\n\\tmkdir -p /usr/share/apis/ && cp -r apis/* /usr/share/apis/\\n\\tmkdir -p /usr/share/doc/GUIDE/ && mkdir -p /usr/share/doc/GUIDE/html/ && cp -r doc/*  /usr/share/doc/GUIDE/html/\" > Makefile\nsudo checkinstall --pkgname \"GUIDE\" --pkgversion \"1.0.2\" -y -rpmi\n```\n\n----------------------------------------\n\nTITLE: Building a Stern-Brocot Tree in C++\nDESCRIPTION: Code for constructing and performing an in-order traversal of the first n levels of a Stern-Brocot tree. The implementation follows the iterative construction method, where each new level is created by inserting mediant fractions between adjacent fractions from the previous level.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvoid dfs(int a, int b, int c, int d, int depth) {\n    if (depth == 0) return;\n    dfs(a, b, a + c, b + d, depth - 1);\n    cout << a + c << \"/\" << b + d << \" \";\n    dfs(a + c, b + d, c, d, depth - 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running a Grader-based Interactive Problem Solution in C++\nDESCRIPTION: This snippet demonstrates how to compile and run a solution for a grader-based interactive problem. It shows the command to compile the grader and solution files together, and then execute the resulting program.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problems.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ng++ grader.cpp my_solution.cpp -o my_solution -Wall -O2\n./my_solution   # Execute the program\n```\n\n----------------------------------------\n\nTITLE: Unsetting a Specific Bit in C++\nDESCRIPTION: A function that sets a specific bit of an integer to 0 while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_11\n\nLANGUAGE: C++\nCODE:\n```\n// 将 a 的第 b 位设置为 0 ，最低位编号为 0\nint unsetBit(int a, int b) { return a & ~(1 << b); }\n```\n\n----------------------------------------\n\nTITLE: Defining Node Structure for Chtholly Tree in C++\nDESCRIPTION: Defines the Node_t structure used to represent intervals in the Chtholly Tree. Each node contains left and right boundaries and a mutable value. The < operator is overloaded for comparison.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct Node_t {\n  int l, r;\n  mutable int v;\n\n  Node_t(const int &il, const int &ir, const int &iv) : l(il), r(ir), v(iv) {}\n\n  bool operator<(const Node_t &o) const { return l < o.l; }\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Windows Command Prompt Example\nDESCRIPTION: Shows the basic command prompt structure in Windows and example command execution\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/cmd.md#2025-04-22_snippet_0\n\nLANGUAGE: doscon\nCODE:\n```\nC:\\Users\\chtholly>echo \"Hello World!\"\n```\n\n----------------------------------------\n\nTITLE: Optimized Extended Euclidean Algorithm using Matrix Representation\nDESCRIPTION: This function provides an optimized implementation of the Extended Euclidean Algorithm using matrix representation. It uses a 2x2 matrix to track the coefficients and simplify the iterative process.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nint exgcd(int a, int b, int &x, int &y) {\n  int x1 = 1, x2 = 0, x3 = 0, x4 = 1;\n  while (b != 0) {\n    int c = a / b;\n    std::tie(x1, x2, x3, x4, a, b) =\n        std::make_tuple(x3, x4, x1 - x3 * c, x2 - x4 * c, b, a - b * c);\n  }\n  x = x1, y = x2;\n  return a;\n}\n```\n\n----------------------------------------\n\nTITLE: Summing Array Elements in C++\nDESCRIPTION: This snippet shows how to sum the elements of an array after reading them from input. It uses two separate loops for input and summation, demonstrating array traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/array.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\nusing namespace std;\n\nint arr[1001];\n\nint main() {\n  int n;\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> arr[i];\n  }\n\n  int sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    sum += arr[i];\n  }\n\n  printf(\"%d\\n\", sum);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: 数论分块伪代码实现\nDESCRIPTION: 展示了数论分块的核心算法伪代码。该算法首先计算f(i)的前缀和，然后将相同⌊n/i⌋值的区间分为一块进行计算，最终得到和式∑f(i)⌊n/i⌋的值。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sqrt-decomposition.md#2025-04-22_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\n1 & \\text{Calculate $s(i)$, the prefix sum of $f(i)$.} \\\\\n2 & l \\gets 1\\\\\n3 & r \\gets 0\\\\\n4 & \\textit{result} \\gets 0 \\\\\n5 & \\textbf{while } l \\leq n \\textbf{ do} : \\\\\n6 & \\qquad r \\gets \\left\\lfloor \\dfrac{n}{\\lfloor n/l \\rfloor} \\right\\rfloor\\\\\n7 & \\qquad \\textit{result} \\gets \\textit{result} + [s(r)-s(l-1)] \\times\\left\\lfloor \\dfrac{n}{l} \\right\\rfloor\\\\\n8 & \\qquad l \\gets r+1\\\\\n9 & \\textbf{end while }\\\\\n```\n\n----------------------------------------\n\nTITLE: Cosine Function Implementation in C++\nDESCRIPTION: Template-based cosine function implementation using Taylor series expansion with configurable floating point precision and epsilon value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\ntemplate <typename FLOAT_T>\nFLOAT_T cos(const FLOAT_T &x, const long double &EPS = fstdlib::EPS) {\n  FLOAT_T res = 0, delt = 1;\n  int d = 0;\n  while (fabs(delt) > EPS) {\n    res += delt, ++d;\n    delt *= -x * x / ((2 * d) * (2 * d - 1));\n  }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Berlekamp-Massey Algorithm in C++\nDESCRIPTION: C++ implementation of the Berlekamp-Massey algorithm to find the shortest linear recurrence relation for a given integer sequence modulo a prime p. The function returns the coefficients of the recurrence relation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/berlekamp-massey.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nvector<int> berlekamp_massey(const vector<int> &a) {\n  vector<int> v, last;  // v is the answer, 0-based, p is the module\n  int k = -1, delta = 0;\n\n  for (int i = 0; i < (int)a.size(); i++) {\n    int tmp = 0;\n    for (int j = 0; j < (int)v.size(); j++)\n      tmp = (tmp + (long long)a[i - j - 1] * v[j]) % p;\n\n    if (a[i] == tmp) continue;\n\n    if (k < 0) {\n      k = i;\n      delta = (a[i] - tmp + p) % p;\n      v = vector<int>(i + 1);\n\n      continue;\n    }\n\n    vector<int> u = v;\n    int val = (long long)(a[i] - tmp + p) * power(delta, p - 2) % p;\n\n    if (v.size() < last.size() + i - k) v.resize(last.size() + i - k);\n\n    (v[i - k - 1] += val) %= p;\n\n    for (int j = 0; j < (int)last.size(); j++) {\n      v[i - k + j] = (v[i - k + j] - (long long)val * last[j]) % p;\n      if (v[i - k + j] < 0) v[i - k + j] += p;\n    }\n\n    if ((int)u.size() - i < (int)last.size() - k) {\n      last = u;\n      k = i;\n      delta = a[i] - tmp;\n      if (delta < 0) delta += p;\n    }\n  }\n\n  for (auto &x : v) x = (p - x) % p;\n  v.insert(v.begin(), 1);\n\n  return v;  // $\\forall i, \\sum_{j = 0} ^ m a_{i - j} v_j = 0$\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Fibonacci Numbers Modulo M using Ring Extension\nDESCRIPTION: This code snippet demonstrates how to calculate the nth Fibonacci number modulo m using a ring extension approach. It avoids issues with irreducibility and inverse elements by working with polynomials modulo x^2-x-1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_11\n\nLANGUAGE: Python\nCODE:\n```\ndef fib_mod(n, m):\n    def mul(a, b):\n        return ((a[0]*b[0] + a[1]*b[1]) % m,\n                (a[0]*b[1] + a[1]*(b[0]+b[1])) % m)\n    \n    def pow(a, n):\n        if n == 0:\n            return (1, 0)\n        if n % 2 == 0:\n            return pow(mul(a, a), n // 2)\n        return mul(a, pow(a, n-1))\n    \n    return pow((1, -1), n)[0]\n```\n\n----------------------------------------\n\nTITLE: Definition of Principal Ideals\nDESCRIPTION: The definition of a principal ideal, which is an ideal generated by a single element of the ring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_18\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"主理想\"\n    由单个元素 $a\\in R$ 生成的理想称为 **主理想**（principal ideal），记作 $(a)$。此时，$a$ 称为 $(a)$ 的 **生成元**（generator）。\n```\n\n----------------------------------------\n\nTITLE: Comparing std::pair Objects\nDESCRIPTION: Example of using comparison operators with pair objects. Pairs are compared first by their first elements, then by their second elements if the first are equal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nif (p2 >= p3) {\n  cout << \"do something here\" << endl;\n}\n```\n\nLANGUAGE: cpp\nCODE:\n```\npriority_queue<pair<int, double>> q;\n```\n\n----------------------------------------\n\nTITLE: Implementing Split Operation for Chtholly Tree using std::map in C++\nDESCRIPTION: Implements the split operation for a Chtholly Tree using std::map instead of std::set. This version simplifies the split operation by using map's key-value structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nvoid split(int x) {\n  auto it = prev(mp.upper_bound(x));\n  mp[x] = it->second;\n}\n```\n\n----------------------------------------\n\nTITLE: Tree Preprocessing DFS - Second Pass\nDESCRIPTION: Second DFS pass to assign chain tops and DFS ordering\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/hld.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nvoid dfs2(int o, int t) {\n  top[o] = t;\n  cnt++;\n  dfn[o] = cnt;\n  rnk[cnt] = o;\n  if (son[o] == -1) return;\n  dfs2(son[o], t);\n  for (int j = h[o]; j; j = nxt[j])\n    if (p[j] != son[o] && p[j] != fa[o]) dfs2(p[j], p[j]);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Member Access Operators in C++\nDESCRIPTION: This code snippet demonstrates various member access operators in C++, including array subscript operator, member access operator, pointer-to-member operator, address-of operator, and dereference operator. These operators allow accessing members of objects or memory.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nauto result1 = v[1];  // 获取v中下标为2的对象\nauto result2 = p.q;   // 获取p对象的q成员\nauto result3 = p -> q;  // 获取p指针指向的对象的q成员，等价于 (*p).q\nauto result4 = &v;      // 获取指向v的指针\nauto result5 = *v;      // 获取v指针指向的对象\n```\n\n----------------------------------------\n\nTITLE: Codeforces Example with Arrays.sort()\nDESCRIPTION: Implementation of Codeforces 1646B - Quality vs Quantity problem using Arrays.sort(). This example demonstrates how the type of array (primitive vs object) affects sorting performance, potentially causing TLE issues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_23\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static class FastReader {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    static PrintWriter out = new PrintWriter(System.out);\n    static FastReader in = new FastReader();\n\n    static void solve() {\n        int n = in.nextInt();\n        Integer[] a = new Integer[n + 10];\n        for (int i = 1; i <= n; i++) {\n            a[i] = in.nextInt();\n        }\n        Arrays.sort(a, 1, n + 1);\n        long left = a[1];\n        long right = 0;\n        int x = n;\n        for (int i = 2; i < x; i++, x--) {\n            left = left + a[i];\n            right = right + a[x];\n            if (right > left) {\n                out.println(\"YES\");\n                return;\n            }\n        }\n        out.println(\"NO\");\n    }\n\n    public static void main(String[] args) {\n        int t = in.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Development Environment\nDESCRIPTION: Command to install C/C++ compilation tools and development environments required by NOI\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# apt install -y build-essential vim ddd gdb fpc emacs gedit anjuta lazarus\n```\n\n----------------------------------------\n\nTITLE: Initializing and Using GNU PBDS Priority Queue Iterator\nDESCRIPTION: Demonstrates how to create a point_iterator for a priority queue and use it to track elements after pushing them into the queue.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/pq.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n__gnu_pbds::priority_queue<int>::point_iterator id;  // 点类型迭代器\n// 在 modify 和 push 的时候都会返回一个 point_iterator，下文会详细的讲使用方法\nid = q.push(1);\n```\n\n----------------------------------------\n\nTITLE: Calculating Same-Column Second Kind Stirling Numbers in C++\nDESCRIPTION: This code calculates the second kind Stirling numbers for a fixed k and varying i using exponential generating functions and polynomial operations. It utilizes modular arithmetic for large number calculations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  poly f(n + 1);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;\n  for (int i = 1; i <= n; ++i) f[i] = qpow(fact[i], mod - 2);\n  f = exp(log(f >> 1) * k) << k, f.resize(n + 1);\n  int inv = qpow(fact[k], mod - 2);\n  for (int i = 0; i <= n; ++i)\n    printf(\"%lld \", (ll)f[i] * fact[i] % mod * inv % mod);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: UOJ Maximum Weight Bipartite Matching Solution\nDESCRIPTION: Solution code for UOJ Problem #80 demonstrating implementation of maximum weight bipartite matching algorithm\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/bigraph-weight-match.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/graph-matching/bigraph-weight-match/bigraph-weight-match_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Dynamic 2D Array Creation in C++\nDESCRIPTION: Shows different methods for creating dynamic 2D arrays, including using a single block of memory and array of pointers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nint* a = new int[N * M];\n```\n\nLANGUAGE: C++\nCODE:\n```\nint** a = new int*[5];\nfor (int i = 0; i < 5; i++) {\n  a[i] = new int[5];\n}\n\n// Deletion\nfor (int i = 0; i < 5; i++) {\n  delete[] a[i];\n}\ndelete[] a;\n```\n\nLANGUAGE: C++\nCODE:\n```\nint main() {\n  int(*a)[5] = new int[5][5];\n  int* p = a[2];\n  a[2][1] = 1;\n  delete[] a;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Complexity for Nested Loops in Python\nDESCRIPTION: Shows the same triple nested loop structure as the C++ example, implemented in Python, with time complexity O(n^2 * m).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nn = int(input())\nm = int(input())\nfor i in range(0, n):\n    for j in range(0, n):\n        for k in range(0, m):\n            print(\"hello world\")\n```\n\n----------------------------------------\n\nTITLE: B+ Tree Display Method Implementation in C++\nDESCRIPTION: Recursive method to display the contents of a B+ Tree, traversing through all nodes and printing their key values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bplus-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid BPTree::display(Node *cursor) {\n  if (cursor != NULL) {\n    for (int i = 0; i < cursor->size; i++) {\n      cout << cursor->key[i] << \" \";\n    }\n    cout << \"\\n\";\n    if (!cursor->IS_LEAF) {\n      for (int i = 0; i < cursor->size + 1; i++) {\n        display(cursor->ptr[i]);\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: C++ Example Program\nDESCRIPTION: Example of compiling and running a C++ program in WSL Ubuntu\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ vim cpuid.cpp\n...\n$ g++ -Wall cpuid.cpp -o cpuid\n$ ./cpuid\nAMD Ryzen 5 1400 Quad-Core Processor\n```\n\n----------------------------------------\n\nTITLE: Building a Stern-Brocot Tree in Python\nDESCRIPTION: Python implementation for constructing and traversing the first n levels of a Stern-Brocot tree. This recursive implementation builds the tree by inserting mediant fractions between adjacent fractions and performs an in-order traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef dfs(a, b, c, d, depth):\n    if depth == 0:\n        return\n    dfs(a, b, a + c, b + d, depth - 1)\n    print(f\"{a + c}/{b + d}\", end=\" \")\n    dfs(a + c, b + d, c, d, depth - 1)\n```\n\n----------------------------------------\n\nTITLE: Mathematical Problem - Radix Sum (CF 1103E)\nDESCRIPTION: Problem statement involving sequence calculations with non-carrying decimal addition and modulo operations. Solution uses dynamic programming and FWT with field extension concepts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fwt.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\sum\\limits_{j=1}^n a_{i_j} = p\n```\n\n----------------------------------------\n\nTITLE: PQa Algorithm for Solving x^2 - 13y^2 = ±4\nDESCRIPTION: This snippet demonstrates the application of the PQa algorithm to solve the Diophantine equation x^2 - 13y^2 = ±4. It shows the initial steps of the algorithm and identifies the fundamental solutions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_7\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\n| k | P | Q | a            | A     | B     | G     | G^2-DB^2 |\n|:---:|:---:|:---:|:--------------:|:-------:|:-------:|:-------:|:----------:|\n| 0 | 1 | 2 | 2            | 2     | 1     | 3     | -4       |\n| 1 | 3 | 2 |\\color{red}{3}| 7     | 3     | 11    | 4        |\n| 2 | 3 | 2 | 3            | 23    | 10    | 36    | -4       |\n| 3 | 3 | 2 | 3            | 74    | 33    | 119   | 4        |\n```\n\n----------------------------------------\n\nTITLE: Continued Fraction-Based Fraction Finding in Python\nDESCRIPTION: Python implementation of the continued fraction-based algorithm for finding a fraction in a Stern-Brocot tree. This method uses the relationship between continued fractions and tree paths for efficient searching.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef find(p, q):\n    path = \"\"\n    while p != 1 or q != 1:\n        if p > q:\n            t = p // q\n            path += \"R\" * t\n            p -= t * q\n        else:\n            t = q // p\n            path += \"L\" * t\n            q -= t * p\n        if p == 0: p = 1\n        if q == 0: q = 1\n    return path\n```\n\n----------------------------------------\n\nTITLE: Implementing Digit DP with Aho-Corasick Automaton in C++\nDESCRIPTION: This code snippet implements a solution for a digit dynamic programming problem using an Aho-Corasick automaton. It includes functions for inserting patterns, building the automaton, and calculating the final result using DP. The solution handles pattern matching and counting valid numbers within a given range.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/number.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\nusing ll = long long;\nconstexpr int N = 1505;\nconstexpr int mod = 1000000007;\nint n, m;\nchar s[N], c[N];\nint ch[N][10], fail[N], ed[N], tot, len;\n\nvoid insert() {\n  int now = 0;\n  int L = strlen(s);\n  for (int i = 0; i < L; ++i) {\n    if (!ch[now][s[i] - '0']) ch[now][s[i] - '0'] = ++tot;\n    now = ch[now][s[i] - '0'];\n  }\n  ed[now] = 1;\n}\n\nqueue<int> q;\n\nvoid build() {\n  for (int i = 0; i < 10; ++i)\n    if (ch[0][i]) q.push(ch[0][i]);\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n    for (int i = 0; i < 10; ++i) {\n      if (ch[u][i]) {\n        fail[ch[u][i]] = ch[fail[u]][i], q.push(ch[u][i]),\n        ed[ch[u][i]] |= ed[fail[ch[u][i]]];\n      } else\n        ch[u][i] = ch[fail[u]][i];\n    }\n  }\n  ch[0][0] = 0;\n}\n\nll f[N][N][2], ans;\n\nvoid add(ll &x, ll y) { x = (x + y) % mod; }\n\nint main() {\n  scanf(\"%s\", c);\n  n = strlen(c);\n  scanf(\"%d\", &m);\n  for (int i = 1; i <= m; ++i) scanf(\"%s\", s), insert();\n  build();\n  f[0][0][1] = 1;\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j <= tot; ++j) {\n      if (ed[j]) continue;\n      for (int k = 0; k < 10; ++k) {\n        if (ed[ch[j][k]]) continue;\n        add(f[i + 1][ch[j][k]][0], f[i][j][0]);\n        if (k < c[i] - '0') add(f[i + 1][ch[j][k]][0], f[i][j][1]);\n        if (k == c[i] - '0') add(f[i + 1][ch[j][k]][1], f[i][j][1]);\n      }\n    }\n  }\n  for (int j = 0; j <= tot; ++j) {\n    if (ed[j]) continue;\n    add(ans, f[n][j][0]);\n    add(ans, f[n][j][1]);\n  }\n  printf(\"%lld\\n\", ans - 1);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Intersection of XOR Linear Bases (C++)\nDESCRIPTION: Implements an algorithm to compute the intersection of two XOR linear bases. Uses a modified greedy insertion method to track contributions from the second basis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/basis.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/basis/basis_intersect_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Displaying PQa Algorithm Results for x^2 - 41y^2 = 1 in Markdown\nDESCRIPTION: A Markdown table showing the step-by-step results of applying the PQa algorithm to solve the Pell equation x^2 - 41y^2 = 1, including intermediate values and the final solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n| $k$ | $P$ | $Q$ | $a$             | $A$     | $B$     | $G$     | $G^2-DB^2$ |\n|:---:|:---:|:---:|:---------------:|:-------:|:-------:|:-------:|:----------:|\n| $0$ | $0$ | $1$ | $6$             | $6$     | $1$     | $6$     | $-5$       |\n| $1$ | $6$ | $5$ |$\\color{red}{2}$ | $13$    | $2$     | $13$    | $5$        |\n| $2$ | $4$ | $5$ |$\\color{red}{2}$ | $32$    | $5$     | $32$    | $-1$       |\n| $3$ | $6$ | $1$ |$\\color{red}{12}$| $397$   | $62$    | $397$   | $5$        |\n| $4$ | $6$ | $5$ | $2$             | $826$   | $129$   | $826$   | $-5$       |\n| $5$ | $4$ | $5$ | $2$             | $2049$  | $320$   | $2049$  | $1$        |\n| $6$ | $6$ | $1$ | $12$            | $25414$ | $3969$  | $25414$ | $-5$       |\n| $7$ | $6$ | $5$ | $2$             | $52877$ | $8258$  | $52877$ | $5$        |\n```\n\n----------------------------------------\n\nTITLE: Converting Manhattan Distance to Chebyshev Distance in C++\nDESCRIPTION: This code converts the problem of finding maximum Manhattan distance to finding maximum Chebyshev distance by transforming coordinates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/distance.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  int n, x, y, a, b, minx = 0x7fffffff, maxx = 0, miny = 0x7fffffff, maxy = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &a, &b);\n    x = a + b, y = a - b;\n    minx = min(minx, x), maxx = max(maxx, x);\n    miny = min(miny, y), maxy = max(maxy, y);\n  }\n  printf(\"%d\\n\", max(maxx - minx, maxy - miny));\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Incremental Algorithm for Minimum Enclosing Circle in C++\nDESCRIPTION: This code implements the random incremental algorithm to find the minimum enclosing circle for a set of points. It includes functions for distance calculation, point comparison, and finding the center of a circle given three points. The main algorithm randomly shuffles points and incrementally builds the minimum enclosing circle.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/random-incremental.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nint n;\ndouble r;\n\nstruct point {\n  double x, y;\n} p[100005], o;\n\ndouble sqr(double x) { return x * x; }\n\ndouble dis(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); }\n\nbool cmp(double a, double b) { return fabs(a - b) < 1e-8; }\n\npoint geto(point a, point b, point c) {\n  double a1, a2, b1, b2, c1, c2;\n  point ans;\n  a1 = 2 * (b.x - a.x), b1 = 2 * (b.y - a.y),\n  c1 = sqr(b.x) - sqr(a.x) + sqr(b.y) - sqr(a.y);\n  a2 = 2 * (c.x - a.x), b2 = 2 * (c.y - a.y),\n  c2 = sqr(c.x) - sqr(a.x) + sqr(c.y) - sqr(a.y);\n  if (cmp(a1, 0)) {\n    ans.y = c1 / b1;\n    ans.x = (c2 - ans.y * b2) / a2;\n  } else if (cmp(b1, 0)) {\n    ans.x = c1 / a1;\n    ans.y = (c2 - ans.x * a2) / b2;\n  } else {\n    ans.x = (c2 * b1 - c1 * b2) / (a2 * b1 - a1 * b2);\n    ans.y = (c2 * a1 - c1 * a2) / (b2 * a1 - b1 * a2);\n  }\n  return ans;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n  for (int i = 1; i <= n; i++) swap(p[rand() % n + 1], p[rand() % n + 1]);\n  o = p[1];\n  for (int i = 1; i <= n; i++) {\n    if (dis(o, p[i]) < r || cmp(dis(o, p[i]), r)) continue;\n    o.x = (p[i].x + p[1].x) / 2;\n    o.y = (p[i].y + p[1].y) / 2;\n    r = dis(p[i], p[1]) / 2;\n    for (int j = 2; j < i; j++) {\n      if (dis(o, p[j]) < r || cmp(dis(o, p[j]), r)) continue;\n      o.x = (p[i].x + p[j].x) / 2;\n      o.y = (p[i].y + p[j].y) / 2;\n      r = dis(p[i], p[j]) / 2;\n      for (int k = 1; k < j; k++) {\n        if (dis(o, p[k]) < r || cmp(dis(o, p[k]), r)) continue;\n        o = geto(p[i], p[j], p[k]);\n        r = dis(o, p[i]);\n      }\n    }\n  }\n  printf(\"%.10lf\\n%.10lf %.10lf\", r, o.x, o.y);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Tuple Member Functions Example in C++\nDESCRIPTION: Shows basic usage of tuple member functions including assignment operator and swap method to manipulate tuple contents.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr std::tuple<int, int> tup = {1, 2};\nstd::tuple<int, int> tupA = {2, 3}, tupB;\ntupB = tup;\ntupB.swap(tupA);\n```\n\n----------------------------------------\n\nTITLE: Defining Core Approach for Maximum Matching in Markdown\nDESCRIPTION: This snippet outlines the core approach for finding maximum matching based on Berge's lemma. It suggests enumerating all unmatched vertices and finding augmenting paths until no more can be found.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/augment.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n??? 核心思路\n    枚举所有未匹配点，找增广路径，直到找不到增广路径。\n```\n\n----------------------------------------\n\nTITLE: Second Isomorphism Theorem Proof in TeX\nDESCRIPTION: Proves the second isomorphism theorem which states that for subgroups A and B of a group G where A is in the normalizer of B, AB/B is isomorphic to A/(A∩B).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_5\n\nLANGUAGE: tex\nCODE:\n```\n因为 $A\\le N_G(B)$，必然有 $aBa^{-1}=B$ 对于所有 $a\\in A$ 都成立，此即 $aB=Ba$。因此，必然有 $AB=BA$，则由上述定理知 $AB$ 是子群。子群 $B$ 作为 $AB$ 的子群，左右陪集相同，因而 $B\\trianglelefteq AB$。\n    \n考察映射 $\\varphi:A\\rightarrow AB/B$ 满足 $\\varphi(a)=aB$，则它是满射，且它的核 $\\ker\\varphi=\\{a\\in A:aB=B\\}=A\\cap B$。应用同态基本定理就可得证。\n```\n\n----------------------------------------\n\nTITLE: Initializing DLX Preprocessing Macros in C++\nDESCRIPTION: Defines an iterator macro IT for traversing the Dancing Links structure elements - iterates through linked list nodes using array A starting from position x.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#define IT(i, A, x) for (i = A[x]; i != x; i = A[i])\n```\n\n----------------------------------------\n\nTITLE: Using Type Casting in C++\nDESCRIPTION: Shows how to perform type casting in C++ using the functional notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nunsigned int a = unsigned(3.14);\n```\n\n----------------------------------------\n\nTITLE: Defining Field Characteristics in LaTeX\nDESCRIPTION: A mathematical expression showing that the characteristic of a field F is the smallest positive integer n such that n times the multiplicative identity equals zero. If no such n exists, the characteristic is 0.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nn\\cdot 1=0\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Character Variable in C++\nDESCRIPTION: Illustrates a switch statement using a character variable. Characters are treated as integers in C++, making them valid for switch statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nchar i = 'A';\n\n// 这里的 i 的数据类型是字符型 ，但 char\n// 也是属于整数的类型，满足整数类型的表达式的要求\nswitch (i) {\n  case 'A':\n    cout << \"OI WIKI\" << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Disjoint Set Union Error in C++\nDESCRIPTION: This code shows an incorrect way to merge sets in a DSU (Disjoint Set Union) data structure. When merging sets, it's essential to connect the representatives (roots) of the sets rather than the elements directly.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nf[a] = b;              // 错误\nf[find(a)] = find(b);  // 正确\n```\n\n----------------------------------------\n\nTITLE: Queue Usage Example in C++\nDESCRIPTION: Demonstrates basic queue operations including push, pop, size, front, and empty checks.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nstd::queue<int> q1;\nq1.push(2);\nq1.push(1);\nstd::queue<int> q2(q1);\nq1.pop();\nstd::cout << q1.size() << \" \" << q2.size() << std::endl;    // 1 2\nstd::cout << q1.front() << \" \" << q2.front() << std::endl;  // 1 2\nq1.pop();\nstd::cout << q1.empty() << \" \" << q2.empty() << std::endl;  // 1 0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Scope in C++\nDESCRIPTION: Shows how variable scope works in C++ with global and local variables, demonstrating how local variables shadow global variables of the same name.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nint g = 20;  // 声明全局变量\nint main() {\n  int g = 10;         // 声明局部变量\n  printf(\"%d\\n\", g);  // 输出 g\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Map Operations Example\nDESCRIPTION: Demonstrates common Map operations including put, get, containsKey, and keySet operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_19\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static Map<Integer, Integer> map1 = new HashMap<>();\n    static Map<Integer, Integer> map2 = new LinkedHashMap<>();\n    static Map<Integer, Integer> map3 = new TreeMap<>();\n    static Map<Integer, Integer> map4 = new TreeMap<>((x,y)->{return y-x;});\n\n    static void put(){\n        map1.put(1, 1);\n    }\n    static void get(){\n        map1.get(1);\n    }\n    static void containsKey(){\n        map1.containsKey(1);\n    }\n    static void KeySet(){\n        map1.keySet();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Manhattan Distance in C++\nDESCRIPTION: This code calculates the maximum Manhattan distance between a set of points by finding the maximum difference in x+y and x-y coordinates.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/distance.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nint main() {\n  int n, x, y, minx = 0x7fffffff, maxx = 0, miny = 0x7fffffff, maxy = 0;\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) {\n    scanf(\"%d%d\", &x, &y);\n    minx = min(minx, x + y), maxx = max(maxx, x + y);\n    miny = min(miny, x - y), maxy = max(maxy, x - y);\n  }\n  printf(\"%d\\n\", max(maxx - minx, maxy - miny));\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Permutation Rank\nDESCRIPTION: Algorithm to calculate the lexicographical rank of a given permutation using Lehmer code and factorial number system.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/permutation.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/permutation/perm_rank.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Proving Optimal Strategy for Game Relics Problem\nDESCRIPTION: This snippet presents a proof for the optimal strategy in the Game Relics problem. It compares two random processes to show that drawing items first and then buying the remaining ones is always optimal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/rand-technique.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"证明\"\n    先考虑证明一个特殊情况。将证：\n    \n    -   随机过程 $A$：先买物品 $x$，然后不断抽直到得到所有物品\n    -   ……一定不优于……\n    -   随机过程 $B$：不断抽直到得到 $x$ 以外的所有物品，然后如果还没有 $x$ 则买下来\n    \n    考虑让随机过程 $A$ 和随机过程 $B$ 使用同一个随机数生成器。即，$A$ 的第一次抽取和 $B$ 的第一次抽取会抽到同一个元素，第二次、第三次……也是一样。\n    \n    显然，此时 $A$ 和 $B$ 抽取的次数必定相等。对于一个被 $A$ 抽到的物品 $y\\neq x$，观察到：\n    \n    -   $A$ 中抽到 $y$ 时已经持有的物品数，一定大于等于 $B$ 中抽到 $y$ 时已经持有的物品数。\n    \n    因此 $B$ 的单次抽取代价不高于 $A$ 的单次抽取代价，进而抽取的总代价也不高于 $A$。\n    \n    显然 $B$ 的购买代价同样不高于 $A$。综上，$B$ 一定不劣于 $A$。\n    \n    然后可以通过数学归纳把这一结论推广到一般情况。具体地说，每次我们找到当前策略中的最后一次购买，然后根据上述结论，把这一次购买移到最后一定不劣。细节略。\n```\n\n----------------------------------------\n\nTITLE: Highly Optimized Enumeration with Bucket in Java\nDESCRIPTION: A highly optimized version using a bucket to record visited numbers, reducing time complexity to O(n). This implementation uses a boolean array to track encountered numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_8\n\nLANGUAGE: Java\nCODE:\n```\nboolean[] met = new boolean[MAXN * 2 + 1];\nfor (int i = 0; i < n; ++i) {\n    if (met[MAXN - a[i]]) ++ans;\n    met[MAXN + a[i]] = true;\n}\n```\n\n----------------------------------------\n\nTITLE: Flipping a Specific Bit in Python\nDESCRIPTION: A Python function that toggles (inverts) a specific bit of an integer while leaving other bits unchanged, useful for manipulating individual bits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bit.md#2025-04-22_snippet_16\n\nLANGUAGE: Python\nCODE:\n```\n# 将 a 的第 b 位取反 ，最低位编号为 0\ndef flapBit(a, b):\n    return a ^ (1 << b)\n```\n\n----------------------------------------\n\nTITLE: Including Example Code with Path Reference in Markdown\nDESCRIPTION: Shows how to include example code in Markdown documents using the special syntax with file path reference. This snippet demonstrates the recommended format for integrating code examples from external files.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/format.md#2025-04-22_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n--8<-- \"path\"\n```\n\n----------------------------------------\n\nTITLE: Java Package Declaration and Import\nDESCRIPTION: Shows how to declare package names and import external classes in Java programs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_5\n\nLANGUAGE: java\nCODE:\n```\npackage org.oi-wiki.tutorial;\n\nimport java.util.Scanner;\n```\n\n----------------------------------------\n\nTITLE: Complete Emacs Configuration\nDESCRIPTION: Extended Emacs configuration including UI customization, encoding settings, font configuration, and visual enhancements. Provides comprehensive settings for a fully customized Emacs environment.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/emacs.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n;;设置一键编译\n(defun compile-file ()(interactive)(compile (format \"g++ -o %s %s -g -lm -Wall\" (file-name-sans-extension (buffer-name))(buffer-name))))\n(global-set-key [f9] 'compile-file)\n;;;;设置编译快捷键（如果设置了一键编译不要与一键编译冲突）\n;;(global-set-key [f9] 'compile)\n\n;;考场必备\n(global-set-key (kbd \"C-a\") 'mark-whole-buffer) ;;全选快捷键\n(global-set-key (kbd \"C-z\") 'undo) ;;撤销快捷键\n(global-set-key [f10] 'gud-gdb) ;;GDB调试快捷键\n(global-set-key (kbd \"RET\") 'newline-and-indent) ;;换行自动缩进\n(global-set-key (kbd \"C-s\") 'save-buffer) ;;设置保存快捷键\n(setq-default kill-ring-max 65535) ;;扩大可撤销记录\n;;(define-key key-translation-map [apps] (kbd \"M-x\")) ;; windows 系统下设置命令快捷键\n\n;;设置缩进\n;;;C++ 代码缩进长度。\n(setq-default c-basic-offset 4)\n;;;使用 tab 缩进\n(setq-default indent-tabs-mode t)\n;;;tab 的长度。务必和缩进长度一致\n(setq-default default-tab-width 4)\n(setq-default tab-width 4)\n\n;;设置默认编码环境\n(set-language-environment \"UTF-8\")\n(set-default-coding-systems 'utf-8)\n\n;;不显示欢迎页面\n(setq-default inhibit-startup-screen t)\n\n;;设置标题\n(setq-default frame-title-format \"\")\n\n;;显示行号\n(global-linum-mode t)\n\n;;高亮\n(global-hl-line-mode 1);;高亮当前行\n(show-paren-mode t);;高亮匹配括号\n(global-font-lock-mode t);;语法高亮\n\n;;允许emacs和外部其他程序的粘贴 好像默认允许\n(setq-default x-select-enable-clipboard t)\n\n;;设置字体是 Ubuntu Mono 的 16 号，如果字体不存在会报错\n(set-default-font \"Ubuntu Mono-16\")\n;(set-default-font \"Consolas-16\") ;; windows 系统请用这条\n\n;;鼠标滚轮支持\n(mouse-wheel-mode t)\n\n;;设置光标形状为竖线（默认为方块）\n(setq-default cursor-type 'bar)\n\n;;回答 yes/no 改成回答 y/n\n(fset 'yes-or-no-p 'y-or-n-p)\n\n;;透明度\n(set-frame-parameter (selected-frame) 'alpha (list 85 60))\n(add-to-list 'default-frame-alist (cons 'alpha (list 85 60)))\n\n;;减少页面滚动的行数，防止整页地滚动\n(setq-default scroll-margin 3 scroll-conservatively 10000)\n\n;;优化文件树结构\n(ido-mode t)\n\n;;配色方案\n(setq default-frame-alist\n         '((vertical-scroll-bars)\n           (top . 25)\n           (left . 45)\n           (width . 120)\n           (height . 40)\n           (background-color . \"grey15\")\n           (foreground-color . \"grey\")\n           (cursor-color . \"gold1\")\n           (mouse-color . \"gold1\")\n           (tool-bar-lines . 0)\n           (menu-bar-lines . 1)\n           (scroll-bar-lines . 0)\n           (right-fringe)\n           (left-fringe)))\n\n(set-face-background 'highlight \"gray5\")\n(set-face-foreground 'region \"cyan\")\n(set-face-background 'region \"blue\")\n(set-face-foreground 'secondary-selection \"skyblue\")\n(set-face-background 'secondary-selection \"darkblue\")\n(set-cursor-color \"wheat\")\n(set-mouse-color \"wheat\")\n\n(custom-set-variables\n '(ansi-color-faces-vector\n   [default default default italic underline success warning error])\n;;启动 Ctrl-x Ctrl-c Ctrl-v = 剪切 复制 粘贴\n '(cua-mode t nil (cua-base))\n '(show-paren-mode t)\n;;隐藏工具栏\n '(tool-bar-mode nil))\n;;关闭光标闪烁\n '(blink-cursor-mode nil)\n(custom-set-faces)\n```\n\n----------------------------------------\n\nTITLE: Calculating Labeled Connected Graphs and Euler Graphs in C++\nDESCRIPTION: Code snippet that computes the number of labeled connected graphs and Euler graphs by using the 'ln' function to transform general graph counts into connected graph counts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/graph-enumeration.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i = 1; i <= n; ++i) G[i] = pow(2, binom[i][2]);\nln(C, G);\nfor (int i = 1; i <= n; ++i) G[i] = pow(2, binom[i - 1][2]);\nln(E, G);\n```\n\n----------------------------------------\n\nTITLE: Cycle Index for Cyclic Group Cn\nDESCRIPTION: Formula for the cycle index of a cyclic group Cn, which represents the rotational symmetry group of a regular n-gon.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\nZ(C_n)=\\frac1n\\sum_{d\\mid n}\\varphi(d)t_{d}^{n/d}.\n```\n\n----------------------------------------\n\nTITLE: Splice and Access Functions\nDESCRIPTION: Implementation of splice operation and main access function that maintains the Top Tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid splice(int x) {\n  splay(x, 1);\n  int y = father[x];\n  splay(y, 0);\n  pushdown(x, 1);\n  if (rs(y)) {\n    swap(father[ms(x)], father[rs(y)]);\n    swap(ms(x), rs(y));\n  } else\n    Delete(x);\n  pushup(x, 1);\n  pushup(y, 0);\n}\n\nvoid access(int x) {\n  splay(x, 0);\n  if (rs(x)) {\n    int y = new_node();\n    setfather(ms(x), y, 0);\n    setfather(rs(x), y, 2);\n    rs(x) = 0;\n    setfather(y, x, 2);\n    pushup(y, 1);\n    pushup(x, 0);\n  }\n  while (father[x]) {\n    splice(father[x]);\n    x = father[x];\n    pushup(x, 0);\n  }\n  splay(x, 0)\n}\n```\n\n----------------------------------------\n\nTITLE: Queue Operations and Blossom Management in C++\nDESCRIPTION: Defines functions for managing the queue of nodes to process and setting blossom membership. These functions are essential for traversing the graph and maintaining blossom structures during the matching process.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid q_push(int x) {\n  // 把x丟到queue里面，我们设定queue不能直接push一朵花\n  if (x <= n)\n    q.push(x);\n  else {\n    // 若要push花必须将花里面原图的点都添加到queue中\n    for (size_t i = 0; i < flower[x].size(); i++) {\n      q_push(flower[x][i]);\n    }\n  }\n}\n\nvoid set_st(int x, int b) {\n  // 将x所在的花设为b\n  st[x] = b;\n  if (x > n) {\n    // 若x也是花的话，就必须要把x里面的点其所在的花也设为b\n    for (size_t i = 0; i < flower[x].size(); ++i) {\n      set_st(flower[x][i], b);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Operations on Ideals in Ring Theory\nDESCRIPTION: Definitions of operations on ideals including sum, product, and intersection, which result in new ideals.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_10\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"理想的运算\"\n    设环 $R$ 有理想 $I,J$，可以定义如下运算：\n    \n    -   理想的 **和**（sum）：$I+J=\\{a+b:a\\in I,b\\in J\\}$；\n    -   理想的 **乘积**（product）：$IJ=\\{\\sum_{i=1}^na_ib_i:a_i\\in I,b_i\\in J\\}$，即全体 $ab$ 形式乘积的有限和构成的集合；\n    -   理想的 **交**（intersection）：$I\\cap J$。\n```\n\n----------------------------------------\n\nTITLE: Implementing Pick's Theorem Solution for POJ 1265\nDESCRIPTION: Implementation of a solution that calculates the number of points on boundaries, interior points, and area of a polygon formed by a robot's movement. The code uses GCD for boundary points calculation, Pick's theorem for interior points, and cross product for area calculation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/pick.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\ndocs/geometry/code/pick/pick_1.cpp\n```\n\n----------------------------------------\n\nTITLE: Defining Block Structure for Linked List Implementation of Chtholly Tree in C++\nDESCRIPTION: Defines the Block structure used in a linked list implementation of the Chtholly Tree. Each block represents an interval with a value and links to the next block.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nusing i64 = int64_t;\n\nstruct Block {\n  Block *next;\n  int l, r;\n  i64 val;\n\n  Block(Block *next, int l, int r, i64 val)\n      : next(next), l(l), r(r), val(val) {}\n\n  bool operator<(const Block &b) const { return val < b.val; }\n} *root;\n```\n\n----------------------------------------\n\nTITLE: Proving Reduced Residue System Composition Theorem\nDESCRIPTION: Mathematical proof showing that reduced residue systems can be composed from smaller moduli systems, which is equivalent to proving Euler's function is multiplicative.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/basic.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n令 $Z_{m_1},Z_{m_2}$ 分别为模 $m_1,m_2$ 的完全剩余系，我们已经证明了\n\n$$\nZ_m=m_2Z_{m_1}+m_1Z_{m_2}\n$$\n\n为模 $m$ 的完全剩余系。令 $M=\\{a\\in Z_m:(a,m)=1\\}\\subseteq Z_m$，显然 $M$ 为模 $m$ 的既约剩余系，所以我们只需证明 $M=Z_m^*$ 即可。\n\n显然 $Z_m^*\\subseteq Z_m$。\n\n任取 $m_2x+m_1y\\in M$，其中 $x\\in Z_{m_1}$ 且 $y\\in Z_{m_2}$，有 $(m_2x+m_1y,m_1m_2)=1$，由 $(m_1,m_2)=1$ 可得\n\n$$\n1=(m_2x+m_1y,m_1)=(m_2x,m_1)=(x,m_1),\n$$\n\n$$\n1=(m_2x+m_1y,m_2)=(m_1y,m_2)=(y,m_2).\n$$\n\n因此可得 $x\\in Z_{m_1}^*$ 且 $y\\in Z_{m_2}^*$，即 $M\\subseteq Z_m^*$。\n\n任取 $m_2x+m_1y\\in Z_m^*$，其中 $x\\in Z_{m_1}^*$ 且 $y\\in Z_{m_2}^*$，有 $(x,m_1)=1$ 且 $(y,m_2)=1$，由 $(m_1,m_2)=1$ 可得\n\n$$\n(m_2x+m_1y,m_1)=(m_2x,m_1)=(x,m_1)=1,\n$$\n\n$$\n(m_2x+m_1y,m_2)=(m_1y,m_2)=(x,m_2)=1,\n$$\n\n因此可得 $(m_2x+m_1y,m_1m_2)=1$，即 $Z_m^*\\subseteq M$。\n\n综上所述，\n\n$$\nZ_m^*=m_2Z_{m_1}^*+m_1Z_{m_2}^*.\n$$\n\n为模 $m$ 的 **既约** 剩余系。\n```\n\n----------------------------------------\n\nTITLE: Example of Subrings in the Integer Ring\nDESCRIPTION: An example showing that for any integer n, the set nZ of multiples of n forms a subring of the integer ring Z.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n???+ example \" 例子：整数环 $\\mathbf Z$\"\n    对于任何整数 $n$，都有 $n\\mathbf Z=\\{nk:k\\in\\mathbf Z\\}$ 是 $\\mathbf Z$ 的一个子环。\n```\n\n----------------------------------------\n\nTITLE: Frobenius Homomorphism Application for Polynomials in Fields of Characteristic p\nDESCRIPTION: Mathematical demonstration of how the Frobenius homomorphism applies to polynomials in fields of characteristic p, showing why certain polynomials can be expressed as p-th powers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_9\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{aligned}\nf(x)&=a_0+a_px^p+a_{2p}x^{2p}+\\cdots+a_{(k-1)p}x^{(k-1)p}+a_{kp}x^{kp}\\\\\n&=b_0^p+b_1^px^p+b_2^px^{2p}+\\cdots+b_{k-1}^px^{(k-1)p}+b_k^px^{kp}\\\\\n&=\\left(b_0+b_1x+b_2x+\\cdots+b_{k-1}x^{k-1}+b_kx^k\\right)^p.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Assembly Output of SCEV-Optimized Loop\nDESCRIPTION: Shows the assembly code generated after SCEV optimization has transformed the loop calculation into a direct formula. The loop has been eliminated and replaced with mathematical operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_2\n\nLANGUAGE: nasm\nCODE:\n```\ntest(int):                               # @test(int)\n        test    edi, edi\n        jle     .LBB0_1\n        lea     eax, [rdi - 1]\n        lea     ecx, [rdi - 2]\n        imul    rcx, rax\n        lea     eax, [rdi - 3]\n        imul    rax, rcx\n        shr     rax\n        imul    eax, eax, 1431655766\n        and     ecx, -2\n        lea     eax, [rax + 2*rcx]\n        lea     eax, [rax + 2*rdi]\n        dec     eax\n        ret\n.LBB0_1:\n        mov     eax, 1\n        ret\n```\n\n----------------------------------------\n\nTITLE: Defining Minimal Polynomial for Algebraic Element in Field Extension\nDESCRIPTION: Defines the minimal polynomial f(x) of degree n for an algebraic element α in a field extension E/F.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\nf(x)=x^n+a_{n-1}x^{n-1}+\\cdots+a_1x+a_0,\n```\n\n----------------------------------------\n\nTITLE: Printing and Reading Strings in C\nDESCRIPTION: Basic input/output operations for strings in C using printf and scanf functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/lib-func.md#2025-04-22_snippet_0\n\nLANGUAGE: C\nCODE:\n```\nprintf(\"%s\", s);\nscanf(\"%s\", &s);\n```\n\n----------------------------------------\n\nTITLE: Applying Weighted Pólya Enumeration to Diamond Necklace Problem\nDESCRIPTION: Calculation of the generating function for different ways to place diamonds on a four-bead necklace, taking into account rotational symmetry.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nF(x)&=\\frac14\\left(f(x)^4+f(x^2)^2+2f(x^4)\\right)\\\\\n&=1+x+3x^2+5x^3+10x^4+\\cdots.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Blossom Addition in General Weighted Matching Algorithm (C++)\nDESCRIPTION: Implements the process of adding a new blossom (odd cycle) to the graph in the general weighted matching algorithm. This function handles the contraction of an odd cycle into a single node, updating all relevant data structures.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-weight-match.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nvoid add_blossom(int u, int lca, int v) {\n  // 将u,v,lca这朵花缩成一个点 b\n  // 交错树上u,v的lca即为花托\n  int b = n + 1;\n  while (b <= n_x && st[b]) ++b;\n  if (b > n_x) ++n_x;\n  // 找出目前未使用的花的编号\n  lab[b] = 0;             // 设置zB=0\n  S[b] = 0;               // 整朵花为一个偶点\n  match[b] = match[lca];  // 设置花的匹配边为花托的匹配边\n  flower[b].clear();\n  flower[b].push_back(lca);\n  for (int x = u, y; x != lca; x = st[pa[y]]) {\n    flower[b].push_back(x);\n    y = st[match[x]];\n    flower[b].push_back(y);\n    q_push(y);\n  }\n  reverse(flower[b].begin() + 1, flower[b].end());\n  for (int x = v, y; x != lca; x = st[pa[y]]) {\n    flower[b].push_back(x);\n    y = st[match[x]];\n    flower[b].push_back(y);\n    q_push(y);\n  }\n  // b中所有点以环形的方式加入flower[b]，并设花托为首个元素\n  set_st(b, b);  // 把整朵花里所有的元素其所在的花设为b\n  for (int x = 1; x <= n_x; ++x) {\n    g[b][x].w = 0;\n    g[x][b].w = 0;\n  }\n  for (int x = 1; x <= n; ++x) {\n    flower_from[b][x] = 0;\n  }\n  for (size_t i = 0; i < flower[b].size(); ++i) {\n    int xs = flower[b][i];\n    for (int x = 1; x <= n_x; ++x) {\n      // 设置b和x相邻的边为b里面和x相邻的边e_delta最小的那条\n      if (g[b][x].w == 0 || e_delta(g[xs][x]) < e_delta(g[b][x])) {\n        g[b][x] = g[xs][x];\n        g[x][b] = g[x][xs];\n      }\n    }\n    for (int x = 1; x <= n; ++x) {\n      if (flower_from[xs][x]) {\n        // 如果b里面的点xs有包含x\n        // 那flower_from[b][x]就会是xs\n        flower_from[b][x] = xs;\n      }\n    }\n  }\n  set_slack(b);\n  // 最后必须要设置b的slack值\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Time Complexity for Nested Loops in C++\nDESCRIPTION: Demonstrates a triple nested loop structure with time complexity O(n^2 * m), where n and m are input values determining the number of iterations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nint n, m;\nstd::cin >> n >> m;\nfor (int i = 0; i < n; ++i) {\n  for (int j = 0; j < n; ++j) {\n    for (int k = 0; k < m; ++k) {\n      std::cout << \"hello world\\n\";\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Java Class Name Convention Example\nDESCRIPTION: Demonstrates the requirement for Java class names to match their file names for successful compilation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_9\n\nLANGUAGE: java\nCODE:\n```\nclass Add {\n    public static void main(String[] args) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Solving Tree Isomorphism (BJOI2015) using Multiset Hashing in C++\nDESCRIPTION: This implementation solves the BJOI2015 tree isomorphism problem by computing hash values for each node as root, then hashing the multiset of these values to compare trees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-hash.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/tree-hash/tree-hash_2.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Index Variable Strength Reduction Example in C++\nDESCRIPTION: Shows how a compiler can optimize expensive multiplication operations into cheaper addition operations within loops by recognizing index variable patterns. The compiler automatically transforms '3 * i' to 'a + 3' for better performance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint a = 0;\nfor (int i = 1; i < 10; i++) {\n  a = 3 * i;  // bad!\n  a = a + 3;  // good!\n}\n```\n\n----------------------------------------\n\nTITLE: Matrix Expression for Multiplying Attribute by Value (Python)\nDESCRIPTION: Demonstrates how to represent multiplying attribute B by a value v using matrix multiplication. This allows efficiently applying the operation to a range of elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix}\nA & B & C & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & v & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & 1\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\nA & B \\cdot v & C & 1\\\\\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Fast I/O Using Memory Mapping (mmap) in C++\nDESCRIPTION: A demonstration of using the mmap system call for extremely fast input operations by mapping a file directly into memory. This technique is particularly useful for large files on Linux systems.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/io.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <bits/stdc++.h>\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\nchar *pc;\n\nint rd() {\n  int x = 0, f = 1;\n  char c = *pc++;\n  while (!isdigit(c)) {\n    if (c == '-') f = -1;\n    c = *pc++;\n  }\n  while (isdigit(c)) x = x * 10 + (c ^ 48), c = *pc++;\n  return x * f;\n}\n\nint main() {\n  int fd = open(\"*.in\", O_RDONLY);\n  struct stat state;\n  fstat(fd, &state);\n  pc = (char *)mmap(NULL, state.st_size, PROT_READ, MAP_PRIVATE, fd, 0);\n  close(fd);\n  printf(\"%d\", rd());\n}\n```\n\n----------------------------------------\n\nTITLE: Traversing All Submasks of Every Possible Mask in C++\nDESCRIPTION: Nested loops to iterate through every possible mask of n bits and all of its submasks. This approach is commonly used in state compression dynamic programming with O(3^n) time complexity.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nfor (int m = 0; m < (1 << n); ++m)\n  // 降序遍历 m 的非空子集\n  for (int s = m; s; s = (s - 1) & m)\n// s 是 m 的一个非空子集\n```\n\n----------------------------------------\n\nTITLE: Implementing Insert Operation in ETT\nDESCRIPTION: Operation to add an edge between two vertices by splitting and merging sequences. Handles creation of new edge nodes and sequence manipulation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/ett.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid Insert(int u, int v) {\n  Node* vertex_u = vertices_[u];\n  Node* vertex_v = vertices_[v];\n\n  Node* edge_uv = AllocateNode(u, v);\n  Node* edge_vu = AllocateNode(v, u);\n  tree_edges_[u][v] = edge_uv;\n  tree_edges_[v][u] = edge_vu;\n\n  auto [L11, L12] = Treap::SplitUp2(vertex_u);\n  auto [L21, L22] = Treap::SplitUp2(vertex_v);\n\n  Node* L = L12;\n  L = Treap::Merge(L, L11);\n  L = Treap::Merge(L, edge_uv);\n  L = Treap::Merge(L, L22);\n  L = Treap::Merge(L, L21);\n  L = Treap::Merge(L, edge_vu);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Bernoulli Numbers and Combinatorics in C++\nDESCRIPTION: This C++ code snippet implements the calculation of Bernoulli numbers, combinatorial numbers, and modular inverses. It uses dynamic programming to precompute these values for efficient lookup.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/bernoulli.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nusing ll = long long;\nconstexpr int MAXN = 10000;\nconstexpr int mod = 1e9 + 7;\nll B[MAXN];        // 伯努利数\nll C[MAXN][MAXN];  // 组合数\nll inv[MAXN];      // 逆元（计算伯努利数）\n\nvoid init() {\n  // 预处理组合数\n  for (int i = 0; i < MAXN; i++) {\n    C[i][0] = C[i][i] = 1;\n    for (int k = 1; k < i; k++) {\n      C[i][k] = (C[i - 1][k] % mod + C[i - 1][k - 1] % mod) % mod;\n    }\n  }\n  // 预处理逆元\n  inv[1] = 1;\n  for (int i = 2; i < MAXN; i++) {\n    inv[i] = (mod - mod / i) * inv[mod % i] % mod;\n  }\n  // 预处理伯努利数\n  B[0] = 1;\n  for (int i = 1; i < MAXN; i++) {\n    ll ans = 0;\n    if (i == MAXN - 1) break;\n    for (int k = 0; k < i; k++) {\n      ans += C[i + 1][k] * B[k];\n      ans %= mod;\n    }\n    ans = (ans * (-inv[i + 1]) % mod + mod) % mod;\n    B[i] = ans;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Bitset Implementation\nDESCRIPTION: Manual implementation of a bitset class optimized for 64-bit operations\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/bitset.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconstexpr int N = 101;\nconstexpr int W = 64;\n\nstruct Bitset {\n  unsigned long long a[N * N * N >> 6];\n\n  void shiftor(const Bitset &y, int p, int l, int r) {\n    int t = p - p / W * W;\n    int tt = (t == 0 ? 0 : W - t);\n    int to = (r + p) / W;\n    int qaq = (p + W - 1) / W;\n\n    for (int i = (l + p) / W; i <= to; ++i) {\n      if (i - qaq >= 0) a[i] |= y.a[i - qaq] >> tt;\n\n      a[i] |= ((y.a[i - qaq + 1] & ((1ull << tt) - 1)) << t);\n    }\n  }\n} f[N];\n```\n\n----------------------------------------\n\nTITLE: Using Constants in C++\nDESCRIPTION: Demonstrates how to define and use constants in C++ using the const keyword. Attempting to modify a constant value will result in a compilation error.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nconst int a = 2;\na = 3;\n```\n\n----------------------------------------\n\nTITLE: Burnside's Lemma Proof in TeX\nDESCRIPTION: A proof of Burnside's lemma which relates the number of orbits in a group action to the average number of fixed points of group elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_7\n\nLANGUAGE: tex\nCODE:\n```\n这一定理的证明十分简明。注意到，轨道个数可以写作\n\n$$\n|X/G|=\\sum_{o\\in X/G}1=\\sum_{x\\in X}\\frac{1}{|Gx|}=\\frac1{|G|}\\sum_{x\\in X}|G_x|.\n$$\n\n最后一个等号就是上面的推论；而右式和所要求证的只差一个 Fubini 定理，因为它们中的求和式都是对集合 $\\{(g,x)\\in G\\times X:gx=x\\}$ 的计数，只不过右式先对 $g$ 求和，而所求证的式子先对 $x$ 求和。\n```\n\n----------------------------------------\n\nTITLE: Direct Sum Decomposition of Vector Space\nDESCRIPTION: Formula showing how a vector space decomposes into a direct sum of subspaces based on the minimal polynomial of a linear transformation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nV=V_1\\oplus V_2\\oplus\\cdots\\oplus V_k\n```\n\n----------------------------------------\n\nTITLE: Third Dimension Query Operation in Tree-on-Tree\nDESCRIPTION: Implements a range query operation for the third dimension of the tree structure. Returns aggregated data within the specified range using a segment tree approach.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg-in-seg.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint vec_query(int k, int l, int r, int x, int y) {\n  if (k == 0) return 0;\n  if (x <= l && r <= y) return data[k];\n  int mid = l + r >> 1, res = 0;\n  if (x <= mid) res += vec_query(ch[k][0], l, mid, x, y);\n  if (y > mid) res += vec_query(ch[k][1], mid + 1, r, x, y);\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Time Complexity Proof for Median of Medians Algorithm\nDESCRIPTION: Mathematical proof demonstrating that the Median of Medians algorithm has O(n) time complexity even in worst-case scenarios, using recurrence relations and substitution method.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/quick-sort.md#2025-04-22_snippet_1\n\nLANGUAGE: tex\nCODE:\n```\nT(n) \\leq T(\\dfrac{n}{5}) + T(\\dfrac{7n}{10}) + O(n)\n```\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{aligned}\nT(n) & \\leq T(\\dfrac{n}{5}) + T(\\dfrac{7n}{10}) + O(n)\\\\\n     & \\leq \\dfrac{cn}{5} + \\dfrac{7cn}{10} + O(n)\\\\\n     & \\leq \\dfrac{9cn}{10} + O(n)\\\\\n     & = O(n)\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Theorem on Quotient Rings and Prime Ideals\nDESCRIPTION: A theorem establishing that a quotient ring of a commutative ring with unity is an integral domain if and only if the ideal is prime.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_15\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"定理\"\n    设交换非零幺环 $R$ 有理想 $P$，那么商环 $R/P$ 是整环，当且仅当 $P$ 是素理想。\n```\n\n----------------------------------------\n\nTITLE: Basic if Statement in C++\nDESCRIPTION: Demonstrates the syntax of a basic if statement in C++. The statement executes the body if the condition evaluates to true (non-zero).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nif (条件) {\n  主体;\n}\n```\n\n----------------------------------------\n\nTITLE: 一条回路覆盖问题状态转移 (C++)\nDESCRIPTION: 一条回路覆盖问题的状态转移代码实现。处理左插头和上插头的不同情况，包括插头的合并、延伸和生成，以确保最终形成一条封闭回路覆盖整个棋盘。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nREP(ii, H0->sz) {\n  decode(H0->state[ii]);                  // 取出状态，并解码\n  d = H0->key[ii];                        // 得到增量 delta\n  int lt = b[j], up = b[j + 1];           // 左插头，上插头\n  bool dn = i != n - 1, rt = j != m - 1;  // 下插头，右插头\n  if (lt && up) {                         // 如果左、上均有插头\n    if (lt == up) {                       // 来自同一个连通块\n      if (i == n - 1 &&\n          j == m - 1) {  // 只有在最后一个格子时，才能合并，封闭回路。\n        push(j, 0, 0);\n      }\n    } else {  // 否则，必须合并这两个连通块，因为本题中需要回路覆盖\n      REP(i, m + 1) if (b[i] == lt) b[i] = up;\n      push(j, 0, 0);\n    }\n  } else if (lt || up) {  // 如果左、上之中有一个插头\n    int t = lt | up;      // 得到这个插头\n    if (dn) {             // 如果可以向下延伸\n      push(j, t, 0);\n    }\n    if (rt) {  // 如果可以向右延伸\n      push(j, 0, t);\n    }\n  } else {           // 如果左、上均没有插头\n    if (dn && rt) {  // 生成一对新插头\n      push(j, m, m);\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SPJ for Cena OJ\nDESCRIPTION: Special Judge implementation for Cena Online Judge platform. Handles specific file naming conventions and scoring requirements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/special-judge.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <cstdio>\n\nint main(int argc, char* argv[]) {\n  FILE* fin = fopen(\"num.in\", \"r\");\n  FILE* fout = fopen(\"num.out\", \"r\");\n  FILE* fstd = fopen(argv[2], \"r\");\n  FILE* fscore = fopen(\"score.log\", \"w\");\n  FILE* freport = fopen(\"report.log\", \"w\");\n\n  double pans, jans;\n  fscanf(fout, \"%lf\", &pans);\n  fscanf(fstd, \"%lf\", &jans);\n\n  if (abs(pans - jans) < 1e-3) {\n    fprintf(fscore, \"%s\", argv[1]);\n    fprintf(freport, \"Good job\\n\");\n  } else {\n    fprintf(fscore, \"%d\", 0);\n    fprintf(freport, \"Too big or too small, expected %f, found %f\\n\", jans, pans);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Set Theory Definition of Covers and Partitions\nDESCRIPTION: Mathematical notation defining covers and partitions in the context of set theory, used to express a more general form of the pigeonhole principle. It explains the relationship between sets and their elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/drawer-principle.md#2025-04-22_snippet_2\n\nLANGUAGE: math\nCODE:\n```\n\\bigcup_{i=1}^k A_i\n```\n\nLANGUAGE: math\nCODE:\n```\ni\\neq j\\to A_i\\cap A_j=\\varnothing\n```\n\nLANGUAGE: math\nCODE:\n```\n\\left\\vert A_i \\right\\vert \\geq \\left\\lceil \\dfrac{\\left\\vert S \\right\\vert}{k} \\right\\rceil\n```\n\n----------------------------------------\n\nTITLE: Defining the Minimal Polynomial in Jordan Decomposition\nDESCRIPTION: Mathematical expression of the minimal polynomial of a linear transformation, which is a key component in understanding the Jordan decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nm_A(\\lambda)={(\\lambda-\\lambda_1)}^{r_1}{(\\lambda-\\lambda_2)}^{r_2}\\cdots{(\\lambda-\\lambda_k)}^{r_k}\n```\n\n----------------------------------------\n\nTITLE: Monic Polynomial Congruence Equation\nDESCRIPTION: Congruence equation for a monic polynomial of degree n modulo p, along with the condition for having exactly n solutions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_3\n\nLANGUAGE: math\nCODE:\n```\nx^n+\\sum_{i=0}^{n-1}a_ix^i\\equiv 0\\pmod p\\tag{7}\n```\n\nLANGUAGE: math\nCODE:\n```\nx^p-x=f(x)q(x)+pr(x)\\tag{8}\n```\n\n----------------------------------------\n\nTITLE: Addition and Multiplication Rules in F2(α)\nDESCRIPTION: Defines addition and multiplication rules for elements in the field extension F2(α) where α is a root of x^2+x+1=0.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_7\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n(a+b\\alpha)+(c+d\\alpha)&=(a+c)+(b+d)\\alpha,\\\\\n(a+b\\alpha)(c+d\\alpha)&=ac+(ad+bc)\\alpha+bd\\alpha^2\\\\\n&=(ac+bd)+(ad+bc+bd)\\alpha.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Orbit-Transversal-Stabilizer Algorithm (Pseudocode)\nDESCRIPTION: Algorithm for computing the orbit, transversal, and stabilizer generator set of a group action on a point. This is a key component of the Schreier-Sims algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_2\n\nLANGUAGE: pseudocode\nCODE:\n```\n\\begin{array}{l}\n\\textbf{Algorithm }\\textrm{OrbitTransversalStabilizer}(S,\\beta):\\\\\n\\textbf{Input. }\\textrm{A generating set }S\\textrm{ for a group }G\\textrm{ and a point }\\beta.\\\\\n\\textbf{Output. }\\textrm{The orbit }\\Delta=\\beta^G\\textrm{, the transversal }T\\textrm{, and a}\\\\\n\\qquad\\textrm{ generating set }S'\\textrm{ for the stabilizer }G_\\beta.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1  & \\Delta \\leftarrow [\\beta]\\\\\n2  & T[\\beta] \\leftarrow e\\\\\n3  & S' \\leftarrow [e]\\\\\n4  & \\textbf{for }\\delta\\in\\Delta\\\\\n5  & \\qquad \\textbf{for }s\\in S\\\\\n6  & \\qquad \\qquad \\gamma \\leftarrow \\delta^s\\\\\n7  & \\qquad \\qquad \\textbf{if }\\gamma\\notin\\Delta\\textbf{ then}\\\\\n8  & \\qquad \\qquad \\qquad\\textrm{append }\\gamma\\textrm{ to }\\Delta\\\\\n9  & \\qquad \\qquad \\qquad T[\\gamma] \\leftarrow T[\\delta]\\cdot s\\\\\n10 & \\qquad \\qquad \\textbf{else} \\\\\n11 & \\qquad \\qquad \\qquad \\textrm{append }T[\\delta]\\cdot s\\cdot T[\\gamma]^{-1}\\textrm{ to }S'\\\\\n12 & \\qquad \\qquad \\textbf{end if}\\\\\n13 & \\qquad \\textbf{end for}\\\\\n14 & \\textbf{end for}\\\\\n15 & \\textbf{return }\\Delta, T, S'\n\\end{array}\n\\end{array}\n```\n\n----------------------------------------\n\nTITLE: Alternative Notation for Elementary Matrices in LaTeX\nDESCRIPTION: A simplified notation for representing elementary matrices using the identity matrix and unit matrices E_ij, which have a 1 in position (i,j) and 0s elsewhere.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_5\n\nLANGUAGE: tex\nCODE:\n```\nD_i(k)=I_n+(k-1)E_{ii}\n```\n\nLANGUAGE: tex\nCODE:\n```\nP_{ij}=I_n-E_{ii}-E_{jj}+E_{ij}+E_{ji}\n```\n\nLANGUAGE: tex\nCODE:\n```\nT_{ij}(k)=I_n+kE_{ij}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Comparison Operators in C++\nDESCRIPTION: Illustrates the use of various comparison operators in conditional statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_15\n\nLANGUAGE: C++\nCODE:\n```\nif (i < 42) ...\nif (i <= 42) ...\nif (i > 42) ...\nif (i >= 42) ...\nif (i == 42) ...\nif (i != 42) ...\n```\n\n----------------------------------------\n\nTITLE: Replacing Substrings in C++ String\nDESCRIPTION: Shows how to use replace() function to substitute portions of a std::string with other strings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nstring s = \"OI Wiki\";\ns.replace(2, 5, \"\");\nprintf(\"将字符串 s 的第 3~7 位替换为空串后得到的字符串是 %s\\n\", s.c_str());\ns.replace(s.begin(), s.begin() + 2, \"NOI\");\nprintf(\"将字符串 s 的前两位替换为 NOI 后得到的字符串是 %s\", s.c_str());\n```\n\n----------------------------------------\n\nTITLE: Traversing Non-Empty Subsets using While Loop in C++\nDESCRIPTION: Code snippet that iterates through all non-empty subsets of a binary mask in descending order. It uses the property that (s-1)&m gives the next smaller subset of m.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\n// 降序遍历 m 的非空子集\nint s = m;\nwhile (s > 0) {\n  // s 是 m 的一个非空子集\n  s = (s - 1) & m;\n}\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Comparison Issues in Java\nDESCRIPTION: Demonstrates the issue with comparing -0.0 and 0.0 in Java. For primitive types they are equal, but for object types (Double) they are not equal. Shows a solution by adding 0.0 to normalize negative zero values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_28\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static void A() {\n        Double a = 0.0;\n        Double b = -0.0;\n        out.println(a.equals(b));  // false \n    }\n\n    static void B() {\n        Double a = 0.0;\n        Double b = -0.0 + 0.0;\n        out.println(a.equals(b));  // true \n    }\n\n    static void C() {\n        double a = 0.0;\n        double b = -0.0;\n        out.println(a == b);  // true \n    }\n\n\n    public static void main(String[] args) {\n        A();\n        B();\n        C();\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Python Control Structures and Operators\nDESCRIPTION: This code snippet shows Python's if-else structure, logical operators, bitwise operators, and the ternary operator. It demonstrates how Python allows chained comparisons and doesn't use parentheses around conditions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n# 条件表达式两侧无括号\nif 4 >= 3 > 2 and 3 != 5 == 5 != 7:\n    print(\"关系运算符可以连续使用\")\n    x = None or [] or -2\n    print(\"&&  ||  !\", \"与  或  非\", \"and or not\", sep=\"\\n\")\n    print(\"善用 and/or 可节省行数\")\n    if not x:\n        print(\"负数也是 True，不执行本句\")\n    elif x & 1:\n        print(\"用 elif 而不是 else if\\n\" \"位运算符与 C 相近，偶数&1 得 0，不执行本句\")\n    else:\n        print(\"也有三目运算符\") if x else print(\"注意结构\")\n```\n\n----------------------------------------\n\nTITLE: Initializing BigInteger Objects in Java\nDESCRIPTION: Demonstrating two common ways to initialize BigInteger objects in Java: from a decimal string and from a string with a specified radix. BigInteger is used for high-precision arithmetic operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\nclass Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    public static void main(String[] args) {\n        BigInteger a = new BigInteger(\"12345678910\");  // 将字符串以十进制的形式创建 BigInteger 对象\n        out.println(a);  // a 的值为 12345678910 \n        BigInteger b = new BigInteger(\"1E\", 16);  // 将字符串以指定进制的形式创建 BigInteger 对象\n        out.println(b);  // b 的值为 30 \n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: SAM Global Variables Declaration\nDESCRIPTION: Global variable declarations for SAM implementation including state array, size counter and last state tracker.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/sam.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int MAXLEN = 100000;\nstate st[MAXLEN * 2];\nint sz, last;\n```\n\n----------------------------------------\n\nTITLE: Including Queue Header in C++\nDESCRIPTION: Header file inclusion for using STL queue container.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <queue>\n```\n\n----------------------------------------\n\nTITLE: Using Arrays.binarySearch() Method in Java\nDESCRIPTION: Shows how to use Arrays.binarySearch() method to perform binary search on sorted arrays. Includes examples of searching in the entire array and within specific ranges.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_24\n\nLANGUAGE: java\nCODE:\n```\nimport java.util.Arrays;\n\npublic class Main {\n    static int[] a = new int[10];\n    static Integer[] b = new Integer[10];\n    static int firstIdx, lastIdx;\n    static int key;\n\n    public static void main(String[] args) {\n        Arrays.binarySearch(a, key);  // 1 \n        Arrays.binarySearch(a, firstIdx, lastIdx, key);  // 2 \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Queue Traversal Example in Java\nDESCRIPTION: Shows how to traverse Queue implementations with complexity analysis for LinkedList and PriorityQueue.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_11\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static Queue<Integer> q1 = new LinkedList<>();\n    static Queue<Integer> q2 = new PriorityQueue<>();\n\n    static void test() {\n        while (!q1.isEmpty()) {  // 复杂度为 O(n) \n            out.println(q1.poll());\n        }\n        while (!q2.isEmpty()) {  // 复杂度为 O(nlogn) \n            out.println(q2.poll());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Including and Declaring GNU PBDS Priority Queue in C++\nDESCRIPTION: Shows how to include the required header and declare a priority queue using the GNU PBDS library. This snippet demonstrates the basic template parameters and initialization of an iterator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/pq.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <ext/pb_ds/priority_queue.hpp>\nusing namespace __gnu_pbds;\n__gnu_pbds::priority_queue<T, Compare, Tag, Allocator>\n```\n\n----------------------------------------\n\nTITLE: Solving GCD Counting Problem using Möbius Inversion in C++\nDESCRIPTION: Implementation for the HAOI 2011 Problem b, which calculates the count of integer pairs with specific GCD using Möbius inversion and number-theoretic division block technique.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/math/code/mobius/mobius_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Bitset Size Specification\nDESCRIPTION: Example showing how to declare a bitset with specified size\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/bitset.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::bitset<1000> bs;  // a bitset with 1000 bits\n```\n\n----------------------------------------\n\nTITLE: Polynomial Class Implementation in C++\nDESCRIPTION: A robust polynomial class implementation providing arithmetic operations, inverse, logarithm, exponential, and other polynomial manipulations. The class uses modular arithmetic and includes Fast Fourier Transform (FFT) for efficient multiplication.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#ifndef _FEISTDLIB_POLY_\n#define _FEISTDLIB_POLY_\n\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n\nnamespace fstdlib {\n\nusing ll = long long;\nint mod = 998244353, grt = 3;\n\nclass poly {\n private:\n  std::vector<int> data;\n\n  void out(void) {\n    for (int i = 0; i < (int)data.size(); ++i) printf(\"%d \", data[i]);\n    puts(\"\");\n  }\n\n public:\n  poly(std::size_t len = std::size_t(0)) { data = std::vector<int>(len); }\n\n  poly(const std::vector<int> &b) { data = b; }\n\n  poly(const poly &b) { data = b.data; }\n\n  void resize(std::size_t len, int val = 0) { data.resize(len, val); }\n\n  std::size_t size(void) const { return data.size(); }\n\n  void clear(void) { data.clear(); }\n#if __cplusplus >= 201103L\n  void shrink_to_fit(void) { data.shrink_to_fit(); }\n#endif\n  int &operator[](std::size_t b) { return data[b]; }\n\n  const int &operator[](std::size_t b) const { return data[b]; }\n\n  // ... [Additional operator implementations omitted for brevity]\n};\n\n// ... [Additional helper functions and implementations omitted for brevity]\n\n} // namespace fstdlib\n```\n\n----------------------------------------\n\nTITLE: Link and Cut Operations\nDESCRIPTION: Functions to connect and disconnect nodes in the tree structure.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nvoid Link(int x, int y, int z) {\n  access(x);\n  makeroot(y);\n  setfather(y, x, 1);\n  setfather(z, y, 0);\n  pushup(x, 0);\n  pushup(y, 0);\n}\n\nvoid cut(int x, int y) {\n  expose(x, y);\n  clear(rs(x));\n  father[x] = ls(y) = rs(x);\n  pushup(y, 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using ensuref() with C-style Formatting for Dynamic Error Messages in C++\nDESCRIPTION: This snippet demonstrates using ensuref() with C-style placeholder formatting to create dynamic error messages. The example checks if a string has even length and includes the actual length in the error message.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/testlib/general.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nensuref(s.length() % 2 == 0,\n        \"String 's' should have even length, but s.length()=%d\",\n        int(s.length()));\n```\n\n----------------------------------------\n\nTITLE: Using Comments in Python\nDESCRIPTION: Demonstrates single and multi-line commenting syntax in Python. Comments do not affect code execution but help make code more readable and understandable.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# 用 # 字符开头的是单行注释\n\n\"\"\"\n跨多行字符串会用三引号\n（即三个单引号或三个双引号）\n包裹，但也通常被用于注释\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: First Isomorphism Theorem for Rings\nDESCRIPTION: The statement of the first isomorphism theorem for rings, establishing the relationship between a ring homomorphism's kernel, image, and the quotient ring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"第一同构定理\"\n    设 $\\pi:R\\rightarrow S$ 是自环 $R$ 到环 $S$ 的同态，则 $\\ker\\pi$ 是 $R$ 的理想，且 $R/\\ker\\pi\\cong\\pi(R)$ 是 $S$ 的子环。\n```\n\n----------------------------------------\n\nTITLE: State Transition for Grid Coloring Problem in C++\nDESCRIPTION: Implements state transition logic for a grid coloring problem. Handles merging, inheriting, and generating new color regions. Includes checks for 2x2 same-color sub-rectangles and closed color regions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nvoid trans(int i, int j, int u, int cc) {\n  decode(H0->state[u]);\n  int lf = j ? c[j - 1] : -1, lu = b[j] ? c[j] : -1,\n      up = b[j + 1] ? c[j + 1] : -1;  // 没有颜色也是颜色的一种！\n  if (lf == cc && up == cc) {         // 合并\n    if (lu == cc) return;             // 2x2 子矩形相同的情况\n    int lf_b = b[j - 1], up_b = b[j + 1];\n    REP(i, m + 1) if (b[i] == up_b) { b[i] = lf_b; }\n    b[j] = lf_b;\n  } else if (lf == cc || up == cc) {  // 继承\n    if (lf == cc)\n      b[j] = b[j - 1];\n    else\n      b[j] = b[j + 1];\n  } else {                                             // 生成\n    if (i == n - 1 && j == m - 1 && lu == cc) return;  // 特判\n    b[j] = m + 2;\n  }\n  c[j] = cc;\n  if (!ok(i, j, cc)) return;  // 判断是否会因生成封闭的连通块导致不合法\n  H1->push(encode(), H0->key[u], u);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete freopen Template for File I/O in C/C++\nDESCRIPTION: A complete template showing how to use freopen for redirecting standard I/O to files. This includes opening files for input and output, using standard I/O functions, and properly closing the streams.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdio>\n#include <iostream>\n\nint main(void) {\n  freopen(\"data.in\", \"r\", stdin);\n  freopen(\"data.out\", \"w\", stdout);\n  /*\n  中间的代码不需要改变，直接使用 cin 和 cout 即可\n  */\n  fclose(stdin);\n  fclose(stdout);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Additional Case: When 4 Divides x-y\nDESCRIPTION: Special case of the Lifting the Exponent lemma stating that when 4 divides x-y, the power of 2 in x+y equals 1, and the power of 2 in x^n-y^n equals the power of 2 in x-y plus the power of 2 in n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_2(x+y)=1\n```\n\n----------------------------------------\n\nTITLE: Iterative Implementation of Euclidean Algorithm for GCD in Python\nDESCRIPTION: An iterative implementation of the Euclidean algorithm for finding the greatest common divisor in Python. This avoids recursion by using a while loop and Python's tuple unpacking for swapping values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/gcd.md#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n```\n\n----------------------------------------\n\nTITLE: Definition of Greatest Common Divisor in a Ring\nDESCRIPTION: The definition of the greatest common divisor of elements in a commutative ring, generalizing the GCD concept from number theory.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_21\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"最大公因子\"\n    对于交换环 $R$ 和它的元素 $a,b\\in R$，如果存在非零元素 $d\\in R$，它满足 $d\\mid a$ 和 $d\\mid b$，且对于任何满足 $d'\\mid a$ 和 $d'\\mid b$ 的 $d'$ 都成立 $d'\\mid d$，则称 $d$ 是 $a$ 和 $b$ 的 **最大公因子**（greatest common divisor），记作 $\\gcd(a,b)$。\n```\n\n----------------------------------------\n\nTITLE: Defining Stack Container in C++\nDESCRIPTION: Different ways to define and initialize an STL stack container with various data types and underlying containers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::stack<TypeName> s;  // 使用默认底层容器 deque，数据类型为 TypeName\nstd::stack<TypeName, Container> s;  // 使用 Container 作为底层容器\nstd::stack<TypeName> s2(s1);        // 将 s1 复制一份用于构造 s2\n```\n\n----------------------------------------\n\nTITLE: Calculating Distinct Cube Colorings with Burnside's Lemma\nDESCRIPTION: Uses Burnside's lemma to calculate the number of distinct ways to color a cube with 3 colors, considering rotational symmetries.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n$$\n\\frac{1\\times3^6+6\\times3^3+3\\times3^4+6\\times3^3+8\\times3^2}{1+6+3+6+8}=57.\n$$\n```\n\n----------------------------------------\n\nTITLE: Defining Blocked List Node Structure in C++\nDESCRIPTION: Defines a node structure for a blocked list, including a pointer to the next node, size, and a character array for data. Includes a constructor and a push_back method.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/block-list.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nstruct node {\n  node* nxt;\n  int size;\n  char d[(sqn << 1) + 5];\n\n  node() { size = 0, nxt = NULL, memset(d, 0, sizeof(d)); }\n\n  void pb(char c) { d[size++] = c; }\n};\n```\n\n----------------------------------------\n\nTITLE: Declaring a Function in C++\nDESCRIPTION: Shows the basic syntax for declaring a function in C++. This example declares a function named 'some_function' that takes two integer parameters and returns an integer value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// 返回值类型 int\n// 函数的名称 some_function\n// 参数列表 int, int\nint some_function(int, int);\n```\n\n----------------------------------------\n\nTITLE: Converting Digit Type to a List in Haskell\nDESCRIPTION: A type definition showing how Finger Tree digits can be represented as a list-like structure with one to four elements. This is used to store elements at each level of the Finger Tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/finger-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: haskell\nCODE:\n```\ntype Digit a = One a | Two a a | Three a a a | Four a a a a\n```\n\n----------------------------------------\n\nTITLE: 使用数论分块计算 H(n) 函数\nDESCRIPTION: 实现了计算 H(n) = ∑⌊n/i⌋ 函数的代码，通过数论分块的方法将时间复杂度降低到 O(√n)。代码处理多组测试数据，对于每组输入的整数 n，输出相应的 H(n) 值。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sqrt-decomposition.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cmath>\n#include <cstdio>\n\ntypedef long long ll;\n\nll H(ll x) {\n  ll ans = 0;\n  for (ll l = 1, r; l <= x; l = r + 1) {\n    r = x / (x / l);\n    ans += (r - l + 1) * (x / l);\n  }\n  return ans;\n}\n\nint main() {\n  int T;\n  ll n;\n  scanf(\"%d\", &T);\n  while (T--) {\n    scanf(\"%lld\", &n);\n    printf(\"%lld\\n\", H(n));\n  }\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Priority Queue Container in C++\nDESCRIPTION: Different ways to define and initialize an STL priority queue with custom comparators and containers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nstd::priority_queue<TypeName> q;             // 数据类型为 TypeName\nstd::priority_queue<TypeName, Container> q;  // 使用 Container 作为底层容器\nstd::priority_queue<TypeName, Container, Compare> q;\n\nauto cmp = [](const std::pair<int, int> &l, const std::pair<int, int> &r) {\n  return l.second < r.second;\n};\nstd::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>,\n                    decltype(cmp)>\n    pq(cmp);\n```\n\n----------------------------------------\n\nTITLE: Deque Double-ended Operations in Java\nDESCRIPTION: Demonstrates double-ended queue operations using ArrayDeque with addFirst/addLast methods.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_13\n\nLANGUAGE: java\nCODE:\n```\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Main {\n    static Deque<Integer> deque = new ArrayDeque<>();\n\n    static void insert() {\n        deque.addFirst(1);\n        deque.addFirst(2);\n        deque.addLast(3);\n        deque.addLast(4);\n    }\n\n    public static void main(String[] args) {\n        insert();\n        while (!deque.isEmpty()) { //输出 2 1 3 4\n            System.out.println(deque.poll());\n        }\n        insert();\n        while (!deque.isEmpty()) { //输出 4 3 1 2\n            System.out.println(deque.pollLast());\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: LibreOJ Problem Solution Using Bitset\nDESCRIPTION: Implementation of a dynamic programming solution optimized with bitset for handling square sums\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/bitset.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n#include <bitset>\n#include <cstdio>\n#include <iostream>\n\nusing namespace std;\n\nconstexpr int N = 101;\n\nint n, a[N], b[N];\nbitset<N * N * N> f[N];\n\nint main() {\n  int i, j;\n\n  cin >> n;\n\n  for (i = 1; i <= n; ++i) cin >> a[i] >> b[i];\n\n  f[0][0] = 1;\n\n  for (i = 1; i <= n; ++i) {\n    for (j = a[i]; j <= b[i]; ++j) {\n      f[i] |= (f[i - 1] << (j * j));\n    }\n  }\n\n  cout << f[n].count();\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Determinant Expansion by Column\nDESCRIPTION: Recursive definition of a determinant using expansion by a column, expressing it as the sum of products of column elements with their corresponding algebraic cofactors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\det A &= a_{1j}A_{1j}+a_{2j}A_{2j}+\\cdots+a_{nj}A_{nj} \\\\\n&= \\sum_{i = 1}^{n} a_{ij}A_{ij} \\\\\n&= \\sum_{i = 1}^{n} (-1)^{i + j} a_{ij} \\det M_{ij}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Common STL Container Functions in C++\nDESCRIPTION: Lists common functions available across most STL containers, including iterators, size operations, and comparison operators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n=  // Assignment operator and copy constructor\nbegin()  // Returns iterator to the first element\nend()  // Returns iterator to the element following the last element\nsize()  // Returns the number of elements\nmax_size()  // Returns the maximum theoretical number of elements\nempty()  // Checks if the container is empty\nswap()  // Swaps the contents of two containers\nclear()  // Removes all elements from the container\n==, !=, <, >, <=, >=  // Comparison operators (lexicographical order)\n```\n\n----------------------------------------\n\nTITLE: Deque Stack Operations in Java\nDESCRIPTION: Implementation of stack operations using ArrayDeque with push and pop operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_12\n\nLANGUAGE: java\nCODE:\n```\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\npublic class Main {\n    static Deque<Integer> stack = new ArrayDeque<>();\n    static int[] a = {1, 2, 3, 4, 5};\n\n    public static void main(String[] args) {\n        for (int v : a) {\n            stack.push(v);\n        }\n        while (!stack.isEmpty()) { //输出 5 4 3 2 1\n            System.out.println(stack.pop()); \n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Modulo Operation for Powers of Two in Python\nDESCRIPTION: Python function that computes the remainder when dividing by a power of 2 using bitwise AND operations. This is more efficient than standard modulo operations for powers of 2.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/binary-set.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef modPowerOfTwo(x, mod):\n    return x & (mod - 1)\n```\n\n----------------------------------------\n\nTITLE: Definition of Divisibility in a Ring\nDESCRIPTION: The definition of divisibility for elements in a commutative ring, generalizing the divisibility relation in integers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_19\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"整除\"\n    设交换环 $R$ 有元素 $a,b\\in R$，如果存在 $x\\in R$，满足 $a=bx$，则称 $b$  **整除**（divide）$a$，记作 $b\\mid a$。此时称 $b$ 是 $a$ 的 **因子**（divisor）。\n```\n\n----------------------------------------\n\nTITLE: Infinite Loop Implementation in C++\nDESCRIPTION: Two equivalent ways to create infinite loops in C++ using while(1) and for(;;).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (1) {\n  // do something...\n}\n\nfor (;;) {\n  // do something...\n}\n```\n\n----------------------------------------\n\nTITLE: Building Farey Sequence in C++\nDESCRIPTION: Function to construct the nth order Farey sequence using a recursive approach. It generates fractions with denominators up to n and adds them to a vector in sorted order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/stern-brocot.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid farey(int n, vector<pair<int, int>>& res, int a = 0, int b = 1, int c = 1, int d = 1) {\n  if (b + d > n) return;\n  int x = (n + b) / d;\n  farey(n, res, a, b, x * c - a, x * d - b);\n  res.emplace_back(c, d);\n  farey(n, res, c, d, x * c - a, x * d - b);\n}\n```\n\n----------------------------------------\n\nTITLE: Determinant Expansion by Row\nDESCRIPTION: Recursive definition of a determinant using expansion by a row, expressing it as the sum of products of row elements with their corresponding algebraic cofactors.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\det A &= a_{i1}A_{i1}+a_{i2}A_{i2}+\\cdots+a_{in}A_{in} \\\\\n&= \\sum_{j = 1}^{n} a_{ij}A_{ij} \\\\\n&= \\sum_{j = 1}^{n} (-1)^{i + j} a_{ij} \\det M_{ij}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Wilson's Theorem Application Example\nDESCRIPTION: Example solution using Wilson's theorem to solve a problem involving factorial calculations modulo prime numbers\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/factorial.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/factorial/wilson_1.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Commutativity in Matrix Jordan Decomposition\nDESCRIPTION: Formula showing that the diagonalizable and nilpotent components of a matrix commute with each other.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\nDN=ND\n```\n\n----------------------------------------\n\nTITLE: Using Continue for Cleaner Nested Loops in C++\nDESCRIPTION: Comparison of nested loops with and without continue statements, showing how continue can make code more readable.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_10\n\nLANGUAGE: cpp\nCODE:\n```\n// 逻辑较为不清晰，大括号层次复杂\n\nfor (int i = 1; i <= n; ++i) {\n  if (i != x) {\n    for (int j = 1; j <= n; ++j) {\n      if (j != x) {\n        // do something...\n      }\n    }\n  }\n}\n\n// 逻辑更加清晰，大括号层次简单明了\n\nfor (int i = 1; i <= n; ++i) {\n  if (i == x) continue;\n  for (int j = 1; j <= n; ++j) {\n    if (j == x) continue;\n    // do something...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Pushing Local Changes to Remote Repository in Git\nDESCRIPTION: This command pushes local changes from a specified branch to a branch in a remote repository. It requires write access to the remote repository and that your local branch is up-to-date with the remote branch.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/git.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ git push <remote> <from>:<to> # 将本地 <from> 分支的更改推送至 <remote> 的 <to> 分支\n```\n\n----------------------------------------\n\nTITLE: Implementing Perform Operation for Chtholly Tree in C++\nDESCRIPTION: Implements the perform operation, which extracts a range of intervals from the Chtholly Tree and performs operations on them. It uses split to isolate the range and then iterates over the intervals.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/odt.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid perform(int l, int r) {\n  auto itr = split(r + 1), itl = split(l);\n  for (; itl != itr; ++itl) {\n    // Perform Operations here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Theorem on Prime Elements and Irreducible Elements\nDESCRIPTION: A theorem stating that in an integral domain, every prime element is also an irreducible element.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_24\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"定理\"\n    设 $R$ 是整环，如果 $a\\in R$ 是素元，那么 $a$ 也一定是不可约元。\n```\n\n----------------------------------------\n\nTITLE: Heuristic Merging in Disjoint Set Union (C++)\nDESCRIPTION: Demonstrates a heuristic optimization for merging sets in a disjoint set union data structure. The smaller set is merged into the larger set to maintain balance and improve performance.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/dsu-on-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvoid merge(int x, int y) {\n  int xx = find(x), yy = find(y);\n  if (size[xx] < size[yy]) swap(xx, yy);\n  fa[yy] = xx;\n  size[xx] += size[yy];\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing std::pair in C++\nDESCRIPTION: Different methods to initialize a std::pair object including direct initialization, member assignment, and make_pair function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\npair<int, double> p0(1, 2.0);\n```\n\nLANGUAGE: cpp\nCODE:\n```\npair<int, double> p1;\np1.first = 1;\np1.second = 2.0;\n```\n\nLANGUAGE: cpp\nCODE:\n```\npair<int, double> p2 = make_pair(1, 2.0);\n```\n\nLANGUAGE: cpp\nCODE:\n```\nauto p3 = make_pair(1, 2.0);\n```\n\n----------------------------------------\n\nTITLE: Definition of Ideals Generated by Subsets\nDESCRIPTION: The definition of an ideal generated by a subset of a ring, which is the smallest ideal containing the subset.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_17\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"由子集生成的理想\"\n    对于非零幺环 $R$ 和它的非空子集 $A\\subseteq R$，如果 $I$ 是包含 $A$ 的 $R$ 的理想中（依包含关系）最小的，则理想 $I$ 称为 **由子集 $A$ 生成的理想**（ideal generated by a subset），并记作 $(A)$。此时，$A$ 称为 $(A)$ 的 **生成子集**（generating set）。\n```\n\n----------------------------------------\n\nTITLE: Defining Union Operation for Undirected Simple Graphs in LaTeX\nDESCRIPTION: This snippet defines the union operation for two undirected simple graphs G and H, resulting in a new graph that contains all vertices and edges from both input graphs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\nG \\cup H = \\left( V_1 \\cup V_2, E_1 \\cup E_2 \\right)\n```\n\n----------------------------------------\n\nTITLE: Definition of Associates in a Ring\nDESCRIPTION: The definition of associate elements in a commutative ring, which are elements that differ by a unit (invertible element).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_20\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"相伴\"\n    设交换环 $R$ 有元素 $a,b\\in R$，如果它们只相差了一个可逆元，即存在可逆元 $u\\in R$，满足 $a=bu$，则称 $a$ 和 $b$ 是 **相伴的**（associate）。\n```\n\n----------------------------------------\n\nTITLE: Implementing A+B Problem in C++\nDESCRIPTION: A solution to the classic A+B problem in C++ demonstrating variable declaration, input/output operations, and basic arithmetic operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n\nint main() {\n  int a, b, c;\n\n  std::cin >> a >> b;\n\n  c = a + b;\n\n  std::cout << c << std::endl;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Polynomial Multiplication Formula\nDESCRIPTION: Defines the multiplication of two polynomials f(x) and g(x) to produce Q(x).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_1\n\nLANGUAGE: Mathematics\nCODE:\n```\nQ(x) = \\sum \\limits_ {i = 0} ^ n \\sum \\limits_ {j = 0 } ^ m a_i b_j x ^ {i + j} = c_0 + c_1 x + \\dots + c_ {n + m} x ^ {n + m}\n```\n\n----------------------------------------\n\nTITLE: Basic Variable Definition and Initialization in C++\nDESCRIPTION: Shows the syntax for defining variables in C++ with different data types, along with optional initialization. Demonstrates how to define integer, double, and character variables.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nint oi;\ndouble wiki;\nchar org = 'c';\n```\n\n----------------------------------------\n\nTITLE: Using Three-Way Comparison Operator in C++\nDESCRIPTION: Shows the usage of the three-way comparison operator (<=>).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_14\n\nLANGUAGE: C++\nCODE:\n```\nif ((i <=> 42) < 0) ...\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Time Complexity in C++\nDESCRIPTION: Shows a loop with a fixed number of iterations (N = 100000), which is considered O(1) time complexity if N is not treated as part of the input size.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nconstexpr int N = 100000;\nfor (int i = 0; i < N; ++i) {\n  std::cout << \"hello world\\n\";\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Dirichlet Convolution in LaTeX\nDESCRIPTION: LaTeX formula defining the Dirichlet convolution of two arithmetic functions f(x) and g(x).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/dgf.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n$$\nh(x)=\\sum_{d\\mid x}{f(d)g\\left(\\dfrac xd \\right)}=\\sum_{ab=x}{f(a)g(b)}\n$$\n```\n\n----------------------------------------\n\nTITLE: Declaring a C++ String\nDESCRIPTION: Shows how to declare a std::string object.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstd::string s;\n```\n\n----------------------------------------\n\nTITLE: 手写哈希表实现 (C++)\nDESCRIPTION: 为优化插头DP中稀疏状态的存储，实现的手写哈希表。包含初始化、状态转移和轮廓线滚动等功能，用于高效存储和查询DP状态及其对应的方案数。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/plug.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nconstexpr int MaxSZ = 16796, Prime = 9973;\n\nstruct hashTable {\n  int head[Prime], next[MaxSZ], sz;\n  int state[MaxSZ];\n  long long key[MaxSZ];\n\n  void clear() {\n    sz = 0;\n    memset(head, -1, sizeof(head));\n  }\n\n  void push(int s) {\n    int x = s % Prime;\n    for (int i = head[x]; ~i; i = next[i]) {\n      if (state[i] == s) {\n        key[i] += d;\n        return;\n      }\n    }\n    state[sz] = s, key[sz] = d;\n    next[sz] = head[x];\n    head[x] = sz++;\n  }\n\n  void roll() { REP(i, sz) state[i] <<= offset; }\n} H[2], *H0, *H1;\n```\n\n----------------------------------------\n\nTITLE: Const Pointers and References in C++\nDESCRIPTION: Shows different ways to use const with pointers and references, including const pointers to variables and pointers to const values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint a = 0;\nconst int b = 0;\n\nint *p1 = &a;\n*p1 = 1;\nconst int *p2 = &a;\n// *p2 = 2; // 不能通过常量指针修改变量\n// int *p3 = &b; // 不能用 int* 指向 const int 变量\nconst int *p4 = &b;\n\nint &r1 = a;\nr1 = 1;\nconst int &r2 = a;\n// r2 = 2; // 不能通过常量引用修改变量\n// int &p3 = b; // 不能用 int& 引用 const int变量\nconst int &r4 = b;\n```\n\n----------------------------------------\n\nTITLE: Input/Output Redirection Example\nDESCRIPTION: Demonstrates how to redirect program input and output using command line operators\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/cmd.md#2025-04-22_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n$ command < input > output\n```\n\n----------------------------------------\n\nTITLE: Mutable Lambda Expressions in C++\nDESCRIPTION: Illustrates the use of the mutable keyword in lambda expressions to allow modification of captured variables.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nint value = 520;\n\n{\n  auto f = [val = value]() mutable -> int {\n    return val = 1314;\n  };  // 需要 mutable\n  auto val_f = f();\n  std::cout << value << ' ' << val_f << std::endl;  // Output: 520 1314\n}\n\n{\n  auto f = [&val = value]() -> int { return val = 1314; };  // 不需要 mutable\n  auto val_f = f();\n  std::cout << value << ' ' << val_f << std::endl;  // Output: 1314 1314\n}\n```\n\n----------------------------------------\n\nTITLE: Prime Power Multiplicity in Factorials\nDESCRIPTION: Implementation of Legendre's formula to calculate the exponent of a prime p in n!\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/factorial.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/factorial/multiplicity.cpp:3:11\"\n```\n\n----------------------------------------\n\nTITLE: Using std::move for Value Transfer in C++\nDESCRIPTION: This snippet shows how to use std::move to transfer ownership of objects, avoiding unnecessary copies. It demonstrates moving strings between function calls and in container operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nstring world(string str) { return std::move(str) += \" world!\"; }\n\nint main() {\n  // 1\n  cout << world(\"hello\") << '\\n';\n\n  vector<string> vec0;\n\n  // 2\n  {\n    string&& size = to_string(vec0.size());\n\n    size += \", \" + to_string(size.size());\n\n    vec0.emplace_back(std::move(size));\n  }\n\n  cout << vec0.front();\n}\n```\n\n----------------------------------------\n\nTITLE: Definition of Prime Ideals in Ring Theory\nDESCRIPTION: The definition of a prime ideal, which is a proper ideal with the property that if a product of elements is in the ideal, at least one of the elements must be in the ideal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_14\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"素理想\"\n    对于交换环 $R$ 和它的理想 $P$，如果 $P\\neq R$，且对于环中任意元素 $a,b\\in R$，每当 $ab\\in P$ 成立时总有 $a\\in P$ 或 $b\\in P$，则称理想 $P$ 是一个 **素理想**（prime ideal）。\n```\n\n----------------------------------------\n\nTITLE: Lemon Test Data Directory Structure\nDESCRIPTION: Example directory structure showing how test data should be organized for Lemon, including input and output files in a product subdirectory.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/lemon.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n├── data\n│   ├── gendata.py\n│   ├── product\n│   │   ├── product100.in\n│   │   ├── product100.out\n│   │   ├── product10.in\n│   │   ├── product10.out\n│   │   ├── product11.in\n...\n```\n\n----------------------------------------\n\nTITLE: PQa Algorithm for Solving x^2 - 41y^2 = ±4\nDESCRIPTION: This snippet shows the application of the PQa algorithm to solve the Diophantine equation x^2 - 41y^2 = ±4. It demonstrates the step-by-step process and identifies the fundamental solutions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_6\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\n| k | P | Q | a            | A     | B     | G     | G^2-DB^2 |\n|:---:|:---:|:---:|:--------------:|:-------:|:-------:|:-------:|:----------:|\n| 0 | 1 | 2 | 3            | 3     | 1     | 5     | -16      |\n| 1 | 5 | 8 |\\color{red}{1}| 4     | 1     | 7     | 8        |\n| 2 | 3 | 4 |\\color{red}{2}| 11    | 3     | 19    | -8       |\n| 3 | 5 | 4 |\\color{red}{2}| 26    | 7     | 45    | 16       |\n| 4 | 3 | 8 |\\color{red}{1}| 37    | 10    | 64    | -4       |\n| 5 | 5 | 2 |\\color{red}{5}| 211   | 57    | 365   | 16       |\n| 6 | 5 | 8 | 1            | 248   | 67    | 429   | -8       |\n| 7 | 3 | 4 | 2            | 707   | 191   | 1223  | 8        |\n| 8 | 5 | 4 | 2            | 1662  | 449   | 2875  | -16      |\n| 9 | 3 | 8 | 1            | 2369  | 640   | 4098  | 4        |\n| 10| 5 | 2 | 5            | 13507 | 3649  | 23365 | -16      |\n| 11| 5 | 8 | 1            | 15876 | 4289  | 27463 | 8        |\n```\n\n----------------------------------------\n\nTITLE: Failed Recursive Lambda Implementation in C++\nDESCRIPTION: This example shows why directly capturing a lambda in its own definition fails due to a circular dependency in type inference. The compiler cannot determine the type of 'dfs' while it's being defined.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nint n = 10;\n\nauto dfs = [&](int i) -> void {\n  if (i == n)\n    return;\n  else\n    dfs(i + 1);  // Error: a variable declared with an auto type specifier\n                 // cannot appear in its own initializer\n};\n```\n\n----------------------------------------\n\nTITLE: Switch Statement without Break in C++\nDESCRIPTION: Demonstrates the behavior of a switch statement without break statements. Execution continues through subsequent cases after a match is found.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nchar i = 'B';\n\nswitch (i) {\n  case 'A':\n    cout << \"OI\" << endl;\n    break;\n\n  case 'B':\n    cout << \"WIKI\" << endl;\n\n  default:\n    cout << \"Hello World\" << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Set WSL Default Version\nDESCRIPTION: PowerShell command to set WSL 2 as the default version\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n# Set WSL default version to WSL 2\nwsl --set-default-version 2\n```\n\n----------------------------------------\n\nTITLE: Example of Dangling Range View in C++20\nDESCRIPTION: Demonstrates undefined behavior when using a view whose underlying range has been destroyed. This illustrates the importance of controlling object lifetimes when using range views.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <ranges>\n#include <vector>\n\nusing namespace std;\n\nint main() {\n  auto view = [] {\n    vector<int> vec{1, 2, 3, 4, 5};\n    return vec | std::views::filter([](int i) { return 0 == i % 2; });\n  }();\n\n  for (int i : view) cout << i << ' ';  // runtime undefined behavior\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Block Partitioning with Fenwick Tree Solution in C++\nDESCRIPTION: Solution using block partitioning combined with Fenwick Tree (Binary Indexed Tree) to solve the problem in O(n√n) time complexity. Handles MEX calculation by maintaining segment queries efficiently.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bit-in-block-array.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nconstexpr int N = 1e5 + 5;\nconstexpr int M = 316 + 5;  // sqrt(N) + 5\n\n// 分块\nint nn, b[N], block_size, block_cnt, block_id[N], L[N], R[N], T[M][N];\n\nvoid build(int n) {\n  nn = n;\n  block_size = sqrt(nn);\n  block_cnt = nn / block_size;\n  for (int i = 1; i <= block_cnt; ++i) {\n    L[i] = R[i - 1] + 1;\n    R[i] = i * block_size;\n  }\n  if (R[block_cnt] < nn) {\n    ++block_cnt;\n    L[block_cnt] = R[block_cnt - 1] + 1;\n    R[block_cnt] = nn;\n  }\n  for (int j = 1; j <= block_cnt; ++j)\n    for (int i = L[j]; i <= R[j]; ++i) block_id[i] = j;\n}\n\nint lb(int x) { return x & -x; }\n\n// d = 1: 加点(p, v)\n// d = -1: 删点(p, v)\nvoid add(int p, int v, int d) {\n  for (int i = block_id[p]; i <= block_cnt; i += lb(i))\n    for (int j = v; j <= nn; j += lb(j)) T[i][j] += d;\n}\n\n// 询问[1, r]内，纵坐标小于等于val的点有多少个\nint getsum(int p, int v) {\n  if (!p) return 0;\n  int res = 0;\n  int id = block_id[p];\n  for (int i = L[id]; i <= p; ++i)\n    if (b[i] && b[i] <= v) ++res;\n  for (int i = id - 1; i; i -= lb(i))\n    for (int j = v; j; j -= lb(j)) res += T[i][j];\n  return res;\n}\n\n// 询问[l, r]内，纵坐标小于等于val的点有多少个\nint query(int l, int r, int val) {\n  if (l > r) return -1;\n  int res = getsum(r, val) - getsum(l - 1, val);\n  return res;\n}\n\n// 加点(p, v)\nvoid update(int p, int v) {\n  b[p] = v;\n  add(p, v, 1);\n}\n\nint n, a[N];\nvector<int> g[N];\n\nint main() {\n  scanf(\"%d\", &n);\n\n  // 为了减少讨论，加了哨兵节点\n  // 因为树状数组添加的时候，为0可能会死循环，所以整体往右偏移一位\n  // a_1和a_{n+2}为哨兵节点\n  for (int i = 2; i <= n + 1; ++i) scanf(\"%d\", &a[i]);\n  for (int i = 2; i <= n + 1; ++i) g[a[i]].push_back(i);\n\n  // 分块\n  build(n + 2);\n\n  int ans = n + 2, lst, ok;\n  for (int i = 1; i <= n + 1; ++i) {\n    g[i].push_back(n + 2);\n\n    lst = 1;\n    ok = 0;\n    for (int pos : g[i]) {\n      if (query(lst + 1, pos - 1, lst) == i - 1) {\n        ok = 1;\n        break;\n      }\n      lst = pos;\n    }\n\n    if (!ok) {\n      ans = i;\n      break;\n    }\n\n    lst = 1;\n    g[i].pop_back();\n    for (int pos : g[i]) {\n      update(pos, lst);\n      lst = pos;\n    }\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Writing Output to File using freopen in C/C++\nDESCRIPTION: Example of using freopen to redirect stdout to write to a file. This allows standard output functions like printf and cout to write to the specified file instead of the console.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nfreopen(\"data.out\", \"w\", stdout);\n// data.out 就是输出文件的文件名，和可执行文件在同一目录下\n```\n\n----------------------------------------\n\nTITLE: LaTeX Output Format Examples\nDESCRIPTION: Examples of LaTeX formatting for problem output specifications with precision requirements\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problemsetting.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n输出包含一个实数，当你的输出与标准答案之间的绝对误差或相对误差小于 $10^{-6}$ 时视作正确。\n\n输出的第二行包含 $n$ 个正整数，表示你构造的一组方案 — 其中第 $i$ 个数表示你打出的第 $i$ 张牌的编号。\n```\n\n----------------------------------------\n\nTITLE: Edge Count Upper Bound for Simple Planar Graphs\nDESCRIPTION: This inequality provides an upper bound for the number of edges (m) in a simple planar graph G with n ≥ 3 vertices. It states that m ≤ 3n - 6.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/planar.md#2025-04-22_snippet_4\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\nm \\leq 3n-6\n```\n\n----------------------------------------\n\nTITLE: Theorem on Quotient Rings and Maximal Ideals\nDESCRIPTION: A theorem establishing that a quotient ring of a commutative ring with unity is a field if and only if the ideal is maximal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_12\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"定理\"\n    设交换非零幺环 $R$ 有理想 $M$，那么商环 $R/M$ 是域，当且仅当 $M$ 是极大理想。\n```\n\n----------------------------------------\n\nTITLE: Pass by Reference Example in C++\nDESCRIPTION: Demonstrates pass-by-reference function parameters using the & symbol, allowing the function to modify the original variables from the calling scope.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nvoid foo(int& x, int& y) {\n  x = x * 2;\n  y = y + 3;\n}\n\n/* ... */\n\na = 1;\nb = 1;\n// 调用前：a = 1, b = 1\nfoo(a, b);  // 调用 foo\n            // 调用后：a = 2, b = 4\n```\n\n----------------------------------------\n\nTITLE: Defining Network Flow Components in LaTeX\nDESCRIPTION: Defines the key components of a network flow graph, including vertices, edges, capacities, source, and sink using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\nG=(V,E)\n```\n\n----------------------------------------\n\nTITLE: Combined Function Declaration and Definition in C++\nDESCRIPTION: Shows how to combine function declaration and definition into a single statement, which is common practice when both are in the same file.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint some_function(int x, int y) { return 2 * x + y; }\n```\n\n----------------------------------------\n\nTITLE: Using sizeof Operator in C++\nDESCRIPTION: Shows how to use the sizeof operator to get the size of a type or variable.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nint size = sizeof floatNum; int size = sizeof(float);\n```\n\n----------------------------------------\n\nTITLE: Linear Sieve for Möbius Function in C++\nDESCRIPTION: Implements a linear sieve algorithm to calculate the Möbius function for numbers up to n. It also generates a list of prime numbers and marks composite numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/sieve.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> pri;\nbool not_prime[N];\nint mu[N];\n\nvoid pre(int n) {\n  mu[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    if (!not_prime[i]) {\n      mu[i] = -1;\n      pri.push_back(i);\n    }\n    for (int pri_j : pri) {\n      if (i * pri_j > n) break;\n      not_prime[i * pri_j] = true;\n      if (i % pri_j == 0) {\n        mu[i * pri_j] = 0;\n        break;\n      }\n      mu[i * pri_j] = -mu[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Computing Extension Degree Using Basis in LaTeX\nDESCRIPTION: A mathematical expression demonstrating that the degree of field extension E over F can be calculated as the product of intermediate extension degrees, which relies on the basis construction.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n[E:F]=[E:K][K:F]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Default Argument Promotion in C Variadic Functions\nDESCRIPTION: Shows how C-style variadic functions handle default argument promotion, where smaller types like float are automatically promoted to larger types like double when passed through the ellipsis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/var.md#2025-04-22_snippet_4\n\nLANGUAGE: C\nCODE:\n```\n#include <stdarg.h>\n#include <stdio.h>\n\nvoid test(int tot, ...) {\n  va_list valist;\n  int i;\n\n  // 初始化可变参数列表\n  va_start(valist, tot);\n\n  for (i = 0; i < tot; ++i) {\n    // 获取第 i 个变量的值\n    double xx = va_arg(valist, double);  // Correct\n    // float xx = va_arg(valist, float); // Wrong\n\n    // 输出第 i 个变量的底层存储内容\n    printf(\"i = %d, value = 0x%016llx\\n\", i, *(long long *)(&xx));\n  }\n\n  // 清理可变参数列表的内存\n  va_end(valist);\n}\n\nint main() {\n  float f;\n  double fd, d;\n  f = 123.;   // 0x42f60000\n  fd = 123.;  // 0x405ec00000000000\n  d = 456.;   // 0x407c800000000000\n  test(3, f, fd, d);\n}\n```\n\n----------------------------------------\n\nTITLE: B+ Tree Root Access and Main Demo in C++\nDESCRIPTION: Getter method for B+ Tree root and main function demonstrating tree operations including insertion and deletion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/bplus-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nNode *BPTree::getRoot() { return root; }\n\nint main() {\n  BPTree node;\n  node.insert(5);\n  node.insert(15);\n  node.insert(25);\n  node.insert(35);\n  node.insert(45);\n\n  node.display(node.getRoot());\n\n  node.remove(15);\n\n  node.display(node.getRoot());\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Node in Single Circular Linked List in C++ and Python\nDESCRIPTION: Demonstrates the insertion of a new node into a single circular linked list, handling the case when the list is empty.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nvoid insertNode(int i, Node *p) {\n  Node *node = new Node;\n  node->value = i;\n  node->next = NULL;\n  if (p == NULL) {\n    p = node;\n    node->next = node;\n  } else {\n    node->next = p->next;\n    p->next = node;\n  }\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef insertNode(i, p):\n    node = Node()\n    node.value = i\n    node.next = None\n    if p == None:\n        p = node\n        node.next = node\n    else:\n        node.next = p.next\n        p.next = node\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Structure in C++\nDESCRIPTION: Demonstrates the basic structure of a switch statement in C++. It allows for multiple branches based on the value of an integer expression.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nswitch (选择句) {\n  case 标签1:\n    主体1;\n  case 标签2:\n    主体2;\n  default:\n    主体3;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bipartite Graph Properties in Markdown\nDESCRIPTION: This snippet defines the concept of a bipartite graph and lists its key properties using Markdown syntax. It includes a note about the absence of odd-length cycles in bipartite graphs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/bi-graph.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## 性质\n\n-   如果两个集合中的点分别染成黑色和白色，可以发现二分图中的每一条边都一定是连接一个黑色点和一个白色点。\n-   二分图不存在长度为奇数的环\n\n    ???+ note\n        因为每一条边都是从一个集合走到另一个集合，只有走偶数次才可能回到同一个集合。\n```\n\n----------------------------------------\n\nTITLE: Reading a 2D Array (Image) in C++\nDESCRIPTION: This code demonstrates how to read a 2D array representing an image from standard input. It uses nested for loops to populate the 2D array with brightness values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/array.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nconst int MAXN = 1001;\nint pic[MAXN][MAXN];\nint n, m;\n\ncin >> n >> m;\nfor (int i = 1; i <= n; ++i)\n  for (int j = 1; j <= m; ++j) cin >> pic[i][j];\n```\n\n----------------------------------------\n\nTITLE: 0-1 Knapsack Incorrect Implementation\nDESCRIPTION: Demonstrates an incorrect implementation of 0-1 knapsack where item order leads to multiple uses of same item. Shows both C++ and Python versions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/knapsack.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 1; i <= n; i++)\n  for (int l = 0; l <= W - w[i]; l++)\n    f[l + w[i]] = max(f[l] + v[i], f[l + w[i]]);\n```\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(1, n + 1):\n    for l in range(0, W - w[i] + 1):\n        f[l + w[i]] = max(f[l] + v[i], f[l + w[i]])\n```\n\n----------------------------------------\n\nTITLE: Constructor Initialization Order Error in C++\nDESCRIPTION: This example shows how member initialization in a constructor's initialization list follows the order of declaration in the class, not the order in the list. This can lead to using uninitialized values when members depend on each other.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nclass Foo {\n public:\n  int a, b;\n\n  // a 将在 b 前初始化，其值不确定\n  Foo(int x) : b(x), a(b + 1) {}\n};\n\nint main() {\n  Foo bar(1, 2);\n  std::cout << bar.a << ' ' << bar.b;\n}\n\n// 可能的输出结果：-858993459 1\n```\n\n----------------------------------------\n\nTITLE: Matrix Expression for Adding Value to Attribute (Python)\nDESCRIPTION: Shows how to represent adding a value v to attribute A using matrix multiplication. This allows efficiently applying the operation to a range of elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{bmatrix}\nA & B & C & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & 1 & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\nv & 0 & 0 & 1\\\\\n\\end{bmatrix}=\n\\begin{bmatrix}\nA+v & B & C & 1\\\\\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Single Jordan Block Structure\nDESCRIPTION: The detailed structure of a single Jordan block showing eigenvalue on the diagonal and ones on the superdiagonal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_18\n\nLANGUAGE: latex\nCODE:\n```\nJ_i=\\begin{pmatrix}\n\\lambda_i & 1 &  &  & \\\\\n & \\lambda_i & 1 &  & \\\\\n &  & \\ddots & \\ddots & \\\\\n &  &  & \\ddots & 1\\\\\n &  &  &  & \\lambda_i\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Definition of Additive and Completely Additive Functions\nDESCRIPTION: Mathematical definition of additive functions in number theory, distinguishing between additive and completely additive functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/basic.md#2025-04-22_snippet_4\n\nLANGUAGE: Markdown\nCODE:\n```\n???+ note \"定义\"\n    在数论中，若函数 $f(n)$ 满足 $f(1)=0$ 且 $f(xy)=f(x)+f(y)$ 对任意互质的 $x, y \\in\\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **加性函数**。\n    \n    在数论中，若函数 $f(n)$ 满足 $f(1)=0$ 且 $f(xy)=f(x)+f(y)$ 对任意的 $x, y \\in\\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **完全加性函数**。\n```\n\n----------------------------------------\n\nTITLE: Matrix Expressions for Tree Operations (Python)\nDESCRIPTION: Shows matrix representations for add and multiply operations on a tree path. These allow efficiently applying operations to entire paths from a node to the root.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/matrix.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\begin{bmatrix}k & t & 1 \\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 0 \\\\\nd & 0 & 1\n\\end{bmatrix}\n&=\n\\begin{bmatrix}k+d & t & 1 \\end{bmatrix}\\\\\n\\begin{bmatrix}k & t & 1 \\end{bmatrix}\n\\begin{bmatrix}\n1 & d & 0 \\\\\n0 & 1 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n&=\n\\begin{bmatrix}k & t+d \\times k & 1 \\end{bmatrix}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Tuple Non-member Functions Example in C++\nDESCRIPTION: Demonstrates non-member functions for tuples, including make_tuple for creation, get for element access, and swap for exchanging tuple contents.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\nstd::tuple<int, int> tupA = {2, 3}, tupB;\ntupB = std::make_tuple(1, 2);\nstd::swap(tupA, tupB);\nstd::cout << std::get<1>(tupA) << std::endl;\n```\n\n----------------------------------------\n\nTITLE: Differential Equation for Zigzag Numbers' Generating Function in LaTeX\nDESCRIPTION: Presents the differential equation and solution for the exponential generating function of zigzag numbers using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\n2\\frac{\\mathrm{d}y}{\\mathrm{d}x}=y^2+1\n$$\n\n$$\ny=\\tan\\left(\\frac{1}{2}x+C\\right)\n$$\n\n$$\ny=\\tan x+\\sec x\n$$\n```\n\n----------------------------------------\n\nTITLE: Splitting Weight Balanced Leafy Trees in C++\nDESCRIPTION: Function for splitting a WBLT into two smaller trees based on a given size or value. This operation is the inverse of merging and maintains balance in the resulting trees.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/wblt.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid split(int p, int k, int &x, int &y) {\n  if (!k) return x = 0, y = p, void();\n  if (leaf(p)) return x = p, y = 0, void();\n  if (k <= sz[ls[p]]) {\n    split(ls[p], k, x, y);\n    y = merges(y, rs[p]);\n  } else {\n    split(rs[p], k - sz[ls[p]], x, y);\n    x = merges(ls[p], x);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Range Maximum with Binary Indexed Tree in C++\nDESCRIPTION: This function queries the maximum value in a range [l, r] using a Binary Indexed Tree. It handles non-differentiable information by carefully traversing the tree structure, with a time complexity of O(log^2 n).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/fenwick.md#2025-04-22_snippet_12\n\nLANGUAGE: C++\nCODE:\n```\nint getmax(int l, int r) {\n  int ans = 0;\n  while (r >= l) {\n    ans = max(ans, a[r]);\n    --r;\n    for (; r - lowbit(r) >= l; r -= lowbit(r)) {\n      ans = max(ans, C[r]);\n    }\n  }\n  return ans;\n}\n```\n\n----------------------------------------\n\nTITLE: Array Usage Example in C++\nDESCRIPTION: Example demonstrating basic usage of std::array including construction, filling and accessing elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/sequence-container.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// 1. 创建空array，长度为3; 常数复杂度\nstd::array<int, 3> v0;\n// 2. 用指定常数创建array; 常数复杂度\nstd::array<int, 3> v1{1, 2, 3};\n\nv0.fill(1);  // 填充数组\n\n// 访问数组\nfor (int i = 0; i != arr.size(); ++i) cout << arr[i] << \" \";\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Reordered Cases in C++\nDESCRIPTION: Illustrates that the order of cases in a switch statement doesn't matter. Cases can be arranged in any order, including the default case.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nchar i = 'B';\n\nswitch (i) {\n  case 'B':\n    cout << \"WIKI\" << endl;\n    break;\n\n  default:\n    cout << \"Hello World\" << endl;\n    break;\n\n  case 'A':\n    cout << \"OI\" << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Mathematical Definition of Order in Groups\nDESCRIPTION: Formal mathematical expression showing how to calculate the order of an element x^k in a finite cyclic group Cn\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\frac{n}{\\gcd(k,n)}\n```\n\n----------------------------------------\n\nTITLE: Calculating delta2 function in Boyer-Moore algorithm\nDESCRIPTION: This pseudocode defines the delta2 function used in the Boyer-Moore algorithm. It calculates the shift distance based on the rightmost plausible reoccurrence of a substring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_1\n\nLANGUAGE: pseudocode\nCODE:\n```\nint delta2(int j)  // j is the position of the mismatched character in pat\n    return patlastpos-rpr(j)\n```\n\n----------------------------------------\n\nTITLE: Defining Edge Dominating Set for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of an edge dominating set E' for a graph G, where every edge not in E' shares at least one endpoint with an edge in E'.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\nE'\\subseteq E \\text{ and } \\forall e\\in(E\\setminus E') \\text{ exists an edge in } E' \\text{ with a common endpoint}\n```\n\n----------------------------------------\n\nTITLE: Optimized Enumeration in Java\nDESCRIPTION: An optimized version of the enumeration algorithm that reduces the search space by only considering pairs where the first number appears earlier in the array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nfor (int i = 0; i < n; ++i)\n    for (int j = 0; j < i; ++j)\n        if (a[i] + a[j] == 0) ++ans;\n```\n\n----------------------------------------\n\nTITLE: Lambda Expression with Parameters in C++\nDESCRIPTION: Shows how to use lambda expressions with parameters, in this case for custom sorting of an array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/lambda.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nint x[] = {5, 1, 7, 6, 1, 4, 2};\nstd::sort(x, x + 7, [](int a, int b) { return (a > b); });\nfor (auto i : x) std::cout << i << \" \";\n```\n\n----------------------------------------\n\nTITLE: Direct WPL Calculation Using Priority Queue in C++\nDESCRIPTION: Calculates WPL directly from an array of weights using a priority queue (min-heap) without explicitly constructing the Huffman tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/huffman-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nint getWPL(int arr[], int n) {\n  priority_queue<int, vector<int>, greater<int>> huffman;\n  for (int i = 0; i < n; i++) huffman.push(arr[i]);\n\n  int res = 0;\n  for (int i = 0; i < n - 1; i++) {\n    int x = huffman.top();\n    huffman.pop();\n    int y = huffman.top();\n    huffman.pop();\n    int temp = x + y;\n    res += temp;\n    huffman.push(temp);\n  }\n  return res;\n}\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 3 of LTE Lemma - Conclusion\nDESCRIPTION: Conclusion of the proof for the third part of the Lifting the Exponent lemma, showing the final formula for the power of 2 in x^n-y^n when 2 divides x-y and n is even.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_14\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)+\\nu_p(x+y)+\\nu_p(n)-1\n```\n\n----------------------------------------\n\nTITLE: Pointer Arithmetic with Arrays in C++\nDESCRIPTION: Demonstrates using pointer arithmetic to access and modify array elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nint main() {\n  int a[3] = {1, 2, 3};\n  int* p = a;  // p points to a[0]\n  *p = 4;      // a: [4, 2, 3]\n  p = p + 1;   // p points to a[1]\n  *p = 5;      // a: [4, 5, 3]\n  p++;         // p points to a[2]\n  *p = 6;      // a: [4, 5, 6]\n}\n```\n\n----------------------------------------\n\nTITLE: Internal Implementation of Collections.sort() in Java\nDESCRIPTION: Shows the underlying implementation of Collections.sort() which converts the collection to an array, uses Arrays.sort(), and then reassigns the sorted elements back to the collection.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_26\n\nLANGUAGE: java\nCODE:\n```\n  default void sort(Comparator<? super E> c) {\n        Object[] a = this.toArray();\n        Arrays.sort(a, (Comparator) c);\n        ListIterator<E> i = this.listIterator();\n        for (Object e : a) {\n            i.next();\n            i.set((E) e);\n        }\n    }\n```\n\n----------------------------------------\n\nTITLE: Implementing IDDFS Algorithm in Pseudocode\nDESCRIPTION: A pseudocode implementation of the Iterative Deepening Depth First Search algorithm. The function takes a node u and current depth d as parameters, and uses a global limit variable to control the maximum search depth. It recursively explores edges until reaching the depth limit.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/iterative.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nIDDFS(u,d)\n    if d>limit\n        return\n    else\n        for each edge (u,v)\n            IDDFS(v,d+1)\nreturn\n```\n\n----------------------------------------\n\nTITLE: Expected Value Min-Max Formula\nDESCRIPTION: Extension of min-max inclusion-exclusion to expected values, showing that the principle holds for expectations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/inclusion-exclusion-principle.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nE\\left(\\max_{i\\in S}{x_i}\\right)=\\sum_{T\\subseteq S}{(-1)^{|T|-1}E\\left(\\min_{j\\in T}{x_j} \\right)}\n\nE\\left(\\min_{i\\in S}{x_i}\\right)=\\sum_{T\\subseteq S}{(-1)^{|T|-1}E\\left(\\max_{j\\in T}{x_j} \\right)}\n```\n\n----------------------------------------\n\nTITLE: Range-Based For Loop with Initialization Statement in C++20\nDESCRIPTION: Shows the C++20 feature of including an initialization statement in range-based for loops, allowing for variable declaration before the loop execution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> v = {0, 1, 2, 3, 4, 5};\n\n  for (auto n = v.size(); auto i : v)  // the init-statement (C++20)\n    std::cout << --n + i << ' ';\n}\n```\n\n----------------------------------------\n\nTITLE: Matroid Intersection for Colorful Graph Problem\nDESCRIPTION: This explains how to model a colorful graph problem using matroid intersection. It defines two matroids: a graph matroid for acyclicity and a partition matroid for color constraints, then solves their intersection.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/matroid.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n1. **拟阵建模**：\n\n   - **图拟阵 ($M_1$)**：定义为所有不形成环的边集，即独立集族 $\\mathcal{I}_1$ 包含所有不构成环的边集合。\n   - **颜色拟阵 ($M_2$)**：定义为每种颜色的边数不超过 $k$ 的边集，即独立集族 $\\mathcal{I}_2$ 包含所有满足每种颜色边数 $\\leq k$ 的边集合。\n\n2. **求解拟阵交**：通过求解 $M = M_1 \\cap M_2$，找到既不形成环又满足每种颜色边数不超过 $k$ 的最大边集。\n```\n\n----------------------------------------\n\nTITLE: Lazy Propagation in Left-Leaning Trees for C++\nDESCRIPTION: Demonstrates how to implement lazy propagation in left-leaning trees to efficiently perform operations on ranges of nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/leftist-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nint merge(int x, int y) {\n  if (!x || !y) return x | y;\n  if (t[x].val > t[y].val) swap(x, y);\n  pushdown(x);\n  t[x].rs = merge(t[x].rs, y);\n  if (t[t[x].rs].d > t[t[x].ls].d) swap(t[x].ls, t[x].rs);\n  t[x].d = t[t[x].rs].d + 1;\n  return x;\n}\n\nint pop(int x) {\n  pushdown(x);\n  return merge(t[x].ls, t[x].rs);\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning a Repository Using SSH in Git\nDESCRIPTION: This command clones a repository using an SSH connection instead of HTTPS. Using SSH connections can be more convenient and secure as it doesn't require entering credentials for each operation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/git.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ git clone git@github.com:OI-wiki/OI-wiki.git\n```\n\n----------------------------------------\n\nTITLE: Defining Ackermann Function in LaTeX\nDESCRIPTION: LaTeX code defining the Ackermann function A_k(j) recursively. This function is used to analyze the time complexity of union-find operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/dsu-complexity.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nA_k(j)=\\left\\{\n\\begin{aligned}\n&j+1& &k=0&\\\\\n&A_{k-1}^{(j+1)}(j)& &k\\geq1&\n\\end{aligned}\n\\right.\n```\n\n----------------------------------------\n\nTITLE: General Double Cross Product Formula\nDESCRIPTION: The main theorem of double cross products that expresses (a×b)×c in terms of dot products and the original vectors. This formula demonstrates how the result lies in the plane containing vectors a and b.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n(\\boldsymbol a\\times \\boldsymbol b)\\times \\boldsymbol c=(\\boldsymbol a \\cdot \\boldsymbol c)\\boldsymbol b - (\\boldsymbol b \\cdot \\boldsymbol c)\\boldsymbol a\n```\n\n----------------------------------------\n\nTITLE: Basic Pigeonhole Principle with Mathematical Notation\nDESCRIPTION: Mathematical representation of the basic pigeonhole principle, where n+1 objects divided into n groups results in at least one group containing two or more objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/drawer-principle.md#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nn+1\n```\n\n----------------------------------------\n\nTITLE: Implementing a Quine in C++\nDESCRIPTION: This code snippet shows an implementation of a Quine - a program that prints its own source code. It uses a string containing a formatted version of the source code and prints it using printf.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problems.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include<cstdio>\n\nchar *s={\"#include<cstdio>%cchar *s={%c%s%c};%cint main(){printf(s,10,34,s,34,10);return 0;}\"};\n\nint main(){printf(s,10,34,s,34,10);return 0;}\n```\n\n----------------------------------------\n\nTITLE: Basic Sum Checker Implementation in C++\nDESCRIPTION: A simple checker that validates if the sum of two integers is correct. Takes input, contestant output and correct answer files as parameters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/testlib/checker.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testlib.h\"\n\nint main(int argc, char* argv[]) {\n  registerTestlibCmd(argc, argv);\n\n  int pans = ouf.readInt(-2000, 2000, \"sum of numbers\");\n\n  // 假定标准输出是正确的，不检查其范围\n  // 之后我们会看到这并不合理\n  int jans = ans.readInt();\n\n  if (pans == jans)\n    quitf(_ok, \"The sum is correct.\");\n  else\n    quitf(_wa, \"The sum is wrong: expected = %d, found = %d\", jans, pans);\n}\n```\n\n----------------------------------------\n\nTITLE: Querying the Kth Element in Range Using Dividing Tree in Pascal\nDESCRIPTION: A function to query the k-th element in a given range [left, right] using a dividing tree. It recursively narrows down the search range by determining if the answer is in the left or right child based on the count of elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/dividing.md#2025-04-22_snippet_1\n\nLANGUAGE: pascal\nCODE:\n```\nfunction Query(left,right,k,l,r,deep:longint):longint;\nvar\n  mid,x,y,cnt,rx,ry:longint;\nbegin\n  if left=right then // 写成 l=r 也无妨,因为目标区间也一定有答案\n    exit(tree[deep,left]);\n  mid:=(l+r) >> 1;\n  x:=toleft[deep,left-1]-toleft[deep,l-1]; // l 到 left 的去左儿子的个数\n  y:=toleft[deep,right]-toleft[deep,l-1]; // l 到 right 的去左儿子的个数\n  ry:=right-l-y; rx:=left-l-x; // ry 是 l 到 right 去右儿子的个数,rx 则是 l 到 left 去右儿子的个数\n  cnt:=y-x; // left 到 right 左儿子的个数\n  if cnt>=k then // 主席树常识啦\n    Query:=Query(l+x,l+y-1,k,l,mid,deep+1) // l+x 就是缩小左边界,l+y-1 就是缩小右区间。对于上图来说,就是把节点 1 和 2 放弃了。\n  else\n    Query:=Query(mid+rx+1,mid+ry+1,k-cnt,mid+1,r,deep+1); // 同样是缩小区间,只不过变成了右边而已。注意要将 k 减去 cnt。\nend;\n```\n\n----------------------------------------\n\nTITLE: fopen Function Declaration in C/C++\nDESCRIPTION: Declaration of the fopen function which opens a file and returns a file pointer. The function takes a path to the file and a mode string as parameters.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nFILE* fopen(const char* path, const char* mode)\n```\n\n----------------------------------------\n\nTITLE: Alternative Extend Procedure (Knuth's Version)\nDESCRIPTION: An alternative, more concise implementation of the Extend procedure proposed by Knuth, which uses recursion to update coset representatives and orbits.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_5\n\nLANGUAGE: pseudocode\nCODE:\n```\n\\begin{array}{l}\n\\textbf{Algorithm }\\textrm{Extend}(C,g):\\\\\n\\textbf{Input. }\\textrm{A stabilizer chain }C\\textrm{ for the group generated by }S\\textrm{ and a}\\\\\n\\qquad \\textrm{permutation }g.\\\\\n\\textbf{Output. }\\textrm{A stabilizer chain }C\\textrm{ for the group generated by }S\\cup\\{g\\}.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1  & \\textbf{if }\\textrm{MembershipTest}(C,g)\\textrm{ is passed}\\textbf{ then}\\\\\n2  & \\qquad \\textbf{return }C\\\\\n3  & \\textbf{end if}\\\\\n4  & \\textbf{if }C\\textrm{ is empty}\\textbf{ then}\\\\\n5  & \\qquad \\beta \\leftarrow \\textrm{an element moved by }g\\\\\n6  & \\qquad C.orbit[0] \\leftarrow \\beta \\\\\n7  & \\qquad C.transversal[\\beta] \\leftarrow e\\\\\n8  & \\textbf{end if}\\\\\n9  & \\textrm{append }g\\textrm{ to }C.generators\\\\\n10 & \\textbf{for }t\\in C.transversal\\\\\n11 & \\qquad \\textrm{ExtendTranserversal}(C,t\\cdot g)\\\\\n12 & \\textbf{end for}\\\\\n13 & \\textbf{return }C\n\\end{array}\\\\\n\\\\\n\\textbf{Sub-Algorithm }\\textrm{ExtendTranserversal}(C,t):\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1  & \\beta \\leftarrow C.orbit[0]\\\\\n2  & \\gamma \\leftarrow \\beta^t\\\\\n3  & \\textbf{if }\\gamma\\notin C.orbit\\textbf{ then}\\\\\n4  & \\qquad \\textrm{append }\\gamma\\textrm{ to }C.orbit\\\\\n5  & \\qquad C.transversal[\\gamma] \\leftarrow t\\\\\n6  & \\qquad \\textbf{for }s\\in C.generators\\\\\n7  & \\qquad \\qquad \\textrm{ExtendTranserversal}(C,t\\cdot s)\\\\\n8  & \\qquad \\textbf{end for}\\\\\n9  & \\textbf{else}\\\\\n10 & \\qquad s' \\leftarrow t\\cdot C.transversal[\\gamma]^{-1}\\\\\n11 & \\qquad \\textrm{Extend}(C.next,s')\\\\\n12 & \\textbf{end if}\n\\end{array}\n\\end{array}\n```\n\n----------------------------------------\n\nTITLE: Determinant with Sum Elements in a Row\nDESCRIPTION: Representation of a determinant where elements in one row are expressed as sums, demonstrating the linearity property of determinants with respect to rows.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{vmatrix}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\n\\vdots & \\vdots &  & \\vdots\\\\\nb_{i1}+c_{i1} & b_{i2}+c_{i2} & \\cdots & b_{in}+c_{in}\\\\\n\\vdots & \\vdots &  & \\vdots\\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\\\\\n\\end{vmatrix}\n```\n\n----------------------------------------\n\nTITLE: Defining Dominating Set for Undirected Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of a dominating set V' for an undirected graph G, where every vertex not in V' is adjacent to at least one vertex in V'.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\nV'\\subseteq V \\text{ and } \\forall v\\in(V\\setminus V') \\text{ exists edge } (u, v)\\in E \\text{ satisfying } u\\in V'\n```\n\n----------------------------------------\n\nTITLE: Batch Script for Generating Multiple Test Cases\nDESCRIPTION: This Windows batch script demonstrates how to use a single generator program to create multiple test cases with different parameters. It runs the generator with various arguments and redirects the output to separate input files.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/problemsetting.md#2025-04-22_snippet_3\n\nLANGUAGE: bat\nCODE:\n```\ngen 10 10 > 1.in\ngen 1 1 > 2.in\ngen 100 200 > 3.in\ngen 2000 1000 > 4.in\ngen 100000 100000 > 5.in\n```\n\n----------------------------------------\n\nTITLE: Equivalent Function Exit Implementation\nDESCRIPTION: Shows a more strictly equivalent Pascal version of the abs function with explicit exit statements, comparing it to the C++ implementation which uses return statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_14\n\nLANGUAGE: Pascal\nCODE:\n```\nfunction abs(x:integer):integer;\nbegin\n    if x < 0 then\n        begin\n            abs := -x; exit; // !注意此处\n        end\n    else\n        begin\n            abs := x;  exit; // !注意此处\n        end;\nend;\n```\n\nLANGUAGE: C++\nCODE:\n```\nint abs(int x) {\n  if (x < 0) {\n    return -x;\n  } else {\n    return x;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing BMHBNFS (B5S) Algorithm in Rust\nDESCRIPTION: Implementation of the BMHBNFS algorithm used in CPython's stringlib. Combines Horspool and Sunday approaches with Galil rule optimization for optimal time performance while maintaining space efficiency.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\npub struct B5STimePattern<'a> {\n    pat_bytes: &'a [u8],\n    alphabet: [bool;256],\n    bm_bc: [usize;256],\n    k: usize\n}\n\nimpl<'a> B5STimePattern<'a> {\n    pub fn new(pat: &'a str) -> Self {\n        assert_ne!(pat.len(), 0);\n\n        let pat_bytes = pat.as_bytes();\n        let (alphabet, bm_bc, k) = B5STimePattern::build(pat_bytes);\n\n        B5STimePattern { pat_bytes, alphabet, bm_bc, k }\n    }\n\n    fn build(p: &'a [u8]) -> ([bool;256], [usize;256], usize)  {\n        let mut alphabet = [false;256];\n        let mut bm_bc = [p.len(); 256];\n        let lastpos = p.len() - 1;\n\n        for i in 0..lastpos {\n            alphabet[p[i] as usize] = true;\n            bm_bc[p[i] as usize] = lastpos - i;\n        }\n\n        alphabet[p[lastpos] as usize] = true;\n\n        (alphabet, bm_bc, compute_k(p))\n    }\n\n    pub fn find_all(&self, string: &str) -> Vec<usize> {\n        let mut result = vec![];\n        let string_bytes = string.as_bytes();\n        let pat_last_pos = self.pat_bytes.len() - 1;\n        let patlen = self.pat_bytes.len();\n        let stringlen = string_bytes.len();\n        let mut string_index = pat_last_pos;\n        let mut offset = pat_last_pos;\n        let offset0 = self.k - 1;\n\n        while string_index < stringlen {\n            if string_bytes[string_index] == self.pat_bytes[pat_last_pos] {\n                if &string_bytes[string_index-offset..string_index] == &self.pat_bytes[pat_last_pos-offset..pat_last_pos] {\n                    result.push(string_index-pat_last_pos);\n\n                    offset = offset0;\n\n                    string_index += self.k;\n                    continue;\n                }\n            }\n\n            if string_index + 1 == stringlen {\n                break;\n            }\n\n            offset = pat_last_pos;\n\n            if !self.alphabet[string_bytes[string_index+1] as usize] {\n                string_index += patlen + 1;\n            } else {\n                string_index += self.bm_bc[string_bytes[string_index] as usize];\n            }\n        }\n\n        result\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 2 of LTE Lemma - Conclusion for n=p\nDESCRIPTION: Conclusion of the proof for the case n=p in the second part of the Lifting the Exponent lemma.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)+1\n```\n\n----------------------------------------\n\nTITLE: String Operations in C++\nDESCRIPTION: Overview of string manipulation operations in C++ using std::string, including concatenation, assignment, access, and capacity functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/lib-func.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nstring1 + string2;\nstring1 = string2;\nstring1[index];\nstring1.data();\nstring1.c_str();\nstring1.size();\n```\n\n----------------------------------------\n\nTITLE: Type Mismatch Error with std::max Function in C++\nDESCRIPTION: This code demonstrates a common compilation error when using std::max with mismatched parameter types (int and long long). The compiler cannot determine which overloaded version of std::max to use, resulting in a compilation error.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n// query 为返回 long long 类型的自定义函数\nprintf(\"%lld\\n\", max(0, query(1, 1, n, l, r));\n\n//错误    没有与参数列表匹配的 重载函数 \"std::max\" 实例\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Modulo Operator Behavior in C/C++\nDESCRIPTION: This code snippet demonstrates how the modulo operator works in C/C++ with different operand signs. According to C99 and C++11 standards, integer division rounds toward zero and the modulo operation produces a result with the same sign as the dividend.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/basic.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n5 % 3 == 2;\n5 % -3 == 2;\n-5 % 3 == -2;\n-5 % -3 == -2;\n```\n\n----------------------------------------\n\nTITLE: Map Traversal Example\nDESCRIPTION: Shows how to iterate through a Map's entries using keySet() and get() methods.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_20\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static Map<Integer, Integer> map1 = new HashMap<>();\n\n    static void print() {\n        for (int key : map1.keySet()) {\n            out.println(key + \" \" + map1.get(key));\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Proving Lemma for Primitive Root Existence in LaTeX\nDESCRIPTION: This LaTeX code snippet proves a lemma used in the proof of the primitive root existence theorem for prime numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/primitive-root.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n    \\delta_m\\left(a^X\\right)&=\\dfrac{\\delta_m(a)}{\\left(\\delta_m(a),X\\right)}\\\\\n    &=\\dfrac{XY}{X}\\\\\n    &=Y\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Simple Range-Based For Loop with Initializer List in C++\nDESCRIPTION: Shows how to use a range-based for loop with a braced initializer list to iterate over a set of predefined values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/new.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i : {1, 1, 4, 5, 1, 4}) std::cout << i;\n```\n\n----------------------------------------\n\nTITLE: Fetching Changes from Remote Repository in Git\nDESCRIPTION: This command fetches changes from a specified remote repository without merging them into the local repository. It only updates the remote-tracking branches to reflect the state of the remote repository.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/git.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ git fetch <remote-name> # 获取 <remote-name> 的更改\n```\n\n----------------------------------------\n\nTITLE: Definition of Ideals in Ring Theory\nDESCRIPTION: The definition of left ideals, right ideals, and two-sided ideals in a ring, which are special subrings closed under multiplication by ring elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"理想\"\n    对于环 $R$ 和它的子环 $I$，则称 $I$ 是 $R$ 的\n    \n    -   **左理想**（left ideal），如果对于所有 $r\\in R$，都有 $rI\\subseteq I$，这里，$rI=\\{ra:a\\in I\\}$；\n    -   **右理想**（left ideal），如果对于所有 $r\\in R$，都有 $Ir\\subseteq I$，这里，$Ir=\\{ar:a\\in I\\}$；\n    -   **理想**（ideal），如果 $I$ 既是 $R$ 的左理想，也是 $R$ 的右理想。\n```\n\n----------------------------------------\n\nTITLE: Accessing and Modifying std::pair Elements\nDESCRIPTION: Examples of accessing and modifying the first and second elements of a pair using member functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/pair.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint i = p0.first;\ndouble d = p0.second;\n```\n\nLANGUAGE: cpp\nCODE:\n```\np1.first++;\n```\n\n----------------------------------------\n\nTITLE: Mathematical Problem - Ellipse Point Calculation (CF103329F)\nDESCRIPTION: Problem involving calculation of sum of expressions containing XOR operations and powers for integer points on an ellipse, with modulo operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/fwt.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\sum_{(x,y) \\in E} (x \\oplus y)^{33}x^{-2}y^{-1} \\mod 10^9+7\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Struct in C++\nDESCRIPTION: Defines a struct called ThreeInt containing three integer members.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pointer.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nstruct ThreeInt {\n  int a;\n  int b;\n  int c;\n};\n```\n\n----------------------------------------\n\nTITLE: Calculating Same-Column First Kind Stirling Numbers in C++\nDESCRIPTION: This code computes the first kind Stirling numbers for a fixed k and varying i using exponential generating functions and polynomial operations. It employs modular arithmetic for handling large numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nint main() {\n  scanf(\"%d%d\", &n, &k);\n  fact[0] = 1;\n  for (int i = 1; i <= n; ++i) fact[i] = (ll)fact[i - 1] * i % mod;\n  ifact[n] = qpow(fact[n], mod - 2);\n  for (int i = n - 1; i >= 0; --i) ifact[i] = (ll)ifact[i + 1] * (i + 1) % mod;\n  poly f(n + 1);\n  for (int i = 1; i <= n; ++i) f[i] = (ll)fact[i - 1] * ifact[i] % mod;\n  f = exp(log(f >> 1) * k) << k, f.resize(n + 1);\n  for (int i = 0; i <= n; ++i)\n    printf(\"%lld \", (ll)f[i] * fact[i] % mod * ifact[k] % mod);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Finger Tree Data Structure in Haskell\nDESCRIPTION: The core data definition for a Finger Tree, including the FingerTree type with Empty, Single, and Deep constructors, along with supporting Digit and Node types. This structure allows for efficient sequence operations in a functional programming context.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/finger-tree.md#2025-04-22_snippet_0\n\nLANGUAGE: haskell\nCODE:\n```\ndata FingerTree a = Empty\n                  | Single a\n                  | Deep (Digit a) (FingerTree (Node a)) (Digit a)\n\ndata Digit a = One a | Two a a | Three a a a | Four a a a a\ndata Node a = Node2 a a | Node3 a a a\n```\n\n----------------------------------------\n\nTITLE: Incorrect Array Assignment in C++\nDESCRIPTION: This snippet shows that direct assignment between arrays is not allowed in C++. It illustrates common mistakes in array handling.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/array.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint arr1[3];\nint arr2 = arr1;  // 错误\narr2 = arr1;      // 错误\n```\n\n----------------------------------------\n\nTITLE: Switch Statement with Integer Variable in C++\nDESCRIPTION: Shows a switch statement using an integer variable as the selector. The case labels must be integer constants.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/branch.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nint i = 1;  // 这里的 i 的数据类型是整型 ，满足整数类型的表达式的要求\n\nswitch (i) {\n  case 1:\n    cout << \"OI WIKI\" << endl;\n}\n```\n\n----------------------------------------\n\nTITLE: Non-local Search for Tree Center in C++\nDESCRIPTION: This function implements a non-local search algorithm to find the center of a tree using SATT. It recursively searches through the tree structure, comparing sums of different subtrees to determine the direction of the search and identify the center node(s).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_8\n\nLANGUAGE: C++\nCODE:\n```\nvoid non_local_search(int x, int lv, int rv, int op) {\n  // lv 和 rv 都是搜索的上一个簇的信息\n  if (!x) return;\n  psd(x, 0);\n  if (op == 0) {\n    if (maxs[ms(x)] >=\n        sum[ms(x)] - maxs[ms(x)] + sum[rs(x)] + sum[ls(x)] + lv + 1 + rv) {\n      if (maxs[ms(x)] ==\n          sum[ms(x)] - maxs[ms(x)] + sum[rs(x)] + sum[ls(x)] + lv + 1 + rv) {\n        if (ans1)\n          ans2 = x;\n        else\n          ans1 = x;\n      }\n      non_local_search(\n          ms(x),\n          sum[ms(x)] - maxs[ms(x)] + sum[rs(x)] + sum[ls(x)] + 1 + lv + rv, 0,\n          1);\n      return;\n    }\n    if (ss[rs(x)] + rv >= ss[ms(x)] + ss[ls(x)] + lv + 1) {\n      if (ss[rs(x)] + rv == ss[ms(x)] + ss[ls(x)] + lv + 1) {\n        if (ans1)\n          ans2 = x;\n        else\n          ans1 = x;\n      }\n      non_local_search(rs(x), sum[ms(x)] + 1 + sum[ls(x)] + lv, rv, 0);\n      return;\n    }\n    if (sum[ls(x)] + lv >= sum[ms(x)] + sum[rs(x)] + 1 + rv) {\n      if (sum[ls(x)] + lv == sum[ms(x)] + sum[rs(x)] + 1 + rv) {\n        if (ans1)\n          ans2 = x;\n        else\n          ans1 = x;\n      }\n      non_local_search(ls(x), lv, rv + sum[ms(x)] + 1 + sum[rs(x)], 0);\n      return;\n    }\n  } else {\n    if (maxs[ls(x)] == maxs[x]) {\n      non_local_search(ls(x), lv, rv, 1);\n      return;\n    }\n    if (maxs[rs(x)] == maxs[x]) {\n      non_local_search(rs(x), lv, rv, 1);\n      return;\n    }\n    non_local_search(ms(x), lv, rv, 0);\n    return;\n  }\n  if (ans1)\n    ans2 = x;\n  else\n    ans1 = x;\n}\n```\n\n----------------------------------------\n\nTITLE: Modified Dynamic Programming Equation for Tree Decomposition\nDESCRIPTION: Modifies the tree-based dynamic programming equation to separate the contribution of the heavy child node (h) from the light child nodes, facilitating the use of heavy-light decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/basic.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nf_{i,1}&=w_i+f_{h,0}+g_{i,1},\\\\\nf_{i,0}&=\\max\\{f_{j,0},f_{j,1}\\}+g_{i,0},\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Calculating Norm of Quadratic Integers in LaTeX\nDESCRIPTION: LaTeX formulas for calculating the norm of quadratic integers based on different cases of d modulo 4.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quadratic.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\nN(a+b\\sqrt{d})=\\begin{cases}\na^2+ab+\\dfrac{1-d}{4}b^2, & d\\equiv 1\\pmod 4,\\\\\na^2-db^2, & d\\equiv 2,3\\pmod 4.\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Optimized Enumeration in C++\nDESCRIPTION: An optimized version of the enumeration algorithm that reduces the search space by only considering pairs where the first number appears earlier in the array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nfor (int i = 0; i < n; ++i)\n  for (int j = 0; j < i; ++j)\n    if (a[i] + a[j] == 0) ++ans;\n```\n\n----------------------------------------\n\nTITLE: Installing xterm on Ubuntu WSL\nDESCRIPTION: Command to install the xterm terminal emulator on Ubuntu using apt package manager.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\napt install xterm -y\n```\n\n----------------------------------------\n\nTITLE: Defining Intersection Operation for Undirected Simple Graphs in LaTeX\nDESCRIPTION: This snippet defines the intersection operation for two undirected simple graphs G and H, resulting in a new graph that contains the common vertices and edges of both input graphs.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\nG \\cap H = \\left( V_1 \\cap V_2, E_1 \\cap E_2 \\right)\n```\n\n----------------------------------------\n\nTITLE: Range Sum Query in Python\nDESCRIPTION: Python implementation of segment tree range sum query operation that returns the sum of elements in a given range. Handles lazy propagation during query traversal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/seg.md#2025-04-22_snippet_7\n\nLANGUAGE: Python\nCODE:\n```\ndef getsum(l, r, s, t, p):\n    if l <= s and t <= r:\n        return d[p]\n    m = s + ((t - s) >> 1)\n    if b[p]:\n        d[p * 2] = d[p * 2] + b[p] * (m - s + 1)\n        d[p * 2 + 1] = d[p * 2 + 1] + b[p] * (t - m)\n        b[p * 2] = b[p * 2] + b[p]\n        b[p * 2 + 1] = b[p * 2 + 1] + b[p]\n        b[p] = 0\n    sum = 0\n    if l <= m:\n        sum = getsum(l, r, s, m, p * 2)\n    if r > m:\n        sum = sum + getsum(l, r, m + 1, t, p * 2 + 1)\n    return sum\n```\n\n----------------------------------------\n\nTITLE: Derivation of General Formula for Second Stirling Numbers in LaTeX\nDESCRIPTION: This LaTeX code block shows the derivation of the general formula for Second Stirling Numbers using the principle of inclusion-exclusion and binomial inversion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nG_i&=i^n\\\\\nG_i&=\\sum\\limits_{j=0}^i\\binom{i}{j}F_j\n\\end{aligned}\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nF_i&=\\sum\\limits_{j=0}^{i}(-1)^{i-j}\\binom{i}{j}G_j\\\\\n&=\\sum\\limits_{j=0}^{i}(-1)^{i-j}\\binom{i}{j}j^n\\\\\n&=\\sum\\limits_{j=0}^{i}\\dfrac{i!(-1)^{i-j}j^n}{j!(i-j)!}\n\\end{aligned}\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\dfrac{F_m}{m!}=\\sum\\limits_{i=0}^m\\dfrac{(-1)^{m-i}i^n}{i!(m-i)!}\n```\n\n----------------------------------------\n\nTITLE: Inserting Node in Single Linked List in C++ and Python\nDESCRIPTION: Demonstrates the insertion of a new node into a single linked list after a given node.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/linked-list.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid insertNode(int i, Node *p) {\n  Node *node = new Node;\n  node->value = i;\n  node->next = p->next;\n  p->next = node;\n}\n```\n\nLANGUAGE: Python\nCODE:\n```\ndef insertNode(i, p):\n    node = Node()\n    node.value = i\n    node.next = p.next\n    p.next = node\n```\n\n----------------------------------------\n\nTITLE: Null Pointer Dereference Undefined Behavior in C++\nDESCRIPTION: Shows how a compiler can optimize code based on the assumption that null pointers will never be dereferenced. Since the pointer is dereferenced before the null check, the compiler can assume the pointer is never null.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\nint f(int* p) {\n  int x = *p;\n  if (!p)\n    return x;  // Either UB above or this branch is never taken\n  else\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Mex Function in Python\nDESCRIPTION: This code snippet defines the mex (minimum excludant) function, which finds the smallest non-negative integer not in a given set. It's a key component in calculating Sprague-Grundy values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/game-theory/impartial-game.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef mex(S):\n    x = 0\n    while x in S:\n        x += 1\n    return x\n```\n\n----------------------------------------\n\nTITLE: Vector Addition and Scalar Multiplication Properties in LaTeX\nDESCRIPTION: Mathematical expressions showing the properties of vector addition and scalar multiplication using LaTeX notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/vector.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n\\lambda(\\mu \\boldsymbol a)&=(\\lambda \\mu)\\boldsymbol a\\\\\n(\\lambda+\\mu)\\boldsymbol a&=\\lambda \\boldsymbol a+\\mu \\boldsymbol a\\\\\n\\lambda(\\boldsymbol a+\\boldsymbol b)&=\\lambda \\boldsymbol a+\\lambda \\boldsymbol b\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constant Time Complexity in Java\nDESCRIPTION: Shows the Java implementation of a loop with fixed iterations, exemplifying O(1) time complexity when N is considered a constant.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/complexity.md#2025-04-22_snippet_5\n\nLANGUAGE: Java\nCODE:\n```\nfinal int N = 100000;\nfor (int i = 0; i < N; ++i) {\n    System.out.println(\"hello world\");\n}\n```\n\n----------------------------------------\n\nTITLE: Polynomial Division with Remainder\nDESCRIPTION: Defines the division of polynomials f(x) by g(x) with quotient Q(x) and remainder R(x).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_4\n\nLANGUAGE: Mathematics\nCODE:\n```\nf(x) = Q(x) g(x) + R(x)\n\\operatorname{deg}{R} < \\operatorname{deg}{g}\n```\n\n----------------------------------------\n\nTITLE: Implementing Randomized Heaps in C++\nDESCRIPTION: Shows an implementation of randomized heaps, which use random number generation to maintain balance instead of explicit dist values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/leftist-tree.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nint merge(int x, int y) {\n  if (!x || !y) return x | y;\n  if (t[y].val < t[x].val) swap(x, y);\n  if (rand() & 1)  // 随机选择是否交换左右子节点\n    swap(t[x].ls, t[x].rs);\n  t[x].ls = merge(t[x].ls, y);\n  return x;\n}\n```\n\n----------------------------------------\n\nTITLE: Recursive Formula for Cycle Index of Symmetric Group\nDESCRIPTION: Recursive relationship for calculating the cycle index of the symmetric group Sn, with initial condition Z(S0)=1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_12\n\nLANGUAGE: latex\nCODE:\n```\nZ(S_n)=\\frac1n\\sum_{k=1}^nt_kZ(S_{n-k}),\n```\n\n----------------------------------------\n\nTITLE: Definition of Kernel in Ring Homomorphism\nDESCRIPTION: The definition of the kernel of a ring homomorphism, which is the set of elements that map to the additive identity element in the target ring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"同态的核\"\n    自环 $R$ 到环 $S$ 的同态 $\\pi:R\\rightarrow S$ 的 **核**（kernel）是 $\\{r\\in R:\\pi(r)=0\\}$，记作 $\\ker\\pi$，其中，$0$ 是 $S$ 的加法单位元。\n```\n\n----------------------------------------\n\nTITLE: Dynamic Programming Equation for Maximum Weighted Independent Set on a Chain\nDESCRIPTION: Defines the recurrence relation for computing the maximum weighted independent set on a chain, where f_{i,1} represents choosing the i-th element and f_{i,0} represents not choosing it.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/basic.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nf_{i,1}&=w_{i}+f_{i-1,0},\\\\\nf_{i,0}&=\\max\\{f_{i-1,1},f_{i-1,0}\\}.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 3: For p=2 When p Divides x-y (Even n)\nDESCRIPTION: Third part of the Lifting the Exponent lemma for p=2, stating that when 2 divides x-y and n is even, the power of 2 in x^n-y^n equals the power of 2 in x-y plus the power of 2 in x+y plus the power of 2 in n minus 1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_10\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)+\\nu_p(x+y)+\\nu_p(n)-1\n```\n\n----------------------------------------\n\nTITLE: Binomial Theorem Method for Polynomial Translation\nDESCRIPTION: Direct application of binomial theorem to expand each term of the polynomial after translation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/shift.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\nf(x+c)=\\sum _ {i=0}^nf_i(x+c)^i=\\sum _ {i=0}^nf_i\\left(\\sum _ {j=0}^i\\binom{i}{j}x^jc^{i-j}\\right)\n```\n\n----------------------------------------\n\nTITLE: Implementing Discrete Root Finding with BSGS Algorithm in C++\nDESCRIPTION: This code implements three key components: finding a primitive root modulo p, solving the discrete logarithm problem using the Baby-Step Giant-Step algorithm, and finding all solutions to the equation x^k ≡ a (mod n). It includes helper functions for GCD calculation and modular exponentiation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/discrete-logarithm.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint gcd(int a, int b) { return a ? gcd(b % a, a) : b; }\n\nint powmod(int a, int b, int p) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) res = res * a % p;\n    a = a * a % p, b >>= 1;\n  }\n  return res;\n}\n\n// Finds the primitive root modulo p\nint generator(int p) {\n  vector<int> fact;\n  int phi = p - 1, n = phi;\n  for (int i = 2; i * i <= n; ++i) {\n    if (n % i == 0) {\n      fact.push_back(i);\n      while (n % i == 0) n /= i;\n    }\n  }\n  if (n > 1) fact.push_back(n);\n  for (int res = 2; res <= p; ++res) {\n    bool ok = true;\n    for (int factor : fact) {\n      if (powmod(res, phi / factor, p) == 1) {\n        ok = false;\n        break;\n      }\n    }\n    if (ok) return res;\n  }\n  return -1;\n}\n\n// This program finds all numbers x such that x^k=a (mod n)\nint main() {\n  int n, k, a;\n  scanf(\"%d %d %d\", &n, &k, &a);\n  if (a == 0) return puts(\"1\\n0\"), 0;\n  int g = generator(n);\n  // Baby-step giant-step discrete logarithm algorithm\n  int sq = (int)sqrt(n + .0) + 1;\n  vector<pair<int, int>> dec(sq);\n  for (int i = 1; i <= sq; ++i)\n    dec[i - 1] = {powmod(g, i * sq * k % (n - 1), n), i};\n  sort(dec.begin(), dec.end());\n  int any_ans = -1;\n  for (int i = 0; i < sq; ++i) {\n    int my = powmod(g, i * k % (n - 1), n) * a % n;\n    auto it = lower_bound(dec.begin(), dec.end(), make_pair(my, 0));\n    if (it != dec.end() && it->first == my) {\n      any_ans = it->second * sq - i;\n      break;\n    }\n  }\n  if (any_ans == -1) return puts(\"0\"), 0;\n  // Print all possible answers\n  int delta = (n - 1) / gcd(k, n - 1);\n  vector<int> ans;\n  for (int cur = any_ans % delta; cur < n - 1; cur += delta)\n    ans.push_back(powmod(g, cur, n));\n  sort(ans.begin(), ans.end());\n  printf(\"%zu\\n\", ans.size());\n  for (int answer : ans) printf(\"%d \", answer);\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Heap Comparison Table in Markdown\nDESCRIPTION: This markdown snippet presents a comparison table of different heap implementations, showing their time complexities for various operations such as insert, find-min, delete-min, merge, and decrease-key. It also indicates whether each implementation supports persistence.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/heap.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|    操作 `\\` 数据结构[^ref4]   |                                      配对堆                                     |      二叉堆     |      左偏树     |          二项堆         |        斐波那契堆       |\n| :---------------------: | :--------------------------------------------------------------------------: | :----------: | :----------: | :------------------: | :----------------: |\n|        插入（insert）       |                                    $O(1)$                                    |  $O(\\log n)$ |  $O(\\log n)$ |  $O(\\log n)$[^ref1]  |       $O(1)$       |\n|     查询最小值（find-min）     |                                    $O(1)$                                    |    $O(1)$    |    $O(1)$    | $O(1)$[^ref2][^ref3] |       $O(1)$       |\n|    删除最小值（delete-min）    |                              $O(\\log n)$[^ref3]                              |  $O(\\log n)$ |  $O(\\log n)$ |      $O(\\log n)$     | $O(\\log n)$[^ref3] |\n|        合并 (merge)       |                                    $O(1)$                                    |    $O(n)$    |  $O(\\log n)$ |      $O(\\log n)$     |       $O(1)$       |\n| 减小一个元素的值 (decrease-key) | $o(\\log n)$（下界 $\\Omega(\\log \\log n)$，上界 $O(2^{2\\sqrt{\\log \\log n}})$）[^ref3] |  $O(\\log n)$ |  $O(\\log n)$ |      $O(\\log n)$     |    $O(1)$[^ref3]   |\n|         是否支持可持久化        |                                   $\\times$                                   | $\\checkmark$ | $\\checkmark$ |     $\\checkmark$     |      $\\times$      |\n```\n\n----------------------------------------\n\nTITLE: Out-of-Bounds Access Undefined Behavior in C++\nDESCRIPTION: Illustrates how compilers can optimize based on the assumption that array access will never be out-of-bounds. The function checks up to index 4 in a 4-element array, which would cause undefined behavior on the last iteration.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nint table[4] = {};\n\nbool exists_in_table(int v) {\n  // return true in one of the first 4 iterations or UB due to out-of-bounds\n  // access\n  for (int i = 0; i <= 4; i++)\n    if (table[i] == v) return true;\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Const Member Functions in C++ Classes\nDESCRIPTION: Demonstrates the implementation of const member functions in classes and their restrictions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/const.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nstruct ConstMember {\n  int s = 0;\n\n  void func() { std::cout << \"General Function\" << std::endl; }\n\n  void constFunc1() const { std::cout << \"Const Function 1\" << std::endl; }\n\n  void constFunc2(int ss) const {\n    // func(); // const 成员函数不能调用非 const 成员函数\n    constFunc1();\n\n    // s = ss; // const 成员函数不能修改成员变量\n  }\n};\n\nint main() {\n  int b = 1;\n  ConstMember c{};\n  const ConstMember d = c;\n  // d.func(); // 常量不能调用非 const 成员函数\n  d.constFunc2(b);\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Switching Matrix in LaTeX\nDESCRIPTION: Mathematical definition of a switching matrix P_ij, which is a special symmetric matrix formed by interchanging the i-th and j-th rows of an identity matrix.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_1\n\nLANGUAGE: tex\nCODE:\n```\nP_{ij}=\\begin{pmatrix}\nI_{i-1} &  &  &  & \\\\\n & 0 &  & 1 & \\\\\n &  & I_{j-i-1} &  & \\\\\n & 1 &  & 0 & \\\\\n &  &  &  & I_{n-j}\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 1: Case when p divides x+y\nDESCRIPTION: First part of the Lifting the Exponent lemma stating that when p divides x+y and n is odd, the power of p in x^n+y^n equals the power of p in x+y.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n+y^n\\right)=\\nu_p(x+y)\n```\n\n----------------------------------------\n\nTITLE: Random Data Generation using mt19937 and shuffle() in C++\nDESCRIPTION: Generates random test data using the mt19937 random number generator and shuffle() algorithm. Provides an alternative to rand() and random_shuffle() with improved randomness.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <ctime>\n#include <iostream>\n#include <random>\n\nint a[100];\n\nint main() {\n  std::mt19937 rng(time(nullptr));\n  int n = rng() % 99 + 1;\n  for (int i = 1; i <= n; i++) a[i] = i;\n  std::cout << n << '\\n';\n  for (int i = 1; i <= n; i++) {\n    std::shuffle(a + 1, a + i, rng);\n    int cnt = rng() % i;\n    for (int j = 1; j <= cnt; j++) std::cout << a[j] << ' ';\n    std::cout << 0 << '\\n';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Nim Sum in Python\nDESCRIPTION: This code snippet calculates the Nim sum (XOR sum) of a list of numbers, which is used to determine the winning strategy in Nim games and other impartial games.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/game-theory/impartial-game.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef nim_sum(piles):\n    return reduce(lambda x, y: x ^ y, piles)\n```\n\n----------------------------------------\n\nTITLE: Displaying LaTeX Set for All Integer Solutions\nDESCRIPTION: A LaTeX set notation describing all integer solutions to the equation x^2 - Dy^2 = ±1 in terms of the fundamental solution to x^2 - Dy^2 = -1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\{(x,y):x+y\\sqrt{D}=\\pm(x_1+y_1\\sqrt{D})^k,k\\in\\mathbf Z\\}.\n```\n\n----------------------------------------\n\nTITLE: Updating Tree Node Information in C++\nDESCRIPTION: This function updates the sum and maxs values for tree nodes. It handles both Compress Nodes and Rake Nodes differently, calculating the sum of child nodes and the maximum sum among child nodes.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/top-tree.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\nvoid pushup(int x, int op) {\n  if (op == 0) {\n    // 是 Compress Node\n    sum[x] = sum[ls(x)] + sum[rs(x)] + sum[ms(x)] + 1;\n  } else {\n    // 是 Rake Node\n    maxs[x] = max(maxs[ls(x)], max(maxs[rs(x)], sum[ms(x)]));\n    sum[x] = sum[ls(x)] + sum[rs(x)] + sum[ms(x)];\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Polynomial GCD using Euclidean Algorithm\nDESCRIPTION: Recursive definition of the greatest common divisor for polynomials using the Euclidean algorithm.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_5\n\nLANGUAGE: Mathematics\nCODE:\n```\n\\gcd(f,0)=f,\\gcd(f,g)=\\gcd(g,f\\bmod g)\n```\n\n----------------------------------------\n\nTITLE: Defining Edge Cover for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of an edge cover E' for a graph G, where every vertex in G is incident to at least one edge in E'.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_9\n\nLANGUAGE: LaTeX\nCODE:\n```\nE'\\subseteq E \\text{ and } \\forall v\\in V, v \\text{ is incident to at least one edge in } E'\n```\n\n----------------------------------------\n\nTITLE: Install GUI Environment\nDESCRIPTION: Commands to install and configure Xfce desktop environment with remote desktop access\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ sudo apt install xfce4 tightvncserver -y\n```\n\n----------------------------------------\n\nTITLE: Assignment vs Comparison Operator Error in C++\nDESCRIPTION: This snippet demonstrates a common mistake where the assignment operator (=) is used instead of the comparison operator (==) in a conditional statement. This results in the condition always evaluating to the assigned value rather than comparing values.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nstd::srand(std::time(nullptr));\nint n = std::rand();\nif (n = 1)\n  printf(\"Yes\");\nelse\n  printf(\"No\");\n\n// 无论 n 的随机所得值为多少，输出肯定是 Yes\n// 警告    运算符不正确: 在 Boolean 上下文中执行了常量赋值。应考虑改用「==」。\n```\n\n----------------------------------------\n\nTITLE: Basic Bitset Header Include\nDESCRIPTION: Required header file inclusion for using std::bitset\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/bitset.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <bitset>\n```\n\n----------------------------------------\n\nTITLE: Third Isomorphism Theorem for Rings\nDESCRIPTION: The statement of the third isomorphism theorem for rings, relating nested ideals to quotient rings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"第三同构定理\"\n    设环 $R$ 有理想 $I,J$ 且 $I\\subseteq J$，那么 $J/I$ 也是 $R/I$ 的理想，并且 $(R/I)/(J/I)\\cong R/J$。\n```\n\n----------------------------------------\n\nTITLE: Basic While Loop Structure in C++\nDESCRIPTION: The fundamental structure of a while loop in C++, showing the condition-based execution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nwhile (判断条件) {\n  循环体;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multiset Construction for Combinatorial Classes in LaTeX\nDESCRIPTION: Defines the multiset construction for a combinatorial class A, generating all possible unordered combinations of objects from A.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\operatorname{MSET}(\\mathcal{A})=\\prod _ {\\alpha\\in\\mathcal{A}}\\operatorname{SEQ}(\\lbrace \\alpha\\rbrace)\n```\n\n----------------------------------------\n\nTITLE: Jordan Decomposition of a Matrix\nDESCRIPTION: The matrix version of the Jordan decomposition showing how a matrix can be split into diagonalizable and nilpotent parts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\nA=D+N\n```\n\n----------------------------------------\n\nTITLE: Creating Basic LaTeX Tables\nDESCRIPTION: Demonstrates how to create tables in LaTeX using the tabular environment. Shows column alignment options, cell separation, row breaks, and horizontal lines.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_1\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{tabular}{|l|l|}\n  Apples       & Green  \\\\\n  Strawberries & Red    \\\\\n  Orange       & Orange \\\\\n\\end{tabular}\n\n\\begin{tabular}{rc}\n  Apples              & Green  \\\\\n  \\hline\n  Strawberries        & Red    \\\\\n  \\cline{1-1} Oranges & Orange \\\\\n\\end{tabular}\n\n\\begin{tabular}{|r|l|}\n  \\hline\n  8              & here's \\\\\n  \\cline{2-2} 86 & stuff  \\\\\n  \\hline\n  \\hline\n  2008           & now    \\\\\n  \\hline\n\\end{tabular}\n```\n\n----------------------------------------\n\nTITLE: Block Diagonal Structure of Jordan Canonical Form\nDESCRIPTION: The overall structure of a Jordan canonical form, showing the block diagonal arrangement with different eigenvalues.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_13\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{pmatrix}\nB_1 &  &  & 0\\\\\n & B_2 &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & B_k\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Loop Macro Definition in C++\nDESCRIPTION: Using macro definitions to simplify loop syntax in competitive programming. The macro f(x,y,z) creates a for loop with predefined start and end conditions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nfor (int i = 0; i < N; i++) {\n  // 循环内容略\n}\n\n// 使用宏简化\n#define f(x, y, z) for (int x = (y), __ = (z); x < __; ++x)\n\n// 这样写循环代码时，就可以简化成 `f(i, 0, N)` 。例如：\n// a is a STL container\nf(i, 0, a.size()) { ... }\n```\n\n----------------------------------------\n\nTITLE: Matroid Intersection for Resource Allocation Problem\nDESCRIPTION: This outlines how to model a resource allocation problem using matroid intersection. It defines two matroids: one for project requirements and another for resource supply constraints, then solves their intersection.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/matroid.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n1. **拟阵建模**：\n\n   - **需求拟阵 ($M_1$)**：定义为满足各项目资源需求的分配方案，即独立集族 $\\mathcal{I}_1$ 包含所有满足项目需求的资源分配集合。\n   - **供应拟阵 ($M_2$)**：定义为不超过每种资源供应量的分配方案，即独立集族 $\\mathcal{I}_2$ 包含所有满足资源供应限制的资源分配集合。\n\n2. **求解拟阵交**：通过求解 $M = M_1 \\cap M_2$，找到既满足所有项目需求又不超过资源供应量的资源分配方案。\n```\n\n----------------------------------------\n\nTITLE: Java Variable Declaration Examples\nDESCRIPTION: Shows how to declare and initialize variables of different types in Java including integers, strings, characters and floating point numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nint a = 12; // 设置 a 为整数类型,并给 a 赋值为 12\nString str = \"Hello, OI-wiki\"; // 声明字符串变量 str\nchar ch = 'W';\ndouble PI = 3.1415926;\n```\n\n----------------------------------------\n\nTITLE: Using Comma Operator in C++\nDESCRIPTION: This code snippet demonstrates the comma operator in C++, which has the lowest precedence among all operators. It shows how expressions separated by commas are evaluated from left to right, with the result being the value of the rightmost expression.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/op.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nexp1, exp2, exp3;  // 最后的值为 exp3 的运算结果。\n\nResult = 1 + 2, 3 + 4, 5 + 6;\n//得到 Result 的值为 3 而不是 11，因为赋值运算符 \"=\"\n//的优先级比逗号运算符高，先进行了赋值运算才进行逗号运算。\n\nResult = (1 + 2, 3 + 4, 5 + 6);\n\n// 若要让 Result 的值得到逗号运算的结果则应将整个表达式用括号提高优先级，此时\n// Result 的值才为 11。\n```\n\n----------------------------------------\n\nTITLE: Pass by Value Example in C++\nDESCRIPTION: Illustrates pass-by-value function parameters, where changes to parameters inside the function do not affect the original variables outside the function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/func.md#2025-04-22_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid foo(int, int);\n\n/* ... */\n\nvoid foo(int x, int y) {\n  x = x * 2;\n  y = y + 3;\n}\n\n/* ... */\n\na = 1;\nb = 1;\n// 调用前：a = 1, b = 1\nfoo(a, b);  // 调用 foo\n            // 调用后：a = 1, b = 1\n```\n\n----------------------------------------\n\nTITLE: Power Congruence Equation\nDESCRIPTION: Congruence equation for x^n ≡ a (mod p) with conditions for solvability when n does not divide p-1 and p does not divide a.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_4\n\nLANGUAGE: math\nCODE:\n```\nx^n\\equiv a\\pmod p\\tag{9}\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 3: For p=2 When p Divides x-y (Odd n)\nDESCRIPTION: Third part of the Lifting the Exponent lemma for p=2, stating that when 2 divides x-y and n is odd, the power of 2 in x^n-y^n equals the power of 2 in x-y.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)\n```\n\n----------------------------------------\n\nTITLE: Using ensuref() Function for Condition Validation in C++\nDESCRIPTION: The ensuref() function checks if a condition is met and provides a custom error message if it fails. This example verifies that a graph doesn't contain loops by ensuring x[i] and y[i] are different.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/testlib/general.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nensuref(x[i] != y[i], \"Graph can't contain loops\");\n```\n\n----------------------------------------\n\nTITLE: Vector Coordinate Operations in LaTeX\nDESCRIPTION: LaTeX expressions for vector addition, subtraction, and scalar multiplication in coordinate form.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/vector.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n\\boldsymbol a+\\boldsymbol b&=(m+p,n+q)\\\\\n\\boldsymbol a-\\boldsymbol b&=(m-p,n-q)\\\\\nk\\boldsymbol a&=(km,kn)\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Displaying LaTeX Equation for Solution Generation\nDESCRIPTION: A LaTeX equation showing how to generate all solutions to x^2 - Dy^2 = ±1 using the PQa algorithm results.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_5\n\nLANGUAGE: LaTeX\nCODE:\n```\n(A_{\\ell-1}+B_{\\ell-1}\\sqrt{D})^k = A_{k\\ell-1}+B_{k\\ell-1}\\sqrt{D}.\n```\n\n----------------------------------------\n\nTITLE: Implementing Bottom-Up Merge Sort in C++\nDESCRIPTION: This iterative implementation of merge sort uses a bottom-up approach. It starts by treating each element as a sorted subarray of length 1, then repeatedly merges adjacent subarrays, doubling the size each time.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/merge-sort.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\nvoid merge_sort(int *a, size_t n) {\n  int tmp[1024] = {};  // 请结合实际情况设置 tmp 数组的长度（与 a 相同），或使用\n                       // vector；先将合并的结果放在 tmp 里，再返回到数组 a\n  for (size_t seg = 1; seg < n; seg <<= 1) {\n    for (size_t left1 = 0; left1 < n - seg;\n         left1 += seg + seg) {  // n - seg: 如果最后只有一个段就不用合并\n      size_t right1 = left1 + seg;\n      size_t left2 = right1;\n      size_t right2 = std::min(left2 + seg, n);  // <!> 注意最后一个段的边界\n      merge(a + left1, a + right1, a + left2, a + right2,\n            tmp + left1);  // pointer-style merge\n      for (size_t i = left1; i < right2; ++i) a[i] = tmp[i];\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Proving Non-existence of Primitive Roots for Certain Cases in LaTeX\nDESCRIPTION: This LaTeX code proves the non-existence of primitive roots for certain cases using binomial expansion and modular arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/primitive-root.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n    a^{2^{\\alpha-2}}&=(2k+1)^{2^{\\alpha-2}}\\\\\n    &\\equiv 1+\\binom{2^{\\alpha-2}}{1}(2k)+\\binom{2^{\\alpha-2}}{2}(2k)^{2} \\pmod {2^{\\alpha}}\\\\\n    &\\equiv1+2^{\\alpha-1}k+2^{\\alpha-1}(2^{\\alpha-2}-1)k^2 \\pmod {2^{\\alpha}}\\\\\n    &\\equiv 1+2^{\\alpha-1}(k+(2^{\\alpha-2}-1)k^2) \\pmod {2^{\\alpha}}\\\\\n    &\\equiv 1 \\pmod {2^{\\alpha}}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Lagged Fibonacci Random Number Generator Implementation in C++\nDESCRIPTION: Implements a lagged Fibonacci random number generator. Shows an advanced technique for generating pseudo-random numbers with a longer period than simple linear congruential generators.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_7\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct myrand {\n  vector<unsigned> vec;\n  int l, j, k, cur;\n\n  myrand(int l, int j, int k) {\n    this->l = l;\n    this->j = j;\n    this->k = k;\n    cur = 0;\n    for (int i = 0; i < l; i++) {\n      vec.push_back(rand());\n    }\n  }\n\n  unsigned next() {\n    vec[cur] = vec[(cur - j + l) % l] * vec[(cur - k + l) % l];\n    return vec[cur++];\n  }\n};\n\nmyrand rnd(11, 4, 7);\n\nint main() {\n  unsigned x = rnd.next();\n  cout << x << endl;\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: DAG Path Checker - Suboptimal Implementation\nDESCRIPTION: A non-ideal implementation of a checker for validating longest paths in a DAG. Shows common mistakes like not validating jury answer and code duplication.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/testlib/checker.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"testlib.h\"\n#include <map>\n#include <vector>\nusing namespace std;\n\nmap<pair<int, int>, int> edges;\n\nint main(int argc, char* argv[]) {\n  registerTestlibCmd(argc, argv);\n  int n = inf.readInt();\n  int m = inf.readInt();\n  for (int i = 0; i < m; i++) {\n    int a = inf.readInt();\n    int b = inf.readInt();\n    int w = inf.readInt();\n    edges[make_pair(a, b)] = edges[make_pair(b, a)] = w;\n  }\n  int s = inf.readInt();\n  int t = inf.readInt();\n\n  int jvalue = 0;\n  vector<int> jpath;\n  int jlen = ans.readInt();\n  for (int i = 0; i < jlen; i++) {\n    jpath.push_back(ans.readInt());\n  }\n  for (int i = 0; i < jlen - 1; i++) {\n    jvalue += edges[make_pair(jpath[i], jpath[i + 1])];\n  }\n\n  int pvalue = 0;\n  vector<int> ppath;\n  vector<bool> used(n);\n  int plen = ouf.readInt(2, n, \"number of vertices\");\n  for (int i = 0; i < plen; i++) {\n    int v = ouf.readInt(1, n, format(\"path[%d]\", i + 1).c_str());\n    if (used[v - 1])\n      quitf(_wa, \"vertex %d was used twice\", v);\n    used[v - 1] = true;\n    ppath.push_back(v);\n  }\n  if (ppath.front() != s)\n    quitf(_wa, \"path doesn't start in s: expected s = %d, found %d\", s, ppath.front());\n  if (ppath.back() != t)\n    quitf(_wa, \"path doesn't finish in t: expected t = %d, found %d\", t, ppath.back());\n  for (int i = 0; i < plen - 1; i++) {\n    if (edges.find(make_pair(ppath[i], ppath[i + 1])) == edges.end())\n      quitf(_wa, \"there is no edge (%d, %d) in the graph\", ppath[i], ppath[i + 1]);\n    pvalue += edges[make_pair(ppath[i], ppath[i + 1])];\n  }\n\n  if (jvalue != pvalue)\n    quitf(_wa, \"jury has answer %d, participant has answer %d\", jvalue, pvalue);\n  else\n    quitf(_ok, \"answer = %d\", pvalue);\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Angle Between Line and Plane in 3D Space (LaTeX)\nDESCRIPTION: Presents the formula for calculating the sine of the angle between a line and a plane in 3D space, using the line's direction vector and the plane's normal vector.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/3d.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n$$\nsin\\varphi = \\dfrac{\\left | am + bn + cp \\right |}{\\sqrt{a^2+b^2+c^2}\\sqrt{m^2+n^2+p^2}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Vector Rotation Formula in LaTeX\nDESCRIPTION: LaTeX expression for the coordinates of a vector after rotation by an angle alpha.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/vector.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\boldsymbol b=(x\\cos\\alpha-y\\sin\\alpha,y\\cos\\alpha+x\\sin\\alpha)\n```\n\n----------------------------------------\n\nTITLE: Definition of Maximal Ideals in Ring Theory\nDESCRIPTION: The definition of a maximal ideal, which is a proper ideal not strictly contained in any other proper ideal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_11\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"极大理想\"\n    对于环 $R$ 和它的理想 $M$，如果 $M\\neq R$，且包含 $M$ 的 $R$ 的理想只有 $M$ 和 $R$ 两个，则称理想 $M$ 是一个 **极大理想**（maximal ideal）。\n```\n\n----------------------------------------\n\nTITLE: Edge Count Upper Bound for Connected Planar Graphs\nDESCRIPTION: This inequality provides an upper bound for the number of edges (m) in a connected planar graph G, where each face has a degree of at least l (l ≥ 3), and n is the number of vertices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/planar.md#2025-04-22_snippet_2\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\nm \\leq \\frac{l}{l-2}(n-2)\n```\n\n----------------------------------------\n\nTITLE: Performing Advanced Mathematical Operations with BigInteger in Java\nDESCRIPTION: This code snippet demonstrates advanced mathematical operations using the BigInteger class in Java, including greatest common divisor (GCD), primality testing, finding the next probable prime, modular exponentiation, and modular multiplicative inverse.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_7\n\nLANGUAGE: Java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static BigInteger a, b, p;\n\n    static void gcd() {  // 最大公约数 \n        a = new BigInteger(\"120032414321432144212100\");\n        b = new BigInteger(\"240231431243123412432140\");\n        out.println(String.format(\"gcd(%s,%s)=%s\", a.toString(), b.toString(), a.gcd(b).toString()));  // gcd(120032414321432144212100,240231431243123412432140)=20 \n    }\n\n    static void isPrime() {  // 基于米勒罗宾判定该数是否是素数，参数越大准确性越高，复杂度越高。准确性为 (1-1/(val*2)) \n        a = new BigInteger(\"1200324143214321442127\");\n        out.println(\"a:\" + a.toString());\n        out.println(a.isProbablePrime(10) ? \"a is prime\" : \"a is not prime\");  // a is not prime \n    }\n\n    static void nextPrime() {  // 找出该数的下一个素数 \n        a = new BigInteger(\"1200324143214321442127\");\n        out.println(\"a:\" + a.toString());\n        out.println(String.format(\"a nextPrime is %s\", a.nextProbablePrime().toString()));  // a nextPrime is 1200324143214321442199 \n    }\n\n    static void modPow() {  // 快速幂，比正常版本要快，内部有数学优化 \n        a = new BigInteger(\"2\");\n        b = new BigInteger(\"10\");\n        p = new BigInteger(\"1000\");\n        out.println(String.format(\"a:%s b:%s p:%s\", a, b, p));\n        out.println(String.format(\"a^b mod p:%s\", a.modPow(b, p).toString()));//  24 \n    }\n\n    static void modInverse() {  // 逆元 \n        a = new BigInteger(\"10\");\n        b = new BigInteger(\"3\");\n        out.println(a.modInverse(b));  // a ^ (p-2) mod p = 1 \n    }\n\n    public static void main(String[] args) {\n        gcd();\n        isPrime();\n        nextPrime();\n        modPow();\n        modInverse();\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Common Restricted Constructions\nDESCRIPTION: Set of formulas showing common restricted constructions for PSET, MSET, and CYC operations with k=2,3,4.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\operatorname{PSET} _ {2}(\\mathcal{A})&:\\quad \\frac{A(z)^2}{2}-\\frac{A(z^2)}{2}\\\\\n\\operatorname{MSET} _ {2}(\\mathcal{A})&:\\quad \\frac{A(z)^2}{2}+\\frac{A(z^2)}{2}\\\\\n\\operatorname{CYC} _ {2}(\\mathcal{A})&:\\quad \\frac{A(z)^2}{2}+\\frac{A(z^2)}{2}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Edge Count Upper Bound for Planar Graphs with Multiple Connected Components\nDESCRIPTION: This inequality extends the edge count upper bound to planar graphs with p (p ≥ 2) connected components, where each face has a degree of at least l (l ≥ 3), and n is the number of vertices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/planar.md#2025-04-22_snippet_3\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\nm \\leq \\frac{l}{l-2}(n-p-1)\n```\n\n----------------------------------------\n\nTITLE: Struct Declaration in C\nDESCRIPTION: Shows the traditional C-style struct declaration with typedef, demonstrating more verbose syntax required in C.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/cpp-other-langs.md#2025-04-22_snippet_1\n\nLANGUAGE: C\nCODE:\n```\ntypedef struct Node_t {\n  struct Node_t *next;\n  int key;\n} Node;\n```\n\n----------------------------------------\n\nTITLE: Coordinate Systems Reference Table in Markdown and LaTeX\nDESCRIPTION: A structured table describing three-dimensional coordinate systems (Cartesian, cylindrical, and spherical) with their position vectors, differentials, and basis vectors. Includes mathematical notation in LaTeX format.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n| 编号    | 坐标                        | 位置向量和微分                                                                                                                                                                                                                      | 坐标名   | 备注                                                                                                                                                                                                                                                   |\n| ----- | ------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| n13.1 | $x$，$y$，$z$               | $\\boldsymbol{r} = x \\boldsymbol{e}_x + y \\boldsymbol{e}_y + z \\boldsymbol{e}_z$;<br>$\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}x~\\boldsymbol{e}_x + \\mathrm{d}y~\\boldsymbol{e}_y + \\mathrm{d}z~\\boldsymbol{e}_z$                  | 笛卡尔坐标 | 基向量 $\\boldsymbol{e}_x$，$\\boldsymbol{e}_y$，$\\boldsymbol{e}_z$ 构成右手正交系，见图 1 和图 4。<br>基向量也可用 $\\boldsymbol{e}_1$，$\\boldsymbol{e}_2$，$\\boldsymbol{e}_3$ 或 $\\boldsymbol{i}$，$\\boldsymbol{j}$，$\\boldsymbol{k}$ 表示，坐标也可用 $x_1$，$x_2$，$x_3$ 或 $i$，$j$，$k$ 表示。 |\n| n13.2 | $\\rho$，$\\varphi$，$z$      | $\\boldsymbol{r} = \\rho~\\boldsymbol{e}_{\\rho} + z~\\boldsymbol{e}_z$;<br>$\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}\\rho~\\boldsymbol{e}_{\\rho} +\\rho~\\mathrm{d}\\varphi~\\boldsymbol{e}_{\\varphi} + \\mathrm{d}z~\\boldsymbol{e}_z$     | 柱坐标   | $\\boldsymbol{e}_{\\rho}(\\varphi)$，$\\boldsymbol{e}_{\\varphi}(\\varphi)$，$\\boldsymbol{e}_z$ 组成右手正交系，见图 2。<br>若 $z = 0$, 则 $\\rho$ 和 $\\varphi$ 是平面上的极坐标。                                                                                                   |\n| n13.3 | $r$，$\\vartheta$，$\\varphi$ | $\\boldsymbol{r} = r \\boldsymbol{e}_r$;<br>$\\mathrm{d}\\boldsymbol{r} = \\mathrm{d}r~\\boldsymbol{e}_r + r~\\mathrm{d}\\vartheta~\\boldsymbol{e}_{\\vartheta} + r~\\sin\\vartheta~\\mathrm{\\mathrm{d}}\\varphi~\\boldsymbol{e}_{\\varphi}$ | 球坐标   | $\\boldsymbol{e}_r(\\vartheta, \\varphi)$，$\\boldsymbol{e}_{\\vartheta}(\\vartheta, \\varphi)$，$\\boldsymbol{e}_{\\varphi}(\\varphi)$ 组成右手正交系，见图 3。                                                                                                            |\n```\n\n----------------------------------------\n\nTITLE: Cross-Row Algebraic Cofactor Product Sum Theorem\nDESCRIPTION: Formula showing that the sum of products of elements from one row with algebraic cofactors from a different row equals zero, an important property of determinants.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\na_{i1}A_{j1}+a_{i2}A_{j2}+\\cdots+a_{in}A_{jn}=0\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 3 of LTE Lemma - Factorization\nDESCRIPTION: Part of the proof for the third part of the Lifting the Exponent lemma, showing the factorization of x^n-y^n when n is even.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_13\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n    \\nu_p\\left(x^n-y^n\\right)&=\\nu_p\\left(x^{2^a}-y^{2^a}\\right)\\\\\n    &=\\nu_p\\left((x-y)(x+y)\\prod_{i=1}^{a-1}\\left(x^{2^i}+y^{2^i}\\right)\\right)\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Optimized Enumeration in Python\nDESCRIPTION: An optimized version of the enumeration algorithm that reduces the search space by only considering pairs where the first number appears earlier in the array.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/enumerate.md#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nfor i in range(n):\n    for j in range(i):\n        if a[i] + a[j] == 0:\n            ans += 1\n```\n\n----------------------------------------\n\nTITLE: Using Break for More Natural Loop Structure in C++\nDESCRIPTION: Comparison of while loops with and without break statements, showing how break can eliminate repetition and improve flow.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\n// 语句重复，顺序不自然\n\nstatement1;\nwhile (statement3) {\n  statement2;\n  statement1;\n}\n\n// 没有重复语句，顺序自然\n\nwhile (1) {\n  statement1;\n  if (!statement3) break;\n  statement2;\n}\n```\n\n----------------------------------------\n\nTITLE: Constant Sequence EGF\nDESCRIPTION: Exponential generating function for the constant sequence of ones\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/egf.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\hat{F}(x) = \\sum_{n \\ge 0}\\frac{x^n}{n!} = \\mathrm{e}^x\n```\n\n----------------------------------------\n\nTITLE: Formal Derivative of Power Series\nDESCRIPTION: Defines the formal derivative operation for power series.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_2\n\nLANGUAGE: Mathematics\nCODE:\n```\n\\left(\\sum_{k=0}^{+\\infty}f_kx^k\\right)'=\\sum_{k=1}^{+\\infty}kf_kx^{k-1}\n```\n\n----------------------------------------\n\nTITLE: Definition of Quotient Group Elements\nDESCRIPTION: Mathematical expression defining the set of elements in a quotient group G/N\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nG/N = \\{gN:g\\in G\\}\n```\n\n----------------------------------------\n\nTITLE: Starting Xfce4 Desktop Environment in WSL\nDESCRIPTION: Command to start the Xfce4 desktop environment session in WSL when using X11 forwarding to Windows.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_7\n\nLANGUAGE: console\nCODE:\n```\n$ xfce4-session\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 2 of LTE Lemma - Binomial Expansion\nDESCRIPTION: Part of the proof for the second part of the Lifting the Exponent lemma, showing a binomial expansion and congruence relation when n=p.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n    \\sum_{i=0}^{p-1}x^{p-1-i}y^i&=\\sum_{i=0}^{p-1}x^{p-1-i}\\sum_{j=0}^i\\binom{i}{j}x^j(kp)^{i-j}\\\\\n    &\\equiv px^{p-1} \\pmod{p^2}\\\\\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Definition of Natural Homomorphism in Ring Theory\nDESCRIPTION: The definition of the natural homomorphism from a ring to its quotient ring by an ideal, which maps each element to its coset.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_6\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"自然同态\"\n    对于环 $R$ 和它的理想 $I$，则由 $\\pi(r)=r+I$ 给出的映射 $\\pi:R\\rightarrow R/I$ 是自 $R$ 到 $R/I$ 的满同态，称为自环 $R$ 到商环 $R/I$ 的 **自然同态**（natural homomorphism）。\n```\n\n----------------------------------------\n\nTITLE: Arbitrary Modulus Polynomial Class Definition\nDESCRIPTION: Class implementation for polynomials with arbitrary modulus arithmetic, including basic operations and mathematical functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nclass arbitrary_module_poly {\n private:\n  std::vector<int> data;\n\n  int construct_element(int D, ll x, ll y, ll z) const {\n    x %= mod, y %= mod, z %= mod;\n    return ((ll)D * D * x % mod + (ll)D * y % mod + z) % mod;\n  }\n\n public:\n  int mod;\n\n  arbitrary_module_poly(std::size_t len = std::size_t(0),\n                        int module_value = 1e9 + 7) {\n    mod = module_value;\n    data = std::vector<int>(len);\n  }\n\n  /* ... Rest of class implementation ... */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining an Addition Matrix in LaTeX\nDESCRIPTION: Mathematical definition of an addition matrix T_ij(k), which is formed by adding k times the j-th row to the i-th row of an identity matrix.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_2\n\nLANGUAGE: tex\nCODE:\n```\nT_{ij}(k)=\\begin{pmatrix}\n1 &  &  &  &  &  & \\\\\n & \\ddots &  &  &  &  & \\\\\n &  & 1 & \\cdots & k &  & \\\\\n &  &  & \\ddots & \\vdots &  & \\\\\n &  &  &  & 1 &  & \\\\\n &  &  &  &  & \\ddots & \\\\\n &  &  &  &  &  & 1\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Creating Markdown Table for Donation Records\nDESCRIPTION: This snippet shows a markdown table listing donation records for the OI Wiki project. Each row includes the donor ID (some anonymized), the donation amount in Chinese Yuan, and the date of the donation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/thanks.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n|       id      |  amount |    date    |\n| :-----------: | :-----: | :--------: |\n|     匿名捐赠者     |   10 元  |  2021.6.20 |\n|     匿名捐赠者     |  100 元  |  2021.6.10 |\n|     wood3     |  256 元  |  2021.6.4  |\n|      海外兔      |  102 元  |  2021.5.12 |\n|      逐梦之人     |  80.7 元 |  2021.5.3  |\n|    十寸雨 zsg    | 10.24 元 |  2021.2.27 |\n|     匿名捐赠者     |   2 元   | 2020.12.10 |\n|    吾有一數名之曰誒   | 10.24 元 | 2020.10.19 |\n|      Huah     |   66 元  |  2020.9.7  |\n|   icedream61  |   66 元  |  2020.9.2  |\n|     三鸽酸鸽可爱    |  2.33 元 |  2020.8.31 |\n|    Apoi2333   | 23.33 元 |  2020.8.31 |\n|      草莓熊      |   50 元  |  2020.7.4  |\n|     匿名捐赠者     |  200 元  |  2020.6.29 |\n|     Hiroid    |   30 元  |  2020.5.13 |\n|     dcmfqw    | 20.48 元 |  2020.5.4  |\n|     akira     |   66 元  |  2020.3.30 |\n|    Hermione   |   10 元  |  2020.3.26 |\n|     Siyuan    |   10 元  |  2020.2.28 |\n|      hsh      |   15 元  |  2020.2.21 |\n|       陌陌      |   10 元  |  2020.2.6  |\n|     匿名捐赠者     |   10 元  |  2020.2.5  |\n|     Yisin     |   10 元  |  2020.2.4  |\n|    GinRyan    |   50 元  | 2019.11.30 |\n|    JuicyMio   |   10 元  | 2019.11.30 |\n|     匿名捐赠者     |   10 元  | 2019.11.14 |\n|    QQ 联系 12   |   5 元   | 2019.10.28 |\n|     匿名捐赠者     |   5 元   | 2019.10.27 |\n|     增肥中的小肥    |   50 元  | 2019.10.24 |\n|    ianahao    |   10 元  | 2019.10.12 |\n|     Sundy     |   10 元  | 2019.10.11 |\n|     三鸽最可爱     | 23.33 元 |  2019.8.17 |\n|     Fburan    | 10.24 元 |  2019.8.17 |\n|     匿名捐赠者     |   30 元  |  2019.8.8  |\n| Billchenchina |  100 元  |  2019.8.7  |\n|   贷款捐头的匿名入土   |   30 元  |  2019.8.4  |\n|     sshwy     |   50 元  |  2019.8.4  |\n|     匿名捐赠者     |   10 元  |  2018.9.9  |\n|     匿名捐赠者     |   20 元  |  2018.8.31 |\n|    Xeonacid   |   30 元  |  2018.8.30 |\n|     匿名捐赠者     |  240 元  |  2018.8.29 |\n|     Anguei    |   5 元   |  2018.8.29 |\n```\n\n----------------------------------------\n\nTITLE: Random Data Generation using rand() and random_shuffle() in C++\nDESCRIPTION: Generates random test data for a problem using the rand() function and random_shuffle() algorithm. Demonstrates basic usage of these standard library functions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/random.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n\nint a[100];\n\nint main() {\n  srand(time(nullptr));\n  int n = rand() % 99 + 1;\n  for (int i = 1; i <= n; i++) a[i] = i;\n  std::cout << n << '\\n';\n  for (int i = 1; i <= n; i++) {\n    std::random_shuffle(a + 1, a + i);\n    int cnt = rand() % i;\n    for (int j = 1; j <= cnt; j++) std::cout << a[j] << ' ';\n    std::cout << 0 << '\\n';\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Euler's Formula for Planar Graphs with Multiple Connected Components\nDESCRIPTION: This formula extends Euler's formula to planar graphs with p (p ≥ 2) connected components. It states that for such a graph G, n - m + r = p + 1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/planar.md#2025-04-22_snippet_1\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\nn-m+r=p+1\n```\n\n----------------------------------------\n\nTITLE: Defining a Polynomial in Ring R\nDESCRIPTION: Represents a polynomial as a sequence of coefficients from ring R.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/intro.md#2025-04-22_snippet_0\n\nLANGUAGE: Mathematics\nCODE:\n```\nf=<f_0,f_1,f_2,\\cdots,f_n>\\quad(f_0,f_1,f_2,\\cdots,f_n\\in R)\n```\n\n----------------------------------------\n\nTITLE: Second Isomorphism Theorem for Rings\nDESCRIPTION: The statement of the second isomorphism theorem for rings, relating a subring and an ideal to their sum and intersection.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_7\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"第二同构定理\"\n    设环 $R$ 有子环 $A$ 和理想 $B$，那么 $A+B=\\{a+b:a\\in A,b\\in B\\}$ 同样是 $R$ 的子环，而 $A\\cap B$ 是 $A$ 的理想，$B$ 是 $A+B$ 的理想，并且 $(A+B)/B\\cong A/(A\\cap B)$。\n```\n\n----------------------------------------\n\nTITLE: Generic Jordan Standard Form Structure\nDESCRIPTION: The general structure of a Jordan standard form with multiple Jordan blocks arranged in a block-diagonal fashion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_17\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{pmatrix}\nJ_1 &  &  & 0\\\\\n & J_2 &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & J_m\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Constructing a Custom __gnu_pbds::tree with Order Statistics\nDESCRIPTION: Example of constructing a tree container that allows tracking order statistics. This example creates a tree that stores pairs of integers and supports operations like finding elements by rank and determining the rank of elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pb-ds/tree.md#2025-04-22_snippet_1\n\nLANGUAGE: c++\nCODE:\n```\n__gnu_pbds::tree<std::pair<int, int>, __gnu_pbds::null_type,\n                 std::less<std::pair<int, int>>, __gnu_pbds::rb_tree_tag,\n                 __gnu_pbds::tree_order_statistics_node_update>\n    trr;\n```\n\n----------------------------------------\n\nTITLE: Defining Multiplicative Inverse in Formal Laurent Series\nDESCRIPTION: This snippet defines the multiplicative inverse of an element in the formal Laurent series ring, using a recursive formula.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/lagrange-inversion.md#2025-04-22_snippet_1\n\nLANGUAGE: TeX\nCODE:\n```\ng_k:=\n\\begin{cases}\nf_N^{-1}, &\\text{ if }k=-N\\text{,} \\\\\n-f_N^{-1}\\sum_{i> N}f_ig_{k-i}, &\\text{ otherwise}\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Block Structure for Each Eigenvalue in Jordan Form\nDESCRIPTION: The structure of blocks corresponding to a single eigenvalue in the Jordan canonical form.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_14\n\nLANGUAGE: latex\nCODE:\n```\nB_i=\\begin{pmatrix}\nJ_{i1} &  &  & 0\\\\\n & J_{i2} &  & \\\\\n &  & \\ddots & \\\\\n0 &  &  & J_{is_i}\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Configuring LSP Servers in Kate\nDESCRIPTION: JSON configuration for setting up Language Server Protocol (LSP) servers in Kate. This snippet defines server configurations for various programming languages including BibTeX, C/C++, Haskell, LaTeX, and Rust.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/editor/kate.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"servers\": {\n        \"bibtex\": {\n            \"use\": \"latex\",\n            \"highlightingModeRegex\": \"^BibTeX$\"\n        },\n        \"c\": {\n            \"command\": [\"clangd\", \"-log=error\", \"--background-index\"],\n            \"commandDebug\": [\"clangd\", \"-log=verbose\", \"--background-index\"],\n            \"url\": \"https://clang.llvm.org/extra/clangd/\",\n            \"highlightingModeRegex\": \"^(C|ANSI C89|Objective-C)$\"\n        },\n        \"cpp\": {\n            \"use\": \"c\",\n            \"highlightingModeRegex\": \"^(C\\\\+\\\\+|ISO C\\\\+\\\\+|Objective-C\\\\+\\\\+)$\"\n        },\n        \"haskell\": {\n            \"command\": [\"haskell-language-server-wrapper\", \"--lsp\"],\n            \"rootIndicationFileNames\": [\"*.cabal\", \"stack.yaml\", \"cabal.project\", \"package.yaml\"],\n            \"url\": \"https://github.com/haskell/haskell-language-server\",\n            \"highlightingModeRegex\": \"^Haskell$\"\n        },\n        \"latex\": {\n            \"command\": [\"texlab\"],\n            \"url\": \"https://texlab.netlify.com/\",\n            \"highlightingModeRegex\": \"^LaTeX$\"\n        },\n        \"rust\": {\n            \"command\": [\"rls\"],\n            \"rootIndicationFileNames\": [\"Cargo.lock\", \"Cargo.toml\"],\n            \"url\": \"https://github.com/rust-lang/rls\",\n            \"highlightingModeRegex\": \"^Rust$\"\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Classification of Finitely Generated Abelian Groups\nDESCRIPTION: This LaTeX snippet shows the fundamental theorem of finitely generated Abelian groups, expressing such a group as a direct product of infinite cyclic groups and finite cyclic groups.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_12\n\nLANGUAGE: LaTeX\nCODE:\n```\nG\\cong C_\\infty^r\\times C_{n_1}\\times\\cdots\\times C_{n_s}.\n```\n\n----------------------------------------\n\nTITLE: Defining Linear Programming Problem in LaTeX\nDESCRIPTION: LaTeX code defining a linear programming problem with objective function and constraints\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/simplex.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\max \\ z = x_1 + x_2\n\ns.t \\begin{cases}  \n2x_1 + x_2 \\leq 12 \\\\ \nx_1 + 2x_2 \\leq 9  \\\\\nx_1, x_2 \\geq 0\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Extend Procedure for Schreier-Sims Algorithm (Pseudocode)\nDESCRIPTION: The Extend procedure adds a new generator to the stabilizer chain, performing sifting and updating orbits, transversals, and Schreier generators as needed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/schreier-sims.md#2025-04-22_snippet_4\n\nLANGUAGE: pseudocode\nCODE:\n```\n\\begin{array}{l}\n\\textbf{Algorithm }\\textrm{Extend}(C,g):\\\\\n\\textbf{Input. }\\textrm{A stabilizer chain }C\\textrm{ for the group generated by }S\\textrm{ and a}\\\\\n\\qquad \\textrm{permutation }g.\\\\\n\\textbf{Output. }\\textrm{A stabilizer chain }C\\textrm{ for the group generated by }S\\cup\\{g\\}.\\\\\n\\textbf{Method.}\\\\\n\\begin{array}{ll}\n1  & \\textbf{if }\\textrm{MembershipTest}(C,g)\\textrm{ is passed}\\textbf{ then}\\\\\n2  & \\qquad \\textbf{return }C\\\\\n3  & \\textbf{end if}\\\\\n4  & \\textbf{if }C\\textrm{ is empty}\\textbf{ then}\\\\\n5  & \\qquad \\beta \\leftarrow \\textrm{an element moved by }g\\\\\n6  & \\qquad C.orbit[0] \\leftarrow \\beta \\\\\n7  & \\qquad C.transversal[\\beta] \\leftarrow e\\\\\n8  & \\textbf{end if}\\\\\n9  & \\textrm{append }g\\textrm{ to }C.generators\\\\\n10  & \\Delta \\leftarrow C.orbit \\\\\n11 & \\textbf{for }\\delta\\in\\Delta \\\\\n12 & \\qquad \\gamma \\leftarrow \\delta^g \\\\\n13 & \\qquad \\textbf{if }\\gamma\\notin C.orbit\\textbf{ then}\\\\\n14 & \\qquad \\qquad \\textrm{append }\\gamma\\textrm{ to }C.orbit\\\\\n15 & \\qquad \\qquad C.transversal[\\gamma] \\leftarrow C.transversal[\\delta]\\cdot g\\\\\n16 & \\qquad \\textbf{else}\\\\\n17 & \\qquad \\qquad s'\\leftarrow C.transversal[\\delta]\\cdot g\\cdot C.transversal[\\gamma]^{-1}\\\\\n18 & \\qquad \\qquad C.next \\leftarrow \\textrm{Extend}(C.next, s')\\\\\n19 & \\qquad \\textbf{end if}\\\\\n20 & \\textbf{end for} \\\\\n21 & \\textbf{for }\\delta\\in C.orbit\\setminus\\Delta \\\\ \n22 & \\qquad \\textbf{for }s\\in C.generators \\\\\n23 & \\qquad \\qquad \\gamma \\leftarrow \\delta^s \\\\\n24 & \\qquad \\qquad \\textbf{if }\\gamma\\notin C.orbit\\textbf{ then}\\\\\n25 & \\qquad \\qquad \\qquad \\textrm{append }\\gamma\\textrm{ to }C.orbit\\\\\n26 & \\qquad \\qquad \\qquad C.transversal[\\gamma] \\leftarrow C.transversal[\\delta]\\cdot s\\\\\n27 & \\qquad \\qquad \\textbf{else}\\\\\n28 & \\qquad \\qquad \\qquad s'\\leftarrow C.transversal[\\delta]\\cdot s\\cdot C.transversal[\\gamma]^{-1}\\\\\n29 & \\qquad \\qquad \\qquad \\textrm{Extend}(C.next, s')\\\\\n30 & \\qquad \\qquad \\textbf{end if}\\\\\n31 & \\qquad \\textbf{end for}\\\\\n32 & \\textbf{end for} \\\\\n33 & \\textbf{return }C\n\\end{array}\n\\end{array}\n```\n\n----------------------------------------\n\nTITLE: Generating Edit URL with JavaScript\nDESCRIPTION: This script generates the URL for editing the current page on GitHub. It extracts the page reference from the URL query string and constructs the full edit link.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/edit-landing.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n<script>\n\tfunction getQueryVariable(name, dft)\n\t{\n\t\tvar reg = new RegExp('(^|&)' + name + '=([^&]*)(&|$)', 'i');\n\t\tvar r = window.location.search.substr(1).match(reg);\n\t\tif (r != null)\n\t\t{\n\t\t\treturn unescape(r[2]);\n\t\t}\n\t\treturn dft;\n\t}\n\tdocument.getElementById(\"btn-startedit\").href = \"https://github.com/OI-wiki/OI-wiki/edit/master/docs\" + getQueryVariable(\"ref\", \"\");\n</script>\n```\n\n----------------------------------------\n\nTITLE: Void Function (Procedure) Comparison\nDESCRIPTION: Example showing how Pascal procedures are implemented as void functions in C++, demonstrating the use of return statement and function declaration differences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_12\n\nLANGUAGE: Pascal\nCODE:\n```\nvar ans: integer;\n\nprocedure printAns(ans:integer);\nbegin\n    writeln(ans);\nend;\n\nbegin\n    ans := 10;\n    printAns(ans);\nend.\n```\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>\n\nvoid printAns(int ans) {\n  std::cout << ans << std::endl;\n\n  return;\n}\n\nint main() {\n  int ans = 10;\n  printAns(ans);\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Java String Creation Examples\nDESCRIPTION: Demonstrates different ways to create String objects in Java, including direct assignment and character array conversion.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java.md#2025-04-22_snippet_4\n\nLANGUAGE: java\nCODE:\n```\n// 最为简单的构造一个字符串变量的方法如下\nString a = \"Hello\";\n\n// 还可以使用字符数组构造一个字符串变量\nchar[] stringArray = { 'H', 'e', 'l', 'l', 'o' };\nString s = new String(stringArray);\n```\n\n----------------------------------------\n\nTITLE: Basic EGF Definition in LaTeX\nDESCRIPTION: Defines the exponential generating function for sequence a as a formal power series\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/egf.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\hat{F}(x)=\\sum_{n}a_n \\frac{x^n}{n!}\n```\n\n----------------------------------------\n\nTITLE: Definition of Multiplicative and Completely Multiplicative Functions\nDESCRIPTION: Mathematical definition of multiplicative functions in number theory, including both multiplicative and completely multiplicative function definitions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/basic.md#2025-04-22_snippet_3\n\nLANGUAGE: Markdown\nCODE:\n```\n???+ note \"定义\"\n    在数论中，若函数 $f(n)$ 满足 $f(1)=1$，且 $f(xy)=f(x)f(y)$ 对任意互质的 $x, y \\in\\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **积性函数**。\n    \n    在数论中，若函数 $f(n)$ 满足 $f(1)=1$ 且 $f(xy)=f(x)f(y)$ 对任意的 $x, y \\in\\mathbf{N}^*$ 都成立，则 $f(n)$ 为 **完全积性函数**。\n```\n\n----------------------------------------\n\nTITLE: Operator Precedence Error in C++\nDESCRIPTION: This example shows how incorrect operator precedence can lead to unexpected results. Without proper parentheses, operations will be executed according to operator precedence rules rather than the intended order.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// 错误\n// std::cout << (1 << 1 + 1);\n// 正确\nstd::cout << ((1 << 1) + 1);\n\n// 警告    「<<」: 检查运算符优先级是否有可能的错误；使用括号阐明优先级\n```\n\n----------------------------------------\n\nTITLE: Constructing the Diagonalizable Component\nDESCRIPTION: Formula for constructing the diagonalizable component of a linear transformation in the Jordan decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\nT_D=\\lambda_1 T_1+\\lambda_2 T_2+\\cdots+\\lambda_k T_k\n```\n\n----------------------------------------\n\nTITLE: Polynomial Addition Operation in LaTeX\nDESCRIPTION: Mathematical formula showing how two polynomials are added term by term.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_26\n\nLANGUAGE: latex\nCODE:\n```\nf(x)+g(x) = (a_0+b_0)+(a_1+b_1)x+\\cdots+(a_{n-1}+b_{n-1})x^{n-1}+(a_n+b_n)x^n\n```\n\n----------------------------------------\n\nTITLE: Handling Case 3 in Red-Black Tree Insertion\nDESCRIPTION: Handles the case where the parent node is the root and is red during insertion. Simply paints the parent node black to maintain red-black tree properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n// clang-format off\n// Case 3: Parent is root and is RED\n//   Paint parent to BLACK.\n//    <P>         [P]\n//     |   ====>   |\n//    <N>         <N>\n//   p.s.\n//    `<X>` is a RED node;\n//    `[X]` is a BLACK node (or NIL);\n//    `{X}` is either a RED node or a BLACK node;\n// clang-format on\nassert(node->parent->isRed());\nnode->parent->color = Node::BLACK;\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Defining Primitive Root Existence Theorem in LaTeX\nDESCRIPTION: This LaTeX code defines the primitive root existence theorem, stating the conditions under which a number m has primitive roots.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/primitive-root.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n???+ note \"原根存在定理\"\n    一个数 $m$ 存在原根当且仅当 $m=2,4,p^{\\alpha},2p^{\\alpha}$，其中 $p$ 为奇素数，$\\alpha\\in \\mathbf{N}^{*}$.\n```\n\n----------------------------------------\n\nTITLE: Naive Factorization Algorithm in C++\nDESCRIPTION: A simple algorithm that finds all prime factors of a number N by testing divisibility from 2 to sqrt(N). This implementation returns a vector containing all prime factors of the input number.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pollard-rho.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nvector<int> breakdown(int N) {\n  vector<int> result;\n  for (int i = 2; i * i <= N; i++) {\n    if (N % i == 0) {  // 如果 i 能够整除 N，说明 i 为 N 的一个质因子。\n      while (N % i == 0) N /= i;\n      result.push_back(i);\n    }\n  }\n  if (N != 1) {  // 说明再经过操作之后 N 留下了一个素数\n    result.push_back(N);\n  }\n  return result;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Determinant Using Permutation Method\nDESCRIPTION: Mathematical definition of a determinant using the permutation method, expressing it as the sum of products of matrix elements with appropriate signs determined by permutation inversions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\det A &= \\begin{vmatrix}\na_{11} & a_{12} & \\cdots & a_{1n}\\\\\na_{21} & a_{22} & \\cdots & a_{2n}\\\\\n\\vdots & \\vdots &  & \\vdots\\\\\na_{n1} & a_{n2} & \\cdots & a_{nn}\\\\\n\\end{vmatrix} \\\\\n&= \\sum_{(j_1j_2\\cdots j_n) \\in S_n} (-1)^{\\pi(j_1j_2\\cdots j_n)} a_{1 j_1} a_{2 j_2}\\dots a_{n j_n}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Definition of Subspace Projections\nDESCRIPTION: Mathematical formulation of the projection transformations onto subspaces in the Jordan decomposition process.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nT_i=u_i(T)\\frac{m_A(T)}{{(T-\\lambda_i T_e)}^{r_i}}\n```\n\n----------------------------------------\n\nTITLE: Defining Vertex Cover for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of a vertex cover V' for a graph G, where every edge in G has at least one endpoint in V'.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_8\n\nLANGUAGE: LaTeX\nCODE:\n```\nV'\\subseteq V \\text{ and } \\forall e\\in E, e \\text{ has at least one endpoint in } V'\n```\n\n----------------------------------------\n\nTITLE: Defining Invariant Subspace with Kernel in LaTeX\nDESCRIPTION: Mathematical definition of an invariant subspace W_i as the kernel of the power of a matrix (λᵢI-A)^r_i, forming a series of invariant subspaces for matrix A.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\nW_i=N({(\\lambda_i I-A)}^{r_i})\n```\n\n----------------------------------------\n\nTITLE: Stating Tutte's Theorem for Perfect Matchings in LaTeX\nDESCRIPTION: This snippet states Tutte's Theorem, which provides a necessary and sufficient condition for an n-vertex undirected graph G to have a perfect matching.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_7\n\nLANGUAGE: LaTeX\nCODE:\n```\np_{\\text{odd}}(G-V')\\leq |V'|, \\text{ for any } V' \\subset V(G)\n```\n\n----------------------------------------\n\nTITLE: Using fopen for File I/O in C/C++\nDESCRIPTION: Example of using fopen to open files for reading and writing. This approach requires defining file pointers and using specialized file I/O functions rather than redirecting standard streams.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/file-op.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nFILE *in, *out;  // 定义文件指针\nin = fopen(\"data.in\", \"r\");\nout = fopen(\"data.out\", \"w\");\n/*\ndo what you want to do\n*/\nfclose(in);\nfclose(out);\n```\n\n----------------------------------------\n\nTITLE: Alternative Forms of Lagrange Inversion Formula in TeX\nDESCRIPTION: This snippet presents alternative forms of the Lagrange inversion formula, which are often more familiar to some readers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/lagrange-inversion.md#2025-04-22_snippet_3\n\nLANGUAGE: TeX\nCODE:\n```\n\\lbrack x^n\\rbrack f(x)^k=\\frac{k}{n}\\lbrack x^{n-k}\\rbrack\\left(\\frac{x}{g(x)}\\right)^n\n```\n\nLANGUAGE: TeX\nCODE:\n```\n\\begin{aligned}\n\\lbrack x^n\\rbrack \\Phi(f(x))&=\\frac{1}{n}\\lbrack x^{n-1}\\rbrack \\Phi'(x)\\left(\\frac{x}{g(x)}\\right)^n \\\\\n&=\\frac{1}{n}\\lbrack x^{-1}\\rbrack\\frac{\\Phi'(x)}{g(x)^n}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Characterizing Diagonalizable Matrices with Eigenspace Dimensions in LaTeX\nDESCRIPTION: Mathematical condition for a matrix A to be diagonalizable, stating that the sum of the dimensions of all eigenspaces must equal the matrix dimension n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{dim} E(\\lambda_1)+\\cdots+\\operatorname{dim} E(\\lambda_m)=n\n```\n\n----------------------------------------\n\nTITLE: Cycle Construction Definition\nDESCRIPTION: Mathematical definition of Cycle construction operation on a set using LaTeX notation, showing the relationship with SEQ operation and equivalence relation S.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{CYC}(\\mathcal{A})=(\\operatorname{SEQ}(\\mathcal{A})\\setminus\\lbrace \\epsilon\\rbrace)/\\mathbf{S}\n```\n\n----------------------------------------\n\nTITLE: Determinant Properties with Row or Column Addition\nDESCRIPTION: Axiomatic property showing that the determinant remains unchanged when adding a multiple of one row/column to another.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_10\n\nLANGUAGE: latex\nCODE:\n```\n\\det(T_{ij}(k)A) = \\det(AT_{ij}(k))= \\det A\n```\n\n----------------------------------------\n\nTITLE: Defining Sequence Construction for Combinatorial Classes in LaTeX\nDESCRIPTION: Defines the sequence construction for a combinatorial class A, generating all possible ordered combinations of objects from A.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\operatorname{SEQ}(\\mathcal{A})=\\mathcal{E}+\\mathcal{A}+(\\mathcal{A}\\times \\mathcal{A})+(\\mathcal{A}\\times \\mathcal{A}\\times \\mathcal{A})+\\cdots\n```\n\n----------------------------------------\n\nTITLE: Calculating Expected Cost for Drawing New Items in Game Relics Problem\nDESCRIPTION: This snippet demonstrates the calculation of the expected cost (f_k) to draw a new item when k different items are already owned. It uses probability theory to determine the expected number of draws needed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/rand-technique.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"期望代价的计算\"\n    显然 $f_k=\\dfrac x2 \\cdot (R-1)+x$，其中 $R$ 表示要得到新物品期望的抽取次数。\n    \n    引理：如果一枚硬币有 $p$ 的概率掷出正面，则首次掷出正面所需的期望次数为 $\\dfrac 1p$。\n    \n    -   感性理解：$\\dfrac 1p \\cdot p = 1$，所以扔这么多次期望得到 1 次正面，看起来就比较对。\n    -   这种感性理解可以通过 [大数定律](https://en.wikipedia.org/wiki/Law_of_large_numbers) 严谨化，即考虑 $n\\to \\infty$ 次「不断抛硬币直到得到正面」的实验。推导细节略。\n    -   另一种可行的证法是，直接把期望的定义带进去暴算。推导细节略。\n    \n    显然抽一次得到新物品的概率是 $\\dfrac {n-k}n$，那么 $R=\\dfrac n{n-k}$。\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Trigonometric Function Decomposition in Markdown\nDESCRIPTION: This snippet shows how a trigonometric function can be decomposed into a linear combination of sine and cosine functions, illustrating a key concept in linear algebra.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/index.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n-   对于任意的 $k,x_0$，$k \\sin (x-x_0)$ 可以分解成 $k_1\\sin x + k_2\\cos x$。\n```\n\n----------------------------------------\n\nTITLE: Equivalence Between While and Do-While Loops in C++\nDESCRIPTION: Demonstration of how while loops can be rewritten as equivalent do-while loops when there are no continue statements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/loop.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\n// while 语句\n\nstatement1;\nwhile (statement2) {\n  statement1;\n}\n\n// do...while 语句\n\ndo {\n  statement1;\n} while (statement2);\n```\n\n----------------------------------------\n\nTITLE: Defining Entringer Numbers in LaTeX\nDESCRIPTION: Defines the initial values and recursive relationship for Entringer numbers using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nE(0,0)=1\n$$\n\n$$\nE(n,0)=0\n$$\n\n$$\nE(n,k)=E(n,k-1)+E(n-1,n-k)\n$$\n```\n\n----------------------------------------\n\nTITLE: EGF Multiplication Formula\nDESCRIPTION: Mathematical derivation showing how to multiply two exponential generating functions\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/egf.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\hat{F}(x)\\hat{G}(x)\n&=\\sum_{i\\ge 0}a_i\\frac{x^i}{i!}\\sum_{j\\ge 0}b_j\\frac{x^j}{j!}\\\\\n&=\\sum_{n\\ge 0}x^{n}\\sum_{i=0}^na_ib_{n-i}\\frac{1}{i!(n-i)!}\\\\\n&=\\sum_{n\\ge 0}\\frac{x^{n}}{n!}\\sum_{i=0}^n\\binom{n}{i}a_ib_{n-i}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Macro Expansion Error in C++\nDESCRIPTION: This code shows how macros without proper parentheses can lead to unexpected results due to operator precedence during expansion. The square macro produces 8 instead of the expected 16 when given the argument 2+2.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-mistakes.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n#define square(x) x* x\nprintf(\"%d\", square(2 + 2));\n```\n\n----------------------------------------\n\nTITLE: Defining Conjugation Action on Power Set in Group Theory\nDESCRIPTION: This LaTeX snippet defines the conjugation action of a group G on its power set X = P(G). It shows the permutation representation of this action using a function φ that maps elements of G to permutations of X.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_8\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n\\varphi:G\\rightarrow S_X&\\\\\ng\\mapsto \\varphi_g&: X\\rightarrow X\\\\\n&\\quad S\\mapsto gSg^{-1} = \\{gsg^{-1}:s\\in S\\}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Polynomial Multiplication Operation in LaTeX\nDESCRIPTION: Mathematical formula showing how two polynomials are multiplied using the distributive property.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_27\n\nLANGUAGE: latex\nCODE:\n```\nf(x)g(x) = a_0b_0+(a_1b_0+a_0b_1)x+(a_2b_0+a_1b_1+a_0b_2)x^2+\\cdots\n```\n\n----------------------------------------\n\nTITLE: Rebalancing Case 2 After Deletion in Red-Black Tree (C++)\nDESCRIPTION: Handles rebalancing when the sibling and nephew nodes are black and the parent is red after deletion in a red-black tree. Swaps colors of parent and sibling to maintain properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/rbtree.md#2025-04-22_snippet_10\n\nLANGUAGE: C++\nCODE:\n```\nsibling->color = Node::RED;\nnode->parent->color = Node::BLACK;\nreturn;\n```\n\n----------------------------------------\n\nTITLE: Fundamental Theorem of Group Homomorphism Proof in TeX\nDESCRIPTION: A proof of the fundamental theorem of group homomorphism (first isomorphism theorem) demonstrating that for a homomorphism φ:G→H, the kernel is a normal subgroup and G/ker(φ) is isomorphic to φ(G).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_3\n\nLANGUAGE: tex\nCODE:\n```\n首先，$N=\\ker\\varphi$ 是正规子群，因为对于任意 $h\\in N$ 都有 $\\varphi(ghg^{-1})=\\varphi(g)\\varphi(h)\\varphi(g)^{-1}=\\varphi(g)\\varphi(g)^{-1}=e$，亦即 $ghg^{-1}\\in\\ker\\varphi$。然后，考察映射 $\\Phi:G/N\\rightarrow\\varphi(G)$，它满足 $\\Phi(gN)=\\varphi(g)$。映射是良定义的，因为如果 $g_1N=g_2N$，那么 $g_1^{-1}g_2\\in N$，则 $\\varphi(g_1^{-1}g_2)=e$，即 $\\varphi(g_1)=\\varphi(g_2)$。映射 $\\Phi$ 显然是满射；它也是单射，因为 $\\ker\\Phi=\\{gN:\\varphi(g)=e\\}=\\{N\\}$。故而，$\\Phi$ 是群同构。最后，$\\varphi(g_1)\\varphi(g_2)^{-1}=\\varphi(g_1g_2^{-1})\\in\\varphi(G)$，根据子群判别法，$\\varphi(G)$ 必然是子群。\n```\n\n----------------------------------------\n\nTITLE: Triggering Navigation Click in JavaScript\nDESCRIPTION: This JavaScript code selects the second element with the class 'md-nav__title' and simulates a click on it. It's likely used to expand a navigation menu item automatically.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/index.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\ndocument.getElementsByClassName('md-nav__title')[1].click()\n```\n\n----------------------------------------\n\nTITLE: Dynamic Programming Equation for Maximum Weighted Independent Set on a Tree\nDESCRIPTION: Defines the recurrence relation for computing the maximum weighted independent set on a tree, where S(i) represents the set of child nodes of node i.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/basic.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\nf_{i,1}&=w_i+\\sum_{j\\in S(i)}f_{j,0},\\\\\nf_{i,0}&=\\sum_{j\\in S(i)}\\max\\{f_{j,1},f_{j,0}\\}.\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Defining Clique for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of a clique V' for a graph G, where every pair of distinct vertices in V' is adjacent.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_10\n\nLANGUAGE: LaTeX\nCODE:\n```\nV'\\subseteq V \\text{ and every pair of distinct vertices in } V' \\text{ is adjacent}\n```\n\n----------------------------------------\n\nTITLE: Defining Ordinary Generating Function (OGF) for Combinatorial Class in LaTeX\nDESCRIPTION: Defines the ordinary generating function A(z) for a combinatorial class A, expressing it as a sum over all objects in the class and as a power series.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\nA(z)=\\sum_{\\alpha\\in\\mathcal{A}}z^{\\lvert \\alpha \\rvert}=\\sum_{n\\geq 0}a_nz^n\n```\n\n----------------------------------------\n\nTITLE: Definition of Irreducible Elements in an Integral Domain\nDESCRIPTION: The definition of irreducible elements in an integral domain, which are non-unit elements that cannot be factored into non-units.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_23\n\nLANGUAGE: markdown\nCODE:\n```\n???+ abstract \"不可约元\"\n    设整环 $R$ 有非零元素 $r\\in R$，如果 $r$ 不是可逆元，而且对于任何 $a,b\\in R$ 且 $r=ab$ 都有 $a$ 或 $b$ 是可逆元，则称 $r$ 是 **不可约元**（irreducible），或称 $r$ 不可约。反过来，如果 $r=ab$ 且 $a,b\\in R$ 都不是可逆元，则称 $r$ 可约。\n```\n\n----------------------------------------\n\nTITLE: Matrix Equation for Polynomial Recurrence\nDESCRIPTION: This LaTeX code snippet shows the matrix equation that represents the polynomial recurrence relation. It illustrates how the next term in the sequence is calculated from the previous m terms using the constructed matrix.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/shift.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n-{\\frac{1}{P_0(n)}}\\begin{bmatrix}P_1(n)&P_2(n)&P_3(n)&\\cdots&P_{m-1}(n)&P_m(n)\\\\-P_0(n)\\\\&-P_0(n)\\\\&&-P_0(n)\\\\&&&\\ddots\\\\&&&&-P_0(n)\\\\\\end{bmatrix}\n\\begin{bmatrix}a_{n-1}\\\\a_{n-2}\\\\a_{n-3}\\\\\\vdots\\\\a_{n-m+1}\\\\a_{n-m}\\end{bmatrix}\n=\\begin{bmatrix}a_n\\\\a_{n-1}\\\\a_{n-2}\\\\\\vdots\\\\a_{n-m+2}\\\\a_{n-m+1}\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Defining a Multiplication Matrix in LaTeX\nDESCRIPTION: Mathematical definition of a multiplication matrix D_i(k), which is a special diagonal matrix with k in the i-th position of the main diagonal and 1s elsewhere.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_0\n\nLANGUAGE: tex\nCODE:\n```\nD_i(k)=\\operatorname{diag}\\{1,\\cdots,1,k,1,\\cdots,1\\}\n```\n\n----------------------------------------\n\nTITLE: Formal Laurent Series Definition in LaTeX\nDESCRIPTION: Mathematical representation of a formal Laurent series allowing negative exponents.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_29\n\nLANGUAGE: latex\nCODE:\n```\n\\sum_{k=N}^\\infty a_kx^k\n```\n\n----------------------------------------\n\nTITLE: Defining Powerset Construction for Combinatorial Classes in LaTeX\nDESCRIPTION: Defines the powerset construction for a combinatorial class A, generating all possible subsets of objects from A.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_5\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\operatorname{PSET}(\\mathcal{A})\\cong \\prod _ {\\alpha\\in\\mathcal{A}}\\left(\\lbrace \\epsilon \\rbrace +\\lbrace \\alpha\\rbrace\\right)\n```\n\n----------------------------------------\n\nTITLE: Implementing Inversion Transformation and Circle Tangents in C++\nDESCRIPTION: This code demonstrates the implementation of inversion transformation and finding tangent lines between circles. It includes structures for points, vectors, and circles, as well as functions for vector operations, circle-circle tangents, and inversion of circles and lines.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/inverse.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-8;   // 精度系数\nconst double PI = acos(-1.0);  // π\nconstexpr int N = 4;\n\n// 点的定义\nstruct Point {\n  double x, y;\n\n  Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n  bool operator<(Point A) const { return x == A.x ? y < A.y : x < A.x; }\n};\n\n// 向量的定义\nusing Vector = Point;\n\n// 向量加法\nVector operator+(Vector A, Vector B) { return Vector(A.x + B.x, A.y + B.y); }\n\n// 向量减法\nVector operator-(Vector A, Vector B) { return Vector(A.x - B.x, A.y - B.y); }\n\n// 向量数乘\nVector operator*(Vector A, double p) { return Vector(A.x * p, A.y * p); }\n\n// 向量数除\nVector operator/(Vector A, double p) { return Vector(A.x / p, A.y / p); }\n\n// 与0的关系\nint dcmp(double x) {\n  if (fabs(x) < EPS) return 0;\n  return x < 0 ? -1 : 1;\n}\n\n// 向量点乘\ndouble Dot(Vector A, Vector B) { return A.x * B.x + A.y * B.y; }\n\n// 向量长度\ndouble Length(Vector A) { return sqrt(Dot(A, A)); }\n\n// 向量叉乘\ndouble Cross(Vector A, Vector B) { return A.x * B.y - A.y * B.x; }\n\n// 点在直线上投影\nPoint GetLineProjection(Point P, Point A, Point B) {\n  Vector v = B - A;\n  return A + v * (Dot(v, P - A) / Dot(v, v));\n}\n\n// 圆\nstruct Circle {\n  Point c;\n  double r;\n\n  Circle() : c(Point(0, 0)), r(0) {}\n\n  Circle(Point c, double r = 0) : c(c), r(r) {}\n\n  // 输入极角返回点坐标\n  Point point(double a) { return Point(c.x + cos(a) * r, c.y + sin(a) * r); }\n};\n\n// 两圆公切线 返回切线的条数，-1表示无穷多条切线\n// a[i] 和 b[i] 分别是第i条切线在圆A和圆B上的切点\nint getTangents(Circle A, Circle B, Point* a, Point* b) {\n  int cnt = 0;\n  if (A.r < B.r) {\n    swap(A, B);\n    swap(a, b);\n  }\n  double d2 =\n      (A.c.x - B.c.x) * (A.c.x - B.c.x) + (A.c.y - B.c.y) * (A.c.y - B.c.y);\n  double rdiff = A.r - B.r;\n  double rsum = A.r + B.r;\n  if (dcmp(d2 - rdiff * rdiff) < 0) return 0;  // 内含\n\n  double base = atan2(B.c.y - A.c.y, B.c.x - A.c.x);\n  if (dcmp(d2) == 0 && dcmp(A.r - B.r) == 0) return -1;  // 无限多条切线\n  if (dcmp(d2 - rdiff * rdiff) == 0) {  // 内切，一条切线\n    a[cnt] = A.point(base);\n    b[cnt] = B.point(base);\n    ++cnt;\n    return 1;\n  }\n  // 有外公切线\n  double ang = acos(rdiff / sqrt(d2));\n  a[cnt] = A.point(base + ang);\n  b[cnt] = B.point(base + ang);\n  ++cnt;\n  a[cnt] = A.point(base - ang);\n  b[cnt] = B.point(base - ang);\n  ++cnt;\n  if (dcmp(d2 - rsum * rsum) == 0) {  // 一条内公切线\n    a[cnt] = A.point(base);\n    b[cnt] = B.point(PI + base);\n    ++cnt;\n  } else if (dcmp(d2 - rsum * rsum) > 0) {  // 两条内公切线\n    double ang = acos(rsum / sqrt(d2));\n    a[cnt] = A.point(base + ang);\n    b[cnt] = B.point(PI + base + ang);\n    ++cnt;\n    a[cnt] = A.point(base - ang);\n    b[cnt] = B.point(PI + base - ang);\n    ++cnt;\n  }\n  return cnt;\n}\n\n// 点 O 在圆 A 外，求圆 A 的反演圆 B，R 是反演半径\nCircle Inversion_C2C(Point O, double R, Circle A) {\n  double OA = Length(A.c - O);\n  double RB = 0.5 * ((1 / (OA - A.r)) - (1 / (OA + A.r))) * R * R;\n  double OB = OA * RB / A.r;\n  double Bx = O.x + (A.c.x - O.x) * OB / OA;\n  double By = O.y + (A.c.y - O.y) * OB / OA;\n  return Circle(Point(Bx, By), RB);\n}\n\n// 直线反演为过 O 点的圆 B，R 是反演半径\nCircle Inversion_L2C(Point O, double R, Point A, Vector v) {\n  Point P = GetLineProjection(O, A, A + v);\n  double d = Length(O - P);\n  double RB = R * R / (2 * d);\n  Vector VB = (P - O) / d * RB;\n  return Circle(O + VB, RB);\n}\n\n// 返回 true 如果 A B 两点在直线同侧\nbool theSameSideOfLine(Point A, Point B, Point S, Vector v) {\n  return dcmp(Cross(A - S, v)) * dcmp(Cross(B - S, v)) > 0;\n}\n\nint main() {\n  int T;\n  scanf(\"%d\", &T);\n  while (T--) {\n    Circle A, B;\n    Point P;\n    scanf(\"%lf%lf%lf\", &A.c.x, &A.c.y, &A.r);\n    scanf(\"%lf%lf%lf\", &B.c.x, &B.c.y, &B.r);\n    scanf(\"%lf%lf\", &P.x, &P.y);\n    Circle NA = Inversion_C2C(P, 10, A);\n    Circle NB = Inversion_C2C(P, 10, B);\n    Point LA[N], LB[N];\n    Circle ansC[N];\n    int q = getTangents(NA, NB, LA, LB), ans = 0;\n    for (int i = 0; i < q; ++i)\n      if (theSameSideOfLine(NA.c, NB.c, LA[i], LB[i] - LA[i])) {\n        if (!theSameSideOfLine(P, NA.c, LA[i], LB[i] - LA[i])) continue;\n        ansC[ans++] = Inversion_L2C(P, 10, LA[i], LB[i] - LA[i]);\n      }\n    printf(\"%d\\n\", ans);\n    for (int i = 0; i < ans; ++i) {\n      printf(\"%.8f %.8f %.8f\\n\", ansC[i].c.x, ansC[i].c.y, ansC[i].r);\n    }\n  }\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Eigenspace with Matrix Equations in LaTeX\nDESCRIPTION: Mathematical equation defining an eigenspace E(λ₀) as the solution space of the homogeneous linear system (λ₀I-A)X=0, where λ₀ is an eigenvalue of matrix A.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n(\\lambda_0 I-A)X=0\n```\n\n----------------------------------------\n\nTITLE: Matrix Notation Reference Table in Markdown and LaTeX\nDESCRIPTION: A formatted reference table showing various matrix notations including basic representation, operations, properties and transformations. The table uses LaTeX expressions embedded within Markdown for mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n| 编号     | 符号，表达式                             | 意义，等同表述             | 备注与示例                                                                                         |\n| ------ | ---------------------------------- | ------------------- | --------------------------------------------------------------------------------------------- |\n| n12.1  | $A$;<br>*参见*[^n12.1-ref1]          | $m\\times n$ 型矩阵 $A$ | $a_{ij} = (A)_{ij}$;<br>也可使用 $A = (a_{ij})$. 其中 $m$ 为行数，$n$ 为列数<br>$m=n$ 时称为方阵<br>可用方括号替代圆括号。 |\n| n12.2  | $A + B$                            | 矩阵 $A$ 和 $B$ 的和     | $(A + B)_{ij} = (A)_{ij} + (B)_{ij}$;<br>矩阵 $A$ 和 $B$ 的行数和列数必须分别相同。                           |\n| n12.3  | $x A$                              | 标量 $x$ 和矩阵 $A$ 的乘积  | $(x A)_{ij} = x (A)_{ij}$.                                                                    |\n| n12.4  | $AB$                               | 矩阵 $A$ 和 $B$ 的乘积    | $\\displaystyle(AB)_{ik} = \\sum\\limits_{j}(A)_{ij}(B)_{jk}$;<br>矩阵 $A$ 的列数必须等于矩阵 $B$ 的行数。      |\n| n12.5  | $I$;<br>$E$                        | 单位矩阵                | $(I)_{ik} = \\delta_{ik}$;<br>$\\delta_{ik}$ 的定义参见 n14.9.                                       |\n| n12.6  | $A^{-1}$                           | 方阵 $A$ 的逆           | $AA^{-1} = A^{-1}A = I\\quad (\\det A \\ne 0)$.<br>$\\det A$ 的定义参见 n12.10.                        |\n| n12.7  | $A^{\\mathrm{T}}$;<br>$A'$          | $A$ 的转置矩阵           | $(A^{\\mathrm{T}})_{ik} = (A)_{ki}$.                                                           |\n| n12.8  | $\\overline{A}$;<br>$A^*$           | $A$ 的复共轭矩阵          | $\\left(\\overline{A}\\right)_{ik}=\\overline{(A)_{ik}}$.                                         |\n| n12.9  | $A^{\\mathrm{H}}$;<br>$A^{\\dagger}$ | $A$ 的 Hermite 共轭矩阵  | $A^{\\mathrm{H}} = \\left(\\overline{A}\\right)^{\\mathrm{T}}$.                                    |\n| n12.10 | $\\det A$;<br>*参见*[^n12.10-ref1]    | 方阵 $A$ 的行列式         | 也可使用 $\\lvert A\\rvert$.                                                                        |\n| n12.11 | $\\operatorname{rank}A$             | 矩阵 $A$ 的秩           |                                                                                               |\n| n12.12 | $\\operatorname{tr}A$               | 方阵 $A$ 的迹           | $\\displaystyle\\operatorname{tr}A=\\sum\\limits_{i}(A)_{ii}$.                                    |\n| n12.13 | $\\lVert A\\rVert$                   | 矩阵 $A$ 的范数          | 满足三角不等式：若 $A + B = C$, 则 $\\lVert A\\rVert+\\lVert B\\rVert \\geq \\lVert C\\rVert$.                 |\n```\n\n----------------------------------------\n\nTITLE: Defining Cartesian Product Construction for Combinatorial Classes in LaTeX\nDESCRIPTION: Defines the Cartesian product construction for two combinatorial classes A and B, creating pairs of objects from each class.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\mathcal{A}\\times \\mathcal{B}=\\left\\lbrace (\\alpha, \\beta)\\mid \\alpha \\in \\mathcal{A},\\beta\\in\\mathcal{B}\\right\\rbrace\n```\n\n----------------------------------------\n\nTITLE: Creating Numbered Equations in LaTeX\nDESCRIPTION: Shows how to create a single numbered equation using the equation environment.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_4\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{equation}\n  1+2=3\n\\end{equation}\n```\n\n----------------------------------------\n\nTITLE: Memory Pool Implementation in C++\nDESCRIPTION: Implementation of memory pools to optimize dynamic memory allocation. Includes examples for array allocation and segment tree node creation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/contest/common-tricks.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n// 申请动态分配 32 位有符号整数数组：\nint* newarr(int sz) {\n  static int pool[MAXN], *allocp = pool;\n  return allocp += sz, allocp - sz;\n}\n\n// 线段树动态开点的代码：\nNode* newnode() {\n  static Node pool[MAXN << 1], *allocp = pool - 1;\n  return ++allocp;\n}\n```\n\n----------------------------------------\n\nTITLE: Weighted Pólya Enumeration Theorem Formula\nDESCRIPTION: The general formula for the generating function that counts essentially different colorings with color constraints using Burnside's Lemma.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\frac1{|G|}\\sum_{g\\in G}\\prod_{k=1}^n\\left(\\sum_{i=1}^mx_i^k\\right)^{\\alpha_k}.\n```\n\n----------------------------------------\n\nTITLE: Unix Root User Terminal Example\nDESCRIPTION: Shows the terminal prompt when logged in as root user in Unix systems\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/cmd.md#2025-04-22_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nroot@seniorious:~# apt-get install gcc\n```\n\n----------------------------------------\n\nTITLE: Calculating Sum of Divisor Function Products in C++\nDESCRIPTION: This code solves the SDOI2015 problem, computing the sum of d(i*j) for 1≤i≤n and 1≤j≤m, where d(n) is the divisor function. It uses Möbius inversion and precomputed prefix sums.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/mobius.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\n--8<-- \"docs/math/code/mobius/mobius_4.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Defining Potential Function in LaTeX\nDESCRIPTION: LaTeX code defining the potential function Φ(x) for a node x in the union-find data structure. This function is key to the amortized analysis.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/dsu-complexity.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\Phi(x)=\n\\begin{cases}\n\\alpha(n)\\times \\mathit{rnk}(x)& \\mathit{rnk}(x)=0\\ \\text{或}\\ x\\ \\text{为某棵树的根节点}\\\\\n(\\alpha(n)-\\mathit{level}(x))\\times \\mathit{rnk}(x)-iter(x)& \\text{otherwise}\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: PowerShell Error Message Example\nDESCRIPTION: Shows typical PowerShell error message when trying to execute local program without path\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/cmd.md#2025-04-22_snippet_4\n\nLANGUAGE: ps1con\nCODE:\n```\nPS> hello\nhello: The term 'hello' is not recognized as a name of a cmdlet,\nfunction, script file, or executable program.\nCheck the spelling of the name, or if a path was included, verify that\nthe path is correct and try again.\n\nSuggestion [3,General]: The command hello was not found, but does exist\nin the current location. PowerShell does not load commands from the\ncurrent location by default. If you trust this command, instead type:\n\".\\hello\". See \"get-help about_Command_Precedence\" for more details.\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation of Reduced Laplace Matrix\nDESCRIPTION: Matrix M_n obtained after removing the first row and column from the original Laplace matrix L_n. This matrix has 3s on the diagonal and -1s in specific positions representing the connectivity pattern in the wheel virus problem.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/matrix-tree.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nM_n = \\begin{bmatrix}\n3&\t-1&\t0&\t\\cdots&\t0&\t-1\\\\\n-1&\t3&\t-1&\t\\cdots&\t0&\t0\\\\\n0&\t-1&\t3&\t\\cdots&\t0&\t0\\\\\n\\vdots&\t\\vdots&\t\\vdots&\t\\ddots&\t\\vdots&\t\\vdots\\\\\n0&\t0&\t0&\t\\cdots&\t3&\t-1\\\\\n-1&\t0&\t0&\t\\cdots&\t-1&\t3\\\\\n\\end{bmatrix}_{n}\n```\n\n----------------------------------------\n\nTITLE: Formal Power Series Definition in LaTeX\nDESCRIPTION: Mathematical representation of a formal power series as an infinite sum.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_28\n\nLANGUAGE: latex\nCODE:\n```\n\\sum_{k=0}^\\infty a_kx^k=a_0+a_1x+a_2x^2+\\cdots\n```\n\n----------------------------------------\n\nTITLE: Defining Independent Set for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of an independent set V' for a graph G, where no two vertices in V' are adjacent to each other.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_5\n\nLANGUAGE: LaTeX\nCODE:\n```\nV'\\subseteq V \\text{ and no two vertices in } V' \\text{ are adjacent}\n```\n\n----------------------------------------\n\nTITLE: Basic Min-Max Formula\nDESCRIPTION: The fundamental min-max inclusion-exclusion formulas for sequences satisfying total order and additivity properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/inclusion-exclusion-principle.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\max_{i\\in S}{x_i}=\\sum_{T\\subseteq S}{(-1)^{|T|-1}\\min_{j\\in T}{x_j}}\n\n\\min_{i\\in S}{x_i}=\\sum_{T\\subseteq S}{(-1)^{|T|-1}\\max_{j\\in T}{x_j}}\n```\n\n----------------------------------------\n\nTITLE: Kronecker Symbol for Quadratic Fields in LaTeX\nDESCRIPTION: LaTeX formula showing the Kronecker symbol used to determine the behavior of prime numbers in quadratic integer rings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quadratic.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\left(\\dfrac{D}{p}\\right)\n```\n\n----------------------------------------\n\nTITLE: Constructing Lambda Matrix for Polynomial Recurrence\nDESCRIPTION: This LaTeX code snippet defines the lambda matrix B(λ) used in the polynomial recurrence algorithm. It represents the linear transformation between consecutive m-dimensional vectors in the sequence.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/shift.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\nB(\\lambda)=\\begin{bmatrix}\n    P_1(\\lambda)&P_2(\\lambda)&P_3(\\lambda)&\\cdots&P_{m-1}(\\lambda)&P_m(\\lambda)\\\\\n    -P_0(\\lambda)\\\\\n    &-P_0(\\lambda)\\\\\n    &&-P_0(\\lambda)\\\\\n    &&&\\ddots\\\\\n    &&&&-P_0(\\lambda)\\\\\n\\end{bmatrix}\n```\n\n----------------------------------------\n\nTITLE: Defining Net Flow in LaTeX\nDESCRIPTION: Expresses the net flow for a vertex in a network using LaTeX mathematical notation, showing the difference between outgoing and incoming flows.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\nf(u) = \\sum_{x \\in V} f(u, x) - \\sum_{x \\in V} f(x, u)\n```\n\n----------------------------------------\n\nTITLE: Determinant of Identity Matrix\nDESCRIPTION: Axiomatic property stating that the determinant of the identity matrix equals 1, serving as a base case for the axiomatic definition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\n\\det I = 1\n```\n\n----------------------------------------\n\nTITLE: Weighted Pólya Enumeration Theorem with Cycle Index\nDESCRIPTION: Formal statement of the weighted Pólya Enumeration Theorem using cycle index notation, showing how to calculate generating functions for essentially different colorings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\nZ_G(f(x_1^1,x_2^1,\\cdots,x_m^1),f(x_1^2,x_2^2,\\cdots,x_m^2),\\cdots,f(x_1^n,x_2^n,\\cdots,x_m^n)),\n```\n\n----------------------------------------\n\nTITLE: Special Cases of Vector Scalar Multiplication in LaTeX\nDESCRIPTION: LaTeX expressions for special cases of vector scalar multiplication, including negation and distributive property over subtraction.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/vector.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{gathered}\n(-\\lambda)\\boldsymbol a=-(\\lambda \\boldsymbol a)=-\\lambda(\\boldsymbol a)\\\\\n\\lambda(\\boldsymbol a-\\boldsymbol b)=\\lambda \\boldsymbol a-\\lambda \\boldsymbol b\n\\end{gathered}\n```\n\n----------------------------------------\n\nTITLE: Proving Primitive Root Existence for Prime Powers in LaTeX\nDESCRIPTION: This LaTeX code proves the existence of primitive roots for prime powers, using binomial expansion and modular arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/primitive-root.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{aligned}\n    (g+p)^{p-1}&\\equiv \\binom{p-1}{0}g^{p-1}+\\binom{p-1}{1}pg^{p-2} \\pmod {p^2}\\\\\n    &\\equiv g^{p-1}+p(p-1)g^{p-2} \\pmod {p^2}\\\\\n    &\\equiv 1-pg^{p-2} \\pmod {p^2}\\\\\n    &\\not\\equiv 1 \\pmod {p^2}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Implementing Hello World in C++\nDESCRIPTION: A basic Hello World program in C++ demonstrating the structure of a simple program, including the iostream library import, main function declaration, and standard output formatting.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n#include <iostream>  // 导入 iostream 库\n\nint main()  // main 部分\n{\n  std::cout << \"Hello World!\" << std::endl;\n\n  return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Taylor Formula Method for Polynomial Translation\nDESCRIPTION: Implementation using Taylor series expansion to compute translated polynomial coefficients by expanding around the translation point c.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/shift.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\nf(x)=f(c)+\\frac{f'(c)}{1!}(x-c)+\\frac{f''(c)}{2!}(x-c)^2+\\cdots +\\frac{f^{(n)}(c)}{n!}(x-c)^n\n```\n\n----------------------------------------\n\nTITLE: Configuring Player Directory Structure\nDESCRIPTION: Sample directory structure showing how to organize contestant files and submissions by day and problem\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/arbiter.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nplayers/\n| -- day1\n|    | -- <contestant_1's ID>\n|    |     | -- <problem_1>\n|    |     |   `-- <problem_1>.c/cpp/pas\n|    |     | -- <problem_2>\n|    |     |   `-- <problem_2>.c/cpp/pas\n|    |     | ...\n|    |     | -- <problem_x>\n|    |        `-- <problem_x>.c/cpp/pas\n|    | -- <contestant_2's ID>\n|    |     | -- <problem_1>\n|    |     ...\n|    ...\n| -- day2\n|    | -- <contestant_1's ID>\n|    |     | -- <problem_1>\n|    |     |   `-- <problem_1>.c/cpp/pas\n|    |     | -- <problem_2>\n|    |     |   `-- <problem_2>.c/cpp/pas\n|    |     | ...\n|    |     | -- <problem_x>\n|    |        `-- <problem_x>.c/cpp/pas\n|    | -- <contestant_2's ID>\n|    |     | -- <problem_1>\n|    |     ...\n|    ...\n...\n```\n\n----------------------------------------\n\nTITLE: Exponential Generating Function for Entringer Numbers in LaTeX\nDESCRIPTION: Presents the exponential generating function for Entringer numbers using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\n\\sum_{m=0}^\\infty\\sum_{n=0}^\\infty E\\left(m+n,\\frac{1}{2}\\left(m+n+{(-1)}^{m+n}(n-m)\\right)\\right)\\frac{x^m}{m!}\\frac{x^n}{n!}=\\frac{\\cos x+\\sin x}{\\cos (x+y)}\n$$\n```\n\n----------------------------------------\n\nTITLE: Generating Function for Cycle Index in Weighted Pólya Enumeration\nDESCRIPTION: Formula representing the generating function used to count permutations with color constraints, where αₖ represents the number of cycles of length k in a permutation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\prod_{k=1}^n\\left(\\sum_{i=1}^mx_i^k\\right)^{\\alpha_k}\n```\n\n----------------------------------------\n\nTITLE: Default Arguments in Python Functions\nDESCRIPTION: This snippet illustrates the behavior of default arguments in Python functions and demonstrates a common pitfall with mutable default arguments. It also shows the recommended practice of using None as a placeholder for mutable defaults.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/python.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef append_to(element, to=[]):\n    to.append(element)\n    return to\n\n\nlst1 = append_to(12)\nlst2 = append_to(42)\nprint(lst1, lst2)\n\n# 你可能以为输出是 [12] [42]\n# 但运行结果其实是 [12] [12, 42]\n\n\n# 这是因为默认参数的值仅仅在函数定义的时候赋值一次\n# 默认参数的值应该是不可变对象，使用 None 占位是一种最佳实践\ndef append_to(element, to=None):\n    if to is None:\n        to = []\n    to.append(element)\n    return to\n```\n\n----------------------------------------\n\nTITLE: Computing Eigenspace Dimension using Rank-Nullity Theorem in LaTeX\nDESCRIPTION: Mathematical formulation of the rank-nullity theorem applied to find the dimension of an eigenspace, showing that dim E(λᵢ) = n - r(λᵢI-A), which is also called the geometric multiplicity of λᵢ.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nr(\\lambda_i I-A)+\\operatorname{dim} N(\\lambda_i I-A)=n\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{dim} E(\\lambda_i)=n-r(\\lambda_i I-A)\n```\n\n----------------------------------------\n\nTITLE: Matrix Footnote References in LaTeX\nDESCRIPTION: LaTeX notation for matrix representation referenced in the main table. Shows the explicit matrix structure with elements and formatting for determinants.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n[^n12.1-ref1]: $\\begin{pmatrix}a_{11}&\\cdots&a_{1n}\\\\\\vdots&\\ddots&\\vdots\\\\a_{m1}&\\cdots&a_{mn}\\end{pmatrix}$\n\n[^n12.10-ref1]: $\\begin{vmatrix}a_{11}&\\cdots&a_{1n}\\\\\\vdots& &\\vdots\\\\a_{n1}&\\cdots&a_{nn}\\end{vmatrix}$\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 1: Case when p divides x-y\nDESCRIPTION: First part of the Lifting the Exponent lemma stating that when p divides x-y and (n,p)=1, the power of p in x^n-y^n equals the power of p in x-y.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)\n```\n\n----------------------------------------\n\nTITLE: Defining ν_p(n) for Prime Factorization in LaTeX\nDESCRIPTION: Definition of ν_p(n) as the power of the prime factor p in the standard factorization of integer n, satisfying p^(ν_p(n)) divides n but p^(ν_p(n)+1) does not divide n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p(n)\n```\n\n----------------------------------------\n\nTITLE: Definition of Cycle Index for Permutation Groups\nDESCRIPTION: Mathematical definition of the cycle index for a permutation group G, where cₖ(g) is the number of cycles of length k in permutation g.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\nZ_G(t_1,t_2,\\cdots,t_n)=\\frac{1}{|G|}\\sum_{g\\in G}t_1^{c_1(g)}t_2^{c_2(g)}\\cdots t_n^{c_n(g)},\n```\n\n----------------------------------------\n\nTITLE: Third Isomorphism Theorem Proof in TeX\nDESCRIPTION: Proof of the third isomorphism theorem showing that for normal subgroups H and K with H≤K, K/H is normal in G/H and (G/H)/(K/H) is isomorphic to G/K.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_6\n\nLANGUAGE: tex\nCODE:\n```\n考察映射 $\\varphi:G/H\\rightarrow G/K$ 满足 $\\varphi(gH)=gK$，则它是满的群同态，且 $\\ker\\varphi=\\{gH:g\\in K\\}=K/H$。应用同态基本定理就可得证。\n```\n\n----------------------------------------\n\nTITLE: Cycle Index for Dihedral Group D2n\nDESCRIPTION: Formula for the cycle index of a dihedral group D2n, which represents both rotation and reflection symmetries of a regular n-gon.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_10\n\nLANGUAGE: latex\nCODE:\n```\nZ(D_{2n})=\\frac12Z(C_n)+\n\\begin{cases}\n\\dfrac12t_1t_2^k,&n=2k+1,\\\\\n\\dfrac14\\left(t_1^2t_2^{k-1}+t_2^k\\right),&n=2k.\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Using TeX Commands in Problem Statements\nDESCRIPTION: Example of using TeX formatting commands in Polygon problem statements instead of Markdown syntax. Shows how to make text bold using TeX commands.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/polygon.md#2025-04-22_snippet_0\n\nLANGUAGE: tex\nCODE:\n```\n\\textbf{text}\n```\n\n----------------------------------------\n\nTITLE: Determinants of Elementary Matrices in LaTeX\nDESCRIPTION: Formulas showing the determinant values for the three types of elementary matrices: multiplication, switching, and addition matrices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/elementary-operations.md#2025-04-22_snippet_3\n\nLANGUAGE: tex\nCODE:\n```\n|D_i(k)|=k\n```\n\nLANGUAGE: tex\nCODE:\n```\n|P_{ij}|=-1\n```\n\nLANGUAGE: tex\nCODE:\n```\n|T_{ij}(k)|=1\n```\n\n----------------------------------------\n\nTITLE: Krull's Theorem on Existence of Maximal Ideals\nDESCRIPTION: Krull's theorem stating that any proper ideal in a ring with unity is contained in a maximal ideal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_13\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"定理（Krull）\"\n    对于非零幺环 $R$ 的理想 $I\\neq R$，总有 $R$ 的极大理想 $M$ 使得 $I\\subseteq M$ 成立。\n```\n\n----------------------------------------\n\nTITLE: Diagonal Matrix of Invariant Factors\nDESCRIPTION: The diagonal matrix containing the invariant factors in the Smith normal form of a lambda matrix.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\nD(\\lambda)=\\begin{pmatrix}\nd_1(\\lambda) &  & \\\\\n & \\ddots & \\\\\n &  & d_r(\\lambda)\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Lagrange Inversion Formula in TeX\nDESCRIPTION: This snippet presents the Lagrange inversion formula, which relates coefficients of composite functions in formal power series.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/lagrange-inversion.md#2025-04-22_snippet_2\n\nLANGUAGE: TeX\nCODE:\n```\n\\begin{aligned}\n\\lbrack x^n\\rbrack\\Phi(f(x))&=\\lbrack x^{n-1}\\rbrack\\Phi(x)\\frac{g'(x)}{g(x)}\\left(\\frac{x}{g(x)}\\right)^n \\\\\n&=\\lbrack x^{-1}\\rbrack\\frac{\\Phi(x)g'(x)}{g(x)^{n+1}}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Hello World Program in C++\nDESCRIPTION: Basic C++ program that outputs 'Hello, world!' to the console. Uses the iostream library and std namespace for output operations.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/helloworld.md#2025-04-22_snippet_3\n\nLANGUAGE: c++\nCODE:\n```\n#include <iostream>  // 引用头文件\n\nint main() {                     // 定义 main 函数\n  std::cout << \"Hello, world!\";  // 使用标准命名空间中的 cout 函数\n  return 0;  // 返回 0，结束 main 函数。编译器一般会自动加上这一行，一般可以省略\n}\n```\n\n----------------------------------------\n\nTITLE: Theorem on Maximal Ideals and Prime Ideals\nDESCRIPTION: A theorem stating that in a commutative ring with unity, every maximal ideal is a prime ideal.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_16\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"定理\"\n    对于交换非零幺环 $R$，那么它的极大理想必然是素理想。\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Aligned Equations in LaTeX\nDESCRIPTION: Demonstrates how to create a series of aligned equations with equation numbers using the eqnarray environment.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_5\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{eqnarray}\n  a & = & b + c \\\\\n  & = & y - z\n\\end{eqnarray}\n```\n\n----------------------------------------\n\nTITLE: Cross-Column Algebraic Cofactor Product Sum Theorem\nDESCRIPTION: Formula showing that the sum of products of elements from one column with algebraic cofactors from a different column equals zero, an important property of determinants.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\na_{1i}A_{1j}+a_{2i}A_{2j}+\\cdots+a_{ni}A_{nj}=0\n```\n\n----------------------------------------\n\nTITLE: Displaying Whitney's Inequality in LaTeX\nDESCRIPTION: This LaTeX snippet shows Whitney's inequality, which relates vertex connectivity (λ), edge connectivity (κ), and minimum degree (δ) in a graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/connectivity.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\kappa \\le \\lambda \\le \\delta\n$$\n```\n\n----------------------------------------\n\nTITLE: Expressing Euler's Number Limit in LaTeX\nDESCRIPTION: LaTeX code for representing the limit definition of Euler's number e.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\mathrm{e}=\\lim\\limits_{n\\to\\infty}\\left(1+\\frac{1}{n}\\right)^n=2.718~281~8\\dots\n```\n\n----------------------------------------\n\nTITLE: Generating Functions for Secant and Tangent in LaTeX\nDESCRIPTION: Presents the generating functions for secant and tangent numbers in terms of zigzag numbers using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_6\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\n\\sec x=A_0+A_2\\frac{x^2}{2!}+A_4\\frac{x^4}{4!}+\\cdots\n$$\n\n$$\n\\tan x=A_1x+A_3\\frac{x^3}{3!}+A_5\\frac{x^5}{5!}+\\cdots\n$$\n\n$$\n\\sec x+\\tan x=A_0+A_1x+A_2\\frac{x^2}{2!}+A_3\\frac{x^3}{3!}+A_4\\frac{x^4}{4!}+A_5\\frac{x^5}{5!}+\\cdots\n$$\n```\n\n----------------------------------------\n\nTITLE: Extracting Substrings from C++ String\nDESCRIPTION: Shows how to use substr() function to extract portions of a std::string.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/string.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nstring s = \"OI Wiki\", t = \"OI\";\nprintf(\"从字符串 s 的第四位开始的最多三个字符构成的子串是 %s\\n\",\n       s.substr(3, 3).c_str());\nprintf(\"从字符串 t 的第二位开始的最多三个字符构成的子串是 %s\",\n       t.substr(1, 3).c_str());\n```\n\n----------------------------------------\n\nTITLE: Converting Binary to Gray Code in C++\nDESCRIPTION: Function that converts a binary number n to its Gray code equivalent using bitwise XOR operations. The formula used is G(n) = n XOR (n/2).\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/misc/gray-code.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint g(int n) { return n ^ (n >> 1); }\n```\n\n----------------------------------------\n\nTITLE: Euler's Formula for Connected Planar Graphs\nDESCRIPTION: This formula relates the number of vertices (n), edges (m), and faces (r) in a connected planar graph. It states that for any connected planar graph G, n - m + r = 2.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/planar.md#2025-04-22_snippet_0\n\nLANGUAGE: Mathematical Notation\nCODE:\n```\nn-m+r=2\n```\n\n----------------------------------------\n\nTITLE: Beta Function LaTeX Formatting\nDESCRIPTION: LaTeX code showing the correct formatting for the beta function operator\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_9\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{B}(z, w)\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 2: For Odd Primes When p Divides x-y\nDESCRIPTION: Second part of the Lifting the Exponent lemma for odd primes p, stating that when p divides x-y, the power of p in x^n-y^n equals the power of p in x-y plus the power of p in n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n-y^n\\right)=\\nu_p(x-y)+\\nu_p(n)\n```\n\n----------------------------------------\n\nTITLE: Basic Polynomial Definition in LaTeX\nDESCRIPTION: Mathematical representation of a polynomial with coefficients in ring R, showing the formal sum notation for polynomials.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_25\n\nLANGUAGE: latex\nCODE:\n```\n\\sum_{k=0}^{n}a_kx^k = a_0+a_1x+\\cdots+a_{n-1}x^{n-1}+a_nx^n\n```\n\n----------------------------------------\n\nTITLE: Determinant Expansion of Matrix M_n\nDESCRIPTION: Expanding the determinant of matrix M_n by the first column to derive a recursive formula. This expansion shows three different matrices whose determinants are used in the subsequent recursion relation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/matrix-tree.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\det M_n = 3\\det \\begin{bmatrix}\n3&\t-1&\t\\cdots&\t0&\t0\\\\\n-1&\t3&\t\\cdots&\t0&\t0\\\\\n\\vdots&\t\\vdots&\t\\ddots&\t\\vdots&\t\\vdots\\\\\n0&\t0&\t\\cdots&\t3&\t-1\\\\\n0&\t0&\t\\cdots&\t-1&\t3\\\\\n\\end{bmatrix}_{n-1} + \\det\\begin{bmatrix}\n-1&\t0&\t\\cdots&\t0&\t-1\\\\\n-1&\t3&\t\\cdots&\t0&\t0\\\\\n\\vdots&\t\\vdots&\t\\ddots&\t\\vdots&\t\\vdots\\\\\n0&\t0&\t\\cdots&\t3&\t-1\\\\\n0&\t0&\t\\cdots&\t-1&\t3\\\\\n\\end{bmatrix}_{n-1} + (-1)^n \\det\\begin{bmatrix}\n-1&\t0&\t\\cdots&\t0&\t-1\\\\\n3&\t-1&\t\\cdots&\t0&\t0\\\\\n-1&\t3&\t\\cdots&\t0&\t0\\\\\n\\vdots&\t\\vdots&\t\\ddots&\t\\vdots&\t\\vdots\\\\\n0&\t0&\t\\cdots&\t3&\t-1\\\\\n\\end{bmatrix}_{n-1}\n```\n\n----------------------------------------\n\nTITLE: Tonelli–Shanks算法数学公式\nDESCRIPTION: 展示了Tonelli–Shanks算法的关键数学公式，包括素数p的分解、二次非剩余r的选择，以及求解过程中的关键等式。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quad-residue.md#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\np-1=2^n\\cdot m \\text{ 其中 } m \\text{ 为奇数}, \\\\ g\\equiv r^m\\pmod p, \\\\ b\\equiv a^{(m-1)/2}\\pmod p, \\\\ ab^2\\equiv g^e\\pmod p, \\\\ \\left(abg^{-e/2}\\right)^2\\equiv a\\pmod p\n```\n\n----------------------------------------\n\nTITLE: LTE Lemma Part 2: For Odd Primes When p Divides x+y\nDESCRIPTION: Second part of the Lifting the Exponent lemma for odd primes p, stating that when p divides x+y and n is odd, the power of p in x^n+y^n equals the power of p in x+y plus the power of p in n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\nu_p\\left(x^n+y^n\\right)=\\nu_p(x+y)+\\nu_p(n)\n```\n\n----------------------------------------\n\nTITLE: Inserting Figures in LaTeX\nDESCRIPTION: Shows how to insert figures in LaTeX documents using the graphicx package. Includes positioning, centering, sizing, captioning, and labeling options.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_2\n\nLANGUAGE: tex\nCODE:\n```\n\\begin{figure}[h]\n  \\centering\n  \\includegraphics[width=1\\textwidth]{myimage}\n  \\caption{Here is my image}\n  \\label{image-myimage}\n\\end{figure}\n```\n\n----------------------------------------\n\nTITLE: Defining Formal Laurent Series Ring in TeX\nDESCRIPTION: This snippet defines the formal Laurent series ring over the complex numbers, allowing for series with both positive and negative exponents.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/lagrange-inversion.md#2025-04-22_snippet_0\n\nLANGUAGE: TeX\nCODE:\n```\n\\mathbb{C}\\left(\\left(x\\right)\\right):=\\left\\lbrace \\sum_{k\\geq N}a_kx^k : N\\in\\mathbb{Z},a_k\\in \\mathbb{C}\\right\\rbrace\n```\n\n----------------------------------------\n\nTITLE: Defining Cut Capacity in LaTeX\nDESCRIPTION: Formulates the capacity of an s-t cut in a network using LaTeX mathematical notation, summing the capacities of edges crossing from set S to set T.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n||S, T|| = \\sum_{u \\in S} \\sum_{v \\in T} c(u, v)\n```\n\n----------------------------------------\n\nTITLE: Displaying LaTeX Set for Positive Integer Solutions\nDESCRIPTION: A LaTeX set notation describing all positive integer solutions to the equation x^2 - Dy^2 = ±1 in terms of the fundamental solution to x^2 - Dy^2 = -1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\{(x,y):x+y\\sqrt{D}=(A_{\\ell-1}+B_{\\ell-1}\\sqrt{D})^k,k\\in\\mathbf N_+\\}\n```\n\n----------------------------------------\n\nTITLE: Defining Sitemap URL Location\nDESCRIPTION: Basic text configuration specifying the location of the XML sitemap file for search engine crawlers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/robots.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nSitemap: https://oi-wiki.org/sitemap.xml\n```\n\n----------------------------------------\n\nTITLE: YAML Frontmatter Block\nDESCRIPTION: Simple YAML frontmatter block defining the author as 'Ir1d'\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/geometry/misc.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nauthor: Ir1d\n```\n\n----------------------------------------\n\nTITLE: Optimized High-Precision Addition with Digit Compression in C++\nDESCRIPTION: An optimized implementation of high-precision addition using digit compression technique to improve computational efficiency by operating on multiple digits at once.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/bignum.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nvoid add(int a[], int b[], int c[]) {\n  clear(c);\n\n  for (int i = 0; i < LEN - 1; ++i) {\n    c[i] += a[i] + b[i];\n    if (c[i] >= p) {  // 在普通高精度运算下，p=10\n      c[i + 1] += 1;\n      c[i] -= p;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Correspondence Theorem for Rings\nDESCRIPTION: The statement of the correspondence theorem for rings, establishing a bijection between subrings containing an ideal and subrings of the quotient ring.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/ring-theory.md#2025-04-22_snippet_9\n\nLANGUAGE: markdown\nCODE:\n```\n???+ note \"对应定理\"\n    设环 $R$ 有理想 $I$，则全体包含 $I$ 的环 $R$ 的子环 $\\mathcal S=\\{S:I\\subseteq S\\subseteq R\\}$ 和商群 $R/I$ 的全体子群 $\\mathcal T=\\{T:T\\le R/I\\}$ 之间存在双射 $\\varphi:\\mathcal S\\rightarrow\\mathcal T$，它将 $S\\in\\mathcal S$ 映射至 $S/I\\in\\mathcal T$。这个双射保持子环的包含关系，且环 $R$ 的理想总是映射到 $R/I$ 的理想。\n```\n\n----------------------------------------\n\nTITLE: Defining Formal Derivatives of Polynomials in LaTeX\nDESCRIPTION: Mathematical definition of the formal derivative of a polynomial over a field F, showing how the coefficients transform according to the standard differentiation rules.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_8\n\nLANGUAGE: tex\nCODE:\n```\nf(x)=a_0+a_1x+a_2x^2+\\cdots+a_{n-1}x^{n-1}+a_nx^n=\\sum_{i=0}^na_ix^i\n```\n\nLANGUAGE: tex\nCODE:\n```\nDf(x)=a_1+2a_2x+\\cdots+(n-1)a_{n-1}x^{n-1}+na_nx^{n-1}=\\sum_{i=1}^nia_ix^{i-1}.\n```\n\n----------------------------------------\n\nTITLE: Prime Power Modulo Congruence Equation\nDESCRIPTION: Equation for congruence modulo p^a where p is a prime number and a is a positive integer greater than 1.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/congruence-equation.md#2025-04-22_snippet_1\n\nLANGUAGE: math\nCODE:\n```\nf(x)\\equiv 0\\pmod{p^{a-1}}\\tag{2}\n```\n\nLANGUAGE: math\nCODE:\n```\nx=x_0+p^{a-1}t\\tag{3}\n```\n\nLANGUAGE: math\nCODE:\n```\nf(x)\\equiv 0\\pmod{p^a}\\tag{4}\n```\n\nLANGUAGE: math\nCODE:\n```\ntf'(x_0)\\equiv -\\frac{f(x_0)}{p^{a-1}}\\pmod p\\tag{5}\n```\n\n----------------------------------------\n\nTITLE: Escaping Special Characters in LaTeX\nDESCRIPTION: Shows how to properly escape special characters in LaTeX by adding backslashes in front of them. For characters like ^ and ~, empty curly braces need to be added afterwards to avoid them being interpreted as superscripts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_0\n\nLANGUAGE: tex\nCODE:\n```\n\\# \\$ \\% \\^{} \\& \\_ \\{ \\} \\~{}\n```\n\n----------------------------------------\n\nTITLE: Launching xterm with X11 forwarding in WSL\nDESCRIPTION: Command to launch xterm graphical terminal in WSL by setting the DISPLAY environment variable to point to the Xming X server running on Windows.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/wsl.md#2025-04-22_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ DISPLAY=:0 xterm\n```\n\n----------------------------------------\n\nTITLE: Contestant List Format\nDESCRIPTION: Format for the contestant list file showing ID and name pairs\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/arbiter.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n<contestant_1's ID>,<contestant_1's name>\n<contestant_2's ID>,<contestant_2's name>\n...\n```\n\n----------------------------------------\n\nTITLE: Expressing Capacity Constraint in LaTeX\nDESCRIPTION: Formulates the capacity constraint for network flows using LaTeX mathematical notation, stating that flow must not exceed capacity for any edge.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/flow.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n0 \\leq f(u,v) \\leq c(u,v)\n```\n\n----------------------------------------\n\nTITLE: Defining Mixed Product in LaTeX\nDESCRIPTION: LaTeX code for defining the mixed product of three vectors using a determinant representation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\begin{vmatrix}\n    a_x & b_x & c_x \\\\\n    a_y & b_y & c_y \\\\\n    a_z & b_z & c_z\n\\end{vmatrix}\n```\n\n----------------------------------------\n\nTITLE: Field Isomorphism for Simple Algebraic Extensions\nDESCRIPTION: A mathematical expression showing that a simple algebraic extension F(α) is isomorphic to the quotient ring of the polynomial ring F[x] modulo the ideal generated by the minimal polynomial of α.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\nF[x]/(f(x))\\cong F(\\alpha).\n```\n\n----------------------------------------\n\nTITLE: Defining Disjoint Union Construction for Combinatorial Classes in LaTeX\nDESCRIPTION: Defines the disjoint union construction for two combinatorial classes A and B, ensuring they remain distinct by using colored neutral objects.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\mathcal{A}+\\mathcal{B}=(\\mathcal{E}_{1}\\times\\mathcal{A})+(\\mathcal{E}_2\\times\\mathcal{B})\n```\n\n----------------------------------------\n\nTITLE: Displaying LaTeX Equation for Solution Verification\nDESCRIPTION: A LaTeX equation showing the verification of the solution for x^2 - 41y^2 = 1 by squaring the intermediate solution.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/pell-equation.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n(32+5\\sqrt{41})^2=2049+320\\sqrt{41}.\n```\n\n----------------------------------------\n\nTITLE: DLX Dance Operation Implementation in C++\nDESCRIPTION: Core recursive operation for solving exact cover problems. Handles column selection, row removal/recovery and solution tracking.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/search/dlx.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nbool dance(int dep) {\n  int i, j, c = R[0];\n  if (!R[0]) {\n    ans = dep;\n    return true;\n  }\n  IT(i, R, 0) if (siz[i] < siz[c]) c = i;\n  remove(c);\n  IT(i, D, c) {\n    stk[dep] = row[i];\n    IT(j, R, i) remove(col[j]);\n    if (dance(dep + 1)) return true;\n    IT(j, L, i) recover(col[j]);\n  }\n  recover(c);\n  return false;\n}\n```\n\n----------------------------------------\n\nTITLE: General Formula for Second Stirling Numbers in LaTeX\nDESCRIPTION: This LaTeX equation presents the general formula for Second Stirling Numbers. It expresses S(n,m) as a sum involving binomial coefficients and powers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/stirling.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{Bmatrix}n\\\\m\\end{Bmatrix}=\\sum\\limits_{i=0}^m\\dfrac{(-1)^{m-i}i^n}{i!(m-i)!}\n```\n\n----------------------------------------\n\nTITLE: Representing Total Differential in LaTeX\nDESCRIPTION: LaTeX code for expressing the total differential of a function f with respect to multiple variables.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\mathrm{d}f(x, y, \\dots)=\\dfrac{\\partial f}{\\partial x}\\mathrm{d}x+\\dfrac{\\partial f}{\\partial y}\\mathrm{d}y+\\dots\n```\n\n----------------------------------------\n\nTITLE: Both Forms of Double Cross Product\nDESCRIPTION: The complete set of double cross product formulas showing how the order of operations matters. The formulas differ depending on whether the first or second cross product is performed first.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n(\\boldsymbol a\\times \\boldsymbol b)\\times \\boldsymbol c &=(\\boldsymbol a \\cdot \\boldsymbol c)\\boldsymbol b - (\\boldsymbol b \\cdot \\boldsymbol c)\\boldsymbol a \\\\\n\\boldsymbol a \\times(\\boldsymbol b \\times \\boldsymbol c) &= (\\boldsymbol a \\cdot \\boldsymbol c)\\boldsymbol b - (\\boldsymbol a \\cdot \\boldsymbol b)\\boldsymbol c\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Defining Inner Product in LaTeX\nDESCRIPTION: LaTeX code for defining the inner product (dot product) of two vectors using geometric and algebraic definitions.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/product.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\boldsymbol{a} \\cdot \\boldsymbol{b} = |\\boldsymbol{a}| |\\boldsymbol{b}| \\cos \\theta\n```\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\boldsymbol{a} \\cdot \\boldsymbol{b} = \\sum_{i = 1}^{n} a_i b_i\n```\n\n----------------------------------------\n\nTITLE: Structure of Single Algebraic Extension F(α)\nDESCRIPTION: Defines the structure of a single algebraic extension F(α) as a set of polynomial expressions in α with coefficients in F.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_5\n\nLANGUAGE: LaTeX\nCODE:\n```\nF(\\alpha)=\\{\\lambda(\\alpha)=\\lambda_0+\\lambda_1\\alpha+\\cdots+\\lambda_{n-1}\\alpha^{n-1}:\\lambda_0,\\lambda_1,\\cdots,\\lambda_{n-1}\\in F\\}.\n```\n\n----------------------------------------\n\nTITLE: Constructing the Nilpotent Component\nDESCRIPTION: Formula for constructing the nilpotent component of a linear transformation in the Jordan decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\nT_N=T-T_D\n```\n\n----------------------------------------\n\nTITLE: Defining Zigzag Numbers in LaTeX\nDESCRIPTION: Defines zigzag numbers in terms of zigzag permutations and provides their recursive relationship using LaTeX mathematical notation.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nA_n=\\frac{Z_n}{2}\n$$\n\n$$\nA_0=A_1=1\n$$\n\n$$\n2A_{n+1}=\\sum_{k=0}^n \\dbinom{n}{k} A_k A_{n-k}\n$$\n```\n\n----------------------------------------\n\nTITLE: Finding Number with Most Divisors Below N in C++\nDESCRIPTION: This code implements a depth-first search algorithm to find the number with the most divisors below a given limit N. It uses prime factorization and keeps track of the maximum number of divisors encountered.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/prime.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nconst int MAX_PRIME = 50;\nlong long prime[MAX_PRIME] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\nlong long ans, n;\nint mxs;\n\nvoid dfs(long long val, int prime_index, int power, long long mult) {\n    if (mult > mxs) {\n        mxs = mult;\n        ans = val;\n    } else if (mult == mxs && val < ans) {\n        ans = val;\n    }\n    if (prime_index == MAX_PRIME) return;\n    long long nxt = val;\n    for (int i = 1; i <= power; i++) {\n        if (nxt <= n / prime[prime_index]) {\n            nxt *= prime[prime_index];\n            dfs(nxt, prime_index + 1, i, mult * (i + 1));\n        } else {\n            break;\n        }\n    }\n}\n\nint main() {\n    while (scanf(\"%lld\", &n) != EOF) {\n        ans = 0;\n        mxs = 0;\n        dfs(1, 0, 60, 1);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing custom lower_bound and upper_bound with bsearch in C\nDESCRIPTION: Implementation of custom comparison functions to simulate lower_bound and upper_bound functionality using C's bsearch function. This implementation requires the array to be a global array and works by manipulating pointer arithmetic.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/basic/binary.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nint A[100005];  // 示例全局数组\n\n// 查找首个不小于待查元素的元素的地址\nint lower(const void *p1, const void *p2) {\n  int *a = (int *)p1;\n  int *b = (int *)p2;\n  if ((b == A || compare(a, b - 1) > 0) && compare(a, b) > 0)\n    return 1;\n  else if (b != A && compare(a, b - 1) <= 0)\n    return -1;  // 用到地址的减法，因此必须指定元素类型\n  else\n    return 0;\n}\n\n// 查找首个大于待查元素的元素的地址\nint upper(const void *p1, const void *p2) {\n  int *a = (int *)p1;\n  int *b = (int *)p2;\n  if ((b == A || compare(a, b - 1) >= 0) && compare(a, b) >= 0)\n    return 1;\n  else if (b != A && compare(a, b - 1) < 0)\n    return -1;  // 用到地址的减法，因此必须指定元素类型\n  else\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Cycle Index for Symmetric Group Sn\nDESCRIPTION: Formula for the cycle index of the symmetric group Sn, representing all possible permutations of n elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/polya.md#2025-04-22_snippet_11\n\nLANGUAGE: latex\nCODE:\n```\nZ(S_n)=\\sum_{a_1+2\\alpha_2+\\cdots+n\\alpha_n=n}\\frac{t_1^{\\alpha_1}t_2^{\\alpha_2}\\cdots t_n^{\\alpha_n}}{1^{\\alpha_1}2^{\\alpha_2}\\cdots n^{\\alpha_n}\\alpha_1!\\alpha_2!\\cdots\\alpha_n!}.\n```\n\n----------------------------------------\n\nTITLE: DGF for Riemann Zeta Function in LaTeX\nDESCRIPTION: LaTeX formula showing the DGF representation of the Riemann zeta function.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/dgf.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\zeta(x) = \\prod_{p\\in\\mathcal{P}} \\left(1 + \\frac{1}{p^x} + \\frac{1}{p^{2x}} + \\ldots \\right) = \\prod_{p\\in \\mathcal{P}} \\frac{1}{1-p^{-x}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Proof for Part 1 of LTE Lemma\nDESCRIPTION: Proof demonstrating why the first part of the Lifting the Exponent lemma holds, showing that when p divides x-y, then x^n-y^n can be factored with specific properties related to p.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/lift-the-exponent.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\sum_{i=0}^{n-1}x^iy^{n-1-i}\\equiv nx^{n-1}\\not\\equiv 0\\pmod p\n```\n\n----------------------------------------\n\nTITLE: Naive Delta2 Table Builder Implementation in Rust\nDESCRIPTION: A naive implementation of the delta2 table builder for the Boyer-Moore algorithm. Uses a brute force approach to find pattern repetitions. Has O(n^3) time complexity but works well for small patterns.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/string/bm.md#2025-04-22_snippet_3\n\nLANGUAGE: Rust\nCODE:\n```\nuse std::cmp::PartialEq;\n\npub fn build_delta_2_table_naive(p: &[impl PartialEq]) -> Vec<usize> {\n    let patlen = p.len();\n    let lastpos = patlen - 1;\n    let mut delta_2 = vec![];\n\n    for i in 0..patlen {\n        let subpatlen = (lastpos - i) as isize;\n\n        if subpatlen == 0 {\n            delta_2.push(0);\n            break;\n        }\n\n        for j in (-subpatlen..(i + 1) as isize).rev() {\n            if (j..j + subpatlen)\n            .zip(i + 1..patlen)\n            .all(|(rpr_index, subpat_index)| {\n                if rpr_index < 0 {\n                    return true;\n                }\n\n                if p[rpr_index as usize] == p[subpat_index] {\n                    return true;\n                }\n\n                false\n            })\n            && (j <= 0 || p[(j - 1) as usize] != p[i])\n            {\n                delta_2.push((lastpos as isize - j) as usize);\n                break;\n            }\n        }\n    }\n\n    delta_2\n}\n```\n\n----------------------------------------\n\nTITLE: Kronecker Symbol Values for Gaussian Integers in LaTeX\nDESCRIPTION: LaTeX formula showing the values of the Kronecker symbol for Gaussian integers based on different cases of n modulo 4.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quadratic.md#2025-04-22_snippet_4\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\left(\\dfrac{-4}{n}\\right) = \\begin{cases}\n+1,& n\\equiv 1\\pmod 4,\\\\\n-1,& n\\equiv 3\\pmod 4,\\\\\n0,& 2\\mid n.\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Restricted Construction Formula for MSET\nDESCRIPTION: Formula showing the generating function for restricted Multiset construction with parameter k.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/symbolic-method.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\nA(z,u)=\\prod_n\\left(1-uz^n\\right)^{-b_n}\\\\ \\implies A(z)=\\lbrack u^k\\rbrack \\exp\\left(\\frac{u}{1}B(z)+\\frac{u^2}{2}B(z^2)+\\frac{u^3}{3}B(z^3)+\\cdots\\right)\n```\n\n----------------------------------------\n\nTITLE: K-th Max/Min Formula\nDESCRIPTION: Advanced formulas for finding the k-th maximum/minimum elements using inclusion-exclusion principle.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/inclusion-exclusion-principle.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\underset{i\\in S}{\\operatorname{kthmax}{x_i}}=\\sum_{T\\subseteq S}{(-1)^{|T|-k}\\dbinom {|T|-1}{k-1}\\min_{j\\in T}{x_j}}\n\n\\underset{i\\in S}{\\operatorname{kthmin}{x_i}}=\\sum_{T\\subseteq S}{(-1)^{|T|-k}\\dbinom {|T|-1}{k-1}\\max_{j\\in T}{x_j}}\n```\n\n----------------------------------------\n\nTITLE: Vector Test Output Code in C++\nDESCRIPTION: Example code showing how to print contents of multiple vector objects using copy algorithm and ostream_iterator.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/sequence-container.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n// 以下是测试代码，有兴趣的同学可以自己编译运行一下本代码。\ncout << \"v1 = \";\ncopy(v1.begin(), v1.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\ncout << \"v2 = \";\ncopy(v2.begin(), v2.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\ncout << \"v3 = \";\ncopy(v3.begin(), v3.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\ncout << \"v4 = \";\ncopy(v4.begin(), v4.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\ncout << \"v5 = \";\ncopy(v5.begin(), v5.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\ncout << \"v6 = \";\ncopy(v6.begin(), v6.end(), ostream_iterator<int>(cout, \" \"));\ncout << endl;\n```\n\n----------------------------------------\n\nTITLE: Defining Class Equation in Group Theory\nDESCRIPTION: This LaTeX snippet shows the class equation for a group G, expressing its order in terms of the center and the indices of centralizers of non-central elements.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_9\n\nLANGUAGE: LaTeX\nCODE:\n```\n|G|=|Z(G)|+\\sum_{i=1}^r[G:C_G(g_i)].\n```\n\n----------------------------------------\n\nTITLE: Calculating Sprague-Grundy Function in Python\nDESCRIPTION: This code snippet defines the Sprague-Grundy (SG) function for a game state. It uses the mex function to calculate the SG value based on the SG values of all possible next states.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/game-theory/impartial-game.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef SG(x, next_states):\n    return mex({SG(y, next_states) for y in next_states[x]})\n```\n\n----------------------------------------\n\nTITLE: DGF Product for Dirichlet Convolution in LaTeX\nDESCRIPTION: LaTeX formula showing how the product of DGFs corresponds to the Dirichlet convolution of sequences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/dgf.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\tilde{F}(x)\\tilde{G}(x) = \\sum_{i} \\sum_{j}\\frac{f_i g_j}{(ij)^x} = \\sum_{i} \\frac{1}{i^x}\\sum_{d | i} f_d g_{\\frac{i}{d}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Dangling Reference - Local Variable Issue in C++\nDESCRIPTION: This example demonstrates a common dangling reference issue where a function returns a reference to a local variable that goes out of scope, leading to undefined behavior when the reference is accessed.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/reference.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n#include <iostream>\n\nint& foo() {\n  int a = 1;\n  return a;\n}\n\nint main() {\n  int& b = foo();\n  std::cout << b << std::endl;  // 未定义行为\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Jacobian Matrix in LaTeX\nDESCRIPTION: LaTeX code for defining the Jacobian matrix, which represents partial derivatives of multiple functions with respect to multiple variables.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\dfrac{\\partial(f_1, \\dots, f_m)}{\\partial(x_1, \\dots, x_n)}=\\begin{pmatrix}\\dfrac{\\partial f_1}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_1}{\\partial x_n}\\\\\\vdots&\\ddots&\\vdots\\\\\\dfrac{\\partial f_m}{\\partial x_1}&\\cdots&\\dfrac{\\partial f_m}{\\partial x_n}\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Inserting Netlify Logo in HTML\nDESCRIPTION: This HTML snippet inserts the Netlify logo with a link to their website. It uses inline styling for alignment and image properties.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<div align=\"center\">\n<a href=\"https://www.netlify.com/\" target=\"_blank\" style=\"margin-left: 60px;\"><img style=\"height: 40px; \" src=\"images/netlify.png\"></a>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Defining Quadratic Integers in LaTeX\nDESCRIPTION: LaTeX formula for representing quadratic integers in the form a + bω, where a and b are integers and ω is defined based on the value of d modulo 4.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quadratic.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\na+b\\omega\n```\n\nLANGUAGE: LaTeX\nCODE:\n```\n\\omega=\\begin{cases}\n\\dfrac{1+\\sqrt{d}}{2}, & d\\equiv 1\\pmod 4,\\\\\n\\sqrt{d}, & d\\equiv 2,3\\pmod 4.\n\\end{cases}\n```\n\n----------------------------------------\n\nTITLE: Tree Isomorphism Solution using Centroids in C++\nDESCRIPTION: Another approach to solve the BJOI2015 tree isomorphism problem, this code finds tree centroids and compares hash values of centroid-rooted trees to determine isomorphism.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/tree-hash.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\n--8<-- \"docs/graph/code/tree-hash/tree-hash_3.cpp\"\n```\n\n----------------------------------------\n\nTITLE: Complex Map Type Definition\nDESCRIPTION: Shows how to define a Map with complex value types like Set.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_21\n\nLANGUAGE: java\nCODE:\n```\nMap<String, Set<Integer>> map = new HashMap<>();\n```\n\n----------------------------------------\n\nTITLE: Defining Convolution of Functions in LaTeX\nDESCRIPTION: LaTeX code for defining the convolution of two functions f and g.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n(f*g)(x)=\\int\\limits_{-\\infty}^{\\infty}f(y)g(x-y)\\mathrm{d}y\n```\n\n----------------------------------------\n\nTITLE: Derivative Proof of Quadrangle Inequality\nDESCRIPTION: LaTeX representation of the derivative proof showing how quadrangle inequality is preserved under certain conditions\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\frac{\\partial^2}{\\partial x\\partial y}h(w(x,y)) = h''(w(x,y))\\frac{\\partial }{\\partial x}w(x,y)\\frac{\\partial}{\\partial y}w(x,y) + h'(w(x,y))\\frac{\\partial^2}{\\partial x\\partial y}w(x,y) \\leq 0\n```\n\n----------------------------------------\n\nTITLE: Commutativity in Jordan Decomposition\nDESCRIPTION: Formula showing that the diagonalizable and nilpotent components of a linear transformation commute with each other.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\nT_DT_N=T_NT_D\n```\n\n----------------------------------------\n\nTITLE: Contribution of Light Child Nodes in Tree Decomposition\nDESCRIPTION: Defines the contributions (g_{i,1} and g_{i,0}) of light child nodes in the modified dynamic programming equation for tree decomposition.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/basic.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\ng_{i,1}&=\\sum_{j\\in S(i),\\ j\\neq h}f_{j,0},\\\\\ng_{i,0}&=\\sum_{j\\in S(i),\\ j\\neq h}\\max\\{f_{j,1},f_{j,0}\\}\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Rotation Operator LaTeX Definition\nDESCRIPTION: LaTeX code for expressing the rotation operator (rot) with proper mathematical formatting\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/symbol.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\operatorname{\\mathbf{rot}}\n```\n\n----------------------------------------\n\nTITLE: Nilpotent Jordan Block Matrix in LaTeX\nDESCRIPTION: Mathematical representation of an r×r nilpotent Jordan block, which is an upper triangular matrix with 1's on the superdiagonal and 0's elsewhere, used in the canonical form of nilpotent matrices.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/diagonalization.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\nN_r=\\begin{pmatrix}\n0 & 1 & 0 & \\cdots & 0 & 0\\\\\n0 & 0 & 1 & \\cdots & 0 & 0\\\\\n0 & 0 & 0 & \\cdots & 0 & 0\\\\\n\\vdots & \\vdots & \\vdots &   & \\vdots& \\vdots\\\\\n0 & 0 & 0 & \\cdots & 0 & 1\\\\\n0 & 0 & 0 & \\cdots & 0 & 0\\\\\n\\end{pmatrix}\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation for Laplace Matrix in Wheel Virus Problem\nDESCRIPTION: Matrix representation of the n+1 order Laplace matrix for the wheel virus problem. The matrix has a specific structure with n in the first diagonal element and 3s along the rest of the diagonal, with -1s in specific positions representing edge connections.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/matrix-tree.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\nL_n = \\begin{bmatrix}\nn&\t-1&\t-1&\t-1&\t\\cdots&\t-1&\t-1\\\\\n-1&\t3&\t-1&\t0&\t\\cdots&\t0&\t-1\\\\\n-1&\t-1&\t3&\t-1&\t\\cdots&\t0&\t0\\\\\n-1&\t0&\t-1&\t3&\t\\cdots&\t0&\t0\\\\\n\\vdots&\t\\vdots&\t\\vdots&\t\\vdots&\t\\ddots&\t\\vdots&\t\\vdots\\\\\n-1&\t0&\t0&\t0&\t\\cdots&\t3&\t-1\\\\\n-1&\t-1&\t0&\t0&\t\\cdots&\t-1&\t3\\\\\n\\end{bmatrix}_{n+1}\n```\n\n----------------------------------------\n\nTITLE: BibTeX Entry Format for Academic Article\nDESCRIPTION: Demonstrates the proper format for entering an academic article reference in a BibTeX file, including author names, title, journal, volume, pages, and year information.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n@article{\n    Birdetal2001,\n    Author = {Bird, R. B. and Smith, E. A. and Bird, D. W.},\n    Title = {The hunting handicap: costly signaling in human foraging strategies},\n    Journal = {Behavioral Ecology and Sociobiology},\n    Volume = {50},\n    Pages = {9-19},\n    Year = {2001} \n}\n```\n\n----------------------------------------\n\nTITLE: Jordan Decomposition of Linear Transformation\nDESCRIPTION: Core equation of the Jordan decomposition showing how a linear transformation can be split into diagonalizable and nilpotent parts.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/jordan.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\nT=T_D+T_N\n```\n\n----------------------------------------\n\nTITLE: Including Priority Queue Header in C++\nDESCRIPTION: Header file inclusion for using STL priority queue container.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\n#include <queue>\n```\n\n----------------------------------------\n\nTITLE: Implementing Gaussian Elimination-based Matching Algorithm in C++\nDESCRIPTION: Implements a function to eliminate a specific row and column from a matrix as part of the Gaussian Elimination-based matching algorithm. This function is used to update the inverse of the Tutte matrix after removing matched vertices from the graph.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/graph-matching/general-match.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nvoid eliminate(int A[][MAXN], int r, int c) {  // 消去第 r 行第 c 列\n  row_marked[r] = col_marked[c] = true;        // 已经被消掉\n\n  int inv = quick_power(A[r][c], p - 2);  // 逆元\n\n  for (int i = 1; i <= n; i++)\n    if (!row_marked[i] && A[i][c]) {\n      int tmp = (long long)A[i][c] * inv % p;\n\n      for (int j = 1; j <= n; j++)\n        if (!col_marked[j] && A[r][j])\n          A[i][j] = (A[i][j] - (long long)tmp * A[r][j]) % p;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Inserting Bibliography in LaTeX\nDESCRIPTION: Shows how to insert a bibliography in a LaTeX document by specifying the bibliography style and referencing the BibTeX file.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/latex.md#2025-04-22_snippet_8\n\nLANGUAGE: tex\nCODE:\n```\n\\bibliographystyle{plain}\n\\bibliography{references}\n```\n\n----------------------------------------\n\nTITLE: Mathematical Proof of Composite Function Properties\nDESCRIPTION: LaTeX proof showing how composite functions preserve quadrangle inequality properties under certain conditions\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/dp/opt/quadrangle.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{aligned}\n\\Delta_i\\Delta_j h\\left(w(j,i)\\right)\n&= h\\left(w(b,d)\\right) - h\\left(w(a,c) + \\Delta_jw(j,c) + \\Delta_iw(a,i)\\right) \\\\\n&\\quad + h\\left(w(a,c) + \\Delta_jw(j,c) + \\Delta_iw(a,i)\\right) - h\\left(w(a,c) + \\Delta_jw(j,c)\\right) \\\\\n&\\quad - h\\left(w(a,c) + \\Delta_iw(a,i)\\right) + h\\left(w(a,c)\\right).\n\\end{aligned}\n```\n\n----------------------------------------\n\nTITLE: Displaying Warning Message in Markdown\nDESCRIPTION: This snippet shows how to create a warning message block in Markdown using the admonition syntax. It informs contributors about the importance of following the guidelines.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/intro/what-oi-wiki-is-not.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n???+ warning \"注意\"\n    作为项目方针的一部分，本页面十分重要，每个贡献者都应确保您的贡献满足如下条件。\n```\n\n----------------------------------------\n\nTITLE: Implementing Scapegoat Tree Rebuild Operation in C++\nDESCRIPTION: Performs an in-order traversal of the subtree to be rebuilt, then reconstructs a balanced tree from the sorted nodes. This is a key operation for maintaining balance in a scapegoat tree.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/sgt.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nint tmp[N], len;\n\nvoid dfs(int& x) {\n  if (!x) return;\n  dfs(lc[x]);\n  if (cnt[x]) tmp[++len] = x;\n  dfs(rc[x]);\n}\n\nint build(int l, int r) {\n  if (l > r) return 0;\n  int mid = (l + r) >> 1;\n  int x = tmp[mid];\n  lc[x] = build(l, mid - 1);\n  rc[x] = build(mid + 1, r);\n  push_up(x);\n  return x;\n}\n\nvoid rebuild(int& x) {\n  len = 0;\n  dfs(x);\n  x = build(1, len);\n}\n```\n\n----------------------------------------\n\nTITLE: Modified Markdown Processing Rules\nDESCRIPTION: Lists the three main modifications made to mdast-util-to-markdown: implementation of 2-space style hardbreaks, prevention of ampersand escaping, and modification of heading detection to avoid treating equal signs as headers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/patches/README.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- 使用 2 space style 的 hardbreak\\n- 避免 escape `&`\\n- 避免将等号视为 heading\n```\n\n----------------------------------------\n\nTITLE: Displaying Seidel–Entringer–Arnold Triangle in LaTeX\nDESCRIPTION: Illustrates the Seidel–Entringer–Arnold triangle using LaTeX aligned environment, showing the 'ox-plowing' order of Entringer numbers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/combinatorics/entringer.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\n\\begin{aligned}\n& E(0,0) \\\\\n& E(1,0) \\rightarrow E(1,1) \\\\\n& E(2,2) \\leftarrow E(2,1) \\leftarrow E(2,0) \\\\\n& E(3,0) \\rightarrow E(3,1) \\rightarrow E(3,2) \\rightarrow E(3,3) \\\\\n& E(4,4) \\leftarrow E(4,3) \\leftarrow E(4,2) \\leftarrow E(4,1) \\leftarrow E(4,0)\n\\end{aligned}\n$$\n```\n\n----------------------------------------\n\nTITLE: Signed Overflow Undefined Behavior Example in C++\nDESCRIPTION: Demonstrates how a compiler can optimize code based on the assumption that signed integer overflow won't occur. The function can be simplified from 'x * 2 / 2' to just 'x' since multiplication overflow is undefined behavior.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/optimizations.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nint f(int x) { return x * 2 / 2; }\n```\n\n----------------------------------------\n\nTITLE: Defining Matching for Graphs in LaTeX\nDESCRIPTION: This snippet defines the concept of a matching E' for a graph G, where no two edges in E' share a common endpoint and none of the edges in E' are self-loops.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/graph/concept.md#2025-04-22_snippet_6\n\nLANGUAGE: LaTeX\nCODE:\n```\nE'\\in E \\text{ and no two edges in } E' \\text{ share a common endpoint, and no edge in } E' \\text{ is a self-loop}\n```\n\n----------------------------------------\n\nTITLE: Comparing while Loops in Pascal and C++\nDESCRIPTION: Demonstrates the syntax differences between Pascal and C++ for while loops, showing how to initialize, increment variables, and output in a loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_5\n\nLANGUAGE: Pascal\nCODE:\n```\nvar i: integer;\n\nbegin\n    i := 1;\n    while i <= 10 do\n        begin\n            write(i,' ');\n            inc(i); // 或者 i := i + 1;\n        end;\nend.\n```\n\nLANGUAGE: C++\nCODE:\n```\nint i = 1;\nwhile (i <= 10) {\n  std::cout << i << \" \";\n  i++;\n}\n```\n\n----------------------------------------\n\nTITLE: Set Traversal Example\nDESCRIPTION: Shows how to iterate through elements in a Set using a for-each loop.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/java-pro.md#2025-04-22_snippet_17\n\nLANGUAGE: java\nCODE:\n```\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class Main {\n    static PrintWriter out = new PrintWriter(System.out);\n    static Set<Integer> s1 = new HashSet<>();\n    static Set<Integer> s2 = new LinkedHashSet<>();\n\n    static void test() {\n        for (int key : s1) {\n            out.println(key);\n        }\n        out.close();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Equality for Sylow Subgroups in Group Theory\nDESCRIPTION: This LaTeX snippet shows an equality involving the number of Sylow p-subgroups (|S|) and the indices of their intersections with a p-subgroup Q.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/group-theory.md#2025-04-22_snippet_10\n\nLANGUAGE: LaTeX\nCODE:\n```\n|\\mathcal S|=\\sum_{i=1}^r[Q:Q\\cap P_i].\n```\n\n----------------------------------------\n\nTITLE: Comparing repeat/do-while Loops in Pascal and C++\nDESCRIPTION: Shows the syntax differences between Pascal's repeat-until and C++'s do-while loops, highlighting the condition logic differences.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/pas-cpp.md#2025-04-22_snippet_7\n\nLANGUAGE: Pascal\nCODE:\n```\nvar i: integer;\n\nbegin\n    i := 1;\n    repeat\n        write(i, ' ');\n        inc(i);\n    until i = 11;\nend.\n```\n\nLANGUAGE: C++\nCODE:\n```\nint i = 1;\ndo {\n  std::cout << i << \" \";\n  i++;\n} while (i <= 10);\n```\n\n----------------------------------------\n\nTITLE: Freshman's Dream Formula in Finite Characteristic Fields\nDESCRIPTION: A mathematical formula showing the Freshman's Dream property that applies in fields of characteristic p, where the p-th power of a sum equals the sum of the p-th powers.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n(x+y)^p=x^p+y^p\n```\n\n----------------------------------------\n\nTITLE: Decomposition of Nth Roots of Unity Groups\nDESCRIPTION: Mathematical expression showing how the group of nth roots of unity decomposes into the union of primitive roots of various orders that divide n.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/algebra/field-theory.md#2025-04-22_snippet_10\n\nLANGUAGE: tex\nCODE:\n```\nC_n=\\bigcup_{d|n}P_d.\n```\n\n----------------------------------------\n\nTITLE: Referencing C++ Rope Data Structure\nDESCRIPTION: Mentions C++ rope as an example of a persistent data structure used for efficient string operations, particularly for merging and avoiding performance degradation due to duplicate substrings.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/ds/persistent.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nC++ rope\n```\n\n----------------------------------------\n\nTITLE: Including Images in Problem Statements\nDESCRIPTION: TeX command for including images in Polygon problem statements. The image file must first be uploaded to Statement Resource Files.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/polygon.md#2025-04-22_snippet_1\n\nLANGUAGE: tex\nCODE:\n```\n\\includegraphics{filename.png}\n```\n\n----------------------------------------\n\nTITLE: Competition Directory Structure\nDESCRIPTION: Directory structure created by Arbiter showing configuration and data folders\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/tools/judger/arbiter.md#2025-04-22_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n<name>/\n| -- data\n| -- evaldata\n| -- filter\n| -- final\n| -- players\n| -- result\n| -- tmp\n`-- day1.info\n`-- player.info\n`-- setup.cfg\n`-- task1_1.info\n`-- task1_2.info\n`-- team.info\n```\n\n----------------------------------------\n\nTITLE: Defining Dirichlet Generating Function in LaTeX\nDESCRIPTION: LaTeX formula defining the Dirichlet generating function for an infinite sequence f1, f2, ...\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/poly/dgf.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\tilde{F}(x) = \\sum_{i\\ge 1}\\frac{f_i}{i^x}\n$$\n```\n\n----------------------------------------\n\nTITLE: Determinant Properties with Scalar Multiplication\nDESCRIPTION: Axiomatic property showing how scalar multiplication of a row or column affects the determinant value.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/linear-algebra/determinant.md#2025-04-22_snippet_8\n\nLANGUAGE: latex\nCODE:\n```\n\\det(D_i(k)A) = \\det(AD_i(k)) = k \\det A\n```\n\n----------------------------------------\n\nTITLE: Legendre算法数学公式\nDESCRIPTION: 描述了Legendre算法的核心数学公式，用于求解二次剩余问题。包括同余方程的表示和解的条件。\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/math/number-theory/quad-residue.md#2025-04-22_snippet_0\n\nLANGUAGE: math\nCODE:\n```\nx^2\\equiv a\\pmod p, \\\\r^2-a \\text{ 为二次非剩余}, \\\\ a_0+a_1x=(r-x)^{\\frac{p-1}{2}}\\bmod (x^2-a), \\\\ a_0\\equiv 0\\pmod p \\text{ 且 } a_1^{-2}\\equiv a\\pmod p\n```\n\n----------------------------------------\n\nTITLE: Including Stack Header in C++\nDESCRIPTION: Header file inclusion for using STL stack container.\nSOURCE: https://github.com/oi-wiki/oi-wiki/blob/master/docs/lang/csl/container-adapter.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <stack>\n```"
  }
]