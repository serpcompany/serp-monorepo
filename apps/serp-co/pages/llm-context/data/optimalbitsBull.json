[
  {
    "owner": "optimalbits",
    "repo": "bull",
    "content": "TITLE: Configuring Repeated Jobs with Bull Queue using Cron Expressions\nDESCRIPTION: This example demonstrates how to set up recurring jobs in Bull using cron expressions. It shows a payment job scheduled to run once every day at 3:15 am using the repeat option.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n  paymentsQueue.process(function (job) {\n    // Check payments\n  });\n\n  // Repeat payment job once every day at 3:15 (am)\n  paymentsQueue.add(paymentsData, { repeat: { cron: '15 3 * * *' } });\n\n```\n\n----------------------------------------\n\nTITLE: Processing Queue Jobs\nDESCRIPTION: Implementation of a consumer/worker that processes jobs from the queue using async/await.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst myFirstQueue = new Bull('my-first-queue');\n\nmyFirstQueue.process(async (job) => {\n  return doSomething(job.data);\n});\n```\n\n----------------------------------------\n\nTITLE: Job Options Interface for Bull Queue\nDESCRIPTION: TypeScript interface defining all available options when adding jobs to a Bull queue, including priority, delay, attempts, backoff strategies, and cleanup options.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ninterface JobOpts {\n  priority: number; // Optional priority value. ranges from 1 (highest priority) to MAX_INT  (lowest priority). Note that\n  // using priorities has a slight impact on performance, so do not use it if not required.\n\n  delay: number; // An amount of milliseconds to wait until this job can be processed. Note that for accurate delays, both\n  // server and clients should have their clocks synchronized. [optional].\n\n  attempts: number; // The total number of attempts to try the job until it completes.\n\n  repeat: RepeatOpts; // Repeat job according to a cron specification, see below for details.\n\n  backoff: number | BackoffOpts; // Backoff setting for automatic retries if the job fails, default strategy: `fixed`.\n  // Needs `attempts` to be set.\n\n  lifo: boolean; // if true, adds the job to the right of the queue instead of the left (default false)\n  timeout: number; // The number of milliseconds after which the job should fail with a timeout error [optional]\n\n  jobId: number | string; // Override the job ID - by default, the job ID is a unique\n  // integer, but you can use this setting to override it.\n  // If you use this option, it is up to you to ensure the\n  // jobId is unique. If you attempt to add a job with an id that\n  // already exists, it will not be added (see caveat below about repeatable jobs).\n\n  removeOnComplete: boolean | number | KeepJobs; // If true, removes the job when it successfully\n  // completes. A number specified the amount of jobs to keep. Default behavior is to keep the job in the completed set.\n  // See KeepJobs if using that interface instead.\n\n  removeOnFail: boolean | number | KeepJobs; // If true, removes the job when it fails after all attempts. A number specified the amount of jobs to keep, see KeepJobs if using that interface instead.\n  // Default behavior is to keep the job in the failed set.\n  stackTraceLimit: number; // Limits the amount of stack trace lines that will be recorded in the stacktrace.\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Queue Processing Functions in Bull\nDESCRIPTION: Shows the different ways to define processing functions for jobs in a Bull queue, including concurrency control and named processors.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Consider these as overloaded functions. Since method overloading doesn't exist in JavaScript,\n * Bull recognizes the desired function call by checking the parameters' types.\n * Make sure you comply with one of the below defined patterns.\n *\n * Note: Concurrency defaults to 1 if not specified.\n */\nprocess(processor: ((job, done?) => Promise<any>) | string)\nprocess(concurrency: number, processor: ((job, done?) => Promise<any>) | string)\nprocess(name: string, processor: ((job, done?) => Promise<any>) | string)\nprocess(name: string, concurrency: number, processor: ((job, done?) => Promise<any>) | string)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Processing Jobs with Bull Queues in JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of Bull queues for processing various media transcoding tasks. It shows how to create queues with different Redis connection options, define job processors with progress reporting and error handling, and add jobs to the queues.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\n\nconst videoQueue = new Queue('video transcoding', 'redis://127.0.0.1:6379');\nconst audioQueue = new Queue('audio transcoding', { redis: { port: 6379, host: '127.0.0.1', password: 'foobared' } }); // Specify Redis connection using object\nconst imageQueue = new Queue('image transcoding');\nconst pdfQueue = new Queue('pdf transcoding');\n\nvideoQueue.process(function (job, done) {\n\n  // job.data contains the custom data passed when the job was created\n  // job.id contains id of this job.\n\n  // transcode video asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give an error if error\n  done(new Error('error transcoding'));\n\n  // or pass it a result\n  done(null, { framerate: 29.5 /* etc... */ });\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw new Error('some unexpected error');\n});\n\naudioQueue.process(function (job, done) {\n  // transcode audio asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give an error if error\n  done(new Error('error transcoding'));\n\n  // or pass it a result\n  done(null, { samplerate: 48000 /* etc... */ });\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw new Error('some unexpected error');\n});\n\nimageQueue.process(function (job, done) {\n  // transcode image asynchronously and report progress\n  job.progress(42);\n\n  // call done when finished\n  done();\n\n  // or give an error if error\n  done(new Error('error transcoding'));\n\n  // or pass it a result\n  done(null, { width: 1280, height: 720 /* etc... */ });\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw new Error('some unexpected error');\n});\n\npdfQueue.process(function (job) {\n  // Processors can also return promises instead of using the done callback\n  return pdfAsyncProcessor();\n});\n\nvideoQueue.add({ video: 'http://example.com/video1.mov' });\naudioQueue.add({ audio: 'http://example.com/audio1.mp3' });\nimageQueue.add({ image: 'http://example.com/image1.tiff' });\n```\n\n----------------------------------------\n\nTITLE: Implementing Message Queue Pattern with Bull\nDESCRIPTION: Demonstrates how to set up bidirectional communication between two servers using Bull queues. Shows both sending and receiving message implementations.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\n\nconst sendQueue = new Queue('Server B');\nconst receiveQueue = new Queue('Server A');\n\nreceiveQueue.process(function (job, done) {\n  console.log('Received message', job.data.msg);\n  done();\n});\n\nsendQueue.add({ msg: 'Hello' });\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\n\nconst sendQueue = new Queue('Server A');\nconst receiveQueue = new Queue('Server B');\n\nreceiveQueue.process(function (job, done) {\n  console.log('Received message', job.data.msg);\n  done();\n});\n\nsendQueue.add({ msg: 'World' });\n```\n\n----------------------------------------\n\nTITLE: Global Event Handling\nDESCRIPTION: Implementation of global event listeners for queue-wide notifications.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nqueue.on('completed', job => {\n  console.log(`Job with id ${job.id} has been completed`);\n})\n```\n\nLANGUAGE: javascript\nCODE:\n```\nqueue.on('global:completed', jobId => {\n  console.log(`Job with id ${jobId} has been completed`);\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Cluster Support with Bull Queues in JavaScript\nDESCRIPTION: This example demonstrates how to parallelize Bull queue processing across multiple Node.js processes using the cluster module. It creates multiple worker processes to handle queue jobs concurrently for improved performance.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\nconst cluster = require('cluster');\n\nconst numWorkers = 8;\nconst queue = new Queue('test concurrent queue');\n\nif (cluster.isMaster) {\n  for (let i = 0; i < numWorkers; i++) {\n    cluster.fork();\n  }\n\n  cluster.on('online', function (worker) {\n    // Let's create a few jobs for the queue workers\n    for (let i = 0; i < 500; i++) {\n      queue.add({ foo: 'bar' });\n    };\n  });\n\n  cluster.on('exit', function (worker, code, signal) {\n    console.log('worker ' + worker.process.pid + ' died');\n  });\n} else {\n  queue.process(function (job, jobDone) {\n    console.log('Job done by worker', cluster.worker.id, job.id);\n    jobDone();\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Using Promises with Bull Queue Job Processors in JavaScript\nDESCRIPTION: This example shows how to use promises instead of callbacks for job processing with Bull. It demonstrates returning promises directly from the processor, handling rejections, and passing resolved values to completion events.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nvideoQueue.process(function (job) { // don't forget to remove the done callback!\n  // Simply return a promise\n  return fetchVideo(job.data.url).then(transcodeVideo);\n\n  // Handles promise rejection\n  return Promise.reject(new Error('error transcoding'));\n\n  // Passes the value the promise is resolved with to the \"completed\" event\n  return Promise.resolve({ framerate: 29.5 /* etc... */ });\n\n  // If the job throws an unhandled exception it is also handled correctly\n  throw new Error('some unexpected error');\n  // same as\n  return Promise.reject(new Error('some unexpected error'));\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Job Processor Module in Bull\nDESCRIPTION: Example of creating a separate processor module file for Bull jobs to improve CPU utilization and run jobs in parallel. The module exports a function that processes jobs.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// my-processor.js\nmodule.exports = function (job) {\n  // do some job\n\n  return value;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Local Event Handlers in Bull Queue\nDESCRIPTION: Demonstrates various event handlers for monitoring job states and queue operations in Bull. Includes handlers for error handling, job progress tracking, completion status, and queue state changes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_54\n\nLANGUAGE: javascript\nCODE:\n```\n.on('error', function (error) {\n  // An error occured.\n})\n\n.on('waiting', function (jobId) {\n  // A Job is waiting to be processed as soon as a worker is idling.\n});\n\n.on('active', function (job, jobPromise) {\n  // A job has started. You can use `jobPromise.cancel()`` to abort it.\n})\n\n.on('stalled', function (job) {\n  // A job has been marked as stalled. This is useful for debugging job\n  // workers that crash or pause the event loop.\n})\n\n.on('lock-extension-failed', function (job, err) {\n  // A job failed to extend lock. This will be useful to debug redis\n  // connection issues and jobs getting restarted because workers\n  // are not able to extend locks.\n});\n\n.on('progress', function (job, progress) {\n  // A job's progress was updated!\n})\n\n.on('completed', function (job, result) {\n  // A job successfully completed with a `result`.\n})\n\n.on('failed', function (job, err) {\n  // A job failed with reason `err`!\n})\n\n.on('paused', function () {\n  // The queue has been paused.\n})\n\n.on('resumed', function (job) {\n  // The queue has been resumed.\n})\n\n.on('cleaned', function (jobs, type) {\n  // Old jobs have been cleaned from the queue. `jobs` is an array of cleaned\n  // jobs, and `type` is the type of jobs cleaned.\n});\n\n.on('drained', function () {\n  // Emitted every time the queue has processed all the waiting jobs (even if there can be some delayed jobs not yet processed)\n});\n\n.on('removed', function (job) {\n  // A job successfully removed.\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Named Processors with Concurrency in Bull\nDESCRIPTION: Example showing how to configure multiple named processors with different concurrency levels in Bull queues. Demonstrates how concurrency stacks up when defining multiple processors in the same queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n/***\n * For each named processor, concurrency stacks up, so any of these three process functions\n * can run with a concurrency of 125. To avoid this behaviour you need to create an own queue\n * for each process function.\n */\nconst loadBalancerQueue = new Queue('loadbalancer');\nloadBalancerQueue.process('requestProfile', 100, requestProfile);\nloadBalancerQueue.process('sendEmail', 25, sendEmail);\nloadBalancerQueue.process('sendInvitation', 0, sendInvite);\n\nconst profileQueue = new Queue('profile');\n// Max concurrency for requestProfile is 100\nprofileQueue.process('requestProfile', 100, requestProfile);\n\nconst emailQueue = new Queue('email');\n// Max concurrency for sendEmail is 25\nemailQueue.process('sendEmail', 25, sendEmail);\n```\n\n----------------------------------------\n\nTITLE: Handling Job Instances in Local and Global Events\nDESCRIPTION: Illustrates the difference in job instance handling between local and global events. Shows how to access job information and perform cleanup operations in both contexts.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_56\n\nLANGUAGE: javascript\nCODE:\n```\n// Local events pass the job instance...\nqueue.on('progress', function (job, progress) {\n  console.log(`Job ${job.id} is ${progress * 100}% ready!`);\n});\n\nqueue.on('completed', function (job, result) {\n  console.log(`Job ${job.id} completed! Result: ${result}`);\n  job.remove();\n});\n\n// ...whereas global events only pass the job ID:\nqueue.on('global:progress', function (jobId, progress) {\n  console.log(`Job ${jobId} is ${progress * 100}% ready!`);\n});\n\nqueue.on('global:completed', function (jobId, result) {\n  console.log(`Job ${jobId} completed! Result: ${result}`);\n  queue.getJob(jobId).then(function (job) {\n    job.remove();\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Using Wildcard Processor for All Named Jobs in Bull\nDESCRIPTION: Example showing how to use '*' as a wildcard process name to handle all named jobs with a single processor function in Bull.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst differentJobsQueue = new Queue('differentJobsQueue');\ndifferentJobsQueue.process('*', processFunction);\ndifferentJobsQueue.add('jobA', data, opts);\ndifferentJobsQueue.add('jobB', data, opts);\n```\n\n----------------------------------------\n\nTITLE: Setting Up Separate Processes for Bull Queue Job Processing\nDESCRIPTION: This snippet explains how to run Bull job processors in separate processes to improve performance, sandboxing, and CPU utilization. It demonstrates creating a processor file and defining processors with different concurrency options.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// processor.js\nmodule.exports = function (job) {\n  // Do some heavy work\n\n  return Promise.resolve(result);\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// Single process:\nqueue.process('/path/to/my/processor.js');\n\n// You can use concurrency as well:\nqueue.process(5, '/path/to/my/processor.js');\n\n// and named processors:\nqueue.process('my processor', 5, '/path/to/my/processor.js');\n```\n\n----------------------------------------\n\nTITLE: Queue Graceful Shutdown Example\nDESCRIPTION: JavaScript example demonstrating graceful queue shutdown after processing 100 jobs.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_20\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\nconst queue = Queue('example');\n\nconst after100 = _.after(100, function () {\n  queue.close().then(function () {\n    console.log('done');\n  });\n});\n\nqueue.on('completed', after100);\n```\n\n----------------------------------------\n\nTITLE: Job Progress Tracking\nDESCRIPTION: Example of tracking and updating job progress during processing.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nmyFirstQueue.process(async (job) => {\n  let progress = 0;\n  for (i = 0; i < 100; i++) {\n    await doSomething(job.data);\n    progress += 10;\n    job.progress(progress);\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Reusing Redis Connections in Bull\nDESCRIPTION: Shows how to reuse Redis connections across multiple Bull queues using the createClient option. Includes handling for different connection types and connection sharing.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { REDIS_URL } = process.env;\n\nconst Redis = require('ioredis');\nlet client;\nlet subscriber;\n\nconst opts = {\n  createClient: function (type, redisOpts) {\n    switch (type) {\n      case 'client':\n        if (!client) {\n          client = new Redis(REDIS_URL, redisOpts);\n        }\n        return client;\n      case 'subscriber':\n        if (!subscriber) {\n          subscriber = new Redis(REDIS_URL, redisOpts);\n        }\n        return subscriber;\n      case 'bclient':\n        return new Redis(REDIS_URL, redisOpts);\n      default:\n        throw new Error('Unexpected connection type: ' + type);\n    }\n  }\n}\n\nconst queueFoo = new Queue('foobar', opts);\nconst queueQux = new Queue('quxbaz', opts);\n```\n\n----------------------------------------\n\nTITLE: Handling Bull Queue Events in JavaScript\nDESCRIPTION: This example shows how to subscribe to events emitted by a Bull queue. It demonstrates listening for the 'completed' event which fires when a job is successfully processed with its result.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\n.on('completed', function (job, result) {\n  // Job completed with output result!\n})\n```\n\n----------------------------------------\n\nTITLE: Queue Constructor Type Definition\nDESCRIPTION: TypeScript definition for the Queue constructor showing the required queueName parameter and optional url and options parameters.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nQueue(queueName: string, url?: string, opts?: QueueOptions): Queue\n```\n\n----------------------------------------\n\nTITLE: Named Jobs Implementation\nDESCRIPTION: Example of implementing named jobs for different types of processing tasks.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\n// Jobs producer\nconst myJob = await transcoderQueue.add('image', { input: 'myimagefile' });\nconst myJob = await transcoderQueue.add('audio', { input: 'myaudiofile' });\nconst myJob = await transcoderQueue.add('video', { input: 'myvideofile' });\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// Worker\ntranscoderQueue.process('image', processImage);\ntranscoderQueue.process('audio', processAudio);\ntranscoderQueue.process('video', processVideo);\n```\n\n----------------------------------------\n\nTITLE: Adding Jobs to Bull Queue with TypeScript Interface\nDESCRIPTION: TypeScript interface definition for the Queue#add method in Bull, showing the method signature and available job options.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nadd(name?: string, data: object, opts?: JobOpts): Promise<Job>\n```\n\n----------------------------------------\n\nTITLE: Creating Repeatable Jobs in Bull Queue\nDESCRIPTION: Demonstrates two ways to create repeatable jobs: one that repeats every 10 seconds for 100 times, and another that runs daily at 3:15 AM using cron syntax.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\n// Repeat every 10 seconds for 100 times.\nconst myJob = await myqueue.add(\n  { foo: 'bar' },\n  {\n    repeat: {\n      every: 10000,\n      limit: 100\n    }\n  }\n);\n\n// Repeat payment job once every day at 3:15 (am)\npaymentsQueue.add(paymentsData, { repeat: { cron: '15 3 * * *' } });\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple Bull Queues for Different Users in JavaScript\nDESCRIPTION: This snippet demonstrates how to create separate queues for different users in a Bull application. It shows creating queue instances with different names for scalability, though notes that each instance requires new Redis connections.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nconst userJohn = new Queue('john');\nconst userLisa = new Queue('lisa');\n.\n.\n.\n```\n\n----------------------------------------\n\nTITLE: Pausing and Resuming Bull Queues in JavaScript\nDESCRIPTION: This snippet shows how to pause and resume a Bull queue using promise-based methods. It demonstrates pausing globally or just for a specific worker, and then resuming queue processing.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nqueue.pause().then(function () {\n  // queue is paused now\n});\n\nqueue.resume().then(function () {\n  // queue is resumed now\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Jobs to Queue\nDESCRIPTION: Example of a producer adding a job to a Bull queue with serializable data.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst myFirstQueue = new Bull('my-first-queue');\n\nconst job = await myFirstQueue.add({\n  foo: 'bar'\n});\n```\n\n----------------------------------------\n\nTITLE: Rate Limiting Queue\nDESCRIPTION: Configuration of rate limiting for queue processing with max jobs per duration.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\n// Limit queue to max 1000 jobs per 5000 milliseconds.\nconst myRateLimitedQueue = new Queue('rateLimited', {\n  limiter: {\n    max: 1000,\n    duration: 5000\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Retrying a Failed Job in Bull Queue\nDESCRIPTION: The retry method re-runs a job that has failed and returns a promise that resolves when the job is scheduled for retry.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_44\n\nLANGUAGE: typescript\nCODE:\n```\nretry(): Promise\n```\n\n----------------------------------------\n\nTITLE: Comparing Local vs Global Event Handling in Bull\nDESCRIPTION: Shows the difference between local and global event handling in Bull queues. Demonstrates how to register global event listeners and handle job instances across different servers using Redis.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_55\n\nLANGUAGE: javascript\nCODE:\n```\n// Will listen locally, just to this queue...\nqueue.on('completed', listener):\n\n// Will listen globally, to instances of this queue...\nqueue.on('global:completed', listener);\n```\n\n----------------------------------------\n\nTITLE: Event Listening\nDESCRIPTION: Example of attaching event listeners to queue for job completion notifications.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst myFirstQueue = new Bull('my-first-queue');\n\n// Define a local completed event\nmyFirstQueue.on('completed', (job, result) => {\n  console.log(`Job completed with result ${result}`);\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Queue Instance\nDESCRIPTION: Basic instantiation of a Bull queue instance.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst myFirstQueue = new Bull('my-first-queue');\n```\n\n----------------------------------------\n\nTITLE: Defining Repeatable Job Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for repeatable job options including cron scheduling, timezone, date ranges, and limits.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RepeatOpts {\n  cron?: string; // Cron string\n  tz?: string; // Timezone\n  startDate?: Date | string | number; // Start date when the repeat job should start repeating (only with cron).\n  endDate?: Date | string | number; // End date when the repeat job should stop repeating.\n  limit?: number; // Number of times the job should repeat at max.\n  every?: number; // Repeat every millis (cron setting cannot be used together with this setting.)\n  count?: number; // The start value for the repeat iteration count.\n  readonly key: string; // The key for the repeatable job metadata in Redis.\n}\n```\n\n----------------------------------------\n\nTITLE: Updating Job Progress in Bull Queue\nDESCRIPTION: The progress method updates a job's progress when called with an argument or returns the current progress when called without an argument.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_39\n\nLANGUAGE: typescript\nCODE:\n```\nprogress(progress?: number | object): Promise\n```\n\n----------------------------------------\n\nTITLE: Waiting for Job Completion in Bull Queue\nDESCRIPTION: The finished method returns a promise that resolves or rejects when the job completes or fails.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_47\n\nLANGUAGE: typescript\nCODE:\n```\nfinished(): Promise\n```\n\n----------------------------------------\n\nTITLE: Creating a Delayed Job in Bull Queue\nDESCRIPTION: Adds a job that will be delayed for at least 5 seconds before processing. When the delay expires, the job moves to the beginning of the queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n// Delayed 5 seconds\nconst myJob = await myqueue.add({ foo: 'bar' }, { delay: 5000 });\n```\n\n----------------------------------------\n\nTITLE: Manual Job State Management in Bull\nDESCRIPTION: Shows how to manually manage job states including adding jobs, moving between states, and handling job transitions.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport Queue from 'bull';\n\nconst queue = new Queue({\n  limiter: {\n    max: 5,\n    duration: 5000,\n    bounceBack: true // important\n  },\n  ...queueOptions\n});\nqueue.add({ random_attr: 'random_value' });\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst job: Job = await queue.getNextJob();\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst (nextJobData, nextJobId) = await job.moveToFailed(\n  {\n    message: 'Call to external service failed!',\n  },\n  true,\n);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst (nextJobData, nextJobId) = await job.moveToCompleted('succeeded', true);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nif (nextJobdata) {\n  return Job.fromJSON(queue, nextJobData, nextJobId);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Prioritized Job in Bull Queue\nDESCRIPTION: Creates a job with a priority value of 3. Jobs with lower priority numbers are processed first. Priority queues are slower than standard queues with insertion time O(n).\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nconst myJob = await myqueue.add({ foo: 'bar' }, { priority: 3 });\n```\n\n----------------------------------------\n\nTITLE: Getting Job Counts in Bull Queue\nDESCRIPTION: The getJobCounts method returns counts of jobs in different states (waiting, active, completed, failed, delayed) for a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_22\n\nLANGUAGE: typescript\nCODE:\n```\ngetJobCounts() : Promise<JobCounts>\n```\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  interface JobCounts {\n    waiting: number,\n    active: number,\n    completed: number,\n    failed: number,\n    delayed: number\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Queue Options Interface Definition\nDESCRIPTION: TypeScript interface defining the available options when creating a new Queue instance, including Redis client configuration, rate limiting, and default job options.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface QueueOptions {\n  createClient?: (type: 'client' | 'subscriber' | 'bclient', config?: Redis.RedisOptions) => Redis.Redis | Redis.Cluster;\n  limiter?: RateLimiter;\n  redis?: RedisOpts;\n  prefix?: string = 'bull'; // prefix for all queue keys.\n  metrics?: MetricsOpts; // Configure metrics\n  defaultJobOptions?: JobOpts;\n  settings?: AdvancedSettings;\n}\n```\n\n----------------------------------------\n\nTITLE: Removing a Job in Bull Queue\nDESCRIPTION: The remove method removes a job from the queue and from any lists it may be included in.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_43\n\nLANGUAGE: typescript\nCODE:\n```\nremove(): Promise\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Backoff Strategy in Bull\nDESCRIPTION: Demonstrates how to implement custom retry backoff strategies including jitter and binary exponential backoff.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst Queue = require('bull');\n\nconst myQueue = new Queue('Server B', {\n  settings: {\n    backoffStrategies: {\n      jitter: function (attemptsMade, err) {\n        return 5000 + Math.random() * 500;\n      }\n    }\n  }\n});\n```\n\nLANGUAGE: javascript\nCODE:\n```\nmyQueue.add({foo: 'bar'}, {\n  attempts: 3,\n  backoff: {\n    type: 'jitter'\n  }\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Backoff Strategy Example\nDESCRIPTION: JavaScript example showing how to define a custom backoff strategy using a jitter function that returns a random delay.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nbackoffStrategies: {\n  jitter: function () {\n    return 5000 + Math.random() * 500;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a LIFO Job in Bull Queue\nDESCRIPTION: Creates a LIFO (Last In First Out) job that will be processed as soon as a worker is idle. LIFO jobs are added to the beginning of the queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nconst myJob = await myqueue.add({ foo: 'bar' }, { lifo: true });\n```\n\n----------------------------------------\n\nTITLE: Logging Job Information in Bull Queue\nDESCRIPTION: The log method adds a log row to a specific job, which can later be retrieved using Queue#getJobLogs.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_40\n\nLANGUAGE: typescript\nCODE:\n```\nlog(row: string): Promise\n```\n\n----------------------------------------\n\nTITLE: Getting Failed Jobs in Bull Queue\nDESCRIPTION: The getFailed method returns an array of failed jobs between start and end indexes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_34\n\nLANGUAGE: typescript\nCODE:\n```\ngetFailed(start?: number, end?: number, opts?: GetterOpts) : Promise<Array<Job>>\n```\n\n----------------------------------------\n\nTITLE: Updating Job Data in Bull Queue\nDESCRIPTION: The update method updates a job's data field with the provided data object.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_42\n\nLANGUAGE: typescript\nCODE:\n```\nupdate(data: object): Promise\n```\n\n----------------------------------------\n\nTITLE: Cleaning Jobs in Bull Queue\nDESCRIPTION: The clean method removes jobs of a specific type created outside of a grace period. It can be limited to a specific status and number of jobs.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_37\n\nLANGUAGE: typescript\nCODE:\n```\nclean(grace: number, status?: string, limit?: number): Promise<number[]>\n```\n\nLANGUAGE: javascript\nCODE:\n```\nqueue.on('cleaned', function (jobs, type) {\n  console.log('Cleaned %s %s jobs', jobs.length, type);\n});\n\n//cleans all jobs that completed over 5 seconds ago.\nawait queue.clean(5000);\n//clean all jobs that failed over 10 seconds ago.\nawait queue.clean(10000, 'failed');\n```\n\n----------------------------------------\n\nTITLE: Redis Options Interface Definition\nDESCRIPTION: TypeScript interface for Redis connection configuration options including port, host, database, and authentication settings.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RedisOpts {\n  port?: number = 6379;\n  host?: string = localhost;\n  db?: number = 0;\n  password?: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Job from ID in Bull 3.0\nDESCRIPTION: Shows how to retrieve a job instance from its ID in Bull 3.0, which is necessary when handling events since both local and global events now receive jobId as the first argument.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/MIGRATION.md#2025-04-14_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nJob.fromId()\n```\n\n----------------------------------------\n\nTITLE: Moving Job to Failed State in Bull Queue\nDESCRIPTION: The moveToFailed method moves a job to the failed queue with error information and can return the next job data and ID.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_49\n\nLANGUAGE: typescript\nCODE:\n```\nmoveToFailed(errorInfo:{ message: string; }, ignoreLock?:boolean): Promise<string[Jobdata, JobId] | null>\n```\n\n----------------------------------------\n\nTITLE: Checking Queue Readiness in Bull 3.0\nDESCRIPTION: Example of how to check if a queue is ready in Bull 3.0, replacing the removed 'ready' event with the isReady() method.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/MIGRATION.md#2025-04-14_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nQueue##isReady()\n```\n\n----------------------------------------\n\nTITLE: Discarding a Job in Bull Queue\nDESCRIPTION: The discard method ensures a job is never run again, even if attemptsMade is less than job.attempts.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_45\n\nLANGUAGE: typescript\nCODE:\n```\ndiscard(): Promise\n```\n\n----------------------------------------\n\nTITLE: Promoting a Delayed Job in Bull Queue\nDESCRIPTION: The promote method moves a job from the 'delayed' state to the 'waiting' state, allowing it to be executed as soon as possible.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_46\n\nLANGUAGE: typescript\nCODE:\n```\npromote(): Promise\n```\n\n----------------------------------------\n\nTITLE: Installing Bull Package\nDESCRIPTION: Commands to install Bull package using npm or yarn package managers.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/docs/README.md#2025-04-14_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install bull --save\n```\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn add bull\n```\n\n----------------------------------------\n\nTITLE: Getting Completed Jobs in Bull Queue\nDESCRIPTION: The getCompleted method returns an array of completed jobs between start and end indexes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_33\n\nLANGUAGE: typescript\nCODE:\n```\ngetCompleted(start?: number, end?: number, opts?: GetterOpts) : Promise<Array<Job>>\n```\n\n----------------------------------------\n\nTITLE: Getting Waiting Jobs in Bull Queue\nDESCRIPTION: The getWaiting method returns an array of waiting jobs between start and end indexes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_30\n\nLANGUAGE: typescript\nCODE:\n```\ngetWaiting(start?: number, end?: number, opts?: GetterOpts) : Promise<Array<Job>>\n```\n\n----------------------------------------\n\nTITLE: Getting Delayed Jobs in Bull Queue\nDESCRIPTION: The getDelayed method returns an array of delayed jobs between start and end indexes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_32\n\nLANGUAGE: typescript\nCODE:\n```\ngetDelayed(start?: number, end?: number, opts?: GetterOpts) : Promise<Array<Job>>\n```\n\n----------------------------------------\n\nTITLE: Getting Metrics in Bull Queue\nDESCRIPTION: The getMetrics method retrieves metrics data for completed or failed jobs within a specified range.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_36\n\nLANGUAGE: typescript\nCODE:\n```\ngetMetrics(type: 'completed' | 'failed', start = 0, end = -1) : Promise<{\n  meta: {\n    count: number;\n    prevTS: number;\n    prevCount: number;\n  };\n  data: number[];\n  count: number;\n}>\n```\n\n----------------------------------------\n\nTITLE: Getting Active Jobs in Bull Queue\nDESCRIPTION: The getActive method returns an array of active jobs between start and end indexes.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_31\n\nLANGUAGE: typescript\nCODE:\n```\ngetActive(start?: number, end?: number, opts?: GetterOpts) : Promise<Array<Job>>\n```\n\n----------------------------------------\n\nTITLE: Extending Job Lock in Bull Queue\nDESCRIPTION: The extendLock method extends the lock duration for a job by the specified milliseconds. Returns 1 on success and 0 on failure.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_53\n\nLANGUAGE: typescript\nCODE:\n```\nextendLock(duration: number): Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Taking Job Lock in Bull Queue\nDESCRIPTION: The takeLock method takes a lock for a job to prevent other queue workers from processing it simultaneously.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_52\n\nLANGUAGE: typescript\nCODE:\n```\ntakeLock(): Promise<number | false>\n```\n\n----------------------------------------\n\nTITLE: Releasing Job Lock in Bull Queue\nDESCRIPTION: The releaseLock method releases the lock on a job. Only locks owned by the queue instance can be released.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_51\n\nLANGUAGE: typescript\nCODE:\n```\nreleaseLock(): Promise<void>\n```\n\n----------------------------------------\n\nTITLE: Getting Job State in Bull Queue\nDESCRIPTION: The getState method returns the current job's status (completed, failed, delayed, etc.). Note that this implementation is not very efficient for queues with many jobs.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_41\n\nLANGUAGE: typescript\nCODE:\n```\ngetState(): Promise\n```\n\n----------------------------------------\n\nTITLE: Rate Limiter Interface Definition\nDESCRIPTION: TypeScript interface defining rate limiting options for job processing, including maximum jobs, duration, and grouping configuration.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RateLimiter {\n  max: number; // Max number of jobs processed\n  duration: number; // per duration in milliseconds\n  bounceBack?: boolean = false; // When jobs get rate limited, they stay in the waiting queue and are not moved to the delayed queue\n  groupKey?: string; // allows grouping of jobs with the specified key from the data object passed to the Queue#add (ex. \"network.handle\")\n}\n```\n\n----------------------------------------\n\nTITLE: Correct Promise Usage in Bull Job Processor\nDESCRIPTION: Example showing the correct way to use promises in Bull job processors by not including the done callback parameter.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_12\n\nLANGUAGE: javascript\nCODE:\n```\nqueue.process(function (job) {\n  // No done callback here :)\n  return Promise.resolve();\n});\n```\n\n----------------------------------------\n\nTITLE: Getting Failed Job Count in Bull Queue\nDESCRIPTION: The getFailedCount method returns the count of failed jobs in a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_24\n\nLANGUAGE: typescript\nCODE:\n```\ngetFailedCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Obliterating a Queue in Bull Queue\nDESCRIPTION: The obliterate method completely removes a queue with all its data. By default, it requires no active jobs, but this can be overridden with the force option.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_38\n\nLANGUAGE: typescript\nCODE:\n```\nobliterate(ops?: { force: boolean}): Promise<void>\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// Removes everything but only if there are no active jobs\nawait queue.obliterate();\n\nawait queue.obliterate({ force: true });\n```\n\n----------------------------------------\n\nTITLE: Getting Completed Job Count in Bull Queue\nDESCRIPTION: The getCompletedCount method returns the count of completed jobs in a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_23\n\nLANGUAGE: typescript\nCODE:\n```\ngetCompletedCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Configuring Redis Cluster with Bull\nDESCRIPTION: Shows how to configure Bull to work with Redis cluster using hash tags for proper key distribution.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst queue = new Queue('cluster', {\n  prefix: '{myprefix}'\n});\n```\n\n----------------------------------------\n\nTITLE: Getting Delayed Job Count in Bull Queue\nDESCRIPTION: The getDelayedCount method returns the count of delayed jobs in a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_25\n\nLANGUAGE: typescript\nCODE:\n```\ngetDelayedCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Getting Workers in Bull Queue\nDESCRIPTION: The getWorkers method returns an array of workers currently listening or processing jobs, including fields from Redis CLIENT LIST command.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_35\n\nLANGUAGE: typescript\nCODE:\n```\ngetWorkers() : Promise<Array<Object>>\n```\n\n----------------------------------------\n\nTITLE: Metrics Options Interface Definition\nDESCRIPTION: TypeScript interface for configuring metrics collection options, specifying the maximum number of data points to collect.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface MetricsOpts {\n    maxDataPoints?: number; //  Max number of data points to collect, granularity is fixed at one minute.\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Active Job Count in Bull Queue\nDESCRIPTION: The getActiveCount method returns the count of active jobs in a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_26\n\nLANGUAGE: typescript\nCODE:\n```\ngetActiveCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Installing Bull Package with NPM\nDESCRIPTION: Command to install Bull package and save it as a dependency in your Node.js project using NPM.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install bull --save\n```\n\n----------------------------------------\n\nTITLE: Getting Waiting Job Count in Bull Queue\nDESCRIPTION: The getWaitingCount method returns the count of waiting jobs in a queue.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_27\n\nLANGUAGE: typescript\nCODE:\n```\ngetWaitingCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Installing Bull Package with Yarn\nDESCRIPTION: Command to install Bull package and add it as a dependency in your Node.js project using Yarn.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add bull\n```\n\n----------------------------------------\n\nTITLE: Moving Job to Completed State in Bull Queue\nDESCRIPTION: The moveToCompleted method moves a job to the completed queue and can return the next job data and ID. The notFetch parameter can be used to avoid prefetching the next job.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_48\n\nLANGUAGE: typescript\nCODE:\n```\nmoveToCompleted(returnValue: any, ignoreLock: boolean, notFetch?: boolean): Promise<string[Jobdata, JobId] | null>\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Job ID Uniqueness in Bull Queue\nDESCRIPTION: Example showing how job ID uniqueness works with repeatable and regular jobs in Bull queue system.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\nawait queue.add({}, { jobId: 'example', repeat: { every: 5 * 1000 } })\nawait queue.add({}, { jobId: 'example', repeat: { every: 5 * 1000 } }) // Will not be created, same repeat configuration\nawait queue.add({}, { jobId: 'example', repeat: { every: 10 * 1000 } }) // Will be created, different repeat configuration\nawait queue.add({}, { jobId: 'example' }) // Will be created, no regular job with this id\nawait queue.add({}, { jobId: 'example' }) // Will not be created, conflicts with previous regular job\n```\n\n----------------------------------------\n\nTITLE: Getting Paused Job Count in Bull Queue (Deprecated)\nDESCRIPTION: The getPausedCount method returns the count of paused jobs in a queue. This is deprecated as only the queue can be paused, so getWaitingCount gives the same result.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_28\n\nLANGUAGE: typescript\nCODE:\n```\ngetPausedCount() : Promise<number>\n```\n\n----------------------------------------\n\nTITLE: Incorrect Promise Usage in Bull Job Processor\nDESCRIPTION: Example showing an incorrect way to use promises in Bull job processors, where both a done callback and a promise return are used, which will cause issues.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\n// THIS WON'T WORK!!\nqueue.process(function (job, done) {\n  // Oops! done callback here!\n  return Promise.resolve();\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Backoff Options Interface\nDESCRIPTION: TypeScript interface for job backoff options specifying retry strategy and delay settings.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ninterface BackoffOpts {\n  type: string; // Backoff type, which can be either `fixed` or `exponential`. A custom backoff strategy can also be specified in `backoffStrategies` on the queue settings.\n  delay: number; // Backoff delay, in milliseconds.\n  options?: any; // Options for custom strategies\n}\n```\n\n----------------------------------------\n\nTITLE: Example of Pattern-based Job Removal\nDESCRIPTION: JavaScript example showing how to remove jobs using pattern matching with glob-style syntax.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nmyQueue.removeJobs('?oo*').then(function () {\n  console.log('done removing jobs');\n});\n```\n\n----------------------------------------\n\nTITLE: Removing Repeatable Jobs by Key in Bull Queue\nDESCRIPTION: The removeRepeatableByKey method removes a specific repeatable job configuration using its key. This prevents any new jobs from being processed with this configuration.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_21\n\nLANGUAGE: typescript\nCODE:\n```\nremoveRepeatableByKey(key: string): Promise<void>\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst job = await queue.add('remove', { example: 'data' }, { repeat: { every: 1000 } });\n// store job.opts.repeat.key somewhere...\nconst repeatableKey = job.opts.repeat.key;\n\n// ...then later...\nawait queue.removeRepeatableByKey(repeatableKey);\n```\n\nLANGUAGE: typescript\nCODE:\n```\nawait queue.add('remove', { example: 'data' }, { jobId: 'findMe', repeat: { every: 1000 } })\n\n// ... then later ...\nconst repeatableJobs = await queue.getRepeatableJobs()\nconst foundJob = repeatableJobs.find(job => job.id === 'findMe')\nawait queue.removeRepeatableByKey(foundJob.key)\n```\n\n----------------------------------------\n\nTITLE: Advanced Settings Interface Definition\nDESCRIPTION: TypeScript interface defining advanced queue settings including lock durations, intervals, and retry strategies.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface AdvancedSettings {\n  lockDuration: number = 30000; // Key expiration time for job locks.\n  lockRenewTime: number = 15000; // Interval on which to acquire the job lock\n  stalledInterval: number = 30000; // How often check for stalled jobs (use 0 for never checking).\n  maxStalledCount: number = 1; // Max amount of times a stalled job will be re-processed.\n  guardInterval: number = 5000; // Poll interval for delayed jobs and added jobs.\n  retryProcessDelay: number = 5000; // delay before processing next job in case of internal error.\n  backoffStrategies: {}; // A set of custom backoff strategies keyed by name.\n  drainDelay: number = 5; // A timeout for when the queue is in drained state (empty waiting for jobs).\n  isSharedChildPool: boolean = false; // enables multiple queues on the same instance of child pool to share the same instance.\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Job Lock Key in Bull Queue\nDESCRIPTION: The lockKey method returns a unique key representing a lock for a job, used for concurrency control.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_50\n\nLANGUAGE: typescript\nCODE:\n```\nlockKey(): string\n```\n\n----------------------------------------\n\nTITLE: Enabling Bull Debug Mode\nDESCRIPTION: Shows how to enable debug mode for Bull using NODE_DEBUG environment variable.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/PATTERNS.md#2025-04-14_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nexport NODE_DEBUG=bull\n```\n\nLANGUAGE: bash\nCODE:\n```\nNODE_DEBUG=bull node ./your-script.js\n```\n\n----------------------------------------\n\nTITLE: Executing Bull Queue Release Process in Bash\nDESCRIPTION: This snippet shows the commands to execute for releasing a new version of the Bull queue library. It includes checking for outdated dependencies, updating the package version, and publishing to npm.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/CONTRIBUTING.md#2025-04-14_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm outdated --depth 0          # See if you can upgrade any dependencies\nnpm version [major|minor|patch] # Update package.json\nnpm publish                     # Tag repo and publish npm package\n```\n\n----------------------------------------\n\nTITLE: KeepJobs Interface for Bull Queue Job Retention\nDESCRIPTION: TypeScript interface defining options for controlling how many finished jobs to keep in the Bull queue, based on age and count criteria.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * KeepJobs\n *\n * Specify which jobs to keep after finishing. If both age and count are\n * specified, then the jobs kept will be the ones that satisfies both\n * properties.\n */\nexport interface KeepJobs {\n  /**\n   * Maximum age in *seconds* for job to be kept.\n   */\n  age?: number;\n\n  /**\n   * Maximum count of jobs to be kept.\n   */\n  count?: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Getter Options Interface for Bull Queue\nDESCRIPTION: Interface defining options for job getter methods, allowing configuration such as excluding job data fields.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/REFERENCE.md#2025-04-14_snippet_29\n\nLANGUAGE: typescript\nCODE:\n```\ninterface GetterOpts\n  excludeData: boolean; // Exclude the data field of the jobs.\n```\n\n----------------------------------------\n\nTITLE: Semantic Version Headers and Change Descriptions\nDESCRIPTION: Changelog entries following semantic versioning format with links to commits and issue references\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/CHANGELOG.md#2025-04-14_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## [4.16.5](https://github.com/OptimalBits/bull/compare/v4.16.4...v4.16.5) (2024-12-18)\n\n### Bug Fixes\n\n* upgrade cron-parser dependency for Luxon CVE-2023-22467 ([e45698e](https://github.com/OptimalBits/bull/commit/e45698eb91b91a4676f9bafdb7bdb35043d2316d))\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript Definitions with NPM\nDESCRIPTION: Command to install TypeScript type definitions for Bull as a development dependency using NPM.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @types/bull --save-dev\n```\n\n----------------------------------------\n\nTITLE: Installing TypeScript Definitions with Yarn\nDESCRIPTION: Command to install TypeScript type definitions for Bull as a development dependency using Yarn.\nSOURCE: https://github.com/OptimalBits/bull/blob/develop/README.md#2025-04-14_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add --dev @types/bull\n```"
  }
]