[
  {
    "owner": "quinn-rs",
    "repo": "quinn",
    "content": "TITLE: Opening a Bidirectional Stream in Rust using Quinn\nDESCRIPTION: This code snippet demonstrates how to open a bidirectional stream using the Quinn library in Rust. It creates a new stream and writes data to it.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet (mut send, recv) = connection.open_bi().await?\nlet data = b\"hello\";\nsend.write_all(data).await?\nsend.finish().await?\n```\n\n----------------------------------------\n\nTITLE: Implementing Quinn Client Connection\nDESCRIPTION: Shows how to create a Quinn client endpoint and establish a connection to a server using DNS name verification.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/set-up-connection.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../bin/set-up-connection.rs:23:33}}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Quinn Server Endpoint\nDESCRIPTION: Demonstrates how to bind a Quinn server endpoint to a socket and configure it for accepting incoming connections.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/set-up-connection.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../bin/set-up-connection.rs:8:20}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Server with Certificates in Rust\nDESCRIPTION: Code snippet showing how to configure a server with certificates, enabling secure TLS authentication for incoming QUIC connections.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nlet server_config = quinn::ServerConfig::with_single_cert(cert_chain, key)?\n```\n\n----------------------------------------\n\nTITLE: Loading Certificates from PEM Files in Rust\nDESCRIPTION: Function to load certificates from PEM files, typically used with certificates issued by Certificate Authorities like Let's Encrypt. This loads the certificate chain and private key from files.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nfn load_certs_from_pem(\n    cert_path: &Path,\n    key_path: &Path,\n) -> Result<(Vec<rustls::Certificate>, rustls::PrivateKey), Box<dyn Error>> {\n    let key = fs::read(key_path)?;\n    let key = rustls_pemfile::pkcs8_private_keys(&mut &*key)?;\n    let key = rustls::PrivateKey(key[0].clone());\n\n    let cert_chain = fs::read(cert_path)?;\n    let cert_chain = rustls_pemfile::certs(&mut &*cert_chain)?;\n    let cert_chain = cert_chain.into_iter().map(rustls::Certificate).collect();\n\n    Ok((cert_chain, key))\n}\n```\n\n----------------------------------------\n\nTITLE: Opening a Unidirectional Stream in Rust using Quinn\nDESCRIPTION: This code snippet illustrates how to open a unidirectional stream using Quinn in Rust. It creates a new stream and writes data to it.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet mut send = connection.open_uni().await?\nlet data = b\"hello\";\nsend.write_all(data).await?\nsend.finish().await?\n```\n\n----------------------------------------\n\nTITLE: Iterating Incoming Bidirectional Streams in Rust using Quinn\nDESCRIPTION: This code snippet shows how to iterate over incoming bidirectional streams using Quinn in Rust. It handles each stream by reading data from it.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(stream) = connection.accept_bi().await? {\n    let (mut send, mut recv) = stream;\n    let data = recv.read_to_end(usize::MAX).await?;\n    println!(\"Received data: {:?}\", data);\n    // Process data\n    send.finish().await?\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Self-Signed Certificates with rcgen in Rust\nDESCRIPTION: Function to generate a self-signed certificate using the rcgen crate. This creates a certificate with the specified DNS name that can be used for testing QUIC connections.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nfn generate_self_signed_cert(\n    server_name: &str,\n) -> Result<(rustls::Certificate, rustls::PrivateKey), Box<dyn Error>> {\n    let cert = rcgen::generate_simple_self_signed(vec![server_name.into()])?;\n    let key = cert.serialize_private_key_der();\n    let cert = cert.serialize_der()?;\n    Ok((rustls::Certificate(cert), rustls::PrivateKey(key)))\n}\n```\n\n----------------------------------------\n\nTITLE: Iterating Incoming Unidirectional Streams in Rust using Quinn\nDESCRIPTION: This code snippet demonstrates how to iterate over incoming unidirectional streams using Quinn in Rust. It handles each stream by reading data from it.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(mut recv) = connection.accept_uni().await? {\n    let data = recv.read_to_end(usize::MAX).await?;\n    println!(\"Received data: {:?}\", data);\n    // Process data\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Client to Trust CA Certificates in Rust\nDESCRIPTION: Code snippet showing how to configure a client with default root certificates, enabling it to trust server certificates signed by conventional certificate authorities.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nlet client_config = quinn::ClientConfig::with_native_roots()\n```\n\n----------------------------------------\n\nTITLE: Sending Datagrams in Rust using Quinn\nDESCRIPTION: This code snippet shows how to send datagrams using Quinn in Rust. It demonstrates unreliable messaging by sending a datagram.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nlet data = b\"hello\";\nconnection.send_datagram(Bytes::copy_from_slice(data))?;\n```\n\n----------------------------------------\n\nTITLE: Iterating Datagram Streams in Rust using Quinn\nDESCRIPTION: This code snippet illustrates how to iterate over datagram streams using Quinn in Rust. It handles each datagram by processing the received data.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/data-transfer.md#2025-04-19_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\nwhile let Some(datagram) = connection.read_datagram().await? {\n    println!(\"Received datagram: {:?}\", datagram);\n    // Process datagram\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Connection Constants in Rust\nDESCRIPTION: Defines constants for server configuration including server name and socket address.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/set-up-connection.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../bin/set-up-connection.rs:35:38}}\n```\n\n----------------------------------------\n\nTITLE: Running Minimal QUIC Connection Example\nDESCRIPTION: Command to run the minimal connection example that demonstrates basic QUIC connectivity.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --example connection\n```\n\n----------------------------------------\n\nTITLE: Running HTTP/0.9 File Server Example\nDESCRIPTION: Command to run the server example that listens for file requests on a specified directory.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --example server ./\n```\n\n----------------------------------------\n\nTITLE: Running HTTP/0.9 File Client Example\nDESCRIPTION: Command to run the client example that requests a file from the server.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --example client https://localhost:4433/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Running Quinn Server and Client Examples in Shell\nDESCRIPTION: These commands demonstrate how to run the Quinn server and client examples. The server serves the current directory, while the client fetches a specific file from the server.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/README.md#2025-04-19_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ cargo run --example server ./\n$ cargo run --example client https://localhost:4433/Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: Running Single Socket Example\nDESCRIPTION: Command to run the example demonstrating multiple QUIC connections over a single UDP socket.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_5\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --example single_socket\n```\n\n----------------------------------------\n\nTITLE: Minimal QUIC Connection Output\nDESCRIPTION: Example output showing successful client-server QUIC connection establishment.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n[client] connected: addr=127.0.0.1:5000\n[server] connection accepted: addr=127.0.0.1:53712\n```\n\n----------------------------------------\n\nTITLE: Single Socket Example Output\nDESCRIPTION: Example output showing multiple connections established over a single socket.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n[client] connected: addr=127.0.0.1:5000\n[server] incoming connection: addr=127.0.0.1:48930\n[client] connected: addr=127.0.0.1:5001\n[client] connected: addr=127.0.0.1:5002\n[server] incoming connection: addr=127.0.0.1:48930\n[server] incoming connection: addr=127.0.0.1:48930\n```\n\n----------------------------------------\n\nTITLE: Running Insecure QUIC Connection Example\nDESCRIPTION: Command to run the insecure connection example that bypasses certificate verification.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/quinn/examples/README.md#2025-04-19_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n$ cargo run --example insecure_connection --features=\"rustls/dangerous_configuration\"\n```\n\n----------------------------------------\n\nTITLE: Implementing ServerCertVerifier for Insecure Connections in Rust\nDESCRIPTION: Implementation of ServerCertVerifier that skips certificate validation for testing purposes. This should not be used in production as it accepts any server certificate without verification.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nstruct SkipServerVerification;\n\nimpl rustls::client::ServerCertVerifier for SkipServerVerification {\n    fn verify_server_cert(\n        &self,\n        _end_entity: &rustls::Certificate,\n        _intermediates: &[rustls::Certificate],\n        _server_name: &rustls::ServerName,\n        _scts: &mut dyn Iterator<Item = &[u8]>,\n        _ocsp_response: &[u8],\n        _now: std::time::SystemTime,\n    ) -> Result<rustls::client::ServerCertVerified, rustls::Error> {\n        Ok(rustls::client::ServerCertVerified::assertion())\n    }\n\n    fn verify_tls12_signature(\n        &self,\n        _message: &[u8],\n        _cert: &rustls::Certificate,\n        _dss: &rustls::DigitallySignedStruct,\n    ) -> Result<(), rustls::Error> {\n        Ok(())\n    }\n\n    fn verify_tls13_signature(\n        &self,\n        _message: &[u8],\n        _cert: &rustls::Certificate,\n        _dss: &rustls::DigitallySignedStruct,\n    ) -> Result<(), rustls::Error> {\n        Ok(())\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Client to Skip Certificate Verification in Rust\nDESCRIPTION: Sets up a ClientConfig to use the SkipServerVerification implementation, allowing connections to any server without certificate validation. This is useful for testing but insecure for production.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nlet crypto = rustls::ClientConfig::builder()\n    .with_safe_defaults()\n    .with_custom_certificate_verifier(Arc::new(SkipServerVerification {}))\n    .with_no_client_auth();\n\nlet client_config = quinn::ClientConfig::new(Arc::new(crypto));\n// Configure an endpoint with this client config\n// let mut endpoint = quinn::Endpoint::client(addr).unwrap();\n// endpoint.set_default_client_config(client_config);\n```\n\n----------------------------------------\n\nTITLE: Including README.md content in a Rust documentation file\nDESCRIPTION: This snippet demonstrates the use of the include directive in Rust documentation to reference and embed content from the project's README.md file. This approach allows maintaining documentation in a single place while reusing it across different contexts.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn.md#2025-04-19_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../README.md}}\n```\n\n----------------------------------------\n\nTITLE: Adding Quinn and Rustls Dependencies in Cargo.toml\nDESCRIPTION: Adding the Quinn and Rustls crates to your project dependencies in Cargo.toml. This enables QUIC functionality and TLS support required for certificate handling.\nSOURCE: https://github.com/quinn-rs/quinn/blob/main/docs/book/src/quinn/certificate.md#2025-04-19_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nquinn = \"0.11\"\nrustls = \"0.23\"\n```"
  }
]