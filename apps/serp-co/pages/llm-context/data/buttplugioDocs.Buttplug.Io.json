[
  {
    "owner": "buttplugio",
    "repo": "docs.buttplug.io",
    "content": "TITLE: Implementing a Simple Buttplug Client Application in C#\nDESCRIPTION: This C# code demonstrates a complete, simple Buttplug client application. It connects to a Buttplug server (likely Intiface Central or similar), scans for devices, lists them, allows the user to select one via console input, and then sends a VibrateCmd to the chosen device. It showcases core Buttplug client functionalities like connection management, device discovery, and command sending. It depends on the Buttplug C# library.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/application.mdx#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Buttplug;\n\nnamespace ApplicationExample\n{\n    internal class Program\n    {\n        private static ButtplugClient _client;\n        private static ButtplugClientDevice _currentDevice;\n\n        private static async Task WaitForKey() {\n            Console.WriteLine(\"Press any key to continue.\");\n            while (!Console.KeyAvailable)\n            {\n                await Task.Delay(1);\n            }\n            Console.ReadKey(true);\n        }\n\n        private static async Task RunExample(CancellationTokenSource aTokenSource = null)\n        {\n            // Set up client object\n            _client = new ButtplugClient(\"Example Client\");\n\n            // Set up handlers\n            _client.DeviceAdded += HandleDeviceAdded;\n            _client.DeviceRemoved += HandleDeviceRemoved;\n            _client.ScanningFinished += HandleScanningFinished;\n\n            // Connect to embedded server\n            // If you want to connect to an external server, use this.\n            // var connector = new ButtplugWebsocketConnectorOptions(new Uri(\"ws://localhost:12345\"));\n\n            // If you want to use an in-process server, use this.\n            var connector = new ButtplugEmbeddedConnectorOptions();\n\n            try\n            {\n                await _client.ConnectAsync(connector);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"Could not connect to Buttplug Server! {ex.Message}\");\n                Console.WriteLine(\"Make sure you have Intiface Central running, and Server is listening on Websockets at ws://127.0.0.1:12345.\");\n                await WaitForKey();\n                return;\n            }\n\n            Console.WriteLine(\"Connected!\");\n\n            // Scan for devices\n            await _client.StartScanningAsync();\n\n            // Wait until scan is finished\n            Console.WriteLine(\"Waiting for scan to finish... Push Enter when finished scanning.\");\n            Console.ReadLine();\n\n            while (true)\n            {\n                // List devices\n                Console.WriteLine(\"Client currently knows about these devices:\");\n                var devices = new List<ButtplugClientDevice>();\n                var i = 1;\n                foreach (var device in _client.Devices)\n                {\n                    Console.WriteLine($\"{i}. {device.Name}\");\n                    devices.Add(device);\n                    i++;\n                }\n                \n                // If we have devices, choose one\n                if (devices.Any())\n                {\n                    Console.WriteLine($\"Choose a device between 1 and {devices.Count()}\");\n                    if (!uint.TryParse(Console.ReadLine(), out var choice) || choice == 0 || choice > devices.Count())\n                    {\n                        Console.WriteLine(\"Invalid choice, breaking.\");\n                        break;\n                    }\n\n                    _currentDevice = devices[(int)choice - 1];\n                } else {\n                    // Otherwise, quit\n                    Console.WriteLine(\"No devices available, breaking.\");\n                    break;\n                }\n\n                // Send commands to the device\n                if (_currentDevice.AllowedMessages.ContainsKey(typeof(VibrateCmd)))\n                {\n                    await _currentDevice.VibrateAsync(1.0);\n                    await Task.Delay(1000);\n                    await _currentDevice.VibrateAsync(0.0);\n                }\n                else\n                {\n                    Console.WriteLine($\"Device {_currentDevice.Name} does not support VibrateCmd\");\n                }\n            }\n            await _client.StopScanningAsync();\n        }\n\n        private static void HandleDeviceAdded(object sender, DeviceAddedEventArgs e)\n        {\n            // For this example, we only care about devices known to the client already.\n            if (_client.Devices.Contains(e.Device))\n            {\n                Console.WriteLine($\"Device {e.Device.Name} Added\");\n            }\n        }\n\n        private static void HandleDeviceRemoved(object sender, DeviceRemovedEventArgs e)\n        {\n            // If the device we're currently using has been removed, set it to null\n            if (e.Device == _currentDevice)\n            {\n                _currentDevice = null;\n            }\n            Console.WriteLine($\"Device {e.Device.Name} Removed\");\n        }\n\n        private static void HandleScanningFinished(object sender, EventArgs e)\n        {\n            Console.WriteLine(\"Device scanning is finished!\");\n        }\n\n        // We'll just block on the task since this is a console app.\n        static void Main(string[] args) => RunExample().Wait();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Connecting to Buttplug Server with the Buttplug C# Client – C#\nDESCRIPTION: This C# code example, referenced as CSharpConnectionExample, demonstrates connecting to a Buttplug server using the official C# client library. The snippet typically includes connector initialization, invocation of the connect method, and handling of exceptions or errors related to platform or version compatibility. Dependencies include the Buttplug C# client library, and it expects valid configuration parameters for connecting. The output is a live connection or an error, with limitations pertaining to network availability and client/server version alignment.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connecting.mdx#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nimport CSharpConnectionExample from '!!raw-loader!/examples/csharp/ConnectionExample/Program.cs';\n\n<CodeBlock language=\"csharp\">{CSharpConnectionExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Connecting to Buttplug Server with the Buttplug Javascript Client – Javascript\nDESCRIPTION: This Javascript code example, referenced as jsConnectionExample, demonstrates how to use the Javascript Buttplug client to connect to a Buttplug server instance. The snippet likely shows how to configure the connector, initiate the connect sequence, and manage connection success or failure states, including handling of protocol version errors. This example depends on the Buttplug Javascript client and assumes access to network or websocket configuration. The key parameter is the connector instance, and the output is either a connected client object or an error handler callback.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connecting.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport jsConnectionExample from '!!raw-loader!/examples/javascript/remote-connector-example.js';\n\n<CodeBlock language=\"js\">{jsConnectionExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Controlling Devices with Buttplug in JavaScript\nDESCRIPTION: This JavaScript example shows how to use the `buttplug` library to connect to a server (via WebSocket or WebBluetooth), listen for `deviceadded` events, and send commands like `device.vibrate()` or `device.stop()` to a connected device. It highlights the event-driven and asynchronous nature of device control in web or Node.js environments.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-control.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n{jsControlExample}\n```\n\n----------------------------------------\n\nTITLE: Implementing Buttplug Device Enumeration in C#\nDESCRIPTION: This C# example shows how to connect to a Buttplug server, start and stop device scanning asynchronously using `StartScanningAsync()` and `StopScanningAsync()`, and respond to device connection changes through the `DeviceAdded` and `DeviceRemoved` events. Requires the Buttplug C# library and an accessible Buttplug server instance.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-enum.mdx#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{CSharpEnumerationExample}\n```\n\n----------------------------------------\n\nTITLE: Controlling Devices with Buttplug in Rust\nDESCRIPTION: This Rust example demonstrates how to connect to a Buttplug server, enumerate devices, and send commands like VibrateCmd to a specific device using the Buttplug Rust client library. It requires the `buttplug` crate and an async runtime like `tokio`, showcasing the typical workflow for device interaction.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-control.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{RustControlExample}\n```\n\n----------------------------------------\n\nTITLE: Establishing Websocket Connection to Buttplug Server in Rust\nDESCRIPTION: This Rust snippet demonstrates how to set up a Websocket connector to a Buttplug server using a specified address, often defaulting to port 12345. It relies on core Buttplug client Rust libraries and expects users to provide the server's address. The code illustrates asynchronous connection logic, error handling, and integration points for further message exchange, with input parameters tailored to the user's local server setup.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connectors.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimport RustExternalConnectorExample from '!!raw-loader!/examples/rust/src/bin/external_connector.rs';\n\n<CodeBlock language=\\\"rust\\\">{RustExternalConnectorExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Connecting to Buttplug Server using Websocket in C#\nDESCRIPTION: This C# example shows how to instantiate a Websocket connector for communicating with a Buttplug server through the .NET ecosystem. The snippet is intended for use with the official C# client libraries and guides the developer through connector creation, server address usage, and handling the default port scenario. It is structured for integration into larger applications and demonstrates best practices for connection management and exception handling.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connectors.mdx#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nimport CSharpExternalConnectorExample from '!!raw-loader!/examples/csharp/RemoteConnectorExample/Program.cs';\n\n<CodeBlock language=\\\"csharp\\\">{CSharpExternalConnectorExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Setting up Logging with tracing_subscriber in Rust\nDESCRIPTION: This Rust snippet demonstrates how to initialize and configure logging output using the tracing and tracing_subscriber crates. It sets up logging to stdout to monitor internal events for debugging and development. Dependencies include the tracing and tracing_subscriber crates, with log levels controlled via the RUST_LOG environment variable. Input is internal log events; output is formatted log messages to stdout. This approach is commonly used in Rust applications for observability.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/logging.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse tracing::info;\nuse tracing_subscriber;\n\nfn main() {\n    tracing_subscriber::fmt::init();\n    info!(\"Hello from Buttplug Rust logging example!\");\n    // Initialize your Buttplug components here...\n}\n```\n\n----------------------------------------\n\nTITLE: Controlling Devices with Buttplug in C#\nDESCRIPTION: This C# example illustrates connecting to a Buttplug server using `Buttplug.Client`, handling device discovery events, and using a `ButtplugClientDevice` object to send asynchronous commands (like `VibrateAsync`) to control device features. It requires the Buttplug.Client NuGet package and runs on the .NET platform.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-control.mdx#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n{CSharpControlExample}\n```\n\n----------------------------------------\n\nTITLE: Handling Buttplug Errors in JavaScript\nDESCRIPTION: This placeholder indicates JavaScript code loaded from an external file (`/examples/javascript/errors-example.js`) demonstrating error handling strategies for the Buttplug.js library. It likely shows how to use try-catch with async/await or `.catch()` with Promises to handle errors thrown during Buttplug operations.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n{jsErrorsExample}\n```\n\n----------------------------------------\n\nTITLE: Websocket Client Setup for Buttplug in JavaScript\nDESCRIPTION: This JavaScript snippet outlines how to connect to a Buttplug server via Websockets, targeting browser or Node.js environments. It uses the appropriate Buttplug JavaScript client libraries and highlights how to handle user-specified server addresses, default ports, and connection status handling. The example demonstrates the setup and initialization, as well as potential callbacks or error considerations relevant to the JavaScript environment.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connectors.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nimport jsExternalConnectorExample from '!!raw-loader!/examples/javascript/remote-connector-example.js';\n\n<CodeBlock language=\\\"js\\\">{jsExternalConnectorExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Required UCDF Configuration for Python WSDM Example (JSON)\nDESCRIPTION: This JSON snippet defines the necessary User Device Configuration File (UCDF) content required to run the provided Python WSDM example. It configures the Buttplug server to recognize a websocket device named `LVSDevice` and associate it with the `lovense` protocol. This file must be created and specified when running Intiface Engine or placed in the Intiface Central configuration directory for the Python example to connect successfully.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": {\n    \"major\": 2,\n    \"minor\": 6\n  },\n  \"user-configs\": {\n    \"specifiers\": {\n      \"lovense\": {\n        \"websocket\": {\n          \"names\": [\"LVSDevice\"]\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Buttplug.js WASM in HTML\nDESCRIPTION: This HTML snippet demonstrates how to load the Buttplug.js library from a CDN and initialize its WebAssembly (WASM) module. The `Buttplug.buttplugInit()` function must be called and its promise resolved before any other Buttplug commands can be executed in a web environment. This initialization step is crucial for loading the underlying WASM code.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<html>\n<head></head>\n<body>\n<script src=\"[buttplug CDN url here, see buttplug-js README for location/version]\"></script>\n<script lang=\"javascript\">\n  // After we've loaded the module above, we'll have a \"Buttplug\" global we can access \n  // methods and classes from. We'll use that to initialize the library. This is \n  // required because of the way we have to load our WASM code into the application. \n  // You'll need to call buttplugInit(), which returns a promise that will resolve \n  // when WASM is loaded, at which point you can go ahead and run other Buttplug \n  // commands.\n  //\n  // We have this call in all of our examples in this guide, to remind users that\n  // this must happen when running the library. If you do not call this, you'll\n  // get errors in your developer console (and exceptions thrown) that will\n  // remind you that you need to do it.\n  Buttplug.buttplugInit().then(() => console.log(\"Buttplug Loaded\"));\n</script>\n</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Serializing SensorSubscribeCmd Message Example - JSON\nDESCRIPTION: This JSON snippet demonstrates proper serialization of a SensorSubscribeCmd message for subscribing to a sensor stream on a device. The message specifies Id, DeviceIndex, SensorIndex, and SensorType, uniquely identifying the subscription details in the Buttplug.io protocol. On submission, the server replies with Ok and will stream SensorReading messages as new data is available. Precise field correspondence is important for successful subscription and subsequent data delivery.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"SensorSubscribeCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"SensorIndex\\\": 0,\\n      \\\"SensorType\\\": \\\"Pressure\\\"\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Async Client/Server Interaction in Rust\nDESCRIPTION: This placeholder indicates Rust code loaded from an external file (`/examples/rust/src/bin/async.rs`) that demonstrates asynchronous client/server interaction using the Buttplug Rust library. The code likely shows how to connect to a server, potentially scan for devices, and handle communication using Rust's async/await features.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{RustExample}\n```\n\n----------------------------------------\n\nTITLE: Modeling Sensor Subscription Workflow - Mermaid\nDESCRIPTION: This Mermaid sequence diagram depicts the process of subscribing to a sensor stream using the SensorSubscribeCmd in the Buttplug.io protocol. It details client-submitted subscription, server's Ok acknowledgment, followed by multiple asynchronous SensorReading messages to the client. The expected pattern is that once subscribed, the client receives real-time sensor readings without further explicit requests. Rendering requires a Mermaid interpreter; the structure ensures chronological clarity of the subscription process.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: SensorSubscribeCmd Id=1\\n    Server->>-Client: Ok Id=1\\n    Server->>+Client: SensorReading Id=0\\n    Server->>+Client: SensorReading Id=0\\n\n```\n\n----------------------------------------\n\nTITLE: Embedding a Buttplug Server using Bluetooth Manager in Rust\nDESCRIPTION: Demonstrates how to instantiate and configure an embedded Buttplug server inside a Rust application using the bluetooth device manager and configuration file included in the Rust library. This example is intended for desktop or server applications that require a fully self-contained server process, with both client and server running in-process. Key dependencies are the Rust Buttplug library and any required OS-level Bluetooth support. The code expects to be included in a Rust binary (main.rs or equivalent) and will require the 'buttplug' Rust crate; output, configuration, and error handling depend on the implementation in the full code. Limitations include platform dependency and debugging complexity, especially related to FFI or OS integration.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/cookbook/connections/embedding.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimport RustConnectorExample from '!!raw-loader!/examples/rust/src/bin/embedded_connector.rs';\n\n<CodeBlock language=\\\"rust\\\">{RustConnectorExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Handling Buttplug Device Enumeration in JavaScript\nDESCRIPTION: This JavaScript code demonstrates connecting to a Buttplug server, starting device discovery with `startScanning()`, stopping it with `stopScanning()`, and managing device connections using `deviceadded` and `deviceremoved` event listeners. It depends on the Buttplug JavaScript library.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-enum.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n{jsEnumerationExample}\n```\n\n----------------------------------------\n\nTITLE: Handling Ping Timeout Events in Buttplug C#\nDESCRIPTION: This C# example demonstrates how a Buttplug client application can react to a ping timeout. It involves setting up event handlers for server disconnection or errors and checking for the specific ERROR_PING error type to identify the cause of disconnection, ensuring graceful handling when communication fails.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/cookbook/connections/ping.mdx#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n{CSharpPingExample}\n```\n\n----------------------------------------\n\nTITLE: Declaring Nested Protocol Defaults and Customizations in YAML Configuration\nDESCRIPTION: This snippet illustrates a condensed configuration section for the Lovense protocol, with both default capabilities and two device-specific overrides under 'configurations'. It defines BLTE identifiers, custom GATT services with RX/TX UUIDs, and both message types (ScalarCmd and SensorReadCmd). Dependencies include the Buttplug Github repository schema validator and the Rust Buttplug server loader. Input parameters include a protocol key with appropriate identifiers, services, defaults, and device customizations; output is a processed runtime configuration. Constraints: Actual GATT service UUIDs may be hardware-specific, and identifiers like 'B' and 'P' map to real device models as per the protocol.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/device-configuration-file.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n  lovense:\n    btle:\n      names:\n        - LVS-*\n        - LOVE-*\n      services:\n        50300011-0023-4bd4-bbd5-a6920e4c5653: # Edge2 paired\n          tx: 50300012-0023-4bd4-bbd5-a6920e4c5653\n          rx: 50300013-0023-4bd4-bbd5-a6920e4c5653\n    defaults:\n      name: Lovense Device\n      messages:\n        ScalarCmd:\n          - StepRange: [0, 20]\n            ActuatorType: Vibrate\n        SensorReadCmd:\n          - FeatureDescriptor: Battery Level\n            SensorType: Battery\n            SensorRange: [[0, 100]]\n    configurations:\n      # For lovense, our identifiers are the letters returned from the\n      # DeviceInfo query sent on initialization.\n      - identifier:\n          - B\n        name: Lovense Max\n        messages:\n          ScalarCmd:\n            - StepRange: [0, 20]\n              FeatureDescriptor: Vibrator\n              ActuatorType: Vibrate\n            - StepRange: [0, 3]\n              FeatureDescriptor: Air Pump\n              ActuatorType: Constrict\n      - identifier:\n          - P\n        name: Lovense Edge\n        messages:\n          ScalarCmd:\n            - StepRange: [0, 20]\n              ActuatorType: Vibrate\n            - StepRange: [0, 20]\n              ActuatorType: Vibrate\n\n```\n\n----------------------------------------\n\nTITLE: Serializing SensorReading Message Example - JSON\nDESCRIPTION: This JSON example illustrates how sensor data returned from a device (in response to SensorReadCmd or via subscription) should be serialized. The message includes fields like Id, DeviceIndex, SensorIndex, SensorType, and an array of signed integers in Data. It provides a standardized format for communicating diverse sensor readings, including units as specified in feature descriptors. Consumers of this object should expect signed integer arrays, with values specific to sensor context (e.g., RSSI, battery, buttons).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"SensorReading\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"SensorIndex\\\": 0,\\n      \\\"SensorType\\\": \\\"Pressure\\\",\\n      \\\"Data\\\": [591]\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Device Protocol Defaults and Capabilities in YAML Configuration\nDESCRIPTION: This snippet demonstrates the structure of a device protocol configuration for the Aneros Vivi device in the YAML-based Device Configuration File (DCF). It shows how bluetooth identifiers and GATT services are specified, and how the default capabilities (two vibrator actuators) are declared under the defaults section. Requires the Buttplug Server Rust implementation and integration with its device configuration loader. The input is a dictionary of device protocols keyed by vendor, with nested keys for identifiers and skill definitions; output is the device's behavior specification as interpreted by Buttplug. Limitations include protocol- and implementation-specific fields which may change between versions.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/device-configuration-file.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  aneros:\n    btle:\n      names:\n        - Massage Demo\n      services:\n        0000ff00-0000-1000-8000-00805f9b34fb:\n          tx: 0000ff01-0000-1000-8000-00805f9b34fb\n    defaults:\n      name: Aneros Vivi\n      messages:\n        ScalarCmd:\n          - StepRange: [0, 127]\n            FeatureDescriptor: Perineum Vibrator\n            ActuatorType: Vibrate\n          - StepRange: [0, 127]\n            FeatureDescriptor: Internal Vibrator\n            ActuatorType: Vibrate\n\n```\n\n----------------------------------------\n\nTITLE: Serializing StopDeviceCmd Message in JSON\nDESCRIPTION: Provides a JSON example demonstrating the serialization format for a StopDeviceCmd message. The message is encapsulated within a JSON array and includes the command name ('StopDeviceCmd') as the key for an object containing the message 'Id' and the target 'DeviceIndex'.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"StopDeviceCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing RequestDeviceList Request - JSON - Buttplug Protocol\nDESCRIPTION: Demonstrates the client-side JSON payload for requesting the current list of devices from the server. Only requires an 'Id' field; upon success, the server replies with a DeviceList message using the same Id. This message does not trigger a device scan, only a list retrieval from known devices.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RequestDeviceList\\\": {\\n      \\\"Id\\\": 1\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing StopAllDevices Message in JSON\nDESCRIPTION: Provides a JSON example demonstrating the serialization format for a StopAllDevices message. Encapsulated in a JSON array, the message uses 'StopAllDevices' as the key for an object containing only the message 'Id', as it applies to all devices.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"StopAllDevices\": {\n      \"Id\": 1\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing DeviceList Response - JSON - Buttplug Protocol\nDESCRIPTION: Provides an exemplary JSON object structure sent by the server in reply to RequestDeviceList, enumerating connected devices and their capabilities. Includes nested arrays for Devices and per-device message parameters (e.g., DeviceMessages). Each device includes a DeviceName, DeviceIndex, with optional DeviceMessageTimingGap and DeviceDisplayName. Output is a JSON array containing a DeviceList object; clients should be prepared to handle optional fields and various device types.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"DeviceList\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"Devices\\\": [\\n        {\\n          \\\"DeviceName\\\": \\\"Test Vibrator\\\",\\n          \\\"DeviceIndex\\\": 0,\\n          \\\"DeviceMessages\\\": {\\n            \\\"ScalarCmd\\\": [\\n              {\\n                \\\"StepCount\\\": 20,\\n                \\\"FeatureDescriptor\\\": \\\"Clitoral Stimulator\\\",\\n                \\\"ActuatorType\\\": \\\"Vibrate\\\"\\n              },\\n              {\\n                \\\"StepCount\\\": 20,\\n                \\\"FeatureDescriptor\\\": \\\"Insertable Vibrator\\\",\\n                \\\"ActuatorType\\\": \\\"Vibrate\\\"\\n              }\\n            ],\\n            \\\"StopDeviceCmd\\\": {}\\n          }\\n        },\\n        {\\n          \\\"DeviceName\\\": \\\"Test Stroker\\\",\\n          \\\"DeviceIndex\\\": 1,\\n          \\\"DeviceMessageTimingGap\\\": 100,\\n          \\\"DeviceDisplayName\\\": \\\"User set name\\\",\\n          \\\"DeviceMessages\\\": {\\n            \\\"LinearCmd\\\": [ {\\n              \\\"StepCount\\\": 100,\\n              \\\"FeatureDescriptor\\\": \\\"Stroker\\\",\\n              \\\"ActuatorType\\\": \\\"Linear\\\"\\n            } ],\\n            \\\"StopDeviceCmd\\\": {}\\n          }\\n        }\\n      ]\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing StartScanning Request - JSON - Buttplug Protocol\nDESCRIPTION: Shows the JSON serialization format for sending a StartScanning message in the Buttplug protocol. Requires an unsigned integer 'Id' field for matching responses. Input: object with StartScanning property and an Id. Output: JSON array containing the structured command. Must be sent to the server as part of protocol communication.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"StartScanning\\\": {\\n      \\\"Id\\\": 1\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing StopScanning Request - JSON - Buttplug Protocol\nDESCRIPTION: Presents the serialization format for a StopScanning client request in the Buttplug protocol. The command requires an 'Id' field that uniquely matches server responses. Provides an explicit mechanism to end active device scans, typically required for connection-oriented discovery protocols. Accepted as a JSON array by the server.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"StopScanning\\\": {\\n      \\\"Id\\\": 1\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Visualizing RequestDeviceList Message Flow - Mermaid - sequenceDiagram\nDESCRIPTION: Provides a sequence diagram of the request and response cycle for fetching the list of known devices from the server. Outlines the client sending a RequestDeviceList message and the server responding with DeviceList, both linked by the same message Id. Can be rendered in documentation tools supporting Mermaid diagrams.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RequestDeviceList Id=1\\n    Server->>-Client: DeviceList Id=1\n```\n\n----------------------------------------\n\nTITLE: Serializing ScanningFinished Event - JSON - Buttplug Protocol\nDESCRIPTION: Shows the JSON representation sent from server to client to indicate scanning completion. Requires an 'Id' field; no other parameters are needed. Intended for the client to recognize the termination of scanning without requiring an explicit StopScanning command. Only sent by the server, not expected to be used by clients.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"ScanningFinished\\\": {\\n      \\\"Id\\\": 0\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing LinearCmd Message in JSON\nDESCRIPTION: Provides a JSON example for serializing a LinearCmd message. The structure includes the 'Id', 'DeviceIndex', and a 'Vectors' array. Each vector object specifies the linear actuator 'Index', the 'Duration' of movement in milliseconds, and the target 'Position' (0.0-1.0).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"LinearCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Vectors\": [\n        {\n          \"Index\": 0,\n          \"Duration\": 500,\n          \"Position\": 0.3\n        },\n        {\n          \"Index\": 1,\n          \"Duration\": 1000,\n          \"Position\": 0.8\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simulated Lovense Device for WSDM (Python)\nDESCRIPTION: This Python script demonstrates how to create a simulated Buttplug device that connects to the Websocket Device Manager (WSDM). It connects to the WSDM server, sends the required JSON handshake identifying itself as a Lovense device (`LVSDevice`), handles the Lovense protocol initialization (responding to `DeviceType;`), prints received vibration commands, and responds to battery level requests. It requires a websocket library (like `websockets`) and illustrates the full lifecycle of a WSDM device connection and interaction.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n// Code loaded from /examples/python/websocket-device-manager-example.py\n// See the full example script linked in the original documentation.\n<CodeBlock language=\"python\">{PythonWSDMExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: Illustrating StopDeviceCmd Flow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram depicts the communication flow for the StopDeviceCmd message. The client initiates the request with a specific message ID, and the server responds with an Ok message containing the same ID upon successful execution.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: StopDeviceCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Illustrating DeviceRemoved Message Flow using Mermaid\nDESCRIPTION: A Mermaid sequence diagram showing the server unilaterally sending a `DeviceRemoved` message with `Id=0` to the client. This visualizes the server-to-client nature of this message type within the Buttplug protocol, indicating a device has been disconnected.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_12\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    participant Client\n    participant Server\n    Server->>Client: DeviceRemoved Id=0\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Buttplug Device Enumeration in Rust\nDESCRIPTION: This Rust code exemplifies connecting to a Buttplug server, initiating device scanning using `start_scanning()`, handling `DeviceAdded` and `DeviceRemoved` events via an event stream, and eventually stopping the scan with `stop_scanning()`. It relies on the Buttplug Rust library and expects a running Buttplug server.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/device-enum.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{RustEnumerationExample}\n```\n\n----------------------------------------\n\nTITLE: Serializing ScalarCmd Message in JSON\nDESCRIPTION: Provides a JSON example for serializing a ScalarCmd message. It includes the message 'Id', target 'DeviceIndex', and an array 'Scalars'. Each element in the 'Scalars' array specifies the actuator 'Index', desired 'Scalar' level (0.0-1.0), and the 'ActuatorType' (e.g., 'Vibrate', 'Inflate') being controlled.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"ScalarCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Scalars\": [\n        {\n          \"Index\": 0,\n          \"Scalar\": 0.5,\n          \"ActuatorType\": \"Vibrate\"\n        },\n        {\n          \"Index\": 1,\n          \"Scalar\": 1.0,\n          \"ActuatorType\": \"Inflate\"\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing SensorReadCmd Message Example - JSON\nDESCRIPTION: This JSON snippet demonstrates how to serialize a SensorReadCmd request to retrieve current values from a device sensor in the Buttplug.io protocol. The object includes fields for unique message Id, DeviceIndex, SensorIndex, and the type of sensor being queried. This structure is used for transmitting commands to the server, and accurate field mapping is required for a valid request. The message expects a SensorReading response upon success.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"SensorReadCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"SensorIndex\\\": 0,\\n      \\\"SensorType\\\": \\\"Pressure\\\"\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing DeviceAdded Event - JSON - Buttplug Protocol\nDESCRIPTION: Shows the full JSON server-to-client message when a new device is added to the system. Includes required (Id, DeviceName, DeviceIndex, DeviceMessages) and optional fields (DeviceMessageTimingGap, DeviceDisplayName), as well as structured device message feature lists. Designed for clients to update their device registry and capability matrices dynamically.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"DeviceAdded\\\": {\\n      \\\"Id\\\": 0,\\n      \\\"DeviceName\\\": \\\"Test Vibrator\\\",\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"DeviceMessageTimingGap\\\": 100,\\n      \\\"DeviceDisplayName\\\": \\\"Rabbit Vibrator\\\",\\n      \\\"DeviceMessages\\\": {\\n        \\\"ScalarCmd\\\": [\\n          {\\n            \\\"StepCount\\\": 20,\\n            \\\"FeatureDescriptor\\\": \\\"Clitoral Stimulator\\\",\\n            \\\"ActuatorType\\\": \\\"Vibrate\\\"\\n          },\\n          {\\n            \\\"StepCount\\\": 20,\\n            \\\"FeatureDescriptor\\\": \\\"Insertable Vibrator\\\",\\n            \\\"ActuatorType\\\": \\\"Vibrate\\\"\\n          }\\n        ],\\n        \\\"StopDeviceCmd\\\": {}\\n       }\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Illustrating RotateCmd Flow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram illustrates the communication flow for the RotateCmd message. The client sends the rotation command with a message ID, and the server responds with an Ok message having the identical ID.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: RotateCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Serializing RawSubscribeCmd request (JSON)\nDESCRIPTION: Provides a JSON example for sending a RawSubscribeCmd to the server, containing Id, DeviceIndex, and Endpoint. Subscribing enables the client to receive continuous RawReading messages. Ensures the correct field structure for protocol compliance.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RawSubscribeCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"Endpoint\\\": \\\"tx\\\"\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing SensorUnsubscribeCmd Message Example - JSON\nDESCRIPTION: This JSON snippet represents how to serialize a SensorUnsubscribeCmd message to request ending a previously established sensor subscription. The object provides the Id, DeviceIndex, SensorIndex, and SensorType to match the target sensor stream. Upon processing, the server will respond with Ok, terminating the data stream. Proper construction and matching of parameters is required to ensure correct unsubscribe behavior and avoid protocol errors.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"SensorUnsubscribeCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"SensorIndex\\\": 0,\\n      \\\"SensorType\\\": \\\"Pressure\\\"\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Specifying Service UUID for Kiiroo Onyx 2 (plaintext)\nDESCRIPTION: This code snippet specifies the Bluetooth service UUID for identifying the primary service on the Kiiroo Onyx 2 device. It is required when establishing a Bluetooth connection or initializing communication. The UUID uniquely identifies the communication context for the device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-2.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nf60402a6-0294-4bdb-9f20-6758133f7090\n```\n\n----------------------------------------\n\nTITLE: Serializing RawReadCmd request (JSON)\nDESCRIPTION: Presents a JSON serialization example for the RawReadCmd command including Id, DeviceIndex, Endpoint, ExpectedLength, and WaitForData fields. Intended for use by clients when requesting the server to read device data. The expected server response is a RawReading JSON message with corresponding Id.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RawReadCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"Endpoint\\\": \\\"tx\\\",\\n      \\\"ExpectedLength\\\": 0,\\n      \\\"WaitForData\\\": false\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing RawUnsubscribeCmd request (JSON)\nDESCRIPTION: Shows the JSON structure for a RawUnsubscribeCmd with Id, DeviceIndex, and Endpoint fields. Used by clients to instruct servers to cease sending RawReading messages from a particular endpoint. Ensures graceful and compliant deactivation of endpoint subscriptions.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_8\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RawUnsubscribeCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"Endpoint\\\": \\\"tx\\\"\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Data Characteristic UUID for Kiiroo Onyx 2 (plaintext)\nDESCRIPTION: This snippet defines the Data Characteristic UUID used to interact with data streams on the Kiiroo Onyx 2 device. It is required when reading from or writing to the device over Bluetooth. The UUID ensures accurate targeting of the device's data channel.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-2.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n02962ac9-e86f-4094-989d-231d69995fc2\n```\n\n----------------------------------------\n\nTITLE: Illustrating RawWriteCmd flow with sequence diagram (Mermaid)\nDESCRIPTION: This snippet provides a visual sequence diagram using Mermaid demonstrating the process of a client issuing a RawWriteCmd message to the server and receiving an Ok response. No external dependencies are needed besides a Mermaid renderer. Shows message flow and expected interaction in the RawWriteCmd protocol.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RawWriteCmd Id=1\\n    Server->>-Client: Ok Id=1\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing RequestServerInfo Message - JSON Example\nDESCRIPTION: This JSON snippet shows a sample serialization structure for the RequestServerInfo message as used in the handshake protocol. It encapsulates all necessary fields: Id, ClientName, and MessageVersion, whereby ClientName must not be null and MessageVersion should match the client's capabilities. Dependencies: Both the client and server must agree on message structure, and this JSON must be valid per the protocol. Input: Specific field values, Output: Serialized JSON for transmission or documentation. Limitation: The values are static and illustrative.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/identification.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RequestServerInfo\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"ClientName\\\": \\\"Test Client\\\",\\n      \\\"MessageVersion\\\": 1\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Illustrating RawReadCmd flow with sequence diagram (Mermaid)\nDESCRIPTION: Uses the Mermaid diagramming language to illustrate the process where a client sends a RawReadCmd and the server returns a RawReading message. Useful for understanding the implementation flow of the read command in the protocol. Requires a Mermaid renderer to visualize.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RawReadCmd Id=1\\n    Server->>-Client: RawReading Id=1\\n\n```\n\n----------------------------------------\n\nTITLE: Documenting the Protocol Lifecycle Sequence Diagram (Mermaid, Markdown)\nDESCRIPTION: This Mermaid code snippet provides a sequence diagram for the Buttplug protocol lifecycle, illustrating message exchanges between client and server during connection setup, device scanning, interaction, and shutdown. No external dependencies are required to view the diagram within compatible Markdown viewers supporting Mermaid (e.g., VSCode with an extension, or GitHub). Key participants (Client, Server) and stepwise commands (RequestServerInfo, StartScanning, DeviceAdded, VibrateCmd, etc.) are annotated to show the flow, including ping routines and device management actions. Input is the static code; output is a rendered sequence diagram, with the constraint that rendering support must exist in the documentation platform.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/architecture.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n  Participant Client\\n  Participant Server\\n\\n  Note over Client,Server: Once a connection is established,<br/> perform the protocol handshake,<br/>which exchanges information<br/>about identification, versions,<br/>ping times, etc...\\n  Client->>+Server: RequestServerInfo Id=1\\n  Server->>-Client: ServerInfo Id=1\\n\\n  Note over Client,Server: If the server has a non-zero<br/>PingTimeout, the client must send<br/>a ping message to theserver<br/>before the specified timeout.<br/>A common strategy is to set<br/>the client Ping time to 1/2 the<br/>requested server ping time.\\n  loop [PingTime/2]\\n    Client->>+Server: Ping ID=N++\\n    Server->>-Client: Ok ID=N++\\n  end\\n\\n  Note over Client,Server: The client calls RequestDeviceList<br/>to get a list of already connected<br/>devices.\\n  Client->>+Server: RequestDeviceList Id=2\\n  Server->>-Client: DeviceList Id=2\\n  \\n  Note over Client,Server: To discover new devices, the client<br/>instructs the server to start<br/>scanning.\\n  Client->>+Server: StartScanning Id=3\\n  Server->>-Client: Ok Id=3\\n  \\n  Note over Client,Server: While the server is scanning, the<br/>server will notify the client of new<br/>devices.\\n  Server->>Client: DeviceAdded Id=0\\n  Server->>Client: DeviceAdded Id=0\\n  \\n  Note over Client,Server: Once devices have been discovered,<br/> the client instruct the server to</br> stop scanning. Once all device<br/>managers have stopped scanning,<br/>the server will notify the client.\\n  Client->>+Server: StopScanning Id=4\\n  Server->>-Client: Ok Id=4\\n  Server->>Client: ScanningFinished Id=0\\n  \\n  Note over Client,Server: Devices may disconnect at any time.<br/>The server will notify the client<br/>when this happens.\\n  Server->>Client: DeviceRemoved Id=0\\n  \\n  Note over Client,Server: The client may instruct devices to<br/>perform actions. Actions vary per<br/>device. Device capabilities are<br/>relayed as part of DeviceAdded and<br/>DeviceList messages.\\n  Client->>+Server: VibrateCmd Id=5\\n  Server->>-Client: Ok Id=5\\n  \\n  Note over Client,Server: The client may instruct the server to<br/>stop a device from whatever it<br/>may be doing.\\n  Client->>+Server: StopDeviceCmd Id=6\\n  Server->>-Client: Ok Id=6\\n  \\n  Note over Client,Server: The client may instruct the server to<br/>stop all devices. This is considered<br/> good form for a client that is<br/>shutting down.\\n  Client->>+Server: StopAllDevices Id=7\\n  Server->>-Client: Ok Id=7\n```\n\n----------------------------------------\n\nTITLE: Serializing Ok Status Message Structure (JSON)\nDESCRIPTION: This JSON example illustrates how a successful Ok status reply is serialized from server to client after receiving a valid message. The 'Id' field links the response to its originating request. There are no additional parameters required, and the output should be used as a server-to-client message only.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_1\n\nLANGUAGE: JSON\nCODE:\n```\n[\\n  {\\n    \\\"Ok\\\": {\\n      \\\"Id\\\": 1\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Returning Device Status JSON Block for Kiiroo Platform Server - JSON\nDESCRIPTION: This snippet represents a sample JSON status response returned by the /status endpoint when queried via a GET request. There are no dependencies required for this block, but in practice, it would be served by the Node.js Kiiroo platform server. The JSON object includes device name, Bluetooth address, firmware status, connection details, and feature flags. Expected output: a JSON block, primarily consumed by clients polling device status. No input parameters are required for this object, but the endpoint does not accept parameters either. This format must be preserved for client compatibility; ensure field names and datatypes match what the server provides.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/network/kiiroo-platform-server.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n\"connectedDeviceName\":\"ONYX\"\n\"bluetoothAddress\":\"8CDE52B866B5\"\n\"firmwareUpdateProgres\":0\n\"remoteDevice\":\"not connected\"\n\"devicestatus\":\"NORMAL\"\n\"localDevice\":\"connected\"\n\"previousdevice_connectionurl\":\"btspp://8CDE52B866B5:1;authenticate=false;encrypt=false;master=false\"\n\"readOnlyMode\":false\n\"streamToDeviceEnabled\":true\n\"delay\":0\n\"writeOnlyMode\":false\n\"currentFW\":\"91\"\n\"waitingforusbcable\":true\n\"bluetoothOn\":true\n\"previousdevice_name\":\"ONYX\"\n\"uienabled\":true\n\"newFWVersionAvailable\":false\n\"previousdevice_bluetoothaddress\":\"8CDE52B866B5\"\n\"statusCode\":1\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing StartScanning Message Flow - Mermaid - sequenceDiagram\nDESCRIPTION: Provides a sequence diagram illustrating the exchange between client and server during a StartScanning request. Shows the full protocol, including StartScanning, Ok, and multiple DeviceAdded events. Dependencies: Mermaid JavaScript renderer or compatible markdown preview with Mermaid support. No parameters; represents the protocol flow visually. Output offers a timeline of message passing for understanding the enumeration process. Only for visualization—does not affect implementation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: StartScanning Id=1\\n    Server->>-Client: Ok Id=1\\n    Server->>Client: DeviceAdded Id=0\\n    Server->>Client: DeviceAdded Id=0\n```\n\n----------------------------------------\n\nTITLE: Visualizing DeviceList Response Flow - Mermaid - sequenceDiagram\nDESCRIPTION: Shows the interaction where a client requests the device list and the server sends back the DeviceList message. Meant to clarify the 1:1 relationship and timing between request and response, as part of the overall enumeration protocol. Written in Mermaid sequence diagram notation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RequestDeviceList Id=1\\n    Server->>-Client: DeviceList Id=1\n```\n\n----------------------------------------\n\nTITLE: Example WSDM Handshake for Simulated Lovense Device (JSON)\nDESCRIPTION: This JSON snippet provides a concrete example of the handshake data sent by a simulated device connecting to the Websocket Device Manager (WSDM). It identifies the device as mapping to the Lovense Hush (identifier \"Z\"), provides a unique `address` (matching the expected output of Lovense `DeviceType;` command), and specifies WSDM protocol `version` 0. This is the first message the Python example script would send to the WSDM server.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"identifier\": \"Z\",\n  \"address\": \"8A3D9FAC2A45\",\n  \"version\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Illustrating StopAllDevices Flow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram illustrates the communication flow for the StopAllDevices message. The client sends the command with a message ID, and the server confirms successful execution by returning an Ok message with the matching ID.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: StopAllDevices Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Modeling Sensor Read Command and Response Sequence - Mermaid\nDESCRIPTION: This Mermaid sequence diagram visualizes the interaction flow between a client and server when issuing a SensorReadCmd in the Buttplug.io protocol. The diagram shows the client sending a SensorReadCmd message and the server responding with a SensorReading message sharing the same Id. No external dependencies are needed, but rendering requires a Mermaid-compatible documentation tool. The diagram expects the standard message Id-based correlation, illustrating request-response behavior.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: SensorReadCmd Id=1\\n    Server->>-Client: SensorReading Id=1\\n\n```\n\n----------------------------------------\n\nTITLE: Running Intiface Engine with WSDM Enabled (Shell)\nDESCRIPTION: This command-line example shows how to launch Intiface Engine with the Websocket Device Manager (WSDM) enabled, configured to run the Python example. The `--websocketport 12345` argument sets the main Buttplug server port (not the WSDM port), `--use-device-websocket-server` enables the WSDM feature itself, and `--user-device-config-file` specifies the path to the User Device Configuration File (UCDF) containing the WSDM settings defined in the previous JSON snippet. Replace `[path to the UDCF created above]` with the actual file path.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nintiface-engine --websocketport 12345 --use-device-websocket-server --user-device-config-file [path to the UDCF created above]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Async Client/Server Interaction in JavaScript\nDESCRIPTION: This placeholder indicates JavaScript code loaded from an external file (`/examples/javascript/async-example.js`) that demonstrates asynchronous client/server interaction using the Buttplug.js library. The code likely shows how to initialize the library, connect to a server, scan for devices, and handle responses/events using Promises or async/await.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{jsExample}\n```\n\n----------------------------------------\n\nTITLE: Extending Lovense Protocol for WSDM in UCDF (JSON)\nDESCRIPTION: This JSON snippet shows how to modify the User Device Configuration File (UCDF) to extend an existing protocol (Lovense) to support Websocket Device Manager (WSDM) connections. It adds a `websocket` specifier under the `lovense` protocol, defining `LVSDevice` as a valid identifier name for a connecting websocket device. This configuration allows the Buttplug server to recognize and handle websocket devices claiming this identifier using the Lovense protocol.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"version\": {\n    \"major\": 2,\n    \"minor\": 6\n  },\n  \"user-configs\": {\n    \"specifiers\": {\n      \"lovense\": {\n        \"websocket\": {\n          \"names\": [\"LVSDevice\"]\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Identifying We-Vibe Main Bluetooth Service UUID\nDESCRIPTION: Specifies the primary Bluetooth Low Energy (BLE) Service Universally Unique Identifier (UUID) used to interact with We-Vibe devices.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/wevibe.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nf000bb03-0451-4000-b000-000000000000\n```\n\n----------------------------------------\n\nTITLE: Example Buttplug Protocol 'Ok' Message (JSON)\nDESCRIPTION: This JSON snippet illustrates the structure of a basic Buttplug Protocol message when serialized to JSON, specifically the 'Ok' message. The server sends this to the client to confirm successful receipt and processing of a prior client message. It includes an 'Id' field which corresponds to the 'Id' of the original message sent by the client, allowing the client to correlate replies with requests, which is important as responses may arrive out of order. This example demonstrates the basic message envelope structure used in the protocol.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/architecture/protocol-in-depth.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Ok\": {\n    \"Id\": 1\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Ping Status Message Structure (JSON)\nDESCRIPTION: Illustrates the JSON serialization for a Ping request from the client to the server, using an Id to uniquely identify the message. The example demonstrates the correct format required for connection watchdog functioning within the protocol. No additional dependencies are needed, but Id must be unique per request.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_6\n\nLANGUAGE: JSON\nCODE:\n```\n[\\n  {\\n    \\\"Ping\\\": {\\n      \\\"Id\\\": 5\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Defining We-Vibe Info Characteristic Data Format\nDESCRIPTION: Describes the 8-byte format of data read from the We-Vibe Info Characteristic. Bytes represent the current vibration pattern (PP), battery level (ZZ, FFFF=100%), temperature in Fahrenheit (WW), internal (X) and external (Y) motor intensities, and device model code (MM).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/wevibe.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n01 PP ZZ ZZ ?? WW XY MM\n```\n\n----------------------------------------\n\nTITLE: Serializing Error Status Message Structure (JSON)\nDESCRIPTION: Shows how to serialize an Error message from server to client, capturing an error related to invalid JSON. Includes fields for Id, ErrorMessage, and ErrorCode. This format should be returned by the server when a client's request can't be parsed or triggers a protocol error; the ErrorCode is critical for programmatic error handling.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_4\n\nLANGUAGE: JSON\nCODE:\n```\n[\\n  {\\n    \\\"Error\\\": {\\n      \\\"Id\\\": 0,\\n      \\\"ErrorMessage\\\": \\\"Server received invalid JSON.\\\",\\n      \\\"ErrorCode\\\": 3\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ping-Ok Exchange with Mermaid Sequence Diagram (Mermaid)\nDESCRIPTION: This snippet details the expected protocol where a client pings the server, which then sends an Ok message in reply. Used to support connection health monitoring (watchdog pattern) in the client-server interaction. Requires a Mermaid renderer for visualization.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_5\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: Ping Id=5\\n    Server->>-Client: Ok Id=5\n```\n\n----------------------------------------\n\nTITLE: Visualizing ScanningFinished Event Flow - Mermaid - sequenceDiagram\nDESCRIPTION: Illustrates the protocol flow from scan initiation to the reception of the ScanningFinished event. Helpful in clarifying the server-driven message indicating the end of device scanning on all busses. Uses Mermaid's sequenceDiagram notation and can be rendered in tools supporting Mermaid diagrams. No parameters—meant purely for documentation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: StartScanning Id=1\\n    Server->>-Client: Ok Id=1\\n    Server->>Client: DeviceAdded Id=0\\n    Server->>Client: DeviceAdded Id=0\\n    Server->>Client: ScanningFinished Id=0\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Async Client/Server Interaction in C#\nDESCRIPTION: This placeholder indicates C# code loaded from an external file (`/examples/csharp/AsyncExample/Program.cs`) that demonstrates asynchronous client/server interaction using the Buttplug C# library. The code likely illustrates connecting to a server, handling device events, and sending commands using C#'s async/await pattern.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n{CSharpExample}\n```\n\n----------------------------------------\n\nTITLE: Serializing RawReading server response (JSON)\nDESCRIPTION: Shows the standardized JSON format of a RawReading message, typically sent from the server to the client after a RawReadCmd or RawSubscribeCmd. Contains Id, DeviceIndex, Endpoint, and Data fields. This format is important for data post-processing or for device communication tracing.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RawReading\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"Endpoint\\\": \\\"rx\\\",\\n      \\\"Data\\\": [0, 1, 0]\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Ok Message Exchange with Mermaid Sequence Diagram (Mermaid)\nDESCRIPTION: This snippet visualizes a client-server interaction where the client issues a StartScanning request and receives an Ok response referencing the same Id. It demonstrates the request-response pattern for successful communication. No programming dependencies are necessary, but a Mermaid-aware renderer is required to view the sequence diagram.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_0\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: StartScanning Id=1\\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Serializing ServerInfo Message - JSON Example\nDESCRIPTION: This JSON snippet provides an example serialization for the ServerInfo message as returned by the server in reply to the client's handshake request. The message includes Id, ServerName, MessageVersion, and MaxPingTime. Dependencies: Message fields must match protocol expectations and client-side parsing logic. Expected input: corresponding response parameters; Output: structured JSON sent from server to client. Constraints: ServerName can be null; all other fields must be appropriately set.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/identification.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"ServerInfo\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"ServerName\\\": \\\"Test Server\\\",\\n      \\\"MessageVersion\\\": 1,\\n      \\\"MaxPingTime\\\": 100\\n    }\\n  }\\n]\n```\n\n----------------------------------------\n\nTITLE: Declaring BLE Service UUID for Possible Kiss - Plain Text\nDESCRIPTION: Provides the Service UUID required for interacting with the Possible Kiss BLE service. This UUID (\"0000cb60-0000-1000-8000-00805f9b34fb\") is essential for applications to discover and communicate with the device's primary GATT service.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/possible_kiss.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n0000cb60-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Device Name for Possible Kiss - Plain Text\nDESCRIPTION: Specifies the BLE device name (\"RS-KNW\") to identify the Possible Kiss hardware during scanning and connection. This is used as a unique identifier in Bluetooth device discovery routines and is required for correct device pairing.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/possible_kiss.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nRS-KNW\n```\n\n----------------------------------------\n\nTITLE: Diagramming Handshake Sequence with Mermaid - Markdown/Diagrams\nDESCRIPTION: This mermaid snippet visually represents the handshake sequence between a client and server, specifically illustrating the client sending a RequestServerInfo message and the server replying with a ServerInfo message. Dependencies: Mermaid.js rendering support is required for visualization. It expects messages named and numbered as per the textual description, serving as a schematic for documentation and developer understanding. Input: none (static example), Output: a rendered sequence diagram. Limitations: does not encode any real protocol logic.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/identification.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>Server: RequestServerInfo Id=0\\n    Server->>Client: ServerInfo Id=0\n```\n\n----------------------------------------\n\nTITLE: Identifying Prettylove BLE Info Characteristic UUID\nDESCRIPTION: This UUID corresponds to the BLE characteristic used for reading device information (like battery level, product ID) and receiving notifications. It supports Read, Write, and Notify operations. Writing specific commands (`VOLT` or `WNDS`) triggers reads or notifications.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n0000ffe2-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: Serializing Buttplug Messages as JSON Array - JSON\nDESCRIPTION: This snippet demonstrates the standardized JSON array format used for serializing multiple Buttplug messages for transport between client and server. Each item in the array represents an individual message, with the key as the message type and its value as a nested object describing that message's fields and values. There are no dependencies, but the consumer should ensure that the receiver can handle the array format and respects the underlying message structure as specified in the protocol. The input expects properly structured objects per message and outputs a JSON array of messages for transmission or parsing.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/messages.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"MessageType\" :\n    {\n      \"MessageField1\": \"MessageValue1\",\n      \"MessageField2\": \"MessageValue2\"\n    }\n  },\n  {\n    \"MessageType2\" :\n    {\n      \"Message2Field1\": \"Message2Value1\",\n      \"Message2Field2\": \"Message2Value2\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Identifying Prettylove BLE Control Characteristic UUID\nDESCRIPTION: This UUID corresponds to the BLE characteristic used for sending control commands to the Prettylove device. It is a 2-byte characteristic supporting Write operations to control functions like vibration and electro-shock.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n0000ffe9-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Button Characteristic UUID - Markdown\nDESCRIPTION: This snippet records the button notification characteristic UUID for BLE communication with BKK devices, presented as a markdown code block. Reading or subscribing to this characteristic allows software to detect button presses. No parameters or dependencies are needed beyond BLE library support for UUIDs.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/bkk.md#_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0000ffe1-0000-1000-8000-00805f9b34fb\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying BLE Accelerometer Service UUID - Markdown\nDESCRIPTION: This snippet presents the UUID used for accessing the accelerometer BLE service on BKK devices, formatted in a markdown code block. Implementers use this UUID to connect to and read accelerometer data. This value should be referenced as-is when developing BLE integrations.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/bkk.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0000ffa0-0000-1000-8000-00805f9b34fb\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating RawUnsubscribeCmd flow with sequence diagram (Mermaid)\nDESCRIPTION: Displays, using Mermaid, the protocol sequence for unsubscribing from an endpoint. Shows the client issuing RawUnsubscribeCmd and the server acknowledging with an Ok message. Highlights the symmetry and minimalism of the unsubscribe workflow in the API.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_7\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RawUnsubscribeCmd Id=1\\n    Server->>-Client: Ok Id=1\\n\n```\n\n----------------------------------------\n\nTITLE: Kiiroo Bluetooth LE Service UUID\nDESCRIPTION: Defines the primary Service UUID used for identifying the Kiiroo device service when communicating via Bluetooth Low Energy (BLE). This UUID is necessary to discover and connect to the Kiiroo service on the device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n49535343-fe7d-4ae5-8fa9-9fafd205e455\n```\n\n----------------------------------------\n\nTITLE: Handling Buttplug Errors in Rust\nDESCRIPTION: This placeholder indicates Rust code loaded from an external file (`/examples/rust/src/bin/errors.rs`) demonstrating error handling within the Buttplug Rust library. It likely shows how to catch and process different `ButtplugError` types that can occur during connection, communication, or device interaction.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n{RustErrorExample}\n```\n\n----------------------------------------\n\nTITLE: Identifying Pearl 1 Device Path (Bluetooth 2.0)\nDESCRIPTION: Specifies the typical serial port device path assigned to the Kiiroo Pearl 1 toy when connected via Bluetooth 2.0 on OS X or Linux systems. This path is used for serial communication with the device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n/dev/tty.PEARL-DevB \n```\n\n----------------------------------------\n\nTITLE: Writing Bytes to ET-312B Device via Serial Protocol - Plaintext Hexadecimal\nDESCRIPTION: This snippet demonstrates how to assemble and send a bulk write command to the ET-312B device over the serial protocol. The command includes the opcode, address, two bytes of data, and a checksum; all values are hexadecimal. Implementers should ensure proper calculation of the opcode based on data length and append the appropriate checksum. The device is expected to respond with an acknowledgement byte if the command is accepted. Dependencies include an active RS-232 connection and appropriate key exchange if required by the protocol state.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et312b.md#_snippet_0\n\nLANGUAGE: plain\nCODE:\n```\n0x5d 0x40 0x10 0xfe 0xff 0xaa\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Response to Parsing Failure (Mermaid)\nDESCRIPTION: Depicting a case where the client sends a message with an unparseable Id, this Mermaid diagram shows the server replying with an Error message using Id=0. The sequence diagram clarifies protocol behavior for JSON parsing errors. Rendering the snippet requires a Mermaid interpreter.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_3\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: InvalidMsgId Id=Wat\\n    Server->>-Client: Error Id=0\n```\n\n----------------------------------------\n\nTITLE: Defining Prettylove Info Characteristic Write Commands\nDESCRIPTION: To read specific data or trigger notifications from the Info characteristic (0000ffe2-...), the client must first write either `VOLT` (0x564F4C54) for battery level or `WNDS` (0x574E4453) for product/UI info to the characteristic.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nVOLT (`0x564F4C54`)\n```\n\nLANGUAGE: text\nCODE:\n```\nWNDS (`0x574E4453`)\n```\n\n----------------------------------------\n\nTITLE: Specifying Pearl 1 Device Path for Local Interaction\nDESCRIPTION: Shows the expected device path for the Kiiroo Pearl 1 (connected via Bluetooth 2.0) on POSIX systems (like Linux or macOS). This path is referenced in the context of setting up direct local interaction with an Onyx 1 using the 'cat' command.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n/dev/tty.PEARL-DevB \n```\n\n----------------------------------------\n\nTITLE: Defining Service and Characteristic UUIDs - Bluetooth LE - text\nDESCRIPTION: Lists the UUID strings required for BLE communication with Vibratissimo devices. These constant values are needed for client applications to correctly identify and interact with the device's BLE service and its characteristics for mode control, motor speed, and temperature readout. Inputs and outputs are string UUIDs; no direct execution or parsing is depicted. Using incorrect UUIDs will render protocol operations inoperative.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vibratissimo.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n00001523-1212-efde-1523-785feabcd123\n```\n\nLANGUAGE: text\nCODE:\n```\n00001524-1212-efde-1523-785feabcd123\n```\n\nLANGUAGE: text\nCODE:\n```\n00001526-1212-efde-1523-785feabcd123\n```\n\nLANGUAGE: text\nCODE:\n```\n00001527-1212-efde-1523-785feabcd123\n```\n\n----------------------------------------\n\nTITLE: Handling Buttplug Exceptions in C#\nDESCRIPTION: This placeholder indicates C# code loaded from an external file (`/examples/csharp/ExceptionExample/Program.cs`) illustrating exception handling for the Buttplug C# library. It likely uses try-catch blocks to manage potential `ButtplugException` subclasses (like Handshake, Message, Device errors) during a session.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/api-basics.mdx#_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n{CSharpErrorsExample}\n```\n\n----------------------------------------\n\nTITLE: Performing Handshake Byte Transmission and Response (ET-232 Protocol, Plaintext)\nDESCRIPTION: This snippet illustrates the initial single-byte handshake sent by the ET-232 upon power-up via serial communication using the RS-232 protocol. Receiving this byte (0xCC) confirms that the device is ready to accept protocol commands. The example assumes configuration of 19200/8/N/1 serial parameters. No external dependencies are required beyond serial communication support. The output is a one-byte value signaling readiness; if missing, recheck physical connections and device state.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et232.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n0xcc\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with Yarn - Shell\nDESCRIPTION: Installs all project dependencies by invoking Yarn without arguments. Requires Node.js, Yarn, and a package.json file in the working directory. This command sets up the necessary Node modules to run, build, or develop the Docusaurus-powered website. No parameters required; output is a populated node_modules directory.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Basic T-code Command Structure for Live Control\nDESCRIPTION: Defines the fundamental structure for T-code commands used in live control. Commands consist of a letter (L, R, V, A for Linear, Rotate, Vibrate, Auxiliary) followed by a channel ID digit (&) and magnitude digits ($$). The magnitude represents a value between 0 and 1 (e.g., '77' means 0.77). Lowercase letters are also valid. Commands are executed upon receiving a newline character ('\\n').\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_0\n\nLANGUAGE: tcode\nCODE:\n```\nL&$$\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website with GitHub User Using Yarn - Shell\nDESCRIPTION: Pushes the static website to a remote repository by specifying the GitHub username via 'GIT_USER' environment variable and running 'yarn deploy'. Intended for users not utilizing SSH; requires that the username supplied has appropriate repository permissions. Effect: Triggers deployment to the 'gh-pages' branch on GitHub Pages.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/README.md#_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Diagramming ServerInfo Handshake Response - Mermaid Diagram\nDESCRIPTION: This mermaid diagram duplicates the server's response cycle for the handshake, mirroring the earlier handshake diagram. It demonstrates the symmetry of message exchange in documentation. Dependencies: Mermaid.js support for rendering; intended for visual documentation rather than execution. Input/Output: None, static for illustration only. Limitation: Redundant with earlier handshake diagram, used for clarity in markdown.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/identification.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>Server: RequestServerInfo Id=0\\n    Server->>Client: ServerInfo Id=0\n```\n\n----------------------------------------\n\nTITLE: Example T-code Live Control Commands\nDESCRIPTION: Provides concrete examples of basic T-code commands for different channels and magnitudes. 'L277' sets linear channel 2 to magnitude 0.77. 'R09' sets rotation channel 0 to magnitude 0.9. 'V317439' sets vibration channel 3 to magnitude 0.17439. For fastest response, each command should be followed immediately by '\\n'.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_1\n\nLANGUAGE: tcode\nCODE:\n```\nL277\n```\n\nLANGUAGE: tcode\nCODE:\n```\nR09\n```\n\nLANGUAGE: tcode\nCODE:\n```\nV317439\n```\n\n----------------------------------------\n\nTITLE: Defining Sensor Notification Characteristic UUID for Kiiroo Onyx 2 (plaintext)\nDESCRIPTION: This code snippet lists the UUID for the Bluetooth characteristic responsible for sensor notifications. This is required to subscribe to notifications from the device sensors. It allows applications to listen for real-time sensor data from the Kiiroo Onyx 2.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-2.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nd44d0393-0731-43b3-a373-8fc70b1f3323\n```\n\n----------------------------------------\n\nTITLE: T-code Save Command Structure for User Preferences\nDESCRIPTION: Defines the structure for saving user preferences (min/max range) for a specific axis to the device's EEPROM (e.g., on OSR2/SR6). The command starts with '$', followed by axis type (T: L, R, V, A), axis number (X: 0-9), preferred minimum (YYYY: 0000-9999), and preferred maximum (ZZZZ: 0000-9999). These saved preferences are informational for the controlling application (retrieved via 'D2') and do not alter the device's core behavior.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_10\n\nLANGUAGE: tcode\nCODE:\n```\n$TX-YYYY-ZZZZ\n```\n\n----------------------------------------\n\nTITLE: Connecting to Buttplug Server with the Buttplug Rust Client – Rust\nDESCRIPTION: This code example, referenced as RustConnectionExample, demonstrates how to establish a connection to a Buttplug server using the Rust client library. It likely covers the setup of the connector, handling connection success or failure, and may illustrate basic event handling or error management. The snippet requires the Buttplug Rust client library and assumes the client and server versions are compatible. Input parameters would typically include the connector configuration, and the expected output is a successful connection object or an error state. Limitations could stem from library version mismatches or unavailable servers.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/connecting.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nimport RustConnectionExample from '!!raw-loader!/examples/rust/src/bin/connection.rs';\n\n<CodeBlock language=\"rust\">{RustConnectionExample}</CodeBlock>\n```\n\n----------------------------------------\n\nTITLE: T-code Channel Definitions for OSR2/SR6 Extra Functions\nDESCRIPTION: Lists the T-code channel assignments for extra functions specific to OSR2/SR6 devices: vibration (V0, V1), direct valve control (A0), valve suck algorithm control (A1), and lube motor speed (A2). It specifies the magnitude range and interpretation for each channel (e.g., A0/A1: 0=open, 9999=closed; A2: 0-9999 for 0-100% speed).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_8\n\nLANGUAGE: tcode\nCODE:\n```\nV0\n```\n\nLANGUAGE: tcode\nCODE:\n```\nV1\n```\n\nLANGUAGE: tcode\nCODE:\n```\nA0\n```\n\nLANGUAGE: tcode\nCODE:\n```\nA1\n```\n\nLANGUAGE: tcode\nCODE:\n```\nA2\n```\n\n----------------------------------------\n\nTITLE: Building Static Docusaurus Content with Yarn - Shell\nDESCRIPTION: Generates static website files for production deployment by executing Yarn's 'build' script. This step compiles markdown, assets, and configuration into the 'build' directory. Prerequisites include completed installation and configuration. Inputs: Markdown content, Docusaurus config; Outputs: Production-ready static files in the build folder.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Illustrating ScalarCmd Flow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram shows the communication flow for the ScalarCmd message. The client sends the command specifying scalar values, identified by an ID, and the server acknowledges receipt and successful processing with an Ok message carrying the same ID.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: ScalarCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Defining a Minimal Funscript File Structure in JSON\nDESCRIPTION: This snippet demonstrates the minimal JSON structure for a .funscript file, which drives time-based interactive device actions. Dependencies include player software that can interpret this format (e.g., OpenFunscripter, JoyFunScripter), and files must be named to match their companion video. Key parameters are 'version' (script schema version), 'inverted' (device directionality), 'range' (movement amplitude), and 'actions' (each holds a 'pos', 0-99, and timestamp 'at' in milliseconds). Expected input is a well-formed JSON file; output is synchronized device motion. The file must include at least these properties to be playable, and additional metadata is optional.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/video-encoding-formats/funscript.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \\\"version\\\": \\\"1.0\\\",\\n  \\\"inverted\\\": false,\\n  \\\"range\\\": 90,\\n  \\\"actions\\\": [\\n    {\\n      \\\"pos\\\": 0,\\n      \\\"at\\\": 1000\\n    },\\n    {\\n      \\\"pos\\\": 99,\\n      \\\"at\\\": 2000\\n    },\\n    {\\n      \\\"pos\\\": 0,\\n      \\\"at\\\": 3000\\n    }\\n  ]\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Accelerometer Characteristic UUID - Markdown\nDESCRIPTION: This entry details the accelerometer characteristic UUID, which supports read and notify operations over BLE. Developers leverage this identifier to subscribe to real-time accelerometer data. Implementation requires using this UUID when setting up BLE characteristic event handlers.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/bkk.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0000ffa1-0000-1000-8000-00805f9b34fb\n```\n```\n\n----------------------------------------\n\nTITLE: Identifying Onyx 1 Device Path (Bluetooth 2.0)\nDESCRIPTION: Specifies the typical serial port device path assigned to the Kiiroo Onyx 1 toy when connected via Bluetooth 2.0 on OS X or Linux systems. This path is used for serial communication with the device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n/dev/tty.ONYX-DevB\n```\n\n----------------------------------------\n\nTITLE: Example T-code Command with Time Interval Ramping\nDESCRIPTION: Illustrates a T-code command using time interval ramping. 'V199I2000' commands vibration channel 1 to ramp to magnitude 0.99 over 2000 milliseconds (2 seconds). The channel maintains the target level after the ramp completes.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_3\n\nLANGUAGE: tcode\nCODE:\n```\nV199I2000\n```\n\n----------------------------------------\n\nTITLE: Example FeelMe .meta File Structure (JSON)\nDESCRIPTION: This JSON snippet exemplifies the structure of a FeelMe `.meta` file. It includes metadata like creation date, ID, name, and video information. The core script is stored as a string in the `text` field, mapping timestamps (in seconds) to integer positions (0-4). Note that the `session_id` and property order might be randomized in actual files.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/video-encoding-formats/feelme.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"created\": \"2021-01-01T00:00:00.000000\",\n  \"id\": 1234,\n  \"description\": \"\",\n  \"name\": \"Name of video\",\n  \"session_id\": \"1234567890123456\",\n  \"text\": \"{1.00:0,2.50:4,5.00:0}\",\n  \"type\": \"penetration\",\n  \"video\": {\n    \"created\": \"2021-01-01T00:00:00.000000\",\n    \"description\": \"\",\n    \"external_id\": \"video_id\",\n    \"name\": \"12345\",\n    \"subtitles_count\": 1\n  },\n  \"video_external_id\": \"video_id\"\n}\n```\n\n----------------------------------------\n\nTITLE: T-code Command Structure with Speed-Based Ramping\nDESCRIPTION: Describes the T-code command format for ramping a channel to a target magnitude at a specified speed. The 'S' (or 's') suffix is followed by the speed (£££) defined as magnitude change per hundred milliseconds.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_4\n\nLANGUAGE: tcode\nCODE:\n```\nR&$$S£££\n```\n\n----------------------------------------\n\nTITLE: Issuing Bootloader Command Bytes - Markdown\nDESCRIPTION: This snippet demonstrates the exact byte-level command sequence used when communicating with the Kiiroo bootloader protocol over Bluetooth. The CTL (control) and DATA characteristics must each receive a single byte, representing the command index and its associated data respectively. No external code dependencies exist, but procedural context assumes access to BLE write operations.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/firmware/kiiroo.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0xGG -> CTL\n0xHH -> DATA\n```\n```\n\n----------------------------------------\n\nTITLE: T-code Command Structure with Time Interval Ramping\nDESCRIPTION: Describes the T-code command format for ramping a channel to a target magnitude over a specified time interval. The 'I' (or 'i') suffix is followed by the duration in milliseconds (£££). The channel starts ramping from its current value.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_2\n\nLANGUAGE: tcode\nCODE:\n```\nL&$$I£££\n```\n\n----------------------------------------\n\nTITLE: T-code Axis Definitions for Multi-Axis Stroker Robots (MAxSR)\nDESCRIPTION: Defines the default T-code channel assignments for linear (L0, L1, L2) and rotational (R0, R1, R2) axes on MAxSR devices. It specifies the positive direction for each axis and notes the standard position range (0 to ~0.9999) with 0.5 as the neutral position.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_7\n\nLANGUAGE: tcode\nCODE:\n```\nL0\n```\n\nLANGUAGE: tcode\nCODE:\n```\nL1\n```\n\nLANGUAGE: tcode\nCODE:\n```\nL2\n```\n\nLANGUAGE: tcode\nCODE:\n```\nR0\n```\n\nLANGUAGE: tcode\nCODE:\n```\nR1\n```\n\nLANGUAGE: tcode\nCODE:\n```\nR2\n```\n\n----------------------------------------\n\nTITLE: T-code Device Commands\nDESCRIPTION: Details device-specific commands prefixed with 'D' or 'd'. 'D0' requests device identification and firmware version. 'D1' requests the supported T-code version. 'D2' requests a list of available axes and their user-defined range preferences. 'DSTOP' commands the device to halt all activity.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_9\n\nLANGUAGE: tcode\nCODE:\n```\nD0\n```\n\nLANGUAGE: tcode\nCODE:\n```\nD1\n```\n\nLANGUAGE: tcode\nCODE:\n```\nD2\n```\n\nLANGUAGE: tcode\nCODE:\n```\nDSTOP\n```\n\n----------------------------------------\n\nTITLE: Identifying We-Vibe Info Characteristic UUID\nDESCRIPTION: Specifies the Bluetooth Low Energy (BLE) Characteristic Universally Unique Identifier (UUID) used to read information and status from We-Vibe devices via its main service.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/wevibe.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nf000b000-0451-4000-b000-000000000000\n```\n\n----------------------------------------\n\nTITLE: Defining We-Vibe Control Command Byte Format\nDESCRIPTION: Describes the 8-byte format for commands sent to the We-Vibe Control Characteristic. Bytes control vibration pattern (PP), internal (X) and external (Y) motor intensity, and potentially motor on/off state (Z). A pattern of 0x00 turns motors off, as intensity 0 does not.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/wevibe.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n0f PP 00 XY 00 0Z 00 00\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for Logging in PowerShell\nDESCRIPTION: This PowerShell snippet sets the RUST_LOG environment variable to enable debug-level logging for Rust-based Buttplug applications. This is the recommended approach when running the program on Windows in a PowerShell environment. Input is the desired log level; output is the environment variable being set for processes started in the session.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/logging.mdx#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n$env:RUST_LOG=\"debug\"\n```\n\n----------------------------------------\n\nTITLE: Serializing RequestLog Message (JSON)\nDESCRIPTION: This JSON snippet demonstrates the serialization format for a `RequestLog` message. It shows an example message with `Id` set to 1 and `LogLevel` set to \"Warn\", requesting log messages at the Warn level or higher from the server. The message is encapsulated within a JSON array, adhering to the Buttplug protocol message structure.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_27\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"RequestLog\": {\n      \"Id\": 1,\n      \"LogLevel\": \"Warn\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Generating F-Machine Signal Data File (`data.bin`) in TypeScript\nDESCRIPTION: This TypeScript script generates a `data.bin` file containing encoded signal data. It defines constants for signal properties (sampling rate, frequency), functions to calculate signal samples (`getSample`), convert floats to 8-bit integers (`floatToInt`), write samples to an array (`writeSamples`), encode a bit sequence into a raw signal (`getRawMessage`), and translate button inputs into the bit sequence (`getMessage`). The script uses Deno's file system API (`Deno.writeFile`) to write an initial silence period followed by multiple repetitions of a specific message (e.g., `speed: \"inc\"`) into the `data.bin` file. It requires the Deno runtime and write permissions (`deno --allow-write f-machine.ts`) to execute.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/f-machine.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst SAMPLES_PER_SECOND = 2_000_000;\nconst SIGNAL_FREQUENCY = SAMPLES_PER_SECOND / 561.4; // 3,562 Hz\nconst ANGULAR_FREQUENCY = 2 * Math.PI * SIGNAL_FREQUENCY;\n\nfunction getSample(position: number, amplitude: number) {\n  const real = amplitude * Math.sin(ANGULAR_FREQUENCY * position);\n  const imag = amplitude * Math.cos(ANGULAR_FREQUENCY * position);\n  return [real, imag];\n}\n\nfunction floatToInt(input: number) {\n  return Math.round(\n    input >= 0 ? Math.min(127, input * 127) : Math.max(-128, input * 128)\n  );\n}\n\nfunction writeSamples(\n  array: Int8Array,\n  numSamples: number,\n  offset: number,\n  magnitude: number\n) {\n  for (let i = 0; i < numSamples; i += 1) {\n    const [real, imag] = getSample(\n      (offset + i) / SAMPLES_PER_SECOND,\n      magnitude\n    );\n    array[i * BYTES_PER_SAMPLE] = floatToInt(real);\n    array[i * BYTES_PER_SAMPLE + 1] = floatToInt(imag);\n  }\n}\n\nconst SAMPLES_PER_BIT = Math.round(1.72 * 0.001 * SAMPLES_PER_SECOND); // 1.72ms per bit\nconst BITS_PER_MESSAGE = 25;\nconst SILENCE_BITS = 7;\nconst BYTES_PER_SAMPLE = 2;\n\nconst WIDTH_SET = 0.79;\nconst WIDTH_UNSET = 0.334 * 2;\n\nfunction getRawMessage(bits: ReadonlyArray<0 | 1>) {\n  const array = new Int8Array(\n    SAMPLES_PER_BIT * (BITS_PER_MESSAGE + SILENCE_BITS) * BYTES_PER_SAMPLE\n  );\n\n  for (let i = 0; i < BITS_PER_MESSAGE; i += 1) {\n    const part = new Int8Array(\n      array.buffer,\n      i * SAMPLES_PER_BIT * BYTES_PER_SAMPLE,\n      SAMPLES_PER_BIT * BYTES_PER_SAMPLE\n    );\n\n    if (bits[i] === 1) {\n      writeSamples(\n        part,\n        SAMPLES_PER_BIT * WIDTH_SET,\n        i * SAMPLES_PER_BIT * BYTES_PER_SAMPLE,\n        2.3\n      );\n    } else {\n      writeSamples(\n        part,\n        (SAMPLES_PER_BIT / 2) * WIDTH_UNSET,\n        i * SAMPLES_PER_BIT * BYTES_PER_SAMPLE,\n        2.3\n      );\n\n      // do nothing for other half since bytes are already zero\n    }\n  }\n\n  // do nothing for empty space at the end, it is already zero\n\n  return array;\n}\n\ninterface Buttons {\n  power?: true;\n  speed?: \"inc\" | \"dec\";\n  suction?: \"inc\" | \"dec\";\n}\n\nfunction getMessage(buttons: Buttons) {\n  const bits = [\n    // header\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0,\n    1,\n    // buttons\n    0,\n    0,\n    buttons.suction === \"inc\" ? 1 : 0,\n    buttons.suction === \"inc\" ? 1 : 0,\n    buttons.speed === \"inc\" ? 1 : 0,\n    buttons.speed === \"inc\" ? 1 : 0,\n    buttons.speed === \"dec\" ? 1 : 0,\n    buttons.speed === \"dec\" ? 1 : 0,\n    buttons.power === true ? 1 : 0,\n    buttons.power === true ? 1 : 0,\n    buttons.suction === \"dec\" ? 1 : 0,\n    buttons.suction === \"dec\" ? 1 : 0,\n    // end\n    0,\n  ] as const;\n\n  return getRawMessage(bits);\n}\n\nconst MESSAGE: Buttons = { speed: \"inc\" };\nconst NUM_MESSAGES = 13;\n\nawait Deno.writeFile(\"./data.bin\", new Uint8Array(SAMPLES_PER_SECOND / 2)); // 250ms of silence at the start\nfor (let m = 0; m < NUM_MESSAGES; m += 1) {\n  const messageData = getMessage(MESSAGE);\n  await Deno.writeFile(\"./data.bin\", new Uint8Array(messageData.buffer), {\n    append: true,\n  });\n}\nconsole.log(\"Done writing to data.bin!\");\n```\n\n----------------------------------------\n\nTITLE: Serializing BatteryLevelReading Message (JSON)\nDESCRIPTION: This JSON snippet demonstrates the serialization format for a `BatteryLevelReading` message sent by the server in response to a `BatteryLevelCmd`. It includes the `Id` (1) matching the original request, the `DeviceIndex` (0) the reading pertains to, and the actual `BatteryLevel` (0.5), which is a double value between 0.0 and 1.0.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_35\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"BatteryLevelReading\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"BatteryLevel\": 0.5\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Illustrating BatteryLevelCmd Request/Response Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram illustrates the request-response flow for checking a device's battery level. The client sends a `BatteryLevelCmd` (with Id=1 targeting DeviceIndex=0) to the server. The server responds with a `BatteryLevelReading` message containing the requested information, including the matching Id, the DeviceIndex, and the BatteryLevel (0.5 in this example).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_32\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>Server: BatteryLevelCmd Id=1 DeviceIndex=0\n    Server->>Client: BatteryLevelReading Id=1 DeviceIndex=0 BatteryLevel=0.5\n```\n\n----------------------------------------\n\nTITLE: Controlling Shock Collar via RFCat in Python 2\nDESCRIPTION: This Python 2 script controls a shock collar using an RFCat device. It depends on `rflib` for RF communication and `bitstring` for data manipulation. The script defines constants for communication parameters (`_COLLAR_BAUD_PWM`, `_COLLAR_FREQ`), includes functions to convert between raw binary and a specific 4-bit PWM encoding (`_pwm_to_raw`, `_raw_to_pwm`), configures the RFCat device for ASK/OOK modulation at the specified frequency and baud rate (`configure_rfcat`), transmits raw data with a preamble and padding (`tx_raw`), constructs and sends a 'zap' command with adjustable intensity (`zap`), and provides a simple `ShockCollar` class to initialize the device and send shock commands.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/petrainer.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport rflib\nimport binascii\nimport bitstring\n\nMHZ=1000*1000\n\n_COLLAR_BAUD_PWM=4200\n_COLLAR_BAUD=_COLLAR_BAUD_PWM/4\n_COLLAR_FREQ=434*MHZ\n\ndef _pwm_to_raw(pwm):\n    raw = bitstring.BitStream()\n    while True:\n        try:\n            nybble = pwm.read(4)\n            if nybble.bin == \"1110\":\n                raw += bitstring.Bits(\"0b1\")\n            elif nybble.bin == \"1000\":\n                raw += bitstring.Bits(\"0b0\")\n            elif nybble.bin == \"0000\":\n                pass #ew\n            else:\n                print nybble\n                print nybble.bin\n                raise ValueError(\"bad nybble\")\n\n        except bitstring.ReadError:\n            break\n\n    return raw\n\ndef _raw_to_pwm(raw):\n    pwm = bitstring.BitStream()\n    for bit in raw.bin:\n        if bit == \"0\": pwm += bitstring.Bits(\"0b1000\")\n        else: pwm += bitstring.Bits(\"0b1110\")\n\n    return pwm\n\n\ndef configure_rfcat(d):\n    d.setFreq(_COLLAR_FREQ)\n    d.setMdmModulation(rflib.MOD_ASK_OOK)\n    d.setMdmDRate(_COLLAR_BAUD_PWM)\n\ndef tx_raw(d, raw, repeat=8):\n    pwm = _raw_to_pwm(raw)\n    tosend = bitstring.BitString(bytes=\"\\x00\\x01\\xf0\", length=(20)) + pwm + bitstring.Bits(bytes=\"\\x00\\x00\\x00\")\n    # print tosend.hex\n    d.RFxmit(tosend.tobytes(), repeat=repeat)\n\ndef zap(d, intensity):\n    assert intensity <= 100\n    assert intensity >= 0\n\n    template=bitstring.BitString(bin=\"010000001101110100101011100101000011111100\")\n    template[25:32] = bitstring.Bits(uint=intensity, length=7)\n    tx_raw(d, template)\n\n\nclass ShockCollar:\n    def __init__(self):\n        d = rflib.RfCat()\n        configure_rfcat(d)\n        self.d = d\n    def shock(self, intensity=1.0):\n        intensity_int = int(intensity*100.0)\n\n        zap(self.d, intensity_int)\n\n```\n\n----------------------------------------\n\nTITLE: Example Firmware Version Return Bytes - Markdown\nDESCRIPTION: Shows a prototypical array of response bytes received from the 'Get Software Version' command, when the firmware is at version 1.3 and the return length is 6 bytes. This documentation snippet is intended to help users recognize how to parse the relevant major and minor version bytes from the raw response. There are no dependencies or code parameters, just the static representation of a response array.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-bootloader.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n    0xXX 0xXX 0xXX 0xXX 0x01 0x03\n```\n\n----------------------------------------\n\nTITLE: Illustrating RSSILevelCmd Request/Response Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram illustrates the request-response flow for checking a device's Received Signal Strength Indicator (RSSI) level. The client sends an `RSSILevelCmd` (with Id=1 targeting DeviceIndex=0) to the server. The server responds with an `RSSILevelReading` message containing the requested information, including the matching Id, the DeviceIndex, and the RSSILevel (-40 dBm in this example).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_36\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>Server: RSSILevelCmd Id=1 DeviceIndex=0\n    Server->>Client: RSSILevelReading Id=1 DeviceIndex=0 RSSILevel=-40\n```\n\n----------------------------------------\n\nTITLE: Formatting Command Packet (Firmware v1.2/1.3) for Device Control - Plaintext\nDESCRIPTION: This snippet shows the structure of a two-byte command sent to the Fleshlight Launch for firmware v1.2/1.3. The first byte (0xYY) sets the desired position (0-99, decimal), and the second (0xZZ) sets the speed (0-99, decimal). The device expects this format as input via Bluetooth to control movement; invalid values are ignored. Requires knowledge of correct position and speed range.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/fleshlight-launch.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n0xYY 0xZZ\n```\n\n----------------------------------------\n\nTITLE: Serializing RSSILevelReading Message (JSON)\nDESCRIPTION: This JSON snippet demonstrates the serialization format for an `RSSILevelReading` message sent by the server in response to an `RSSILevelCmd`. It includes the `Id` (1) matching the original request, the `DeviceIndex` (0) indicating the device the reading belongs to, and the `RSSILevel` (-40), representing the signal strength, typically in dBm (usually ranging from -100 to 0).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_39\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"RSSILevelReading\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"RSSILevel\": -40\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Parsing Prettylove Info Characteristic Read Format\nDESCRIPTION: Data read from the Info characteristic (0000ffe2-...) follows this 4-byte format. If bytes BB and CC are zero, AA represents the battery level (0-100). If CC is 0x40, AABB represents the product value and DD represents the UI value.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_4\n\nLANGUAGE: hexadecimal\nCODE:\n```\n0xAA 0xBB 0xCC 0xDD\n```\n\n----------------------------------------\n\nTITLE: Example ET312 Firmware Version Bytes Representation\nDESCRIPTION: This snippet shows an example byte sequence representing the firmware version stored at memory addresses $00fd to $00ff in the ET312. The bytes correspond to Major (0x01), Minor (0x06), and Interval (0x00) revision numbers, respectively. This specific example represents firmware version 1.6.0.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et312b.md#_snippet_1\n\nLANGUAGE: example\nCODE:\n```\n0x01 0x06 0x00\n```\n\n----------------------------------------\n\nTITLE: Requesting Programmed Pattern Command (Lovense Protocol)\nDESCRIPTION: Command sent to a Lovense device (Lush 2, Domi) to retrieve the definition of a pre-programmed pattern. The digit following the colon (e.g., '4') indicates the index of the pattern to retrieve. This command is available for Lush 2 and Domi models.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/lovense.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nGetPatten:4;\n```\n\n----------------------------------------\n\nTITLE: Viewing Programmed Pattern Response Example (Domi)\nDESCRIPTION: Example response from a Lovense Domi device when pattern 4 is requested using 'GetPatten:4;'. The response ('P4') is split into multiple parts (e.g., '1/5', '2/5'), using single-digit part indices. Each digit in the sequence represents the vibration level (0-9) for one half-second interval.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/lovense.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nP4:1/5:000042003720;\nP4:2/5:000002436658;\nP4:3/5:997339993001;\nP4:4/5:291111115111;\nP4:5/5:1110000000;\n```\n\n----------------------------------------\n\nTITLE: Confirmation Response for Running Pattern (Lovense Protocol)\nDESCRIPTION: Standard 'OK;' response from a Lovense device indicating that the 'Preset' command (to run or stop a pattern) was successfully received and acknowledged by the device. This is the expected positive confirmation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/lovense.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nOK;\n```\n\n----------------------------------------\n\nTITLE: Describing Protocol Response Format - Markdown\nDESCRIPTION: This Markdown-formatted snippet documents the ASCII response packet structure from the EStim 2B serial protocol. It lists and explains each colon-separated field in the device response, including battery level, power levels, mode, power setting, and firmware. No dependencies or execution is involved—it is purely documentation and reference, not meant for direct code execution.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/estim-systems-2b.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\nAAA:BB:CC:DD:EE:F:G:H:II\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating Log Message Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram depicts the flow leading to `Log` messages. First, the client enables logging by sending a `RequestLog` message (Id=1), which is acknowledged by the server (`Ok` Id=1). Subsequently, the server sends unsolicited `Log` messages (Id=0) to the client, with varying `LogLevel`s (e.g., \"Warn\", \"Trace\"), containing the actual log content.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_28\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: RequestLog Id=1\n    Server->>-Client: Ok Id=1\n    Server->>Client: Log Id=0 LogLevel=Warn\n    Server->>Client: Log Id=0 LogLevel=Trace\n```\n\n----------------------------------------\n\nTITLE: Transmitting RF Message with HackRF One - Command-line Tool - bash\nDESCRIPTION: This Bash command demonstrates how to use the 'hackrf_transfer' tool to transmit a pre-encoded binary message to an F-machine device using the HackRF One hardware. It specifies the transmission frequency (314.965 MHz), transmit power (30 dB), sample rate (2,000,000 Hz), and reads message data from a local 'data.bin' file. Users must have HackRF One and its drivers/software installed, and possess a valid binary data payload suitable for the protocol. Inputs are CLI arguments and a message file; output is the RF transmission.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/f-machine.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nhackrf_transfer -f 314965000 -x 30 -s 2000000 -t ./data.bin\n```\n\n----------------------------------------\n\nTITLE: Specifying Read/Notify (Rx) Characteristic UUID for Possible Kiss - Plain Text\nDESCRIPTION: Lists the UUID (\"0000cb62-0000-1000-8000-00805f9b34fb\") of the BLE characteristic designated for reading and notifications (Rx) from the Possible Kiss device. This UUID is used to receive device data such as battery status and pressure readings.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/possible_kiss.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n0000cb62-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: Visualizing StopScanning Message Flow - Mermaid - sequenceDiagram\nDESCRIPTION: Depicts the extended sequence of messages for a scan session lifecycle, including StartScanning, DeviceAdded events, a StopScanning request, and their respective responses. Useful for understanding the full progression from starting to finishing a device enumeration session. Uses Mermaid syntax for sequence diagram rendering; intended for documentation and protocol comprehension.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: StartScanning Id=1\\n    Server->>-Client: Ok Id=1\\n    Server->>Client: DeviceAdded Id=0\\n    Server->>Client: DeviceAdded Id=0\\n    Client->>+Server: StopScanning Id=2\\n    Server->>-Client: Ok Id=2\\n    Server->>Client: ScanningFinished Id=0\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Deprecated DeviceAdded (Spec V1)\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow for the deprecated `DeviceAdded` message (Spec V1). The server sends this message asynchronously to the client when a new device is detected. This version is deprecated and superseded by Spec V3.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n    Server->>Client: DeviceAdded Id=0\n```\n\n----------------------------------------\n\nTITLE: Defining Command/Firmware Characteristic UUID for Kiiroo Onyx 2 (plaintext)\nDESCRIPTION: This snippet provides the UUID needed for sending commands or updating firmware on the Kiiroo Onyx 2. Integrating applications should use this identifier for control operations. The correct UUID is required for low-level device management and firmware upgrades.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-2.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nc7b7a04b-2cc4-40ff-8b10-5d531d1161db\n```\n\n----------------------------------------\n\nTITLE: Specifying Onyx 1 Device Path for Local Interaction\nDESCRIPTION: Shows the expected device path for the Kiiroo Onyx 1 (connected via Bluetooth 2.0) on POSIX systems (like Linux or macOS). This path is referenced in the context of setting up direct local interaction with a Pearl 1 using the 'cat' command.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n/dev/tty.ONYX-DevB\n```\n\n----------------------------------------\n\nTITLE: Defining Bluetooth Service and Characteristics UUIDs - Mysteryvibe Crescendo - Plaintext\nDESCRIPTION: This set of code snippets lists the Bluetooth Low Energy (BLE) UUIDs for the main service ('Main Service ID'), as well as key characteristics used to control the Mysteryvibe Crescendo vibrator. Each UUID uniquely identifies a BLE service or characteristic for applications that need to read from or write to device features using GATT operations. There are no additional dependencies, as these are universally formatted BLE UUID strings conforming to the standard 128-bit format excerpted from device firmware documentation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/mysteryvibe.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nf0006900-110c-478b-b74b-6f403b364a9c\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nf0006901-110c-478b-b74b-6f403b364a9c\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nf0006902-110c-478b-b74b-6f403b364a9c\n```\n\nLANGUAGE: plaintext\nCODE:\n```\nf0006903-110c-478b-b74b-6f403b364a9c\n```\n\n----------------------------------------\n\nTITLE: Issuing Pattern Selection and Motor Control Packets - Mysteryvibe Crescendo - Plaintext\nDESCRIPTION: These snippets demonstrate the byte structure for controlling the onboard pattern index and real-time motor speeds of the Crescendo device. For the Control Characteristic, the command shows the position of the onboard pattern index; for the Motor Control Characteristic, each byte represents the speed level for one of the six motors. Usage requires writing these six-byte arrays to the appropriate characteristic, with expected int values ranging from 0 to 56 for motor speed. These packets must be resent frequently to maintain motor state, as there is no known sustain command.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/mysteryvibe.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n0x0a 0xWW 0x?? 0x?? 0x?? 0x??\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n0xAA 0xBB 0xCC 0xDD 0xEE 0xFF\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n0x38 0x38 0x38 0x38 0x38 0x38\n```\n\n----------------------------------------\n\nTITLE: Acknowledgement and Error Responses (ET-232 Protocol, Plaintext)\nDESCRIPTION: These two snippets respectively show the expected acknowledgement from the ET-232 after a valid command (newline character) and the error string returned for unrecognized or incorrectly checksummed commands ('?\\r\\n'). They clarify how to program a serial client to recognize command success/failure. Ensure your parser handles these ASCII character responses at the end of each command transaction.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et232.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n\\n\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n?\\r\\n\n```\n\n----------------------------------------\n\nTITLE: Serialization Example for Deprecated RequestServerInfo (Spec V0)\nDESCRIPTION: JSON example demonstrating the serialization format for the deprecated `RequestServerInfo` message (Spec V0). It contains the message ID and the client's name. This version is superseded by Spec V1.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"RequestServerInfo\": {\n      \"Id\": 1,\n      \"ClientName\": \"Test Client\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Controlling Petrainer Shock Collar via RFCat in Python\nDESCRIPTION: This Python script utilizes the `rflib` and `bitstring` libraries to interact with a Petrainer shock collar using an RFCat dongle over the 433MHz frequency band. It includes functions for encoding raw bit commands into the required PWM format (`_raw_to_pwm`), configuring the RFCat device (`configure_rfcat`), transmitting the encoded messages (`tx_raw`), and specifically sending a 'zap' (shock) command with a given intensity (`zap`). A `ShockCollar` class simplifies usage by encapsulating the device initialization and providing a `shock` method that accepts intensity as a float between 0 and 1. The script requires Python 3, `rflib`, `bitstring`, and compatible RF hardware like RFCat or YardStickOne.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/petrainer.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n\"\"\"\nModule for connecting to a Petrainer Shock Collar and sending commands\n\nThis module implements a framework to send On-Off-Key-encoded messages\nover radio using an rfcat dongle, and a class that controls the collar's shock function.\n\nCredit to XMPPWocky (https://twitter.com/xmppwocky) for the proof of concept control code.\nIt was modified by definite_purple to work with python3.\nAlthough she was not able to test it, because she doesn't have the hardware.\n\nrflib can be obtained here: https://bitbucket.org/eviljonny/rflib\nbitstring over pypi or here: https://github.com/scott-griffiths/bitstring\n\"\"\"\n\n\nimport bitstring\nimport rflib\n# import binascii\n\nMHZ = 1000*1000\n\n_COLLAR_BAUD_PWM = 4200  # The baud of the rc\n_COLLAR_BAUD = _COLLAR_BAUD_PWM/4  # message bits get encoded to 4 radio bits\n_COLLAR_FREQ = 434*MHZ\n\n\ndef _pwm_to_raw(pwm):\n    \"\"\"decodes messages received from the control unit\"\"\"\n    raw = bitstring.BitStream()\n    while True:\n        try:\n            nybble = pwm.read(4)\n            if nybble.bin == \"1110\":\n                raw += bitstring.Bits(\"0b1\")\n            elif nybble.bin == \"1000\":\n                raw += bitstring.Bits(\"0b0\")\n            elif nybble.bin == \"0000\":\n                pass  # radio silence. No info\n            else:\n                print(nybble)\n                print(nybble.bin)\n                raise ValueError(\"bad nybble\")\n\n        except bitstring.ReadError:\n            break\n\n    return raw\n\n\ndef _raw_to_pwm(raw):\n    \"\"\"encodes messages in preparation to sending them to the collar\"\"\"\n    pwm = bitstring.BitStream()\n    for bit in raw.bin:\n        if bit == \"0\":\n            pwm += bitstring.Bits(\"0b1000\")\n        else:\n            pwm += bitstring.Bits(\"0b1110\")\n\n    return pwm\n\n\ndef configure_rfcat(d):\n    \"\"\"configures the rfcat dongle to the collar's language\"\"\"\n    d.setFreq(_COLLAR_FREQ)\n    d.setMdmModulation(rflib.MOD_ASK_OOK)\n    d.setMdmDRate(_COLLAR_BAUD_PWM)\n\n\ndef tx_raw(d, raw, repeat=8):\n    \"\"\"encodes message, precedes pulse, pads with silcence, sends 8x\n\n    adds 00000000000000011111 in front of the encoded part\n    (silence, then a pulse)\n    and  000000000000000000000000 behind it.\n    (silence)\n\n    I don't know exactly why the signal goes high for five pwm-bits\n    before each transmission.\n    It is likely there to allow the receiver to set its gain.\"\"\"\n    pwm = _raw_to_pwm(raw)\n    tosend = bitstring.BitString(bytes=b\"\\x00\\x01\\xf0\", length=(20)) \\\n        + pwm + bitstring.Bits(bytes=b\"\\x00\\x00\\x00\")\n    # print(tosend.hex)\n    d.RFxmit(tosend.tobytes(), repeat=repeat)\n\n\ndef zap(d, intensity):\n    \"\"\"modifies a template with the shock intesity, and proceeds to transmit\"\"\"\n    assert intensity <= 100\n    assert intensity >= 0\n\n    template = bitstring.BitString(\n        bin=\"010000001101110100101011100101000011111100\")\n    template[25:32] = bitstring.Bits(uint=intensity, length=7)\n    tx_raw(d, template)\n\n\nclass ShockCollar:\n    \"\"\"class for the shock collar\"\"\"\n    def __init__(self):\n        d = rflib.RfCat()\n        configure_rfcat(d)\n        self.d = d\n\n    def shock(self, intensity=1.0):\n        \"\"\"accepts a number 0 <= intensity <= 1 and sends the shock command\"\"\"\n        intensity_int = int(intensity*100.0)\n\n        zap(self.d, intensity_int)\n\n```\n\n----------------------------------------\n\nTITLE: RawCmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 RawCmd message. This message allows sending raw byte commands to a specified device, intended primarily for development.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"RawCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Command\": [0, 2, 4]\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: SingleMotorVibrateCmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram showing the message exchange for the deprecated Spec V0 SingleMotorVibrateCmd. The client sends the command to vibrate a device at a certain speed, and the server responds with an Ok message.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_14\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>+Server: SingleMotorVibrateCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: Serialization Example for Deprecated DeviceList (Spec V1)\nDESCRIPTION: JSON example demonstrating the serialization format for the deprecated `DeviceList` message (Spec V1). It includes device details and uses a dictionary for `DeviceMessages`, where keys are message types and values are objects containing message attributes like `FeatureCount`. Superseded by Spec V3.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"DeviceList\": {\n      \"Id\": 1,\n      \"Devices\": [\n        {\n          \"DeviceName\": \"TestDevice 1\",\n          \"DeviceIndex\": 0,\n          \"DeviceMessages\": {\n            \"VibrateCmd\": { \"FeatureCount\": 2 },\n            \"StopDeviceCmd\": {}\n          }\n        },\n        {\n          \"DeviceName\": \"TestDevice 2\",\n          \"DeviceIndex\": 1,\n          \"DeviceMessages\": {\n            \"LinearCmd\": { \"FeatureCount\": 1 },\n            \"StopDeviceCmd\": {}\n          }\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Vorze SA Series Packet Structure Example – Markdown / Plaintext\nDESCRIPTION: Illustrates the generic structure of a single communication packet to be sent to the Vorze SA Series device. The format is a three-byte sequence, detailing how each byte is used for the device identifier, a reserved byte, and speed/direction encoding. This format is essential for developers implementing low-level communication drivers.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n0x0X 0x01 0xZZ\n```\n\n----------------------------------------\n\nTITLE: Cyclone SA Clockwise at 50% Speed Packet – Markdown / Plaintext\nDESCRIPTION: Presents a specific packet sequence used to spin the Vorze Cyclone SA device clockwise at half speed. The first byte (0x01) identifies the device, the second byte (0x01) is reserved, and the last byte (0x32) sets clockwise rotation at 50% (hex 0x32 = 50 decimal). This example is an exact packet that should be transmitted over BLE or serial connection.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\n0x01 0x01 0x32\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Deprecated DeviceList (Spec V1)\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow for the deprecated `DeviceList` message (Spec V1). Similar to V0, the client requests the list, and the server responds. This version is deprecated as it was superseded by Spec V3, which adds more detail like display names and timing info.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: RequestDeviceList Id=1\n    Server->>-Client: DeviceList Id=1\n```\n\n----------------------------------------\n\nTITLE: Defining the TrainingCollar Class for Device Communication in C++\nDESCRIPTION: Declares the `TrainingCollar` C++ class, intended for managing communication with a training collar device. It defines nested structs (`TCMessage`, `TCMessageTimings`, `TCMessageWithTimings`) to hold message data and timing information critical for radio transmission. The class interface includes a constructor taking the radio pin, methods for building messages (`build`), printing debug information (`printTCMessage`, `printTCMessageTimings`), calculating transmission timings (`calculateTimings`), and sending the message (`transmit`). Private members store timing constants, the radio pin, and helper methods for constructing individual parts of the message.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/petroom.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n/*\n *          Bits  Description\n * START    1     Start\n * CHANNEL  4     The channel (A or B on the remote, but reciever seems to accept all values 0-15).\n * MODE     4     4 bits, 1 for each mode. You can't mix modes, it will just pick the leftmost bit to use. \n * SERIAL   16    Remote serial number. Unique to each remote, presumably to stop you interering with other users.\n * LEVEL    8     Max 100, anything over 100 seems to be at the same strength as 100.\n *                Light / Audio - No change, Vibration / Shock - Controls intensity.\n * CHECKSUM 8     Channel (4 bits) and Mode (4 bits) to make 8 bits, which are then reverse ordered and inverted.\n * END      1     End\n * --------------------\n *          42\n */\n\nclass TrainingCollar {\n  public:\n\n    typedef struct {\n      byte start;// : 1; //1\n      byte channel;// : 4; //5\n      byte mode;// : 4; //9\n      unsigned int serial;// : 16; //25\n      byte level;// : 8; //33\n      byte checksum;// : 8; //41\n      byte end;// : 1; //42\n    } TCMessage;\n\n    typedef struct {\n      int timings[TC_MESSAGE_BITS_TOTAL * TC_TIMINGS_PER_BIT];\n    } TCMessageTimings;\n\n    typedef struct {\n      TCMessage message;\n      TCMessageTimings messageTimings;\n    } TCMessageWithTimings;\n\n    TrainingCollar(int radioPin);\n    TrainingCollar::TCMessageWithTimings TrainingCollar::build(byte channel, unsigned int serial, byte mode, byte level);\n    void build(const TCMessageWithTimings *x, byte channel, unsigned int serial, byte mode, byte level);\n    void printTCMessage(TCMessage *x);\n    void printTCMessageTimings(TCMessageTimings *y);\n    void calculateTimings(TCMessageWithTimings *xy);\n    void transmit(TCMessageWithTimings *y);\n  private:\n    const int _timingsStart[2] = {1456, 780};\n    const int _timingsEnd[2] = {208, 10428};\n    const int _timingsBitOn[TC_TIMINGS_PER_BIT] = {741, 247}; //{708, 280};\n    const int _timingsBitOff[TC_TIMINGS_PER_BIT] = {247, 741}; // {208, 780};\n\n    int _radioPin;\n\n    //void insertBits(bool input_array[], int output_array[], int _inputSize, int offset);\n    //void insertRawTimings(bool bits[], int timings[], int _size, int offset);\n    \n    void buildStart(TCMessage*);\n    void buildChannel(TCMessage*, byte channel);\n    void buildMode(TCMessage*, byte mode);\n    void buildSerial(TCMessage*, unsigned int serial);\n    void buildLevel(TCMessage*, byte level);\n    void buildChecksum(TCMessage*);\n    void buildEnd(TCMessage*);\n\n    void _printByte(byte);\n};\n\n#endif\n```\n\n----------------------------------------\n\nTITLE: Defining Momentary Command Structure for Sportdog SD-400 Protocol (Text)\nDESCRIPTION: Describes the 43-bit format (172 ms duration) for momentary commands (e.g., nick) sent by the Sportdog FT-100 remote. The format consists of a fixed prefix ('1 1111 0001'), a 16-bit remote ID, an 8-bit command type, an 8-bit command argument, and a fixed suffix ('10'). Symbols '0' (0 Hz, 4ms) and '1' (5 kHz mod, 4ms) represent specific FSK modulations.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/sportdog-sd400.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nFormat:\\n  1 1111 0001 [16-bit remote ID] [8-bit command type] [8-bit command arg] 10\n```\n\n----------------------------------------\n\nTITLE: Defining Continuous Command Structure for Sportdog SD-400 Protocol (Text)\nDESCRIPTION: Outlines the structure for continuous commands (e.g., continuous stimulation, tone) sent by the Sportdog FT-100 remote. It includes a starting sequence similar to momentary commands but ending in '102', a repeating sequence for the duration the button is held (prefixed by '0001'), and an ending sequence. The '2' symbol (5 kHz mod, 2ms) demarcates repeats, while '0' (0 Hz, 4ms) and '1' (5 kHz mod, 4ms) are data symbols.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/sportdog-sd400.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nStart:\\n  1 1111 0001 [16-bit remote ID] [8-bit command type] [8-bit command arg] 102\\nRepeated N times:\\n         0001 [16-bit remote ID] [8-bit command type] [8-bit command arg] 102\\nEnd:\\n         0001 [16-bit remote ID] [8-bit command type] [8-bit command arg] 1021111111111\n```\n\n----------------------------------------\n\nTITLE: Modeling Sensor Unsubscribe Command Workflow - Mermaid\nDESCRIPTION: This Mermaid sequence diagram visualizes the workflow for unsubscribing from a sensor stream using the SensorUnsubscribeCmd in the Buttplug.io protocol. The client sends an unsubscribe command, and the server acknowledges with an Ok response, signaling successful termination of the stream. No further sensor readings are sent. The diagram serves as a reference for implementing or documenting the unsubscription interaction.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/sensors.md#_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: SensorUnsubscribeCmd Id=1\\n    Server->>-Client: Ok Id=1\\n\n```\n\n----------------------------------------\n\nTITLE: Defining Kiiroo Device Communication Protocol Format\nDESCRIPTION: Illustrates the command format used to communicate with Kiiroo Onyx 1 and Pearl 1 devices. It consists of an integer (x, ranging from 0 to 4) followed by a comma and a newline character ('\\n'). This command sets the pressure ring position on the Onyx or the vibration level on the Pearl.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nx,\\n\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Deprecated DeviceList (Spec V0)\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow for the deprecated `DeviceList` message (Spec V0). The client sends a `RequestDeviceList` message, and the server replies with the `DeviceList` message. This version is deprecated as it was superseded by Spec V1, which provides more detail about device features.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: RequestDeviceList Id=1\n    Server->>-Client: DeviceList Id=1\n```\n\n----------------------------------------\n\nTITLE: Kiiroo Bluetooth LE Transmit (TX) Characteristic UUID\nDESCRIPTION: Defines the Characteristic UUID used for transmitting data (notifications/sensor readings) *from* the Kiiroo device when communicating via Bluetooth Low Energy (BLE). Applications subscribe to notifications on this characteristic to receive data.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n49535343-8841-43f4-a8d4-ecbe34729bb3\n```\n\n----------------------------------------\n\nTITLE: LovenseCmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram illustrating the message flow for the deprecated Spec V0 LovenseCmd. The client sends a Lovense-specific command string, and the server responds with an Ok message.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_20\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>Server: LovenseCmd Id=1\n    Server->>Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: Example VirtualRealPlayer Configuration File (INI)\nDESCRIPTION: This INI file demonstrates the structure of a VirtualRealPlayer configuration file (`.txt`). It includes sections for default player settings (`[Player]`), user-modified settings (`[User]`), video metadata (`[VideoInfo]`), Lovense Max control commands (`[Lovense]`), and Kiiroo Onyx control commands (`[Kiiroo]`). Timestamps and intensity/vibration values control the devices.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/video-encoding-formats/virtualrealplayer.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n[Player]\nzoom=0\nvert_rot=11.5\nh_offset=0\n\n[User]\nh_offset=-5.279996\nzoom=1.73999894\ny_pos=0.6\n\n[VideoInfo]\nversion=2\nname=Video name\n\n[Lovense]\nhombre_trailer=-1.0/05-2.5/04-5.0/05\nhombre=-3.0/05-4.5/04-6.0/05\n\n[Kiiroo]\nonyx=1.00,4;2.50,0;6.00,4\n```\n\n----------------------------------------\n\nTITLE: Listing BLE Device Name Values - Markdown\nDESCRIPTION: This snippet lists the advertised BLE device name for BKK hardware using a markdown code block. The device name allows identification of the BKK Cup when scanning for available Bluetooth devices. No dependencies or parameters are required; this is reference data for implementers.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/bkk.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\nBKK Cup\n```\n```\n\n----------------------------------------\n\nTITLE: VorzeA10CycloneCmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram representing the communication sequence for the deprecated Spec V0 VorzeA10CycloneCmd. The client sends speed and direction, and the server confirms.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_22\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>Server: VorzeA10CycloneCmd Id=1\n    Server->>Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: Example T-code Command with Speed-Based Ramping\nDESCRIPTION: Illustrates a T-code command using speed-based ramping. 'L020S10' commands linear channel 0 to ramp to magnitude 0.2 at a speed of 0.1 per second (10 per hundred milliseconds). The channel maintains the target level after the ramp completes.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_5\n\nLANGUAGE: tcode\nCODE:\n```\nL020S10\n```\n\n----------------------------------------\n\nTITLE: LovenseCmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 LovenseCmd message. This message contains a string command intended for Lovense devices, which was never implemented in reference libraries.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_21\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"LovenseCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Command\": \"Vibrate:20;\"\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Test Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram showing the flow for the deprecated Spec V0 Test message. The client sends a Test message with a string, and the server echoes the same message back, unless the string is 'Error'.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_24\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>+Server: Test Id=5 TestString=X\n    Server->>-Client: Test Id=5 TestString=X\n```\n```\n\n----------------------------------------\n\nTITLE: Specifying Command (Tx) Characteristic UUID for Possible Kiss - Plain Text\nDESCRIPTION: Defines the UUID (\"0000cb61-0000-1000-8000-00805f9b34fb\") for the BLE characteristic used to transmit (Tx) commands to the Possible Kiss device. Communication with this characteristic controls device actions.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/possible_kiss.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n0000cb61-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: ServerInfo Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 ServerInfo message. This message is sent from the server to the client, containing server details like name, version, and ping time expectations.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_11\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"ServerInfo\": {\n      \"Id\": 1,\n      \"ServerName\": \"Test Server\",\n      \"MajorVersion\": 1,\n      \"MinorVersion\": 0,\n      \"BuildVersion\": 0,\n      \"MessageVersion\": 1,\n      \"MaxPingTime\": 100\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Identifying Prettylove BLE Service UUID\nDESCRIPTION: This UUID identifies the primary Bluetooth Low Energy service exposed by Prettylove devices. Applications need to connect to this service to interact with the device's characteristics.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n0000ffe5-0000-1000-8000-00805f9b34fb\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Level for Buttplug with Shell Environment\nDESCRIPTION: This shell snippet demonstrates setting the RUST_LOG environment variable to configure log filtering levels when running Rust-based Buttplug applications. By specifying the desired log level (e.g., debug), users control the verbosity of log output. This command should be run in the shell prior to launching the application. Input is the program to execute; output is the shell configuring the environment for the program to use.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/writing-buttplug-applications/logging.mdx#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nRUST_LOG=\"debug\" ./[your_program_here]\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Service UUID – Markdown / Plaintext\nDESCRIPTION: Specifies the Bluetooth LE service UUID assigned to Vorze SA Series devices for hardware discovery and pairing. This value is required to establish BLE communication and should be used by any BLE client intending to control or identify the supported toys. The UUID is presented in standard 128-bit format with all hexadecimal digits, and no programming language syntax.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n40ee1111-63ec-4b7f-8ce7-712efd55b90e\n```\n\n----------------------------------------\n\nTITLE: Sending 'Write Byte' Command (ET-232 Protocol, Plaintext)\nDESCRIPTION: This snippet demonstrates how to construct a 'Write Byte' command ('I') to store a value at a specific address on the ET-232. It includes the command code, address, value, checksum, and '\\r' terminator, all in ASCII hex. This command, when successful, results in a '$\\n' confirmation response. Proper serial communication setup and checksum computation are prerequisites. Invalid commands or bad checksums will yield an error response; double-check formatting for correctness.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et232.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nI801012\\r\n```\n\n----------------------------------------\n\nTITLE: Serializing RSSILevelCmd Message (JSON)\nDESCRIPTION: This JSON snippet shows the serialization format for an `RSSILevelCmd` message. It includes the message `Id` (1) for tracking the request and the `DeviceIndex` (0) specifying the target device. This command requests the device's current wireless signal strength (RSSI) and expects an `RSSILevelReading` message in response.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_37\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"RSSILevelCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Illustrating RawSubscribeCmd and streaming flow with sequence diagram (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram shows the command/response cycle for RawSubscribeCmd, including the Ok acknowledgment and a stream of RawReading messages being sent to the client. Helps clarify protocol behavior for subscription-based device endpoints such as BLE notifications.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_5\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: RawSubscribeCmd Id=1\\n    Server->>-Client: Ok Id=1\\n    Server->>+Client: RawReading Id=0\\n    Server->>+Client: RawReading Id=0\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing VibrateCmd Message (JSON)\nDESCRIPTION: This JSON snippet provides an example of a serialized `VibrateCmd` message. It specifies the message `Id` (1), the target `DeviceIndex` (0), and an array of `Speeds`. Each object within the `Speeds` array targets a specific vibrator `Index` (0 and 1 in this example) with a corresponding `Speed` (0.5 and 1.0 respectively), where speed is a double value between 0.0 and 1.0.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_31\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"VibrateCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Speeds\": [\n        {\n          \"Index\": 0,\n          \"Speed\": 0.5\n        },\n        {\n          \"Index\": 1,\n          \"Speed\": 1.0\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing BatteryLevelCmd Message (JSON)\nDESCRIPTION: This JSON snippet shows the serialization format for a `BatteryLevelCmd` message. It contains the message `Id` (1), uniquely identifying the request, and the `DeviceIndex` (0), specifying which connected device's battery level is being queried. This command expects a `BatteryLevelReading` message in response.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_33\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"BatteryLevelCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing RawWriteCmd request (JSON)\nDESCRIPTION: Demonstrates a canonical JSON serialization structure for the RawWriteCmd, including all required fields such as Id, DeviceIndex, Endpoint, Data, and WriteWithResponse. Requires adherence to the Buttplug device specification. This format is used for communication between client and server when issuing a raw write command.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/raw.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\\n  {\\n    \\\"RawWriteCmd\\\": {\\n      \\\"Id\\\": 1,\\n      \\\"DeviceIndex\\\": 0,\\n      \\\"Endpoint\\\": \\\"tx\\\",\\n      \\\"Data\\\": [0, 1, 0],\\n      \\\"WriteWithResponse\\\": false\\n    }\\n  }\\n]\\n\n```\n\n----------------------------------------\n\nTITLE: Serializing RotateCmd Message in JSON\nDESCRIPTION: Provides a JSON example for serializing a RotateCmd message. It contains the 'Id', 'DeviceIndex', and a 'Rotations' array. Each rotation object specifies the motor 'Index', the rotation 'Speed' (0.0-1.0), and the direction ('Clockwise' boolean).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"RotateCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Rotations\": [\n        {\n          \"Index\": 0,\n          \"Speed\": 0.5,\n          \"Clockwise\": true\n        },\n        {\n          \"Index\": 1,\n          \"Speed\": 1.0,\n          \"Clockwise\": false\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Serializing Log Message (JSON)\nDESCRIPTION: This JSON snippet illustrates the serialization format for a `Log` message sent from the server to the client, typically after a `RequestLog` command has been successfully processed. It includes the message `Id` (usually 0 for server-initiated messages not directly responding to a specific request), the `LogLevel` (e.g., \"Trace\"), and the `LogMessage` string containing the log information.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_29\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"Log\": {\n      \"Id\": 0,\n      \"LogLevel\": \"Trace\",\n      \"LogMessage\": \"This is a Log Message.\"\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Illustrating VibrateCmd Message Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram shows the basic interaction for a `VibrateCmd`. The client sends a `VibrateCmd` message (Id=1) to the server, instructing a specific device to activate its vibration motor(s) at certain speed(s). The server responds with an `Ok` message (Id=1) to confirm successful receipt and processing of the command.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_30\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: VibrateCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Serialization Example for Deprecated DeviceAdded (Spec V0)\nDESCRIPTION: JSON example demonstrating the serialization format for the deprecated `DeviceAdded` message (Spec V0). This message informs the client about a newly added device, including its name, index, and an array of supported message type strings. Superseded by Spec V1.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"DeviceAdded\": {\n      \"Id\": 0,\n      \"DeviceName\": \"TestDevice 1\",\n      \"DeviceIndex\": 0,\n      \"DeviceMessages\": [\"SingleMotorVibrateCmd\", \"RawCmd\", \"KiirooCmd\", \"StopDeviceCmd\"]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Error Response Exchange with Invalid Message (Mermaid)\nDESCRIPTION: This Mermaid snippet displays how a server responds with an Error when a client sends a message with an invalid name. It’s intended to visually clarify error handling in the message protocol. Only a Mermaid sequence diagram renderer is required.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/status.md#_snippet_2\n\nLANGUAGE: Mermaid\nCODE:\n```\nsequenceDiagram\\n    Client->>+Server: InvalidMsgName Id=2\\n    Server->>-Client: Error Id=2\n```\n\n----------------------------------------\n\nTITLE: Illustrating LinearCmd Flow with Mermaid\nDESCRIPTION: This Mermaid sequence diagram depicts the communication flow for the LinearCmd message. The client sends the command detailing linear movements and includes a message ID. The server confirms with an Ok message using the same ID.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/generic.md#_snippet_6\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: LinearCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Serializing DeviceRemoved Message in JSON\nDESCRIPTION: A JSON example representing an array containing a single `DeviceRemoved` message object. The message specifies the `Id` (set to 0, indicating a server-sent message) and the `DeviceIndex` (set to 0 in this example) of the device being removed, conforming to the Buttplug protocol specification.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_13\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"DeviceRemoved\": {\n      \"Id\": 0,\n      \"DeviceIndex\": 0\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: FleshlightLaunchFW12Cmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 FleshlightLaunchFW12Cmd message. It specifies the target position and speed (both 0-99) for a Fleshlight Launch device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_19\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"FleshlightLaunchFW12Cmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Position\": 95,\n      \"Speed\": 90\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Visualizing DeviceAdded Event - Mermaid - sequenceDiagram\nDESCRIPTION: Displays the minimal sequence in which the server notifies the client of a newly added device, independent of scanning. Useful for understanding device hotplug flows and server-to-client event initiation. Relies on Mermaid for rendering.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/enumeration.md#_snippet_10\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\\n    participant Client\\n    participant Server\\n    Server->>Client: DeviceAdded Id=0\n```\n\n----------------------------------------\n\nTITLE: Linking Kiiroo Pearl 1 to Onyx 1 Locally (POSIX)\nDESCRIPTION: Demonstrates a POSIX shell command using 'cat' to directly pipe the output (touch sensor data formatted according to the Kiiroo protocol) from a Bluetooth 2.0 connected Kiiroo Pearl 1 device to a connected Kiiroo Onyx 1 device. This enables local control without external software or servers. Requires both devices to be paired and accessible via the specified TTY paths.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\ncat /dev/tty.PEARL-DevB > /dev/tty.ONYX-DevB\n```\n\n----------------------------------------\n\nTITLE: Defining WSDM Handshake Data Format (JSON)\nDESCRIPTION: This JSON structure defines the format of the initial handshake message a device must send as text when connecting to the Websocket Device Manager (WSDM) server. The `identifier` maps the device to a specific device identifier within a protocol (e.g., 'Z' for Lovense Hush), `address` is an arbitrary unique string identifying the device across sessions, and `version` specifies the WSDM protocol version being used (currently 0). This packet must be the first message sent over the websocket connection; subsequent communication uses binary format.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/inflating-buttplug/devices/websocket-device-manager.mdx#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"identifier\": \"\",\n  \"address\": \"\",\n  \"version\": 0\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Training Collar Message Structure Constants in C++\nDESCRIPTION: Defines constant byte arrays in C++ specifying the start positions (`TC_START_POS`) and lengths (`TC_LENGTHS`) for different segments within a training collar message protocol (Start, Channel, Mode, Serial, Level, Checksum, End). It also defines a lookup array (`TC_MODE_LOOKUP`) mapping symbolic mode names to their corresponding byte values. These constants are likely used by the `TrainingCollar` class to correctly assemble and interpret message data.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/petroom.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nconst byte TC_START_POS[TC_MESSAGE_PARTS] = {TC_MESSAGE_START_START, TC_MESSAGE_CHANNEL_START, TC_MESSAGE_MODE_START, TC_MESSAGE_SERIAL_START, TC_MESSAGE_LEVEL_START, TC_MESSAGE_CHECKSUM_START, TC_MESSAGE_END_START};\nconst byte TC_LENGTHS[TC_MESSAGE_PARTS] = {TC_MESSAGE_START_LENGTH, TC_MESSAGE_CHANNEL_LENGTH, TC_MESSAGE_MODE_LENGTH, TC_MESSAGE_SERIAL_LENGTH, TC_MESSAGE_LEVEL_LENGTH, TC_MESSAGE_CHECKSUM_LENGTH, TC_MESSAGE_END_LENGTH};\nconst byte TC_MODE_LOOKUP[TC_MODES] = {TC_MODE_LIGHT_VALUE, TC_MODE_AUDIO_VALUE, TC_MODE_VIBRATION_VALUE, TC_MODE_SHOCK_VALUE};\n```\n\n----------------------------------------\n\nTITLE: Sending 'Read Byte' Command (ET-232 Protocol, Plaintext)\nDESCRIPTION: This snippet demonstrates how to construct and send a 'Read Byte' command ('H') to the ET-232 to read a single byte from a specified address. It includes the command identifier, address in hex, calculated checksum as two ASCII hex characters, and '\\r' terminator. Dependencies include access to a properly configured serial port. The command reads data from the target memory address and expects a two-digit ASCII hex value in response; ensure correct checksum calculation based on the specified algorithm.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/erostek-et232.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nH80B0\\r\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Deprecated DeviceAdded (Spec V0)\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow for the deprecated `DeviceAdded` message (Spec V0). The server sends this message asynchronously to the client when a new device is detected. This version is deprecated and superseded by Spec V1.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_2\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    participant Client\n    participant Server\n    Server->>Client: DeviceAdded Id=0\n```\n\n----------------------------------------\n\nTITLE: Running Programmed Pattern Command (Lovense Protocol)\nDESCRIPTION: Command sent to a Lovense device (Lush, Hush, Ambi, Domi, Edge, Osci) to start running a pre-programmed pattern on a loop. The integer following the colon (e.g., '8') specifies the pattern index. Sending 'Preset:0;' stops the currently running pattern. Note: Lush 2 may only support indices 0-4.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/lovense.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nPreset:8;\n```\n\n----------------------------------------\n\nTITLE: Serialization Example for Deprecated DeviceAdded (Spec V1)\nDESCRIPTION: JSON example demonstrating the serialization format for the deprecated `DeviceAdded` message (Spec V1). It includes device details and uses a dictionary for `DeviceMessages` with attributes like `FeatureCount`. Superseded by Spec V3.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"DeviceAdded\": {\n      \"Id\": 0,\n      \"DeviceName\": \"TestDevice 1\",\n      \"DeviceIndex\": 0,\n      \"DeviceMessages\": {\n        \"VibrateCmd\": { \"FeatureCount\": 2 },\n        \"StopDeviceCmd\": {}\n      }\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: SingleMotorVibrateCmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 SingleMotorVibrateCmd message. It specifies the device index and the vibration speed (0.0 to 1.0).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_15\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"SingleMotorVibrateCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Speed\": 0.5\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: RawCmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram illustrating the communication flow for sending a deprecated Spec V0 RawCmd message from the client to the server. The client sends the RawCmd, and the server typically responds with an Ok message upon success.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_12\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>+Server: RawCmd Id=1\n    Server->>-Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: Test Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 Test message. This message is intended for development and testing, allowing a client to send a string and receive it back from the server.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_25\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"Test\": {\n      \"Id\": 5,\n      \"TestString\": \"Moo\"\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple T-code Commands Simultaneously\nDESCRIPTION: Explains how to send commands for multiple channels concurrently. Commands are separated by a space character (' '). All buffered commands are executed simultaneously upon receiving a newline character ('\\n'). Sending a new command for the same channel before the newline overwrites the previous buffered command for that channel.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/tcode.md#_snippet_6\n\nLANGUAGE: plaintext\nCODE:\n```\n(Example: L050 R175 V090\\n)\n```\n\n----------------------------------------\n\nTITLE: KiirooCmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram showing the message sequence for the deprecated Spec V0 KiirooCmd. The client sends a Kiiroo-specific command string, and the server acknowledges with an Ok message.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_16\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>Server: KiirooCmd Id=1\n    Server->>Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: Illustrating RSSILevelReading Context Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram shows the context for sending an `RSSILevelReading` message. It occurs after a client sends an `RSSILevelCmd` (Id=1, DeviceIndex=0). The server then responds with the `RSSILevelReading` message (Id=1, DeviceIndex=0, RSSILevel=-40) containing the signal strength information for the specified device, matching the request's Id.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_38\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>Server: RSSILevelCmd Id=1 DeviceIndex=0\n    Server->>Client: RSSILevelReading Id=1 DeviceIndex=0 RSSILevel=-40\n```\n\n----------------------------------------\n\nTITLE: Sending Mode Commands for Device Initialization and Real Time Control - Mysteryvibe Crescendo - Plaintext\nDESCRIPTION: These examples show the byte-level command sequences required for initializing the Crescendo vibrator, transitioning to real-time control mode, and interpreting the mode characteristic structure. Each example lists the hexadecimal byte sequence to be written to the Mode Control Characteristic UUID, and provides contextual explanations of mode bytes (status flag, mode setting, memory offset). The inputs are raw byte arrays for BLE Write operations and the outputs are determined by device state transitions. Applicable directly to Bluetooth LE programming using raw WriteCharacteristic commands.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/mysteryvibe.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n0xXX 0x0Y 0xZZ\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n0x48 0x01 0x00\n```\n\nLANGUAGE: plaintext\nCODE:\n```\n0x43 0x02 0x00\n```\n\n----------------------------------------\n\nTITLE: Ignored Over-Speed Packet Example – Markdown / Plaintext\nDESCRIPTION: Shows a packet where the speed byte exceeds the device's maximum supported value (over 100). This demonstrates a protocol limitation: packets specifying speeds greater than 100 decimal will be ignored, leaving the device state unchanged. Useful for implementers to validate bounds checking in their applications.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_5\n\nLANGUAGE: plaintext\nCODE:\n```\n0x02 0x01 0xef\n```\n\n----------------------------------------\n\nTITLE: Example Button Status Notification Array from Bluetooth LE - Plaintext\nDESCRIPTION: This snippet demonstrates the typical 14-byte array returned by the Status Notification Characteristic to indicate capacitive button sensor values on the Fleshlight Launch. Each pair of bytes forms a big-endian 16-bit integer for one of seven buttons. This array should be parsed to determine which pads are pressed based on value thresholds. The array is used in BLE notification payloads.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/fleshlight-launch.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n[0x03, 0xCC, 0x03, 0x5A, 0x03, 0xA3, 0x03, 0xF4, 0x03, 0xAF, 0x03, 0x67, 0x03, 0xCF]\n```\n\n----------------------------------------\n\nTITLE: Viewing Programmed Pattern Response Example (Lush 2)\nDESCRIPTION: Example response from a Lovense Lush 2 device when pattern 4 is requested using 'GetPatten:4;'. The response ('P4') uses two-digit padding for the part count and index (e.g., '01/01'). The sequence of digits represents the vibration pattern, with each digit indicating the level (0-9) for a half-second interval.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/lovense.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\nP4:01/01:346797643;\n```\n\n----------------------------------------\n\nTITLE: Defining Prettylove Control Characteristic Write Format\nDESCRIPTION: Commands sent to the Control characteristic (0000ffe9-...) use this 2-byte format. Typically, AA is fixed at 0x00, while BB determines the specific action, such as setting vibration patterns or controlling electro-shock features based on the product.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/prettylove.md#_snippet_5\n\nLANGUAGE: hexadecimal\nCODE:\n```\n0xAA 0xBB\n```\n\n----------------------------------------\n\nTITLE: Sending Device Initialization Command via Bluetooth LE - Plaintext\nDESCRIPTION: This plaintext snippet shows the command data (0x00) to be sent to the Fleshlight Launch's Bluetooth Command Characteristic on bootup, transitioning the device to user mode for operation. The command is a single byte with no dependencies. The input is the byte 0x00; no output is expected beyond device state change. This must be sent to the command UUID on initialization.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/fleshlight-launch.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n0x00\n```\n\n----------------------------------------\n\nTITLE: UFO SA Counterclockwise at 100% Speed Packet – Markdown / Plaintext\nDESCRIPTION: Demonstrates the packet required for spinning the UFO SA device counterclockwise at maximum speed. The first byte (0x02) is the device selector for UFO SA, the reserved byte (0x01), and the final byte (0xe4) encodes direction and full speed. This sequence must be written to the appropriate BLE characteristic or transmitted over serial.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_4\n\nLANGUAGE: plaintext\nCODE:\n```\n0x02 0x01 0xe4\n```\n\n----------------------------------------\n\nTITLE: Kiiroo Bluetooth LE Receive (RX) Characteristic UUID\nDESCRIPTION: Defines the Characteristic UUID used for receiving data (commands) sent *to* the Kiiroo device when communicating via Bluetooth Low Energy (BLE). Applications write commands to this characteristic.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-onyx-pearl-1.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n49535343-1e4d-4bd9-ba61-23c647249616\n```\n\n----------------------------------------\n\nTITLE: Identifying We-Vibe Control Characteristic UUID\nDESCRIPTION: Specifies the Bluetooth Low Energy (BLE) Characteristic Universally Unique Identifier (UUID) used to send control commands to We-Vibe devices via its main service.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/wevibe.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nf000c000-0451-4000-b000-000000000000\n```\n\n----------------------------------------\n\nTITLE: Specifying BLE Button Service UUID - Markdown\nDESCRIPTION: This snippet provides the UUID of the button BLE service for BKK devices, shown as a markdown code block. Integrators use this UUID to subscribe to notifications pertaining to button interactions. This is reference data and does not require input parameters.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/bkk.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0000ffe0-0000-1000-8000-00805f9b34fb\n```\n```\n\n----------------------------------------\n\nTITLE: Defining BLE Write Data Characteristic UUID – Markdown / Plaintext\nDESCRIPTION: Provides the Bluetooth LE characteristic UUID used for write operations on Vorze SA Series devices. Clients must use this UUID when sending control data to the hardware. The value is a standard 128-bit UUID string with no language-specific decoration.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/vorze-sa.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n40ee2222-63ec-4b7f-8ce7-712efd55b90e\n```\n\n----------------------------------------\n\nTITLE: Illustrating BatteryLevelReading Context Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram shows the context in which a `BatteryLevelReading` message is sent. It is a direct response to a client's `BatteryLevelCmd` request (Id=1, DeviceIndex=0). The server sends the `BatteryLevelReading` message back to the client, providing the battery level (0.5) for the specified device, and matching the request's Id.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_34\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>Server: BatteryLevelCmd Id=1 DeviceIndex=0\n    Server->>Client: BatteryLevelReading Id=1 DeviceIndex=0 BatteryLevel=0.5\n```\n\n----------------------------------------\n\nTITLE: Illustrating RequestLog Message Flow (Mermaid)\nDESCRIPTION: This Mermaid sequence diagram shows the interaction for a `RequestLog` message. The client sends a `RequestLog` message (with Id=1) to the server, and the server responds with an `Ok` message (with the same Id) to confirm the request was successful. This initiates the server sending log messages if the requested LogLevel was not 'Off'.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_26\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>+Server: RequestLog Id=1\n    Server->>-Client: Ok Id=1\n```\n\n----------------------------------------\n\nTITLE: Starting Local Docusaurus Development Server with Yarn - Shell\nDESCRIPTION: Launches a local development server for the Docusaurus site using Yarn's 'start' script. This enables hot-reloading; all source file changes appear live in the browser without a server restart. Requires all dependencies to be installed and assumes the existence of a suitable 'start' script in package.json. Output is a locally hosted preview at a specified port (usually http://localhost:3000).\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Website with SSH Using Yarn - Shell\nDESCRIPTION: Deploys the static site using SSH for authentication by setting 'USE_SSH=true' and running the 'deploy' script with Yarn. Prerequisites: Prior build, SSH credentials configured, and relevant deploy script in package.json. Pushes the built files to the remote repository, usually targeting a branch like gh-pages.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Sending Bootloader Command Bytes Over Bluetooth - Markdown\nDESCRIPTION: This markdown code block illustrates the general structure of commands sent to the Kiiroo device's bootloader via Bluetooth. Each command is composed of two bytes: a command index (sent to the CTL characteristic) and command-specific data (sent to the DATA characteristic). No code dependencies exist, as this is a protocol representation, not executable code. The primary inputs are the two command bytes; after sending, the CTL value must be read to determine success (0x02) or failure, and DATA is read only if data feedback is expected. This is a documentation snippet, so there are no run-time constraints.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/kiiroo-bootloader.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n    0xGG -> CTL\n    0xHH -> DATA\n```\n\n----------------------------------------\n\nTITLE: Firmware Version 6-Byte Return Format - Markdown\nDESCRIPTION: This snippet illustrates an example 6-byte return payload received when querying the firmware version from a Kiiroo device. The last two bytes represent the major and minor version numbers respectively. No executable requirements exist; this table simply documents the precise byte format developers should expect.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/firmware/kiiroo.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n```\n0xXX 0xXX 0xXX 0xXX 0x01 0x03\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C# Code Example Format\nDESCRIPTION: This C# snippet demonstrates the format used for code examples throughout the Buttplug Developer Guide. It shows a simple variable assignment using 'var', illustrating how C# code will be presented within the documentation's tabbed interface.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/intro/how-to-read.mdx#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n// This is some C#\nvar a = 1 + 2;\n```\n\n----------------------------------------\n\nTITLE: Describing RF Bit Encoding Protocol - Protocol Documentation - plaintext\nDESCRIPTION: This snippet visually documents the waveform and encoding details for bits '0', '1', and 'F' in the F-machine's RF communication protocol. It uses ASCII waveform diagrams to illustrate the timing and signal structure, which is essential for developers or engineers attempting to replicate or decode the bit transmission at the electrical level. No dependencies are required, as this is documentation rather than executable code.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/protocols/f-machine.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n            __        __\\nBit '0' : _|  |______|  |______\\n            ______    ______\\nBit '1' : _|      |__|      |__\\n            __        ______\\nBit 'F' : _|  |______|      |__\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Javascript Code Example Format\nDESCRIPTION: This Javascript snippet demonstrates the format used for code examples throughout the Buttplug Developer Guide. It shows a simple variable assignment and includes a comment explaining that Javascript examples often suffice for Typescript as well due to the nature of the WASM implementation. It illustrates how Javascript/Typescript code will be presented.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/intro/how-to-read.mdx#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\n// For most of the examples in this guide, Javascript and Typescript will look mostly the\n// same (we don't use Typescript specific features in our WASM implementation), therefore we only\n// include javascript examples. Typescript typings files are distributed with the library, so you\n// should still get type completions in your IDE.\n\n// This is some Javascript\nlet a = 1 + 2;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Rust Code Example Format\nDESCRIPTION: This Rust snippet demonstrates the format used for code examples throughout the Buttplug Developer Guide. It shows a simple variable assignment, illustrating how Rust code will be presented within the documentation's tabbed interface.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/dev-guide/intro/how-to-read.mdx#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// This is some Rust\nlet a = 1 + 2;\n```\n\n----------------------------------------\n\nTITLE: Flow Diagram for Deprecated RequestServerInfo (Spec V0)\nDESCRIPTION: Mermaid sequence diagram illustrating the message flow for the deprecated `RequestServerInfo` message (Spec V0). The client sends this message to identify itself and request server details, and the server responds with `ServerInfo`. Superseded by Spec V1 which added message version checking.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_8\n\nLANGUAGE: mermaid\nCODE:\n```\nsequenceDiagram\n    Client->>Server: RequestServerInfo Id=0\n    Server->>Client: ServerInfo Id=0\n```\n\n----------------------------------------\n\nTITLE: ServerInfo Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram showing the sequence of messages exchanged between client and server for obtaining Server Information using the deprecated Spec V0 ServerInfo message. The client sends RequestServerInfo, and the server replies with ServerInfo.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_10\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>Server: RequestServerInfo Id=0\n    Server->>Client: ServerInfo Id=0\n```\n```\n\n----------------------------------------\n\nTITLE: FleshlightLaunchFW12Cmd Message Flow Diagram (Mermaid)\nDESCRIPTION: Diagram depicting the communication for the deprecated Spec V0 FleshlightLaunchFW12Cmd. The client sends position and speed parameters, and the server confirms with an Ok message.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_18\n\nLANGUAGE: mermaid\nCODE:\n```\n```mermaid\nsequenceDiagram\n    Client->>Server: FleshlightLaunchFW12Cmd Id=1\n    Server->>Client: Ok Id=1\n```\n```\n\n----------------------------------------\n\nTITLE: VorzeA10CycloneCmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 VorzeA10CycloneCmd message. It specifies the rotation speed (0-100) and direction (Clockwise boolean) for a Vorze A10 Cyclone device.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_23\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"VorzeA10CycloneCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Speed\": 50,\n      \"Clockwise\": true\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: KiirooCmd Message Serialization Example (JSON)\nDESCRIPTION: Example JSON serialization for the deprecated Spec V0 KiirooCmd message. This message carries a string command intended for Kiiroo devices, typically representing position or speed.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_17\n\nLANGUAGE: json\nCODE:\n```\n```json\n[\n  {\n    \"KiirooCmd\": {\n      \"Id\": 1,\n      \"DeviceIndex\": 0,\n      \"Command\": \"4\"\n    }\n  }\n]\n```\n```\n\n----------------------------------------\n\nTITLE: Serialization Example for Deprecated DeviceList (Spec V0)\nDESCRIPTION: JSON example demonstrating the serialization format for the deprecated `DeviceList` message (Spec V0). It shows a list of devices, each containing its name, index, and an array of supported message type strings. This format is superseded by Spec V1.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/spec/deprecated.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n  {\n    \"DeviceList\": {\n      \"Id\": 1,\n      \"Devices\": [\n        {\n          \"DeviceName\": \"TestDevice 1\",\n          \"DeviceIndex\": 0,\n          \"DeviceMessages\": [\"SingleMotorVibrateCmd\", \"RawCmd\", \"KiirooCmd\", \"StopDeviceCmd\"]\n        },\n        {\n          \"DeviceName\": \"TestDevice 2\",\n          \"DeviceIndex\": 1,\n          \"DeviceMessages\": [\"SingleMotorVibrateCmd\", \"LovenseCmd\", \"StopDeviceCmd\"]\n        }\n      ]\n    }\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Specifying JavaScript Format for Kiiroo Interaction\nDESCRIPTION: This section indicates that JavaScript is the designated format or language for interacting with Kiiroo devices. No specific code is provided, but it establishes the language context for Kiiroo device implementation.\nSOURCE: https://github.com/buttplugio/docs.buttplug.io/blob/master/docs/stpihkal/video-encoding-formats/kiiroo.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n* Format: JavaScript\n```"
  }
]