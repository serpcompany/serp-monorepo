[
  {
    "owner": "op-engineering",
    "repo": "op-sqlite",
    "content": "TITLE: Opening a Database Connection in JavaScript\nDESCRIPTION: Demonstrates how to open a connection to an SQLite database using the op-sqlite library. It's recommended to open only one connection per app session for optimal performance.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\n\nexport const db = open({\n  name: 'myDb.sqlite',\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Basic SQL Queries in TypeScript\nDESCRIPTION: Illustrates how to execute a basic SQL query using the op-sqlite library. The execute method runs on native C++ threads to avoid blocking the JS/UI thread.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\n\ntry {\n  const db = open({ name: 'myDb.sqlite' });\n\n  let { rows } = await db.execute('SELECT somevalue FROM sometable');\n\n  rows.forEach((row) => {\n    console.log(row);\n  });\n} catch (e) {\n  console.error('Something went wrong executing SQL commands:', e.message);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Transactions in TypeScript\nDESCRIPTION: Illustrates how to use transactions for executing multiple SQL commands atomically. Any error thrown inside the transaction body will cause a rollback.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nawait db.transaction((tx) => {\n  const { status } = await tx.execute(\n    'UPDATE sometable SET somecolumn = ? where somekey = ?',\n    [0, 1]\n  );\n\n  // Any uncatched error ROLLBACK transaction\n  throw new Error('Random Error!');\n\n  // You can manually commit or rollback\n  await tx.commit();\n  // or\n  await tx.rollback();\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Queries with Host Objects in TypeScript\nDESCRIPTION: Demonstrates how to use the executeWithHostObjects method to return HostObjects, which are beneficial when dealing with massive amounts of data but only accessing a few objects at a time.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nlet res = await db.executeWithHostObjects('select * from USERS');\n```\n\n----------------------------------------\n\nTITLE: Using Prepared Statements in TypeScript\nDESCRIPTION: Shows how to use prepared statements for optimizing query execution, especially for queries that are executed multiple times with different parameters.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst statement = db.prepareStatement('SELECT * FROM User WHERE name = ?;');\n\n// bind the variables in the order they appear\nawait statement.bind(['Oscar']);\nlet results1 = await statement.execute();\n\nawait statement.bind(['Carlos']);\nlet results2 = await statement.execute();\n```\n\n----------------------------------------\n\nTITLE: Opening an Encrypted SQLite Database with SQLCipher\nDESCRIPTION: Shows how to open an encrypted SQLite database using SQLCipher. This method requires an additional encryption key parameter for database encryption and decryption.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\n\nexport const db = open({\n  name: 'myDb.sqlite',\n  encryptionKey: 'YOUR ENCRYPTION KEY, KEEP IT SOMEWHERE SAFE', // for example op-s2\n});\n```\n\n----------------------------------------\n\nTITLE: Executing Batch Commands in TypeScript\nDESCRIPTION: Shows how to execute a batch of SQL commands in a single call. The entire batch is wrapped in a transaction for atomic execution.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nconst commands = [\n  ['CREATE TABLE TEST (id integer)'],\n  ['INSERT INTO TEST (id) VALUES (?)', [1]],\n  [('INSERT INTO TEST (id) VALUES (?)', [2])],\n  [('INSERT INTO TEST (id) VALUES (?)', [[3], [4], [5], [6]])],\n];\n\nconst res = await db.executeBatch(commands);\n\nconsole.log(`Batch affected ${result.rowsAffected} rows`);\n```\n\n----------------------------------------\n\nTITLE: Executing Multiple SQL Statements in TypeScript\nDESCRIPTION: Shows how to execute multiple SQL statements in a single operation, noting that the results may be mangled and this is not supported in libsql.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\n// The result of this query will all be all mixed, no point in trying to read it\nlet res = await db.execute(\n  `CREATE TABLE T1 (id INT PRIMARY KEY) STRICT;\n  CREATE TABLE T2 (id INT PRIMARY KEY) STRICT;`\n);\n```\n\n----------------------------------------\n\nTITLE: Loading SQL Dump Files in TypeScript\nDESCRIPTION: Demonstrates how to load large SQL dump files or restore database backups efficiently using the loadFile method.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\nconst { rowsAffected, commands } = await db.loadFile(\n  '/absolute/path/to/file.sql'\n);\n```\n\n----------------------------------------\n\nTITLE: Attaching and Detaching Databases in TypeScript\nDESCRIPTION: Shows how to attach and detach other database files to the main database connection, allowing operations across multiple databases.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\ndb.attach('mainDatabase', 'statistics', 'stats', '../databases');\n\nconst res = await db.execute(\n  'SELECT * FROM some_table_from_mainschema a INNER JOIN stats.some_table b on a.id_column = b.id_column'\n);\n\n// You can detach databases at any moment\ndb.detach('mainDatabase', 'stats');\nif (!detachResult.status) {\n  // Database de-attached\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Blob Data in TypeScript\nDESCRIPTION: Demonstrates how to work with blob data using ArrayBuffer or typed arrays in op-sqlite. This example shows inserting and retrieving blob data.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\ndb = open({\n  name: 'blobs',\n});\n\nawait db.execute('DROP TABLE IF EXISTS BlobTable;');\nawait db.execute(\n  'CREATE TABLE BlobTable ( id INT PRIMARY KEY, name TEXT NOT NULL, content BLOB) STRICT;'\n);\n\nlet binaryData = new Uint8Array(2);\nbinaryData[0] = 42;\n\nawait db.execute(`INSERT OR REPLACE INTO BlobTable VALUES (?, ?, ?);`, [\n  1,\n  'myTestBlob',\n  binaryData,\n]);\n\nconst result = await db.execute('SELECT content FROM BlobTable');\n\nconst finalUint8 = new Uint8Array(result.rows[0].content);\n```\n\n----------------------------------------\n\nTITLE: Executing Synchronous Queries in JavaScript\nDESCRIPTION: Demonstrates the use of executeSync for synchronous query execution. This should be used sparingly as it blocks the UI thread.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_7\n\nLANGUAGE: jsx\nCODE:\n```\nlet res = db.executeSync('SELECT 1');\n```\n\n----------------------------------------\n\nTITLE: Using Database Hooks in TypeScript\nDESCRIPTION: Illustrates how to use update, commit, and rollback hooks to subscribe to database changes and transaction events.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\ndb.updateHook(({ rowId, table, operation }) => {\n  console.warn(`Hook has been called, rowId: ${rowId}, ${table}, ${operation}`);\n  const changes = await db.execute('SELECT * FROM User WHERE rowid = ?', [\n    rowid,\n  ]);\n});\n\nawait db.execute(\n  'INSERT INTO User (id, name, age, networth) VALUES(?, ?, ?, ?)',\n  [id, name, age, networth]\n);\n\n// will fire whenever a transaction commits\ndb.commitHook(() => {\n  console.log('Transaction commmitted!');\n});\n\ndb.rollbackHook(() => {\n  console.log('Transaction rolled back!');\n});\n\n// will fire the commit hook\ndb.transaction(async (tx) => {\n  tx.execute(\n    'INSERT INTO \"User\" (id, name, age, networth) VALUES(?, ?, ?, ?)',\n    [id, name, age, networth]\n  );\n});\n\n// will fire the rollback hook\ntry {\n  await db.transaction(async (tx) => {\n    throw new Error('Test Error');\n  });\n} catch (e) {\n  // intentionally left blank\n}\n\ndb.updateHook(null);\n\ndb.commitHook(null);\n\ndb.rollbackHook(null);\n```\n\n----------------------------------------\n\nTITLE: Getting Database File Path in TypeScript\nDESCRIPTION: Shows how to retrieve the file location of the database on disk, which can be useful for debugging or attaching to bug tickets.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nconst path = db.getDbPath();\n```\n\n----------------------------------------\n\nTITLE: Moving SQLite Database from Assets\nDESCRIPTION: Demonstrates how to move a SQLite database from app bundle assets to documents folder. Important for preserving database changes across app updates.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_15\n\nLANGUAGE: tsx\nCODE:\n```\nconst copied = await moveAssetsDatabase({\n  filename: 'sample2.sqlite',\n  path: 'sqlite', // The path inside your assets folder on Android, on iOS the file structure is flat\n  overwrite: true, // Always overwrite the database\n});\n\nexpect(copied).to.equal(true);\n```\n\n----------------------------------------\n\nTITLE: JSONB Operations in SQLite\nDESCRIPTION: Shows how to perform JSONB operations in SQLite including creating tables, inserting JSON data, and querying JSON fields.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_16\n\nLANGUAGE: jsx\nCODE:\n```\nawait db.execute('CREATE TABLE states(data TEXT);');\nawait db.execute(\n  `INSERT INTO states VALUES ('{\"country\":\"Luxembourg\",\"capital\":\"Luxembourg City\",\"languages\":[\"French\",\"German\",\"Luxembourgish\"]}');`\n);\nlet res = await db.execute(\n  `SELECT data->>'country' FROM states WHERE data->>'capital'=='Amsterdam';`\n);\nlet res2 = await db.execute(\n  `SELECT jsonb_extract(data, '$.languages') FROM states;`\n);\n```\n\n----------------------------------------\n\nTITLE: JSON Data Insertion Methods\nDESCRIPTION: Demonstrates different methods for inserting JSON data into SQLite, including string serialization and ArrayBuffer conversion.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_17\n\nLANGUAGE: jsx\nCODE:\n```\nlet states = // some JS object\n  await db.execute('INSERT INTO states VALUES (?)', [JSON.stringify(states)]);\n// or if using blobs\n\nfunction objectToArrayBuffer(obj) {\n  // Step 1: Serialize the object to a JSON string\n  const jsonString = JSON.stringify(obj);\n\n  // Step 2: Encode the string to UTF-8\n  const encoder = new TextEncoder();\n  const uint8Array = encoder.encode(jsonString);\n\n  // Step 3: Convert Uint8Array to ArrayBuffer\n  return uint8Array.buffer;\n}\n\nawait db.execute('INSERT INTO states VALUES (?)', [\n  objectToArrayBuffer(states),\n]);\n```\n\n----------------------------------------\n\nTITLE: Executing Raw SQL Queries in TypeScript\nDESCRIPTION: Demonstrates the use of executeRaw method for simplified query execution that returns an array of scalars, which can be faster for certain operations.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nlet result = await db.executeRaw('SELECT * FROM Users;');\n// result = [[123, 'Katie', ...]]\n```\n\n----------------------------------------\n\nTITLE: Configuring op-sqlite Features in package.json\nDESCRIPTION: Configuration options for customizing op-sqlite features including encryption, performance mode, and extensions.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"op-sqlite\": {\n    \"sqlcipher\": false\n    // \"crsqlite\": false,\n    // \"performanceMode\": true,\n    // \"iosSqlite\": false,\n    // \"sqliteFlags\": \"-DSQLITE_DQS=0\",\n    // \"fts5\": true,\n    // \"rtree\": true,\n    // \"libsql\": true,\n    // \"sqliteVec\": true,\n    // \"tokenizers\": [\"simple_tokenizer\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing op-sqlite via npm and pod\nDESCRIPTION: Basic installation commands for adding op-sqlite to a React Native project using npm and pod-install.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -s @op-engineering/op-sqlite\nnpx pod-install@latest\n```\n\n----------------------------------------\n\nTITLE: Installing op-sqlite in Expo\nDESCRIPTION: Commands for installing op-sqlite in an Expo project, requiring prebuild step.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpx expo install @op-engineering/op-sqlite\nnpx expo prebuild\n```\n\n----------------------------------------\n\nTITLE: Opening SQLite Database with Absolute Paths\nDESCRIPTION: Shows how to configure SQLite database using absolute paths with platform-specific directory constants.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  IOS_LIBRARY_PATH, // Default iOS\n  IOS_DOCUMENT_PATH,\n  ANDROID_DATABASE_PATH, // Default Android\n  ANDROID_FILES_PATH,\n  ANDROID_EXTERNAL_FILES_PATH, // Android SD Card\n  open,\n} from '@op-engineering/op-sqlite';\n\nconst db = open({\n  name: 'myDb',\n  location: Platform.OS === 'ios' ? IOS_LIBRARY_PATH : ANDROID_DATABASE_PATH,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Database with Relative Path in React Native\nDESCRIPTION: Demonstrates opening a SQLite database using a relative path location from the default directory.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\n\nconst db = open({\n  name: 'myDB',\n  location: '../files/databases',\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite with External Storage Path\nDESCRIPTION: Example of opening a SQLite database using external storage (SD card) on Android or library path on iOS.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst db = open({\n  name: 'myDB',\n  location:\n    Platform.OS === 'ios' ? IOS_LIBRARY_PATH : ANDROID_EXTERNAL_FILES_PATH,\n});\n```\n\n----------------------------------------\n\nTITLE: Opening SQLite Database with Custom Path\nDESCRIPTION: Demonstrates opening a SQLite database with a custom nested path structure.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst db = open({\n  name: 'myDB',\n  location:\n    Platform.OS === 'ios'\n      ? IOS_LIBRARY_PATH\n      : `${ANDROID_EXTERNAL_FILES_PATH}/dbs/`,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring In-Memory SQLite Database\nDESCRIPTION: Shows how to create an in-memory SQLite database for faster operations without disk I/O.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { open } from '@op-engineering/op-sqlite';\n\nconst largeDb = open({\n  name: 'inMemoryDb',\n  location: ':memory:',\n});\n```\n\n----------------------------------------\n\nTITLE: React Native Asset Configuration for SQLite\nDESCRIPTION: Configuration for including SQLite database files in React Native assets.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_5\n\nLANGUAGE: jsx\nCODE:\n```\nmodule.exports = {\n  assets: ['./assets/'],\n};\n```\n\n----------------------------------------\n\nTITLE: Loading SQLite Database from Assets\nDESCRIPTION: Example of moving and opening a SQLite database from the app's assets bundle.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { moveAssetsDatabase, open } from '@op-engineering/op-sqlite';\n\nconst openAssetsDb = async () => {\n  const moved = await moveAssetsDatabase({ filename: 'sample.sqlite' });\n  if (!moved) {\n    throw new Error('Could not move assets database');\n  }\n  const db = open({ name: 'sample.sqlite' });\n  const users = await db.execute('SELECT * FROM User');\n  console.log('users', users.rows);\n};\n```\n\n----------------------------------------\n\nTITLE: Downloading and Opening SQLite Database\nDESCRIPTION: Demonstrates downloading a SQLite database from a server and opening it with platform-specific paths.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport FetchBlob from 'react-native-fetch-blob';\nimport {\n  IOS_LIBRARY_PATH, // Default iOS\n  ANDROID_DATABASE_PATH, // Default Android\n} from '@op-engineering/op-sqlite';\n\n// Pseudo-code replace with the proper calls however you download the database\nasync function downloadAndMove() {\n  await FetchBlob.download(\n    `<download url>/sample.sqlite`,\n    Platform.OS === 'ios' ? IOS_LIBRARY_PATH : ANDROID_DATABASE_PATH\n  );\n}\n\nopenDb = () => {\n  const db = open({ name: 'sample.sqlite' });\n  const users = await db.execute('SELECT * FROM User');\n  console.log('users', users.rows?._array);\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Memory Mapping\nDESCRIPTION: Example of enabling SQLite memory mapping for improved performance with potential stability trade-offs.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nconst db = open({\n  name: 'mydb.sqlite',\n});\n\n// 0 turns off memory mapping, any other number enables it with the cache size\nawait db.execute('PRAGMA mmap_size=268435456');\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLite Journal Mode\nDESCRIPTION: Shows how to modify SQLite journaling settings for performance optimization with associated risks.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/configuration.md#2025-04-09_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nawait db.execute('PRAGMA journal_mode = MEMORY;'); // or OFF\n```\n\n----------------------------------------\n\nTITLE: Configuring LibSQL in package.json\nDESCRIPTION: Configuration settings to enable LibSQL support in OP-SQLite through package.json. Note that LibSQL cannot be used simultaneously with SQLCipher.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/Libsql/start.md#2025-04-09_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"op-sqlite\": {\n\t\"libsql\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to Remote LibSQL Database\nDESCRIPTION: Implementation of a remote database connection using LibSQL, requiring a URL and authentication token for connection to Turso databases.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/Libsql/start.md#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { openRemote } from '@op-engineering/op-sqlite';\n\nconst remoteDb = openRemote({\n  url: 'url',\n  authToken: 'token',\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Synchronized Local-Remote Database\nDESCRIPTION: Setup for a local database that synchronizes with a remote database, including configuration for sync interval and authentication.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/Libsql/start.md#2025-04-09_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { openSync } from '@op-engineering/op-sqlite';\n\nconst remoteDb = openSync({\n  name: 'myDb.sqlite',\n  url: 'url',\n  authToken: 'token',\n  syncInterval: 1, // Optional, in seconds\n});\n```\n\n----------------------------------------\n\nTITLE: Forcing Database Synchronization\nDESCRIPTION: Example of manually triggering synchronization between local and remote databases using the sync() method, available only for LibSQL databases.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/Libsql/start.md#2025-04-09_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nremoteDb.sync();\n```\n\n----------------------------------------\n\nTITLE: Using OP-SQLite Key-Value Storage API in TypeScript\nDESCRIPTION: Demonstrates how to initialize and use the Storage class from OP-SQLite for key-value operations. Shows both synchronous and asynchronous methods for setting and retrieving values, along with optional configuration for database location and encryption.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/key_value_storage.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Storage } from '@op-engineering/op-sqlite';\n\n// Storage is backed by it's own database\n// You can set the location like any other op-sqlite database\nconst storage = new Storage({\n  location: 'storage', // Optional, see location param on normal databases\n  encryptionKey: 'myEncryptionKey', // Optional, only used when used against SQLCipher\n});\n\nconst item = storage.getItemSync('foo');\n\nconst item2 = await storage.getItem('foo');\n\nawait storage.setItem('foo', 'bar');\n\nstorage.setItemSync('foo', 'bar');\n\nconst allKeys = storage.getAllKeys();\n\n// Clears the internal table\nstorage.clear();\n```\n\n----------------------------------------\n\nTITLE: Implementing Table-Level Reactive Query in op-sqlite with TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a reactive query that listens for changes to an entire table. It includes subscribing to changes, handling the callback, and unsubscribing. The example also shows how to trigger the reactive query using a transaction.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/reactive_queries.md#2025-04-09_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nlet unsubscribe = db.reactiveExecute({\n  query: 'SELECT * FROM Users',\n  fireOn: [\n    {\n      table: 'User',\n    },\n  ],\n  callback: (usersResponse) => {\n    console.log(usersReponse.rows); // should print the entire list of users\n    // You can pair this with your favourite state management\n    // If you would do this with a mobx store\n    runInAction(() => {\n      this.users = usersReponse.rows;\n    });\n  },\n});\n\n// If you later want to stop receiving updates or you eliminate the row you are watching\nunsubscribe();\n\n// To trigger the reactive query you need to execute a transaction. The query will be re-run\n// at the end of the transaction\nawait db.transaction(async () => {\n  await db.execute('...'); // Do a query that mutates the table\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Row-Level Reactive Query in op-sqlite with TypeScript\nDESCRIPTION: This snippet shows how to create a reactive query that listens for changes to a specific row in a table. It includes retrieving the rowid, setting up the reactive query, and handling the callback for row updates.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/reactive_queries.md#2025-04-09_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nlet rowid = db\n  .execute('SELECT rowid WHERE id = ? FROM Users', [123])\n  .item(0).rowid;\n\nlet unsubscribe = db.reactiveExecute({\n  query: 'SELECT * WHERE id = ? FROM Users',\n  arguments: ['123'],\n  fireOn: [\n    {\n      table: 'Users',\n      ids: [rowId],\n    },\n  ],\n  callback: (userResponse) => {\n    console.log(usersReponse.item(0)); // should print the user whenever it updates\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Reactive Query in op-sqlite with TypeScript and SQL\nDESCRIPTION: This snippet demonstrates how to set up a complex reactive query involving multiple tables and joins. It shows how to listen for changes in multiple tables and handle the results in the callback function.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/reactive_queries.md#2025-04-09_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nlet unsubscribe = db.reactiveExecute({\n  query: `SELECT \n    c.customer_id,\n    c.first_name,\n    c.last_name,\n    c.email,\n    COUNT(o.order_id) AS total_orders,\n    SUM(o.total_amount) AS total_spent\nFROM \n    customers c\nLEFT JOIN \n    orders o ON c.customer_id = o.customer_id\nGROUP BY \n    c.customer_id, c.first_name, c.last_name, c.email\nORDER BY \n    total_spent DESC;`,\n  arguments: [],\n  fireOn: [\n    {\n      table: 'customers',\n    },\n    {\n      table: 'orders',\n    },\n  ],\n  callback: (data: any) => {\n    // data = normal op-sqlite response\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing TypeORM Driver with OP-SQLite\nDESCRIPTION: Custom driver implementation for TypeORM integration with OP-SQLite. Provides database operations including opening connections, executing SQL queries, handling transactions, and managing database attachments/detachments. Includes error handling and encryption key validation.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/ORM_Libs.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { QueryResult, Transaction, open } from '@op-engineering/op-sqlite';\n\nconst enhanceQueryResult = (result: QueryResult): void => {\n  result.rows.item = (idx: number) => result.rows[idx];\n};\n\nexport const typeORMDriver = {\n  openDatabase: (\n    options: {\n      name: string;\n      location?: string;\n      encryptionKey: string;\n    },\n    ok: (db: any) => void,\n    fail: (msg: string) => void\n  ): any => {\n    try {\n      if (!options.encryptionKey || options.encryptionKey.length === 0) {\n        throw new Error('[op-sqlite]: Encryption key is required');\n      }\n\n      const database = open({\n        location: options.location,\n        name: options.name,\n        encryptionKey: options.encryptionKey,\n      });\n\n      const connection = {\n        executeSql: async (\n          sql: string,\n          params: any[] | undefined,\n          ok: (res: QueryResult) => void,\n          fail: (msg: string) => void\n        ) => {\n          try {\n            const response = await database.execute(sql, params);\n            enhanceQueryResult(response);\n            ok(response);\n          } catch (e) {\n            fail(`[op-sqlite]: Error executing SQL: ${e as string}`);\n          }\n        },\n        transaction: (\n          fn: (tx: Transaction) => Promise<void>\n        ): Promise<void> => {\n          return database.transaction(fn);\n        },\n        close: (ok: any, fail: any) => {\n          try {\n            database.close();\n            ok();\n          } catch (e) {\n            fail(`[op-sqlite]: Error closing db: ${e as string}`);\n          }\n        },\n        attach: (\n          dbNameToAttach: string,\n          alias: string,\n          location: string | undefined,\n          callback: () => void\n        ) => {\n          database.attach(options.name, dbNameToAttach, alias, location);\n\n          callback();\n        },\n        detach: (alias: string, callback: () => void) => {\n          database.detach(options.name, alias);\n\n          callback();\n        },\n      };\n\n      ok(connection);\n\n      return connection;\n    } catch (e) {\n      fail(`[op-sqlite]: Error opening database: ${e as string}`);\n    }\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Converting BigInt to String for SQLite Insert in TypeScript\nDESCRIPTION: Demonstrates how to insert a BigInt value into SQLite by converting it to a string, and how to retrieve and convert it back to BigInt when querying.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/gotchas.md#2025-04-09_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// When inserting, convert bigint into a string\nawait db.execute('INSERT INTO NumbersTable VALUES (?)', [\n  bigint('123').toString(),\n]);\n\n// When retrieving, convert string into bigint\nlet res = await db.execute('SELECT * FROM NumbersTable');\nlet myBigint = BigInt(res.rows[0].number);\n```\n\n----------------------------------------\n\nTITLE: Creating a Strict Table in SQLite using TypeScript\nDESCRIPTION: Shows how to create a table in SQLite with strict type checking enabled, ensuring true type safety for the declared columns.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/gotchas.md#2025-04-09_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.execute('CREATE TABLE Test (id INT PRIMARY KEY, name TEXT) STRICT;');\n```\n\n----------------------------------------\n\nTITLE: Enabling Foreign Key Constraints in SQLite using TypeScript\nDESCRIPTION: Demonstrates how to enable foreign key constraint checking in SQLite, which is necessary to catch foreign key errors.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/gotchas.md#2025-04-09_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nawait db.execute('PRAGMA foreign_keys = true');\n```\n\n----------------------------------------\n\nTITLE: Manipulating HostObjects in React Native with TypeScript\nDESCRIPTION: Illustrates the limitations and workarounds when working with HostObjects returned by op-sqlite's executeWithHostObjects API, including property assignment and object creation.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/gotchas.md#2025-04-09_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nlet results = await db.executeWithHostObjects('SELECT * FROM USER;');\nresults._array[0].newProp = 'myNewProp';\n\n// This won't work:\n// results._array[0].newProp = { foo: 'bar' };\n\n// Workaround:\nlet newUser = { ...{}, ...results._array[0], newProp: { foo: 'bar' } };\n```\n\n----------------------------------------\n\nTITLE: Retrieving Database File Path in OP SQLite with TypeScript\nDESCRIPTION: This code snippet demonstrates how to open an OP SQLite database, create a table, and retrieve the database file path. It also shows how to copy the path to the clipboard for easy access.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/debugging.md#2025-04-09_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst db = open({ name: 'dbPath.sqlite' });\nawait db.execute('CREATE TABLE test (id INTEGER PRIMARY KEY AUTOINCREMENT)');\nconst path = db.getDbPath();\nconsole.warn(path);\nClipboard.setString(path);\n```\n\n----------------------------------------\n\nTITLE: Configuring Tokenizers in package.json\nDESCRIPTION: Configuration in package.json to enable FTS5 and declare custom tokenizers for op-sqlite.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/tokenizers.md#2025-04-09_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n\"op-sqlite\": {\n\t// Leave whatever configuration you already have\n\t\"fts5\": true, // fts needs to be enabled\n\t\"tokenizers\": [\"word_tokenizer\"] // declare which tokenizers you will create\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Word Tokenizer in C++\nDESCRIPTION: Complete C++ implementation of a custom word tokenizer for op-sqlite, including tokenizer creation, deletion, and tokenization functions.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/tokenizers.md#2025-04-09_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n#include \"tokenizers.h\"\n#include <cctype>\n#include <memory>\n#include <string>\n\nnamespace opsqlite {\n\nfts5_api *fts5_api_from_db(sqlite3 *db) {\n  fts5_api *pRet = 0;\n  sqlite3_stmt *pStmt = 0;\n\n  if (SQLITE_OK == sqlite3_prepare_v2(db, \"SELECT fts5(?1)\", -1, &pStmt, 0)) {\n    sqlite3_bind_pointer(pStmt, 1, (void *)&pRet, \"fts5_api_ptr\", NULL);\n    sqlite3_step(pStmt);\n  }\n  sqlite3_finalize(pStmt);\n  return pRet;\n}\n\nclass WordTokenizer {\npublic:\n  WordTokenizer() = default;\n  ~WordTokenizer() = default;\n};\n\n// Define `xCreate`, which initializes the tokenizer\nint wordTokenizerCreate(void *pUnused, const char **azArg, int nArg,\n                        Fts5Tokenizer **ppOut) {\n  auto tokenizer = std::make_unique<WordTokenizer>();\n  *ppOut = reinterpret_cast<Fts5Tokenizer *>(\n      tokenizer.release()); // Cast to Fts5Tokenizer*\n  return SQLITE_OK;\n}\n\n// Define `xDelete`, which frees the tokenizer\nvoid wordTokenizerDelete(Fts5Tokenizer *pTokenizer) {\n  delete reinterpret_cast<WordTokenizer *>(pTokenizer);\n}\n\n// Define `xTokenize`, which performs the actual tokenization\nint wordTokenizerTokenize(Fts5Tokenizer *pTokenizer, void *pCtx, int flags,\n                          const char *pText, int nText,\n                          int (*xToken)(void *, int, const char *, int, int,\n                                        int)) {\n  int start = 0;\n  int i = 0;\n\n  while (i <= nText) {\n    if (i == nText || !std::isalnum(static_cast<unsigned char>(pText[i]))) {\n      if (start < i) { // Found a token\n        int rc = xToken(pCtx, 0, pText + start, i - start, start, i);\n        if (rc != SQLITE_OK)\n          return rc;\n      }\n      start = i + 1;\n    }\n    i++;\n  }\n  return SQLITE_OK;\n}\n\nint opsqlite_word_tokenizer_init(sqlite3 *db, char **error,\n                         sqlite3_api_routines const *api) {\n  fts5_tokenizer wordtokenizer = {wordTokenizerCreate, wordTokenizerDelete,\n                                  wordTokenizerTokenize};\n\n  fts5_api *ftsApi = (fts5_api *)fts5_api_from_db(db);\n  if (ftsApi == NULL)\n    return SQLITE_ERROR;\n\n  return ftsApi->xCreateTokenizer(ftsApi, \"word_tokenizer\", NULL,\n                                  &wordtokenizer, NULL);\n}\n\n} // namespace opsqlite\n```\n\n----------------------------------------\n\nTITLE: Using Custom Tokenizer with FTS5 in React Native\nDESCRIPTION: Example of how to use the custom tokenizer in a React component by creating an FTS5 virtual table and performing a search query.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/tokenizers.md#2025-04-09_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nlet db = open({\n  name: 'tokenizers.sqlite',\n  encryptionKey: 'test',\n});\n\n// inside your component or wherever you initialize your database\n// THIS IS SAMPLE CODE, use your head when creating your tables\nuseEffect(() => {\n  let setup = async () => {\n    await db.execute(\n      `CREATE VIRTUAL TABLE tokenizer_table USING fts5(content, tokenize = 'word_tokenizer');`\n    );\n\n    await db.execute('INSERT INTO tokenizer_table(content) VALUES (?)', [\n      'This is a test document',\n    ]);\n\n    const res = await db.execute(\n      'SELECT content FROM tokenizer_table WHERE content MATCH ?',\n      ['test']\n    );\n\n    console.warn(res);\n  };\n  setup();\n}, []);\n```\n\n----------------------------------------\n\nTITLE: Initializing OPSQLite CMake Project\nDESCRIPTION: Sets up the CMake project for OPSQLite, defining the minimum CMake version and project name.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nproject(OPSQLite)\ncmake_minimum_required(VERSION 3.9.0)\n\nset (PACKAGE_NAME \"op-sqlite\")\n```\n\n----------------------------------------\n\nTITLE: Configuring Include Directories and Definitions\nDESCRIPTION: Specifies include directories for the project and adds SQLite-specific definitions.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ninclude_directories(\n  ../cpp\n  ../cpp/sqlcipher\n  ../cpp/libsql\n)\n\nadd_definitions(\n  ${SQLITE_FLAGS}\n)\n```\n\n----------------------------------------\n\nTITLE: Defining OPSQLite Library Sources\nDESCRIPTION: Creates a shared library target for OPSQLite and specifies its source files.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_library(\n  ${PACKAGE_NAME}\n  SHARED\n  ../cpp/bindings.cpp\n  ../cpp/utils.cpp\n  ../cpp/OPThreadPool.cpp\n  ../cpp/SmartHostObject.cpp\n  ../cpp/PreparedStatementHostObject.cpp\n  ../cpp/DumbHostObject.cpp\n  ../cpp/DBHostObject.cpp\n  cpp-adapter.cpp\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring SQLCipher Support\nDESCRIPTION: Adds SQLCipher-specific source files and definitions when USE_SQLCIPHER is enabled.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nif (USE_SQLCIPHER)\n  target_sources(${PACKAGE_NAME} PRIVATE ../cpp/sqlcipher/sqlite3.h ../cpp/sqlcipher/sqlite3.c ../cpp/bridge.cpp ../cpp/bridge.h)\n\n  add_definitions(\n    -DOP_SQLITE_USE_SQLCIPHER=1\n    -DSQLITE_HAS_CODEC\n    -DSQLITE_TEMP_STORE=2\n  )\n  \n  find_package(openssl REQUIRED CONFIG)\nelseif (USE_LIBSQL)\n  target_sources(${PACKAGE_NAME} PRIVATE ../cpp/libsql/bridge.cpp)\n  \n  add_definitions(\n    -DOP_SQLITE_USE_LIBSQL=1\n  )\nelse()\n target_sources(${PACKAGE_NAME} PRIVATE ../cpp/sqlite3.h ../cpp/sqlite3.c ../cpp/bridge.cpp ../cpp/bridge.h)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Configuring Additional SQLite Features\nDESCRIPTION: Adds definitions for CRSQLite and SQLite Vector support if enabled.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nif (USE_CRSQLITE)\n  add_definitions(\n    -DOP_SQLITE_USE_CRSQLITE=1\n  )\nendif()\n\nif (USE_SQLITE_VEC)\n  add_definitions(\n    -DOP_SQLITE_USE_SQLITE_VEC=1\n  )\nendif()\n```\n\n----------------------------------------\n\nTITLE: Finding Required Packages and Libraries\nDESCRIPTION: Locates necessary packages and libraries for the project, including React Native, FBJNI, and system libraries.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nfind_package(ReactAndroid REQUIRED CONFIG)\nfind_package(fbjni REQUIRED CONFIG)\nfind_library(LOG_LIB log)\n```\n\n----------------------------------------\n\nTITLE: Handling User-Defined Source Files\nDESCRIPTION: Includes user-defined source files and tokenizer header path if specified.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nif (USER_DEFINED_SOURCE_FILES)\n  target_sources(${PACKAGE_NAME} PRIVATE ${USER_DEFINED_SOURCE_FILES})\n\n  add_definitions(\"-DTOKENIZERS_HEADER_PATH=\\\"${USER_DEFINED_TOKENIZERS_HEADER_PATH}\\\"\")\nendif()\n```\n\n----------------------------------------\n\nTITLE: Linking Libraries Based on SQLite Variant\nDESCRIPTION: Links appropriate libraries based on the SQLite variant (SQLCipher, libSQL, or standard) and React Native version.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/android/CMakeLists.txt#2025-04-09_snippet_7\n\nLANGUAGE: CMake\nCODE:\n```\nif (USE_SQLCIPHER)\n  if (ReactAndroid_VERSION_MINOR GREATER_EQUAL 76)\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      ReactAndroid::reactnative\n      ReactAndroid::jsi\n      fbjni::fbjni\n      openssl::crypto\n    )\n  else()\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      fbjni::fbjni\n      ReactAndroid::jsi\n      ReactAndroid::turbomodulejsijni\n      ReactAndroid::react_nativemodule_core\n      android\n      openssl::crypto\n    )\n  endif()\nelseif (USE_LIBSQL)\n  cmake_path(SET LIBSQL ${CMAKE_CURRENT_SOURCE_DIR}/jniLibs/${ANDROID_ABI}/libsql_experimental.a NORMALIZE)\n  add_library(libsql STATIC IMPORTED)\n  set_target_properties(libsql PROPERTIES IMPORTED_LOCATION ${LIBSQL})\n\n  if (ReactAndroid_VERSION_MINOR GREATER_EQUAL 76)\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      ReactAndroid::reactnative\n      ReactAndroid::jsi\n      fbjni::fbjni\n      libsql\n    )\n  else()\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      fbjni::fbjni\n      ReactAndroid::jsi\n      ReactAndroid::turbomodulejsijni\n      ReactAndroid::react_nativemodule_core\n      android\n      libsql\n    )\n  endif()\nelse ()\n  if (ReactAndroid_VERSION_MINOR GREATER_EQUAL 76)\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      ReactAndroid::reactnative\n      ReactAndroid::jsi\n      fbjni::fbjni\n    )\n  else()\n    target_link_libraries(\n      ${PACKAGE_NAME}\n      ${LOG_LIB}\n      fbjni::fbjni\n      ReactAndroid::jsi\n      ReactAndroid::turbomodulejsijni\n      ReactAndroid::react_nativemodule_core\n      android\n    )\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Compiling Libsql for iOS and Android\nDESCRIPTION: Commands to navigate to the libsql bindings/c directory and run make scripts to generate the iOS and Android binary files. This process creates the necessary platform-specific libraries that will be integrated into op-sqlite.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/Libsql/updating.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd libsql/bindings/c\nmake ios\nmake android\n```\n\n----------------------------------------\n\nTITLE: Static Library Compilation in Podfile\nDESCRIPTION: Ruby code for forcing static compilation of op-sqlite in iOS when using use_frameworks.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\npre_install do |installer|\n  installer.pod_targets.each do |pod|\n    if pod.name.eql?('op-sqlite')\n      def pod.build_type\n        Pod::BuildType.static_library\n      end\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Initializing op-sqlite with Expo Updates Workaround\nDESCRIPTION: Objective-C code modification in AppDelegate for using libsql with expo-updates.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_4\n\nLANGUAGE: objective-c\nCODE:\n```\n#import \"OPSQLite.h\" // Add the header\n\n-(BOOL)application: (UIApplication *)application didFinishLaunchingWithOptions: (NSDictionary *)launchOptions {\n  self moduleName = @\"main\";\n  self.initialProps = 0{};\n\n  // Add the call to the workaround\n  [OPSQLite expoUpdatesWorkaround];\n\n  return [super application:application didFinishLaunchingWithOptions:launchOptions];\n}\n```\n\n----------------------------------------\n\nTITLE: Conflict Resolution in Pod Installation\nDESCRIPTION: Ruby code for handling conflicts during pod installation by modifying pod configurations.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/installation.md#2025-04-09_snippet_5\n\nLANGUAGE: ruby\nCODE:\n```\npre_install do |installer|\n\tinstaller.pod_targets.each do |pod|\n\t\tif pod.name.eql?('expo-updates')\n\t\t\t# Modify the configuration of the pod so it doesn't depend on the sqlite pod\n\t\tend\n\tend\nend\n```\n\n----------------------------------------\n\nTITLE: Installing Docusaurus Website Dependencies\nDESCRIPTION: Installs all required node dependencies using Yarn package manager\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/README.md#2025-04-09_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn\n```\n\n----------------------------------------\n\nTITLE: Starting Docusaurus Development Server\nDESCRIPTION: Launches a local development server with hot-reload capabilities for real-time preview of changes\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/README.md#2025-04-09_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn start\n```\n\n----------------------------------------\n\nTITLE: Building Docusaurus Static Site\nDESCRIPTION: Generates optimized static files in the build directory ready for production deployment\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/README.md#2025-04-09_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn build\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Site Using SSH\nDESCRIPTION: Deploys the website using SSH authentication method\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/README.md#2025-04-09_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus Site Without SSH\nDESCRIPTION: Deploys the website using GitHub username authentication method\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/README.md#2025-04-09_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Extension Directory Structure\nDESCRIPTION: Shows the required directory structure for SQLite extensions on Android platform.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_18\n\nLANGUAGE: text\nCODE:\n```\n/android\n  /app\n    /src\n      /main\n        /jniLibs\n          /arm64-v8a\n            libcrsqlite.so\n          /armeabi-v7a\n            libcrsqlite.so\n          /x86\n            libcrsqlite.so\n          /x86_64\n            libcrsqlite.so\n```\n\n----------------------------------------\n\nTITLE: Loading SQLite Extensions\nDESCRIPTION: Shows how to load runtime extensions in SQLite for both iOS and Android platforms.\nSOURCE: https://github.com/OP-Engineering/op-sqlite/blob/main/docs/docs/api.md#2025-04-09_snippet_19\n\nLANGUAGE: tsx\nCODE:\n```\nimport {open, getDylibPath} from '@op-sqlite/op-engineering';\n\nconst db = open(...);\nlet path = \"libcrsqlite\" // in Android it will be the name of the .so\nif (Platform.os == \"ios\") {\n\tpath = getDylibPath(\"io.vlcn.crsqlite\", \"crsqlite\"); // You need to get the bundle name from the .framework/plist.info inside of the .xcframework you created and then the canonical name inside the same plist\n}\n// Extensions usually have a default entry point to be loaded, if the documentation says nothing, you should assume no entry point change\ndb.loadExtension(path);\n\n// Others might need a different entry point function, you can pass it as a second argument\ndb.loadExtension(path, \"entry_function_of_the_extension\");\n```"
  }
]