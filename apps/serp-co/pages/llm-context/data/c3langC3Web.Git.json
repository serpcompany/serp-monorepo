[
  {
    "owner": "c3lang",
    "repo": "c3-web.git",
    "content": "TITLE: Compiling and Running a C3 Program in One Step\nDESCRIPTION: Command that compiles and immediately runs a C3 program. The highlighted line shows the output of the Hello World program.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ c3c compile-run hello_world.c3\n> Program linked to executable 'hello_world'.\n> Launching hello_world...\n> Hello, World\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack Module in C3 with int and double\nDESCRIPTION: This code snippet shows how to use the generic stack module with different types (int and double) by creating aliases with specific types. It demonstrates pushing and popping elements from the stacks and printing the results.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nalias IntStack = Stack {int};\n\nfn void test()\n{\n    IntStack stack;\n    stack.push(1);\n    stack.push(2);\n    // Prints pop: 2\n    io::printfn(\"pop: %d\", stack.pop());\n    // Prints pop: 1\n    io::printfn(\"pop: %d\", stack.pop());\n\n    Stack {double} dstack;\n    dstack.push(2.3);\n    dstack.push(3.141);\n    dstack.push(1.1235);\n    // Prints pop: 1.1235\n    io::printfn(\"pop: %f\", dstack.pop());\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring C3 Project Settings in JSON5\nDESCRIPTION: Comprehensive example of a project.json file for C3, including language version, warnings, dependencies, authors, version, sources, targets, and various compilation options. This configuration file allows customization of build settings, optimization levels, and target-specific parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/project-config.md#2025-04-21_snippet_0\n\nLANGUAGE: json5\nCODE:\n```\n{\n  // Language version of C3.\n  \"langrev\": \"1\",\n  // Warnings used for all targets.\n  \"warnings\": [ \"no-unused\" ],\n  // Directories where C3 library files may be found.\n  \"dependency-search-paths\": [ \"lib\" ],\n  // Libraries to use for all targets.\n  \"dependencies\": [ ],\n  // Authors, optionally with email.\n  \"authors\": [ \"John Doe <john.doe@example.com>\" ],\n  // Version using semantic versioning.\n  \"version\": \"0.1.0\",\n  // Sources compiled for all targets.\n  \"sources\": [ \"src/**\" ],\n  // C sources if the project also compiles C sources\n  // relative to the project file.\n  // \"c-sources\": [ \"csource/**\" ],\n  // Include directories for C sources relative to the project file.\n  // \"c-include-dirs: [ \"csource/include\" ],\n  // Output location, relative to project file.\n  \"output\": \"../build\",\n  // Architecture and OS target.\n  // You can use 'c3c --list-targets' to list all valid targets,\n  // \"target\": \"windows-x64\",\n  // Current Target options:\n  //    android-aarch64 \n  //    elf-aarch64 elf-riscv32 elf-riscv64 elf-x86 elf-x64 elf-xtensa\n  //    mcu-x86 mingw-x64 netbsd-x86 netbsd-x64 openbsd-x86 openbsd-x64\n  //    freebsd-x86 freebsd-x64 ios-aarch64 \n  //    linux-aarch64 linux-riscv32 linux-riscv64 linux-x86 linux-x64 \n  //    macos-aarch64 macos-x64 \n  //    wasm32 wasm64 \n  //    windows-aarch64 windows-x64 \n  \"targets\": {\n    \"linux-x64\": {\n      // Executable or library.\n      \"type\": \"executable\",\n      // Additional libraries, sources\n      // and overrides of global settings here.\n    },\n  },\n  // Global settings.\n  // C compiler if the project also compiles C sources\n  // defaults to 'cc'.\n  \"cc\": \"cc\",\n  // CPU name, used for optimizations in the LLVM backend.\n  \"cpu\": \"generic\",\n  // Debug information, may be \"none\", \"full\" and \"line-tables\".\n  \"debug-info\": \"full\",\n  // FP math behaviour: \"strict\", \"relaxed\", \"fast\".\n  \"fp-math\": \"strict\",\n  // Link libc other default libraries.\n  \"link-libc\": true,\n  // Memory environment: \"normal\", \"small\", \"tiny\", \"none\".\n  \"memory-env\": \"normal\",\n  // Optimization: \"O0\", \"O1\", \"O2\", \"O3\", \"O4\", \"O5\", \"Os\", \"Oz\".\n  \"opt\": \"O0\",\n  // Code optimization level: \"none\", \"less\", \"more\", \"max\".\n  \"optlevel\": \"none\",\n  // Code size optimization: \"none\", \"small\", \"tiny\".\n  \"optsize\": \"none\",\n  // Relocation model: \"none\", \"pic\", \"PIC\", \"pie\", \"PIE\".\n  \"reloc\": \"none\",\n  // Trap on signed and unsigned integer wrapping for testing.\n  \"trap-on-wrap\": false,\n  // Turn safety (contracts, runtime bounds checking, null pointer checks etc).\n  \"safe\": true,\n  // Compile all modules together, enables more inlining.\n  \"single-module\": true,\n  // Use / don't use soft float, value is otherwise target default.\n  \"soft-float\": false,\n  // Strip unused code and globals from the output.\n  \"strip-unused\": true,\n  // The size of the symtab, which limits the amount\n  // of symbols that can be used. Should usually not be changed.\n  \"symtab\": 1048576,\n  // Use the system linker.\n  \"linker\": \"cc\",\n  // Include the standard library.\n  \"use-stdlib\": true,\n  // Set general level of x64 cpu: \"baseline\", \"ssse3\", \"sse4\", \"avx1\", \"avx2-v1\", \"avx2-v2\", \"avx512\", \"native\".\n  \"x86cpu\": \"native\",\n  // Set max type of vector use: \"none\", \"mmx\", \"sse\", \"avx\", \"avx512\", \"native\".\n  \"x86vec\": \"sse\",\n}\n```\n\n----------------------------------------\n\nTITLE: File Operations\nDESCRIPTION: File handling functions for input/output operations including file opening, reading, writing and stream manipulation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn CFile fopen(ZString filename, ZString mode) @weak @extern(\"fopen\") @nostrip\nfn int fclose(CFile) @weak @extern(\"fclose\") @nostrip\nfn usz fread(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(\"fread\") @nostrip\nfn usz fwrite(void* ptr, usz size, usz nmemb, CFile stream) @weak @extern(\"fwrite\") @nostrip\n```\n\n----------------------------------------\n\nTITLE: Building and Running a C3 Project\nDESCRIPTION: This command builds and runs the C3 project. It uses 'c3c run' to compile the project and execute the resulting binary.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nc3c run\n> Program linked to executable 'build/myc3project'.\n> Launching ./build/myc3project...\n> Hello, World\n```\n\n----------------------------------------\n\nTITLE: Basic Function Declaration in C3\nDESCRIPTION: Demonstrates basic function declaration syntax using the fn keyword and implementation of a simple loop function.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int times)\n{\n    for (int i = 0; i < times; i++)\n    {\n        io::printfn(\"Hello %d\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a C3 Project\nDESCRIPTION: Use the c3c run command to build and execute a C3 project. This command compiles the project and runs the resulting executable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nc3c run\n> Program linked to executable 'build/myc3project'.\n> Launching ./build/myc3project...\n> Hello, World\n```\n\n----------------------------------------\n\nTITLE: Creating a Hello World Program in C3\nDESCRIPTION: A simple C3 program that prints 'Hello, World!' to the console. It imports the io module from the standard library and defines a main function as the entry point.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void main()\n{\n    io::printn(\"Hello, World!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Hello World Program in C3\nDESCRIPTION: Simple C3 program that prints 'Hello, World!' to the console using the std::io module. Demonstrates basic program structure with imports and main function.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/hello-world.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void main()\n{\n    io::printn(\"Hello, World!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Basic libc Type Definitions\nDESCRIPTION: Core type definitions for the C standard library bindings including error handling, division results, and time structures.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Errno = inline CInt;\nstruct DivResult\nstruct LongDivResult\nstruct TimeSpec\nstruct Timespec\nstruct Tm\n```\n\n----------------------------------------\n\nTITLE: Running C3 Compiler on Windows\nDESCRIPTION: Command to compile a C3 file using the c3c compiler on Windows after setting it as a global environment variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile ./hello.c3\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling in C3\nDESCRIPTION: Demonstrates C3's error handling using optional results. It shows how to define and use faults, return optional results, and handle errors using the 'catch' keyword and flow typing.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfault DIVISION_BY_ZERO;\n\nfn double? divide(int a, int b)\n{\n    // We return an optional result of type DIVISION_BY_ZERO\n    // when b is zero.\n    if (b == 0) return DIVISION_BY_ZERO?;\n    return (double)a / (double)b;\n}\n\n// Re-returning an optional result uses \"?\" suffix\nfn void? testMayError()\n{\n    divide(foo(), bar())!;\n}\n\nfn void main()\n{\n    // ratio is an optional result.\n    double? ratio = divide(foo(), bar());\n\n    // Handle the optional result value if it exists.\n    if (catch err = ratio)\n    {\n        case DIVISION_BY_ZERO:\n            io::printn(\"Division by zero\");\n            return;\n        default:\n            io::printn(\"Unexpected error!\");\n            return;\n    }\n    // Flow typing makes \"ratio\"\n    // have the plain type 'double' here.\n    io::printfn(\"Ratio was %f\", ratio);\n}\n\nfn void print_file(String filename)\n{\n    String? file = io::load_file(filename);\n\n    // The following function is not called on error,\n    // so we must explicitly discard it with a void cast.\n    (void)io::printfn(\"Loaded %s and got:%s\", filename, file);\n\n    if (catch err = file)\n    {\n        switch(err)\n        {\n            case io::FILE_NOT_FOUND:\n                io::printfn(\"I could not find the file %s\", filename);\n            default:\n                io::printfn(\"Could not load %s.\", filename);\n        }\n    }\n}\n\n// Note that the above is only illustrating how Optionals may skip\n// call invocation. A more normal implementation would be:\n\nfn void print_file2(String filename)\n{\n    String? file = io::load_file(filename);\n\n    if (catch err = file)\n    {\n        // Print the error\n        io::printfn(\"Failed to load %s: %s\", filename, err);\n        // We return, so that below 'file' will be unwrapped.\n        return;\n    }\n    // No need for a void cast here, 'file' is unwrappeed to 'String'.\n    io::printfn(\"Loaded %s and got:\\n%s\", filename, file);\n}\n```\n\n----------------------------------------\n\nTITLE: Running a Compiled C3 Program\nDESCRIPTION: Command to execute a compiled C3 program on Unix-like systems. The executable is created in the current directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n./hello_world\n```\n\n----------------------------------------\n\nTITLE: Memory Management Functions in C3\nDESCRIPTION: Functions for allocating, freeing, and reallocating memory, with variants for different allocation types and error handling approaches.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_35\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* calloc(Allocator allocator, usz size) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? calloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? calloc_try(Allocator allocator, usz size) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro clone(Allocator allocator, value) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any clone_any(Allocator allocator, any value) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void free(Allocator allocator, void* ptr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void free_aligned(Allocator allocator, void* ptr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Allocator heap()\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* malloc(Allocator allocator, usz size) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? malloc_aligned(Allocator allocator, usz size, usz alignment) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? malloc_try(Allocator allocator, usz size) @nodiscard\n```\n\n----------------------------------------\n\nTITLE: Optional Function Return Types in C3\nDESCRIPTION: Shows how Optional arguments affect function return types and execution.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn int test(int input)\n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int? optional_argument = 7;\n\n    // `optional_argument` makes returned `returned_optional`\n    // Optional too:\n    int? returned_optional = test(optional_argument);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AnyList Structure and Operations in C3\nDESCRIPTION: This snippet implements the AnyList structure providing various methods for manipulating a list of items that can be of any type. It includes functions for adding, removing, and accessing elements as well as utilities for maintaining the list's state, such as clearing the list, reversing elements, and checking if it is empty.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nstruct AnyList (Printable)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any AnyList.@item_at(&self, usz index) @operator([])\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.add_all(&self, AnyList* other_list)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any[] AnyList.array_view(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.clear(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro AnyList.first(&self, $Type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.first_any(&self) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.free(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.free_element(&self, any element) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro AnyList.get(&self, usz index, $Type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any AnyList.get_any(&self, usz index) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool AnyList.is_empty(&self) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro AnyList.last(&self, $Type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.last_any(&self) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz AnyList.len(&self) @operator(len) @inline\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn AnyList* AnyList.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.new_pop(&self, Allocator allocator = allocator::heap())\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.new_pop_first(&self, Allocator allocator = allocator::heap())\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro AnyList.pop(&self, $Type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro AnyList.pop_first(&self, $Type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.pop_first_retained(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.pop_retained(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void AnyList.push(&self, element)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void AnyList.push_front(&self, type)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.remove_at(&self, usz index)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.remove_first(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz AnyList.remove_if(&self, AnyPredicate filter)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.remove_last(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz AnyList.remove_using_test(&self, AnyTest filter, any context)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.reserve(&self, usz min_capacity)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz AnyList.retain_if(&self, AnyPredicate selection)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz AnyList.retain_using_test(&self, AnyTest filter, any context)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.reverse(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void AnyList.set(&self, usz index, value)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void AnyList.swap(&self, usz i, usz j)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn AnyList* AnyList.temp_init(&self, usz initial_capacity = 16)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.temp_pop(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn any? AnyList.temp_pop_first(&self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? AnyList.to_format(&self, Formatter* formatter) @dynamic\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String AnyList.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String AnyList.to_tstring(&self)\n\n```\n\n----------------------------------------\n\nTITLE: Switching on Any Type in C3\nDESCRIPTION: Demonstrates how to use a switch statement to handle different types stored in an 'any' variable based on their typeid.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nswitch (my_any.type)\n{\n    case Foo.typeid:\n        ...\n    case Bar: // .typeid can be elided\n        ...\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling in C3\nDESCRIPTION: This snippet demonstrates error handling using optional results in C3. It illustrates how to manage possible division by zero errors and handle optional results effectively.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfault MathError\n{\n    DIVISION_BY_ZERO\n}\n\nfn double! divide(int a, int b)\n{\n    // We return an optional result of type DIVISION_BY_ZERO\n    // when b is zero.\n    if (b == 0) return MathError.DIVISION_BY_ZERO?;\n    return (double)a / (double)b;\n}\n\n// Re-returning an optional result uses \"!\" suffix\nfn void! testMayError()\n{\n    divide(foo(), bar())!;\n}\n\nfn void main()\n{\n    // ratio is an optional result.\n    double! ratio = divide(foo(), bar());\n\n    // Handle the optional result value if it exists.\n    if (catch err = ratio)\n    {\n        case MathError.DIVISION_BY_ZERO:\n            io::printn(\"Division by zero\\n\");\n            return;\n        default:\n            io::printn(\"Unexpected error!\");\n            return;\n    }\n    // Flow typing makes \"ratio\"\n    // have the plain type 'double' here.\n    io::printfn(\"Ratio was %f\", ratio);\n}\n```\n\n----------------------------------------\n\nTITLE: String Iterator Creation in C3\nDESCRIPTION: Creates a StringIterator for the given String.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_47\n\nLANGUAGE: c3\nCODE:\n```\nfn StringIterator String.iterator(s);\n```\n\n----------------------------------------\n\nTITLE: Generic Types Usage in C3\nDESCRIPTION: This snippet demonstrates how to use generic types in C3, showcasing a struct `Foo` and usage of a generic `MyList`.  It exemplifies aliasing a concrete type to a generic type, and highlights the difference between a proper alias versus an inline type definition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nimport generic_list; // Contains the generic MyList\n\nstruct Foo {\n    int x;\n}\n\n// ✅ alias for each type used with a generic module.\nalias IntMyList = MyList {Foo};\nMyListFoo working_example;\n\n// ❌ An inline type definition will give an error.\n// Only allowed in a type definition or macro\nMyList {Foo} failing_example = MyList {Foo};\n```\n```\n\n----------------------------------------\n\nTITLE: Lambda Function Usage in C3\nDESCRIPTION: Demonstrates how to create and use anonymous functions (lambdas) in C3, including type aliases for function pointers and array transformation examples. Shows both short inference syntax and regular syntax implementations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nalias IntTransform = fn int(int);\nfn void apply(int[] arr, IntTransform t)\n{\n    foreach (&i : arr) *i = t(*i);\n}\nfn void main()\n{\n    int[] x = { 1, 2, 5 };\n    // Short syntax with inference:\n    apply(x, fn (i) => i * i);\n    // Regular syntax without inference:\n    // apply(x, fn int(int i) { return i * i; });\n    // Prints [1, 4, 25]\n    io::printfn(\"%s\", x);\n}\n```\n\n----------------------------------------\n\nTITLE: String Freeing in C3\nDESCRIPTION: Frees the memory allocated for a String using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.free(&s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Function with Default Arguments\nDESCRIPTION: Shows how to define and use functions with default parameter values in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn int test_with_default(int foo = 1)\n{\n    return foo;\n}\n\nfn void test()\n{\n    test_with_default();\n    test_with_default(100);\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Variable Initialization in C3\nDESCRIPTION: This code snippet illustrates various ways of initializing variables in C3, including default zero initialization, explicit zero initialization, and opting out of initialization. It covers both primitive types and structs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/variables.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint x;               // x = 0\nint y @noinit;       // y is explicitly undefined and must be assigned before use.\n\nAStruct foo;         // foo is implicitly zeroed\nAStruct bar = {};    // bar is explicitly zeroed\nAStruct baz @noinit; // baz is explicitly undefined\n```\n\n----------------------------------------\n\nTITLE: Optional Error Checking in C3\nDESCRIPTION: Shows how to check for errors in Optional values using the catch syntax and handle error cases appropriately.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void? test()\n{\n    // Return an Excuse by adding '?' after the fault.\n    return io::FILE_NOT_FOUND?;\n}\n\nfn void main(String[] args)\n{\n    // If the Optional is empty, assign the\n    // Excuse to a variable:\n    if (catch excuse = test())\n    {\n        io::printfn(\"test() gave an Excuse: %s\", excuse);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bit Manipulation Macros in C3\nDESCRIPTION: This snippet defines a set of macros for bitwise manipulation operations like byte swapping, counting leading/trailing zeros, and rotating bits for various data types including char, int, and long. It focuses on supporting bitwise operations for basic data types as well as their array counterparts in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nmacro bswap(i) @builtin\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char char.fshl(hi, char lo, char shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char char.fshr(hi, char lo, char shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char char.rotl(self, char shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char char.rotr(self, char shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>] char[<*>].fshl(hi, char[<*>] lo, char[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>] char[<*>].fshr(hi, char[<*>] lo, char[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>] char[<*>].rotl(self, char[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[<*>] char[<*>].rotr(self, char[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar ichar.fshl(hi, ichar lo, ichar shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar ichar.fshr(hi, ichar lo, ichar shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar ichar.rotl(self, ichar shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar ichar.rotr(self, ichar shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].fshl(hi, ichar[<*>] lo, ichar[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].fshr(hi, ichar[<*>] lo, ichar[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].rotl(self, ichar[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].rotr(self, ichar[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int int.fshl(hi, int lo, int shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int int.fshr(hi, int lo, int shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int int.rotl(self, int shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int int.rotr(self, int shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128 int128.fshl(hi, int128 lo, int128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128 int128.fshr(hi, int128 lo, int128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128 int128.rotl(self, int128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128 int128.rotr(self, int128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>] int128[<*>].fshl(hi, int128[<*>] lo, int128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>] int128[<*>].fshr(hi, int128[<*>] lo, int128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>] int128[<*>].rotl(self, int128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int128[<*>] int128[<*>].rotr(self, int128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>] int[<*>].fshl(hi, int[<*>] lo, int[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>] int[<*>].fshr(hi, int[<*>] lo, int[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>] int[<*>].rotl(self, int[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int[<*>] int[<*>].rotr(self, int[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long long.fshl(hi, long lo, long shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long long.fshr(hi, long lo, long shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long long.rotl(self, long shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long long.rotr(self, long shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>] long[<*>].fshl(hi, long[<*>] lo, long[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>] long[<*>].fshr(hi, long[<*>] lo, long[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>] long[<*>].rotl(self, long[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro long[<*>] long[<*>].rotr(self, long[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro reverse(i)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short short.fshl(hi, short lo, short shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short short.fshr(hi, short lo, short shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short short.rotl(self, short shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short short.rotr(self, short shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>] short[<*>].fshl(hi, short[<*>] lo, short[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>] short[<*>].fshr(hi, short[<*>] lo, short[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>] short[<*>].rotl(self, short[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro short[<*>] short[<*>].rotr(self, short[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.fshl(hi, uint lo, uint shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.fshr(hi, uint lo, uint shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.rotl(self, uint shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.rotr(self, uint shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128 uint128.fshl(hi, uint128 lo, uint128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128 uint128.fshr(hi, uint128 lo, uint128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128 uint128.rotl(self, uint128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128 uint128.rotr(self, uint128 shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].fshl(hi, uint128[<*>] lo, uint128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].fshr(hi, uint128[<*>] lo, uint128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].rotl(self, uint128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].rotr(self, uint128[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>] uint[<*>].fshl(hi, uint[<*>] lo, uint[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>] uint[<*>].fshr(hi, uint[<*>] lo, uint[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>] uint[<*>].rotl(self, uint[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint[<*>] uint[<*>].rotr(self, uint[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong.fshl(hi, ulong lo, ulong shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong.fshr(hi, ulong lo, ulong shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong.rotl(self, ulong shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong.rotr(self, ulong shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].fshl(hi, ulong[<*>] lo, ulong[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].fshr(hi, ulong[<*>] lo, ulong[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].rotl(self, ulong[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].rotr(self, ulong[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort.clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort.ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.fshl(hi, ushort lo, ushort shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.fshr(hi, ushort lo, ushort shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort.popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.rotl(self, ushort shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.rotr(self, ushort shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>].clz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>].ctz(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].fshl(hi, ushort[<*>] lo, ushort[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].fshr(hi, ushort[<*>] lo, ushort[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>].popcount(self)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].rotl(self, ushort[<*>] shift)\n\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].rotr(self, ushort[<*>] shift)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Collection Operations in C3\nDESCRIPTION: This collection of code snippets describes the operations that can be performed on an 'AnyList', a generic list structure in C3. These operations facilitate managing elements within a list, such as adding, removing, retrieving, and traversing list items while allowing type flexibility using generics. The 'AnyList' is tuned for dynamic and efficient data manipulation, tailored for C3's memory management system.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_5\n\nLANGUAGE: C3\nCODE:\n```\nstruct AnyList (Printable)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro any AnyList.@item_at(&self, usz index) @operator([])\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.add_all(&self, AnyList* other_list)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any[] AnyList.array_view(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.clear(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro AnyList.first(&self, $Type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.first_any(&self) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.free(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.free_element(&self, any element) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro AnyList.get(&self, usz index, $Type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any AnyList.get_any(&self, usz index) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn bool AnyList.is_empty(&self) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro AnyList.last(&self, $Type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.last_any(&self) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz AnyList.len(&self) @operator(len) @inline\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn AnyList* AnyList.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.new_pop(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.new_pop_first(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro AnyList.pop(&self, $Type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro AnyList.pop_first(&self, $Type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.pop_first_retained(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.pop_retained(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro void AnyList.push(&self, element)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro void AnyList.push_front(&self, type)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.remove_at(&self, usz index)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.remove_first(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz AnyList.remove_if(&self, AnyPredicate filter)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.remove_last(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz AnyList.remove_using_test(&self, AnyTest filter, any context)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.reserve(&self, usz min_capacity)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz AnyList.retain_if(&self, AnyPredicate selection)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz AnyList.retain_using_test(&self, AnyTest filter, any context)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.reverse(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro void AnyList.set(&self, usz index, value)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void AnyList.swap(&self, usz i, usz j)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn AnyList* AnyList.temp_init(&self, usz initial_capacity = 16)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.temp_pop(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn any! AnyList.temp_pop_first(&self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn usz! AnyList.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn String AnyList.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn String AnyList.to_tstring(&self)\n```\n\n----------------------------------------\n\nTITLE: Generic Stack Module in C3\nDESCRIPTION: This code demonstrates the creation of a generic stack module in C3, parameterized by a type `Type`.  It includes the definition of the `Stack` struct and associated functions for pushing, popping, and checking if the stack is empty. `realloc` is used to resize the internal buffer.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nmodule stack {Type};\nstruct Stack\n{\n    usz capacity;\n    usz size;\n    Type* elems;\n}\n\n\nfn void Stack.push(Stack* this, Type element)\n{\n    if (this.capacity == this.size)\n    {\n        this.capacity = this.capacity ? this.capacity * 2 : 16;\n        this.elems = realloc(this.elems, Type.sizeof * this.capacity);\n    }\n    this.elems[this.size++] = element;\n}\n\nfn Type Stack.pop(Stack* this)\n{\n    assert(this.size > 0);\n    return this.elems[--this.size];\n}\n\nfn bool Stack.empty(Stack* this)\n{\n    return !this.size;\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Type Usage in C3\nDESCRIPTION: This snippet demonstrates the usage of optional types in C3 using the `?` suffix.  It shows how to assign a real value, an optional result (via `io::EOF?`), and how to catch the Excuse (fault) into a fault variable. `faultdef` is used to define the excuses.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfaultdef MISSING; // define a fault\n\nint? i;\ni = 5;              // Assigning a real value to i.\ni = io::EOF?;       // Assigning an optional result to i.\nfault b = MISSING;  // Assign a fault to b\nb = @catch(i);      // Assign the Excuse in i to b (EOF)\n```\n```\n\n----------------------------------------\n\nTITLE: Compiling a C3 Program\nDESCRIPTION: Command to compile a C3 source file into an executable program. This uses the c3c compiler with the 'compile' action on a C3 source file.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile hello_world.c3\n```\n\n----------------------------------------\n\nTITLE: File Reading with Optional Error Handling in C3\nDESCRIPTION: Demonstrates reading a file with Optional error handling, including proper resource cleanup and error propagation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn char[]? read_file(String filename, char[] buffer)\n{\n    File file = file::open(filename, \"r\")!;\n    defer (void)file.close();\n    file.read(buffer)!;\n    return buffer;\n}\n\nfn void? test_read()\n{\n    char[] buffer = mem::new_array(char, 100);\n    defer free(buffer);\n    char[]? read_buffer = read_file(\"file_to_open.txt\", buffer);\n    if (catch excuse = read_buffer)\n    {\n        io::printfn(\"Excuse found: %s\", excuse);\n        return excuse?;\n    }\n    io::printfn(\"read_buffer: %s\", read_buffer);\n}\n\nfn void main()\n{\n    test_read()!!;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Input with treadline in C3\nDESCRIPTION: Read a line of input from stdin using treadline, which returns an optional string and uses the temporary allocator\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void? hello_name()\n{\n    String? name = io::treadline();\n    if (catch excuse = name) {\n        return excuse?;\n    }\n\n    io::printfn(\"Hello %s! Hope you have a great day\", name);\n}\n```\n\n----------------------------------------\n\nTITLE: Formatted Printing with io::printfn in C3\nDESCRIPTION: This snippet shows how to use io::printfn for formatted output in C3. It demonstrates printing integers, hexadecimal values, scientific notation, and converting byte arrays to strings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printfn(\"a was: %d\", a);\n    io::printfn(\"b in hex was: %x\", b);\n    io::printfn(\"d in scientific notation was: %e\", d);\n    io::printfn(\"Bytes as string: %s\", (String)&hex);\n}\n```\n\n----------------------------------------\n\nTITLE: Module Sections in C3\nDESCRIPTION: Shows how to use multiple module sections in a single file with different visibility settings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\n// File foo.c3\nmodule foo;\nfn int hello_world()\n{\n    return my_hello_world();\n}\n\nmodule foo @private;\nimport std::io;         // The import is only visible in this section.\nfn int my_hello_world() // @private by default\n{\n    io::printn(\"Hello, world\\n\");\n    return 0;\n}\n\nmodule foo @test;\nfn void test_hello() // @test by default\n{\n    assert(hello_world() == 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Compound Literals with Struct in C3\nDESCRIPTION: Shows how to use compound literals with structs in C3, including type inference for cleaner syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int a;\n    double b;\n}\n\nfn void test1(Foo x) { ... }\n\n...\n\ntest1((Foo){ 1, 2.0 });\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre-conditions in C3\nDESCRIPTION: Demonstrates how to use @require annotation to validate function arguments with optional error messages. The example shows validation of an integer parameter with range checks.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require foo > 0, foo < 1000 : \"optional error msg\"\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Contracts for Error Handling and Preconditions in C3\nDESCRIPTION: Shows how to define preconditions and postconditions using contracts in C3 for improved code reliability. Leveraging annotations like `@ensure` and `@require`, the code is equipped with runtime checks in debug builds to enforce function validity.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param foo `the number of foos`\n @require foo > 0, foo < 1000\n @return `number of foos x 10`\n @ensure return < 10000, return > 0\n*>\nfn int test_foo(int foo)\n{\n    return foo * 10;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Typedefs in C3\nDESCRIPTION: This snippet demonstrates how to create new types using `typedef` in C3. It shows that a `typedef` creates a distinct type that is not implicitly convertible to the original type, except for literals. Explicit casting is required for conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ntypedef MyId = int;\nfn void* get_by_id(MyId id) { ... }\n\nfn void test(MyId id)\n{\n    void* val = get_by_id(id); // Ok\n    void* val2 = get_by_id(1); // Literals convert implicitly\n    int a = 1;\n    // void* val3 = get_by_id(a); // ERROR expected a MyId\n    void* val4 = get_by_id((MyId)a); // Works\n    // a = id; // ERROR can't assign 'MyId' to 'int'\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre-conditions in C3\nDESCRIPTION: Demonstrates how to use the @require annotation for pre-conditions in C3. Pre-conditions are used to validate incoming arguments and can include optional error messages.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require foo > 0, foo < 1000 : \"optional error msg\"\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Dispatch through Interfaces in C3\nDESCRIPTION: Shows C3's approach to dynamic dispatch using interfaces. The example defines a MyName interface with a myname method, implements it for different types, and demonstrates runtime polymorphism.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Define a dynamic interface\ninterface MyName\n{\n    fn String myname();\n}\n\nstruct Bob (MyName) { int x; }\n\n// Required implementation as Bob implements MyName\nfn String Bob.myname(Bob*) @dynamic { return \"I am Bob!\"; }\n\n// Ad hoc implementation\nfn String int.myname(int*) @dynamic { return \"I am int!\"; }\n\nfn void whoareyou(any a)\n{\n    MyName b = (MyName)a;\n    if (!&b.myname)\n    {\n        io::printn(\"I don't know who I am.\");\n        return;\n    }\n    io::printn(b.myname());\n}\n\nfn void main()\n{\n    int i = 1;\n    double d = 1.0;\n    Bob bob;\n\n    any a = &i;\n    whoareyou(a);\n    a = &d;\n    whoareyou(a);\n    a = &bob;\n    whoareyou(a);\n}\n```\n\n----------------------------------------\n\nTITLE: C3 Language YACC Grammar Definition\nDESCRIPTION: Comprehensive YACC grammar specification defining the syntax rules for parsing C3 language code. Includes tokens for operators, keywords, identifiers, and rules for expressions, declarations, control flow structures, and language-specific features.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n%{\n\n#include <stdio.h>\n#define YYERROR_VERBOSE\nint yydebug = 1;\nextern char yytext[];\nextern int column;\nint yylex(void);\nvoid yyerror(char *s);\n%}\n\n%token IDENT HASH_IDENT CT_IDENT CONST_IDENT\n%token TYPE_IDENT CT_TYPE_IDENT\n%token AT_TYPE_IDENT AT_IDENT CT_INCLUDE\n%token STRING_LITERAL INTEGER\n%token INC_OP DEC_OP SHL_OP SHR_OP LE_OP GE_OP EQ_OP NE_OP\n%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN\n%token SUB_ASSIGN SHL_ASSIGN SHR_ASSIGN AND_ASSIGN\n%token XOR_ASSIGN OR_ASSIGN VAR NUL ELVIS NEXTCASE ANYFAULT\n%token MODULE IMPORT DEF EXTERN\n%token CHAR SHORT INT LONG FLOAT DOUBLE CONST VOID USZ ISZ UPTR IPTR ANY\n%token ICHAR USHORT UINT ULONG BOOL INT128 UINT128 FLOAT16 FLOAT128 BFLOAT16\n%token TYPEID BITSTRUCT STATIC BANGBANG AT_CONST_IDENT HASH_TYPE_IDENT\n%token STRUCT UNION ENUM ELLIPSIS DOTDOT BYTES\n\n%token CT_ERROR\n%token CASE DEFAULT IF ELSE SWITCH WHILE DO FOR CONTINUE BREAK RETURN FOREACH_R FOREACH\n%token FN FAULT MACRO CT_IF CT_ENDIF CT_ELSE CT_SWITCH CT_CASE CT_DEFAULT CT_FOR CT_FOREACH CT_ENDFOREACH\n%token CT_ENDFOR CT_ENDSWITCH BUILTIN IMPLIES INITIALIZE FINALIZE CT_ECHO CT_ASSERT CT_EVALTYPE CT_VATYPE\n%token TRY CATCH SCOPE DEFER LVEC RVEC OPTELSE CT_TYPEFROM CT_TYPEOF TLOCAL\n%token CT_VASPLAT INLINE DISTINCT CT_VACONST CT_VAREF CT_VACOUNT CT_VAARG\n%token CT_SIZEOF CT_STRINGIFY CT_QNAMEOF CT_OFFSETOF CT_VAEXPR\n%token CT_EXTNAMEOF CT_EVAL CT_DEFINED CT_CHECKS CT_ALIGNOF ASSERT\n%token ASM CHAR_LITERAL REAL TRUE FALSE CT_CONST_IDENT\n%token LBRAPIPE RBRAPIPE HASH_CONST_IDENT\n\n%start translation_unit\n%%\n\npath\n    \t: IDENT SCOPE\n    \t| path IDENT SCOPE\n    \t;\n\npath_const\n\t: path CONST_IDENT\n\t| CONST_IDENT\n\t;\n\npath_ident\n\t: path IDENT\n\t| IDENT\n\t;\n\npath_at_ident\n\t: path AT_IDENT\n\t| AT_IDENT\n\t;\n\nident_expr\n\t: CONST_IDENT\n\t| IDENT\n\t| AT_IDENT\n\t;\n\nlocal_ident_expr\n\t: CT_IDENT\n        | HASH_IDENT\n\t;\n\nct_call\n\t: CT_ALIGNOF\n\t| CT_DEFINED\n\t| CT_EXTNAMEOF\n\t| CT_NAMEOF\n\t| CT_OFFSETOF\n\t| CT_QNAMEOF\n\t;\n\nct_analyse\n\t: CT_EVAL\n\t| CT_SIZEOF\n\t| CT_STRINGIFY\n\t;\n\nct_arg\n\t: CT_VACONST\n        | CT_VAARG\n        | CT_VAREF\n        | CT_VAEXPR\n\t;\n\nflat_path\n\t: primary_expr param_path\n\t| type\n\t| primary_expr\n\t;\n\nmaybe_optional_type\n\t: optional_type\n\t| empty\n\t;\n\nstring_expr\n\t: STRING_LITERAL\n\t| string_expr STRING_LITERAL\n\t;\n\nbytes_expr\n\t: BYTES\n\t| bytes_expr BYTES\n\t;\n\nexpr_block\n\t: LBRAPIPE opt_stmt_list RBRAPIPE\n\t;\n\nbase_expr\n\t: string_expr\n\t| INTEGER\n\t| bytes_expr\n\t| NUL\n\t| BUILTIN CONST_IDENT\n\t| BUILTIN IDENT\n\t| CHAR_LITERAL\n\t| REAL\n\t| TRUE\n\t| FALSE\n\t| path ident_expr\n\t| ident_expr\n\t| local_ident_expr\n\t| type initializer_list\n\t| type '.' access_ident\n\t| type '.' CONST_IDENT\n\t| '(' expr ')'\n\t| expr_block\n\t| ct_call '(' flat_path ')'\n\t| ct_arg '(' expr ')'\n\t| ct_analyse '(' expr ')'\n\t| CT_VACOUNT\n\t| CT_CHECKS '(' expression_list ')'\n\t| lambda_decl compound_statement\n\t;\n\nprimary_expr\n\t: base_expr\n\t| initializer_list\n\t;\n\nrange_loc\n\t: expr\n\t| '^' expr\n\t;\n\nrange_expr\n\t: range_loc DOTDOT range_loc\n\t| range_loc DOTDOT\n\t| DOTDOT range_loc\n\t| range_loc ':' range_loc\n\t| ':' range_loc\n\t| range_loc ':'\n\t| DOTDOT\n\t;\n\n\ncall_inline_attributes\n\t: AT_IDENT\n\t| call_inline_attributes AT_IDENT\n\t;\n\ncall_invocation\n\t: '(' call_arg_list ')'\n\t| '(' call_arg_list ')' call_inline_attributes\n\t;\n\naccess_ident\n\t: IDENT\n\t| AT_IDENT\n\t| HASH_IDENT\n\t| CT_EVAL '(' expr ')'\n\t| TYPEID\n\t;\n\ncall_trailing\n\t: '[' range_loc ']'\n\t| '[' range_expr ']'\n\t| call_invocation\n\t| call_invocation compound_statement\n\t| '.' access_ident\n\t| INC_OP\n\t| DEC_OP\n\t| '!'\n\t| BANGBANG\n\t;\n\ncall_stmt_expr\n\t: base_expr\n\t| call_stmt_expr call_trailing\n\t;\n\ncall_expr\n\t: primary_expr\n\t| call_expr call_trailing\n\t;\n\nunary_expr\n\t: call_expr\n\t| unary_op unary_expr\n\t;\n\nunary_stmt_expr\n\t: call_stmt_expr\n\t| unary_op unary_expr\n\t;\n\nunary_op\n\t: '&'\n\t| AND_OP\n\t| '*'\n\t| '+'\n\t| '-'\n\t| '~'\n\t| '!'\n\t| INC_OP\n\t| DEC_OP\n\t| '(' type ')'\n\t;\n\nmult_op\n\t: '*'\n\t| '/'\n\t| '%'\n    \t;\n\nmult_expr\n\t: unary_expr\n\t| mult_expr mult_op unary_expr\n\t;\n\nmult_stmt_expr\n\t: unary_stmt_expr\n\t| mult_stmt_expr mult_op unary_expr\n\t;\n\nshift_op\n\t: SHL_OP\n\t| SHR_OP\n\t;\n\nshift_expr\n\t: mult_expr\n\t| shift_expr shift_op mult_expr\n\t;\n\nshift_stmt_expr\n\t: mult_stmt_expr\n\t| shift_stmt_expr shift_op mult_expr\n\t;\n\n\nbit_op\n    \t: '&'\n    \t| '^'\n    \t| '|'\n    \t;\n\nbit_expr\n\t: shift_expr\n\t| bit_expr bit_op shift_expr\n\t;\n\nbit_stmt_expr\n\t: shift_stmt_expr\n\t| bit_stmt_expr bit_op shift_expr\n\t;\n\nadditive_op\n\t: '+'\n\t| '-'\n    \t;\n\nadditive_expr\n\t: bit_expr\n\t| additive_expr additive_op bit_expr\n\t;\n\nadditive_stmt_expr\n\t: bit_stmt_expr\n\t| additive_stmt_expr additive_op bit_expr\n\t;\n\nrelational_op\n\t: '<'\n\t| '>'\n\t| LE_OP\n\t| GE_OP\n\t| EQ_OP\n\t| NE_OP\n\t;\n\nrelational_expr\n\t: additive_expr\n\t| relational_expr relational_op additive_expr\n\t;\n\nrelational_stmt_expr\n\t: additive_stmt_expr\n\t| relational_stmt_expr relational_op additive_expr\n\t;\n\nrel_or_lambda_expr\n\t: relational_expr\n\t| lambda_decl IMPLIES relational_expr\n\t;\n\nand_expr\n\t: relational_expr\n\t| and_expr AND_OP relational_expr\n\t;\n\nand_stmt_expr\n\t: relational_stmt_expr\n\t| and_stmt_expr AND_OP relational_expr\n\t;\n\nor_expr\n\t: and_expr\n\t| or_expr OR_OP and_expr\n\t;\n\nor_stmt_expr\n\t: and_stmt_expr\n\t| or_stmt_expr OR_OP and_expr\n\t;\n\nor_expr_with_suffix\n\t: or_expr\n\t| or_expr '?'\n\t| or_expr '?' '!'\n\t;\n\nor_stmt_expr_with_suffix\n\t: or_stmt_expr\n\t| or_stmt_expr '?'\n\t| or_stmt_expr '?' '!'\n\t;\n\nternary_expr\n\t: or_expr_with_suffix\n\t| or_expr '?' expr ':' ternary_expr\n\t| or_expr_with_suffix ELVIS ternary_expr\n\t| or_expr_with_suffix OPTELSE ternary_expr\n\t| lambda_decl implies_body\n\t;\n\nternary_stmt_expr\n\t: or_stmt_expr_with_suffix\n\t| or_stmt_expr '?' expr ':' ternary_expr\n\t| or_stmt_expr_with_suffix ELVIS ternary_expr\n\t| or_stmt_expr_with_suffix OPTELSE ternary_expr\n\t| lambda_decl implies_body\n\t;\n\nassignment_op\n\t: '='\n\t| ADD_ASSIGN\n\t| SUB_ASSIGN\n\t| MUL_ASSIGN\n\t| DIV_ASSIGN\n\t| MOD_ASSIGN\n\t| SHL_ASSIGN\n\t| SHR_ASSIGN\n\t| AND_ASSIGN\n\t| XOR_ASSIGN\n\t| OR_ASSIGN\n\t;\n\nempty\n\t:\n\t;\n\nassignment_expr\n    \t: ternary_expr\n    \t| CT_TYPE_IDENT '=' type\n    \t| unary_expr assignment_op assignment_expr\n    \t;\nassignment_stmt_expr\n    \t: ternary_stmt_expr\n    \t| CT_TYPE_IDENT '=' type\n    \t| unary_stmt_expr assignment_op assignment_expr\n    \t;\n\nimplies_body\n\t: IMPLIES expr\n\t;\n\nlambda_decl\n\t: FN maybe_optional_type fn_parameter_list opt_attributes\n\t;\n\nexpr_no_list\n\t: assignment_stmt_expr\n\t;\n\nexpr\n\t: assignment_expr\n\t;\n\n\nconstant_expr\n\t: ternary_expr\n\t;\n\nparam_path_element\n\t: '[' expr ']'\n\t| '[' expr DOTDOT expr ']'\n\t| '.' IDENT\n\t;\n\nparam_path\n\t: param_path_element\n\t| param_path param_path_element\n\t;\n\narg\t: param_path '=' expr\n\t| type\n\t| param_path '=' type\n\t| expr\n\t| CT_VASPLAT '(' range_expr ')'\n\t| CT_VASPLAT '(' ')'\n\t| ELLIPSIS expr\n\t;\n\narg_list\n\t: arg\n\t| arg_list ',' arg\n\t;\n\ncall_arg_list\n\t: arg_list\n\t| arg_list ';'\n\t| arg_list ';' parameters\n\t| ';'\n\t| ';' parameters\n\t| empty\n\t;\n\nopt_arg_list_trailing\n\t: arg_list\n\t| arg_list ','\n\t| empty\n\t;\n\nenum_constants\n    : enum_constant\n    | enum_constants ',' enum_constant\n    ;\n\nenum_list\n\t: enum_constants\n\t| enum_constants ','\n\t;\n\nenum_constant\n\t: CONST_IDENT\n\t| CONST_IDENT '(' arg_list ')'\n\t| CONST_IDENT '(' arg_list ',' ')'\n\t;\n\nidentifier_list\n\t: IDENT\n\t| identifier_list ',' IDENT\n\t;\n\nenum_param_decl\n\t: type\n\t| type IDENT\n\t| type IDENT '=' expr\n\t;\n\nbase_type\n    : VOID\n    | BOOL\n    | CHAR\n    | ICHAR\n    | SHORT\n    | USHORT\n    | INT\n    | UINT\n    | LONG\n    | ULONG\n    | INT128\n    | UINT128\n    | FLOAT\n    | DOUBLE\n    | FLOAT16\n    | BFLOAT16\n    | FLOAT128\n    | IPTR\n    | UPTR\n    | ISZ\n    | USZ\n    | ANYFAULT\n    | ANY\n    | TYPEID\n    | TYPE_IDENT\n    | path TYPE_IDENT\n    | CT_TYPE_IDENT\n    | CT_TYPEOF '(' expr ')'\n    | CT_TYPEFROM '(' constant_expr ')'\n    | CT_VATYPE '(' constant_expr ')'\n    | CT_EVALTYPE '(' constant_expr ')'\n    ;\n\ntype\n    : base_type\n    | type '*'\n    | type '[' constant_expr ']'\n    | type '[' ']'\n    | type '[' '*' ']'\n    | type LVEC constant_expr RVEC\n    | type LVEC '*' RVEC\n    ;\n\noptional_type\n    : type\n    | type '!'\n    ;\n\nlocal_decl_after_type\n\t: CT_IDENT\n\t| CT_IDENT '=' constant_expr\n\t| IDENT opt_attributes\n\t| IDENT opt_attributes '=' expr\n\t;\n\nlocal_decl_storage\n\t: STATIC\n\t| TLOCAL\n\t;\n\ndecl_or_expr\n\t: var_decl\n\t| optional_type local_decl_after_type\n\t| expr\n\t;\n\nvar_decl\n\t: VAR IDENT '=' expr\n\t| VAR CT_IDENT '=' expr\n\t| VAR CT_IDENT\n\t| VAR CT_TYPE_IDENT '=' type\n\t| VAR CT_TYPE_IDENT\n\t;\n\ninitializer_list\n\t: '{' opt_arg_list_trailing '}'\n\t;\n\nct_case_stmt\n    \t: CT_CASE constant_expr ':' opt_stmt_list\n    \t| CT_CASE type ':' opt_stmt_list\n    \t| CT_DEFAULT ':' opt_stmt_list\n    \t;\n\nct_switch_body\n\t: ct_case_stmt\n    \t| ct_switch_body ct_case_stmt\n    \t;\n\nct_for_stmt\n    \t: CT_FOR '(' for_cond ')' opt_stmt_list CT_ENDFOR\n\t;\n\nct_foreach_stmt\n\t: CT_FOREACH '(' CT_IDENT ':' expr ')' opt_stmt_list CT_ENDFOREACH\n\t| CT_FOREACH '(' CT_IDENT ',' CT_IDENT ':' expr ')' opt_stmt_list CT_ENDFOREACH\n\t;\nct_switch\n    \t: CT_SWITCH '(' constant_expr ')'\n    \t| CT_SWITCH '(' type ')'\n    \t| CT_SWITCH\n   \t;\n\nct_switch_stmt\n\t: ct_switch ct_switch_body CT_ENDSWITCH\n\t;\n\nvar_stmt\n\t: var_decl ';'\n\ndecl_stmt_after_type\n\t: local_decl_after_type\n\t| decl_stmt_after_type ',' local_decl_after_type\n\t;\n\ndeclaration_stmt\n\t: const_declaration\n\t| local_decl_storage optional_type decl_stmt_after_type ';'\n\t| optional_type decl_stmt_after_type ';'\n\t;\n\nreturn_stmt\n\t: RETURN expr ';'\n\t| RETURN ';'\n\t;\n\ncatch_unwrap_list\n\t: relational_expr\n\t| catch_unwrap_list ',' relational_expr\n\t;\n\ncatch_unwrap\n\t: CATCH catch_unwrap_list\n\t| CATCH IDENT '=' catch_unwrap_list\n\t| CATCH type IDENT '=' catch_unwrap_list\n\t;\n\ntry_unwrap\n\t: TRY rel_or_lambda_expr\n\t| TRY IDENT '=' rel_or_lambda_expr\n\t| TRY type IDENT '=' rel_or_lambda_expr\n\t;\n\ntry_unwrap_chain\n\t: try_unwrap\n\t| try_unwrap_chain AND_OP try_unwrap\n\t| try_unwrap_chain AND_OP rel_or_lambda_expr\n\t;\n\ndefault_stmt\n\t: DEFAULT ':' opt_stmt_list\n\t;\n\ncase_stmt\n\t: CASE expr ':' opt_stmt_list\n\t| CASE expr DOTDOT expr ':' opt_stmt_list\n\t| CASE type ':' opt_stmt_list\n\t;\n\nswitch_body\n\t: case_stmt\n\t| default_stmt\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating @pool Context for Automatic Memory Management in C3\nDESCRIPTION: This code snippet showcases the use of the @pool context in C3 for automatic memory deallocation. It's mentioned in the 'Ergonomics and Safety' section, illustrating how C3 can automatically free memory after use within this context.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/index.mdx#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n@pool {\n    // Memory allocated here will be automatically freed\n    // when execution leaves this block\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Calls using Interfaces in C3\nDESCRIPTION: This code demonstrates dynamic dispatch in C3 using interfaces. An interface `MyName` is defined with a `myname` function. Structs and types can implement the interface using the `@dynamic` keyword. The `whoareyou` function takes an `any` type and calls the `myname` function through the interface, or prints a default message if the interface is not implemented.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Define a dynamic interface\ninterface MyName\n{\n    fn String myname();\n}\n\nstruct Bob (MyName) { int x; }\n\n// Required implementation as Bob implements MyName\nfn String Bob.myname(Bob*) @dynamic { return \"I am Bob!\"; }\n\n// Ad hoc implementation\nfn String int.myname(int*) @dynamic { return \"I am int!\"; }\n\nfn void whoareyou(any a)\n{\n    MyName b = (MyName)a;\n    if (!&b.myname)\n    {\n        io::printn(\"I don't know who I am.\");\n        return;\n    }\n    io::printn(b.myname());\n}\n\nfn void main()\n{\n    int i = 1;\n    double d = 1.0;\n    Bob bob;\n\n    any a = &i;\n    whoareyou(a);\n    a = &d;\n    whoareyou(a);\n    a = &bob;\n    whoareyou(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing List Operations in C3\nDESCRIPTION: Defines a List struct and associated methods for dynamic array operations, including element manipulation, searching, and formatting.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nstruct List (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Type List.@item_at(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.add_all(&self, List* other_list)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.add_array(&self, Type[] array)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type[] List.array_view(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.byte_size(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.clear(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.compact(&self) @if(ELEMENT_IS_POINTER)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.compact_count(&self) @if(ELEMENT_IS_POINTER)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool List.contains(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool List.equals(&self, List other_list) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! List.first(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type List.get(&self, usz index) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type* List.get_ref(&self, usz index) @operator(&[]) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! List.index_of(&self, Type type) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.init_wrapping_array(&self, Type[] types, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.insert_at(&self, usz index, Type type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool List.is_empty(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! List.last(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.len(&self) @operator(len) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn List* List.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! List.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! List.pop_first(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.push(&self, Type element) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.push_front(&self, Type type) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.remove_all_from(&self, List* other_list) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.remove_all_matches(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.remove_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! List.remove_first(&self) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool List.remove_first_match(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.remove_if(&self, ElementPredicate filter)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! List.remove_last(&self) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool List.remove_last_match(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.remove_using_test(&self, ElementTest filter, any context)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.reserve(&self, usz min_capacity)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.retain_if(&self, ElementPredicate selection)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz List.retain_using_test(&self, ElementTest filter, any context)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.reverse(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! List.rindex_of(&self, Type type) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.set(&self, usz index, Type value) @operator([]= )\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.set_at(&self, usz index, Type type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void List.swap(&self, usz i, usz j)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn List* List.temp_init(&self, usz initial_capacity = 16)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! List.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type[] List.to_new_array(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String List.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type[] List.to_tarray(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String List.to_tstring(&self)\n```\n\n----------------------------------------\n\nTITLE: Exporting C3 Functions for C Usage\nDESCRIPTION: Demonstrates how to export C3 functions for use in C code, using @export and @export with custom names to control the external visibility and naming of functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/cinterop.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\nfn int square(int x) @export // @export ensures external visibility\n{\n    return x * x;\n}\n\nfn int square2(int x) @export(\"square\")\n{\n    return x * x;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Contracts in C3\nDESCRIPTION: Shows how to use contracts in C3 for defining pre- and post-conditions. These contracts can be optionally compiled into asserts to help with code optimization and debugging.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param foo \"the number of foos\"\n @require foo > 0, foo < 1000\n @return \"number of foos x 10\"\n @ensure return < 10000, return > 0\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n\n<*\n @param array \"the array to test\"\n @param length \"length of the array\"\n @require length > 0\n*>\nfn int getLastElement(int* array, int length)\n{\n    return array[length - 1];\n}\n```\n\n----------------------------------------\n\nTITLE: CSV Reading in C3\nDESCRIPTION: Provides functionality for reading CSV files with customizable separators.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_62\n\nLANGUAGE: c3\nCODE:\n```\nstruct CsvReader\n\nmacro CsvReader.@each_row(self, int rows = int.max; @body(String[] row))\nfn void CsvReader.init(&self, InStream stream, String separator = \",\")\nfn String[]! CsvReader.read_new_row(self, Allocator allocator = allocator::heap())\nfn String[]! CsvReader.read_new_row_with_allocator(self, Allocator allocator = allocator::heap())\nfn String[]! CsvReader.read_temp_row(self)\nfn void! CsvReader.skip_row(self) @maydiscard\n```\n\n----------------------------------------\n\nTITLE: Rethrow Operator Usage in C3\nDESCRIPTION: Shows how to use the Rethrow operator (!) to unwrap Optional values and handle errors.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Function returning an Optional\nfn int? maybe_func() { /* ... */ }\n\nfn void? test()\n{\n    // ❌ This will be a compile error\n    // maybe_function() returns an Optional\n    // and 'bar' is not declared Optional:\n    // int bar = maybe_function();\n\n    int bar = maybe_function()!;\n    // ✅ The above is equivalent to:\n    // int? temp = maybe_function();\n    // if (catch excuse = temp) return excuse?\n\n    // Now temp is unwrapped to a non-Optional\n    int bar = temp; // ✅ This is OK\n}\n```\n\n----------------------------------------\n\nTITLE: Automatic Optional Unwrapping in C3\nDESCRIPTION: Demonstrates automatic unwrapping of Optional values when using control flow statements like return, break, or continue.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void? test()\n{\n    int? foo = unreliable_function();\n    if (catch excuse = foo)\n    {\n        // Return the excuse with `?` operator\n        return excuse?;\n    }\n    // Because the compiler knows 'foo' cannot\n    // be empty here, it is unwrapped to non-Optional\n    // 'int foo' in this scope:\n    io::printfn(\"foo: %s\", foo); // 7\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing RingBuffer in C3\nDESCRIPTION: Defines the RingBuffer structure and its methods for managing a circular buffer of fixed size.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nstruct RingBuffer\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type RingBuffer.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.init(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type? RingBuffer.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.push(&self, Type c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz RingBuffer.read(&self, usz index, Type[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.write(&self, Type[] buffer)\n```\n\n----------------------------------------\n\nTITLE: Implementing Struct Methods in C3\nDESCRIPTION: Demonstrates how to define and use struct methods in C3. It shows how to namespace functions with a struct type to enable dot syntax calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int i;\n}\n\nfn void Foo.next(Foo* this)\n{\n    if (this) this.i++;\n}\n\nfn void test()\n{\n    Foo foo = { 2 };\n    foo.next();\n    foo.next();\n    // Prints 4\n    io::printfn(\"%d\", foo.i);\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Specific C3 Project Target\nDESCRIPTION: Specify a target when building and running a C3 project. This is useful when working with multiple targets defined in the project.json file.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nc3c run myc3project\n```\n\n----------------------------------------\n\nTITLE: Using Post-conditions in C3\nDESCRIPTION: Shows how to implement post-conditions using @ensure annotation to verify function return values. The example validates that the return value is greater than a struct member.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require foo != null\n @ensure return > foo.x\n*>\nfn uint checkFoo(Foo* foo)\n{\n    uint y = abs(foo.x) + 1;\n    return y * abs(foo.x);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Types in C3\nDESCRIPTION: Demonstrates struct definition in C3, including nested structs, anonymous structs, unions, and various field types such as function pointers and enums.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nalias Callback = fn int(char c);\n\nenum Status : int\n{\n    IDLE,\n    BUSY,\n    DONE,\n}\n\nstruct MyData\n{\n    char* name;\n    Callback open;\n    Callback close;\n    State status;\n\n    // named sub-structs (x.other.value)\n    struct other\n    {\n        int value;\n        int status;   // ok, no name clash with other status\n    }\n\n    // anonymous sub-structs (x.value)\n    struct\n    {\n        int value;\n        int status;   // error, name clash with other status in MyData\n    }\n\n    // anonymous union (x.person)\n    union\n    {\n        Person* person;\n        Company* company;\n    }\n\n    // named sub-unions (x.either.this)\n    union either\n    {\n        int this;\n        bool  or;\n        char* that;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring and Initializing Fixed-Size Arrays in C3\nDESCRIPTION: Demonstrates how to declare and initialize fixed-size arrays in C3, including using the [*] syntax for size inference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[3] a = { 1, 2, 3 };\nint[*] b = { 4, 5, 6 }; // Type inferred to be int[3]\n```\n\n----------------------------------------\n\nTITLE: Printing Basic Values using io::printn in C3\nDESCRIPTION: This snippet shows how to print different data types such as int, ulong, double, and char array using the basic printing function io::printn from the std::io module. It demonstrates the output of each variable after running the program, including hex representation for char arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io; // Get the io functions.\n\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printn(a);\n    io::printn(b);\n    io::printn(d);\n    io::printn(hex);\n}\n```\n\n----------------------------------------\n\nTITLE: For Statement Syntax in C3\nDESCRIPTION: Shows the syntax definition for 'for' loops in C3, including initialization, condition, and increment expressions. The example demonstrates the structure of a standard for loop with optional components.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\nfor_stmt           ::= \"for\" label? \"(\" init_expr \";\" cond_expr? \";\" incr_expr \")\" stmt\ninit_expr          ::= decl_expr_list?\nincr_expr          ::= expr_list?\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Fibonacci Calculation using C3 Macros\nDESCRIPTION: This code snippet showcases compile-time execution in C3 using macros. The `fib` macro calculates the Fibonacci number for a given input at compile time. The result is then assigned to a constant.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nmacro long fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return fib($n - 1) + fib($n - 2);\n    $endif\n}\n\nconst long FIB19 = fib(19);\n// Same as const long FIB19 = 4181;\n```\n\n----------------------------------------\n\nTITLE: Defining Slice Structure in C3\nDESCRIPTION: Presents the internal representation of a slice in C3 as a two-element struct containing a pointer and length.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nstruct SliceRaw\n{\n\tvoid* ptr;\n\tusz len;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Varargs in C3 Functions\nDESCRIPTION: Demonstrates the use of varargs in C3, showing single typed, explicitly and implicitly typed, and untyped varargs. Emphasizes the versatility in handling parameter lists of varying lengths and types, including C-style untyped varargs for external functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void va_singletyped(int... args)\n{\n    /* args has type int[] */\n}\n\nfn void va_variants_explicit(any*... args)\n{\n    /* args has type any*[] */\n}\n\nfn void va_variants_implicit(args...)\n{\n    /* args has type any*[] */\n}\n\nextern fn void va_untyped(...);\n\nfn void test()\n{\n    va_singletyped(1, 2, 3);\n    int x = 1;\n    any* v = &x;\n    va_variants_explicit(&&1, &x, v);\n    va_variants_implicit(1, x, \"foo\");\n    va_untyped(1, x, \"foo\");\n}\n\n```\n\n----------------------------------------\n\nTITLE: Socket Programming API in C3\nDESCRIPTION: Socket programming interface in C3 with conditional compilation for systems supporting Internet protocols. Provides polling, socket options, and stream-based socket I/O operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_93\n\nLANGUAGE: c3\nCODE:\n```\ntypedef PollEvents = ushort;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef PollSubscribes = ushort;\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum SocketOption : char (CInt value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Poll\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Socket (InStream, OutStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @loop_over_ai(AddrInfo* ai; @body(NativeSocket fd, AddrInfo* ai))\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.close(&self) @inline @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.destroy(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_broadcast(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_dontroute(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_keepalive(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_oobinline(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_option(&self, SocketOption option)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Socket.get_reuseaddr(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Socket.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? Socket.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_broadcast(&self, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_dontroute(&self, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_keepalive(&self, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_oobinline(&self, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_option(&self, SocketOption option, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.set_reuseaddr(&self, bool value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Socket.write(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Socket.write_byte(&self, char byte) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Socket new_socket(fd, ai)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong? poll(Poll[] polls, Duration timeout)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong? poll_ms(Poll[] polls, long timeout_ms)\n```\n\n----------------------------------------\n\nTITLE: Implementing HashMap Operations in C3\nDESCRIPTION: Defines a HashMap struct and associated methods for key-value pair storage and retrieval, including initialization, modification, and querying operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nstruct Entry\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct HashMap\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro HashMap.@each(map; @body(key, value))\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro HashMap.@each_entry(map; @body(entry))\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Value HashMap.@get_or_set(&map, Key key, Value #expr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void HashMap.clear(&map)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void HashMap.free(&map)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Value! HashMap.get(&map, Key key) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Entry*! HashMap.get_entry(&map, Key key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Value*! HashMap.get_ref(&map, Key key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool HashMap.has_key(&map, Key key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool HashMap.has_value(&map, Value v) @if(VALUE_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool HashMap.is_empty(&map) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool HashMap.is_initialized(&map)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Key[] HashMap.key_new_list(&map, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Key[] HashMap.key_tlist(&map)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz HashMap.len(&map) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn HashMap* HashMap.new_init(&self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn HashMap* HashMap.new_init_from_map(&self, HashMap* other_map, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! HashMap.remove(&map, Key key) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool HashMap.set(&map, Key key, Value value) @operator([]=)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn HashMap* HashMap.temp_init(&self, uint capacity = DEFAULT_INITIAL_CAPACITY, float load_factor = DEFAULT_LOAD_FACTOR)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn HashMap* HashMap.temp_init_from_map(&map, HashMap* other_map)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Value[] HashMap.value_new_list(&map, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Value[] HashMap.value_tlist(&map)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Slices in C3\nDESCRIPTION: Demonstrates various ways to create and manipulate slices in C3, including array indexing, pointer conversion, and range operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[100] a;\nint[] b = a[3..6]; // Or a[3:4]\nb[0] = 1;          // Same as a[3] = 1\n```\n\n----------------------------------------\n\nTITLE: Vector 3D Operations in C3\nDESCRIPTION: Methods for 3D vector operations in both double precision (Vec3) and float precision (Vec3f). Includes angle calculation, cross product, rotation, transformation, projection and other vector operations required for 3D graphics.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_90\n\nLANGUAGE: c3\nCODE:\n```\nfn double Vec3.angle(self, Vec3 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.barycenter(self, Vec3 a, Vec3 b, Vec3 c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3.clamp_mag(self, double min, double max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.cross(self, Vec3 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3.distance_sq(self, Vec3 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.perpendicular(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.refract(self, Vec3 n, double r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.rotate_axis(self, Vec3 axis, double angle)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.rotate_quat(self, Quaternion q)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.towards(self, Vec3 target, double max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.transform(self, Matrix4 mat)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3 Vec3.unproject(self, Matrix4 projection, Matrix4 view)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float Vec3f.angle(self, Vec3f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.barycenter(self, Vec3f a, Vec3f b, Vec3f c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3f.clamp_mag(self, float min, float max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.cross(self, Vec3f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3f.distance_sq(self, Vec3f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec3f.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.perpendicular(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.refract(self, Vec3f n, float r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.rotate_axis(self, Vec3f axis, float angle)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.rotate_quat(self, Quaternionf q)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.towards(self, Vec3f target, float max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.transform(self, Matrix4f mat)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec3f Vec3f.unproject(self, Matrix4f projection, Matrix4f view)\n```\n\n----------------------------------------\n\nTITLE: Module Import and Function Usage Example in C3\nDESCRIPTION: Shows how to import and use functions from other modules including implicit submodule imports.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nmodule some::foo;\nfn void test() {}\n```\n\nLANGUAGE: c3\nCODE:\n```\nmodule bar;\nimport some;\n// import some::foo; <- not needed, as it is a sub module to \"some\"\nfn void test()\n{\n    foo::test();\n    // some::foo::test() also works.\n}\n```\n\n----------------------------------------\n\nTITLE: First-class Types in C3 Macros\nDESCRIPTION: Shows how C3 macros can work with types as first-class citizens, using the $ symbol for compile-time evaluation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\n#define SIZE(T) (sizeof(T) + sizeof(int))\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro size($Type)\n{\n    return $Type.sizeof + int.sizeof;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Undefined Behaviour Handling in C3\nDESCRIPTION: This snippet shows how C3 handles potential division by zero, illustrating the difference between release and safe builds. In release builds, the compiler may optimize based on the assumption that undefined behaviour cannot occur.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/undefined-behaviour.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nuint x = foo();\nuint z = 255 / x;\nreturn x != 0;\n```\n\n----------------------------------------\n\nTITLE: Implementing Macros in C3\nDESCRIPTION: Shows various macro implementations in C3, including immediate evaluation, deferred evaluation using #var syntax, and macro preconditions for improved error handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo(a, b)\n{\n    return a(b);\n}\n\nfn int square(int x)\n{\n    return x * x;\n}\n\nfn int test()\n{\n    int a = 2;\n    int b = 3;\n    return foo(&square, 2) + a + b; // 9\n    // return foo(square, 2) + a + b;\n    // Error the symbol \"square\" cannot be used as an argument.\n}\n\nmacro @foo(#a, b, #c)\n{\n    c = a(b) * b;\n}\n\nmacro @foo2(#a)\n{\n    return a * a;\n}\n\nfn int square(int x)\n{\n    return x * x;\n}\n\nfn int test1()\n{\n    int a = 2;\n    int b = 3;\n    @foo(square, a + 1, b);\n    return b; // 27\n}\n\nfn int test2()\n{\n    return @foo2(1 + 1); // 1 + 1 * 1 + 1 = 3\n}\n\n<*\n @param x \"value to square\"\n @require types::is_numeric($typeof(x)) \"cannot multiply\"\n*>\nmacro square(x)\n{\n    return x * x;\n}\n\nfn void test()\n{\n    square(\"hello\"); // Error: cannot multiply \"hello\"\n    int a = 1;\n    square(&a); // Error: cannot multiply '&a'\n}\n```\n\n----------------------------------------\n\nTITLE: Using Base64 and Hex Data Literals in C3\nDESCRIPTION: Shows how to use Base64 and hexadecimal data literals in C3 to initialize character arrays at compile time.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\";\n\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n```\n\n----------------------------------------\n\nTITLE: Handling void! Function Returns in C3\nDESCRIPTION: Illustrates how to handle Excuses from void! functions using the @catch macro, as void! cannot be represented as a variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nfn void! test() \n{\n    return IoError.FILE_NOT_FOUND?;\n}\n\nanyfault excuse = @catch(test());\n```\n\n----------------------------------------\n\nTITLE: Testing the C3 Compiler with Hello World Example\nDESCRIPTION: Command to test the newly built C3 compiler by compiling and running a hello world example program. This verifies that the compiler works correctly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ ./c3c compile-run ../resources/testfragments/helloworld.c3\n```\n\n----------------------------------------\n\nTITLE: Implementing Foreach Loops in C3\nDESCRIPTION: Demonstrates two foreach loop examples in C3. The first iterates over a slice of floats, printing each index and value. The second modifies the values in-place by using a reference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n// Prints the values in the slice.\nfn void example_foreach(float[] values)\n{\n    foreach (index, value : values)\n    {\n        io::printfn(\"%d: %f\", index, value);\n    }\n}\n\n// Updates each value in the slice\n// by multiplying it by 2.\nfn void example_foreach_by_ref(float[] values)\n{\n    foreach (&value : values)\n    {\n        *value *= 2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: If Statement Syntax\nDESCRIPTION: Defines the syntax for an if statement in C3, which conditionally executes a statement based on the evaluation of a condition expression. It supports an optional label and an else clause.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\n\"if_stmt            ::= \\\"if\\\" (label \":\")? \\\"(\\\" cond_expr \\\")\\\" if_body\\nif_body            ::= non_compound_stmt | compound_stmt else_clause? | \\\"{\\\" switch_body \\\"}\\\"\\nelse_clause        ::= \\\"else\\\" (if_stmt | compound_stmt)\"\n```\n\n----------------------------------------\n\nTITLE: Using Deferred Execution in C3\nDESCRIPTION: This snippet showcases the defer statement in C3, allowing functions or actions to be executed upon scope exit. It illustrates both standard and error-deferred behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int x)\n{\n    defer io::printn();\n    defer io::print(\"A\");\n    if (x == 1) return;\n    {\n        defer io::print(\"B\");\n        if (x == 0) return;\n    }\n    io::print(\"!\");\n}\n\nfn void main()\n{\n    test(1); // Prints \"A\"\n    test(0); // Prints \"BA\"\n    test(10); // Prints \"B!A\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining String Type in C3\nDESCRIPTION: Defines the String type as an inline character array, which is the typical string type to use in C3. It supports slicing, comparison, and length access via the .len operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\ntypedef String = inline char[];\n```\n\n----------------------------------------\n\nTITLE: Including and Using Generic Modules\nDESCRIPTION: Shows how to import and use generic modules, including creating type aliases and calling generic functions with specific type parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport foo_test;\n\nalias FooFloat = Foo {float, double};\nalias test_float = foo_test::test {float, double};\n\n...\n\nFooFloat f;\nFoo {int, double} g;\n\n...\n\ntest_float(1.0, &f);\nfoo_test::test {int, double} (1.0, &g);\n```\n\n----------------------------------------\n\nTITLE: Threading Primitives and Functions (C3)\nDESCRIPTION: Type definitions and functions for thread management, including mutexes, condition variables, and thread creation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_112\n\nLANGUAGE: c3\nCODE:\n```\ntypedef ConditionVariable = NativeConditionVariable;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Mutex = NativeMutex;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef MutexType = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef OnceFlag = NativeOnceFlag;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef RecursiveMutex = inline Mutex;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Thread = NativeThread;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef TimedMutex = inline Mutex;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef TimedRecursiveMutex = inline Mutex;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault ThreadFault\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.broadcast(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.destroy(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.init(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.signal(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.wait(&cond, Mutex* mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? ConditionVariable.wait_timeout(&cond, Mutex* mutex, ulong timeout)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Mutex.destroy(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Mutex.init(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Mutex.lock(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool Mutex.try_lock(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Mutex.unlock(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void OnceFlag.call(&flag, OnceFn func)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? RecursiveMutex.init(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Thread.create(&thread, ThreadFn thread_fn, void* arg)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? Thread.detach(thread)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool Thread.equals(thread, Thread other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int? Thread.join(thread)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? TimedMutex.init(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? TimedMutex.lock_timeout(&mutex, ulong ms)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? TimedRecursiveMutex.init(&mutex)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? TimedRecursiveMutex.lock_timeout(&mutex, ulong ms)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Thread current()\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void exit(int result)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? sleep(Duration d) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? sleep_ms(ulong ms) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? sleep_ns(NanoDuration ns) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void yield()\n```\n\n----------------------------------------\n\nTITLE: Splitting String in C3\nDESCRIPTION: Function to split a string into an array of strings based on a specified needle string, with optional maximum split count and allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nfn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Optional Expression Handling in C3\nDESCRIPTION: Demonstrates how Optionals affect expressions and their resulting types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void main(String[] args)\n{\n    // Returns Optional with result of type `int` or an Excuse\n    int? first_optional = 7;\n\n    // This is Optional too:\n    int? second_optional = first_optional + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation with Defer Catch\nDESCRIPTION: Demonstrates using defer catch for memory cleanup when handling errors in memory allocation operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::core::mem;\n\nfn char[]! test()\n{\n    char[] data = mem::new_array(char, 12)!;\n    \n    defer (catch err) \n    {\n        io::printfn(\"Excuse found: %s\", err)\n        (void)free(data);\n    }\n\n    return IoError.FILE_NOT_FOUND?; \n}\n```\n\n----------------------------------------\n\nTITLE: Array Allocation in C3\nDESCRIPTION: Shows how to allocate arrays on the heap using new_array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nint[] ints = mem::new_array(int, 100); // Allocated int[100] on the heap, zero initialized.\n```\n\n----------------------------------------\n\nTITLE: File Reading with Defer in C3\nDESCRIPTION: Example of using defer for file cleanup, ensuring files are properly closed after operations complete or fail.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn char[]? file_read(String filename, char[] buffer)\n{\n    File file = file::open(filename, \"r\")!;\n\n    defer {\n        io::printn(\"File was found, close the file\");\n        if (catch excuse = file.close())\n        {\n            io::printfn(\"Fault closing file: %s\", excuse);\n        }\n    }\n\n    file.read(buffer)!;\n    return buffer;\n}\n```\n\n----------------------------------------\n\nTITLE: Function Contracts Example\nDESCRIPTION: Demonstrates the use of function contracts with require and ensure conditions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param foo `the number of foos`\n @require foo > 0, foo < 1000\n @return `number of foos x 10`\n @ensure return < 10000, return > 0\n*>\nfn int test_foo(int foo)\n{\n    return foo * 10;\n}\n```\n\n----------------------------------------\n\nTITLE: Array Slicing and Function Calls in C3\nDESCRIPTION: Demonstrates C3's array handling capabilities including implicit conversions and array slicing syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint x[100] = ...;\nint y[30] = ...;\nint z[15] = ...;\nsort_my_array(x, 100);\nsort_my_array(y, 30);\nsort_my_array(z + 1, 10);\n```\n\nLANGUAGE: c3\nCODE:\n```\nint[100] x = ...;\nint[30] y = ...;\nsort_my_array(&x);\nsort_my_array(&y);\nsort_my_array(z[1..10]);\n```\n\n----------------------------------------\n\nTITLE: Splat Operator Usage\nDESCRIPTION: Shows different ways to use the splat operator (...) with arrays and slices in function calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_splat()\n{\n   int[] x = { 1, 2, 3 };\n   va_singletyped(...x);\n}\n```\n\n----------------------------------------\n\nTITLE: Using For Loop in C3\nDESCRIPTION: This snippet showcases both a standard for loop and an infinite for loop in C3. It initializes an integer for looping and prints its value using io::printfn.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void example_for() \n{\n    // the for-loop is the same as C99. \n    for (int i = 0; i < 10; i++) \n    {\n        io::printfn(\"%d\", i);\n    }\n\n    // also equal\n    for (;;) \n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Building a C3 Project Without Running\nDESCRIPTION: Use the c3c build command to compile a C3 project without executing it. This creates the executable in the build directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nc3c build\n```\n\n----------------------------------------\n\nTITLE: Error handling and debugging functions in C3\nDESCRIPTION: Functions for handling errors, generating panic messages, and debugging. These utilities support error reporting and debugging in different runtime environments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_30\n\nLANGUAGE: c3\nCODE:\n```\nfn void default_panic(String message, String file, String function, uint line) @if(!env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void default_panic(String message, String file, String function, uint line) @if(env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void panicf(String fmt, String file, String function, uint line, args...)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool print_backtrace(String message, int backtraces_to_ignore) @if(env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void unreachable(String string = \"Unreachable statement reached.\", ...) @builtin @noreturn\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void unsupported(String string = \"Unsupported function invoked\") @builtin @noreturn\n```\n\n----------------------------------------\n\nTITLE: Enum and Switch Statement in C3\nDESCRIPTION: This snippet defines an enumeration type and demonstrates switch-case statements that allow for usage of implicit breaks and case scopes in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nenum Height : uint\n{\n    LOW,\n    MEDIUM,\n    HIGH,\n}\n\nfn void demo_enum(Height h)\n{\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case HIGH:\n            io::printn(\"High\");\n    }\n\n    // This also works\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case Height.HIGH:\n            io::printn(\"High\");\n    }\n\n    // Completely empty cases are not allowed.\n    switch (h)\n    {\n        case LOW:\n            break; // Explicit break required, since switches can't be empty.\n        case MEDIUM:\n            io::printn(\"Medium\");\n        case HIGH:\n            break;\n    }\n\n    // special checking of switching on enum types\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n        case HIGH:\n            break;\n        default:    // warning: default label in switch which covers all enumeration value\n            break;\n    }\n\n    // Using \"nextcase\" will fallthrough to the next case statement,\n    // and each case statement starts its own scope.\n    switch (h)\n    {\n        case LOW:\n            int a = 1;\n            io::printn(\"A\");\n            nextcase;\n        case MEDIUM:\n            int a = 2;\n            io::printn(\"B\");\n            nextcase;\n        case HIGH:\n            // a is not defined here\n            io::printn(\"C\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: POSIX-specific OS Functions (C3)\nDESCRIPTION: Type definitions, structures, and functions for POSIX-compliant operating systems, including directory operations and process status handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_107\n\nLANGUAGE: c3\nCODE:\n```\ntypedef DIRPtr = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_t = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Posix_dirent\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Posix_spawn_file_actions_t\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Posix_spawnattr_t\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn CInt backtrace(void** buffer, CInt size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt wEXITSTATUS(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool wIFCONTINUED(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool wIFEXITED(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool wIFSIGNALED(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool wIFSTOPPED(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt wSTOPSIG(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt wTERMSIG(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt wWCOREDUMP(CInt status)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt w_EXITCODE(CInt ret, CInt sig)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CInt w_STOPCODE(CInt sig)\n```\n\n----------------------------------------\n\nTITLE: HashMap Implementation in C3\nDESCRIPTION: Generic hash map implementation with key-value storage, supporting operations like get, set, remove and various collection views. Includes iteration macros and initialization options.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nstruct HashMap\n\nfn void HashMap.clear(&map)\nfn void HashMap.free(&map)\nfn Value? HashMap.get(&map, Key key) @operator([])\nfn Entry*? HashMap.get_entry(&map, Key key)\nfn Value*? HashMap.get_ref(&map, Key key)\nfn bool HashMap.has_key(&map, Key key)\nfn bool HashMap.has_value(&map, Value v) @if(VALUE_IS_EQUATABLE)\n```\n\n----------------------------------------\n\nTITLE: Defining Anonymous Functions in C3\nDESCRIPTION: This snippet showcases the definition and usage of anonymous functions in C3. It includes examples of applying a transformation function to an array of integers using both short and regular function syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\ndef IntTransform = fn int(int);\nfn void apply(int[] arr, IntTransform t)\n{\n    foreach (&i : arr) *i = t(*i);\n}\nfn void main()\n{\n    int[] x = { 1, 2, 5 };\n    // Short syntax with inference:\n    apply(x, fn (i) => i * i);\n    // Regular syntax without inference: \n    // apply(x, fn int(int i) { return i * i; });\n    // Prints [1, 4, 25]\n    io::printfn(\"%s\", x);        \n}\n```\n\n----------------------------------------\n\nTITLE: Enums with Multiple Associated Values in C3\nDESCRIPTION: This code snippet demonstrates associating multiple static values with each enum value. The enum `State` has a description, an active status, and a `Position`. The code shows how to access these associated values using dot notation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Position\n{\n    int x;\n    int y;\n}\n\nenum State : int (String desc, bool active, Position pos)\n{\n    WAITING    = { \"waiting\", false, { 1, 2} },\n    RUNNING    = { \"running\", true,  {12,22} },\n    TERMINATED = { \"ended\",   false, { 0, 0} },\n}\n\nfn void main()\n{\n    State process = State.RUNNING;\n    if (process.active)\n    {\n        io::printfn(\"Process is: %s\", process.desc);\n        io::printfn(\"Position x: %d\", process.pos.x);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Module Parameters in C3\nDESCRIPTION: Shows how to declare a generic module with multiple type parameters. TypeA, TypeB, and TypeC are generic parameters that can be used within the module.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n// TypeA, TypeB, TypeC are generic parameters.\nmodule vector {TypeA, TypeB, TypeC};\n```\n\n----------------------------------------\n\nTITLE: Implementing If Statement in C3\nDESCRIPTION: Demonstrates the basic if-else statement syntax in C3. The function takes an integer parameter and executes different code blocks based on the condition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void if_example(int a)\n{\n    if (a > 0)\n    {\n        // ..\n    }\n    else\n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Object Creation Functions in C3\nDESCRIPTION: Functions for creating new objects and arrays with proper memory allocation and initialization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_36\n\nLANGUAGE: c3\nCODE:\n```\nmacro new(Allocator allocator, $Type, ...) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_array(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_array_try(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TempAllocator*? new_temp_allocator(usz size, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_try(Allocator allocator, $Type, ...) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_with_padding(Allocator allocator, $Type, usz padding) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* realloc(Allocator allocator, void* ptr, usz new_size) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? realloc_aligned(Allocator allocator, void* ptr, usz new_size, usz alignment) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? realloc_try(Allocator allocator, void* ptr, usz new_size) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro TempAllocator* temp()\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Macros in C3\nDESCRIPTION: Macros for common memory allocation patterns, including aligned allocation, array allocation, and type-safe allocations with error handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_34\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? @aligned_alloc(#alloc_fn, usz bytes, usz alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? @aligned_free(#free_fn, void* old_pointer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void*? @aligned_realloc(#calloc_fn, #free_fn, void* old_pointer, usz bytes, usz alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc(Allocator allocator, $Type) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_array(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_array_aligned(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_array_try(Allocator allocator, $Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_try(Allocator allocator, $Type) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_with_padding(Allocator allocator, $Type, usz padding) @nodiscard\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Arrays with foreach in C3\nDESCRIPTION: Demonstrates how to use foreach loops to iterate over arrays in C3, including by-copy and by-reference iterations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    int[4] arr = { 1, 2, 3, 5 };\n    foreach (item : arr)\n    {\n        io::printfn(\"item: %s\", item);\n    }\n\n    // Or equivalently, writing the type:\n    foreach (int x : arr)\n    {\n        /* ... */\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Function Pointers in C3\nDESCRIPTION: This snippet demonstrates how to define and use function pointers in C3 using `alias`. It shows how to declare a function pointer type, assign a function to it, and call the function through the pointer. It also illustrates the use of default arguments in function pointers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nalias Callback = fn void(int value);\nCallback callback = &test;\n\nfn void test(int a) { /* ... */ }\n```\n```\n\n----------------------------------------\n\nTITLE: Varargs Function Examples\nDESCRIPTION: Demonstrates different types of variable arguments (varargs) implementations in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void va_singletyped(int... args)\n{\n    /* args has type int[] */\n}\n\nfn void va_variants_explicit(any*... args)\n{\n    /* args has type any*[] */\n}\n\nfn void va_variants_implicit(args...)\n{\n    /* args has type any*[] */\n}\n\nextern fn void va_untyped(...); // only used for extern C functions\n\nfn void test()\n{\n    va_singletyped(1, 2, 3);\n\n    int x = 1;\n    any* v = &x;\n    va_variants_explicit(&&1, &x, v);\n\n    va_variants_implicit(1, x, \"foo\");\n\n    va_untyped(1, x, \"foo\");\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Custom Attributes in C3\nDESCRIPTION: Shows how to create a user-defined attribute @MyAttribute that combines @noreturn and @inline attributes. The example demonstrates applying this custom attribute to a function, which is equivalent to applying the individual attributes directly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/attributes.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nattrdef @MyAttribute = { @noreturn @inline };\n\n// The following two are equivalent:\nfn void foo() @MyAttribute { /* */ }\nfn void foo() @noreturn @inline { /* */ }\n```\n\n----------------------------------------\n\nTITLE: Working with Slices in C3\nDESCRIPTION: Demonstrates slice creation and conversion from arrays and pointers in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    int[4] arr = { 1, 2, 3, 4 };\n    int[4]* ptr = &arr;\n\n    // Assignments to slices\n    int[] slice1 = &arr;                // Implicit conversion\n    int[] slice2 = ptr;                 // Implicit conversion\n\n    // Assignments from slices\n    int[] slice3 = slice1;              // Assign slices from other slices\n    int* int_ptr = slice1;              // Assign from slice\n    int[4]* arr_ptr = (int[4]*)slice1;  // Cast from slice\n}\n```\n\n----------------------------------------\n\nTITLE: Using $alignof Function in C3\nDESCRIPTION: Shows how to use the $alignof compile-time function to get alignment of types and members.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nmodule test::bar;\n\nstruct Foo\n{\n    int x;\n    char[] y;\n}\nint g = 123;\n\n$alignof(Foo.x); // => returns 4\n$alignof(Foo.y); // => returns 8 on 64 bit\n$alignof(Foo);   // => returns 8 on 64 bit\n$alignof(g);     // => returns 4\n```\n\n----------------------------------------\n\nTITLE: Multiple Defer Execution Order in C3\nDESCRIPTION: Shows how multiple defer statements are executed in reverse order of declaration (last-to-first).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, defers execute in reverse order\");\n    defer io::printn(\"print second, defers execute in reverse order\");\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Struct Members in C3\nDESCRIPTION: This code demonstrates how to define a struct in C3 and access its members using dot notation. Dot notation can be used even with pointers to structs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Person  \n{\n    char age;\n    String name;\n}\n```\n```\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void test()\n{\n    Person p;\n    p.age = 21;\n    p.name = \"John Doe\";\n\n    io::printfn(\"%s is %d years old.\", p.name, p.age);\n\n    Person* p_ptr_ = &p;\n    p_ptr.age = 20; // Ok!\n\n    io::printfn(\"%s is %d years old.\", p_ptr.name, p_ptr.age);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Switching on Any Type in C3\nDESCRIPTION: Demonstrates how to use a switch statement to check the type of an 'any' variable at runtime.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nswitch (my_any.type)\n{\n    case Foo.typeid:\n        ...\n    case Bar: // .typeid can be elided\n        ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints to Generic Modules\nDESCRIPTION: Demonstrates how to add compile-time constraints to generic modules using @require annotations to ensure type compatibility.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require $assignable(1, TypeB) && $assignable(1, TypeC)\n @require $assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)\n*>\nmodule vector {TypeA, TypeB, TypeC};\n\n/* .. code  .. */\n```\n\n----------------------------------------\n\nTITLE: Function Declaration in C3\nDESCRIPTION: Illustrates the new function declaration syntax using the 'fn' keyword in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nint foo(Foo *b, int x, void *z) { ... }\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int foo(Foo* b, int x, void* z) { ... }\n```\n\n----------------------------------------\n\nTITLE: POSIX Threading Interface in C3\nDESCRIPTION: Function declarations for the POSIX-specific threading and synchronization primitives in C3. Includes functions for mutex, condition variables, thread creation, and thread control.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_106\n\nLANGUAGE: c3\nCODE:\n```\nstruct NativeMutex\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.broadcast(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.destroy(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.init(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.signal(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.wait(&cond, NativeMutex* mtx)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.wait_timeout(&cond, NativeMutex* mtx, ulong ms)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.destroy(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.init(&self, MutexType type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool NativeMutex.is_initialized(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.lock(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.lock_timeout(&self, ulong ms)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool NativeMutex.try_lock(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.unlock(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void NativeOnceFlag.call_once(&flag, OnceFn func)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeThread.create(&thread, ThreadFn thread_fn, void* arg)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeThread.detach(thread)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool NativeThread.equals(thread, NativeThread other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! NativeThread.join(thread)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! native_sleep_nano(NanoDuration nano)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn NativeThread native_thread_current()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void native_thread_exit(int result)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void native_thread_yield()\n```\n\n----------------------------------------\n\nTITLE: Implementing GrowableBitSet Operations in C3\nDESCRIPTION: Defines a GrowableBitSet struct and associated methods for dynamic bit manipulation, including memory management and bit operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nstruct GrowableBitSet\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz GrowableBitSet.cardinality(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void GrowableBitSet.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool GrowableBitSet.get(&self, usz i) @operator([]) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz GrowableBitSet.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn GrowableBitSet* GrowableBitSet.new_init(&self, usz initial_capacity = 1, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void GrowableBitSet.set(&self, usz i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void GrowableBitSet.set_bool(&self, usz i, bool value) @operator([]=) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn GrowableBitSet* GrowableBitSet.temp_init(&self, usz initial_capacity = 1)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void GrowableBitSet.unset(&self, usz i)\n```\n\n----------------------------------------\n\nTITLE: Switching on the 'any' Type in C3\nDESCRIPTION: Shows different methods of switching on the 'any' type in C3, including unwrapping switch, assignment switch, and direct unwrapping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(any z)\n{\n    // Unwrapping switch\n    switch (z)\n    {\n        case int:\n            // z is unwrapped to int* here\n        case double:\n            // z is unwrapped to double* here\n    }\n    // Assignment switch\n    switch (y = z)\n    {\n        case int:\n            // y is int* here\n    }\n    // Direct unwrapping to a value is also possible:\n    switch (w = *z)\n    {\n        case int:\n            // w is int here\n    }\n    // Finally, if we just want to deal with the case\n    // where it is a single specific type:\n    if (z.type == int.typeid)\n    {\n        // This is safe here:\n        int* a = (int*)z;\n    }\n    if (try b = *anycast(z, int))\n    {\n        // b is an int:\n        foo(b * 3);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Stack with Different Types in C3\nDESCRIPTION: Demonstrates how to use the generic stack implementation with different types (int and double), showing type instantiation and method calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\ndef IntStack = Stack(<int>);\n\nfn void test()\n{\n    IntStack stack;\n    stack.push(1);\n    stack.push(2);\n    // Prints pop: 2\n    io::printfn(\"pop: %d\", stack.pop());\n    // Prints pop: 1\n    io::printfn(\"pop: %d\", stack.pop());\n    \n    Stack(<double>) dstack;\n    dstack.push(2.3);\n    dstack.push(3.141);\n    dstack.push(1.1235);\n    // Prints pop: 1.1235\n    io::printfn(\"pop: %f\", dstack.pop());\n}\n```\n\n----------------------------------------\n\nTITLE: C3 System and Memory Operations\nDESCRIPTION: Low-level system operations including memory manipulation, volatile operations, and system calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/builtins.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n$$trap()            // Emit trap instruction\n$$unreachable()     // Insert unreachable annotation\n$$stacktrace()      // Get current callstack reference\n$$volatile_store()  // Volatile store operation\n$$volatile_load()   // Volatile load operation\n$$memcpy()         // Memory copy operation\n$$memset()         // Memory set operation\n$$prefetch()       // Prefetch memory location\n$$sysclock()       // Access cycle counter\n$$syscall()        // Perform system call\n```\n\n----------------------------------------\n\nTITLE: Foreach Loop for Array in C3\nDESCRIPTION: This snippet demonstrates how to iterate over an array of float values using both normal and reference foreach loops. It prints the index and value while traversing the array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n// Prints the values in the slice.\nfn void example_foreach(float[] values) \n{\n    foreach (index, value : values) \n    {\n        io::printfn(\"%d: %f\", index, value);\n    }\n}\n\n// Updates each value in the slice\n// by multiplying it by 2.\nfn void example_foreach_by_ref(float[] values) \n{\n    foreach (&value : values) \n    {\n        *value *= 2;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Time Fibonacci Implementation in C3\nDESCRIPTION: Shows how to implement fibonacci calculation at compile time using recursive macros.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nmacro long @fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return @fib($n - 1) + @fib($n - 2);\n    $endif\n}\n```\n\n----------------------------------------\n\nTITLE: Using Function Pointers in C3\nDESCRIPTION: This snippet defines a function pointer in C3 and provides an example of how to use it to call a callback function. It showcases parameter passing through pointers effectively.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nmodule demo;\n\ndef Callback = fn int(char* text, int value);\n\nfn int my_callback(char* text, int value) \n{\n    return 0;\n}\n\nCallback cb = &my_callback;\n\nfn void example_cb() \n{\n    int result = cb(\"demo\", 123);\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing While Loop in C3\nDESCRIPTION: This snippet illustrates the use of a while loop in C3, mimicking behavior found in C. It decrements a variable until it reaches zero and also includes a declaration-style while loop.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void example_while() \n{\n    // again exactly the same as C\n    int a = 10;\n    while (a > 0) \n    {\n        a--;\n    }\n\n    // Declaration \n    while (Point* p = getPoint()) \n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Error Handling with Catch Statement\nDESCRIPTION: Shows how to handle Optional errors using catch statement and return an IoError excuse.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void! test()\n{\n    // Return an Excuse by adding '?' after the fault.\n    return IoError.FILE_NOT_FOUND?; \n}\n\nfn void main(String[] args)\n{\n    // If the Optional is empty, assign the\n    // Excuse to a variable: \n    if (catch excuse = test())\n    {\n        io::printfn(\"test() gave an Excuse: %s\", excuse);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Element at' Operator ([]) in C3\nDESCRIPTION: This snippet demonstrates how to implement the '[]' operator for a custom type Foo, allowing array-like access syntax. The operator takes an unsigned size type (usz) as an index and returns a double value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/operator-overloading.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    double[] x;\n}\n\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Stringification in C3 Macros\nDESCRIPTION: Demonstrates how C3 handles stringification in macros, using the $stringify function for converting expressions to strings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#define CHECK(x) do { if (!x) abort(#x); } while(0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @check(#expr)\n{\n    if (!#expr) abort($stringify(#expr));\n}\n```\n\n----------------------------------------\n\nTITLE: Using the 'Any' Type for Variants in C3\nDESCRIPTION: The snippet shows how to use the 'any' type in C3 to create a variant that holds a 'typeid' and a 'void*' pointer. It demonstrates safe and unsafe ways to cast and manipulate the contained value using 'anycast' and type checks.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void main()\n{\n    int x;\n    any y = &x;\n    int* w = (int*)y;                // Returns the pointer to x\n    double* z_bad = (double*)y;      // Don't do this!\n    double! z = anycast(y, double);  // The safe way to get a value\n    if (y.type == int.typeid)\n    {\n        // Do something if y contains an int*\n    }\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(any z)\n{\n    // Unwrapping switch\n    switch (z)\n    {\n        case int: \n            // z is unwrapped to int* here\n        case double:\n            // z is unwrapped to double* here\n    }\n    // Assignment switch\n    switch (y = z)\n    {\n        case int:\n            // y is int* here\n    }\n    // Direct unwrapping to a value is also possible:\n    switch (w = *z)\n    {\n        case int:\n            // w is int here\n    }\n    // Finally, if we just want to deal with the case\n    // where it is a single specific type:\n    if (z.type == int.typeid)\n    {\n        // This is safe here:\n        int* a = (int*)z;\n    }\n    if (try b = *anycast(z, int))\n    {\n        // b is an int:\n        foo(b * 3);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Modules in C3\nDESCRIPTION: This snippet shows how to import another module in C3 using the `import` keyword. It also demonstrates that importing a module automatically imports its sub-modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nmodule some::foo;\nfn void test() {}\n```\n\n----------------------------------------\n\nTITLE: Running C3 Compiler on Windows\nDESCRIPTION: Command to compile a C3 program using the c3c compiler after setting up the environment variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile ./hello.c3\n```\n\n----------------------------------------\n\nTITLE: Sorting Functions (C3)\nDESCRIPTION: Macros and functions for sorting and searching arrays, including quicksort and binary search implementations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_111\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @is_comparer(#cmp, #list)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz @len_from_list(&list)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz binarysearch(list, x, cmp = null) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro quicksort(list, cmp = null) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void qsort(Type list, isz low, isz high, Comparer cmp)\n```\n\n----------------------------------------\n\nTITLE: Defining an Enum in C3\nDESCRIPTION: This snippet defines an enum named `State` with three possible values: `WAITING`, `RUNNING`, and `TERMINATED`. It demonstrates how to access enum values using the enum's name as a namespace and how to declare a variable of the enum type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum State : int\n{\n    WAITING,\n    RUNNING,\n    TERMINATED\n}\n\n// Access enum values via:\nState current_state = State.WAITING;\n```\n```\n\n----------------------------------------\n\nTITLE: OS File System Operations in C3\nDESCRIPTION: Platform-agnostic operating system operations for file system interaction, including directory operations and file metadata queries.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_57\n\nLANGUAGE: c3\nCODE:\n```\nmacro String? getcwd(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? native_chdir(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool native_file_or_dir_exists(String path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_file_size(String path) @if(!env::WIN32 && !env::DARWIN)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_file_size(String path) @if(env::DARWIN)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_file_size(String path) @if(env::WIN32)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool native_is_dir(String path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool native_is_file(String path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool? native_mkdir(Path path, MkdirPermissions permissions)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool? native_rmdir(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_stat(Stat* stat, String path) @if(env::DARWIN || env::LINUX)\n```\n\n----------------------------------------\n\nTITLE: Using Splat\nOperator in C3 Function Calls\nDESCRIPTION: Demonstrates the use of the splat operator (...) to pass arguments or slices in functions, facilitating dynamic argument handling. This snippet shows how to pass array-like data conveniently and intuitively.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void va_singletyped(int... args) { \n    io::printfn(\"%s\", args); \n}\nfn void main() \n{\n    int[2] arr = {1, 2};\n    va_singletyped(...arr); \n}\n\n```\n\n----------------------------------------\n\nTITLE: Process Management Functions (C3)\nDESCRIPTION: Structures and functions for managing subprocesses, including creation, termination, and I/O operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_108\n\nLANGUAGE: c3\nCODE:\n```\nfault SubProcessResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct SubProcess\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool SubProcess.destroy(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? SubProcess.is_running(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn CInt? SubProcess.join(&self) @if(env::POSIX)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn CInt? SubProcess.join(&self) @if(env::WIN32)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? SubProcess.read_stderr(&self, char* buffer, usz size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? SubProcess.read_stdout(&self, char* buffer, usz size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File SubProcess.stdout(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? SubProcess.terminate(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn SubProcess? create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::POSIX)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn SubProcess? create(String[] command_line, SubProcessOptions options = {}, String[] environment = {}) @if(env::WIN32)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? execute_stdout_to_buffer(char[] buffer, String[] command_line, SubProcessOptions options = {}, String[] environment = {})\n```\n\n----------------------------------------\n\nTITLE: Named Arguments with Default Values\nDESCRIPTION: Shows function declaration and usage with both named arguments and default values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_named_default(int times = 1, double data = 3.0, bool dummy = false)\n{\n    for (int i = 0; i < times; i++)\n    {\n        io::printfn(\"Hello %f\", i + data);\n    }\n}\n\nfn void test()\n{\n    // Named only\n    test_named_default(times: 10, data: 3.5);\n\n    // Unnamed and named\n    test_named_default(3, dummy: false);\n}\n```\n\n----------------------------------------\n\nTITLE: File Reading with Defer\nDESCRIPTION: Example of using defer for file handling cleanup. Shows how to ensure file handles are properly closed after reading operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn char[]! file_read(String filename, char[] buffer)\n{   \n    File file = file::open(filename, \"r\")!; \n\n    defer { \n        io::printn(\"File was found, close the file\"); \n        if (catch excuse = file.close()) \n        {\n            io::printfn(\"Fault closing file: %s\", excuse); \n        }\n    }\n\n    file.read(buffer)!; \n    return buffer;\n}\n```\n\n----------------------------------------\n\nTITLE: String Trimming in C3\nDESCRIPTION: Trims the specified characters from both ends of the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.trim(string, String to_trim);\n```\n\n----------------------------------------\n\nTITLE: Basic Static Initializers and Finalizers in C3\nDESCRIPTION: Shows the basic implementation of program startup and shutdown handlers using @init and @finalizer annotations. These functions run automatically at program start and end respectively.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nfn void run_at_startup() @init\n{\n    // Run at startup\n    some_function.init(512);\n}\n\nfn void run_at_shutdown() @finalizer\n{\n    some_thing.shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: BitSet Implementation in C3\nDESCRIPTION: Fixed-size bitset implementation providing bit manipulation operations with methods for getting, setting and unsetting bits, as well as counting set bits (cardinality).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nstruct BitSet\n\nfn usz BitSet.cardinality(&self)\nfn bool BitSet.get(&self, usz i) @operator([]) @inline\nfn usz BitSet.len(&self) @operator(len) @inline\nfn void BitSet.set(&self, usz i)\nfn void BitSet.set_bool(&self, usz i, bool value) @operator([]=) @inline\nfn void BitSet.unset(&self, usz i)\n```\n\n----------------------------------------\n\nTITLE: Working with Slices in C3\nDESCRIPTION: This snippet demonstrates how to create and assign slices in C3, including conversions between different array types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() \n{\n    int[4] arr = { 1, 2, 3, 4 };\n    int[4]* ptr = &arr;\n    \n    // Assignments to slices\n    int[] slice1 = &arr;                // Implicit conversion\n    int[] slice2 = ptr;                 // Implicit conversion\n\n    // Assignments from slices\n    int[] slice3 = slice1;              // Assign slices from other slices\n    int* int_ptr = slice1;              // Assign from slice\n    int[4]* arr_ptr = (int[4]*)slice1;  // Cast from slice\n}\n```\n\n----------------------------------------\n\nTITLE: Slicing Arrays in C3\nDESCRIPTION: Shows various ways to create slices from arrays using range syntax in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b = a[0 .. 4]; // The whole array as a slice.\n    int[] c = a[2 .. 3]; // { 50, 100 }\n}\n```\n\n----------------------------------------\n\nTITLE: Thread Pool Implementation\nDESCRIPTION: Generic thread pool implementation with initialization, destruction, and task queue management\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_119\n\nLANGUAGE: c3\nCODE:\n```\nstruct QueueItem\nstruct ThreadPool\nfn void? ThreadPool.destroy(&self)\nfn void? ThreadPool.init(&self)\nfn void? ThreadPool.push(&self, ThreadFn func, void* arg)\nfn void? ThreadPool.stop_and_destroy(&self)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Foreach with Enums in C3\nDESCRIPTION: Demonstrates using $foreach to iterate over enum values at compile time.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo_enum($SomeEnum)\n{\n    $foreach $x : $SomeEnum.values:\n        io::printfn(\"%d\", (int)$x);\n    $endforeach\n}\n\nenum MyEnum\n{\n    A,\n    B,\n}\n\nfn void test()\n{\n    foo_enum(MyEnum);\n    // Expands to ->\n    // io::printfn(\"%d\", (int)MyEnum.A);\n    // io::printfn(\"%d\", (int)MyEnum.B);\n}\n```\n\n----------------------------------------\n\nTITLE: Union Usage in C3\nDESCRIPTION: This code demonstrates how unions are used to store one of many possible values. Setting one member of the union makes it the active member. Accessing an inactive member leads to undefined behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void test()\n{\n    Integral i;\n    i.as_byte = 40; // Setting the active member to as_byte\n\n    i.as_int = 500; // Changing the active member to as_int\n\n    // Undefined behaviour: as_byte is not the active member,\n    // so this will probably print garbage.\n    io::printfn(\"%d\\n\", i.as_byte);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Control Flow and Statements\nDESCRIPTION: This snippet defines grammar rules for C3 programming language constructs including conditional statements, loops, switch statements, and other basic control flow mechanisms.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_5\n\nLANGUAGE: yacc\nCODE:\n```\nswitch_body case_stmt\n\t| switch_body default_stmt\n\t;\n\ncond_repeat\n\t: decl_or_expr\n\t| cond_repeat ',' decl_or_expr\n\t;\n\ncond\n\t: try_unwrap_chain\n\t| catch_unwrap\n\t| cond_repeat\n\t| cond_repeat ',' try_unwrap_chain\n\t| cond_repeat ',' catch_unwrap\n\t;\n\nelse_part\n\t: ELSE if_stmt\n\t| ELSE compound_statement\n\t;\n\nif_stmt\n\t: IF optional_label paren_cond '{' switch_body '}'\n\t| IF optional_label paren_cond '{' switch_body '}' else_part\n\t| IF optional_label paren_cond statement\n\t| IF optional_label paren_cond compound_statement else_part\n\t;\n\nexpr_list_eos\n\t: expression_list ';'\n\t| ';'\n\t;\n\ncond_eos\n\t: cond ';'\n\t| ';'\n\t;\n\nfor_cond\n\t: expr_list_eos cond_eos expression_list\n\t| expr_list_eos cond_eos\n\t;\n\nfor_stmt\n\t: FOR optional_label '(' for_cond ')' statement\n\t;\n\nparen_cond\n\t: '(' cond ')'\n\t;\n\nwhile_stmt\n\t: WHILE optional_label paren_cond statement\n\t;\n\ndo_stmt\n\t: DO optional_label compound_statement WHILE '(' expr ')' ';'\n\t| DO optional_label compound_statement ';'\n\t;\n\noptional_label_target\n\t: CONST_IDENT\n\t| empty\n\t;\n\ncontinue_stmt\n\t: CONTINUE optional_label_target ';'\n\t;\n\nbreak_stmt\n\t: BREAK optional_label_target ';'\n\t;\n\nnextcase_stmt\n\t: NEXTCASE CONST_IDENT ':' expr ';'\n\t| NEXTCASE expr ';'\n\t| NEXTCASE CONST_IDENT ':' type ';'\n\t| NEXTCASE type ';'\n\t| NEXTCASE ';'\n\t;\n\nforeach_var\n\t: optional_type '&' IDENT\n\t| optional_type IDENT\n\t| '&' IDENT\n\t| IDENT\n\t;\n\nforeach_vars\n\t: foreach_var\n\t| foreach_var ',' foreach_var\n\t;\n\nforeach_stmt\n\t: FOREACH optional_label '(' foreach_vars ':' expr ')' statement\n\t: FOREACH_R optional_label '(' foreach_vars ':' expr ')' statement\n\t;\n\ndefer_stmt\n\t: DEFER statement\n\t| DEFER TRY statement\n\t| DEFER CATCH statement\n\t;\n\nct_if_stmt\n\t: CT_IF constant_expr ':' opt_stmt_list CT_ENDIF\n\t| CT_IF constant_expr ':' opt_stmt_list CT_ELSE opt_stmt_list CT_ENDIF\n\t;\n\nassert_expr\n\t: try_unwrap_chain\n\t| expr\n\t;\n\nassert_stmt\n\t: ASSERT '(' assert_expr ')' ';'\n\t| ASSERT '(' assert_expr ',' expr ')' ';'\n\t;\n```\n\n----------------------------------------\n\nTITLE: Creating Function and Variable Aliases in C3\nDESCRIPTION: This snippet demonstrates how to create aliases for functions and variables in C3 using the 'alias' keyword.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo() { ... }\nint foo_var;\n\nalias bar = foo;\nalias bar_var = foo_var;\n\nfn void test()\n{\n  // These are the same:\n  foo();\n  bar();\n\n  // These access the same variable:\n  int x = foo_var;\n  int y = bar_var;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Code When Optional Has a Result in C3\nDESCRIPTION: Shows how to use 'if (try)' to execute code only when an Optional contains a result, demonstrating both direct use and assignment to a new variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    // 'optional_value' is a non-Optional variable inside the scope\n    if (try optional_value) \n    {\n        io::printfn(\"Result found: %s\", optional_value);    \n    } \n\n    // The Optional result is assigned to 'unwrapped_value' inside the scope\n    if (try unwrapped_value = optional_value)\n    {\n        io::printfn(\"Result found: %s\", unwrapped_value);    \n    }  \n}\n```\n\n----------------------------------------\n\nTITLE: Working with Multi-Dimensional Arrays in C3\nDESCRIPTION: Demonstrates declaration and initialization of multi-dimensional arrays in C3, comparing with C syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n// C3\n// Uses: <type>[<x-size>][<y-size>]\n// C3 declares the dimensions, inner-most to outer-most\nint[4][2] array = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n};\n\n// To match C we must invert the order of the dimensions\nint[2][4] array = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// C3 also supports Irregular arrays, for example:\nint[][4] array = {\n    { 1 },\n    { 2, 3 },\n    { 4, 5, 6 },\n    { 7, 8, 9, 10 },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Slices from Arrays in C3\nDESCRIPTION: Shows how to create a slice from an array in C3, demonstrating the relationship between arrays and slices.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nint[3] abc = { 1, 2, 3 };\nint[] slice = &abc;       // A slice pointing to abc with length 3\n```\n\n----------------------------------------\n\nTITLE: ZString to String View Conversion in C3\nDESCRIPTION: Creates a String view from a ZString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_48\n\nLANGUAGE: c3\nCODE:\n```\nfn String ZString.str_view(str);\n```\n\n----------------------------------------\n\nTITLE: Enums with Associated Values in C3\nDESCRIPTION: This code snippet demonstrates how to associate static values with each enum value in C3. The `State` enum is defined with a `String description`. It shows how to access these associated values using dot notation on an enum variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum State : int (String description)\n{\n    WAITING = \"waiting\",\n    RUNNING = \"running\",\n    TERMINATED = \"ended\",\n}\n\nfn void main()\n{\n    State process = State.RUNNING;\n    io::printfn(\"%s\", process.description);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Contract Definition Example\nDESCRIPTION: Illustrates contract syntax for functions including param constraints and ensures\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_5\n\nLANGUAGE: C3\nCODE:\n```\n<* @param ptr [&inout] Input/output parameter that cannot be null\n   @ensure return > 0\n   @pure\n   @return! ERROR_TYPE *>\n```\n\n----------------------------------------\n\nTITLE: Defining Core Built-in Types and Functions in C3\nDESCRIPTION: Defines various built-in types, enums, and functions for core operations in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nenum PrefetchLocality\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault CastResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault IteratorResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault SearchResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[] @as_char_view(&value) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro fault @catch(#expr) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @expect(#value, expected, $probability = 1.0) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @likely(bool #value, $probability = 1.0) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @ok(#expr) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @prefetch(void* ptr, PrefetchLocality $locality = VERY_NEAR, bool $write = false) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @scope(&variable; @body) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @swap(&a, &b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @unlikely(bool #value, $probability = 1.0) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint String.hash(String c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any.as_inner(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any.retype_to(&self, typeid type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any_make(void* ptr, typeid type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro anycast(any v, $Type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bitcast(expr, $Type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint bool.hash(bool b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint char.hash(char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint char[].hash(char[] c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int compare_to(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void default_panic(String message, String file, String function, uint line) @if(!env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void default_panic(String message, String file, String function, uint line) @if(env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro enum_by_name($Type, String enum_name) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool equals(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* get_frameaddress(int n)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* get_returnaddress(int n)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro greater(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro greater_eq(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ichar.hash(ichar c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint int.hash(int i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint int128.hash(int128 i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro less(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro less_eq(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint long.hash(long i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro max(x, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro min(x, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void panicf(String fmt, String file, String function, uint line, args...)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool print_backtrace(String message, int backtraces_to_ignore) @if(env::NATIVE_STACKTRACE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint short.hash(short s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro swizzle(v, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro swizzle2(v, v2, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint typeid.hash(typeid t)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.hash(uint i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint128.hash(uint128 i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ulong.hash(ulong i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void unreachable(String string = \"Unreachable statement reached.\", ...) @builtin @noreturn\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void unsupported(String string = \"Unsupported function invoked\") @builtin @noreturn\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ushort.hash(ushort s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint void*.hash(void* ptr)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Any-Switch Type Handling in C3\nDESCRIPTION: Shows how to use switch statements with 'any' type in C3. The example demonstrates how the switch converts the 'any' variable to appropriate pointer types based on each case clause, allowing type-based conditional processing.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\nany a = abc();\nswitch (a)\n{\n    case int:\n        int b = *a;   // a is int*\n    case float:\n        float z = *a; // a is float*\n    case Bar:\n        Bar f = *a;   // a is Bar*\n    default:\n        // a is not unwrapped\n}\n```\n\n----------------------------------------\n\nTITLE: Time Types and Operations\nDESCRIPTION: Core time-related type definitions and operations including duration, clock, and date/time manipulations\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_120\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Clock = ulong;\ntypedef Duration = long;\ntypedef NanoDuration (Printable) = long;\ntypedef Time = long;\n// ... [rest of time-related functions]\n```\n\n----------------------------------------\n\nTITLE: Scanner Implementation in C3\nDESCRIPTION: A utility for scanning input streams with pattern matching, with methods for initialization, reading, and scanning for patterns.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_51\n\nLANGUAGE: c3\nCODE:\n```\nstruct Scanner (InStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? Scanner.close(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[] Scanner.flush(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Scanner.init(&self, InStream stream, char[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Scanner.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? Scanner.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? Scanner.scan(&self, String pattern = \"\\n\")\n```\n\n----------------------------------------\n\nTITLE: Accessing Function Pointer Parameters in C3\nDESCRIPTION: Shows how to retrieve information about function pointer parameters using the 'paramsof' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nalias TestFunc = fn int(int x, double f);\nString s = TestFunc.paramsof[1].name; // \"f\"\ntypeid t = TestFunc.paramsof[1].type; // double.typeid\n```\n\n----------------------------------------\n\nTITLE: Using Generic Parameters in Module Implementation\nDESCRIPTION: Example showing how generic parameters can be used within a module to define structures and functions. Demonstrates using Type1 and Type2 in struct and function definitions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo_test {Type1, Type2};\n\nstruct Foo\n{\n   Type1 a;\n}\n\nfn Type2 test(Type2 b, Foo* foo)\n{\n   return foo.a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Do Statements in C3\nDESCRIPTION: Demonstrates the syntax for do statements in C3, which execute a block of code first, then test a condition to determine whether to continue. The block can optionally contain a while condition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\ndo_stmt            ::= \"do\" label? compound_stmt (\"while\" \"(\" cond_expr \")\")?  \";\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Function Features in C3\nDESCRIPTION: This snippet shows new function features in C3, including named arguments, typed varargs, and type methods.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_4\n\nLANGUAGE: C3\nCODE:\n```\n// Function with named arguments\nfn void foo(int name, int len) {}\nfoo(.name: a, .len: 2);\n\n// Typed varargs\nfn void bar(int... args) {}\n\n// Splatting an array into varargs\nbar(1, 2, ...arrayOfInts);\n\n// Any varargs\nfn void baz(args...) {}\n\n// Inline attribute\n@inline fn int add(int a, int b) { return a + b; }\n\n// Type method\nfn void String.print(String* self) {\n    // Implementation\n}\nstring.print();\n\n// Error handling with optional return\nfn int! mayFail() {\n    if (error) return IOError.FILE_NOT_FOUND?;\n    return 42;\n}\n```\n\n----------------------------------------\n\nTITLE: Runtime and Testing Framework in C3\nDESCRIPTION: Core runtime structures and functions for testing, benchmarking, and handling runtime features.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_38\n\nLANGUAGE: c3\nCODE:\n```\nstruct AnyRaw\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct BenchmarkUnit\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct SliceRaw\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TestContext\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TestUnit\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn BenchmarkUnit[] benchmark_collection_create(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int cmp_test_unit(TestUnit a, TestUnit b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool default_benchmark_runner()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool default_test_runner()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool run_benchmarks(BenchmarkUnit[] benchmarks)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool run_tests(TestUnit[] tests)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void set_benchmark_max_iterations(uint value) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void set_benchmark_warmup_iterations(uint value) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TestUnit[] test_collection_create(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_panic(String message, String file, String function, uint line)\n```\n\n----------------------------------------\n\nTITLE: Supporting Optional Returns in C3 Functions\nDESCRIPTION: Illustrates how to utilize optional return types in C3 marked by `!`, allowing functions to return multiple types based on conditions, including errors or exceptions. This snippet demonstrates using optionals, chaining, handling defaults, and error propagation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn double! test_error()\n{\n    double val = random_value();\n    if (val >= 0.2) return SomeError.BAD_JOSS_ERROR?;\n    if (val > 0.5) return OtherError.BAD_LUCK_ERROR?;\n    return val;\n}\n\nfn void test()\n{\n    io::printfn(\"%d\", test_error());\n    double x = (test_error() + test_error()) ?? 100;  \n    io::printfn(\"%d\", x);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Enum Values in C3\nDESCRIPTION: Demonstrates how to retrieve the values of an enum using the 'values' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nenum FooEnum\n{\n    BAR,\n    BAZ\n}\nString x = FooEnum.values[1].nameof; // \"BAR\"\n```\n\n----------------------------------------\n\nTITLE: Fixed Array Behavior in C3\nDESCRIPTION: Shows how fixed arrays in C3 have value semantics and don't decay to pointers, unlike C. Demonstrates various array operations and conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint[3] a = { 1, 2, 3 };\nint[4]* b = &a; // No conversion\nint* c = a; // ERROR\nint* d = &a; // Valid implicit conversion\nint* e = b; // Valid implicit conversion\nint[3] f = a; // Copy by value!\n```\n\n----------------------------------------\n\nTITLE: Implementing For Loops in C3\nDESCRIPTION: Shows two examples of for loops in C3. The first is a standard C99-style loop, and the second is an infinite loop. It demonstrates loop initialization, condition checking, and iteration.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void example_for()\n{\n    // the for-loop is the same as C99.\n    for (int i = 0; i < 10; i++)\n    {\n        io::printfn(\"%d\", i);\n    }\n\n    // also equal\n    for (;;)\n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Atomic Operations Interface\nDESCRIPTION: Atomic memory operation functions for thread-safe operations including compare-exchange and fetch operations\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nstruct Atomic\nmacro fetch_add(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\nmacro fetch_sub(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n\n----------------------------------------\n\nTITLE: Parameter Annotation Edge Case Example\nDESCRIPTION: Demonstrates a potential issue with parameter annotations where the compiler might not detect incorrect usage of an [in] parameter through indirect function calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void bad_func(int* i)\n{\n    *i = 2;\n}\n\n<*\n @param [&in] i\n*>\nfn void lying_func(int* i)\n{\n    bad_func(i); // The compiler might not check this!\n}\n\nfn void test()\n{\n    int a = 1;\n    lying_func(&a);\n    io::printf(\"%d\", a); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: String to WString Conversion in C3\nDESCRIPTION: Converts a String to a WString using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_44\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_wstring(s, Allocator allocator);\n```\n\n----------------------------------------\n\nTITLE: TCP Socket API in C3\nDESCRIPTION: TCP socket API for creating client and server sockets in C3. Provides functions for establishing connections, accepting connections, and listening for incoming connections with various options.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_97\n\nLANGUAGE: c3\nCODE:\n```\ntypedef TcpServerSocket = inline Socket;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef TcpSocket = inline Socket;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpSocket? accept(TcpServerSocket* server_socket)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpSocket? connect(String host, uint port, Duration timeout = 0, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpSocket? connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpSocket? connect_async_to(AddrInfo* ai, SocketOption... options)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpSocket? connect_to(AddrInfo* ai, SocketOption... options)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpServerSocket? listen(String host, uint port, uint backlog, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TcpServerSocket? listen_to(AddrInfo* ai, uint backlog, SocketOption... options)\n```\n\n----------------------------------------\n\nTITLE: Basic Vector Arithmetic Operations in C3\nDESCRIPTION: Demonstrates elementwise arithmetic operations between vectors and how to initialize vectors with values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/vectors.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[<2>] a = { 23, 11 };\nint[<2>] b = { 2, 1 };\nint[<2>] c = a * b;     // c = { 46, 11 }\n```\n\n----------------------------------------\n\nTITLE: Managing a Dynamic List in C\nDESCRIPTION: This snippet demonstrates the use of the std::collections::list module to manage a list of integers. It shows how to create a list, add an element, and free the list, emphasizing dynamic memory management in C.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/index.mdx#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nimport std::collections::list;\ndef MyIntList = List(<int>);\n\n...\n\nMyIntList list;\nlist.push(123);\nlist.free();\n```\n\n----------------------------------------\n\nTITLE: Performing Arithmetic Operations on Vectors in C3\nDESCRIPTION: Demonstrates element-wise arithmetic operations on vectors, including multiplication of two vectors and division of a vector by a scalar.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/vectors.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[<2>] a = { 23, 11 };\nint[<2>] b = { 2, 1 };\nint[<2>] c = a * b;     // c = { 46, 11 }\n\nint[<2>] d = { 21, 14 };\nint[<2>] e = d / 7;      // e = { 3, 2 }\nint[<2>] f = 4;          // f = { 4, 4 }\n```\n\n----------------------------------------\n\nTITLE: Function Pointers with Default Arguments in C3\nDESCRIPTION: This code shows how function pointers handle default arguments. The `alias` defines a default argument for the function pointer type `Callback`.  The `main` function then calls the function pointer with and without arguments, and also shows how named arguments work.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nalias Callback = fn void(int value = 1);\nfn void test(int a = 0) { /* ... */ }\n\nCallback callback = &test; // Ok\n\nfn void main()\n{\n    callback(); // Works, same as test(0);\n    test(); // Works, same as test(1);\n    callback(value: 3); // Works, same as test(3)\n    test(a: 4); // Works, same as test(4)\n    // callback(a: 3); // ERROR!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing an Interface in C3\nDESCRIPTION: Shows how to implement the 'MyName' interface for a struct 'Baz' with a dynamic method.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nstruct Baz (MyName)\n{\n    int x;\n}\n\n// Note how the first argument differs from the interface.\nfn String Baz.myname(Baz* self) @dynamic\n{\n    return \"I am Baz!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Path data types and enumerations in C3\nDESCRIPTION: Core data types and enumerations for path manipulation in C3, including directory permissions, path environment settings, error handling, and the main Path struct that implements the Printable interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_62\n\nLANGUAGE: c3\nCODE:\n```\nenum MkdirPermissions\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum PathEnv\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault PathResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Path (Printable)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Switch Statement Behavior in C3\nDESCRIPTION: This snippet illustrates C3's switch statement behavior, including implicit breaks and the use of the nextcase keyword for explicit fallthrough and case jumping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/changesfromc.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nswitch (h)\n{\n    case 1:\n        a = 1;\n        nextcase; // Fall through\n    case 2:\n        b = 123;\n    case 3:\n        a = 2;\n        nextcase 2; // Jump to case 2\n    default:\n        a = 111;\n}\n```\n\n----------------------------------------\n\nTITLE: String Copy in C3\nDESCRIPTION: Creates a copy of a String using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.copy(s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: C3 Variable Initialization Examples\nDESCRIPTION: Demonstrates different variable initialization patterns in C3. Shows default zero initialization for local variables, explicit opt-out of initialization using @noinit, and struct initialization variants. Includes examples for both primitive types and structs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/variables.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint x;               // x = 0\nint y @noinit;       // y is explicitly undefined and must be assigned before use.\n\nAStruct foo;         // foo is implicitly zeroed\nAStruct bar = {};    // bar is explicitly zeroed\nAStruct baz @noinit; // baz is explicitly undefined\n```\n\n----------------------------------------\n\nTITLE: Compile Time Type Introspection in C3\nDESCRIPTION: Example of compile time type introspection capabilities.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nusz foo_alignment = Foo.alignof;\nusz foo_member_count = Foo.membersof.len;\nString foo_name = Foo.nameof;\n```\n\n----------------------------------------\n\nTITLE: Implementing While Loops in C3\nDESCRIPTION: Shows two while loop examples in C3. The first is a standard decrementation loop, and the second demonstrates declaration within the loop condition, which is useful for resource management patterns.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void example_while()\n{\n    // again exactly the same as C\n    int a = 10;\n    while (a > 0)\n    {\n        a--;\n    }\n\n    // Declaration\n    while (Point* p = getPoint())\n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Copy Operations in C3\nDESCRIPTION: Shows how to copy memory between pointers with optional alignment and volatility.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nFoo* f = tmalloc(data_size);\nmem::copy(f, slice.ptr, size);\n```\n\n----------------------------------------\n\nTITLE: Automatic Optional Unwrapping in C3\nDESCRIPTION: Demonstrates automatic unwrapping of Optional values when using control flow statements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void! test() \n{\n    int! foo = unreliable_function();\n    if (catch excuse = foo) \n    {\n        // Return the excuse with `?` operator\n        return excuse?;\n    }\n    // Because the compiler knows 'foo' cannot\n    // be empty here, it is unwrapped to non-Optional\n    // 'int foo' in this scope:\n    io::printfn(\"foo: %s\", foo); // 7\n}\n```\n\n----------------------------------------\n\nTITLE: Atomic Operations\nDESCRIPTION: Atomic operations and memory ordering primitives for concurrent programming.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nstruct Atomic\nmacro fetch_add(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\nmacro fetch_sub(ptr, y, AtomicOrdering $ordering = SEQ_CONSISTENT, bool $volatile = false, usz $alignment = 0)\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation with @if Attributes in C3\nDESCRIPTION: This snippet illustrates how to use @if attributes for conditional compilation of functions and struct members at the top level in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo_win32() @if(env::WIN32)\n{\n    /* .... */\n}\n\nstruct Foo\n{\n    int a;\n    int b @if(env::NO_LIBC);\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Array-Like Types in C3\nDESCRIPTION: This snippet shows how to implement custom array-like types that support foreach iteration in C3 by using the @operator attribute.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nstruct DynamicArray\n{\n    usz count;\n    usz capacity;\n    int* elements;\n}\n\nmacro int DynamicArray.get(DynamicArray* arr, usz element) @operator([])\n{\n    return arr.elements[element];\n}\n\nmacro usz DynamicArray.count(DynamicArray* arr) @operator(len)\n{\n    return arr.count;\n}\n\nfn void DynamicArray.push(DynamicArray* arr, int value)\n{\n    arr.ensure_capacity(arr.count + 1);  // Function not shown in example.\n    arr.elements[arr.count++] = value;\n}\n\nfn void test()\n{\n    DynamicArray v;\n    v.push(3);\n    v.push(7);\n\n    // Will print 3 and 7\n    foreach (int i : v)\n    {\n        io::printfn(\"%d\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using $defined Function in C3\nDESCRIPTION: Demonstrates the use of $defined compile-time function to check if expressions are defined and valid.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\n$defined(Foo.x);     // => returns true\n$defined(Foo.z);     // => returns false\nint[2] abc;\n$defined(abc.len);   // => returns true\n$defined(abc.len()); // => returns false\n$defined((int)abc);  // => returns false\n// $defined(abc.len() + 1)  would be an error\n```\n\n----------------------------------------\n\nTITLE: Specifying Big Endian Bitstructs in C3\nDESCRIPTION: This code snippet demonstrates how to specify a big-endian bitstruct using the `@bigendian` attribute. It defines a `Test` bitstruct with two ushort fields and shows that using `@bigendian` reverses the byte order compared to the previous example. This influences how the bitstruct is interpreted when cast to a uint and how individual bytes are accessed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_30\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nbitstruct Test : uint @bigendian\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Named Arguments Function Example\nDESCRIPTION: Demonstrates the use of named arguments in function calls with multiple parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_named(int times, double data)\n{\n    for (int i = 0; i < times; i++)\n    {\n        io::printf(\"Hello %d\\n\", i + data);\n    }\n}\n\nfn void test()\n{\n    // Named only\n    test_named(times: 1, data: 3.0);\n\n    // Unnamed only\n    test_named(3, 4.0);\n\n    // Mixing named and unnamed\n    test_named(15, data: 3.141592);\n}\n```\n\n----------------------------------------\n\nTITLE: ByteWriter Implementation in C3\nDESCRIPTION: An implementation of OutStream for writing to byte arrays, with methods for initialization, writing, capacity management, and string view generation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_47\n\nLANGUAGE: c3\nCODE:\n```\nstruct ByteWriter (OutStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteWriter.destroy(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteWriter.ensure_capacity(&self, usz len) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteWriter* ByteWriter.init_with_buffer(&self, char[] data)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteWriter* ByteWriter.new_init(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteWriter.read_from(&self, InStream reader) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ByteWriter.str_view(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteWriter* ByteWriter.temp_init(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteWriter.write(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteWriter.write_byte(&self, char c) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Defer Try Failure Example in C3\nDESCRIPTION: Shows defer try behavior when an Optional contains an Excuse rather than a result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void? test()\n{\n    defer try io::printn(\"❌ defer try not run\");\n    return io::FILE_NOT_FOUND?;\n}\n\nfn void main(String[] args)\n{\n    if (catch err = test())\n    {\n        io::printfn(\"test() returned a fault: %s\", err);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Type Usage in C3\nDESCRIPTION: This code shows how to define and use optional types in C3 using the `!` suffix. An optional type can hold either a value of the specified type or an excuse (fault).  It also shows assigning an optional result to a normal variable using the rethrow operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nint! i;\ni = 5; // Assigning a real value to i.\ni = IOResult.IO_ERROR?; // Assigning an optional result to i.\nanyfault b = SearchError.MISSING;\nb = @catch(i); // Assign the Excuse in i to b (IO_ERROR) \n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Range and ExclusiveRange in C3\nDESCRIPTION: Defines Range and ExclusiveRange structures and their methods for representing ranges of values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nstruct ExclusiveRange (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Range (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool ExclusiveRange.contains(&self, Type value) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type ExclusiveRange.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ExclusiveRange.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ExclusiveRange.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ExclusiveRange.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ExclusiveRange.to_tstring(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Range.contains(&self, Type value) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type Range.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Range.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Range.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Range.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Range.to_tstring(&self)\n```\n\n----------------------------------------\n\nTITLE: Initializing and Operating on Vectors in C3\nDESCRIPTION: Demonstrates vector initialization and arithmetic operations in C3, showcasing SIMD-like parallel operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nint[<*>] a = { 1, 2 };\nint[<2>] b = { 3, 8 };\nint[<2>] c = { 7, 2 };\nint[<2>] d = b * c;    // d is { 21, 16 }\n```\n\n----------------------------------------\n\nTITLE: Implementing Enums and Switch Statements in C3\nDESCRIPTION: Demonstrates enum declaration and various switch statement patterns in C3, including implicit breaks, fallthrough with 'nextcase', and enum reflection properties.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nenum Height : uint\n{\n    LOW,\n    MEDIUM,\n    HIGH,\n}\n\nfn void demo_enum(Height h)\n{\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case HIGH:\n            io::printn(\"High\");\n    }\n\n    // This also works\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n            io::printn(\"Not high\");\n            // Implicit break.\n        case Height.HIGH:\n            io::printn(\"High\");\n    }\n\n    // Completely empty cases are not allowed.\n    switch (h)\n    {\n        case LOW:\n            break; // Explicit break required, since switches can't be empty.\n        case MEDIUM:\n            io::printn(\"Medium\");\n        case HIGH:\n            break;\n    }\n\n    // special checking of switching on enum types\n    switch (h)\n    {\n        case LOW:\n        case MEDIUM:\n        case HIGH:\n            break;\n        default:    // warning: default label in switch which covers all enumeration value\n            break;\n    }\n\n    // Using \"nextcase\" will fallthrough to the next case statement,\n    // and each case statement starts its own scope.\n    switch (h)\n    {\n        case LOW:\n            int a = 1;\n            io::printn(\"A\");\n            nextcase;\n        case MEDIUM:\n            int a = 2;\n            io::printn(\"B\");\n            nextcase;\n        case HIGH:\n            // a is not defined here\n            io::printn(\"C\");\n    }\n}\n\nenum State : uint\n{\n    START,\n    STOP,\n}\n\nState start = State.values[0];\nusz enums = State.elements;   // 2\nString[] names = State.names; // [ \"START\", \"STOP\" ]\n```\n\n----------------------------------------\n\nTITLE: Generic Type Usage in C3\nDESCRIPTION: This example demonstrates the usage of generic types in C3 using a generic list. It shows how to define a specific type for a generic module using `def` and highlights that inline type definitions are not allowed for generic modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nimport generic_list; // Contains the generic MyList\n\nstruct Foo { \n    int x; \n}\n\n// ✅ def for each type used with a generic module.\ndef IntMyList = MyList(<Foo>);\nMyListFoo working_example;\n\n// ❌ An inline type definition will give an error.\n// Only allowed in a type definition or macro \n// To avoid this A type may be declared with @adhoc\nMyList<Foo> failing_example = MyList(<Foo>);\n```\n```\n\n----------------------------------------\n\nTITLE: Struct Definition in C3\nDESCRIPTION: This snippet defines a simple struct named `Person` with two members: `age` (char) and `name` (String). It demonstrates the basic syntax for defining a struct in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Person\n{\n    char age;\n    String name;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: ArenaAllocator Implementation in C3\nDESCRIPTION: Functions implementing the ArenaAllocator, which allocates memory from a predefined block of memory with minimal overhead.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\nstruct ArenaAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? ArenaAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ArenaAllocator.clear(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ArenaAllocator.init(&self, char[] data)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ArenaAllocator.mark(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ArenaAllocator.release(&self, void* ptr, bool) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ArenaAllocator.reset(&self, usz mark) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? ArenaAllocator.resize(&self, void *old_pointer, usz size, usz alignment) @dynamic\n```\n\n----------------------------------------\n\nTITLE: BitWriter Implementation in C3\nDESCRIPTION: A utility for writing bits to a byte stream, with methods for initialization, writing specified numbers of bits, and flushing the buffer.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_44\n\nLANGUAGE: c3\nCODE:\n```\nstruct BitWriter\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? BitWriter.flush(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitWriter.init(&self, OutStream byte_writer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? BitWriter.write_bits(&self, uint bits, uint nbits)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Reflection and Field Printing in C3\nDESCRIPTION: Demonstrates C3's compile-time reflection capabilities by using a macro to print information about the fields of a struct, including name, offset, size, and type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nstruct Foo\n{\n    int a;\n    double b;\n    int* ptr;\n}\n\nmacro print_fields($Type)\n{\n    $foreach ($field : $Type.membersof)\n        io::printfn(\"Field %s, offset: %s, size: %s, type: %s\", \n                $field.nameof, $field.offsetof, $field.sizeof, $field.typeid.nameof);\n    $endforeach\n}\n\n\nfn void main()\n{\n    print_fields(Foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Array Memory Allocation in C3\nDESCRIPTION: Shows different methods for allocating arrays in memory with various initialization options.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nFoo* foos1 = malloc(Foo.sizeof * len);    // No initialization\nFoo* foos2 = calloc(Foo.sizeof * len);    // Zero initialization\nFoo[] foos3 = mem::new_array(Foo, len);   // Zero initialization\nFoo[] foos4 = mem::alloc_array(Foo, len); // No initialization\n```\n\n----------------------------------------\n\nTITLE: Basic Optional Declaration in C3\nDESCRIPTION: Demonstrates how to declare and initialize Optional values in C3, showing both successful result and error cases.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint? a = 1; // Set the Optional to a result\n\n// Set the Optional to empty with a specific Excuse.\nint? b = io::FILE_NOT_FOUND?;\n```\n\n----------------------------------------\n\nTITLE: File Loading with Error Handling in C3\nDESCRIPTION: This snippet demonstrates loading a file and handling possible errors during the process. It showcases both an explicit discard of an action on error and an optimal implementation example.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nfn void print_file(String filename)\n{\n    String! file = io::load_file(filename);\n\n    // The following function is not called on error,\n    // so we must explicitly discard it with a void cast.\n    (void)io::printfn(\"Loaded %s and got:\\n%s\", filename, file);\n\n    if (catch err = file)\n    {\n        case IoError.FILE_NOT_FOUND:\n            io::printfn(\"I could not find the file %s\", filename);\n        default:\n            io::printfn(\"Could not load %s.\", filename);\n    }\n}\n\n// Note that the above is only illustrating how Optionals may skip \n// call invocation. A more normal implementation would be:\n\nfn void print_file2(String filename)\n{\n    String! file = io::load_file(filename);\n\n    if (catch err = file)\n    {\n        // Print the error \n        io::printfn(\"Failed to load %s: %s\", filename, err);\n        // We return, so that below 'file' will be unwrapped.\n        return;\n    }    \n    // No need for a void cast here, 'file' is unwrappeed to 'String'.\n    io::printfn(\"Loaded %s and got:\\n%s\", filename, file);\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Time Macro Execution in C3\nDESCRIPTION: Example of compile time macro execution with constant evaluation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nmacro @test($abc)\n{\n    return $abc * 2;\n}\n\nconst int MY_CONST = @test(2); // Will fold to \"4\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Post-conditions in C3\nDESCRIPTION: Shows how to use the @ensure annotation for post-conditions in C3. Post-conditions are evaluated to make checks on the resulting state after passing through the function.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require foo != null\n @ensure return > foo.x\n*>\nfn uint checkFoo(Foo* foo)\n{\n    uint y = abs(foo.x) + 1;\n    // If we had row: foo.x = 0, then this would be a compile time error.\n    return y * abs(foo.x);\n}\n```\n\n----------------------------------------\n\nTITLE: String-Based Element Access Operator [] in C3\nDESCRIPTION: Shows how to implement the array access operator [] using string keys instead of numeric indices. Enables string-based lookup syntax for custom types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn double Bar.get(&self, String str) @operator([])\n{\n    return self.get_val_by_key(str);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Function Pointers in C3\nDESCRIPTION: This code snippet demonstrates how to define and use function pointers in C3 using the `def` keyword. It shows how to assign a function to a function pointer and how default arguments are handled in function pointer assignments and calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ndef Callback = fn void(int value);\nCallback callback = &test;\n\nfn void test(int a) { /* ... */ }\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Defer Statements in C3\nDESCRIPTION: Shows the usage of defer statements in C3 for executing code on scope exit. It also demonstrates error-specific defers using 'catch' and regular exit defers using 'try'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int x)\n{\n    defer io::printn();\n    defer io::print(\"A\");\n    if (x == 1) return;\n    {\n        defer io::print(\"B\");\n        if (x == 0) return;\n    }\n    io::print(\"!\");\n}\n\nfn void main()\n{\n    test(1); // Prints \"A\"\n    test(0); // Prints \"BA\"\n    test(10); // Prints \"B!A\"\n}\n\nfn void? test(int x)\n{\n    defer io::printn(\"\");\n    defer io::print(\"A\");\n    defer try io::print(\"X\");\n    defer catch io::print(\"B\");\n    defer (catch err) io::printf(\"%s\", err);\n    if (x == 1) return SearchResult.MISSING?;\n    io::print(\"!\");\n}\n\ntest(0); // Prints \"!XA\"\ntest(1); // Prints \"MISSINGBA\" and returns a FooError\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Reflection with C3 Macros\nDESCRIPTION: This code snippet demonstrates how to use C3 macros to access type information at compile time. The `print_fields` macro iterates over the members of a given type (`Foo` in this case) and prints their name, offset, size, and type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nstruct Foo\n{\n    int a;\n    double b;\n    int* ptr;\n}\n\nmacro print_fields($Type)\n{\n    $foreach $field : $Type.membersof:\n        io::printfn(\"Field %s, offset: %s, size: %s, type: %s\",\n                $field.nameof, $field.offsetof, $field.sizeof, $field.typeid.nameof);\n    $endforeach\n}\n\n\nfn void main()\n{\n    print_fields(Foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Standard I/O Functions with LIBC Support in C3\nDESCRIPTION: Standard I/O functions specifically for environments with LIBC support, providing access to standard streams and character output.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_54\n\nLANGUAGE: c3\nCODE:\n```\nfn void putchar(char c) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stderr()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stdin()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stdout()\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Element set' Operator ([]=) in C3\nDESCRIPTION: This example shows how to implement the '[]=' operator for the Foo type, enabling element assignment using array-like syntax. It takes an index and a new value as parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/operator-overloading.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void Foo.set(&self, usz i, double new_val) @operator([]=)\n{\n    return self.x[i] = new_val;\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Method Invocation with Any Type in C3\nDESCRIPTION: Demonstrates how to check for and invoke dynamic methods on an 'any' type, showing polymorphic behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn void whoareyou2(any a)\n{\n    // Query if the function exists\n    if (!&a.myname)\n    {\n        io::printn(\"I don't know who I am.\");\n        return;\n    }\n    // Dynamically call the function\n    io::printn(((MyName)a).myname());\n}\n\nfn void main()\n{\n    int i;\n    double d;\n    Bob bob;\n\n    any a = &i;\n    whoareyou2(a); // Prints \"I am int!\"\n    a = &d;\n    whoareyou2(a); // Prints \"I don't know who I am.\"\n    a = &bob;\n    whoareyou2(a); // Prints \"I am Bob!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Type Declarations in C3\nDESCRIPTION: This snippet illustrates new type declaration syntax in C3, including left-to-right declarations, SIMD vector types, and slice types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_1\n\nLANGUAGE: C3\nCODE:\n```\n// Left-to-right declaration\nint[4]*[2] a;\n\n// SIMD vector types\nfloat[<4>] vec4;\nfloat[<*>] vecInferred;\n\n// Slice type\nint[] slice;\n\n// Typedef for new type\ntypedef String = char[];\n\n// Optional type\nint! optionalInt;\n\n// Inferred array type\nint[*] x = { 1, 2 };\n\n// Flexible array member\nstruct Foo {\n    int size;\n    int data[*];\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Printable Interface in C3\nDESCRIPTION: Demonstrates implementing the 'Printable' interface from the standard library for the 'Baz' struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn String Baz.to_new_string(Baz baz, Allocator allocator) @dynamic\n{\n    return string::printf(\"Baz(%d)\", baz.x, allocator: allocator);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining ZString Type in C3\nDESCRIPTION: Defines the ZString type as an inline char pointer, used for working with C-style null-terminated strings. Requires explicit casting from String to ensure proper null-termination.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\ntypedef ZString = inline char*;\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Behavior in C3\nDESCRIPTION: Shows C3's switch statement behavior with implicit breaks and the nextcase statement for explicit fallthrough and case jumping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nswitch (h)\n{\n    case 1:\n        a = 1;\n        nextcase; // Fall through\n    case 2:\n        b = 123;\n    case 3:\n        a = 2;\n        nextcase 2; // Jump to case 2\n    default:\n        a = 111;\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling foreach Loop for Custom Type in C3\nDESCRIPTION: This snippet demonstrates how to enable foreach loop functionality for a custom type Foo by implementing both the '[]' and 'len' operators. It also includes a test function showcasing the usage of foreach with the custom type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/operator-overloading.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n\nfn usz Foo.len(&self) @operator(len)\n{\n    return self.x.len;\n}\n\nfn void test(Foo f)\n{\n    // Print all elements in f\n    foreach (d : f)\n    {\n        io::printfn(\"%f\", d);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Excuse Handling in C3\nDESCRIPTION: Demonstrates how to modify returned Excuses and create custom fault definitions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfaultdef DOG_ATE_HOMEWORK, TEXTBOOK_ON_FIRE;\n\nfn int? test()\n{\n    return io::FILE_NOT_FOUND?;\n}\n\nfn void? examples()\n{\n    int? a = test();\n    int? b = test();\n    int? c = test() ?? DOG_ATE_HOMEWORK?;\n    int? d = test() ?? TEXTBOOK_ON_FIRE?;\n    int? e = test() ?? DOG_ATE_HOMEWORK?!;\n    int? f = test() ?? TEXTBOOK_ON_FIRE?!;\n}\n```\n\n----------------------------------------\n\nTITLE: Calling Dynamic Methods through Interfaces in C3\nDESCRIPTION: Illustrates how to call dynamic methods through interfaces and check for optional method implementations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn void whoareyou(MyName a)\n{\n    io::printn(a.myname());\n}\n\nfn void do_something(VeryOptional z)\n{\n    if (&z.do_something)\n    {\n        z.do_something(1, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Variables in C3\nDESCRIPTION: Shows how to declare Optional variables and use them in function signatures.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint? example = unreliable_function();\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int? example() { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Safe Build Implementation with Trap in C3\nDESCRIPTION: Demonstrates how the same code is compiled in safe (debug) builds, including runtime checks for undefined behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/undefined-behaviour.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nuint x = foo();\nif (x == 0) trap(\"Division by zero\")\nreturn true;\n```\n\n----------------------------------------\n\nTITLE: Accessing Array Length in C3\nDESCRIPTION: Shows how to get the length of arrays using the .len property in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint len1 = int[4].len; // 4\nint[3] a = { 1, 2, 3 };\nint len2 = a.len; // 3\nint[*] b = { 1, 2 };\nint len3 = b.len; // 2\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Default Arguments and Named Parameters in C3\nDESCRIPTION: This snippet demonstrates how to use default arguments and named parameters with function pointer aliases in C3. It shows how the behavior differs between direct function calls and calls through function pointers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nalias TestFn = fn void(int y = 123);\n\nfn void test(int x = 5)\n{\n    io::printfn(\"X = %d\", x);\n}\n\nfn void main()\n{\n    TestFn test2 = &test;\n    test();         // Prints X = 5\n    test2();        // Prints X = 123\n    test(x: 3);     // Prints X = 3\n    test2(y: 4);    // Prints X = 4\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Module Declaration Examples in C3\nDESCRIPTION: Demonstrates basic module declaration across multiple files showing how files can belong to different modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n/* ... */\n```\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n/* ... */\n```\n\nLANGUAGE: c3\nCODE:\n```\nmodule bar;\n\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Basic Defer Usage in C3\nDESCRIPTION: Demonstrates the basic usage of defer statement for executing cleanup code at scope exit. Shows how defer statements are executed in order after regular code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() \n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, on function return\");\n    io::printn(\"print second\");\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Named and Mixed Arguments in Functions\nDESCRIPTION: Illustrates the use of named arguments combined with default values and traditional positional arguments in C3 functions. Emphasizes the flexibility of mixing named and unnamed arguments, while highlighting errors when mixing improperly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_named_default(int times = 1, double data = 3.0, bool dummy = true)\n{\n    for (int i = 0; i < times; i++)\n    {\n        io::printfn(\"Hello %f\", i + data);\n    }\n}\n\nfn void test()\n{\n    test_named_default(times: 10, data: 3.5);\n    test_named_default(3, dummy: false);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Object Methods in C3\nDESCRIPTION: Defines various methods for the Object structure, including getter methods for different data types, type checking methods, and manipulation methods.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object*? Object.get(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* Object.get_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Object.get_bool(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Object.get_bool_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? Object.get_char(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? Object.get_char_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String? Object.get_enum(&self, $EnumType, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String? Object.get_enum_at(&self, $EnumType, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double? Object.get_float(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double? Object.get_float_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar? Object.get_ichar(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar? Object.get_ichar_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int? Object.get_int(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int128? Object.get_int128(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int128? Object.get_int128_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int? Object.get_int_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Object.get_len(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long? Object.get_long(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long? Object.get_long_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* Object.get_or_create_obj(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short? Object.get_short(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short? Object.get_short_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? Object.get_string(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? Object.get_string_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint? Object.get_uint(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128? Object.get_uint128(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128? Object.get_uint128_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint? Object.get_uint_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong? Object.get_ulong(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong? Object.get_ulong_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short? Object.get_ushort(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort? Object.get_ushort_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.has_key(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_array(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_bool(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_empty(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_float(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_indexable(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_int(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_keyable(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_map(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_null(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_string(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.push(&self, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.push_object(&self, Object* to_append)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.set(&self, String key, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.set_at(&self, usz index, String key, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.set_object_at(&self, usz index, Object* to_set)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Object.to_format(&self, Formatter* formatter) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Building and Running a C3 Project\nDESCRIPTION: Command to build a C3 project (if needed) and then run the resulting executable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nc3c run [target]\n```\n\n----------------------------------------\n\nTITLE: Path utility functions in C3\nDESCRIPTION: Global utility functions for file system operations in C3, including directory navigation, file manipulation, path existence checking, and directory creation/removal. These functions operate on Path objects and provide core file system functionality.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_64\n\nLANGUAGE: c3\nCODE:\n```\nfn void? chdir(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? delete(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool exists(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? file_size(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? getcwd(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool is_dir(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool is_file(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn PathList? ls(Path dir, bool no_dirs = false, bool no_symlinks = false, String mask = \"\", Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? mkdir(Path path, bool recursive = false, MkdirPermissions permissions = NORMAL)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? rmdir(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? rmtree(Path path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? temp_directory(Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: C3 Bit Manipulation Functions\nDESCRIPTION: Bit-level operations including shifts, counts, and reversals for integers and integer vectors.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/builtins.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\n$$fshl()       // Funnel shift left\n$$fshr()       // Funnel shift right\n$$ctz()        // Count trailing zeros\n$$clz()        // Count leading zeros\n$$bitreverse() // Reverse bits\n$$bswap()      // Byte swap\n$$popcount()   // Population count\n```\n\n----------------------------------------\n\nTITLE: Module Visibility Override Example in C3\nDESCRIPTION: Demonstrates how to override module visibility rules using @public import.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\n// File a.c3\nmodule a;\n\nfn void a_function() @private { ... }\n\n// File b.c3\nmodule b;\n\nfn void b_function() @private { ... }\n\n// File c.c3\nmodule c;\nimport a;\nimport b @public;\n\nfn void test()\n{\n    // Error! a_function() is private\n    a::a_function(); \n\n    // Allowed since `import b @public` allowed `b`\n    // to \"public\" in this context.\n    b::b_function(); \n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Array Operations in C3\nDESCRIPTION: Defines various array operations such as concatenation and index finding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nmacro concat_new(arr1, arr2, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro index_of(array, element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro rindex_of(array, element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro slice2d(array, x = 0, xlen = 0, y = 0, ylen = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro tconcat(arr1, arr2)\n```\n\n----------------------------------------\n\nTITLE: Checking String Contains Substring in C3\nDESCRIPTION: Function to check if a string contains a specified needle string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.contains(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Function Contracts in C3\nDESCRIPTION: This snippet shows how C3 uses function contracts to indicate input and output parameters, replacing C's const qualifier for function parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/changesfromc.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n This function ensures that foo is not changed in the function.\n @param [in] foo\n @param [out] bar\n*>\nfn void test(Foo* foo, Bar* bar)\n{\n    bar.y = foo.x;\n    // foo.x = foo.x + 1 - compile time error, can't write to 'in' param.\n    // int x = bar.y     - compile time error, can't read from an 'out' param.\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Defer Usage in C3\nDESCRIPTION: Demonstrates basic defer functionality to execute cleanup code at scope end, including after return statements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, on function return\");\n    io::printn(\"print second\");\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Foreach Statement Syntax in C3\nDESCRIPTION: Defines the syntax for foreach and foreach_r statements in C3, which iterate over sequences of values. The syntax includes optional index variables, reference iteration with '&', and reverse iteration with foreach_r.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\nforeach_stmt       ::= \"foreach\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_r_stmt     ::= \"foreach_r\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_vars       ::= (foreach_index \",\")? foreach_var\nforeach_var        ::= type? \"&\"? IDENTIFIER\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Syntax\nDESCRIPTION: Defines the syntax for `switch` statements, including optional labels, a conditional expression, and a switch body containing case clauses.  Cases can be specified using the keyword `case`, followed by an expression, optionally a range operator '..', then another expression.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\n\nswitch_stmt        ::= \"switch\" (label \":\")? (\"(\" cond_expr \")\")? switch body\nswitch_body        ::= \"{\" case_clause* \"}\"\ncase_clause        ::= default_stmt | case_stmt\ndefault_stmt       ::= \"default\" \":\" stmt*\ncase_stmt          ::= \"case\" label? expr (\"..\" expr)? \":\" stmt*\n\n```\n\n----------------------------------------\n\nTITLE: String to Integer Conversion in C3\nDESCRIPTION: Converts a String to an integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_28\n\nLANGUAGE: c3\nCODE:\n```\nfn int? String.to_int(s, int base = 10) => s.to_integer(int, base);\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Regular Functions in C3\nDESCRIPTION: The snippet showcases how to define and utilize regular functions in C3, adopting a syntax similar to C but with the `fn` keyword. The example demonstrates the basic looping structure to print messages. Dependencies include the built-in `io` module for printing.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int times)\n{\n    for (int i = 0; i < times; \n i++)\n    {\n        io::printfn(\"Hello %d\", i);\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining an Interface in C3\nDESCRIPTION: Illustrates how to define an interface named 'MyName' with a single method 'myname'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ninterface MyName\n{\n    fn String myname();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Element at' Operator ([]) with String Index in C3\nDESCRIPTION: This example shows how to implement the '[]' operator for a custom type Bar, using a String as the index instead of a numeric value. This allows for key-based access to elements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/operator-overloading.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn double Bar.get(&self, String str) @operator([])\n{\n    return self.get_val_by_key(str);\n}\n```\n\n----------------------------------------\n\nTITLE: Integer Type Conversion in C3\nDESCRIPTION: Shows safe integer type conversion using any_to_int.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_13\n\nLANGUAGE: c\nCODE:\n```\nany* v = &&128;\nshort y = any_to_int(v, short)!!; // Works\nichar z = any_to_int(v, ichar)!!; // Panics VALUE_OUT_OF_RANGE\n```\n\n----------------------------------------\n\nTITLE: Expression Arguments in C3 Macros\nDESCRIPTION: Demonstrates how C3 handles expression arguments in macros using the # symbol for unevaluated expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#define M(x, y) x = 2 * (y);\n...\nM(x, 3);\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @m(#x, y)\n{\n    #x = 2 * y;\n}\n...\n@m(x, 3);\n```\n\n----------------------------------------\n\nTITLE: Creating Overloaded Methods with Macro Methods in C3\nDESCRIPTION: This snippet demonstrates how to create overloaded methods in C3 using macro methods. It shows how to dispatch to different private methods based on the arguments passed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfn void Obj.func1(&self, String... args) @private {} // varargs variant\nfn void Obj.func2(&self, Foo* pf) @private {} // Foo pointer variant\n\n// The macro must be vararg, since the functions take different amount of arguments\nmacro void Obj.func(&self, ...)\n{\n    // Does it have a single argument of type 'Foo*'?\n    $if $vacount == 1 &&& @typeis($vaarg[0], Foo*):\n        // If so, dispatch to func2\n        return self.func2($vaarg[0]);\n    $else\n        // Otherwise, dispatch all varargs to func1\n        return self.func1($vasplat);\n    $endif\n}\n```\n\n----------------------------------------\n\nTITLE: Parameter Contract Example in C3\nDESCRIPTION: Demonstrates C3's parameter contracts using [in] and [out] annotations instead of const qualifiers. Shows compile-time enforcement of parameter access rules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n This function ensures that foo is not changed in the function.\n @param [in] foo\n @param [out] bar\n*>\nfn void test(Foo* foo, Bar* bar)\n{\n    bar.y = foo.x;\n    // foo.x = foo.x + 1 - compile time error, can't write to 'in' param.\n    // int x = bar.y     - compile time error, can't read from an 'out' param.\n}\n```\n\n----------------------------------------\n\nTITLE: Type Aliasing in C3\nDESCRIPTION: Demonstrates basic type aliasing using the def statement to create aliases for pointer types and arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\ndef CharPtr = char*;\ndef Numbers = int[10];\n```\n\n----------------------------------------\n\nTITLE: Initializing Boolean Values in C3\nDESCRIPTION: Shows how to initialize boolean values in C3 using the 'bool' type and 'true' or 'false' literals.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nbool b = true;\nbool f = false;\n```\n\n----------------------------------------\n\nTITLE: Running Tests in a C3 Project\nDESCRIPTION: Command to run all tests defined with the @test attribute in the project's source directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nc3c test\n```\n\n----------------------------------------\n\nTITLE: POSIX Thread Operations\nDESCRIPTION: Implementation of native thread operations for POSIX systems including mutex, condition variables, and thread management\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_117\n\nLANGUAGE: c3\nCODE:\n```\nstruct NativeMutex\nfn void? NativeConditionVariable.broadcast(&cond)\nfn void? NativeConditionVariable.destroy(&cond)\nfn void? NativeConditionVariable.init(&cond)\nfn void? NativeConditionVariable.signal(&cond)\nfn void? NativeConditionVariable.wait(&cond, NativeMutex* mtx)\nfn void? NativeConditionVariable.wait_timeout(&cond, NativeMutex* mtx, ulong ms)\nfn void? NativeMutex.destroy(&self)\nfn void? NativeMutex.init(&self, MutexType type)\nfn bool NativeMutex.is_initialized(&self)\nfn void? NativeMutex.lock(&self)\nfn void? NativeMutex.lock_timeout(&self, ulong ms)\nfn bool NativeMutex.try_lock(&self)\nfn void? NativeMutex.unlock(&self)\nfn void NativeOnceFlag.call_once(&flag, OnceFn func)\nfn void? NativeThread.create(&thread, ThreadFn thread_fn, void* arg)\nfn void? NativeThread.detach(thread)\nfn bool NativeThread.equals(thread, NativeThread other)\nfn int? NativeThread.join(thread)\nfn void? native_sleep_nano(NanoDuration nano)\nfn NativeThread native_thread_current()\nfn void native_thread_exit(int result)\nfn void native_thread_yield()\n```\n\n----------------------------------------\n\nTITLE: Defining ZString Type in C3\nDESCRIPTION: Defines the ZString type as a distinct inline char pointer, used for compatibility with C-style null-terminated strings. Explicit casting is required for conversion, reminding users to check for proper null termination.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\ndistinct ZString = inline char*;\n```\n\n----------------------------------------\n\nTITLE: Slice Operations with Compound Literals in C3\nDESCRIPTION: Shows various ways to pass slices using compound literals, including using the && operator and direct slice syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int[] y) { ... }\n\n// Using &&\ntest(&&(int[3]){ 1, 2, 3 });\n\n// Explicitly slicing:\ntest(((int[3]){ 1, 2, 3 })[..]);\n\n// Using a slice directly as a temporary:\ntest((int[]){ 1, 2, 3 });\n\n// Same as above but with inferred type:\ntest({ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Using Rethrow Operator for Optional Unwrapping\nDESCRIPTION: Shows usage of the rethrow operator (!) to safely unwrap Optional values with automatic error propagation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Function returning an Optional\nfn int! maybe_func() { /* ... */ }\n\nfn void! test() \n{\n    // ❌ This will be a compile error\n    // maybe_function() returns an Optional\n    // and 'bar' is not declared Optional:\n    // int bar = maybe_function();\n    \n    int bar = maybe_function()!; \n    // ✅ The above is equivalent to:    \n    // int! temp = maybe_function();\n    // if (catch excuse = temp) return excuse?\n\n    // Now temp is unwrapped to a non-Optional\n    int bar = temp; // ✅ This is OK\n}\n```\n\n----------------------------------------\n\nTITLE: Converting String to Integer Types in C3\nDESCRIPTION: Functions to convert a String to various integer types with an optional base parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\nfn int128! String.to_int128(s, int base = 10) => s.to_integer(int128, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long! String.to_long(s, int base = 10) => s.to_integer(long, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! String.to_int(s, int base = 10) => s.to_integer(int, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short! String.to_short(s, int base = 10) => s.to_integer(short, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar! String.to_ichar(s, int base = 10) => s.to_integer(ichar, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128! String.to_uint128(s, int base = 10) => s.to_integer(uint128, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong! String.to_ulong(s, int base = 10) => s.to_integer(ulong, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint! String.to_uint(s, int base = 10) => s.to_integer(uint, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort! String.to_ushort(s, int base = 10) => s.to_integer(ushort, base);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char! String.to_uchar(s, int base = 10) => s.to_integer(char, base);\n```\n\n----------------------------------------\n\nTITLE: External Function Declaration in C3\nDESCRIPTION: Demonstrates how to declare and use external C functions in C3, including custom naming with @extern attribute.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nextern fn int puts(char*);\nextern fn int _puts(char* message) @extern(\"puts\");\n```\n\n----------------------------------------\n\nTITLE: Using Nextcase in Switch Statements in C3\nDESCRIPTION: This snippet demonstrates the use of nextcase in a switch statement to jump to the next case. It also shows how to use nextcase with an expression to jump to an arbitrary case or between labeled switch statements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/statements.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nswitch (i)\n{\n    case 1:\n        doSomething();\n        nextcase; // Jumps to case 2\n    case 2:\n        doSomethingElse();\n}\n\nswitch MAIN: (enum_var)\n    case FOO:\n        switch (i)\n        {\n            case 1:\n                doSomething();\n                nextcase 3; // Jump to case 3\n            case 2:\n                doSomethingElse();\n            case 3:\n                nextcase rand(); // Jump to random case\n            default:\n                io::printn(\"Ended\");\n                nextcase MAIN: BAR;  // Jump to outer (MAIN) switch\n        } \n    case BAR:\n        io::printn(\"BAR\");\n    default:\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Narrowing in C3\nDESCRIPTION: This code snippet illustrates implicit narrowing conversions in C3, showing valid and invalid cases for different numeric types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/conversion.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfloat16 h = 12.0;\nfloat f = 13.0;\ndouble d = 22.0;\n\nchar x = 1;\nshort y = -3;\nint z = 0xFFFFF;\nulong w = -0xFFFFFFF;\n\nx = x + x; // => calculated as x = (char)((int)x + (int)x);\nx = y + x; // => Error, narrowing not allowed as y > char\nh = x * h; // => calculated as h = (float16)((float)x * (float)h);\nh = f + x; // => Error, narrowing not allowed since f > f16\n```\n\n----------------------------------------\n\nTITLE: Fault Definitions for Optional Types in C3\nDESCRIPTION: This snippet defines a few faults, `IO_ERROR`, `PARSE_ERROR`, and `NOT_FOUND`, that can be used as excuses for optional types.  The faults are globally unique and pointer sized.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfaultdef IO_ERROR, PARSE_ERROR, NOT_FOUND;\n```\n```\n\n----------------------------------------\n\nTITLE: Object Instantiation with new in C3\nDESCRIPTION: Demonstrates object creation using new and new_aligned with optional initializers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nint* a = mem::new(int);\nFoo* foo = mem::new(Foo, { 1, 2 });\n```\n\n----------------------------------------\n\nTITLE: TempAllocator Implementation in C3\nDESCRIPTION: Functions implementing the TempAllocator, which provides temporary memory allocation with marking and resetting capabilities.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_31\n\nLANGUAGE: c3\nCODE:\n```\nstruct TempAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TempAllocatorPage\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? TempAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz TempAllocator.mark(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? TempAllocator.print_pages(&self, File* f)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TempAllocator.release(&self, void* old_pointer, bool) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TempAllocator.reset(&self, usz mark) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? TempAllocator.resize(&self, void* pointer, usz size, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool TempAllocatorPage.is_aligned(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz TempAllocatorPage.pagesize(&self)\n```\n\n----------------------------------------\n\nTITLE: Implementing Switch Cases with Runtime Evaluation in C3\nDESCRIPTION: This code shows how to use switch as an enhanced if-else chain in C3. It demonstrates switch cases with runtime evaluation and the implicit true condition when the switch expression is omitted.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/statements.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nswitch (true)\n{\n    case x < 0:\n        xless();\n    case x > 0:\n        xgreater();\n    default:\n        xequals();\n}\n\nswitch\n{\n    case foo() > 0:\n        bar();\n    case test() == 1:\n        baz();\n}\n```\n\n----------------------------------------\n\nTITLE: LinkedList Implementation in C3\nDESCRIPTION: Double-linked list implementation with comprehensive list operations including push/pop at both ends, insertion, removal, and element access methods.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nstruct LinkedList\n\nfn void LinkedList.clear(&self)\nfn Type? LinkedList.first(&self)\nfn void LinkedList.free(&self)\nfn Type LinkedList.get(&self, usz index)\nfn void LinkedList.insert_at(&self, usz index, Type element)\nfn Type? LinkedList.last(&self)\nfn usz LinkedList.len(&self) @inline\nfn LinkedList* LinkedList.new_init(&self, Allocator allocator = allocator::heap())\nfn Type? LinkedList.peek(&self)\nfn Type? LinkedList.peek_last(&self)\nfn Type? LinkedList.pop(&self)\nfn Type? LinkedList.pop_front(&self)\nfn void LinkedList.push(&self, Type value)\nfn void LinkedList.push_front(&self, Type value)\n```\n\n----------------------------------------\n\nTITLE: New String Splitting in C3\nDESCRIPTION: Splits the string by the specified needle, creating a new array using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.new_split(s, String needle, usz max = 0) => s.split(needle, max, allocator::heap()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation in C3 and C\nDESCRIPTION: Demonstrates conditional compilation using macros in both C and C3. C3 offers a more concise syntax using $if and @if attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n#if defined(x) && Y > 3\nint z;\n#endif\n```\n\nLANGUAGE: c3\nCODE:\n```\n$if $defined(x) && Y > 3:\n    int z;\n$endif\n\n// or\nint z @if($defined(x) && Y > 3);\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Reference Operator &[] in C3\nDESCRIPTION: Shows implementation of the element reference operator &[] which returns a pointer to an element. This enables reference access syntax for custom types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn double* Foo.get_ref(&self, usz i) @operator(&[])\n{\n    return &self.x[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Type of a Struct in C3\nDESCRIPTION: Demonstrates how to get the parent type of a struct using the 'parentof' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int a;\n}\n\nstruct Bar\n{\n    inline Foo f;\n}\n\nString x = Bar.parentof.nameof; // \"Foo\"\n```\n\n----------------------------------------\n\nTITLE: Calling Dynamic Methods through Interfaces in C3\nDESCRIPTION: Illustrates how to call dynamic methods through interfaces and check for optional methods.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn void whoareyou(MyName a)\n{\n    io::printn(a.myname());\n}\n\nfn void do_something(VeryOptional z)\n{\n    if (&z.do_something)\n    {\n        z.do_something(1, null);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Distribution Package for a C3 Project\nDESCRIPTION: Command to clean, build, and package a C3 project target for distribution. Will also run the target if it is an executable. Note: this feature is not fully implemented yet.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nc3c dist [target]\n```\n\n----------------------------------------\n\nTITLE: Temporary String Concatenation in C3\nDESCRIPTION: Concatenates two strings using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tconcat(s1, String s2);\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Types, Functions, and Variables with Alias in C3\nDESCRIPTION: This snippet shows how to use 'alias' to create aliases for parameterized types, functions, and variables in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport generic_foo;\n\n// Parameterized function aliases\nalias int_foo_call = generic_foo::foo_call {int};\nalias double_foo_call = generic_foo::foo_call {double};\n\n// Parameterized type aliases\nalias IntFoo = Foo {int};\nalias DoubleFoo = Foo {double};\n\n// Parameterized global aliases\nalias int_max_foo = generic_foo::max_foo {int};\nalias double_max_foo = generic_foo::max_foo {double};\n```\n\n----------------------------------------\n\nTITLE: Working with the 'any' Type in C3\nDESCRIPTION: Demonstrates various ways to work with the 'any' type in C3, including casting, switching, and unwrapping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void main()\n{\n    int x;\n    any y = &x;\n    int* w = (int*)y;\n    double! z = anycast(y, double);\n    if (y.type == int.typeid)\n    {\n        // Do something if y contains an int*\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Converting String to Floating-Point Types in C3\nDESCRIPTION: Functions to convert a String to double and float types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\nfn double! String.to_double(s) => s.to_real(double);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float! String.to_float(s) => s.to_real(float);\n```\n\n----------------------------------------\n\nTITLE: Reading Input and Greeting in C\nDESCRIPTION: This snippet demonstrates how to read a string from stdin using the treadline function, handle potential errors, and print a greeting message to stdout. It requires the std::io module and handles standard input using a temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/index.mdx#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nimport std::io;\n\nfn void! hello_name()\n{\n    String! name = io::treadline();\n    if (catch excuse = name) {\n        return excuse?;\n    }\n\n    io::printfn(\"Hello %s! Hope you have a great day\", name);\n}\n```\n\n----------------------------------------\n\nTITLE: File Input/Output in C3\nDESCRIPTION: Example of reading input from stdin using readline.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void? hello_name()\n{\n    String? name = io::readline();\n    if (catch excuse = name)\n    {\n        return excuse?;\n    }\n\n    io::printfn(\"Name was: %s.\", name);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Function Pointer Aliases in C3\nDESCRIPTION: This snippet shows how to define and use function pointer aliases in C3. It includes an example of defining a callback function type and using it.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nalias Callback = fn void(int a, bool b);\n```\n\nLANGUAGE: c3\nCODE:\n```\nCallback cb = &my_callback;\ncb(10, false);\n```\n\n----------------------------------------\n\nTITLE: OS-Specific CPU Information in C3\nDESCRIPTION: Operating system-specific functions for retrieving system information like the number of CPUs. These functions are conditionally compiled for specific platforms like Darwin (macOS) and Linux.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_99\n\nLANGUAGE: c3\nCODE:\n```\nfn uint num_cpu()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint num_cpu()\n```\n\n----------------------------------------\n\nTITLE: Vector Swizzling Operations in C3\nDESCRIPTION: Demonstrates vector swizzling operations using dot notation with x,y,z,w or r,g,b,a components, including component access and modification.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/vectors.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nint[<3>] a = { 11, 22, 33 };\nint[<4>] b = a.xxzx;                         // b = { 11, 11, 33, 11 }\nint c = b.w;                                 // c = 11;\nchar[<4>] color = { 0x11, 0x22, 0x33, 0xFF };\nchar red = color.r;                          // red = 0x11\nb.xy = b.zw;\ncolor.rg += { 1, 2 };\n```\n\n----------------------------------------\n\nTITLE: String to WString Conversion in C3\nDESCRIPTION: Converts a String to a WString using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_wstring(s, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: RingBuffer implementation in C3\nDESCRIPTION: Defines a fixed-size RingBuffer with methods for push, pop, and bulk read/write operations. The RingBuffer is a circular buffer with fixed capacity defined by the SIZE template parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nstruct RingBuffer\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type RingBuffer.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.init(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! RingBuffer.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.push(&self, Type c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz RingBuffer.read(&self, usz index, Type[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void RingBuffer.write(&self, Type[] buffer)\n```\n\n----------------------------------------\n\nTITLE: Macro Definitions in C3 and C\nDESCRIPTION: Shows how macros are defined and used in C and C3. C3 uses a more function-like syntax for macro definitions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define M(x) ((x) + 2)\n#define UInt32 unsigned int\n\n// Use:\nint y = M(foo() + 2);\nUInt32 b = y;\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro m(x)\n{\n    return x + 2;\n}\nalias UInt32 = uint;\n\n// Use:\nint y = m(foo() + 2);\nUInt32 b = y;\n```\n\n----------------------------------------\n\nTITLE: No-libc Math Functions in C3\nDESCRIPTION: Implementation of various mathematical functions for use when the standard C library is not available, including trigonometric, exponential, and rounding functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_72\n\nLANGUAGE: c3\nCODE:\n```\nmacro double __math_oflow(ulong sign)\nmacro float __math_oflowf(uint sign)\nmacro double __math_uflow(ulong sign)\nmacro float __math_uflowf(uint sign)\nmacro __math_xflow(sign, v)\nmacro force_eval_add(x, v)\n\nfn double __cos(double x, double y) @extern(\"__cos\") @weak @nostrip\nfn float __cosdf(double x) @extern(\"__cosdf\") @weak @nostrip\nfn int __rem_pio2(double x, double *y)\nfn int __rem_pio2_large(double* x, double* y, int e0, int nx, int prec)\nfn int __rem_pio2f(float x, double *y)\nfn double __sin(double x, double y, int iy) @extern(\"__sin\") @weak @nostrip\nfn float __sindf(double x) @extern(\"__sindf\") @weak @nostrip\nfn double __tan(double x, double y, int odd) @extern(\"__tan\") @weak @nostrip\nfn float __tandf(double x, int odd) @extern(\"__tandf\") @weak @nostrip\nfn double _atan(double x) @weak @extern(\"atan\") @nostrip\nfn double _atan2(double y, double x) @weak @extern(\"atan2\") @nostrip\nfn float _atan2f(float y, float x) @weak @extern(\"atan2f\") @nostrip\nfn float _atanf(float x) @weak @extern(\"atanf\") @nostrip\nfn double _ceil(double x) @weak @extern(\"ceil\") @nostrip\nfn float _ceilf(float x) @weak @extern(\"ceilf\") @nostrip\nfn double _cos(double x) @weak @nostrip\nfn float _cosf(float x) @extern(\"cosf\") @weak @nostrip\nfn double _exp2(double x) @extern(\"exp2\") @weak @nostrip\nfn float _exp2f(float x) @extern(\"exp2f\") @weak @nostrip\nfn double _floor(double x) @weak @extern(\"floor\") @nostrip\nfn float _floorf(float x) @weak @extern(\"floorf\") @nostrip\nfn double _round(double x) @extern(\"round\") @weak @nostrip\nfn float _roundf(float x) @extern(\"roundf\") @weak @nostrip\nfn double _scalbn(double x, int n) @weak @extern(\"scalbn\") @nostrip\nfn float _sinf(float x) @weak @extern(\"sinf\") @nostrip\nfn double _trunc(double x) @weak @extern(\"trunc\") @nostrip\nfn float _truncf(float x) @weak @extern(\"truncf\") @nostrip\nfn double pow_broken(double x, double y) @extern(\"pow\") @weak @nostrip\nfn float powf_broken(float x, float f) @extern(\"powf\") @weak @nostrip\nfn double sin(double x) @extern(\"sin\") @weak @nostrip\nfn void sincos(double x, double *sin, double *cos) @extern(\"sincos\") @weak @nostrip\nfn double sincos_broken(double x) @extern(\"sincos\") @weak @nostrip\nfn void sincosf(float x, float *sin, float *cos) @extern(\"sincosf\") @weak @nostrip\nfn double tan(double x) @extern(\"tan\") @weak @nostrip\nfn float tanf(float x) @extern(\"tanf\") @weak @nostrip\n```\n\n----------------------------------------\n\nTITLE: Function Arguments with Default and Named Parameters in C3\nDESCRIPTION: Demonstrates C3's ability to handle default and named arguments in functions. Default parameters are assigned directly within the function signature, and named arguments allow for clearer invocation. Important constraints include ordering rules for named and unnamed arguments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn int test_with_default(int foo = 1)\n{\n    return foo;\n}\n\nfn void test()\n{\n    test_with_default();\n    test_with_default(100);\n}\n\n```\n\n----------------------------------------\n\nTITLE: New ASCII to Uppercase Conversion in C3\nDESCRIPTION: Converts ASCII characters in a String to uppercase, creating a new String with the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_38\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Enum Type Inference in C3\nDESCRIPTION: This code demonstrates enum type inference in C3. When an enum is used where its type can be inferred, such as in switch cases or variable assignments, the enum name can be omitted.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nState process = WAITING; // State.WAITING is inferred.\nswitch (process)\n{\n    case RUNNING: // State.RUNNING is inferred\n        io::printfn(\"Position x: %d\", process.pos.x);\n    default:\n        io::printfn(\"Process is: %s\", process.desc);\n}\n\nfn void test(State s) { ... }\n\ntest(RUNNING); // State.RUNNING is inferred\n```\n```\n\n----------------------------------------\n\nTITLE: Getting Minimum Value of a Type in C3\nDESCRIPTION: Shows how to retrieve the minimum value of an integer type using the 'min' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nichar min_ichar = ichar.min; // -128\n```\n\n----------------------------------------\n\nTITLE: Enum Ordinal Conversion in C3\nDESCRIPTION: This code snippet illustrates how to convert an enum to its ordinal value using `.ordinal` and back using `EnumName.from_ordinal(...)` in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void store_enum(State s)\n{\n    write_int_to_file(s.ordinal);\n}\n\nfn State read_enum()\n{\n    return State.from_ordinal(read_int_from_file());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Declaring and Calling C Functions in C3\nDESCRIPTION: Demonstrates how to declare and call C functions in C3 using the 'extern' keyword. The example shows calling the C standard library function 'puts'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/cinterop.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nextern fn void puts(char*); // C \"puts\"\n\nfn void main()\n{\n    // This will call the \"puts\"\n    // function in the standard c lib.\n    puts(\"Hello, world!\"); \n}\n```\n\n----------------------------------------\n\nTITLE: DString Formatted Append Functions in C3\nDESCRIPTION: Functions for appending formatted content to a DString using printf-style formatting.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_35\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! DString.appendf(&self, String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! DString.appendfn(&self, String format, args...) @maydiscard\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Implicit Widening in C3\nDESCRIPTION: This code snippet shows examples of implicit widening conversions in C3, including valid cases for simple expressions and invalid cases for complex expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/conversion.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint a = ...\nshort b = ...\nchar c = ...\nlong d = a; // Valid - simple expression.\nint e = (int)(d + (a + b)); // Error\nint f = (int)(d + ~b); // Valid\nlong g = a + b; // Valid\n```\n\n----------------------------------------\n\nTITLE: Calling Exported C3 Functions from C\nDESCRIPTION: Shows how to call C3 functions from C code, including the use of weak aliases to handle C3's default module-based namespacing of exported functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/cinterop.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nextern int square(int);\nint foo_square(int) __attribute__ ((weak, alias (\"foo__square\")));\n\nvoid test()\n{\n    // This would call square2\n    printf(\"%d\\n\", square(11));\n\n    // This would call square\n    printf(\"%d\\n\", foo_square(11));\n}\n```\n\n----------------------------------------\n\nTITLE: ZString Member Functions in C3\nDESCRIPTION: Functions to work with ZString type, including conversion to String view, character length, and string length calculations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_33\n\nLANGUAGE: c3\nCODE:\n```\nfn String ZString.str_view(str);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ZString.char_len(str);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ZString.len(str);\n```\n\n----------------------------------------\n\nTITLE: Formatted Printing to Stdout in C3\nDESCRIPTION: This snippet demonstrates using the io::printfn function for formatted output in the C3 language. It supports various format specifiers and prints complex types like enums and vectors to stdout.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/index.mdx#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Heat \n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main() \n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = REALLY_WARM;\n    String dialogue = \"Hello\";\n\n    io::printfn(\"%s\", dialogue);  // Hello\n    io::printfn(\"%d\", 20);        // 20\n    io::printfn(\"%f\", 2.2);       // 2.200000\n    io::printfn(\"%s\", vec);       // [<4, 2>]\n    io::printfn(\"%s\", weather);   // REALLY_WARM\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a New C3 Project\nDESCRIPTION: Use the c3c init command to create a new C3 project directory. This command sets up the basic project structure and files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c init myc3project\n```\n\n----------------------------------------\n\nTITLE: Function and Variable Aliasing\nDESCRIPTION: Shows how to create aliases for functions and variables using the def statement.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo() { ... }\nint foo_var;\n\ndef bar = foo;\ndef bar_var = foo_var;\n\nfn void test() \n{\n  // These are the same:\n  foo();\n  bar();\n  \n  // These access the same variable:\n  int x = foo_var;\n  int y = bar_var;\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation in C3\nDESCRIPTION: Demonstrates various memory allocation patterns including heap allocation and initialization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nFoo* f1 = malloc(Foo.sizeof);                   // No initialization\nFoo* f2 = calloc(Foo.sizeof);                   // Zero initialization\nFoo* f3 = mem::new(Foo);                        // Zero initialization\nFoo* f4 = mem::alloc(Foo);                      // No initialization\nFoo* f5 = mem::new(Foo, { 4, 10.0, .a = 123 }); // Initialized to argument\n```\n\n----------------------------------------\n\nTITLE: Enum Type Inference in C3\nDESCRIPTION: This code snippet shows how enum type inference works in C3.  When the type of an enum is known from context, like in a switch statement or variable assignment, the enum name qualifier can be omitted.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nState process = WAITING; // State.WAITING is inferred.\nswitch (process)\n{\n    case RUNNING: // State.RUNNING is inferred\n        io::printfn(\"Position x: %d\", process.pos.x);\n    default:\n        io::printfn(\"Process is: %s\", process.desc);\n}\n\nfn void test(State s) { ... }\n\ntest(RUNNING); // State.RUNNING is inferred\n```\n```\n\n----------------------------------------\n\nTITLE: Enum Ordinal Conversion in C3\nDESCRIPTION: This code demonstrates how to convert an enum to its ordinal value using `.ordinal` and back using `EnumName.from_ordinal(...)`. It shows a use case where the ordinal value is stored and retrieved from a file.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void store_enum(State s)\n{\n    write_int_to_file(s.ordinal);\n}\n\nfn State read_enum()\n{\n    return State.from_ordinal(read_int_from_file());\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Native File Operations (No LibC)\nDESCRIPTION: Core file operation functions when LibC is not available. Includes basic file operations like open, read, write, seek and remove.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_64\n\nLANGUAGE: c3\nCODE:\n```\nfn void*! native_fopen(String filename, String mode) @inline\nfn usz! native_fread(CFile file, char[] buffer) @inline\nfn void*! native_freopen(void* file, String filename, String mode) @inline\nfn void! native_fseek(void* file, isz offset, Seek seek_mode) @inline\nfn usz! native_ftell(CFile file) @inline\nfn usz! native_fwrite(CFile file, char[] buffer) @inline\nfn void! native_remove(String filename) @inline\nmacro Path! native_temp_directory(Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Conditional Optional Processing in C3\nDESCRIPTION: Shows how to conditionally process Optionals using if (try) statements with multiple conditions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn int? reliable_function()\n{\n    return 7;\n}\n\nfn void main(String[] args)\n{\n    int? reliable_result1 = reliable_function();\n    int? reliable_result2 = reliable_function();\n    if (try reliable_result1 && try reliable_result2 && 5 > 2)\n    {\n        io::printfn(\"reliable_result1: %s\", reliable_result1);\n        io::printfn(\"reliable_result2: %s\", reliable_result2);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implicit Narrowing Example in C3\nDESCRIPTION: This C3 code snippet demonstrates implicit narrowing of integer and float types. It showcases scenarios where narrowing is allowed or results in an error, as well as how arithmetic operations are handled with different data types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/conversion.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n\"float16 h = 12.0;\nfloat f = 13.0;\ndouble d = 22.0;\n\nchar x = 1;\nshort y = -3;\nint z = 0xFFFFF;\nulong w = -0xFFFFFFF;\n\nx = x + x; // => calculated as x = (char)((int)x + (int)x);\nx = y + x; // => Error, narrowing not allowed as y > char\nh = x * h; // => calculated as h = (float16)((float)x * (float)h);\nh = f + x; // => Error, narrowing not allowed since f > f16\"\n```\n\n----------------------------------------\n\nTITLE: Defining Structs, Unions, Enums, and Faults in C3\nDESCRIPTION: This code snippet demonstrates the declaration of structs, unions, enums, and faults in C3, along with the use of the `extern` attribute for C compatibility. User-defined types must start with A-Z (after an optional initial `_`) and contain at least one lowercase letter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @extern(\"foo\")\n{\n    int x;\n    Bar bar;\n}\n\nunion Bar \n{\n    int i;\n    double d;\n}\n\nenum Baz \n{\n    VALUE_1,\n    VALUE_2\n}\n\nfault Err \n{\n    OOPS,\n    LOTS_OF_OOPS\n}\n```\n\n----------------------------------------\n\nTITLE: Thread Local Storage Example\nDESCRIPTION: Illustrates the correct usage of thread-local storage (`tlocal`) by demonstrating valid and invalid initialization scenarios. The initializer for a `tlocal` variable must be a valid global init expression.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_24\n\n\n\n----------------------------------------\n\nTITLE: String and Raw String Literals in C3\nDESCRIPTION: This snippet illustrates the usage of string literals and raw strings in C3. Raw strings are enclosed within backticks and allow for the inclusion of special characters without the need for escaping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nchar* foo = `C:\\foo\\bar.dll`;\nchar* bar = `\"Say ``hello``\"`;\n// Same as\nchar* foo = \"C:\\\\foo\\\\bar.dll\";\nchar* bar = \"\\\"Say `hello`\\\"\";\n```\n\n----------------------------------------\n\nTITLE: Finding Last Index of Substring in String in C3\nDESCRIPTION: Function to find the last index of a specified needle string within a string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! String.rindex_of(s, String needle)\n```\n\n----------------------------------------\n\nTITLE: Enum Iteration with $foreach in C3\nDESCRIPTION: This example shows how to use $foreach to iterate over enum values at compile time in C3, generating code for each enum member.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo_enum($SomeEnum)\n{\n    $foreach ($x : $SomeEnum.values)\n        io::printfn(\"%d\", (int)$x);     \n    $endforeach\n}\n\nenum MyEnum\n{\n    A,\n    B,\n}\n\nfn void test()\n{\n    foo_enum(MyEnum);\n    // Expands to ->\n    // io::printfn(\"%d\", (int)MyEnum.A);\n    // io::printfn(\"%d\", (int)MyEnum.B);    \n}\n```\n\n----------------------------------------\n\nTITLE: Applying Alignment Attribute to Struct and Field in C3\nDESCRIPTION: Demonstrates the use of the @align attribute to set minimum alignment for a struct and its field. The struct Foo is aligned to 32 bytes, while the field 'b' is aligned to 16 bytes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @align(32)\n{\n    int a;\n    int b @align(16);\n}\n```\n\n----------------------------------------\n\nTITLE: Variable and Parameter Declaration in C3\nDESCRIPTION: Shows the naming rules for variables and parameters which must start with a-z after any optional '_'. Demonstrates both local and global variable usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint theGlobal = 1;\n\nfn void foo(int x)\n{\n    Foo foo = getFoo(x);\n    theGlobal++;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Bitstruct in C3\nDESCRIPTION: This code snippet demonstrates the basic syntax for defining a bitstruct in C3. It defines a bitstruct named `Foo` with a `char` backing type and three fields: `a`, `b`, and `c`, each occupying a specific range of bits. The example shows how to access and modify bitstruct fields, and how the bit values affect the underlying char value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_28\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nbitstruct Foo : char\n{\n    int a : 0..2;\n    int b : 4..6;\n    bool c : 7;\n}\n\nfn void test()\n{\n    Foo f;\n    f.a = 2;\n    char x = (char)f;\n    io::printfn(\"%d\", (char)f); // prints 2\n    f.b = 1;\n    io::printfn(\"%d\", (char)f); // prints 18\n    f.c = true;\n    io::printfn(\"%d\", (char)f); // prints 146\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Compile Time Fibonacci Calculation in C3\nDESCRIPTION: Demonstrates compile-time execution in C3 using a macro to calculate Fibonacci numbers during compilation, showing how complex calculations can be performed at compile time.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nmacro long fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return fib($n - 1) + fib($n - 2);\n    $endif\n}\n\nconst long FIB19 = fib(19); \n// Same as const long FIB19 = 4181;\n```\n\n----------------------------------------\n\nTITLE: Matrix Operations in C3\nDESCRIPTION: Structures and functions for 2x2, 3x3, and 4x4 matrices, including operations like addition, multiplication, inversion, and transformations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_71\n\nLANGUAGE: c3\nCODE:\n```\nstruct Matrix2x2\nstruct Matrix3x3\nstruct Matrix4x4\n\nfn Matrix2x2 Matrix2x2.add(&self, Matrix2x2 mat2)\nfn Matrix2x2 Matrix2x2.adjoint(&self)\nfn Real[<2>] Matrix2x2.apply(&self, Real[<2>] vec)\nfn Matrix2x2 Matrix2x2.component_mul(&self, Real s)\nfn Real Matrix2x2.determinant(&self)\nfn Matrix2x2? Matrix2x2.inverse(&self)\nfn Matrix2x2 Matrix2x2.mul(&self, Matrix2x2 b)\nfn Matrix2x2 Matrix2x2.sub(&self, Matrix2x2 mat2)\nfn Real Matrix2x2.trace(&self)\nfn Matrix2x2 Matrix2x2.transpose(&self)\n\nfn Matrix3x3 Matrix3x3.add(&self, Matrix3x3 mat2)\nfn Matrix3x3 Matrix3x3.adjoint(&self)\nfn Real[<3>] Matrix3x3.apply(&self, Real[<3>] vec)\nfn Matrix3x3 Matrix3x3.component_mul(&self, Real s)\nfn Real Matrix3x3.determinant(&self)\nfn Matrix3x3? Matrix3x3.inverse(&self)\nfn Matrix3x3 Matrix3x3.mul(&self, Matrix3x3 b)\nfn Matrix3x3 Matrix3x3.rotate(&self, Real r)\nfn Matrix3x3 Matrix3x3.scale(&self, Real[<2>] v)\nfn Matrix3x3 Matrix3x3.sub(&self, Matrix3x3 mat2)\nfn Real Matrix3x3.trace(&self)\nfn Matrix3x3 Matrix3x3.translate(&self, Real[<2>] v)\nfn Matrix3x3 Matrix3x3.transpose(&self)\n\nfn Matrix4x4 Matrix4x4.add(&self, Matrix4x4 mat2)\nfn Matrix4x4 Matrix4x4.adjoint(&self)\nfn Real[<4>] Matrix4x4.apply(&self, Real[<4>] vec)\nfn Matrix4x4 Matrix4x4.component_mul(&self, Real s)\nfn Real Matrix4x4.determinant(&self)\nfn Matrix4x4? Matrix4x4.inverse(&self)\nfn Matrix4x4 Matrix4x4.mul(Matrix4x4* a, Matrix4x4 b)\nfn Matrix4x4 Matrix4x4.rotate_x(&self, Real r)\nfn Matrix4x4 Matrix4x4.rotate_y(&self, Real r)\nfn Matrix4x4 Matrix4x4.rotate_z(&self, Real r)\nfn Matrix4x4 Matrix4x4.scale(&self, Real[<3>] v)\nfn Matrix4x4 Matrix4x4.sub(&self, Matrix4x4 mat2)\nfn Real Matrix4x4.trace(&self)\nfn Matrix4x4 Matrix4x4.translate(&self, Real[<3>] v)\nfn Matrix4x4 Matrix4x4.transpose(&self)\n\nfn Matrix4x4 ortho(Real left, Real right, Real top, Real bottom, Real near, Real far)\nfn Matrix4x4 perspective(Real fov, Real aspect_ratio, Real near, Real far)\n```\n\n----------------------------------------\n\nTITLE: Generic List Operations in C3\nDESCRIPTION: Demonstrate creating and manipulating a generic list with integer elements, showing initialization, pushing, and freeing\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nimport std::collections::list;\nalias MyIntList = List{ int };\n\n...\n\nMyIntList list;\nlist.init(mem); // heap allocated\nlist.push(123);\nlist.free();\n```\n\n----------------------------------------\n\nTITLE: Creating Slices from Pointers in C3\nDESCRIPTION: Shows how to create a slice from a pointer to an array, demonstrating the ampersand operator for array-to-slice conversion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nb = &a; // Same as b = a[0..99];\n```\n\n----------------------------------------\n\nTITLE: Defining Function Pointer Alias in C3\nDESCRIPTION: Shows how to define and use function pointer aliases in C3, which is required for all function pointer usages.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nalias Callback = fn void();\nCallback a = null; // Ok!\nfn Callback getCallback() { /* ... */ } // Ok!\n\n// fn fn void() getCallback() { /* ... */ } - ERROR!\n// fn void() a = null; - ERROR!\n```\n\n----------------------------------------\n\nTITLE: LimitReader Implementation in C3\nDESCRIPTION: A wrapper around an InStream that limits the number of bytes that can be read, with methods for initialization, reading, and querying status.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_49\n\nLANGUAGE: c3\nCODE:\n```\nstruct LimitReader (InStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? LimitReader.available(&self) @inline @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? LimitReader.close(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn LimitReader* LimitReader.init(&self, InStream wrapped_stream, usz limit)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? LimitReader.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? LimitReader.read_byte(&self) @dynamic\n```\n\n----------------------------------------\n\nTITLE: If-Catch Example\nDESCRIPTION: Demonstrates the use of `if-catch` and implicit unwrapping of variables in the `else` clause and outer scope. If one or more variables are in the catch, then the \"else\" clause have these variables implicitly unwrapped.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\nint? a = foo();\nint? b = foo();\nif (catch a, b)\n{\n    // Do something\n}\nelse\n{\n    int x = a + b; // Valid, a and b are implicitly unwrapped.\n}\n```\n\n----------------------------------------\n\nTITLE: Using Static Initializers and Finalizers in C3\nDESCRIPTION: This snippet demonstrates how to define static initializers and finalizers in C3. It outlines their usage for executing code at program startup and shutdown, as well as the distinction from constructors and destructors in other languages.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nfn void run_at_startup() @init\n{\n    // Run at startup\n    some_function.init(512);\n} \n\nfn void run_at_shutdown() @finalizer\n{\n    some_thing.shutdown();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Identifiers for C Functions in C3\nDESCRIPTION: Shows how to use the @extern attribute to provide a different identifier for a C function within C3 code, while still linking to the correct external C function.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/cinterop.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nextern fn void foo_puts(char*) @extern(\"puts\"); // C \"puts\"\n\nfn void main()\n{\n    foo_puts(\"Hello, world!\"); // Still calls C \"puts\"\n}\n```\n\n----------------------------------------\n\nTITLE: Overlapping Bit Fields in C3\nDESCRIPTION: This code snippet demonstrates the use of the `@overlap` attribute to allow overlapping bit fields within a bitstruct.  It defines a `Foo` bitstruct where the `b` field overlaps with the `a` field. Without the `@overlap` attribute, this would be an error, as bit ranges cannot normally overlap.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_32\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nbitstruct Foo : char @overlap\n{\n    int a : 2..5;\n    // \"b\" is valid due to the @overlap attribute\n    int b : 1..3;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Normalizing a Quaternion in C3\nDESCRIPTION: A macro that normalizes a quaternion to unit length and returns the normalized quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_82\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.normalize(Quaternion q)\n```\n\n----------------------------------------\n\nTITLE: SimpleHeapAllocator Implementation in C3\nDESCRIPTION: Functions implementing the SimpleHeapAllocator, which provides a basic heap-based memory allocation interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_30\n\nLANGUAGE: c3\nCODE:\n```\nstruct SimpleHeapAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? SimpleHeapAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void SimpleHeapAllocator.init(&self, MemoryAllocFn allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void SimpleHeapAllocator.release(&self, void* old_pointer, bool aligned) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? SimpleHeapAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Method for Built-in Type in C3\nDESCRIPTION: Shows how to implement a dynamic method 'myname' for the built-in 'int' type to satisfy the 'MyName' interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn String int.myname(int*) @dynamic\n{\n    return \"I am int!\";\n}\n```\n\n----------------------------------------\n\nTITLE: Lexical Character Definitions\nDESCRIPTION: EBNF rules for basic character classifications including letters, digits, and special characters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_2\n\nLANGUAGE: ebnf\nCODE:\n```\nUC_LETTER       ::= [A-Z]\nLC_LETTER       ::= [a-z]\nLETTER          ::= UC_LETTER | LC_LETTER\nDIGIT           ::= [0-9]\nHEX_DIGIT       ::= [0-9a-fA-F]\nBINARY_DIGIT    ::= [01]\nOCTAL_DIGIT     ::= [0-7]\nLC_LETTER_US    ::= LC_LETTER | \"_\"\nUC_LETTER_US    ::= UC_LETTER | \"_\"\nALPHANUM        ::= LETTER | DIGIT\nALPHANUM_US     ::= ALPHANUM | \"_\"\nUC_ALPHANUM_US  ::= UC_LETTER_US | DIGIT\nLC_ALPHANUM_US  ::= LC_LETTER_US | DIGIT\n```\n\n----------------------------------------\n\nTITLE: Detecting Empty Optionals without Reading the Excuse in C3\nDESCRIPTION: Illustrates how to check for an empty Optional without actually reading or using the Excuse value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\nfn void test() \n{\n    int! optional_value = IoError.FILE_NOT_FOUND?;\n\n    // Find empty Optional, then handle inside scope\n    if (catch optional_value) \n    {\n        io::printn(\"Found empty Optional, the Excuse was not read\");\n    } \n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Aliases in C3\nDESCRIPTION: This snippet demonstrates how to create type aliases in C3 using the 'alias' keyword. It shows examples for creating aliases for basic types and arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nalias CharPtr = char*;\nalias Numbers = int[10];\n```\n\n----------------------------------------\n\nTITLE: Runtime Switch Case Evaluation\nDESCRIPTION: Demonstrates using switch statements with runtime-evaluated conditions as an enhanced if-else chain.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nswitch (true)\n{\n    case x < 0:\n        xless();\n    case x > 0:\n        xgreater();\n    default:\n        xequals();\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Variables with Inferred Types in C3\nDESCRIPTION: Defines the syntax for variable declarations using 'var' in C3. This can be used for runtime variables in macros or compile-time variables, with optional type inference from an expression.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_41\n\nLANGUAGE: C3\nCODE:\n```\nvar_stmt           ::= \"var\" IDENTIFIER | CT_IDENT | CT_TYPE_IDENT (\"=\" expr)? \";\"\n```\n\n----------------------------------------\n\nTITLE: Function and Macro Definition in C3\nDESCRIPTION: Shows naming conventions for functions and macros which must start with lowercase letters after any optional '_'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void theMostAmazingFunction()\n{\n    return;\n}\n\nmacro justDoIt(x)\n{\n    justDo(x);\n}\n```\n\n----------------------------------------\n\nTITLE: ASCII Character Operations\nDESCRIPTION: Functions for ASCII character manipulation and classification including case conversion and character type checking.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn bool char.is_alnum(char c)\nfn bool char.is_alpha(char c)\nfn char char.to_lower(char c)\nfn char char.to_upper(char c)\n```\n\n----------------------------------------\n\nTITLE: Implementing Low-Level Math Utilities in C3\nDESCRIPTION: A set of low-level mathematical macros for handling numeric overflow, underflow, and value evaluation, used as building blocks for other math functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_73\n\nLANGUAGE: c3\nCODE:\n```\nmacro double __math_oflow(ulong sign)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro float __math_oflowf(uint sign)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro double __math_uflow(ulong sign)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro float __math_uflowf(uint sign)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro __math_xflow(sign, v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro force_eval_add(x, v)\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Function in C3\nDESCRIPTION: Example of how to define a test function in C3 using the @test attribute. This function will be discovered and executed when running the test command.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_fn() @test\n{\n    assert(true == true, \"true is definitely true\");\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Operation Example\nDESCRIPTION: Illustrates element-wise arithmetic operations on vector types in C3. This example demonstrates how the multiplication operator applies to vectors, performing the operation on corresponding elements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_16\n\nLANGUAGE: c\nCODE:\n```\n\"int[<2>] a = { 1, 3 };\nint[<2>] b = { 2, 7 };\n\nint[<2>] c = a * b;\n// Equivalent to\nint[<2>] c = { a[0] * b[0], a[1] * b[1] };\n\"\n```\n\n----------------------------------------\n\nTITLE: Trailing Blocks for Macros in C3\nDESCRIPTION: Demonstrates C3's ability to use trailing blocks in macros, providing a more expressive syntax for certain patterns.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#define FOR_EACH(x, list) \\\nfor (x = (list); x; x = x->next)\n\n// Use:\nFoo *it;\nFOR_EACH(it, list)\n{\n    if (!process(it)) return;\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @for_each(list; @body(it))\n{\n    for ($typeof(list) x = list; x; x = x.next)\n    {\n        @body(x);\n    }\n}\n\n// Use:\n@for_each(list; Foo* x)\n{\n    if (!process(x)) return;\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Operations in C3\nDESCRIPTION: Shows vector declaration and arithmetic operations including element-wise operations and swizzling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nint[<2>] pos = { 1, 3 };\nint[<2>] speed = { 5, 7 };\npos += speed;              // pos is now { 6, 10 }\n\nint[<3>] test = pos.yxx;    // test is now { 10, 6, 6 }\n\n// Same as speed = speed * { 2, 2 }\nspeed = speed * 2;\n```\n\n----------------------------------------\n\nTITLE: String to New UTF-32 Conversion in C3\nDESCRIPTION: Converts a String to a new UTF-32 encoded Char32 array using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_42\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]? String.to_new_utf32(s) => s.to_utf32(allocator::heap()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Random Number Generation Methods in C3\nDESCRIPTION: Collection of function declarations for various random number generators in C3 including Sfc32Random, Sfc64Random, Sfc8Random, and SimpleRandom. These methods generate random values of different types (int, long, short, byte) and provide seed functionality.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_87\n\nLANGUAGE: c3\nCODE:\n```\nfn uint Sfc32Random.next_int(&sfc) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128 Sfc32Random.next_int128(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong Sfc32Random.next_long(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort Sfc32Random.next_short(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char Sfc64Random.next_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Sfc64Random.next_bytes(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint Sfc64Random.next_int(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128 Sfc64Random.next_int128(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong Sfc64Random.next_long(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort Sfc64Random.next_short(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char Sfc8Random.next_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Sfc8Random.next_bytes(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint Sfc8Random.next_int(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128 Sfc8Random.next_int128(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong Sfc8Random.next_long(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort Sfc8Random.next_short(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char SimpleRandom.next_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void SimpleRandom.next_bytes(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint SimpleRandom.next_int(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128 SimpleRandom.next_int128(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong SimpleRandom.next_long(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort SimpleRandom.next_short(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void SimpleRandom.set_seed(&self, char[] seed) @dynamic\n```\n\n----------------------------------------\n\nTITLE: DynamicArenaAllocator Implementation in C3\nDESCRIPTION: Functions implementing the DynamicArenaAllocator, which provides arena-based memory allocation with dynamic page growth capabilities.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_28\n\nLANGUAGE: c3\nCODE:\n```\nstruct DynamicArenaAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? DynamicArenaAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DynamicArenaAllocator.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DynamicArenaAllocator.init(&self, usz page_size, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DynamicArenaAllocator.release(&self, void* ptr, bool) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DynamicArenaAllocator.reset(&self, usz mark = 0) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? DynamicArenaAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Using Raw String Literals in C3\nDESCRIPTION: Illustrates the use of raw string literals in C3, which can span multiple lines and don't process escape sequences.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n// Note: String is a typedef inline char[]\nString three_lines =\n`multi\nline\nstring`;\n\nString foo = `C:\\foo\\bar.dll`;\nString bar = `\"Say ``hello``\"`;\n// Same as\nString foo = \"C:\\\\foo\\\\bar.dll\";\nString bar = \"\\\"Say `hello`\\\"\";\n```\n\n----------------------------------------\n\nTITLE: Using Typedef Inline for One-Way Type Conversion in C3\nDESCRIPTION: This snippet shows how to use 'typedef inline' in C3 to create types that can implicitly convert to their base type but not vice versa.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CString = char*;\ntypedef ZString = inline char*;\n...\nCString abc = \"abc\";\nZString alias = \"alias\";\n// char* from_abc = abc; // Error!\nchar* from_def = alias; // Valid!\n```\n\n----------------------------------------\n\nTITLE: Using $typeof Function in C3\nDESCRIPTION: Demonstrates how to use $typeof to get the type of an expression or variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nFoo f;\n$typeof(f) x = f;\n```\n\n----------------------------------------\n\nTITLE: ByteReader Implementation in C3\nDESCRIPTION: An implementation of InStream for reading from byte arrays, with methods for initialization, reading, seeking, and querying buffer status.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_46\n\nLANGUAGE: c3\nCODE:\n```\nstruct ByteReader (InStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteReader.available(&self) @inline @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteReader* ByteReader.init(&self, char[] bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ByteReader.len(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteReader.pushback_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteReader.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? ByteReader.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteReader.seek(&self, isz offset, Seek seek) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteReader.write_to(&self, OutStream writer) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Iterating Over Arrays in C3\nDESCRIPTION: This snippet shows different ways to iterate over arrays in C3 using foreach loops, including by copy and by reference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    int[4] arr = { 1, 2, 3, 5 };\n    foreach (item : arr)\n    {\n        io::printfn(\"item: %s\", item);\n    }\n\n    // Or equivalently, writing the type:\n    foreach (int x : arr)\n    {\n        /* ... */\n    }\n\n    int[4] arr2 = { };\n    foreach (idx, &item : arr2)\n    {\n        *item = 7 + idx; // Mutates the array element\n    }\n\n    // Or equivalently, writing the types\n    foreach (int idx, int* &item : arr2)\n    {\n        *item = 7 + idx; // Mutates the array element\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Accessing Enum Values in C3\nDESCRIPTION: This code demonstrates how to define an enum in C3 and access its values. Enum values are accessed via the enum's name, creating a separate namespace similar to C++ class enums.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum State : int \n{\n    WAITING,\n    RUNNING,\n    TERMINATED\n}\n\n// Access enum values via:\nState current_state = State.WAITING;\n```\n```\n\n----------------------------------------\n\nTITLE: Import Path Comparison in C3\nDESCRIPTION: Demonstrates the difference between using full and shortened import paths in C3, showing the conventional path-shortening approach.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/hello-world.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n- std::io::printn(\"Hello, World!\");\n+ io::printn(\"Hello, World!\");\n```\n\n----------------------------------------\n\nTITLE: Printing Values with io::print in C3\nDESCRIPTION: Demonstrate printing various types, including vectors, enums, and strings using io::print functionality\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Heat\n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main()\n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = WARM;\n    int[5] fib = { 0, 1, 1, 2, 3 };\n    String dialogue = \"secret\";\n\n    io::print(\"Hello\");   // Hello\n    io::print(20);        // 20\n    io::print(2.2);       // 2.200000\n    io::print(vec);       // [<4, 2>]\n    io::print(weather);   // WARM\n    io::print(fib);       // [0, 1, 1, 2, 3]\n    io::print(dialogue);  // secret\n}\n```\n\n----------------------------------------\n\nTITLE: Contract Documentation Example\nDESCRIPTION: Example of C3 contract documentation syntax showing parameter constraints and ensure directives\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_6\n\nLANGUAGE: C3\nCODE:\n```\n<* \n@param ptr [&inout] Pointer must not be null\n@ensure return > 0\n@pure\n@return? IoError, NetworkError\n*>\n```\n\n----------------------------------------\n\nTITLE: Pure Function Direct Violation\nDESCRIPTION: Shows how the compiler typically catches direct violations of pure function annotations when calling known impure functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nint i = 0;\n\nalias SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // <- ERROR: Only '@pure' functions may be called.\n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: ByteBuffer Implementation in C3\nDESCRIPTION: A buffer that implements both InStream and OutStream interfaces, with methods for initialization, memory management, reading, writing, and seeking.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_45\n\nLANGUAGE: c3\nCODE:\n```\nstruct ByteBuffer (InStream, OutStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteBuffer.available(&self) @inline @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ByteBuffer.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteBuffer.grow(&self, usz n)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteBuffer*? ByteBuffer.init_with_buffer(&self, char[] buf)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteBuffer*? ByteBuffer.new_init(&self, usz max_read, usz initial_capacity = 16, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteBuffer.pushback_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteBuffer.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? ByteBuffer.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteBuffer.seek(&self, isz offset, Seek seek) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ByteBuffer.shrink(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ByteBuffer*? ByteBuffer.temp_init(&self, usz max_read, usz initial_capacity = 16)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ByteBuffer.write(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ByteBuffer.write_byte(&self, char c) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Threading and Synchronization Primitives\nDESCRIPTION: Thread management, mutex operations, and condition variables implementation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_102\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Thread = NativeThread;\ndistinct Mutex = NativeMutex;\ndistinct ConditionVariable = NativeConditionVariable;\n```\n\n----------------------------------------\n\nTITLE: Printing Enum and Mixed Data Types using io::printfn in C3\nDESCRIPTION: This snippet demonstrates printing a mix of integer, uint128, and enum data types using the io::printfn function. It gives an example of how to format multiple types in a single print statement, showcasing the ability to print enums directly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Foo\n{\n    ABC,\n    BCD,\n    EFG,\n}\nfn void main()\n{\n    int a = 1234;\n    uint128 b = 0xFFEEDDCC_BBAA9988_77665544_33221100;\n    Foo foo = BCD;\n    io::printfn(\"a: %s, b: %d, foo: %s\", a, b, foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Printing Different Data Types in C3\nDESCRIPTION: This snippet demonstrates how to print various data types in C3 using io::printn. It includes printing integers, unsigned longs, doubles, and byte arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io; // Get the io functions.\n\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printn(a);\n    io::printn(b);\n    io::printn(d);\n    io::printn(hex);\n}\n```\n\n----------------------------------------\n\nTITLE: C3 $exec Scripting Mode\nDESCRIPTION: Shows how to use $exec in scripting mode to compile and run multiple C3 files on the fly during compilation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Compile foo.c3 and bar.c3 in the /scripts directory, invoke the resulting binary\n// with the argument 'test'\n$exec(\"foo.c3;bar.c3\", { \"test\" });\n\nfn void main()\n{\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: String to UTF-32 Conversion in C3\nDESCRIPTION: Converts a String to a UTF-32 encoded Char32 array using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_41\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]? String.to_utf32(s, Allocator allocator);\n```\n\n----------------------------------------\n\nTITLE: String to Double Conversion in C3\nDESCRIPTION: Converts a String to a double-precision floating-point number.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_36\n\nLANGUAGE: c3\nCODE:\n```\nfn double? String.to_double(s) => s.to_real(double);\n```\n\n----------------------------------------\n\nTITLE: Initializing Arrays in C3\nDESCRIPTION: Demonstrates explicit and implicit array initialization in C3 using both fixed-size and wildcard notation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nint[3] abc = { 1, 2, 3 }; // Explicit int[3]\nint[*] bcd = { 1, 2, 3 }; // Implicit int[3]\n```\n\n----------------------------------------\n\nTITLE: Array Initialization in C3\nDESCRIPTION: Demonstrates array initialization in C3 using both explicit size declaration and wildcard syntax for size inference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nint[3] abc = { 1, 2, 3 }; // Explicit int[3]\nint[*] bcd = { 1, 2, 3 }; // Implicit int[3]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Maximum Value of a Type in C3\nDESCRIPTION: Shows how to get the maximum value of an integer type using the 'max' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nushort max_ushort = ushort.max; // 65535\n```\n\n----------------------------------------\n\nTITLE: File Operations in C3\nDESCRIPTION: Functions and methods for file handling, including opening, closing, reading, writing, seeking, and metadata operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_56\n\nLANGUAGE: c3\nCODE:\n```\nstruct File (InStream, OutStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? File.close(&self) @inline @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool File.eof(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? File.flush(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? File.memopen(File* file, char[] data, String mode)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? File.read(&self, char[] buffer) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? File.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? File.reopen(&self, String filename, String mode)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? File.seek(&self, isz offset, Seek seek_mode = Seek.SET) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? File.write(&self, char[] buffer) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? File.write_byte(&self, char c) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? delete(String filename)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File from_handle(CFile file)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? get_size(String path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool is_file(String path)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? load_buffer(String filename, char[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? load_new(String filename, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? load_temp(String filename)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File? open(String filename, String mode)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File? open_path(Path path, String mode)\n```\n\n----------------------------------------\n\nTITLE: IP Networking Base Types and Address Functions in C3\nDESCRIPTION: Core networking types and address-related functions for the C3 standard library. Includes IP protocol enumeration, address types, and functions for address validation and conversion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_92\n\nLANGUAGE: c3\nCODE:\n```\nenum IpProtocol : char (AIFamily ai_family)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault NetError\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct InetAddress (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_any_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_link_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_loopback(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast_global(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast_link_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast_node_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast_org_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_multicast_site_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool InetAddress.is_site_local(InetAddress* addr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? InetAddress.to_format(InetAddress* addr, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String InetAddress.to_new_string(InetAddress* addr, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn AddrInfo*? addrinfo(String host, uint port, AIFamily ai_family, AISockType ai_socktype) @if(os::SUPPORTS_INET)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? int_to_new_ipv4(uint val, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? int_to_temp_ipv4(uint val)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn InetAddress? ipv4_from_str(String s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint? ipv4toint(String s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn InetAddress? ipv6_from_str(String s)\n```\n\n----------------------------------------\n\nTITLE: Using Function Pointers in C3\nDESCRIPTION: Shows how to define and use function pointers in C3. It includes an alias definition for a callback function and demonstrates assigning a function to a function pointer variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/examples.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nmodule demo;\n\nalias Callback = fn int(char* text, int value);\n\nfn int my_callback(char* text, int value)\n{\n    return 0;\n}\n\nCallback cb = &my_callback;\n\nfn void example_cb()\n{\n    int result = cb(\"demo\", 123);\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Floating-Point Literal Grammar\nDESCRIPTION: Defines the grammar for floating-point literals in C3, including decimal and hexadecimal forms.  It specifies the structure with integer parts, fractional parts, exponents, and allowed separators (underscores). The grammer uses Extended Backus-Naur Form (EBNF).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\n\"FLOAT_LIT       ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT\nDEC_FLOAT_LIT   ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT? \n                    | DECIMAL_DIGITS DEC_EXPONENT\n                    | '.' DECIMAL_DIGITS DEC_EXPONENT?\nDEC_EXPONENT    ::= [eE] [+-]? DECIMAL_DIGITS\nHEX_FLOAT_LIT   ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT\nHEX_MANTISSA    ::= HEX_DIGITS '.' HEX_DIGITS?\n                    | HEX_DIGITS\n                    | '.' HEX_DIGITS \nHEX_EXPONENT    ::= [pP] [+-] DECIMAL_DIGITS                    \n\"\n```\n\n----------------------------------------\n\nTITLE: Module Visibility Control in C3\nDESCRIPTION: Shows how to control symbol visibility using @private and @local attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\nfn void init() { .. }\n\nfn void open() @private { .. }\n```\n\n----------------------------------------\n\nTITLE: Module Declaration\nDESCRIPTION: This snippet demonstrates how to declare a module in C3 using the `module` keyword. It shows that a module can span multiple files and that different files can belong to different modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre-conditions for Macros in C3\nDESCRIPTION: Demonstrates how to use pre-conditions for macros in C3, utilizing the $defined and $assignable built-in functions for semantic checking.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require $defined(resource.open, resource.open()), `Expected resource to have an \"open\" function`\n @require resource != nil\n @require $assignable(resource.open(), void*)\n*>\nmacro open_resource(resource)\n{\n    return resource.open();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Array-Like Types in C3\nDESCRIPTION: Shows how to implement custom array-like types that support foreach iteration in C3 using operator attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/arrays.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nstruct DynamicArray\n{\n    usz count;\n    usz capacity;\n    int* elements;\n}\n\nmacro int DynamicArray.get(DynamicArray* arr, usz element) @operator([])\n{\n    return arr.elements[element];\n}\n\nmacro usz DynamicArray.count(DynamicArray* arr) @operator(len)\n{\n    return arr.count;\n}\n\nfn void DynamicArray.push(DynamicArray* arr, int value)\n{\n    arr.ensure_capacity(arr.count + 1);  // Function not shown in example.\n    arr.elements[arr.count++] = value;\n}\n\nfn void test()\n{\n    DynamicArray v;\n    v.push(3);\n    v.push(7);\n\n    // Will print 3 and 7\n    foreach (int i : v)\n    {\n        io::printfn(\"%d\", i);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Module Constraint Error Example\nDESCRIPTION: Shows an example of constraint violation and the resulting compile error when generic parameters don't meet the required conditions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nalias testFunction = vector::testFunc {Bar, float, int};\n\n// This would give the error\n// --> Parameter(s) failed validation:\n//     @require \"$assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)\" violated.\n```\n\n----------------------------------------\n\nTITLE: C3 Math Functions\nDESCRIPTION: Mathematical operations for floating point and integer values, including basic arithmetic, trigonometric functions, and logarithmic operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/builtins.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n$$ceil()      // Ceiling function\n$$trunc()     // Truncate function\n$$sin()       // Sine function\n$$cos()       // Cosine function\n$$log()       // Natural logarithm\n$$log2()      // Base-2 logarithm\n$$log10()     // Base-10 logarithm\n$$sqrt()      // Square root\n$$pow()       // Power function\n$$sat_add()   // Saturated addition\n$$sat_shl()   // Saturated left shift\n$$sat_sub()   // Saturated subtraction\n```\n\n----------------------------------------\n\nTITLE: Advanced Printing with Enums and Large Integers in C3\nDESCRIPTION: This snippet demonstrates printing enums and large integers (uint128) in C3 using io::printfn. It showcases C3's ability to print various types using the %s format specifier.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Foo\n{\n    ABC,\n    BCD,\n    EFG,\n}\nfn void main()\n{\n    int a = 1234;\n    uint128 b = 0xFFEEDDCC_BBAA9988_77665544_33221100;\n    Foo foo = BCD;\n    io::printfn(\"a: %s, b: %d, foo: %s\", a, b, foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Array Pointer Operations in C3\nDESCRIPTION: Shows how to pass pointers to arrays using temporary arrays in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test1(int[3]* z) { ... }\nfn void test2(int* z) { ... }\n\ntest1(&&(int[3]){ 1, 2, 3 });\ntest2(&&(int[3]){ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Compile-Time Switch Statement Syntax\nDESCRIPTION: Defines the syntax for compile-time switch and case statements using `$switch`, `$case`, and `$default`.  Statements in the branch not picked will not be semantically checked.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_21\n\nLANGUAGE: c\nCODE:\n```\n\nct_switch_stmt     ::= \"$switch\" (ct_expr_or_type)? \":\"\nct_case_stmt       ::= (\"$default\" | \"$case\" ct_expr_or_type) \":\" stmt*\n\n```\n\n----------------------------------------\n\nTITLE: Compile Time Conditional Macro Example in C3\nDESCRIPTION: Demonstrates the use of $if and $else in a macro to perform different operations based on compile time values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nmacro @foo($x, #y)\n{\n    $if $x > 3:\n        #y += $x * $x;\n    $else\n        #y += $x;\n    $endif\n}\n\nconst int FOO = 10;\n\nfn void test()\n{\n    int a = 5;\n    int b = 4;\n    @foo(1, a); // Allowed, expands to a += 1;\n    // @foo(b, a); // Error: b is not a compile time constant.\n    @foo(FOO, a); // Allowed, expands to a += FOO * FOO;\n}\n```\n\n----------------------------------------\n\nTITLE: Return Statement Syntax in C3\nDESCRIPTION: Shows the syntax for return statements in C3. Return statements can include an optional expression to return a value, and special handling for jumps within return expressions is described.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_39\n\nLANGUAGE: c\nCODE:\n```\nreturn_stmt        ::= \"return\" expr? \";\"\n```\n\n----------------------------------------\n\nTITLE: Converting String to Uppercase ASCII in C3\nDESCRIPTION: Function to create a new uppercase ASCII version of a string using a specified allocator or the heap allocator by default.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_28\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Default Value Handling with Optionals in C3\nDESCRIPTION: Shows how to handle empty Optionals by providing default values using the ?? operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void test_bad()\n{\n    int regular_value;\n    int? optional_value = function_may_error();\n    if (catch optional_value)\n    {\n        regular_value = -1;\n    }\n    if (try optional_value)\n    {\n        regular_value = optional_value;\n    }\n    io::printfn(\"The value was: %d\", regular_value);\n}\n\nfn void test_good()\n{\n    int regular_value = foo_may_error() ?? -1;\n    io::printfn(\"The value was: %d\", regular_value);\n}\n```\n\n----------------------------------------\n\nTITLE: Generic Type and Function Aliasing\nDESCRIPTION: Demonstrates how to use def to create aliases for parameterized types, functions, and variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nimport generic_foo;\n\n// Parameterized function aliases\ndef int_foo_call = generic_foo::foo_call(<int>);\ndef double_foo_call = generic_foo::foo_call(<double>);\n\n// Parameterized type aliases\ndef IntFoo = Foo(<int>);\ndef DoubleFoo = Foo(<double>);\n\n// Parameterized global aliases\ndef int_max_foo = generic_foo::max_foo(<int>);\ndef double_max_foo = generic_foo::max_foo(<double>);\n```\n\n----------------------------------------\n\nTITLE: First-class Names in C3 Macros\nDESCRIPTION: Illustrates how C3 macros can work with names as first-class entities, using the # symbol for field names.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\n#define offsetof(T, field) (size_t)(&((T*)0)->field)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz @offset($Type, #field)\n{\n    $Type* t = null;\n    return (usz)(uptr)&t.#field;\n}\n```\n\n----------------------------------------\n\nTITLE: Environment Variable Operations (C3)\nDESCRIPTION: Functions for manipulating environment variables, including getting, setting, and clearing values, as well as retrieving system directories.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_103\n\nLANGUAGE: c3\nCODE:\n```\nfn bool clear_var(String name)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? executable_path(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? get_config_dir(Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? get_home_dir(Allocator using = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? get_var(String name, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? get_var_temp(String name)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool set_var(String name, String value, bool overwrite = true)\n```\n\n----------------------------------------\n\nTITLE: Thread Pool Implementation in C3\nDESCRIPTION: Implementation of a thread pool with configurable size in C3. Provides functionality to initialize, push tasks to, and gracefully destroy a pool of worker threads.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_108\n\nLANGUAGE: c3\nCODE:\n```\nstruct QueueItem\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct ThreadPool\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! ThreadPool.destroy(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! ThreadPool.init(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! ThreadPool.push(&self, ThreadFn func, void* arg)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! ThreadPool.stop_and_destroy(&self)\n```\n\n----------------------------------------\n\nTITLE: Inline Enum Conversions in C3\nDESCRIPTION: This code demonstrates how to make an enum implicitly convert to its ordinal value or associated values using `inline`. The example shows how to declare an enum with an inline string parameter and how it can be used in string assignments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum MyEnum : char (inline String s)\n{\n    FOO = \"Hello\",\n    BAR = \"C3\"\n}\n\nenum OtherEnum : inline int\n{\n    ABC,\n    DEF,\n    GHI\n}\n\nfn void main()\n{\n    String a = MyEnum.FOO; // Same as MyEnum.FOO.s due to inline\n    String b = MyEnum.BAR;\n    io::printfn(\"%s %s!\", a, b); // Print \"Hello C3!\"\n    int x = OtherEnum.GHI; // Assigns the value 2 to x.\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing LinkedList Operations in C3\nDESCRIPTION: Defines a LinkedList struct and associated methods for linked list operations, including insertion, removal, and traversal of elements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nstruct LinkedList\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.clear(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.first(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type LinkedList.get(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.insert_at(&self, usz index, Type element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.last(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz LinkedList.len(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn LinkedList* LinkedList.new_init(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Node* LinkedList.node_at_index(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.peek(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.peek_last(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! LinkedList.pop_front(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.push(&self, Type value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.push_front(&self, Type value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz LinkedList.remove(&self, Type t) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.remove_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! LinkedList.remove_first(&self) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool LinkedList.remove_first_match(&self, Type t) @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! LinkedList.remove_last(&self) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool LinkedList.remove_last_match(&self, Type t)  @if(ELEMENT_IS_EQUATABLE)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LinkedList.set(&self, usz index, Type element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn LinkedList* LinkedList.temp_init(&self)\n```\n\n----------------------------------------\n\nTITLE: Struct Declaration Differences in C and C3\nDESCRIPTION: Demonstrates how struct declarations differ between C and C3, including removal of typedef and semicolon\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct\n{\n    int a;\n    struct\n    {\n        double x;\n    } bar;\n} Foo;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int a;\n    struct bar\n    {\n        double x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Compiler Detection of Pure Function Violations in C3\nDESCRIPTION: Shows a case where the compiler is likely to detect a violation of the @pure annotation, resulting in a compile-time error.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nint i = 0;\n\ndef SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // <- ERROR: Only '@pure' functions may be called. \n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: Force Unwrapping Optionals in C3\nDESCRIPTION: Shows how to force unwrap Optionals using the !! operator, which causes panic on empty Optionals.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void find_file_and_test()\n{\n    find_file()!!;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Associated Types of an Enum in C3\nDESCRIPTION: Shows how to access associated types of an enum using the 'associated' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nenum Foo : int (double d, String s)\n{\n    BAR = { 1.0, \"normal\" },\n    BAZ = { 2.0, \"exceptional\" }\n}\nString s = Foo.associated[0].nameof; // \"double\"\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Definitions and Declarations\nDESCRIPTION: This snippet defines grammar rules for defining identifiers, attributes, types, and type aliases in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_19\n\nLANGUAGE: yacc\nCODE:\n```\ndefine_ident\n\t: IDENT '=' path_ident opt_generic_parameters\n\t| CONST_IDENT '=' path_const opt_generic_parameters\n\t| AT_IDENT '=' path_at_ident opt_generic_parameters\n        ;\n\ndefine_declaration\n\t: DEF define_ident ';'\n\t| DEF define_attribute ';'\n\t| DEF TYPE_IDENT opt_attributes '=' opt_distinct_inline typedef_type ';'\n\t;\n\ntl_ct_if\n\t: CT_IF constant_expr ':' opt_tl_stmts CT_ENDIF\n\t| CT_IF constant_expr ':' opt_tl_stmts CT_ELSE opt_tl_stmts CT_ENDIF\n\t;\n\ntl_ct_switch\n\t: ct_switch tl_ct_switch_body CT_ENDSWITCH\n\t;\n```\n\n----------------------------------------\n\nTITLE: Nested Anonymous Sub-structs/unions in C3\nDESCRIPTION: This code illustrates how to define nested anonymous sub-structs/unions in C3, similar to C99 and later versions. The placement of struct/union names is different.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Person  \n{\n    char age;\n    String name;\n    union \n    {\n        int employee_nr;\n        uint other_nr;\n    }\n    union subname \n    {\n        bool b;\n        Callback cb;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Complex Number Operations in C3\nDESCRIPTION: Macros for performing arithmetic operations on complex numbers, including addition, subtraction, multiplication, division, and scaling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_69\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.add(self, Complex b)\nmacro Complex Complex.add_each(self, Real b)\nmacro Complex Complex.div(self, Complex b)\nmacro Complex Complex.mul(self, Complex b)\nmacro Complex Complex.scale(self, Real s)\nmacro Complex Complex.sub(self, Complex b)\nmacro Complex Complex.sub_each(self, Real b)\n```\n\n----------------------------------------\n\nTITLE: Implicit Widening Example in C3\nDESCRIPTION: This C3 code snippet shows examples of implicit widening in C3, explaining the conditions under which widening occurs for simple expressions and assignments. It also illustrates cases where explicit casts are needed due to multiple possible conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/conversion.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n\"int a = ...\nshort b = ...\nchar c = ...\nlong d = a; // Valid - simple expression.\nint e = (int)(d + (a + b)); // Error\nint f = (int)(d + ~b); // Valid\nlong g = a + b; // Valid\"\n```\n\n----------------------------------------\n\nTITLE: Bitstruct Endianness Example in C3\nDESCRIPTION: This code snippet illustrates how bitstructs follow the endianness of their underlying type. It defines a `Test` bitstruct with two ushort fields and demonstrates how the byte order within the bitstruct affects the output when cast to a uint and when accessing individual bytes through a char pointer. The example shows the output using `io::printfn` and byte-by-byte printing in a loop.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_29\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nbitstruct Test : uint\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n\nfn void test()\n{\n    Test t;\n    t.a = 0xABCD;\n    t.b = 0x789A;\n    char* c = (char*)&t;\n\n    // Prints 789AABCD\n    io::printfn(\"%X\", (uint)t);\n\n    for (int i = 0; i < 4; i++)\n    {\n        // Prints CDAB9A78\n        io::printf(\"%X\", c[i]);\n    }\n    io::printn();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: String Stripping in C3\nDESCRIPTION: Strips the specified needle from both ends of the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.strip(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Using C3 Compiler Constants\nDESCRIPTION: Basic compiler-provided constants that provide information about the current compilation context, including file information, function names, and timestamps.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/builtins.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n$$BENCHMARK_NAMES  // Array of benchmark function names\n$$BENCHMARK_FNS    // Array of benchmark function addresses\n$$DATE             // Current date\n$$FILE             // Current file name\n$$FILEPATH         // Current file with path\n$$FUNC             // Current function name\n$$FUNCTION         // Current function as expression\n$$LINE             // Current line number\n$$LINE_RAW         // Raw line number (for macros)\n$$MODULE           // Current module name\n$$TIME             // Current time\n```\n\n----------------------------------------\n\nTITLE: Setting Priority for Static Initializers in C3\nDESCRIPTION: This snippet illustrates how to set the execution priority for static initializers in C3. It presents an example that prints 'Hello' and 'World' at startup with specified priorities.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\n// Print \"Hello World\" at startup.\n\nfn void start_world() @init(3000)\n{\n    io::printn(\"World\");\n}\nfn void start_hello() @init(2000)\n{\n    io::print(\"Hello \");\n}\n```\n\n----------------------------------------\n\nTITLE: Operating System Detection Macros in C3\nDESCRIPTION: Macros for detecting the operating system type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_46\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool os_is_darwin()\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool os_is_posix()\n```\n\n----------------------------------------\n\nTITLE: UDP Socket API in C3\nDESCRIPTION: UDP socket API for datagram-based networking in C3. Provides functions for creating and connecting UDP sockets with various options and protocols.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_98\n\nLANGUAGE: c3\nCODE:\n```\ntypedef UdpSocket = inline Socket;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn UdpSocket? connect(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn UdpSocket? connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn UdpSocket? connect_async_to(AddrInfo* ai, SocketOption... options)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn UdpSocket? connect_to(AddrInfo* ai, SocketOption... options)\n```\n\n----------------------------------------\n\nTITLE: BitReader Implementation in C3\nDESCRIPTION: A utility for reading bits from a byte stream, with methods for initialization, clearing, and reading specified numbers of bits.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_43\n\nLANGUAGE: c3\nCODE:\n```\nstruct BitReader\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitReader.clear(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitReader.init(&self, InStream byte_reader)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? BitReader.read_bits(&self, uint nbits)\n```\n\n----------------------------------------\n\nTITLE: Inline Distinct Types for Implicit Conversion in C3\nDESCRIPTION: This code demonstrates how to use the `inline` keyword with distinct types to allow implicit conversions to their underlying types. While an inline distinct type can be implicitly converted to its underlying type, the reverse conversion (from the underlying type to the distinct type) is not allowed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ndistinct Abc = int;\ndistinct Bcd = inline int;\n\nfn void test()\n{\n    Abc a = 1;\n    Bcd b = 1;\n\n    // int i = a; Error: Abc cannot be implicitly converted to 'int'\n    int i = b; // This is valid\n\n    // However, 'inline' does not allow implicit conversion from \n    // the inline type to the distinct type:\n    // a = i; Error: Can't implicitly convert 'int' to 'Abc'\n    // b = i; Error: Can't implicitly convert 'int' to 'Bcd'\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Compile Time Assert Statement Syntax\nDESCRIPTION: Defines the syntax for a compile-time assert statement in C3, which checks a compile-time expression and creates a compile-time error with an optional message if the expression is false. After evaluation, the `$assert` becomes a NOP statement.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n\"ct_assert_stmt     ::= \\\"$assert\\\" constant_expr (\":\" constant_expr) \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Macro Pre-conditions with $defined\nDESCRIPTION: Shows how to implement pre-conditions for macros using the $defined builtin function to validate semantic correctness and resource availability.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require $defined(resource.open, resource.open()), `Expected resource to have an \"open\" function`\n @require resource != nil\n @require $assignable(resource.open(), void*)\n*>\nmacro open_resource(resource)\n{\n    return resource.open();\n}\n```\n\n----------------------------------------\n\nTITLE: Applying @align Attribute to Struct and Field in C3\nDESCRIPTION: This example demonstrates how to use the @align attribute to set minimum alignment for a struct and its field, increasing memory alignment for potential performance optimization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/attributes.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @align(32)\n{\n    int a;\n    int b @align(16);\n}\n```\n\n----------------------------------------\n\nTITLE: OS-Specific Networking Types in C3\nDESCRIPTION: Operating system-specific networking types and structures used for cross-platform socket programming. Defines address information types and socket address pointers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_94\n\nLANGUAGE: c3\nCODE:\n```\ntypedef AIFamily = CInt;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef AIFlags = CInt;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef AIProtocol = CInt;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef AISockType = CInt;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef SockAddrPtr = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct AddrInfo\n```\n\n----------------------------------------\n\nTITLE: Illustrating Array Handling in C3\nDESCRIPTION: This code demonstrates how C3 handles different types of arrays, showing that fixed arrays do not decay and have copy semantics, unlike in C.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/changesfromc.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint[3] a = { 1, 2, 3 };\nint[4]* b = &a; // No conversion\nint* c = a; // ERROR\nint* d = &a; // Valid implicit conversion\nint* e = b; // Valid implicit conversion\nint[3] f = a; // Copy by value!\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Kind in C3\nDESCRIPTION: Shows how to retrieve the TypeKind of a type using the 'kindof' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nTypeKind kind = int.kindof; // TypeKind.SIGNED_INT\n```\n\n----------------------------------------\n\nTITLE: Statement Definition in C3\nDESCRIPTION: Comprehensive list of supported statement types in C3, including control flow, declaration, and specialized statements\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_8\n\nLANGUAGE: c3-grammar\nCODE:\n```\nstatement\n\t: compound_statement\n\t| var_stmt\n\t| declaration_stmt\n\t| return_stmt\n\t| if_stmt\n\t| while_stmt\n\t| defer_stmt\n\t| switch_stmt\n\t| do_stmt\n\t| for_stmt\n\t| foreach_stmt\n\t| continue_stmt\n\t| break_stmt\n\t| nextcase_stmt\n\t| asm_block_stmt\n\t| ct_echo_stmt\n\t| ct_assert_stmt\n\t| ct_if_stmt\n\t| ct_switch_stmt\n\t| ct_foreach_stmt\n\t| ct_for_stmt\n\t| expr_no_list ';'\n\t| assert_stmt\n\t| ';'\n```\n\n----------------------------------------\n\nTITLE: Union Definition in C3\nDESCRIPTION: This code defines a union named `Integral` with members of different integer types.  It illustrates the basic syntax for defining a union in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nunion Integral\n{\n    char as_byte;\n    short as_short;\n    int as_int;\n    long as_long;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Random Number Generation Utility Macros in C3\nDESCRIPTION: Utility macros for random number generation, including seed creation, range-based random number generation, and type-specific random number generation (e.g., booleans, floats, doubles).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_93\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_random(random)\n\nmacro make_seed($Type, char[] input)\n\nmacro int next(random, int max)\n\nmacro void next_bool(random)\n\nmacro double next_double(random)\n\nmacro float next_float(random)\n\nfn int rand(int max) @builtin\n\nmacro void seed(random, seed)\n\nmacro void seed_entropy(random)\n\nfn void seeder(char[] input, char[] out_buffer)\n```\n\n----------------------------------------\n\nTITLE: Building a C3 Project\nDESCRIPTION: Command to build a C3 project with an optional target. The default target is 'debug' if not specified.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nc3c build [target]\n```\n\n----------------------------------------\n\nTITLE: Using $sizeof Function in C3\nDESCRIPTION: Shows how to use $sizeof to determine the allocation size needed for a value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\n$typeof(a)* x = allocate_bytes($sizeof(a));\n*x = a;\n```\n\n----------------------------------------\n\nTITLE: String to Temporary WString Conversion in C3\nDESCRIPTION: Converts a String to a temporary WString using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_46\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Using Function Pointers with 'def' in C3\nDESCRIPTION: This example showcases the requirement in C3 to use 'def' for all function pointers. It defines a function pointer type 'Callback' and uses it correctly in variable and function definitions. Direct usage of bare function pointer types results in an error.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\ndef Callback = fn void();\nCallback a = null; // Ok!\nfn Callback getCallback() { /* ... */ } // Ok!\n\n// fn fn void() getCallback() { /* ... */ } - ERROR!\n// fn void() a = null; - ERROR!\n```\n\n----------------------------------------\n\nTITLE: Detailed Non-recursive Import Usage in C3\nDESCRIPTION: Complete example demonstrating the practical use of non-recursive imports to avoid importing unwanted submodules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nmodule mylib;\nimport std::io;\nfn void only_want_this()\n{\n    io::printn(\"only_want_this\");\n}\n\nmodule mylib::submod;\nimport std::io;\nfn void undesired_fn()\n{\n    io::printn(\"undesired_fn\");\n}\n\nmodule my_code;\n// Using Non-recursive import undesired_fn not found\nimport mylib @norecurse; \n\n// Using Recursive import undesired_fn is found\n// import mylib;\n\nfn void main()\n{\n    mylib::only_want_this();\n    submod::undesired_fn(); // This should error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Macros in C3\nDESCRIPTION: This snippet demonstrates how to define and use macros in C3, showcasing immediate and deferred evaluation of macro arguments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo(a, b)\n{\n    return a(b);\n}\n\nfn int square(int x)\n{\n    return x * x;\n}\n\nfn int test()\n{\n    int a = 2;\n    int b = 3;    \n    return foo(&square, 2) + a + b; // 9\n    // return foo(square, 2) + a + b; \n    // Error the symbol \"square\" cannot be used as an argument.\n}\n\nmacro @foo(#a, b, #c)\n{\n    c = a(b) * b;\n}\n\nmacro @foo2(#a)\n{\n    return a * a;\n}\n\nfn int test1()\n{\n    int a = 2;\n    int b = 3; \n    @foo(square, a + 1, b);\n    return b; // 27   \n}\n\nfn int test2()\n{\n    return @foo2(1 + 1); // 1 + 1 * 1 + 1 = 3\n}\n\nImprove macro errors with preconditions:\n\n<*\n @param x \"value to square\"\n @require types::is_numeric($typeof(x)) \"cannot multiply\"\n*>\nmacro square(x)\n{\n    return x * x;\n}\n\nfn void test()\n{\n    square(\"hello\"); // Error: cannot multiply \"hello\"\n    int a = 1;\n    square(&a); // Error: cannot multiply '&a'\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumMap Operations in C3\nDESCRIPTION: Defines an EnumMap struct for mapping enum values to a specific value type, with methods for getting, setting, and formatting the map contents.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nstruct EnumMap (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ValueType EnumMap.get(&self, Enum key) @operator([]) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ValueType* EnumMap.get_ref(&self, Enum key) @operator(&[]) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumMap.init(&self, ValueType init_value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz EnumMap.len(&self) @operator(len) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumMap.set(&self, Enum key, ValueType value) @operator([]=) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! EnumMap.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String EnumMap.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String EnumMap.to_tstring(&self) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Comparing Backing Types of Bitstructs\nDESCRIPTION: This snippet contrasts two bitstruct definitions with different backing types (char array and uint) and highlights how this affects the layout of the fields. It includes test code that prints the byte representation of each configuration.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Test1 : char[4]\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\nbitstruct Test2 : char[4] @bigendian\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n\nfn void test()\n{\n    Test1 t1;\n    Test2 t2;\n    t1.a = t2.a = 0xABCD;\n    t1.b = t2.b = 0x789A;\n\n    char* c = (char*)&t1;\n    for (int i = 0; i < 4; i++) \n    {\n        // Prints CDAB9A78 on x86\n        io::printf(\"%X\", c[i]); \n    }\n    io::printn();\n\n    c = (char*)&t2;\n    for (int i = 0; i < 4; i++) \n    {\n        // Prints ABCD789A\n        io::printf(\"%X\", c[i]); \n    }\n    io::printn();\n}\n```\n\n----------------------------------------\n\nTITLE: Scaling a Quaternion in C3\nDESCRIPTION: A macro that scales a quaternion by a real scalar value and returns the scaled quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_83\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.scale(Quaternion a, Real s)\n```\n\n----------------------------------------\n\nTITLE: Multiple Module Imports with @norecurse in C3\nDESCRIPTION: Shows how to import multiple modules in one line and apply @norecurse selectively to individual imports.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nimport lib1, lib2;\n\nimport lib1 @norecurse, lib2;\n```\n\n----------------------------------------\n\nTITLE: Defining DString Type in C3\nDESCRIPTION: Defines the DString type as a dynamic string builder that supports various string operations at runtime, allowing flexible manipulation without manual memory allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\ntypedef DString (OutStream) = void*;\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Members in C3\nDESCRIPTION: This code demonstrates how to access struct members using dot notation in C3. It shows that dot notation works for both direct struct variables and pointers to structs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void test()\n{\n    Person p;\n    p.age = 21;\n    p.name = \"John Doe\";\n\n    io::printfn(\"%s is %d years old.\", p.name, p.age);\n\n    Person* p_ptr_ = &p;\n    p_ptr.age = 20; // Ok!\n\n    io::printfn(\"%s is %d years old.\", p_ptr.name, p_ptr.age);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: C3 Reserved Keywords\nDESCRIPTION: Core reserved keywords used in the C3 programming language including data types, control flow statements, and language constructs\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nvoid        bool        char        double\nfloat       float16     int128      ichar\nint         iptr        isz         long\nshort       uint128     uint        ulong\nuptr        ushort      usz         float128\nany         fault    \ttypeid      assert\nasm         bitstruct   break       case\ncatch       const       continue    alias\ndefault     defer       typedef     do\nelse        enum        extern      false\nfor         foreach     foreach_r \tfn\ntlocal      if          inline      import\nmacro       module      nextcase\tnull\nreturn      static      struct      switch\ntrue        try         union       var\nwhile       attrdef\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Bit Structures\nDESCRIPTION: This snippet defines grammar rules for bit structures in C3, a feature for defining compact bit field layouts with specific field widths and positions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_9\n\nLANGUAGE: yacc\nCODE:\n```\nbitstruct_declaration\n\t: BITSTRUCT TYPE_IDENT ':' type opt_attributes bitstruct_body\n\nbitstruct_body\n\t: '{' '}'\n\t| '{' bitstruct_defs '}'\n\t| '{' bitstruct_simple_defs '}'\n\t;\n\nbitstruct_defs\n\t: bitstruct_def\n\t| bitstruct_defs bitstruct_def\n\t;\n\nbitstruct_simple_defs\n\t: base_type IDENT ';'\n\t| bitstruct_simple_defs base_type IDENT ';'\n\t;\n\nbitstruct_def\n\t: base_type IDENT ':' constant_expr DOTDOT constant_expr ';'\n\t| base_type IDENT ':' constant_expr ';'\n\t;\n```\n\n----------------------------------------\n\nTITLE: Defining Extern Struct in C3\nDESCRIPTION: This snippet demonstrates how to define a struct with an external name to affect generated C headers. The 'extern' attribute changes the external representation of a type name. The code includes a function 'stat' using the defined struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Stat @extern(\"stat\")\n{\n    // ...\n} \n\nfn CInt stat(char* pathname, Stat* buf);\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguities with Module Paths in C3\nDESCRIPTION: This snippet shows how to resolve ambiguities when different modules define symbols with the same name by using the full module path.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nmodule test1;\nimport de, abc;\n// Context c = {} <- ambiguous\nabc::Context c = {};\n```\n\n----------------------------------------\n\nTITLE: Defer Statement Syntax\nDESCRIPTION: Defines the syntax for a defer statement in C3, which specifies a statement to be executed at scope exit, whether through return, break, continue, or rethrow. It also includes variants for `defer try` and `defer catch`.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_36\n\nLANGUAGE: c\nCODE:\n```\n\"defer_stmt         ::= \\\"defer\\\" (\\\"try\\\" | \\\"catch\\\")? stmt\"\n```\n\n----------------------------------------\n\nTITLE: Optional Shorthand Operations in C3\nDESCRIPTION: Demonstrates shorthand operations for working with Optionals using @catch and @ok macros.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn void main(String[] args)\n{\n    int? optional_value = io::FILE_NOT_FOUND?;\n    faultdef excuse = @catch(optional_value);\n    if (excuse)\n    {\n        io::printfn(\"Excuse found: %s\", excuse);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Raw Strings in C3\nDESCRIPTION: Shows how to use raw strings in C3, which are enclosed in backticks and don't process escape characters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nchar* foo = `C:\\foo\\bar.dll`;\nchar* bar = `\"Say ``hello``\"`;\n// Same as\nchar* foo = \"C:\\\\foo\\\\bar.dll\";\nchar* bar = \"\\\"Say `hello`\\\"\";\n```\n\n----------------------------------------\n\nTITLE: Short Function Declaration Syntax\nDESCRIPTION: Shows the concise arrow syntax for declaring simple functions in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// Regular\nfn int square(int x)\n{\n    return x * x;\n}\n// Short\nfn int square_short(int x) => x * x;\n```\n\n----------------------------------------\n\nTITLE: Optional Empty Check without Reading Excuse in C3\nDESCRIPTION: Demonstrates how to check for empty Optionals without reading the Excuse value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-advanced.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\nfn void test()\n{\n    int? optional_value = io::FILE_NOT_FOUND?;\n    if (catch optional_value)\n    {\n        io::printn(\"Found empty Optional, the Excuse was not read\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation with @if in C3\nDESCRIPTION: Demonstrates conditional compilation at the top level using @if attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo_win32() @if(env::WIN32)\n{\n    /* .... */\n}\n\nstruct Foo\n{\n    int a;\n    int b @if(env::NO_LIBC);\n}\n```\n\n----------------------------------------\n\nTITLE: Module Declaration Example\nDESCRIPTION: Example showing C3 module declaration syntax with visibility modifiers and generic parameters\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_5\n\nLANGUAGE: C3\nCODE:\n```\nmodule my_module @private;\nmodule arr {Type, LEN};\n```\n\n----------------------------------------\n\nTITLE: Compile Time For Loop in C3\nDESCRIPTION: Shows how to use $for loops with compile time variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo($a)\n{\n    $for var $x = 0; $x < $a; $x++:\n        io::printfn(\"%d\", $x);\n    $endfor\n}\n\nfn void test()\n{\n    foo(2);\n    // Expands to ->\n    // io::printfn(\"%d\", 0);\n    // io::printfn(\"%d\", 1);\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing Algorithms in C3\nDESCRIPTION: Implements various hashing algorithms including Adler32, CRC32, CRC64, and FNV32a.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_63\n\nLANGUAGE: c3\nCODE:\n```\nstruct Adler32\nstruct Crc32\nstruct Crc64\ndistinct Fnv32a = uint;\n\nfn uint Adler32.final(&self)\nfn void Adler32.init(&self)\nfn void Adler32.update(&self, char[] data)\nfn void Adler32.updatec(&self, char c)\nfn uint Adler32.encode(char[] data)\n\nfn uint Crc32.final(&self)\nfn void Crc32.init(&self, uint seed = 0)\nfn void Crc32.update(&self, char[] data)\nfn void Crc32.updatec(&self, char c)\nfn uint Crc32.encode(char[] data)\n\nfn ulong Crc64.final(&self)\nfn void Crc64.init(&self, uint seed = 0)\nfn void Crc64.update(&self, char[] data)\nfn void Crc64.updatec(&self, char c)\nfn ulong Crc64.encode(char[] data)\n\nfn void Fnv32a.init(&self)\nfn void Fnv32a.update(&self, char[] data)\nmacro void Fnv32a.update_char(&self, char c)\nfn uint Fnv32a.encode(char[] data)\n```\n\n----------------------------------------\n\nTITLE: SHA1 Hash Implementation in C3\nDESCRIPTION: Defines the Sha1 struct and methods for cryptographic hashing, including initialization, updating with data, and finalizing to produce a 20-byte hash value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_41\n\nLANGUAGE: c3\nCODE:\n```\nstruct Sha1\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[20] Sha1.final(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Sha1.init(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Sha1.update(&self, char[] data)\n```\n\n----------------------------------------\n\nTITLE: Adding Two Quaternions in C3\nDESCRIPTION: A macro function that adds two quaternions together and returns the result quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_73\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.add(Quaternion a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: Enum with Associated Static Values in C3\nDESCRIPTION: This code illustrates how to associate static values with each enum value in C3. The example shows how to define an enum with a string description and how to access the associated values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum State : int (String description) \n{\n    WAITING = \"waiting\",\n    RUNNING = \"running\",\n    TERMINATED = \"ended\",\n}\n\nfn void main() \n{\n    State process = State.RUNNING;\n    io::printfn(\"%s\", process.description);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Documentation Contracts in C3\nDESCRIPTION: Example demonstrating the use of documentation contracts in C3, showing various annotations including parameter documentation, requirements, deprecation notice, and custom attributes. The function takes an integer parameter and prints it.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/comments.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n Here are some docs.\n @param num_foo `The number of foos.`\n @require num_foo > 4 \n @deprecated\n @mycustom 2\n*>\nvoid bar(int num_foo)\n{\n    io::printfn(\"%d\", num_foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Type Casting with anycast in C3\nDESCRIPTION: Shows how to safely cast values using the anycast function, which returns an optional result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint b;\nany a = &b;\nfloat*? c = anycast(a, float); // Will return TYPE_MISMATCH\nint*? d = anycast(a, int);     // Works!\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Modules and Imports\nDESCRIPTION: This snippet defines grammar rules for module declarations and import statements in C3, including module parameters and import paths.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_20\n\nLANGUAGE: yacc\nCODE:\n```\nmodule_param\n    \t: CONST_IDENT\n    \t| TYPE_IDENT\n    \t;\n\nmodule_params\n\t: module_param\n    \t| module_params ',' module_param\n    \t;\n\nmodule\n\t: MODULE path_ident opt_attributes ';'\n\t| MODULE path_ident '{' module_params '}' opt_attributes ';'\n\t;\n\nimport_paths\n\t: path_ident\n\t| path_ident ',' path_ident\n\t;\n\nimport_decl\n    \t: IMPORT import_paths opt_attributes ';'\n    \t;\n```\n\n----------------------------------------\n\nTITLE: String to Unsigned Long Integer Conversion in C3\nDESCRIPTION: Converts a String to an unsigned long integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_32\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong? String.to_ulong(s, int base = 10) => s.to_integer(ulong, base);\n```\n\n----------------------------------------\n\nTITLE: Windows Thread Implementation\nDESCRIPTION: Windows-specific implementation of threading primitives and operations\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_118\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeThread = inline Win32_HANDLE;\nstruct NativeConditionVariable\nstruct NativeMutex\nstruct NativeOnceFlag\n// ... [rest of Windows thread functions]\n```\n\n----------------------------------------\n\nTITLE: Defining Module Structure in C3\nDESCRIPTION: Specifies the syntax for declaring modules in C3, including optional generic parameters and attributes. Modules use hierarchical paths separated by '::'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_43\n\nLANGUAGE: C3\nCODE:\n```\npath               ::= PATH_SEGMENT (\"::\" PATH_SEGMENT)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmodule_section     ::= \"module\" path opt_generic_params? attributes? \";\"\n```\n\nLANGUAGE: C3\nCODE:\n```\ngeneric_param      ::= TYPE_IDENT | CONST_IDENT\n```\n\nLANGUAGE: C3\nCODE:\n```\nopt_generic_params ::= \"{\" generic_param (\",\" generic_param)* \"}\"\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Memory Allocation in C3\nDESCRIPTION: Memory allocation for WebAssembly environments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_33\n\nLANGUAGE: c3\nCODE:\n```\nstruct WasmMemory\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? WasmMemory.allocate_block(&self, usz bytes)\n```\n\n----------------------------------------\n\nTITLE: Slicing Arrays in C3\nDESCRIPTION: This snippet shows various ways to create slices from arrays in C3, including using range syntax and omitting indices.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() \n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b = a[0 .. 4]; // The whole array as a slice.\n    int[] c = a[2 .. 3]; // { 50, 100 }\n\n    int[] b2 = a[0 : 5]; // { 1, 20, 50, 100, 200 } start-index 0, slice-length 5\n    int[] c2 = a[2 : 2]; // { 50, 100 } start-index 2, slice-length 2\n\n    int[] d = a[0..]; // Whole array\n    int[] e = a[..]; // Whole array\n    \n    int[] f = a[0 : 5]; // Whole array\n    int[] g = a[:5]; // Whole array\n}\n```\n\n----------------------------------------\n\nTITLE: Darwin-specific OS Functions (C3)\nDESCRIPTION: Structures and functions specific to Darwin (macOS) operating systems, including executable path retrieval and backtrace symbolization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_102\n\nLANGUAGE: c3\nCODE:\n```\nstruct Darwin_Dl_info\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Darwin_segment_command_64\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? executable_path(Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Alignment with alignof in C3\nDESCRIPTION: Demonstrates how to use the 'alignof' property to retrieve the alignment of a struct type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @align(8)\n{\n    int a;\n}\n\nuint a = Foo.alignof; // 8\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Functions and Macros\nDESCRIPTION: This snippet defines grammar rules for function and macro headers, parameters, and definitions in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_15\n\nLANGUAGE: yacc\nCODE:\n```\nfunc_macro_name\n\t: IDENT\n\t| AT_IDENT\n\t;\n\nfunc_header\n\t: optional_type type '.' func_macro_name\n\t| optional_type func_macro_name\n\t;\n\n\nmacro_header\n\t: func_header\n\t| type '.' func_macro_name\n\t| func_macro_name\n\t;\n\nfn_parameter_list\n\t: '(' parameters ')'\n\t| '(' ')'\n\t;\n\nparameters\n\t: parameter '=' expr\n\t| parameter\n\t| parameters ',' parameter\n\t| parameters ',' parameter '=' expr\n\t;\n\nparameter\n\t: type IDENT opt_attributes\n\t| type ELLIPSIS IDENT opt_attributes\n\t| type ELLIPSIS CT_IDENT\n\t| type CT_IDENT\n        | type ELLIPSIS opt_attributes\n\t| type HASH_IDENT opt_attributes\n\t| type '&' IDENT opt_attributes\n\t| type opt_attributes\n\t| '&' IDENT opt_attributes\n\t| HASH_IDENT opt_attributes\n\t| ELLIPSIS\n\t| IDENT opt_attributes\n\t| IDENT ELLIPSIS opt_attributes\n\t| CT_IDENT\n\t| CT_IDENT ELLIPSIS\n\t;\n\nfunc_definition\n\t: FN func_header fn_parameter_list opt_attributes ';'\n\t| FN func_header fn_parameter_list opt_attributes macro_func_body\n\t;\n```\n\n----------------------------------------\n\nTITLE: Normalized Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A function that performs normalized linear interpolation (nlerp) between two quaternions based on a given amount. Returns the normalized interpolated quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_79\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.nlerp(Quaternion q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Modifying Returned Excuses with Optionals in C3\nDESCRIPTION: Demonstrates how to use the '??' operator to change the Excuse type when an Optional is empty, allowing for more specific error handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfault NoHomework\n{\n    DOG_ATE_MY_HOMEWORK,\n    MY_TEXTBOOK_CAUGHT_FIRE,\n    DISTRACTED_BY_CAT_PICTURES\n}\n\nfn int! test() \n{\n    return IoError.FILE_NOT_FOUND?;\n}\n\nfn void! examples() \n{\n    int! a = test(); // IoError.FILE_NOT_FOUND\n    int! b = test(); // IoError.FILE_NOT_FOUND\n\n    // We can tell these apart by default assigning our own unique\n    // Excuse. Our custom Excuse is assigned only if an\n    // empty Optional is returned.\n    int! c = test() ?? NoHomework.DOG_ATE_MY_HOMEWORK?;\n    int! d = test() ?? NoHomework.DISTRACTED_BY_CAT_PICTURES?;\n\n    // If you want to immediately return with an Excuse, \n    // use the \"?\" and \"!\" operators together, see the code below:\n    int! e = test() ?? NoHomework.DOG_ATE_MY_HOMEWORK?!;\n    int! f = test() ?? NoHomework.DISTRACTED_BY_CAT_PICTURES?!;\n}\n```\n\n----------------------------------------\n\nTITLE: Temporary Memory Pool Usage in C3\nDESCRIPTION: Demonstrates the use of temporary allocation pools for scoped memory management.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\n@pool()\n{\n    void* some_mem = tmalloc(128);\n    foo(some_mem);\n};\n// Temporary allocations are automatically freed here.\n```\n\n----------------------------------------\n\nTITLE: Using Custom Identifiers for C Functions in C3\nDESCRIPTION: Shows how to use the @extern attribute to assign a different identifier to a C function within C3 code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/cinterop.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nextern fn void foo_puts(char*) @extern(\"puts\"); // C \"puts\"\n\nfn void main()\n{\n    foo_puts(\"Hello, world!\"); // Still calls C \"puts\"\n}\n```\n\n----------------------------------------\n\nTITLE: Switching on Excuse Values in C3\nDESCRIPTION: Demonstrates how to use 'if (catch)' to immediately switch on the Excuse value of an empty Optional.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn void! test() \n{\n    if (catch excuse = optional_value)\n    {\n        case NoHomework.DOG_ATE_MY_HOMEWORK:\n            io::printn(\"Dog ate your file\");\n        case IoError.FILE_NOT_FOUND:\n            io::printn(\"File not found\");\n        default:\n            io::printfn(\"Unexpected Excuse: %s\", excuse);\n            return excuse?;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using $exec Directive in C3\nDESCRIPTION: Demonstrates how to use the $exec directive to execute external programs and include their output in C3 code. Requires full trust level enabled with --trust=full flag.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// On Linux or MacOS this will insert 'String a = \"Hello world!\";'\n$exec(\"echo\", { \"String a = \\\"Hello world!\\\"\\;\" });\n\nfn void main()\n{\n\tio::printn(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Object Creation Functions in C3\nDESCRIPTION: Defines various functions for creating new Object instances with different data types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nmacro get_integer_value(Object* value, $Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_bool(bool b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* new_enum(e, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_float(double f, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_int(int128 i, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_null()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_obj(Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_string(String s, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Using Base64 and Hex Data Literals in C3\nDESCRIPTION: Demonstrates the usage of Base64 and hexadecimal data literals in C3, which initialize arrays of the char type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nchar[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\";\nchar[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n```\n\n----------------------------------------\n\nTITLE: Defining User Attributes in C3\nDESCRIPTION: Specifies the syntax for declaring user-defined attributes in C3. These can group multiple attributes and optionally take parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_42\n\nLANGUAGE: C3\nCODE:\n```\nattribute_decl     ::= \"attrdef\" AT_TYPE_IDENT (\"(\" parameters \")\")? attribute* \"=\" \"{\" attribute* \"}\" \";\"\n```\n\n----------------------------------------\n\nTITLE: Static Storage Example\nDESCRIPTION: Demonstrates the correct usage of `static` variables, ensuring that the initializer is a valid global initialization expression. It highlights that visibility is limited to the function where the static variable is declared.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_25\n\n\n\n----------------------------------------\n\nTITLE: Utilizing Short Function Declaration Syntax in C3\nDESCRIPTION: Introduces the concise syntax for declaring very short functions using `=>` in C3. This stylistic feature encourages clarity and brevity in function definitions by omitting the traditional block structure when feasible.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfn int square_short(int x) => x * x;\n\n```\n\n----------------------------------------\n\nTITLE: Getting Array Length in C3\nDESCRIPTION: Demonstrates how to obtain the length of an array type using the 'len' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nusz len = int[4].len; // 4\n```\n\n----------------------------------------\n\nTITLE: DString Modification Functions in C3\nDESCRIPTION: Functions for modifying the content of a DString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_38\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.delete(&self, usz start, usz len = 1)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.delete_range(&self, usz start, usz end)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.insert_at(&self, usz index, String s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.set(self, usz index, char c)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Operator Precedence Differences in C3 vs C\nDESCRIPTION: This code snippet shows examples of how operator precedence differs between C3 and C, particularly for bitwise operations, shift operators, and relational operators. It illustrates how parentheses may be required in C3 for certain expressions that would not need them in C.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/precedence.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\na + b >> c + d\n\n(a + b) >> (c + d) // C (+ - are evaluated before >>)\na + (b >> c) + d   // C3 (>> is evaluated before + -)\n\n\na & b == c\n\na & (b == c)       // C  (bitwise operators are evaluated after relational)\n(a & b) == c       // C3 (bitwise operators are evaluated before relational)\n\n\na > b == c < d\n\n(a > b) == (c < d) // C  (< > binds tighter than ==)\n((a > b) == c) < d // C3 Error, requires parenthesis!\n\n\na | b ^ c & d\n\na | ((b ^ c) & d)  // C  (All bitwise operators have different precedence)\n((a | b) ^ c) & d  // C3 Error, requires parenthesis!\n```\n\n----------------------------------------\n\nTITLE: OnStackAllocator Implementation in C3\nDESCRIPTION: Functions implementing the OnStackAllocator, which provides memory allocation from the stack with fallback to a parent allocator when needed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_29\n\nLANGUAGE: c3\nCODE:\n```\nstruct OnStackAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct OnStackAllocatorHeader\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? OnStackAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void OnStackAllocator.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void OnStackAllocator.init(&self, char[] data, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void OnStackAllocator.release(&self, void* old_pointer, bool aligned) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? OnStackAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Defer and Return Example\nDESCRIPTION: Illustrates the execution order of `defer` statements in relation to `return` statements with expressions. The return expression is evaluated before the defer statements are executed, and a temporary variable may be used to store the result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\nint a = 0;\ndefer a++;\nreturn a;\n// This is equivalent to\nint a = 0;\nint temp = a;\na++;\nreturn temp;\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Static Initialization\nDESCRIPTION: This snippet defines grammar rules for static initialization and finalization blocks in C3 that execute when the program starts or ends.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_10\n\nLANGUAGE: yacc\nCODE:\n```\nstatic_declaration\n\t: STATIC INITIALIZE opt_attributes compound_statement\n\t| STATIC FINALIZE opt_attributes compound_statement\n\t;\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Typedef Types in C3\nDESCRIPTION: This snippet demonstrates the usage of 'typedef' in C3 to create new types. It shows how typedef types differ from aliases in terms of type conversion and method definition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/alias.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Foo = int;\nFoo f = 0; // Valid since 0 converts to an int.\nf = f + 1;\nint i = 1;\n// f = f + i Error!\nf = f + (Foo)i; // Valid\n```\n\n----------------------------------------\n\nTITLE: POSIX-specific directory operations in C3\nDESCRIPTION: POSIX-specific implementations of directory listing and recursive directory removal operations. These functions are only available when the POSIX environment flag is set.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_60\n\nLANGUAGE: c3\nCODE:\n```\nfn PathList? native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_rmtree(Path dir)\n```\n\n----------------------------------------\n\nTITLE: External Temporary Allocator Usage in C3\nDESCRIPTION: Shows how to use an external temporary allocator to persist allocations beyond a pool scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// Store the temp allocator\nAllocator temp = tmem;\n@pool()\n{\n    // Note, 'temp != tmem' here!\n    void* some_mem = tmalloc(128);\n    // Allocate this on the external temp allocator\n    Foo* foo = allocator::new(temp, Foo);\n    foo.z = foo(some_mem);\n    // Now \"some_mem\" will be released,\n    // but the memory pointed to by \"foo\" is still valid.\n    return foo;\n};\n```\n\n----------------------------------------\n\nTITLE: Complex asm block example in C3\nDESCRIPTION: This snippet demonstrates a more complex asm block in C3, showcasing various assembly instructions and addressing modes. It includes moving values between variables, registers, and memory addresses, as well as using arithmetic expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/asm.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nint aa = 3;\nint g;\nint* gp = &g;\nint* xa = &a;\nusz asf = 1;\nasm\n{\n    movl x, 4;                  // Move 4 into the variable x\n    movl [gp], x;               // Move the value of x into the address in gp\n    movl x, 1;                  // Move 1 into x\n    movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1]\n    movl $eax, (23 + x);        // Move 23 + x into EAX\n    movl x, $eax;               // Move EAX into x\n    movq [&z], 33;              // Move 33 into the memory address of z\n}\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Modules with Constants in C3\nDESCRIPTION: Demonstrates how to parameterize a module with specific types and constant values. The example shows using float type and integer constant 3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/generics.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n// module custom_type {Type, VALUE}\nmodule custom_type {float, 3};\n```\n\n----------------------------------------\n\nTITLE: FNV64a Hash Type Definition and Functions in C3\nDESCRIPTION: Defines the Fnv64a hash type as an unsigned long integer and provides methods for initialization, updating with data, updating with a single character, and encoding string data.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_40\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Fnv64a = ulong;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Fnv64a.init(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Fnv64a.update(&self, char[] data)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void Fnv64a.update_char(&self, char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong encode(char[] data)\n```\n\n----------------------------------------\n\nTITLE: Implementing EnumSet Operations in C3\nDESCRIPTION: Defines an EnumSet distinct type and associated methods for set operations on enum values, including adding, removing, and combining sets.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\ndistinct EnumSet (Printable) = EnumSetType;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumSet.add(&self, Enum v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumSet.add_all(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn EnumSet EnumSet.and_of(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumSet.clear(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn EnumSet EnumSet.diff_of(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool EnumSet.has(&self, Enum v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn EnumSet EnumSet.or_of(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool EnumSet.remove(&self, Enum v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumSet.remove_all(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void EnumSet.retain_all(&self, EnumSet s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! EnumSet.to_format(&set, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String EnumSet.to_new_string(&set, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String EnumSet.to_tstring(&set) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn EnumSet EnumSet.xor_of(&self, EnumSet s)\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Scoping in C3\nDESCRIPTION: Macros for controlling memory allocation scopes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_50\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @pool(TempAllocator* #other_temp = null; @body) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @report_heap_allocs_in_scope(;@body())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @scoped(Allocator allocator; @body())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @stack_mem(usz $size; @body(Allocator mem)) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @stack_pool(usz $size; @body) @builtin\n```\n\n----------------------------------------\n\nTITLE: Character Element Grammar Specification\nDESCRIPTION: Defines the grammar rules for character elements, character literals and Unicode characters in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_5\n\nLANGUAGE: text\nCODE:\n```\nCHAR_ELEMENT    ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F]\nCHAR_LIT_BYTE   ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE\nCHAR_ESCAPE     ::= [abefnrtv\\'\\\"\\\\]\n                    | 'x' HEX_DIGIT HEX_DIGIT\nUNICODE_CHAR    ::= unicode_char\n                    | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n                    | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n                          HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Bitstruct in C3\nDESCRIPTION: This snippet demonstrates how to define a basic bitstruct named 'Foo' with specific bit ranges for its fields. It includes a test function that shows how to assign values to the fields and print the results using formatted output.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Foo : char\n{\n    int a : 0..2;\n    int b : 4..6;\n    bool c : 7;\n}\n\nfn void test()\n{   \n    Foo f;\n    f.a = 2;\n    char x = (char)f;\n    io::printfn(\"%d\", (char)f); // prints 2\n    f.b = 1;\n    io::printfn(\"%d\", (char)f); // prints 18 \n    f.c = true;\n    io::printfn(\"%d\", (char)f); // prints 146\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Conditions with 'if (try)' in C3\nDESCRIPTION: Demonstrates how to combine multiple 'if (try)' conditions using logical AND (&&). Note that logical OR (||) cannot be used in this context.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Returns Optional with an 'int' result or empty with an Excuse\nfn int! reliable_function()\n{\n    return 7; // Return an Optional result\n}\n\nfn void main(String[] args)\n{\n    int! reliable_result1 = reliable_function();\n    int! reliable_result2 = reliable_function();\n\n    // Unwrap the result from reliable_result1 and reliable_result2\n    if (try reliable_result1 && try reliable_result2 && 5 > 2)\n    {\n        // `reliable_result1` is can be used as a normal variable here\n        io::printfn(\"reliable_result1: %s\", reliable_result1);\n\n        // `reliable_result2` is can be used as a normal variable here\n        io::printfn(\"reliable_result2: %s\", reliable_result2);\n    }\n\n    // ERROR cannot use logical OR `||`\n    // if (try reliable_result1 || try reliable_result2)\n    // {\n    //     io::printn(\"this can never happen);\n    // }\n}\n```\n\n----------------------------------------\n\nTITLE: Unreachable Code Handling in C3\nDESCRIPTION: Example of marking code paths as unreachable using the unreachable() function for compiler optimization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nswitch (x)\n{\n    case 0:\n        foo();\n    case 1:\n        bar();\n    default:\n        // Should never happen.\n        unreachable(\"x should have been 0 or 1\");\n}\n```\n\n----------------------------------------\n\nTITLE: DString Creation and Initialization in C3\nDESCRIPTION: Functions for creating and initializing DStrings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_40\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.new_concat(self, DString b, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.new_init(&self, usz capacity = MIN_CAPACITY, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString new(String c = \"\", Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString new_join(String[] s, String joiner, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString new_with_capacity(usz capacity, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Labelled Break in C3\nDESCRIPTION: This snippet shows how to use a labelled break to exit an outer scope in C3. It prints numbers until i exceeds 10, then breaks out of the labeled 'FOO' if statement.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/statements.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int i)\n{\n    if FOO: (i > 0)\n    {\n        while (1)\n        {\n            io::printfn(\"%d\", i);\n            // Break out of the top if statement.\n            if (i++ > 10) break FOO;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Enum Names in C3\nDESCRIPTION: Demonstrates how to get an array of enum names using the 'names' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nenum FooEnum\n{\n    BAR,\n    BAZ\n}\nString[] x = FooEnum.names; // [\"BAR\", \"BAZ\"]\n```\n\n----------------------------------------\n\nTITLE: DString Stream Operations in C3\nDESCRIPTION: Functions for reading from and writing to streams with DStrings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_41\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! DString.read_from_stream(&self, InStream reader)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! DString.write(&self, char[] buffer) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! DString.write_byte(&self, char c) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Defining Structs, Unions and Enums in C3\nDESCRIPTION: Demonstrates the naming conventions for user-defined types in C3. Types must start with A-Z after optional '_' and include at least one lowercase letter. Shows usage of @extern attribute for C compatibility.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @extern(\"foo\")\n{\n    int x;\n    Bar bar;\n}\n\nunion Bar\n{\n    int i;\n    double d;\n}\n\nenum Baz\n{\n    VALUE_1,\n    VALUE_2\n}\n\nfaultdef OOPS, LOTS_OF_OOPS;\n```\n\n----------------------------------------\n\nTITLE: C3 Predefined Constants\nDESCRIPTION: Built-in constants for accessing compilation and runtime information in C3, prefixed with $$\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\n$$BENCHMARK_FNS  $$BENCHMARK_NAMES $$DATE\n$$FILE           $$FILEPATH        $$FUNC\n$$FUNCTION       $$LINE            $$LINE_RAW\n$$MODULE         $$TEST_FNS        $$TEST_NAMES\n$$TIME\n```\n\n----------------------------------------\n\nTITLE: External Function Declaration in C3\nDESCRIPTION: Demonstrates how to declare and use external C functions in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nextern fn int puts(char*);\n...\nputs(\"Hello world\");\n```\n\n----------------------------------------\n\nTITLE: Temporary String Copy in C3\nDESCRIPTION: Creates a temporary copy of a String using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tcopy(s) => s.copy(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Using Address-of Temporary Operator in C3\nDESCRIPTION: Demonstrates using the && operator to take the address of a temporary value, which differs from C's & operator. The pointer is only valid within the current function scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int* x) { ... }\n\ntest(&&1);\n\n// In C:\n// int x = 1;\n// test(&x);\n```\n\n----------------------------------------\n\nTITLE: C Language Interface Example\nDESCRIPTION: Shows how C3 Optional types are represented in C interface code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// C3 code:\nfn int? get_value();\n```\n\nLANGUAGE: c\nCODE:\n```\n// Corresponding C code:\nc3fault_t get_value(int *value_ref);\n```\n\n----------------------------------------\n\nTITLE: Linker Visibility and Exports in C3\nDESCRIPTION: This snippet demonstrates how to declare functions and globals that are linked in later using the `extern` keyword. It also shows how to explicitly mark a function as exported from a library using the `@export` attribute.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Compound Literals with Struct in C3\nDESCRIPTION: Shows how to use compound literals with structs in C3, including type declaration and initialization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int a;\n    double b;\n}\n\nfn void test1(Foo x) { ... }\n\n... \n\ntest1((Foo){ 1, 2.0 });\n```\n\n----------------------------------------\n\nTITLE: Module Declaration in C3\nDESCRIPTION: Demonstrates module naming convention which only allows lowercase letters, numbers, and underscores.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n```\n\n----------------------------------------\n\nTITLE: POSIX-specific Directory Operations\nDESCRIPTION: Directory listing and recursive removal operations specific to POSIX systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_65\n\nLANGUAGE: c3\nCODE:\n```\nfn PathList! native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\nfn void! native_rmtree(Path dir)\n```\n\n----------------------------------------\n\nTITLE: Array Pointer Operations in C3\nDESCRIPTION: Demonstrates passing array pointers using compound literals and the && operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void test1(int[3]* z) { ... }\nfn void test2(int* z) { ... }\n\ntest1(&&(int[3]){ 1, 2, 3 });\ntest2(&&(int[3]){ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Slice Creation from Pointers in C3\nDESCRIPTION: Shows how to create slices from array pointers and use range syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nb = &a; // Same as b = a[0..99];\n\na[..6]; // a[0..6]\na[1..]; // a[1..99]\na[..];  // a[0..99];\n```\n\n----------------------------------------\n\nTITLE: Declaring and Initializing Multi-Dimensional Arrays in C3\nDESCRIPTION: This snippet shows how to declare and initialize multi-dimensional arrays in C3, including irregular arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\n// Uses: <type>[<x-size>][<y-size>]\n// C3 declares the dimensions, inner-most to outer-most\nint[4][2] array = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n};\n\n// To match C we must invert the order of the dimensions \nint[2][4] array = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// C3 also supports Irregular arrays, for example:\nint[][4] array = {\n    { 1 },\n    { 2, 3 },\n    { 4, 5, 6 },\n    { 7, 8, 9, 10 },\n};\n```\n\n----------------------------------------\n\nTITLE: Importing Modules in C3\nDESCRIPTION: This snippet shows how to import another module in C3 using the `import` keyword. It also demonstrates that importing a module automatically imports its sub-modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nmodule bar;\nimport some;\n// import some::foo; <- not needed, as it is a sub module to \"some\"\nfn void test()\n{\n    foo::test();\n    // some::foo::test() also works.\n}\n```\n\n----------------------------------------\n\nTITLE: WriteBuffer Implementation in C3\nDESCRIPTION: A buffer around an OutStream that provides efficient writing operations, with methods for initialization, writing, flushing, and string view generation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_52\n\nLANGUAGE: c3\nCODE:\n```\nstruct WriteBuffer (OutStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? WriteBuffer.close(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? WriteBuffer.flush(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn WriteBuffer* WriteBuffer.init(&self, OutStream wrapped_stream, char[] bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String WriteBuffer.str_view(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? WriteBuffer.write(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? WriteBuffer.write_byte(&self, char c) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Using $eval Function in C3\nDESCRIPTION: Shows how to use the $eval compile-time function to convert strings to variable references.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nint a = 123;         // => a is now 123\n$eval(\"a\") = 222;    // => a is now 222\n$eval(\"mymodule::fooFunc\")(a); // => same as mymodule::fooFunc(a)\n```\n\n----------------------------------------\n\nTITLE: DString View Functions in C3\nDESCRIPTION: Functions for obtaining read-only views of DString content.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_43\n\nLANGUAGE: c3\nCODE:\n```\nfn String DString.str_view(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString DString.zstr_view(&self)\n```\n\n----------------------------------------\n\nTITLE: Defining Enum and Fault Values in C3\nDESCRIPTION: This code demonstrates the declaration of enums and faults with their corresponding values in C3. Enum and fault values follow the same naming convention as global constants, starting with an uppercase letter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nenum Baz \n{\n    VALUE_1,\n    VALUE_2\n}\n\nfault Err \n{\n    OOPS,\n    LOTS_OF_OOPS\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Object Structure in C3\nDESCRIPTION: Defines the Object structure which implements the Printable interface. This structure is likely used for generic object representation in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nstruct Object (Printable)\n```\n\n----------------------------------------\n\nTITLE: Formatter Implementation in C3\nDESCRIPTION: A utility for formatted output, with methods for initialization and various print operations including formatted printing with variable arguments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_48\n\nLANGUAGE: c3\nCODE:\n```\nstruct Formatter\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Formatter.init(&self, OutputFn out_fn, void* data = null)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Formatter.print(&self, String str)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Formatter.print_with_function(&self, Printable arg)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Formatter.printf(&self, String format, args...)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Formatter.vprintf(&self, String format, any[] anys)\n```\n\n----------------------------------------\n\nTITLE: Character Index from Position in String in C3\nDESCRIPTION: Finds the index of the specified character in the string, starting from a given position.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? String.index_of_char_from(s, char needle, usz start_index);\n```\n\n----------------------------------------\n\nTITLE: Binary Data Embedding in C3\nDESCRIPTION: Demonstrates how to embed binary data from files into C3 code using the $embed function, including length limiting and optional handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nchar[*] my_image = $embed(\"my_image.png\");\nchar[4] my_data = $embed(\"foo.txt\", 4);\nchar[]! my_image = $embed(\"my_image.png\");\nchar[] my_image = $embed(\"my_image.png\") ?? DEFAULT_IMAGE_DATA;\n```\n\n----------------------------------------\n\nTITLE: Compile Time Switch Without Argument in C3\nDESCRIPTION: Demonstrates using $switch without an argument for if-else chain behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmacro @foo($x, #y)\n{\n    $switch\n        $case $x > 10:\n            #y += $x * $x;\n        $case $x < 0:\n            #y += $x;\n        $default:\n            #y -= $x;\n    $endswitch\n}\n```\n\n----------------------------------------\n\nTITLE: Freeing String Memory in C3\nDESCRIPTION: Function to free the memory associated with a String using a specified allocator or the heap allocator by default.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.free(&s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Basic C3 Function Definition\nDESCRIPTION: The basic structure of a main function in C3 with an empty body. This demonstrates the function declaration syntax with return type before the function name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void main() {}\n```\n\n----------------------------------------\n\nTITLE: Platform-Specific LibcAllocator Implementations in C3\nDESCRIPTION: Platform-specific implementations of the LibcAllocator for different operating systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_37\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? LibcAllocator.acquire(&self, usz bytes, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void LibcAllocator.release(&self, void* old_ptr, bool aligned) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? LibcAllocator.resize(&self, void* old_ptr, usz new_bytes, usz alignment) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Force Unwrapping Optionals in C3\nDESCRIPTION: Shows how to use the '!!' operator to force unwrap an Optional, causing a panic if the Optional is empty. This should be used cautiously in production code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void find_file_and_test()\n{\n    find_file()!!;\n\n    // Force unwrap '!!' is roughly equal to:\n    // if (catch find_file()) unreachable(\"Unexpected excuse\");\n}\n```\n\n----------------------------------------\n\nTITLE: SIMD Memory Operations in C3\nDESCRIPTION: Macros for SIMD-enabled memory operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_49\n\nLANGUAGE: c3\nCODE:\n```\nmacro @gather_aligned(ptrvec, bool[<*>] mask, passthru, usz $alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @masked_load_aligned(ptr, bool[<*>] mask, passthru, usz $alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @masked_store_aligned(ptr, value, bool[<*>] mask, usz $alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @scatter_aligned(ptrvec, value, bool[<*>] mask, usz $alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro gather(ptrvec, bool[<*>] mask, passthru)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro masked_load(ptr, bool[<*>] mask, passthru)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro masked_store(ptr, value, bool[<*>] mask)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro scatter(ptrvec, value, bool[<*>] mask)\n```\n\n----------------------------------------\n\nTITLE: I/O Core Definitions in C3\nDESCRIPTION: Core I/O definitions including enumerations, faults, interfaces, and utility macros for stream operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_42\n\nLANGUAGE: c3\nCODE:\n```\nenum Seek\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault FormattingFault\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault IoError\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault PrintFault\n```\n\nLANGUAGE: c3\nCODE:\n```\ninterface InStream\n```\n\nLANGUAGE: c3\nCODE:\n```\ninterface OutStream\n```\n\nLANGUAGE: c3\nCODE:\n```\ninterface Printable\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @is_instream(#expr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @is_outstream(#expr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? @pushback_using_seek(&s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro char? @read_byte_using_read(&s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? @read_using_read_byte(&s, char[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? @write_byte_using_write(&s, char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? @write_using_write_byte(&s, char[] bytes)\n```\n\n----------------------------------------\n\nTITLE: Swizzling Operations on Vectors in C3\nDESCRIPTION: Shows how to perform swizzling operations on vectors using dot notation, including creating new vectors and accessing individual components.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/vectors.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint[<3>] a = { 11, 22, 33 };\nint[<4>] b = a.xxzx;                         // b = { 11, 11, 33, 11 }\nint c = b.w;                                 // c = 11;\nchar[<4>] color = { 0x11, 0x22, 0x33, 0xFF };\nchar red = color.r;                          // red = 0x11\nb.xy = b.zw;\ncolor.rg += { 1, 2 };\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling Functions in C3\nDESCRIPTION: Defines functions for handling bus errors, panics, and segmentation faults in C3 when specific environment conditions are met.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_bus_error(CInt i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_panic(String message)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_segmentation_fault(CInt i)\n```\n\n----------------------------------------\n\nTITLE: Defining DString Type in C3\nDESCRIPTION: Definition of the DString type as a distinct type implementing OutStream interface, backed by a void pointer.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_32\n\nLANGUAGE: c3\nCODE:\n```\ndistinct DString (OutStream) = void*;\n```\n\n----------------------------------------\n\nTITLE: Defining String Types in C3\nDESCRIPTION: Defines distinct types for wide strings and zero-terminated strings in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_58\n\nLANGUAGE: c3\nCODE:\n```\ndistinct WString = inline Char16*;\ndistinct ZString = inline char*;\n```\n\n----------------------------------------\n\nTITLE: Prioritized Static Initializers in C3\nDESCRIPTION: Demonstrates how to set execution priority for static initializers using numeric values. Higher priority values (1024-65535) execute later in the sequence.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/functions.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nfn void start_world() @init(3000)\n{\n    io::printn(\"World\");\n}\nfn void start_hello() @init(2000)\n{\n    io::print(\"Hello \");\n}\n```\n\n----------------------------------------\n\nTITLE: Non-Recursive Imports in C3\nDESCRIPTION: This snippet demonstrates the use of non-recursive imports using the `@norecurse` keyword in C3.  It imports the `mylib` module without importing its submodules, preventing potential name collisions.  This is contrasted with a normal import, which would include all submodules. The main function attempts to use a function from a submodule, demonstrating that it is not available due to the non-recursive import.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\n// Non-recursive import\nimport mylib @norecurse; \n\n// Normal import\nimport mylib; \n```\n\n----------------------------------------\n\nTITLE: Type Inference with Compound Literals in C3\nDESCRIPTION: Shows type inference usage with compound literals in C3, which is the preferred syntax when possible.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\ntest1({ 1, 2.0 });\ntest2({ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Direct Parameter Annotation Violation\nDESCRIPTION: Shows how the compiler typically catches direct violations of parameter annotations when attempting to modify an [in] parameter directly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param [&in] i\n*>\nfn void bad_func(int* i)\n{\n    *i = 2; // <- Compiler error: cannot write to \"in\" parameter\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Slice2d Structure in C3\nDESCRIPTION: Defines the Slice2d structure and its methods for handling 2D slices of arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nstruct Slice2d\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void Slice2d.@each(&self; @body(usz[<2>], Type))\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void Slice2d.@each_ref(&self; @body(usz[<2>], Type*))\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Slice2d.count(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Type[] Slice2d.get(self, usz idy) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Slice2d.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Slice2d Slice2d.slice(&self, isz x = 0, isz xlen = 0, isz y = 0, isz ylen = 0)\n```\n\n----------------------------------------\n\nTITLE: Implementing Printable Interface in C3\nDESCRIPTION: Demonstrates implementing the 'Printable' interface from the standard library for the 'Baz' struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn String Baz.to_new_string(Baz baz, Allocator allocator) @dynamic\n{\n    return string::printf(\"Baz(%d)\", baz.x, allocator: allocator);\n}\n```\n\n----------------------------------------\n\nTITLE: Enum Associated Values in C3\nDESCRIPTION: Shows how to access associated value types from an enum using the associated property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nenum Foo : int (double d, String s)\n{\n    BAR = { 1.0, \"normal\" },\n    BAZ = { 2.0, \"exceptional\" }\n}\nString s = Foo.associated[0].nameof; // \"double\"\n```\n\n----------------------------------------\n\nTITLE: Using @catch Macro for Excuse Retrieval in C3\nDESCRIPTION: Shows how to use the @catch macro to retrieve the Excuse from an Optional without causing automatic unwrapping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nfn void main(String[] args)\n{\n    int! optional_value = IoError.FILE_NOT_FOUND?;\n    \n    anyfault excuse = @catch(optional_value);\n    if (excuse)\n    {\n        io::printfn(\"Excuse found: %s\", excuse);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Examples in C3\nDESCRIPTION: Shows various memory allocation patterns using malloc and malloc_aligned.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nchar* data = malloc(8);\nint[<16>]*? data2 = malloc_aligned(16 * int.sizeof), 128);\n```\n\n----------------------------------------\n\nTITLE: Array Declaration and Usage in C vs C3\nDESCRIPTION: Shows how array declarations and pointer conversions differ between C and C3, including array size syntax and manual pointer conversion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint x[2] = { 1, 2 };\nint *y = x;\n```\n\nLANGUAGE: c3\nCODE:\n```\nint[2] x = { 1, 2 };\nint* y = &x;\n```\n\n----------------------------------------\n\nTITLE: Defining Faults for Optional Types in C3\nDESCRIPTION: This code demonstrates how to define fault types in C3 for use with optional types. Faults are used as excuses when an optional type does not contain a valid result. The underlying values are guaranteed to be unique across separately compiled code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfault IOResult\n{\n    IO_ERROR,\n    PARSE_ERROR\n}   \n\nfault MapResult\n{\n    NOT_FOUND\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Output of Struct Field Reflection in C3\nDESCRIPTION: Shows the output of the compile-time reflection example when run on an x64 architecture, displaying field information for the Foo struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_14\n\nLANGUAGE: text\nCODE:\n```\nField a, offset: 0, size: 4, type: int\nField b, offset: 8, size: 8, type: double\nField ptr, offset: 16, size: 8, type: int*\n```\n\n----------------------------------------\n\nTITLE: Inline Enum Conversions in C3\nDESCRIPTION: This code snippet shows how to use the `inline` keyword with enums to enable implicit conversion to the associated value or ordinal. `MyEnum` converts to its string `s`, while `OtherEnum` converts to its integer ordinal value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nenum MyEnum : char (inline String s)\n{\n    FOO = \"Hello\",\n    BAR = \"C3\"\n}\n\nenum OtherEnum : inline int\n{\n    ABC,\n    DEF,\n    GHI\n}\n\nfn void main()\n{\n    String a = MyEnum.FOO; // Same as MyEnum.FOO.s due to inline\n    String b = MyEnum.BAR;\n    io::printfn(\"%s %s!\", a, b); // Print \"Hello C3!\"\n    int x = OtherEnum.GHI; // Assigns the value 2 to x.\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Compile Time Conditionals in C3 Macros\nDESCRIPTION: This snippet shows how to use $if and $else for compile time conditionals within a C3 macro, along with compile time variables and constant expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nmacro @foo($x, #y)\n{\n    $if $x > 3:\n        #y += $x * $x;\n    $else\n        #y += $x;\n    $endif\n}\n\nconst int FOO = 10;\n\nfn void test()\n{\n    int a = 5;\n    int b = 4;\n    @foo(1, a); // Allowed, expands to a += 1;\n    // @foo(b, a); // Error: b is not a compile time constant.\n    @foo(FOO, a); // Allowed, expands to a += FOO * FOO;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation with Feature Flags in C3\nDESCRIPTION: This snippet shows how to use feature flags for conditional compilation in C3. It demonstrates how to define and check for feature flags using the $feature macro.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nint my_var @if($feature(USE_MY_VAR));\n\nfn int test()\n{\n    $if $feature(USE_MY_VAR):\n        return my_var;\n    $else\n        return 0;\n    $endif\n}\n```\n\n----------------------------------------\n\nTITLE: Slice Lifetime Example in C3\nDESCRIPTION: Illustrates a common error with slices where a slice referencing a local array is returned from a function, creating a dangling pointer situation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn int[] buggy_code()\n{\n    int[3] a;\n    int[] b = a[0..1];\n    return b; // returning a pointer to a!\n}\n```\n\n----------------------------------------\n\nTITLE: LIBC-specific OS File Operations in C3\nDESCRIPTION: Operating system operations for file handling that specifically rely on LIBC, providing low-level file access functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_58\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? native_fopen(String filename, String mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_fread(CFile file, char[] buffer) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? native_freopen(void* file, String filename, String mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_fseek(void* file, isz offset, Seek seek_mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_ftell(CFile file) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_fwrite(CFile file, char[] buffer) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_remove(String filename)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? native_temp_directory(Allocator allocator = allocator::heap()) @if(!env::WIN32)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? native_temp_directory(Allocator allocator = allocator::heap()) @if(env::WIN32)\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Visibility in C3\nDESCRIPTION: This snippet demonstrates how to override the default visibility (e.g., `@private`) using the `@public` attribute to make a function public.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo @private;\n\nfn void ab_private() { ... }        // Private\nfn void ab_public() @public { ... } // Public\n```\n\n----------------------------------------\n\nTITLE: Using $qnameof Function in C3\nDESCRIPTION: Demonstrates the use of $qnameof to get the fully qualified name of a function or variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nmodule abc;\nfn void test() { }\nint g = 1;\n\nString a = $qnameof(g); // => \"abc::g\"\nString b = $qnameof(test); // => \"abc::test\"\n```\n\n----------------------------------------\n\nTITLE: Building a Specific C3 Project Target\nDESCRIPTION: Build a specific target in a C3 project by specifying its name. This is useful when working with multiple targets defined in the project.json file.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nc3c build myc3project\n```\n\n----------------------------------------\n\nTITLE: Module Ambiguity Resolution in C3\nDESCRIPTION: Demonstrates how to resolve naming conflicts between modules using full path qualification.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule abc;\nstruct Context\n{\n    int a;\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nmodule de;\nstruct Context\n{\n    void* ptr;\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nmodule test1;\nimport de, abc;\n// Context c = {} <- ambiguous\nabc::Context c = {};\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Type Features in C3\nDESCRIPTION: This snippet shows new type features in C3, including bitstruct, fault, vector types, and generic types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_2\n\nLANGUAGE: C3\nCODE:\n```\n// Bitstruct\nbitstruct Flags : uint {\n    READ = 1,\n    WRITE = 2,\n    EXECUTE = 4\n}\n\n// Fault\nfault IOError {\n    FILE_NOT_FOUND,\n    PERMISSION_DENIED\n}\n\n// Vector type\nfloat[<4>] vector;\n\n// Optional type\nint! optional;\n\n// Enum with associated constants\nenum Color {\n    RED { rgb = 0xFF0000 },\n    GREEN { rgb = 0x00FF00 },\n    BLUE { rgb = 0x0000FF }\n}\n\n// Generic type\nList{ int } intList;\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Method for Existing Type in C3\nDESCRIPTION: Shows how to implement a dynamic method for an existing type (int) to satisfy an interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\n// This will make \"int\" satisfy the MyName interface\nfn String int.myname(int*) @dynamic\n{ \n    return \"I am int!\"; \n}\n```\n\n----------------------------------------\n\nTITLE: Macro Definition Example\nDESCRIPTION: Shows syntax for defining function-like and at-macros with various parameter types\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_4\n\nLANGUAGE: C3\nCODE:\n```\nmacro func(param1, $TypeParam)\nmacro @atmacro(&ref_param, $compile_time_val) { ... }\n```\n\n----------------------------------------\n\nTITLE: Vector Swizzling in C3\nDESCRIPTION: Demonstrates vector swizzling, a technique to rearrange or duplicate vector components using component names (x, y, z, etc.) to create a new vector.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nint[<3>] test = pos.yxx;    // test is now { 10, 6, 6 }\n```\n\n----------------------------------------\n\nTITLE: ASCII Character Manipulation Functions\nDESCRIPTION: Functions for testing and manipulating ASCII characters including case conversion and character classification\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn bool char.is_alnum(char c)\nfn bool char.is_alpha(char c)\nfn bool char.is_digit(char c)\nfn char char.to_lower(char c)\nfn char char.to_upper(char c)\n```\n\n----------------------------------------\n\nTITLE: String Splitting in C3\nDESCRIPTION: Splits the string by the specified needle, with optional maximum split count and allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nfn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Vector 2D Operations in C3\nDESCRIPTION: Methods for 2D vector operations in both double precision (Vec2) and float precision (Vec2f). Includes functionality for vector angle calculation, magnitude clamping, distance calculations, rotation, and transformations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_89\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.angle(self, Vec2 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.clamp_mag(self, double min, double max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.distance_sq(self, Vec2 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.rotate(self, double angle)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec2 Vec2.towards(self, Vec2 target, double max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.transform(self, Matrix4 mat)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.angle(self, Vec2f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.clamp_mag(self, float min, float max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.distance_sq(self, Vec2f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.rotate(self, float angle)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec2f Vec2f.towards(self, Vec2f target, float max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2f.transform(self, Matrix4f mat)\n```\n\n----------------------------------------\n\nTITLE: Dynamic List Implementation in C3\nDESCRIPTION: Dynamic array implementation with extensive functionality including element manipulation, searching, filtering, and array conversion methods. Implements the Printable interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nstruct List (Printable)\n\nfn void List.add_all(&self, List* other_list)\nfn void List.add_array(&self, Type[] array)\nfn Type[] List.array_view(&self)\nfn usz List.byte_size(&self) @inline\nfn void List.clear(&self)\nfn bool List.contains(&self, Type value) @if(ELEMENT_IS_EQUATABLE)\nfn Type? List.first(&self)\nfn void List.free(&self)\nfn Type List.get(&self, usz index) @inline\nfn Type* List.get_ref(&self, usz index) @operator(&[]) @inline\n```\n\n----------------------------------------\n\nTITLE: Optional Expression Propagation\nDESCRIPTION: Demonstrates how Optional types propagate through expressions and affect result types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void main(String[] args)\n{\n    // Returns Optional with result of type `int` or an Excuse\n    int! first_optional = 7;\n\n    // This is Optional too:\n    int! second_optional = first_optional + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Binary Data Embedding in C3\nDESCRIPTION: Shows how to embed binary data from files at compile time using the $embed function, including length limiting and optional handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nchar[*] my_image = $embed(\"my_image.png\");\nchar[4] my_data = $embed(\"foo.txt\", 4);\nchar[]? my_image = $embed(\"my_image.png\");\nchar[] my_image = $embed(\"my_image.png\") ?? DEFAULT_IMAGE_DATA;\n```\n\n----------------------------------------\n\nTITLE: Logical And Expression Syntax in C3\nDESCRIPTION: Defines the syntax for logical AND expressions with short-circuit evaluation\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nand_group_expr     ::= rel_group_expr | and_expr\nand_expr           ::= and_group_expr \"&&\" rel_group_expr\n```\n\n----------------------------------------\n\nTITLE: Implementing Do-Without-While Loop in C3\nDESCRIPTION: This function demonstrates a do-without-while loop in C3. It prints 'World!' if x is zero, otherwise it prints 'Hello World!'. The loop acts as if it had a while(0) condition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/statements.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int x)\n{\n    do \n    {\n        if (!x) break;\n        io::printf(\"Hello \");\n    };\n    io::printf(\"World!\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Self-Referencing Initialization Example\nDESCRIPTION: Provides an example to illustrate valid and invalid self-referencing initialization scenarios within variable declarations.  An init expression may refer to the **address** of the same variable that is declared, but not the **value** of the variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_26\n\nLANGUAGE: c\nCODE:\n```\nvoid* a = &a;  // Valid\nint a = a + 1; // Invalid\n```\n\n----------------------------------------\n\nTITLE: Using Varargs with Splat Operator in C3\nDESCRIPTION: Demonstrates how to pass variable arguments from one function to another using the splat operator (...) in C3, which forwards all arguments as-is.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(String format, args...)\n{\n\tio::printfn(format, ...args);\n}\n\nfn void main()\n{\n\ttest(\"Format: %s %d\", \"Foo\", 123);\n}\n```\n\n----------------------------------------\n\nTITLE: Path character and separator utility macros in C3\nDESCRIPTION: Utility macros for checking path separator characters and reserved path characters across different operating systems. These macros help with path normalization and validation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_65\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_posix_separator(char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_reserved_path_char(char c, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_reserved_win32_path_char(char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_separator(char c, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_win32_separator(char c)\n```\n\n----------------------------------------\n\nTITLE: Declaration Attributes in C3\nDESCRIPTION: Shows how C3 uses attributes for function declarations, providing a cleaner syntax compared to C macros.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/macros.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n#define PURE_INLINE __attribute__((pure)) __attribute__((always_inline))\nint foo(int x) PURE_INLINE { ... }\n```\n\nLANGUAGE: c3\nCODE:\n```\nattrdef @NoDiscardInline = { @nodiscard @inline };\nfn int foo(int) @NoDiscardInline { ... }\n```\n\n----------------------------------------\n\nTITLE: ReadBuffer Implementation in C3\nDESCRIPTION: A buffer around an InStream that provides efficient reading operations, with methods for initialization, reading, and string view generation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_50\n\nLANGUAGE: c3\nCODE:\n```\nstruct ReadBuffer (InStream)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? ReadBuffer.close(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ReadBuffer* ReadBuffer.init(&self, InStream wrapped_stream, char[] bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? ReadBuffer.read(&self, char[] bytes) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char? ReadBuffer.read_byte(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ReadBuffer.str_view(&self) @inline\n```\n\n----------------------------------------\n\nTITLE: Illustrating Ambiguous Conversions in C3\nDESCRIPTION: This code snippet demonstrates a case where multiple possible conversions exist, requiring explicit casts to clarify the intended behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/conversion.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nlong h = a + (b + c);\n\n// Possible intention 1\nlong h = (long)(a + (b + c));\n\n// Possible intention 2\nlong h = (long)a + (long)(b + c);\n\n// Possible intention 3\nlong h = (long)a + ((long)b + (long)c);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Library Interface in C3\nDESCRIPTION: Shows how to define and use dynamic library interfaces with version constraints.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nmodule dynlib;\nfn void do_something() @dynamic(4.0)\nfn void do_something_else() @dynamic(0, 5.0)\nfn void do_another_thing() @dynamic(0, 2.5)\n```\n\nLANGUAGE: c3\nCODE:\n```\nimport dynlib;\nfn void test()\n{\n    if (@available(dynlib::do_something))\n    {\n        dynlib::do_something();\n    }\n    else\n    {\n        dynlib::do_someting_else();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Suffix Expression Syntax in C3\nDESCRIPTION: Defines the syntax for converting a fault type to an optional with optional immediate return behavior\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nsuffix_group_exp   ::= or_group_expr | suffix_expr\nsuffix_expr        ::= or_group_expr \"?\" \"!\"?\n```\n\n----------------------------------------\n\nTITLE: Reflection-based Method Invocation in C3\nDESCRIPTION: Shows how to retrieve and invoke a dynamic method by name using reflection (note: functionality not yet implemented).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nalias VoidMethodFn = fn void(void*);\n\nfn void* int.test_something(&self) @dynamic\n{\n    io::printfn(\"Testing: %d\", *self);\n}\n\nfn void main()\n{\n    int z = 321;\n    any a = &z;\n    VoidMethodFn test_func = a.reflect(\"test_something\");\n    test_func(a); // Will print \"Testing: 321\"\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Variables and Functions in C3\nDESCRIPTION: Demonstrates how to declare Optional variables and function return signatures in C3. Optionals are denoted by the '!' suffix.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint! example = unreliable_function();\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! example() { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Literal Syntax in C3\nDESCRIPTION: This snippet showcases various new literal syntax features in C3, including octal and binary prefixes, digit separators, and byte data representations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_0\n\nLANGUAGE: C3\nCODE:\n```\n// Octal and binary prefixes\n0o123  // octal\n0b1010 // binary\n\n// Digit separator\n1_000_000\n\n// Hexadecimal and Base64 byte data\nx\"abcd\"\nb64\"QzM=\"\n\n// Character literals\n'a'   // 1 byte\n2cc'ab' // 2 bytes\n4cc'abcd' // 4 bytes\n\n// Raw string literal\n`This is a raw string literal`\n\n// Integer and float suffixes\n42u8   // unsigned 8-bit integer\n3.14f32 // 32-bit float\n```\n\n----------------------------------------\n\nTITLE: Using $offsetof Function in C3\nDESCRIPTION: Shows how to use $offsetof to get the offset of a member in a struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nFoo z;\n$offsetof(z.y); // => returns 8 on 64 bit, 4 on 32 bit\n```\n\n----------------------------------------\n\nTITLE: C3 Vector Operations\nDESCRIPTION: Vector-specific operations for reducing and manipulating vector values, supporting both integer and floating-point vectors.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/builtins.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\n$$reduce_add()      // Vector addition reduction\n$$reduce_mul()      // Vector multiplication reduction\n$$reduce_and()      // Vector AND reduction\n$$reduce_or()       // Vector OR reduction\n$$reduce_xor()      // Vector XOR reduction\n$$reduce_fadd()     // Float vector addition reduction\n$$reduce_fmul()     // Float vector multiplication reduction\n$$reduce_max()      // Vector maximum reduction\n$$reduce_min()      // Vector minimum reduction\n$$reverse()         // Vector value reversal\n$$shufflevector()   // Vector value rearrangement\n```\n\n----------------------------------------\n\nTITLE: Reverse Slicing in C3\nDESCRIPTION: This snippet demonstrates how to create reverse slices using the ^i syntax in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() \n{\n    int[5] a = { 1, 20, 50, 100, 200 };\n\n    int[] b1 = a[1 .. ^1];  // { 20, 50, 100, 200 } a[1 .. (a.len-1)]\n    int[] b2 = a[1 .. ^2];  // { 20, 50, 100 }      a[1 .. (a.len-2)]\n    int[] b3 = a[1 .. ^3];  // { 20, 50 }           a[1 .. (a.len-3)]\n\n    int[] c1 = a[^1..];     // { 200 }              a[(a.len-1)..]\n    int[] c2 = a[^2..];     // { 100, 200 }         a[(a.len-2)..]\n    int[] c3 = a[^3..];     // { 50, 100, 200 }     a[(a.len-3)..]\n\n    int[] d = a[^3 : 2];    // { 50, 100 }          a[(a.len-3) : 2]\n    \n    // Slicing a whole array, the inclusive index of : gives the difference\n    int[] e = a[0 .. ^1];   // a[0 .. a.len-1]\n    int[] f = a[0 : ^0];    // a[0 : a.len]\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running C3 Files\nDESCRIPTION: Compile multiple C3 source files and immediately run the resulting executable. This is useful for quickly testing small programs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile-run <file1> <file2> <file3>\n```\n\n----------------------------------------\n\nTITLE: Struct Declaration Comparison between C and C3\nDESCRIPTION: Demonstrates the differences in struct declaration syntax between C and C3, particularly the removal of semicolons and different nested struct syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\ntypedef struct\n{\n    int a;\n    struct\n    {\n        double x;\n    } bar;\n} Foo;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int a;\n    struct bar\n    {\n        double x;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Type ID in C3\nDESCRIPTION: Shows how to get the typeid of a type using the 'typeid' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\ntypeid x = Foo.typeid;\n```\n\n----------------------------------------\n\nTITLE: Printf with Different Data Types in C3\nDESCRIPTION: Demonstrate printf functionality with various data types including strings, numbers, enums, and vectors\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Heat\n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main()\n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = REALLY_WARM;\n    String dialogue = \"Hello\";\n\n    io::printfn(\"%s\", dialogue);  // Hello\n    io::printfn(\"%d\", 20);        // 20\n    io::printfn(\"%f\", 2.2);       // 2.200000\n    io::printfn(\"%s\", vec);       // [<4, 2>]\n    io::printfn(\"%s\", weather);   // REALLY_WARM\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Subtyping in C3\nDESCRIPTION: This snippet demonstrates struct subtyping in C3 using the `inline` keyword.  `ImportantPerson` is a subtype of `Person`, inheriting its members.  When passing the subtype to a function expecting the base type, only the inherited portion is copied.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct ImportantPerson\n{\n    inline Person person;\n    String title;\n}\n\nfn void print_person(Person p)\n{\n    io::printfn(\"%s is %d years old.\", p.name, p.age);\n}\n\n\nfn void test()\n{\n    ImportantPerson important_person;\n    important_person.age = 25;\n    important_person.name = \"Jane Doe\";\n    important_person.title = \"Rockstar\";\n\n    // Only the first part of the struct is copied.\n    print_person(important_person);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Dynamic Inclusion in C3\nDESCRIPTION: This snippet demonstrates how to use the `@dynamic` attribute and `@available` to conditionally include functions and globals from dynamic libraries based on versioning.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nmodule dynlib;\nfn void do_something() @dynamic(4.0)\nfn void do_something_else() @dynamic(0, 5.0)\nfn void do_another_thing() @dynamic(0, 2.5)\n```\n\n----------------------------------------\n\nTITLE: Scaling a Quaternion in C3\nDESCRIPTION: A macro function that scales a quaternion by a scalar value and returns the scaled quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_81\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.scale(Quaternion a, Real s)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Evaluation in C3\nDESCRIPTION: Shows usage of $eval for compile-time string evaluation of variables and functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nint a = 123;         // => a is now 123\n$eval(\"a\") = 222;    // => a is now 222\n$eval(\"mymodule::fooFunc\")(a); // => same as mymodule::fooFunc(a)\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Functions in C3\nDESCRIPTION: Low-level memory allocation functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_52\n\nLANGUAGE: c3\nCODE:\n```\nfn void* calloc(usz size) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* calloc_aligned(usz size, usz alignment) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void free(void* ptr) @builtin @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void free_aligned(void* ptr) @builtin @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* malloc(usz size) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* realloc(void *ptr, usz new_size) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* realloc_aligned(void *ptr, usz new_size, usz alignment) @builtin @inline @nodiscard\n```\n\n----------------------------------------\n\nTITLE: Implementing Bitorder Operations in C3\nDESCRIPTION: Defines various bitorder operations and checks for arrays and slices.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_array_or_slice_of_char(bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_arrayptr_or_slice_of_char(bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro is_bitorder($Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro read(bytes, $Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro write(x, bytes, $Type)\n```\n\n----------------------------------------\n\nTITLE: Conditional Function Execution with Optionals in C3\nDESCRIPTION: Demonstrates how Optional arguments affect function execution and error propagation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/optionals-essential.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn int test(int input, int input2)\n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int? first_optional = io::FILE_NOT_FOUND?;\n    int? second_optional = 7;\n\n    // Return first excuse we find\n    int? third_optional = test(first_optional, second_optional);\n    if (catch excuse = third_optional)\n    {\n        // excuse == io::FILE_NOT_FOUND\n        io::printfn(\"third_optional's Excuse: %s\", excuse);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Non-recursive Import Example in C3\nDESCRIPTION: Simple example showing the syntax difference between recursive and non-recursive imports in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n// Non-recursive import\nimport mylib @norecurse; \n\n// Normal import\nimport mylib; \n```\n\n----------------------------------------\n\nTITLE: Defining an Interface in C3\nDESCRIPTION: Illustrates how to define an interface named 'MyName' with a single method 'myname'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ninterface MyName\n{\n    fn String myname();\n}\n```\n\n----------------------------------------\n\nTITLE: Path creation and normalization functions in C3\nDESCRIPTION: Functions for creating new Path objects with different operating system conventions and normalizing path strings. These functions provide flexibility in creating and managing paths across different platforms.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_66\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? new(String path, Allocator allocator = allocator::heap(), PathEnv path_env = DEFAULT_PATH_ENV)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? new_posix(String path, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? new_win32_wstring(WString path, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? new_windows(String path, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? normalize(String path_str, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? tnew(String path, PathEnv path_env = DEFAULT_PATH_ENV)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? tgetcwd()\n```\n\n----------------------------------------\n\nTITLE: Module Declaration\nDESCRIPTION: This snippet demonstrates how to declare a module in C3 using the `module` keyword. It shows that a module can span multiple files and that different files can belong to different modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Safe Build C3 Code with Trap for Division by Zero\nDESCRIPTION: This snippet shows how the compiler handles potential division by zero in a safe build, adding a trap to catch and report the error.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/undefined-behaviour.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nuint x = foo();\nif (x == 0) trap(\"Division by zero\")\nreturn true;\n```\n\n----------------------------------------\n\nTITLE: Character Literal Grammar\nDESCRIPTION: Defines the grammar for character literals in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_9\n\nLANGUAGE: text\nCODE:\n```\nCHARACTER_LIT   ::= \"'\" (CHAR_LIT_BYTE+) | UNICODE_CHAR \"'\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Access Operator [] in C3\nDESCRIPTION: Demonstrates how to implement the array access operator [] for custom types. This allows using the my_type[<value>] syntax to access elements of a custom container.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    double[] x;\n}\n\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Windows-Specific Socket Operations in C3\nDESCRIPTION: Windows-specific socket implementation details conditionally compiled for Windows environments. Includes handle-based socket management and Windows socket error conversion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_96\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeSocket = uptr;\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? NativeSocket.close(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? NativeSocket.set_non_blocking(self, bool non_blocking)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn fault convert_error(WSAError error)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn fault socket_error()\n```\n\n----------------------------------------\n\nTITLE: Inline Typedefs in C3\nDESCRIPTION: This snippet demonstrates the use of `inline` in a `typedef` declaration.  An inline typedef allows implicit conversion from the new type to its underlying type, but not the other way around. It illustrates the difference in behavior compared to a regular `typedef`.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ntypedef Abc = int;\ntypedef Bcd = inline int;\n\nfn void test()\n{\n    Abc a = 1;\n    Bcd b = 1;\n\n    // int i = a; Error: Abc cannot be implicitly converted to 'int'\n    int i = b; // This is valid\n\n    // However, 'inline' does not allow implicit conversion from\n    // the inline type to the typedef type:\n    // a = i; Error: Can't implicitly convert 'int' to 'Abc'\n    // b = i; Error: Can't implicitly convert 'int' to 'Bcd'\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Usage Example\nDESCRIPTION: Demonstrates how to use function pointer aliases in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nCallback cb = my_callback;\ncb(10, false);\n```\n\n----------------------------------------\n\nTITLE: Retrieving Function Return Type in C3\nDESCRIPTION: Shows how to get the return type of a function using the 'returns' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nalias TestFunc = fn int(int, double);\nString s = TestFunc.returns.nameof; // \"int\"\n```\n\n----------------------------------------\n\nTITLE: String Starts With Check in C3\nDESCRIPTION: Checks if the string starts with the specified needle.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.starts_with(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Converting Quaternion to Matrix4 in C3\nDESCRIPTION: A macro function that converts a quaternion to a 4x4 matrix representation and returns the matrix.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_85\n\nLANGUAGE: c3\nCODE:\n```\nmacro Matrix4 Quaternion.to_matrix(Quaternion* q)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating New Expression Features in C3\nDESCRIPTION: This snippet illustrates new expression features in C3, including range initializers, new operators, and slice operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_3\n\nLANGUAGE: C3\nCODE:\n```\n// Array initializer with range\nint[256] x = { [0..128] = 1 };\n\n// Ternary operator\nint result = condition ? value1 : value2;\n\n// Orelse operator\nint value = optionalValue ?? defaultValue;\n\n// Rethrow operator\nreturn maybeError!;\n\n// Slice creation\nint[] slice = array[4..8];\n\n// Indexing from end\nint lastElement = array[^1];\n\n// Range assignment\narray[4..8] = 1;\n\n// Slice assignment\narray[4..8] = otherArray[8..12];\n\n// Array comparison\nbool areEqual = array1 == array2;\n\n// Optional conversion\nint? optionalValue = faultValue?;\n\n// Panic on optional\nint value = optionalValue!!;\n\n// Compile-time defined check\nbool isDefined = $defined(SOME_CONSTANT);\n\n// Compile-time logical operators\nbool result = CONDITION1 &&& CONDITION2;\n\n// Lambda\nfn(int x) => x * 2;\n\n// Swizzling\nvec4.xyz\n```\n\n----------------------------------------\n\nTITLE: Windows-specific File and Network Operations (C3)\nDESCRIPTION: Functions and structures for Windows-specific file and network operations, including module loading and backtrace resolution.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_110\n\nLANGUAGE: c3\nCODE:\n```\ntypedef WSAError = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum Win32_GET_FILEEX_INFO_LEVELS\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Symbol\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_FILE_ATTRIBUTE_DATA\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_WIN32_FIND_DATAW\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_pollfd\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Win32_DWORD? load_modules()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Backtrace? resolve_backtrace(void* addr, Win32_HANDLE process, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Using $nameof Function in C3\nDESCRIPTION: Demonstrates how to use $nameof to get the name of a function or variable without module prefixes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() { }\nint g = 1;\n\nString a = $nameof(g); // => \"g\"\nString b = $nameof(test); // => \"test\"\n```\n\n----------------------------------------\n\nTITLE: TrackingAllocator Implementation in C3\nDESCRIPTION: Functions implementing the TrackingAllocator, which tracks memory allocations and provides reporting capabilities for debugging memory usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_32\n\nLANGUAGE: c3\nCODE:\n```\nstruct TrackingAllocator (Allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TrackingEnv\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? TrackingAllocator.acquire(&self, usz size, AllocInitType init_type, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz TrackingAllocator.allocated(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz TrackingAllocator.allocation_count(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Allocation[] TrackingAllocator.allocations_tlist(&self, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TrackingAllocator.clear(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? TrackingAllocator.fprint_report(&self, OutStream out)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TrackingAllocator.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TrackingAllocator.init(&self, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TrackingAllocator.print_report(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void TrackingAllocator.release(&self, void* old_pointer, bool is_aligned) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? TrackingAllocator.resize(&self, void* old_pointer, usz size, usz alignment) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz TrackingAllocator.total_allocated(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz TrackingAllocator.total_allocation_count(&self)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Endianness in Bitstructs\nDESCRIPTION: This snippet defines a bitstruct named 'Test' and illustrates how to handle endianness. The code shows how to assign values to fields and print the byte representation in both little and big endian formats.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Test : uint\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n\nfn void test()\n{\n    Test t;\n    t.a = 0xABCD;\n    t.b = 0x789A;\n    char* c = (char*)&t;\n\n    // Prints 789AABCD\n    io::printfn(\"%X\", (uint)t); \n\n    for (int i = 0; i < 4; i++) \n    {\n        // Prints CDAB9A78\n        io::printf(\"%X\", c[i]); \n    }\n    io::printn();\n}\n```\n\n----------------------------------------\n\nTITLE: Pure Function Annotation Edge Case\nDESCRIPTION: Demonstrates a potential issue with pure function annotations where the compiler might not detect impure behavior through function pointers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/contracts.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nint i = 0;\n\nalias SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // The compiler cannot reason about this!\n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: Inverting a Quaternion in C3\nDESCRIPTION: A function that inverts a given quaternion and returns the inverted quaternion. This is useful for reversing rotations represented by quaternions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_75\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.invert(q)\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguities with Module Paths in C3\nDESCRIPTION: This snippet shows how to resolve ambiguities when different modules define symbols with the same name by using the full module path.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nmodule abc;\nstruct Context\n{\n    int a;\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling Individual Files in C3\nDESCRIPTION: Command to compile multiple individual C3 source files into an executable binary. Accepts a list of files to be compiled together.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile <file1> <file2> <file3>\n```\n\n----------------------------------------\n\nTITLE: Module Sections in C3\nDESCRIPTION: This snippet demonstrates how a single file can contain multiple module declarations, even for the same module. This allows using different imports or visibility for different parts of the code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\n// File foo.c3\nmodule foo;\nfn int hello_world()\n{\n    return my_hello_world();\n}\n\nmodule foo @private;\nimport std::io;         // The import is only visible in this section.\nfn int my_hello_world() // @private by default\n{\n    io::printn(\"Hello, world\\n\");\n    return 0;\n}\n\nmodule foo @test;\nfn void test_hello() // @test by default\n{\n    assert(hello_world() == 0);\n}\n```\n\n----------------------------------------\n\nTITLE: POSIX Time Functions in C3\nDESCRIPTION: POSIX-specific time functions in C3 for non-Darwin platforms. Provides native clock and timestamp implementations for POSIX systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_113\n\nLANGUAGE: c3\nCODE:\n```\nfn Clock native_clock() @if(!env::DARWIN)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time native_timestamp()\n```\n\n----------------------------------------\n\nTITLE: Defining Bitstructs in C3\nDESCRIPTION: This code shows how C3 replaces C's bitfields with bitstructs, providing a well-defined encapsulating type and exact bit layout.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/changesfromc.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Foo : short\n{  \n    int a : 0..2;\n    uint b : 3..6;\n    MyEnum c : 7..13;\n}\n\n// Simple form, only allowed when all fields are bools.\nstruct Flags : char\n{\n    bool has_hyperdrive;\n    bool has_tractorbeam;\n    bool has_plasmatorpedoes;\n}\n```\n\n----------------------------------------\n\nTITLE: Character Grammar\nDESCRIPTION: Defines the grammar for character literals in C3, including basic characters, escaped characters, and Unicode characters. It specifies the valid character ranges and escape sequences for representing special characters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_8\n\nLANGUAGE: text\nCODE:\n```\n\"CHAR_ELEMENT    ::= [\\x20-\\x26] | [\\x28-\\x5B] | [\\x5D-\\x7F]\nCHAR_LIT_BYTE   ::= CHAR_ELEMENT | \\x5C CHAR_ESCAPE\nCHAR_ESCAPE     ::= [abefnrtv\\'\\\"\\\\] \n                    | 'x' HEX_DIGIT HEX_DIGIT\nUNICODE_CHAR    ::= unicode_char                    \n                    | 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n                    | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT \n                          HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT\n\"\n```\n\n----------------------------------------\n\nTITLE: Nested Sub-structs and Unions in C3\nDESCRIPTION: This code snippet illustrates how to use nested anonymous sub-structs and unions in C3, similar to C99 and later. It shows the syntax for declaring these nested structures.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Person\n{\n    char age;\n    String name;\n    union\n    {\n        int employee_nr;\n        uint other_nr;\n    }\n    union subname\n    {\n        bool b;\n        Callback cb;\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Basic Nextcase Usage in Switch Statement\nDESCRIPTION: Demonstrates the nextcase statement for flow control in switch statements, allowing execution to continue into the next case.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nswitch (i)\n{\n    case 1:\n        doSomething();\n        nextcase; // Jumps to case 2\n    case 2:\n        doSomethingElse();\n}\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Assignability and Default Arguments in C3\nDESCRIPTION: This code illustrates function pointer assignability with default arguments in C3. Even if the function has default arguments and parameter names, they are disregarded when determining function pointer assignability, allowing `callback` to be assigned the address of `test`.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ndef Callback = fn void(int value = 1);\nfn void test(int a = 0) { /* ... */ }\n\nCallback callback = &test; // Ok\n\nfn void main()\n{\n    callback(); // Works, same as test(0);\n    test(); // Works, same as test(1);\n    callback(value: 3); // Works, same as test(3)\n    test(a: 4); // Works, same as test(4)\n    // callback(a: 3); // ERROR!\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly Block in C3\nDESCRIPTION: This snippet demonstrates the use of an `asm` block in C3.  It showcases the supported syntax for assembly instructions and arguments within the block. The C3 compiler infers register clobbers and in/out parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Misc Advanced/asm.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint aa = 3;\nint g;\nint* gp = &g;\nint* xa = &a;\nusz asf = 1;\nasm\n{\n    movl x, 4;                  // Move 4 into the variable x\n    movl [gp], x;               // Move the value of x into the address in gp\n    movl x, 1;                  // Move 1 into x\n    movl [xa + asf * 4 + 4], x; // Move x into the address at xa[asf + 1]\n    movl $eax, (23 + x);        // Move 23 + x into EAX\n    movl x, $eax;               // Move EAX into x\n    movq [&z], 33;              // Move 33 into the memory address of z\n}\n```\n\n----------------------------------------\n\nTITLE: Function Declaration Syntax in C vs C3\nDESCRIPTION: Shows how function declarations differ in C3 with the addition of the 'fn' keyword.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nint foo(Foo *b, int x, void *z) { ... }\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int foo(Foo* b, int x, void* z) { ... }\n```\n\n----------------------------------------\n\nTITLE: Defining a Big Endian Bitstruct\nDESCRIPTION: This snippet shows how to define a bitstruct with a big endian layout. The comments explain the output of the test function that reflects the difference in byte order based on the defined endianess.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Test : uint @bigendian\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Pointer and Integer Cast Syntax in C3 Language\nDESCRIPTION: This snippet provides examples of both integer to pointer and pointer to integer casts, delineating valid scenarios and constraints surrounding these operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_24\n\nLANGUAGE: C3\nCODE:\n```\nbyte a = 1;\nint* b = (int*)a; // Invalid, pointer type is > 8 bits.\nint* c = (int*)1; // Valid, but runtime value.\nint* d = (int*)0; // Valid and constant value.\n```\n\nLANGUAGE: C3\nCODE:\n```\nfn void test() { ... }\ndef VoidFunc = fn void test();\nVoidFunc a = &test;\nint b = (int)null;\nint c = (int)a; // Invalid, not constant\nint d = (int)((int*)1); // Invalid, not constant\n```\n\n----------------------------------------\n\nTITLE: Value Swapping Example in C3\nDESCRIPTION: Demonstrates using the @swap builtin function to exchange values between two variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nint a = 3;\nint b = 5;\n@swap(a, b);\nio::printfn(\"%d\", a); // Prints 5\n```\n\n----------------------------------------\n\nTITLE: Memory Management Enumerations in C3\nDESCRIPTION: Enumerations used for memory management and atomic operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_47\n\nLANGUAGE: c3\nCODE:\n```\nenum AtomicOrdering : int\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TempState\n```\n\n----------------------------------------\n\nTITLE: Creating Overlapping Bit Fields in Bitstructs\nDESCRIPTION: This snippet defines a bitstruct with overlapping bit fields using the @overlap attribute. It demonstrates how overlapping fields can be useful for modeling layouts that change based on flag bits.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Foo : char @overlap\n{\n    int a : 2..5;\n    // \"b\" is valid due to the @overlap attribute\n    int b : 1..3; \n}\n\n```\n\n----------------------------------------\n\nTITLE: Defer Try Success Example in C3\nDESCRIPTION: Demonstrates defer try execution when an Optional contains a result value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void? test()\n{\n    defer try io::printn(\"✅ defer try run\");\n    return;\n}\n\nfn void main(String[] args)\n{\n    (void)test();\n}\n```\n\n----------------------------------------\n\nTITLE: Subtracting Scalar from Quaternion in C3\nDESCRIPTION: A macro function that subtracts a scalar value from each component of a quaternion and returns the resulting quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_84\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.sub_each(Quaternion a, Real b)\n```\n\n----------------------------------------\n\nTITLE: Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A macro that performs linear interpolation between two quaternions based on a specified amount parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_79\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.lerp(Quaternion q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Compiling Individual Files in C3\nDESCRIPTION: Compile multiple C3 source files to produce an executable binary. This is the basic compilation command for standalone files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile <file1> <file2> <file3>\n```\n\n----------------------------------------\n\nTITLE: Defining External Name for a Struct in C3\nDESCRIPTION: Demonstrates how to use attributes to change the external name of a struct type in C3, which affects things like generated C headers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Stat @extern(\"stat\")\n{\n    // ...\n}\n\nfn CInt stat(char* pathname, Stat* buf);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Inclusion in C3\nDESCRIPTION: This snippet demonstrates how to use the `@dynamic` attribute and `@available` to conditionally include functions and globals from dynamic libraries based on versioning.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nimport dynlib;\nfn void test()\n{\n    if (@available(dynlib::do_something))\n    {\n        dynlib::do_something();\n    }\n    else\n    {\n        dynlib::do_someting_else();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Default Arguments\nDESCRIPTION: Shows how to use default arguments and named parameters with function pointer aliases.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\ndef TestFn = fn void(int y = 123);\n\nfn void test(int x = 5)\n{\n    io::printfn(\"X = %d\", x);\n}\n\nfn void main()\n{\n    TestFn test2 = &test;\n    test();         // Prints X = 5\n    test2();        // Prints X = 123\n    test(x: 3);     // Prints X = 3 \n    test2(y: 4);    // Prints X = 4\n}\n```\n\n----------------------------------------\n\nTITLE: String Literal Grammar\nDESCRIPTION: Defines the grammar for string literals in C3, specifying that they are enclosed in double quotes and can contain character literal bytes or Unicode characters. Explains the interpretation of backslash escapes within string literals and the representation of bytes and UTF-8 encoding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_10\n\nLANGUAGE: text\nCODE:\n```\n\"STRING_LIT      ::= \\x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \\x22\n\"\n```\n\n----------------------------------------\n\nTITLE: Time Handling Core Types and Functions in C3\nDESCRIPTION: Core time handling types and functions in C3, including representations for time durations, clock handling, date/time structures, and utility functions for time calculations and conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_109\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Clock = ulong;\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Duration = long;\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct NanoDuration (Printable) = long;\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Time = long;\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum Month : char\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum Weekday : char\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct DateTime\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct TzDateTime\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long Duration.to_ms(td)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn NanoDuration Duration.to_nano(td)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration NanoDuration.to_duration(nd)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! NanoDuration.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long NanoDuration.to_ms(nd)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double NanoDuration.to_sec(nd)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_days(time, long days)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_duration(time, Duration duration)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_hours(time, long hours)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_minutes(time, long minutes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_seconds(time, long seconds)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time Time.add_weeks(time, long weeks)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.diff_days(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.diff_hour(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.diff_min(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.diff_sec(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration Time.diff_us(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.diff_weeks(time, Time other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double Time.to_seconds(time)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration from_float(double s) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration hour(long l) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration min(long l) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration ms(long l) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time now()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration sec(long l) @inline\n```\n\n----------------------------------------\n\nTITLE: Defer Try Failure Example\nDESCRIPTION: Shows defer try behavior when an Optional contains an Excuse (error case).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void! test() \n{\n    defer try io::printn(\"❌ defer try not run\");\n    return IoError.FILE_NOT_FOUND?;\n}\n\nfn void main(String[] args) \n{\n    if (catch err = test()) \n    {\n        io::printfn(\"test() returned a fault: %s\", err);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Bitwise and Relational Operator Precedence in C3\nDESCRIPTION: Shows how bitwise operators have higher precedence than relational operators in C3, unlike in C\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/precedence.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\na & b == c\n```\n\nLANGUAGE: c3\nCODE:\n```\na & (b == c)       // C  (bitwise operators are evaluated after relational)\n(a & b) == c       // C3 (bitwise operators are evaluated before relational)\n```\n\n----------------------------------------\n\nTITLE: Calling C3 Functions from C\nDESCRIPTION: Demonstrates how to call exported C3 functions from C code, including the use of weak aliases.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/cinterop.md#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nextern int square(int);\nint foo_square(int) __attribute__ ((weak, alias (\"foo__square\")));\n\nvoid test()\n{\n    // This would call square2\n    printf(\"%d\\n\", square(11));\n\n    // This would call square\n    printf(\"%d\\n\", foo_square(11));\n}\n```\n\n----------------------------------------\n\nTITLE: Easing Functions in C3\nDESCRIPTION: A collection of easing functions for animation and interpolation, including various types of easing such as linear, quadratic, cubic, and more complex easing patterns.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_70\n\nLANGUAGE: c3\nCODE:\n```\nfn float back_in(float t, float b, float c, float d, float s = 1.70158f) @inline\nfn float back_inout(float t, float b, float c, float d, float s = 1.70158f) @inline\nfn float back_out(float t, float b, float c, float d, float s = 1.70158f) @inline\nfn float bounce_in(float t, float b, float c, float d) @inline\nfn float bounce_inout(float t, float b, float c, float d) @inline\nfn float bounce_out(float t, float b, float c, float d) @inline\nfn float circ_in(float t, float b, float c, float d) @inline\nfn float circ_inout(float t, float b, float c, float d) @inline\nfn float circ_out(float t, float b, float c, float d) @inline\nfn float cubic_in(float t, float b, float c, float d) @inline\nfn float cubic_inout(float t, float b, float c, float d) @inline\nfn float cubic_out(float t, float b, float c, float d) @inline\nfn float elastic_in(float t, float b, float c, float d) @inline\nfn float elastic_inout(float t, float b, float c, float d) @inline\nfn float elastic_out(float t, float b, float c, float d) @inline\nfn float expo_in(float t, float b, float c, float d) @inline\nfn float expo_inout(float t, float b, float c, float d) @inline\nfn float expo_out(float t, float b, float c, float d) @inline\nfn float linear_in(float t, float b, float c, float d) @inline\nfn float linear_inout(float t, float b, float c, float d) @inline\nfn float linear_none(float t, float b, float c, float d) @inline\nfn float linear_out(float t, float b, float c, float d) @inline\nfn float quad_in(float t, float b, float c, float d) @inline\nfn float quad_inout(float t, float b, float c, float d) @inline\nfn float quad_out(float t, float b, float c, float d) @inline\nfn float sine_in(float t, float b, float c, float d) @inline\nfn float sine_inout(float t, float b, float c, float d) @inline\nfn float sine_out(float t, float b, float c, float d) @inline\n```\n\n----------------------------------------\n\nTITLE: String Ends With Check in C3\nDESCRIPTION: Checks if the string ends with the specified needle.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.ends_with(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: If-Catch Implicit Unwrap Example\nDESCRIPTION: Illustrates how an `if-catch` statement can implicitly unwrap variables in the outer scope if the `then`-clause always exits the outer scope.  If an if-catch's \"then\"-clause will jump out of the outer scope in all code paths and the catch is on one or more variables, then this variable(s) will be implicitly unwrapped in the outer scope after the if-statement.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\nint? a = foo();\nif (catch a)\n{\n  return;\n}\nint x = a; // Valid, a is implicitly unwrapped.\n```\n\n----------------------------------------\n\nTITLE: Temporary Address Operator Example in C3\nDESCRIPTION: Demonstrates using the && operator to take the address of a temporary value in C3, which differs from C's & operator usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int* x) { ... }\n\ntest(&&1);\n\n// In C:\n// int x = 1;\n// test(&x);\n```\n\n----------------------------------------\n\nTITLE: Expr Statement Syntax\nDESCRIPTION: Defines the syntax for an expression statement in C3, which evaluates an expression. It also describes the `@nodiscard` and `@maydiscard` attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_38\n\nLANGUAGE: c\nCODE:\n```\n\"expr_stmt          ::= expr \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Custom Allocator Usage in C3\nDESCRIPTION: Example of using a custom allocator with the @scoped macro.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_9\n\nLANGUAGE: c\nCODE:\n```\nDynamicArenaAllocator dynamic_arena;\ndynamic_arena.init(1024);\nmem::@scoped(&dynamic_arena)\n{\n    // This allocation uses the dynamic arena\n    Foo* f = malloc(Foo);\n};\n// Release any dynamic arena memory.\ndynamic_arena.destroy();\n```\n\n----------------------------------------\n\nTITLE: Counting Enum Elements in C3\nDESCRIPTION: Demonstrates how to get the count of elements in an enum using the 'elements' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nenum FooEnum\n{\n    BAR,\n    BAZ\n}\nint x = FooEnum.elements; // 2\n```\n\n----------------------------------------\n\nTITLE: Using $evaltype Function in C3\nDESCRIPTION: Demonstrates the use of $evaltype compile-time function to convert strings to type references.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\n$evaltype(\"float\") f = 12.0f;\n```\n\n----------------------------------------\n\nTITLE: Backtrace Functionality (C3)\nDESCRIPTION: Structures and functions for handling backtraces, including initialization, memory management, and formatting.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_101\n\nLANGUAGE: c3\nCODE:\n```\nfault BacktraceFault\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Backtrace (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Backtrace.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Backtrace.has_file(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Backtrace* Backtrace.init(&self, uptr offset, String function, String object_file, String file = \"\", uint line = 0, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Backtrace.is_unknown(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Backtrace.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*[] capture_current(void*[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator) @if(!env::NATIVE_STACKTRACE)\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Changes in C3\nDESCRIPTION: Highlights the differences in switch statement behavior, including automatic breaks and nextcase\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nswitch (a)\n{\n    case 1:\n    case 2:\n        doOne();\n        break;\n    case 3:\n        i = 0;\n    case 4:\n        doFour();\n        break;\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nswitch (a)\n{\n    case 1:\n    case 2:\n        doOne();\n    case 3:\n        i = 0;\n        nextcase;\n    case 4:\n        doFour();\n}\n```\n\n----------------------------------------\n\nTITLE: Example of C3 Project Sources Configuration\nDESCRIPTION: Example JSON5 configuration for defining source directories in a C3 project.json file. This specifies where the compiler should look for source files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_4\n\nLANGUAGE: json5\nCODE:\n```\n...\n\"sources\": [ \"src/**\" ],\n...\n```\n\n----------------------------------------\n\nTITLE: Testing C3 Compiler\nDESCRIPTION: Command to test the built C3 compiler by compiling and running a hello world program.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ ./c3c compile-run ../resources/testfragments/helloworld.c3\n```\n\n----------------------------------------\n\nTITLE: Building and Running a C3 Project\nDESCRIPTION: Build the project if needed and then run the resulting executable. An optional target can be specified.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nc3c run [target]\n```\n\n----------------------------------------\n\nTITLE: WebAssembly Initialization in C3\nDESCRIPTION: WebAssembly-specific initialization function for C3 runtime when running without libc.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_39\n\nLANGUAGE: c3\nCODE:\n```\nfn void wasm_initialize() @extern(\"_initialize\") @wasm\n```\n\n----------------------------------------\n\nTITLE: String Concatenation Example\nDESCRIPTION: Illustrates compile-time string concatenation in C3, where adjacent string literals are automatically combined into a single string. This example shows how multiple string literals can be concatenated to form a longer string during compilation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\n\"String s = \\\"abc\\\" \\\"def\\\" \\\"ghi\\\";\n// This is equivalent to:\nString s = \\\"abcdefghi\\\";\n\"\n```\n\n----------------------------------------\n\nTITLE: Array Compound Literals in C3\nDESCRIPTION: Demonstrates array compound literals syntax in C3, including both explicit type declaration and type inference usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test2(int[3] x) { ... }\n\n...\n\ntest2((int[3]){ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: If Statement Syntax\nDESCRIPTION: Defines the syntax for `if` statements, including optional labels, a conditional expression, an `if_body` (which can be a non-compound statement, a compound statement, or a switch body), and an optional `else_clause`. It specifies how scopes are handled within the `then` and `else` clauses.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_30\n\nLANGUAGE: c\nCODE:\n```\n\nif_stmt            ::= \"if\" (label \":\")? \"(\" cond_expr \")\" if_body\nif_body            ::= non_compound_stmt | compound_stmt else_clause? | \"{\" switch_body \"}\"\nelse_clause        ::= \"else\" (if_stmt | compound_stmt)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing an Interface in C3\nDESCRIPTION: Shows how to implement the 'MyName' interface for a struct 'Baz' with a dynamic method.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nstruct Baz (MyName) \n{ \n    int x; \n}\n\n// Note how the first argument differs from the interface.\nfn String Baz.myname(Baz* self) @dynamic \n{ \n    return \"I am Baz!\"; \n}\n```\n\n----------------------------------------\n\nTITLE: Do Statement Syntax in C3\nDESCRIPTION: Defines the syntax for the do statement, which executes a block of code and then evaluates a condition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_46\n\nLANGUAGE: c3\nCODE:\n```\ndo_stmt            ::= \"do\" label? compound_stmt (\"while\" \"(\" cond_expr \")\")? \";\" \n```\n\n----------------------------------------\n\nTITLE: Equivalent If-Else Chain\nDESCRIPTION: Shows the equivalent if-else structure for the runtime switch case evaluation example.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nif (x < 0)\n{\n    xless();\n}\nelse if (x > 0)\n{\n    xgreater();\n}\nelse\n{\n    xequals();\n}\n```\n\n----------------------------------------\n\nTITLE: Nextcase Statement Syntax in C3\nDESCRIPTION: Defines the syntax for the nextcase statement, which is used to jump to another switch case.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_43\n\nLANGUAGE: c3\nCODE:\n```\nnextcase_stmt      ::= \"nextcase\" ((label \":\")? (expr | \"default\"))? \";\" \n```\n\n----------------------------------------\n\nTITLE: Building C3 Compiler\nDESCRIPTION: Command to build the C3 compiler using make.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ make\n```\n\n----------------------------------------\n\nTITLE: Base64 Encoding and Decoding in C3\nDESCRIPTION: Implements Base64 encoding and decoding functionality with customizable alphabet and padding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_61\n\nLANGUAGE: c3\nCODE:\n```\nstruct Base64Decoder\nstruct Base64Encoder\n\nfn usz! Base64Decoder.decode(&self, char[] src, char[] dst)\nfn usz! Base64Decoder.decode_len(&self, usz n)\nfn void! Base64Decoder.init(&self, String alphabet, int padding = '=')\nfn usz! Base64Encoder.encode(&self, char[] src, char[] dst)\nfn usz Base64Encoder.encode_len(&self, usz n)\nfn void! Base64Encoder.init(&self, String alphabet, int padding = '=')\n```\n\n----------------------------------------\n\nTITLE: EnumMap Implementation in C3\nDESCRIPTION: Map implementation specifically designed for enum keys with methods for getting, setting values and string conversion capabilities. Implements the Printable interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nstruct EnumMap (Printable)\n\nfn ValueType EnumMap.get(&self, Enum key) @operator([]) @inline\nfn ValueType* EnumMap.get_ref(&self, Enum key) @operator(&[]) @inline\nfn void EnumMap.init(&self, ValueType init_value)\nfn usz EnumMap.len(&self) @operator(len) @inline\nfn void EnumMap.set(&self, Enum key, ValueType value) @operator([]=) @inline\nfn usz? EnumMap.to_format(&self, Formatter* formatter) @dynamic\nfn String EnumMap.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\nfn String EnumMap.to_tstring(&self) @dynamic\n```\n\n----------------------------------------\n\nTITLE: macOS Core Foundation Bindings (C3)\nDESCRIPTION: Type definitions and macros for interacting with macOS Core Foundation framework, including memory allocation and array operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_105\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFAllocatorContextRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFAllocatorRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFArrayCallBacksRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFArrayRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFMutableArrayRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef CFTypeRef = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct CFRange\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* CFAllocatorRef.alloc(CFAllocatorRef allocator, usz size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void CFAllocatorRef.dealloc(CFAllocatorRef allocator, void* ptr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz CFAllocatorRef.get_preferred_size(CFAllocatorRef allocator, usz req_size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void CFAllocatorRef.set_default(CFAllocatorRef allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro CFAllocatorRef default_allocator()\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Structs and Unions\nDESCRIPTION: This snippet defines grammar rules for struct and union declarations in C3, including their bodies and member declarations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_13\n\nLANGUAGE: yacc\nCODE:\n```\nstruct_or_union\n\t: STRUCT\n\t| UNION\n\t;\n\nstruct_declaration\n\t: struct_or_union TYPE_IDENT opt_attributes struct_body\n    \t;\n\nstruct_body\n    \t: '{' struct_declaration_list '}'\n\t;\n\nstruct_declaration_list\n\t: struct_member_decl\n    \t| struct_declaration_list struct_member_decl\n    \t;\n\nenum_params\n\t: enum_param_decl\n\t| enum_params ',' enum_param_decl\n\t;\n\nenum_param_list\n\t: '(' enum_params ')'\n\t| '(' ')'\n\t| empty\n\t;\n\nstruct_member_decl\n    \t: type identifier_list opt_attributes ';'\n    \t| struct_or_union IDENT opt_attributes struct_body\n    \t| struct_or_union opt_attributes struct_body\n    \t| BITSTRUCT ':' type opt_attributes bitstruct_body\n    \t| BITSTRUCT IDENT ':' type opt_attributes bitstruct_body\n    \t| INLINE type IDENT opt_attributes ';'\n    \t| INLINE type opt_attributes ';'\n\t;\n```\n\n----------------------------------------\n\nTITLE: Cleaning a C3 Project Build\nDESCRIPTION: Command to clean build artifacts from a C3 project.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nc3c clean\n```\n\n----------------------------------------\n\nTITLE: ZString Length in C3\nDESCRIPTION: Returns the length of a ZString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_50\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ZString.len(str);\n```\n\n----------------------------------------\n\nTITLE: Scalar Expansion with Vectors in C3\nDESCRIPTION: Shows how scalar values are automatically expanded to match vector size in C3, allowing for concise vector-scalar operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\n// Same as speed = speed * { 2, 2 }    \nspeed = speed * 2;\n```\n\n----------------------------------------\n\nTITLE: Random Number Generator Type Definitions\nDESCRIPTION: Defines distinct types for different random number generator implementations with varying bit widths, all implementing the Random interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_89\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Lcg128Random (Random) = uint128;\ndistinct Lcg16Random (Random) = ushort;\ndistinct Lcg32Random (Random) = uint;\ndistinct Lcg64Random (Random) = ulong;\ndistinct Mcg128Random (Random) = uint128;\ndistinct Mcg16Random (Random) = ushort;\ndistinct Mcg32Random (Random) = uint;\ndistinct Mcg64Random (Random) = ulong;\ndistinct Pcg128Random (Random) = uint128;\ndistinct Pcg16Random (Random) = ushort;\ndistinct Pcg32Random (Random) = uint;\ndistinct Pcg64Random (Random) = ulong;\ndistinct Sfc128Random (Random) = uint128[4];\ndistinct Sfc16Random (Random) = ushort[4];\ndistinct Sfc32Random (Random) = uint[4];\ndistinct Sfc64Random (Random) = ulong[4];\ndistinct Sfc8Random (Random) = char[4];\ndistinct SimpleRandom (Random) = ulong;\n```\n\n----------------------------------------\n\nTITLE: Defining Integer Literals in C3 Language\nDESCRIPTION: EBNF production rules for integer literals in C3, including decimal, binary, octal, and hexadecimal representations. These rules define how integer constants are expressed in the language, including the use of underscores for readability.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_5\n\nLANGUAGE: EBNF\nCODE:\n```\nINTEGER         ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT\nDECIMAL_LIT     ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)?\nBINARY_LIT      ::= '0' [bB] '_'* BINARY_DIGITS\nOCTAL_LIT       ::= '0' [oO] '_'* OCTAL_DIGITS\nHEX_LIT         ::= '0' [xX] '_'* HEX_DIGITS\n\nBINARY_DIGIT    ::= [01]\nHEX_DIGIT       ::= [0-9a-fA-F]\n\nDECIMAL_DIGITS  ::= DIGIT ('_'* DIGIT)*\nBINARY_DIGITS   ::= BINARY_DIGIT ('_'* BINARY_DIGIT)*\nOCTAL_DIGITS    ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)*\nHEX_DIGITS      ::= HEX_DIGIT ('_'* HEX_DIGIT)*\n```\n\n----------------------------------------\n\nTITLE: Presenting C3 Release Schedule in Markdown Table\nDESCRIPTION: This Markdown table displays the intended roadmap for major C3 releases, showing the planned release dates and version numbers up to version 1.0.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/roadmap.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Date       |  Release  |\n|------------|-----------|\n| 2025-04-01 |    0.7    |\n| 2026-04-01 |    0.8    |\n| 2027-04-01 |    0.9    |\n| 2028-04-01 |    1.0    |\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks on a C3 Project\nDESCRIPTION: Command to run benchmarks on a C3 project target to measure performance.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nc3c bench [target]\n```\n\n----------------------------------------\n\nTITLE: String to New WString Conversion in C3\nDESCRIPTION: Converts a String to a new WString using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Defining WString Type in C3\nDESCRIPTION: Defines the WString type as a distinct inline Char16 pointer, typically used for UTF-16 encoded strings. This type is useful for applications requiring 16-bit character encoding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ndistinct WString = inline Char16*;\n```\n\n----------------------------------------\n\nTITLE: Character Index in String in C3\nDESCRIPTION: Finds the index of the specified character in the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? String.index_of_char(s, char needle);\n```\n\n----------------------------------------\n\nTITLE: String to Temporary UTF-32 Conversion in C3\nDESCRIPTION: Converts a String to a temporary UTF-32 encoded Char32 array using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_43\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]? String.to_temp_utf32(s) => s.to_utf32(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Runtime Switch Case Evaluation Order Example\nDESCRIPTION: Illustrates the evaluation order in runtime switch cases where only the first matching case is executed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nswitch (true)\n{\n    case x > 0:\n        foo();\n    case x > 2:\n        bar();\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Character Classes in C3 Language\nDESCRIPTION: EBNF production rules for various character classes used in C3, including letters, digits, and their combinations. These rules are fundamental for defining identifiers and other language elements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_3\n\nLANGUAGE: EBNF\nCODE:\n```\nUC_LETTER       ::= [A-Z]\nLC_LETTER       ::= [a-z]\nLETTER          ::= UC_LETTER | LC_LETTER\nDIGIT           ::= [0-9]\nHEX_DIGIT       ::= [0-9a-fA-F]\nBINARY_DIGIT    ::= [01]\nOCTAL_DIGIT     ::= [0-7]\nLC_LETTER_US    ::= LC_LETTER | \"_\"\nUC_LETTER_US    ::= UC_LETTER | \"_\"\nALPHANUM        ::= LETTER | DIGIT\nALPHANUM_US     ::= ALPHANUM | \"_\"\nUC_ALPHANUM_US  ::= UC_LETTER_US | DIGIT\nLC_ALPHANUM_US  ::= LC_LETTER_US | DIGIT\n```\n\n----------------------------------------\n\nTITLE: Building with Docker\nDESCRIPTION: Commands to build C3 compiler using Docker with Ubuntu 18.04/20.04 containers. Includes option for release build.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./build-with-docker.sh 18\n./build-with-docker.sh 20 Release\n```\n\n----------------------------------------\n\nTITLE: For Statement Syntax in C3\nDESCRIPTION: Defines the syntax for the for loop, including initialization, condition, and increment expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_47\n\nLANGUAGE: c3\nCODE:\n```\nfor_stmt           ::= \"for\" label? \"(\" init_expr \";\" cond_expr? \";\" incr_expr \")\" stmt\ninit_expr          ::= decl_expr_list?\nincr_expr          ::= expr_list? \n```\n\n----------------------------------------\n\nTITLE: Relational Expression Syntax in C3\nDESCRIPTION: Defines syntax for relational comparison expressions with standard comparison operators\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nrel_group_expr     ::= add_group_expr | relational_expr\nrelational_expr    ::= rel_group_expr relational_op add_group_expr\nrelational_op      ::= \"<\" | \">\" | \"<=\" | \">=\"\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Statement Types\nDESCRIPTION: This snippet defines the different types of statements in C3 language, including compound statements, control flow, declarations, and expressions, arranged in compiler-matching order.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_7\n\nLANGUAGE: yacc\nCODE:\n```\n/* Order here matches compiler */\nstatement\n\t: compound_statement\n\t| var_stmt\n\t| declaration_stmt\n\t| return_stmt\n\t| if_stmt\n\t| while_stmt\n\t| defer_stmt\n\t| switch_stmt\n\t| do_stmt\n\t| for_stmt\n\t| foreach_stmt\n\t| continue_stmt\n\t| break_stmt\n\t| nextcase_stmt\n\t| asm_block_stmt\n        | ct_echo_stmt\n\t| ct_assert_stmt\n        | ct_if_stmt\n        | ct_switch_stmt\n        | ct_foreach_stmt\n        | ct_for_stmt\n    \t| expr_no_list ';'\n        | assert_stmt\n        | ';'\n\t;\n\ncompound_statement\n\t: '{' opt_stmt_list '}'\n\t;\n\nstatement_list\n\t: statement\n\t| statement_list statement\n\t;\n\nopt_stmt_list\n\t: statement_list\n\t| empty\n\t;\n\nswitch_stmt\n\t: SWITCH optional_label '{' switch_body '}'\n\t| SWITCH optional_label '{' '}'\n\t| SWITCH optional_label paren_cond '{' switch_body '}'\n\t| SWITCH optional_label paren_cond '{' '}'\n\t;\n\nexpression_list\n    \t: decl_or_expr\n    \t| expression_list ',' decl_or_expr\n    \t;\n\noptional_label\n\t: CONST_IDENT ':'\n\t| empty\n\t;\n```\n\n----------------------------------------\n\nTITLE: Defining While Loop Structure in C3\nDESCRIPTION: Specifies the syntax for a while loop in C3, including optional label and condition expression. The loop executes the statement while the condition is true.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_40\n\nLANGUAGE: C3\nCODE:\n```\nwhile_stmt         ::= \"while\" label? \"(\" cond_expr \")\" stmt\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Global Variables\nDESCRIPTION: This snippet defines grammar rules for global variable declarations in C3, including thread-local storage and multiple declarations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_17\n\nLANGUAGE: yacc\nCODE:\n```\nmulti_declaration\n\t: ',' IDENT\n\t| multi_declaration ',' IDENT\n\t;\n\nglobal_storage\n\t: TLOCAL\n\t| empty\n\t;\n\nglobal_declaration\n    : global_storage optional_type IDENT opt_attributes ';'\n    | global_storage optional_type IDENT multi_declaration opt_attributes ';'\n    | global_storage optional_type IDENT opt_attributes '=' expr ';'\n    ;\n```\n\n----------------------------------------\n\nTITLE: Cleaning, Building, and Running a C3 Project\nDESCRIPTION: Command to clean, build, and then run a C3 project target in sequence.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nc3c clean-run [target]\n```\n\n----------------------------------------\n\nTITLE: Defining a Module in C3\nDESCRIPTION: This example shows how to define a module in C3. Module names may contain a-z, 0-9 and `_`, no upper case characters are allowed.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n```\n\n----------------------------------------\n\nTITLE: Defining Type Aliases in C3\nDESCRIPTION: Demonstrates how to create type aliases in C3 using the 'alias' keyword, similar to typedef in C.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nalias Int32 = int;\nalias Vector2 = float[<2>];\n\n/* ... */\n\nInt32 a = 1;\nint b = a;\n```\n\n----------------------------------------\n\nTITLE: Generic OS Thread Primitives (C3)\nDESCRIPTION: Type definitions for thread primitives on non-POSIX and non-Windows systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_114\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeConditionVariable = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeMutex = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeOnceFlag = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeThread = int;\n```\n\n----------------------------------------\n\nTITLE: String End Stripping in C3\nDESCRIPTION: Strips the specified needle from the end of the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.strip_end(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Assignment Expression Grammar\nDESCRIPTION: Defines the grammar for assignment expressions in C3, including type assignments and combined assignments. It specifies the operators used for assignment and the order of operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_17\n\nLANGUAGE: text\nCODE:\n```\n\"assignment_expr    ::= ct_type_assign | unary_expr assignment_op expr\nct_type_assign     ::= ct_type_ident \\\"=\\\" type\nassignment_op      ::= \\\"=\\\" | \\\"+=\\\" | \\\"-=\\\" | \\\"*=\\\" | \\\"/=\\\" | \\\"%=\\\" | \\\"<<=\\\" | \\\">>=\\\" | \\\"&=\\\" | \\\"^=\\\" | \\\"|=\"\n\"\n```\n\n----------------------------------------\n\nTITLE: Installing C3 Compiler on Arch Linux using AUR Package Manager\nDESCRIPTION: Commands to install the c3c compiler on Arch Linux using different AUR package managers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nparu -S c3c-git\n# or yay -S c3c-git\n# or aura -A c3c-git\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Assembly Integration\nDESCRIPTION: This snippet defines grammar rules for embedding assembly code within C3 programs, including various forms of assembly statements and expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_6\n\nLANGUAGE: yacc\nCODE:\n```\nasm_stmts\n\t: asm_stmt\n\t| asm_stmts asm_stmt\n\t;\n\nasm_instr\n\t: INT\n\t| IDENT\n\t| INT '.' IDENT\n\t| IDENT '.' IDENT\n\t;\n\nasm_addr\n\t: asm_expr\n\t| asm_expr additive_op asm_expr\n\t| asm_expr additive_op asm_expr '*' INTEGER\n\t| asm_expr additive_op asm_expr '*' INTEGER additive_op INTEGER\n\t| asm_expr additive_op asm_expr shift_op INTEGER\n\t| asm_expr additive_op asm_expr additive_op INTEGER\n\t;\n\nasm_expr\n\t: CT_IDENT\n\t| CT_CONST_IDENT\n\t| IDENT\n\t| '&' IDENT\n\t| CONST_IDENT\n\t| REAL\n\t| INTEGER\n\t| '(' expr ')'\n\t| '[' asm_addr ']'\n\nasm_exprs\n\t: asm_expr\n\t| asm_exprs ',' asm_expr\n\t;\n\nasm_stmt\n\t: asm_instr asm_exprs ';'\n\t| asm_instr ';'\n\t;\n\nasm_block_stmt\n\t: ASM '(' expr ')'\n\t| ASM '{' asm_stmts '}'\n\t| ASM '{' '}'\n\t;\n```\n\n----------------------------------------\n\nTITLE: Converting String to UTF-32 in C3\nDESCRIPTION: Functions to convert a String to UTF-32 encoded Char32 array, with options for new or temporary allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_30\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]! String.to_utf32(s, Allocator allocator);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]! String.to_new_utf32(s) => s.to_utf32(allocator::heap()) @inline;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[]! String.to_temp_utf32(s) => s.to_utf32(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A macro function that performs linear interpolation (lerp) between two quaternions based on a given amount and returns the interpolated quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_77\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.lerp(Quaternion q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Using $switch for Multiple Compile Time Conditions in C3\nDESCRIPTION: This example demonstrates how to use $switch for handling multiple compile time conditions within a C3 macro.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nmacro @foo($x, #y)\n{\n    $switch ($x)\n        $case 1: \n            #y += $x * $x;\n        $case 2:\n            #y += $x;\n        $case 3:\n            #y *= $x;\n        $default:\n            #y -= $x;\n    $endswitch\n}\n```\n\n----------------------------------------\n\nTITLE: Backslash Escape Characters Reference\nDESCRIPTION: Lists all available backslash escape sequences for characters and string literals with their hex values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_6\n\nLANGUAGE: text\nCODE:\n```\n\\0      0x00 zero value\n\\a      0x07 alert/bell\n\\b      0x08 backspace\n\\e      0x1B escape\n\\f      0x0C form feed\n\\n      0x0A newline\n\\r      0x0D carriage return\n\\t      0x09 horizontal tab\n\\v      0x0B vertical tab\n\\\\      0x5C backslash\n\\'      0x27 single quote '\n\\\"      0x22 double quote \"\n\\x      Escapes a single byte hex value\n\\u      Escapes a two byte unicode hex value\n\\U      Escapes a four byte unicode hex value\n```\n\n----------------------------------------\n\nTITLE: Running a C3 Project Executable\nDESCRIPTION: Execute the compiled C3 project binary directly from the build directory. This runs the program without recompiling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/projects.mdx#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./build/myc3project\n```\n\n----------------------------------------\n\nTITLE: Versionless Dynamic Loading in C3\nDESCRIPTION: This snippet demonstrates versionless dynamic loading using the `@dynamic` attribute and `@available` to optionally load dynamic libraries.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nmodule maybe_dynlib;\nfn void testme() @dynamic;\n```\n\n----------------------------------------\n\nTITLE: Listing C3 Preprocessor Directives\nDESCRIPTION: This snippet lists all preprocessor directives available in C3, including conditional compilation, code generation, and meta-programming constructs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n$alignof    $assert     $case       $default    \n$defined    $echo       $embed      $exec\n$else       $endfor     $endforeach $endif      \n$endswitch  $eval       $evaltype   $error      \n$extnameof  $for        $foreach    $if         \n$include    $nameof     $offsetof   $qnameof    \n$sizeof     $stringify  $switch     $typefrom   \n$typeof     $vacount    $vatype     $vaconst    \n$varef      $vaarg      $vaexpr     $vasplat\n```\n\n----------------------------------------\n\nTITLE: Import Statement Example\nDESCRIPTION: Example showing C3 module import syntax with multiple imports\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/allfeatures.md#2025-04-21_snippet_7\n\nLANGUAGE: C3\nCODE:\n```\nimport std::net, std::io;\n```\n\n----------------------------------------\n\nTITLE: C3 Built-in Attributes\nDESCRIPTION: Built-in attributes for specifying function, variable, and type behavior in C3, prefixed with @\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n@align        @benchmark  @bigendian  @builtin\n@cdecl        @deprecated @dynamic    @export\n@extern       @extname    @inline     @interface\n@littleendian @local      @maydiscard @naked\n@nodiscard    @noinit     @noinline   @noreturn\n@nostrip      @obfuscate  @operator   @overlap\n@packed       @priority   @private    @public\n@pure         @reflect    @section    @stdcall\n@test         @unused     @used       @veccall\n@wasm         @weak       @winmain\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Translation Units\nDESCRIPTION: This snippet defines grammar rules for translation units and top-level statements in C3, including the various declarations and directives that can appear at the module level.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_21\n\nLANGUAGE: yacc\nCODE:\n```\ntranslation_unit\n    : top_level_statements\n    | empty\n    ;\n\ntop_level_statements\n    : top_level\n    | top_level_statements top_level\n    ;\n\nopt_extern\n\t: EXTERN\n\t| empty\n\t;\n\ntop_level\n\t: module\n\t| import_decl\n\t| opt_extern func_definition\n\t| opt_extern const_declaration\n\t| opt_extern global_declaration\n\t| ct_assert_stmt\n\t| ct_echo_stmt\n\t| ct_include_stmt\n\t| tl_ct_if\n\t| tl_ct_switch\n\t| struct_declaration\n\t| fault_declaration\n\t| enum_declaration\n\t| macro_declaration\n\t| define_declaration\n\t| static_declaration\n```\n\n----------------------------------------\n\nTITLE: Cross-Compiling C3 Program for Windows on Linux\nDESCRIPTION: This snippet provides instructions for cross-compiling a C3 program for Windows on a Linux system. It includes the command to specify the Windows target and steps to obtain the necessary MSVC SDK files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\nc3c compile main.c3 --target windows-x64\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 msvc_build_libraries.py\n```\n\n----------------------------------------\n\nTITLE: Accessing Type Alignment in C3\nDESCRIPTION: Demonstrates using the alignof property to get struct alignment requirements in bytes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo @align(8)\n{\n    int a;\n}\n\nuint a = Foo.alignof; // 8\n```\n\n----------------------------------------\n\nTITLE: Module Declaration\nDESCRIPTION: This snippet demonstrates how to declare a module in C3 using the `module` keyword. It shows that a module can span multiple files and that different files can belong to different modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule bar;\n\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Continue Statement Syntax\nDESCRIPTION: Defines the syntax for the `continue` statement, which allows optionally specifying a label to jump to the corresponding `while`, `for`, `do` or `foreach` loop's condition. Any code following a `continue` statement in the same scope is considered unreachable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_22\n\nLANGUAGE: c\nCODE:\n```\n\ncontinue_stmt      ::= \"continue\" label? \";\"\n\n```\n\n----------------------------------------\n\nTITLE: String to Temporary UTF-16 Conversion in C3\nDESCRIPTION: Converts a String to a temporary UTF-16 encoded Char16 array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_40\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]? String.to_temp_utf16(s);\n```\n\n----------------------------------------\n\nTITLE: CPU Information Functions (C3)\nDESCRIPTION: Platform-specific functions to retrieve the number of CPUs on Darwin, Linux, and Windows systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_113\n\nLANGUAGE: c3\nCODE:\n```\nfn uint native_cpu()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint native_cpu()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint native_cpu()\n```\n\n----------------------------------------\n\nTITLE: Initializing a New C3 Project\nDESCRIPTION: Command to create a new C3 project structure in the current directory. Optionally specify a path and template type (exe, static-lib, or dynamic-lib).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nc3c init <project_name> [optional path]\n```\n\n----------------------------------------\n\nTITLE: Operating System Functions and Structures\nDESCRIPTION: Core OS functions for backtraces, environment variables, and process management with platform-specific implementations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_100\n\nLANGUAGE: c3\nCODE:\n```\nfn uint num_cpu()\nfault BacktraceFault\nstruct Backtrace (Printable)\nfn void Backtrace.free(&self)\n```\n\n----------------------------------------\n\nTITLE: Integer Types\nDESCRIPTION: Lists the built-in integer types in C3, specifying their signedness and bit width (8, 16, 32, 64, and 128 bits). Includes aliases for pointer-sized integers and offsets.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_13\n\nLANGUAGE: text\nCODE:\n```\n\"char      unsigned 8-bit\nichar     signed 8-bit\nushort    unsigned 16-bit\nshort     signed 16-bit\nuint      unsigned 32-bit\nint       signed 32-bit\nulong     unsigned 64-bit\nlong      signed 64-bit\nuint128   unsigned 128-bit\nint128    singed 128-bit\n\"\n```\n\nLANGUAGE: text\nCODE:\n```\n\"uptr      unsigned pointer size\niptr      signed pointer size\nusz       unsigned pointer offset / object size\nisz       signed pointer offset  / object size\n\"\n```\n\n----------------------------------------\n\nTITLE: Reverse Substring Index in String in C3\nDESCRIPTION: Finds the last index of the specified substring in the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? String.rindex_of(s, String needle)\n```\n\n----------------------------------------\n\nTITLE: Spherical Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A function that performs spherical linear interpolation (slerp) between two quaternions based on an amount parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_84\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.slerp(q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Building a Specific C3 Project Target\nDESCRIPTION: This command builds a specific target in the C3 project. It uses 'c3c build' followed by the target name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nc3c build myc3project\n```\n\n----------------------------------------\n\nTITLE: Grammar Start Rule for C3 Language Translation Unit\nDESCRIPTION: Defines the starting point for parsing a complete translation unit in the C3 language, establishing the top-level parsing entry point\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_6\n\nLANGUAGE: yacc\nCODE:\n```\n%start translation_unit\n%%\n\npath\n    \t: IDENT SCOPE\n    \t| path IDENT SCOPE\n    \t;\n```\n\n----------------------------------------\n\nTITLE: Adding Scalar to Quaternion in C3\nDESCRIPTION: A macro function that adds a scalar value to each component of a quaternion and returns the resulting quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_74\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.add_each(Quaternion a, Real b)\n```\n\n----------------------------------------\n\nTITLE: String to Unsigned 128-bit Integer Conversion in C3\nDESCRIPTION: Converts a String to an unsigned 128-bit integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_31\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128? String.to_uint128(s, int base = 10) => s.to_integer(uint128, base);\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Comparison between C and C3\nDESCRIPTION: Shows the differences in switch statement behavior between C and C3, including automatic breaks and explicit fallthrough.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/primer.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nswitch (a)\n{\n    case 1:\n    case 2:\n        doOne();\n    case 3:\n        i = 0;\n        nextcase;\n    case 4:\n        doFour();\n    case 5:\n        doFive();\n        nextcase;\n    default:\n        return false;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining POSIX Thread Types in C3\nDESCRIPTION: Declarations of POSIX thread-related types as distinct types in C3. These are conditional declarations that only apply when targeting POSIX systems that are not Linux.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_105\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_attr_t = ulong[8];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_cond_t = ulong[6];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_condattr_t = ulong[8];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_key_t = ulong;\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_mutex_t = ulong[8];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_mutexattr_t = ulong[2];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_once_t = ulong[2];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_rwlock_t = ulong[25];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_rwlockattr_t = ulong[3];\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Pthread_sched_param = ulong;\n```\n\n----------------------------------------\n\nTITLE: Creating Documentation Header in Astro\nDESCRIPTION: Demonstrates how to add a frontmatter header to Astro documentation files for SEO and visibility on the website.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: astro\nCODE:\n```\n```astro\n---\ntitle: the C3 Handbook\ndescription: A guide to the C3 Programming Language\n---\nand after the `---` everything else is just plain old markdown!\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Operations in C3\nDESCRIPTION: A comprehensive matrix library with support for 2x2, 3x3, and 4x4 matrices, providing operations such as addition, multiplication, determinant calculation, inversion, and transformations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_72\n\nLANGUAGE: c3\nCODE:\n```\nstruct Matrix2x2\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Matrix3x3\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Matrix4x4\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.add(&self, Matrix2x2 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.adjoint(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real[<2>] Matrix2x2.apply(&self, Real[<2>] vec)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.component_mul(&self, Real s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix2x2.determinant(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2! Matrix2x2.inverse(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.mul(&self, Matrix2x2 b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.sub(&self, Matrix2x2 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix2x2.trace(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix2x2 Matrix2x2.transpose(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.add(&self, Matrix3x3 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.adjoint(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real[<3>] Matrix3x3.apply(&self, Real[<3>] vec)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.component_mul(&self, Real s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix3x3.determinant(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3! Matrix3x3.inverse(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.mul(&self, Matrix3x3 b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.rotate(&self, Real r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.scale(&self, Real[<2>] v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.sub(&self, Matrix3x3 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix3x3.trace(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.translate(&self, Real[<2>] v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix3x3 Matrix3x3.transpose(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.add(&self, Matrix4x4 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.adjoint(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real[<4>] Matrix4x4.apply(&self, Real[<4>] vec)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.component_mul(&self, Real s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix4x4.determinant(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4! Matrix4x4.inverse(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.mul(Matrix4x4* a, Matrix4x4 b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.rotate_x(&self, Real r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.rotate_y(&self, Real r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.rotate_z(&self, Real r)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.scale(&self, Real[<3>] v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.sub(&self, Matrix4x4 mat2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Real Matrix4x4.trace(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.translate(&self, Real[<3>] v)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 Matrix4x4.transpose(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 ortho(Real left, Real right, Real top, Real bottom, Real near, Real far)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4x4 perspective(Real fov, Real aspect_ratio, Real near, Real far)\n```\n\n----------------------------------------\n\nTITLE: Expression Statement Syntax\nDESCRIPTION: Defines the syntax for an expression statement, which evaluates an expression.  It specifies that discarding the return value of functions or macros annotated with `@nodiscard` or returning optionals is a compile-time error, unless the `@maydiscard` attribute is used.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n\nexpr_stmt          ::= expr \";\"\n\n```\n\n----------------------------------------\n\nTITLE: Return Statement Syntax Definition in C3\nDESCRIPTION: Defines the syntax for return statements in C3, showing the basic grammar rule for returns with optional expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_49\n\nLANGUAGE: bnf\nCODE:\n```\nreturn_stmt        ::= \"return\" expr? \";\"\n```\n\n----------------------------------------\n\nTITLE: Standard Library Memory Management Functions\nDESCRIPTION: Memory allocation and manipulation functions from libc including malloc, free, calloc and memory operations\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void* malloc(usz size) @weak @extern(\"malloc\") @nostrip\nfn void* calloc(usz count, usz size) @weak @extern(\"calloc\") @nostrip\nfn void free(void*) @weak @extern(\"free\")\nfn void* realloc(void* ptr, usz size) @weak @extern(\"realloc\") @nostrip\n```\n\n----------------------------------------\n\nTITLE: Creating Build Directory\nDESCRIPTION: Commands to create and enter the build directory for C3 compiler compilation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c$ mkdir build\nMyMachine:c3c$ cd build/\n```\n\n----------------------------------------\n\nTITLE: Declaration Statement Syntax\nDESCRIPTION: Defines the syntax for a declaration statement in C3, which adds a new runtime or compile-time variable to the current scope, including support for thread-local and static storage. It details the possible initializers and modifiers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_35\n\nLANGUAGE: c\nCODE:\n```\n\"declaration_stmt   ::= const_declaration | local_decl_storage? optional_type decls_after_type \\\";\\\"\\nlocal_decl_storage ::= \\\"tlocal\\\" | \\\"static\\\"\\ndecls_after_type   ::= local_decl_after_type (\\\",\\\" local_decl_after_type)*\\ndecl_after_type    ::= CT_IDENT (\\\"=\\\" constant_expr)? | IDENTIFIER opt_attributes (\\\"=\\\" expr)?\"\n```\n\n----------------------------------------\n\nTITLE: Var Statement Syntax Definition in C3\nDESCRIPTION: Defines the syntax for variable declarations in C3, showing grammar rules for both runtime and compile-time variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_51\n\nLANGUAGE: bnf\nCODE:\n```\nvar_stmt           ::= \"var\" IDENTIFIER | CT_IDENT | CT_TYPE_IDENT (\"=\" expr)? \";\"\n```\n\n----------------------------------------\n\nTITLE: Restrictions on Optional Types in C3\nDESCRIPTION: This snippet highlights restrictions on where optional types can be used in C3.  Only variables, expressions, and function returns may be Optionals. Function and macro parameters cannot be optionals.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn Foo*? getFoo() { /* ... */ } // ✅ Ok!\nint? x = 0; // ✅ Ok!\nfn void processFoo(Foo*! f) { /* ... */ } // ❌ fn paramater\n```\n```\n\n----------------------------------------\n\nTITLE: Creating an Empty Custom Attribute in C3\nDESCRIPTION: Illustrates the definition of an empty user-defined attribute @MyAttributeEmpty. This can be used for organizational or documentation purposes without adding any specific behavior to the decorated element.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/attributes.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nattrdef @MyAttributeEmpty = {};\n```\n\n----------------------------------------\n\nTITLE: Defining Whitespace in C3 Language\nDESCRIPTION: EBNF production rule for whitespace in C3. It includes horizontal tab, form feed, vertical tab, carriage return, space, and line terminator characters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_2\n\nLANGUAGE: EBNF\nCODE:\n```\nWHITESPACE      ::= [ \\t\\f\\v\\r\\n]\n```\n\n----------------------------------------\n\nTITLE: Running a C3 Project Binary\nDESCRIPTION: This command runs the compiled C3 project binary. It executes the binary file located in the build directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./build/myc3project\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Enums and Faults\nDESCRIPTION: This snippet defines grammar rules for enum and fault declarations in C3, including their specifications and member lists.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_14\n\nLANGUAGE: yacc\nCODE:\n```\nenum_spec\n\t: ':' type enum_param_list\n\t| empty\n\t;\n\nenum_declaration\n\t: ENUM TYPE_IDENT enum_spec opt_attributes '{' enum_list '}'\n\t;\n\nfaults\n    : CONST_IDENT\n    | faults ',' CONST_IDENT\n    ;\n\nfault_declaration\n    \t: FAULT TYPE_IDENT opt_attributes '{' faults '}'\n    \t| FAULT TYPE_IDENT opt_attributes '{' faults ',' '}'\n    \t;\n```\n\n----------------------------------------\n\nTITLE: Path instance methods in C3\nDESCRIPTION: Methods for manipulating Path objects in C3, including operations to convert paths to absolute form, append filenames, extract components, compare paths, and manage memory allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_63\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? Path.absolute(self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? Path.append(self, String filename, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString Path.as_zstr(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.basename(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.dirname(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Path.equals(self, Path p2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String? Path.extension(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Path.free(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Path.has_suffix(self, String str)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Path.is_absolute(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? Path.parent(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.root_directory(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.str_view(self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Path? Path.tappend(self, String filename)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? Path.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Path.volume_name(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool? Path.walk(self, PathWalker w, void* data)\n```\n\n----------------------------------------\n\nTITLE: String to Signed Character Conversion in C3\nDESCRIPTION: Converts a String to a signed character with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_30\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar? String.to_ichar(s, int base = 10) => s.to_integer(ichar, base);\n```\n\n----------------------------------------\n\nTITLE: Enum Name Lookup in C3\nDESCRIPTION: Shows how to look up enum values by their string names using enum_by_name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nenum Foo { ABC, CDE, EFG }\n\nfn void? test()\n{\n    Foo f = enum_by_name(Foo, \"CDE\")!;\n    // same as Foo f = Foo.CDE;\n}\n```\n\n----------------------------------------\n\nTITLE: Range type definitions and methods in C3\nDESCRIPTION: Defines Range and ExclusiveRange structures with methods for creating and manipulating numeric ranges. Range includes both endpoints while ExclusiveRange excludes the end value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nstruct ExclusiveRange (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Range (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool ExclusiveRange.contains(&self, Type value) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type ExclusiveRange.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ExclusiveRange.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! ExclusiveRange.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ExclusiveRange.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String ExclusiveRange.to_tstring(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Range.contains(&self, Type value) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type Range.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Range.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! Range.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Range.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String Range.to_tstring(&self)\n```\n\n----------------------------------------\n\nTITLE: Floating Point Literal Syntax\nDESCRIPTION: EBNF rules defining the syntax for floating point literals in both decimal and hexadecimal formats.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_4\n\nLANGUAGE: ebnf\nCODE:\n```\nFLOAT_LIT       ::= DEC_FLOAT_LIT | HEX_FLOAT_LIT\nDEC_FLOAT_LIT   ::= DECIMAL_DIGITS '.' DECIMAL_DIGITS? DEC_EXPONENT?\n                    | DECIMAL_DIGITS DEC_EXPONENT\n                    | '.' DECIMAL_DIGITS DEC_EXPONENT?\nDEC_EXPONENT    ::= [eE] [+-]? DECIMAL_DIGITS\nHEX_FLOAT_LIT   ::= '0' [xX] HEX_MANTISSA HEX_EXPONENT\nHEX_MANTISSA    ::= HEX_DIGITS '.' HEX_DIGITS?\n                    | HEX_DIGITS\n                    | '.' HEX_DIGITS\nHEX_EXPONENT    ::= [pP] [+-] DECIMAL_DIGITS\n```\n\n----------------------------------------\n\nTITLE: Including and Using Generic Modules in C3\nDESCRIPTION: Shows how to import a generic module, define type aliases, and use generic functions with specific type parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nimport foo_test;\n\ndef FooFloat = Foo(<float, double>);\ndef test_float = foo_test::test(<float, double>);\n\n...\n\nFooFloat f;\nFoo(<int, double>) g;\n\n...\n\ntest_float(1.0, &f);\nfoo_test::test(<int, double>)(1.0, &g);\n```\n\n----------------------------------------\n\nTITLE: DString Comparison and Information Methods in C3\nDESCRIPTION: Functions for comparing DStrings and retrieving information about them.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_39\n\nLANGUAGE: c3\nCODE:\n```\nfn bool DString.equals(self, DString other_string)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz DString.len(&self) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool DString.less(self, DString other_string)\n```\n\n----------------------------------------\n\nTITLE: User Defined Attributes Syntax in C3\nDESCRIPTION: Defines the syntax for declaring user-defined attributes in C3, showing grammar rules for attribute declarations with optional parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_52\n\nLANGUAGE: bnf\nCODE:\n```\nattribute_decl     ::= \"def\" AT_TYPE_IDENT \"(\" parameters \")\"? attribute* \"=\" \"{\" attribute* \"}\" \";\"\n```\n\n----------------------------------------\n\nTITLE: Implementing If Statement in C3\nDESCRIPTION: This snippet demonstrates the usage of if-else statements to execute code blocks based on condition evaluation. The function takes an integer parameter and executes different blocks based on whether the value is greater than zero.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void if_example(int a) \n{\n    if (a > 0) \n    {\n        // ..\n    } \n    else \n    {\n        // ..\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation with Defer Catch in C3\nDESCRIPTION: Example of using defer catch for memory cleanup when handling errors in allocation operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/defer.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::core::mem;\n\nfn char[]? test()\n{\n    char[] data = mem::new_array(char, 12)!;\n\n    defer (catch err)\n    {\n        io::printfn(\"Excuse found: %s\", err)\n        (void)free(data);\n    }\n\n    return io::FILE_NOT_FOUND?;\n}\n```\n\n----------------------------------------\n\nTITLE: Trimming String in C3\nDESCRIPTION: Function to remove specified characters from both ends of a given string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.trim(string, String to_trim);\n```\n\n----------------------------------------\n\nTITLE: Relational and Equality Operator Precedence Example\nDESCRIPTION: Demonstrates the different precedence rules for relational and equality operators in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/precedence.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\na > b == c < d\n```\n\nLANGUAGE: c3\nCODE:\n```\n(a > b) == (c < d) // C  (< > binds tighter than ==)\n((a > b) == c) < d // C3 Error, requires parenthesis!\n```\n\n----------------------------------------\n\nTITLE: Foreach and Foreach_r Statement Syntax in C3\nDESCRIPTION: Defines the syntax for foreach and foreach_r statements, which iterate over sequences in forward or reverse order.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_48\n\nLANGUAGE: c3\nCODE:\n```\nforeach_stmt       ::= \"foreach\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_r_stmt     ::= \"foreach_r\" label? \"(\" foreach_vars \":\" expr \")\" stmt\nforeach_vars       ::= (foreach_index \",\")? foreach_var\nforeach_var        ::= type? \"&\"? IDENTIFIER\n```\n\n----------------------------------------\n\nTITLE: Enum Name Qualification in C3\nDESCRIPTION: This snippet illustrates a case where the enum name qualifier is required. If an enum value shares a name with a global variable in the same scope, you must explicitly qualify the enum value with `EnumName.Value` to avoid ambiguity.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nmodule test;\n\n// Global variable\n// ❌ Don't do this!\nconst State RUNNING = State.TERMINATED;\n\ntest(RUNNING);       // Ambiguous\ntest(test::RUNNING); // Uses global variable.\ntest(State.RUNNING); // Uses enum constant.\n```\n```\n\n----------------------------------------\n\nTITLE: Temporary String Splitting in C3\nDESCRIPTION: Splits the string by the specified needle, creating a temporary array using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tsplit(s, String needle, usz max = 0) => s.split(needle, max, allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Attributes\nDESCRIPTION: This snippet defines grammar rules for attributes in C3, which provide metadata annotations for various language constructs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_11\n\nLANGUAGE: yacc\nCODE:\n```\nattribute_name\n\t: AT_IDENT\n\t| AT_TYPE_IDENT\n\t| path AT_TYPE_IDENT\n\t;\n\nattribute_operator_expr\n\t: '&' '[' ']'\n\t| '[' ']' '='\n\t| '[' ']'\n\t;\n\nattr_param\n\t: attribute_operator_expr\n\t| constant_expr\n\t;\n\nattribute_param_list\n\t: attr_param\n\t| attribute_param_list ',' attr_param\n\t;\n\nattribute\n    : attribute_name\n    | attribute_name '(' attribute_param_list ')'\n    ;\n\nattribute_list\n\t: attribute\n\t| attribute_list attribute\n\t;\n\nopt_attributes\n   \t: attribute_list\n    \t| empty\n    \t;\n```\n\n----------------------------------------\n\nTITLE: Unsigned Short Operations in C3\nDESCRIPTION: Macros for performing various operations on unsigned short values, including overflow checking, saturation arithmetic, and array operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_68\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool ushort.is_even(ushort x)\nmacro bool ushort.is_odd(ushort x)\nmacro ushort? ushort.overflow_add(ushort x, ushort y)\nmacro ushort? ushort.overflow_mul(ushort x, ushort y)\nmacro ushort? ushort.overflow_sub(ushort x, ushort y)\nmacro ushort ushort.sat_add(ushort x, ushort y)\nmacro ushort ushort.sat_mul(ushort x, ushort y)\nmacro ushort ushort.sat_shl(ushort x, ushort y)\nmacro ushort ushort.sat_sub(ushort x, ushort y)\nmacro ushort ushort[<*>].and(ushort[<*>] x)\nmacro bool[<*>] ushort[<*>].comp_eq(ushort[<*>] x, ushort[<*>] y)\nmacro bool[<*>] ushort[<*>].comp_ge(ushort[<*>] x, ushort[<*>] y)\nmacro bool[<*>] ushort[<*>].comp_gt(ushort[<*>] x, ushort[<*>] y)\nmacro bool[<*>] ushort[<*>].comp_le(ushort[<*>] x, ushort[<*>] y)\nmacro bool[<*>] ushort[<*>].comp_lt(ushort[<*>] x, ushort[<*>] y)\nmacro bool[<*>] ushort[<*>].comp_ne(ushort[<*>] x, ushort[<*>] y)\nmacro ushort ushort[<*>].max(ushort[<*>] x)\nmacro ushort ushort[<*>].min(ushort[<*>] x)\nmacro ushort ushort[<*>].or(ushort[<*>] x)\nmacro ushort ushort[<*>].product(ushort[<*>] x)\nmacro ushort ushort[<*>].sum(ushort[<*>] x)\nmacro ushort ushort[<*>].xor(ushort[<*>] x)\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Compile-Time Control Flow in Top-Level Statements\nDESCRIPTION: This snippet defines grammar rules for compile-time conditional statements and switch cases at the top level of C3 modules.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_18\n\nLANGUAGE: yacc\nCODE:\n```\nopt_tl_stmts\n\t: top_level_statements\n\t| empty\n\t;\n\ntl_ct_case\n\t: CT_CASE constant_expr ':' opt_tl_stmts\n\t| CT_CASE type ':' opt_tl_stmts\n    \t| CT_DEFAULT ':' opt_tl_stmts\n    \t;\n\ntl_ct_switch_body\n    \t: tl_ct_case\n    \t| tl_ct_switch_body tl_ct_case\n    \t;\n\ndefine_attribute\n\t: AT_TYPE_IDENT '(' parameters ')' opt_attributes '=' '{' opt_attributes '}'\n\t| AT_TYPE_IDENT opt_attributes '=' '{' opt_attributes '}'\n\t;\n\nopt_generic_parameters\n\t: '{' generic_parameters '}'\n\t| empty\n\t;\n```\n\n----------------------------------------\n\nTITLE: Converting String to Temporary WString in C3\nDESCRIPTION: Function to convert a String to a temporary WString using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: String to Unsigned Integer Conversion in C3\nDESCRIPTION: Converts a String to an unsigned integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_33\n\nLANGUAGE: c3\nCODE:\n```\nfn uint? String.to_uint(s, int base = 10) => s.to_integer(uint, base);\n```\n\n----------------------------------------\n\nTITLE: Installing C3 Compiler on Arch Linux using AUR Package Manager\nDESCRIPTION: Commands for installing the C3 compiler on Arch Linux using different AUR package managers like paru, yay, or aura.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nparu -S c3c-git\n# or yay -S c3c-git\n# or aura -A c3c-git\n```\n\n----------------------------------------\n\nTITLE: DString Append Macro in C3\nDESCRIPTION: Macro for appending a value to a DString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_33\n\nLANGUAGE: c3\nCODE:\n```\nmacro void DString.append(&self, value)\n```\n\n----------------------------------------\n\nTITLE: Bitcast Operation Example in C3\nDESCRIPTION: Demonstrates bitcast operation between types of the same memory size.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nfloat x = 1.0;\nint y = bitcast(x, int); // y = 0x3f800000\n```\n\n----------------------------------------\n\nTITLE: Demonstrating @adhoc Attribute Usage in C3\nDESCRIPTION: This snippet shows how the @adhoc attribute allows a parameterized type to be declared without a prior definition, enabling more flexible generic programming.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/attributes.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nmodule my_lib(<Type>);\n\nstruct MyType @adhoc\n{\n\t  Type value;\n}\n\nmodule my_code;\n\nfn void main()\n{\n    MyType(<int>) x;\n}\n```\n\n----------------------------------------\n\nTITLE: Rethrow Expression Syntax in C3\nDESCRIPTION: Defines the syntax for implicitly returning an optional value\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nrethrow_expr       ::= expr \"!\"\n```\n\n----------------------------------------\n\nTITLE: Defining Functions and Macros in C3\nDESCRIPTION: This snippet demonstrates the declaration of a function and a macro in C3. Functions and macros must start with a-z (after an optional initial `_`).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void theMostAmazingFunction() \n{ \n    return;\n}\n\nmacro justDoIt(x) \n{\n    justDo(x);\n}\n```\n\n----------------------------------------\n\nTITLE: Checking Optional Result Presence with @ok Macro in C3\nDESCRIPTION: Demonstrates the use of the @ok macro to check if an Optional has a result without unwrapping it.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nfn void main(String[] args)\n{\n    int! optional_value = 7;\n    \n    bool result_found = @ok(optional_value);\n    assert(result_found == !@catch(optional_value));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining And and Or Expressions in C3 Language\nDESCRIPTION: This snippet defines syntax and evaluation rules for 'and' and 'or' expressions, explaining how they determine the truthiness of composite conditions based on their operands.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_23\n\nLANGUAGE: C3\nCODE:\n```\nand_group_expr     ::= rel_group_expr | and_expr\nand_expr           ::= and_group_expr \"&&\" rel_group_expr\nor_group_expr      ::= and_group_expr | or_expr\nor_expr            ::= or_group_expr \"||\" and_group_expr\n```\n\n----------------------------------------\n\nTITLE: Module Path EBNF Definition\nDESCRIPTION: EBNF syntax definition for module paths in C3, showing the hierarchical structure using '::' as separator between path segments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_53\n\nLANGUAGE: ebnf\nCODE:\n```\npath               ::= PATH_SEGMENT (\"::\" PATH_SEGMENT)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Union Types in C3\nDESCRIPTION: This code demonstrates how to define and use union types in C3. Unions allow storing one of several possible values, and their size is determined by the largest member.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nunion Integral  \n{\n    char as_byte;\n    short as_short;\n    int as_int;\n    long as_long;\n}\n```\n```\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nfn void test()\n{\n    Integral i;\n    i.as_byte = 40; // Setting the active member to as_byte\n\n    i.as_int = 500; // Changing the active member to as_int\n\n    // Undefined behaviour: as_byte is not the active member, \n    // so this will probably print garbage.\n    io::printfn(\"%d\\n\", i.as_byte);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Cloning the C3 Compiler Repository with Git\nDESCRIPTION: Command to clone the C3 compiler source code from GitHub using git. This is the first step after installing the prerequisites.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/c3lang/c3c.git\n```\n\n----------------------------------------\n\nTITLE: DString Copy Methods in C3\nDESCRIPTION: Functions for creating copies of DStrings in various formats.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_37\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.copy(self, Allocator allocator = null)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String DString.copy_str(self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Char32[] DString.copy_utf32(&self, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString DString.copy_zstr(self, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Using Implicit Slice Bounds in C3\nDESCRIPTION: Demonstrates the use of omitted start and end indices when creating slices, allowing for more concise slice notation when working with array bounds.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\na[..6]; // a[0..6]\na[1..]; // a[1..99]\na[..];  // a[0..99];\n```\n\n----------------------------------------\n\nTITLE: macOS Objective-C Runtime Bindings (C3)\nDESCRIPTION: Type definitions and macros for interacting with the Objective-C runtime on macOS, including class and selector operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_106\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Class = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Ivar = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Method = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Selector = void*;\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault ObjcFailure\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool Class.equals(Class a, Class b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Method Class.method(Class cls, Selector name)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ZString Class.name(Class cls)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool Class.responds_to(Class cls, Selector sel)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Class Class.superclass(Class cls)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool Selector.equals(Selector a, Selector b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Class? class_by_name(ZString c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Class[] class_get_list(Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Enum and Fault Definitions in C3\nDESCRIPTION: Shows how enum and fault definitions follow the same naming conventions as global constants, starting with uppercase letters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nenum Baz\n{\n    VALUE_1,\n    VALUE_2\n}\n\nfaultdef OOPS, LOTS_OF_OOPS;\n```\n\n----------------------------------------\n\nTITLE: Defining Statement Syntax in C3 Language\nDESCRIPTION: This snippet presents the grammar for various types of statements in C3, categorizing them into compound and non-compound statements and providing a concise syntax outline for each category.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_27\n\nLANGUAGE: C3\nCODE:\n```\nstmt               ::= compound_stmt | non_compound_stmt\nnon_compound_stmt  ::= assert_stmt | if_stmt | while_stmt | do_stmt | foreach_stmt | foreach_r_stmt \n                       | for_stmt | return_stmt | break_stmt | continue_stmt | var_stmt \n                       | declaration_stmt | defer_stmt | nextcase_stmt | asm_block_stmt\n                       | ct_echo_stmt | ct_error_stmt | ct_assert_stmt | ct_if_stmt | ct_switch_stmt \n                       | ct_for_stmt | ct_foreach_stmt | expr_stmt\n```\n\n----------------------------------------\n\nTITLE: Converting String to ZString in C3\nDESCRIPTION: Functions to convert a String to ZString, with options for heap or temporary allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_34\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString String.zstr_tcopy(s) => s.zstr_copy(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: String to Float Conversion in C3\nDESCRIPTION: Converts a String to a single-precision floating-point number.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_37\n\nLANGUAGE: c3\nCODE:\n```\nfn float? String.to_float(s) => s.to_real(float);\n```\n\n----------------------------------------\n\nTITLE: Getting Size of a Type in C3\nDESCRIPTION: Demonstrates how to get the size of a type using the 'sizeof' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nusz x = Foo.sizeof;\n```\n\n----------------------------------------\n\nTITLE: String to New WString Conversion in C3\nDESCRIPTION: Converts a String to a new WString using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_45\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Configuring C3 Library Manifest JSON Structure\nDESCRIPTION: Example manifest.json configuration for a C3 library showing multi-platform target specifications, dependencies, link flags, and library references. Demonstrates configuration for both macOS and Windows targets with platform-specific linking requirements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/library-packaging.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"provides\" : \"my_lib\",\n  \"execs\" : [],\n  \"targets\" : {\n    \"macos-x64\" : {\n      \"linkflags\" : [],\n      \"dependencies\" : [],\n      \"linked-libs\" : [\"my_lib_static\", \"Cocoa.framework\", \"c\"]\n    },\n    \"windows-x64\" : {\n      \"linkflags\" : [\"/stack:65536\"],\n      \"dependencies\" : [\"ms_my_extra\"],\n      \"linked-libs\" : [\"my_lib_static\", \"kernel32\"],\n      \"execs\" : [],\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Compound Literals Syntax in C3\nDESCRIPTION: Defines the syntax for creating compound literals with complex initialization options\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\ncompound_literal   ::= (type) initializer_list\ninitializer_list   ::= '{' (initializer_param (',' initializer_param)* ','?)? '}'\ninitializer_param  ::= expression | designator '=' expression\ndesignator         ::= array_designator | range_designator | field_designator\narray_designator   ::= '[' expression ']'\nrange_designator   ::= '[' range_expression ']'\nfield_designator   ::= IDENTIFIER\nrange_expression   ::= (range_index)? '..' (range_index)?\nrange_index        ::= expression | '^' expression\n```\n\n----------------------------------------\n\nTITLE: Scalar Operations with Vectors in C3\nDESCRIPTION: Shows how scalar values automatically widen to vectors when used in vector operations and vector initialization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/vectors.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint[<2>] d = { 21, 14 };\nint[<2>] e = d / 7;      // e = { 3, 2 }\nint[<2>] f = 4;          // f = { 4, 4 }\n```\n\n----------------------------------------\n\nTITLE: Defining Triple and Tuple Structures in C3\nDESCRIPTION: Defines Triple and Tuple structures for holding multiple values of different types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nstruct Triple\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Tuple\n```\n\n----------------------------------------\n\nTITLE: String to Unsigned Character Conversion in C3\nDESCRIPTION: Converts a String to an unsigned character with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_35\n\nLANGUAGE: c3\nCODE:\n```\nfn char? String.to_uchar(s, int base = 10) => s.to_integer(char, base);\n```\n\n----------------------------------------\n\nTITLE: Continue Statement Syntax\nDESCRIPTION: Defines the syntax for a continue statement in C3, which jumps to the cond expression of a `while`, `for`, `do` or `foreach` loop, optionally with a label to specify the target loop in an outer scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_34\n\nLANGUAGE: c\nCODE:\n```\n\"continue_stmt      ::= \\\"continue\\\" label? \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: EnumSet Implementation in C3\nDESCRIPTION: Set implementation for enum values with standard set operations (union, intersection, difference) and element manipulation methods. Implements the Printable interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\ntypedef EnumSet (Printable) = EnumSetType;\n\nfn void EnumSet.add(&self, Enum v)\nfn void EnumSet.add_all(&self, EnumSet s)\nfn EnumSet EnumSet.and_of(&self, EnumSet s)\nfn void EnumSet.clear(&self)\nfn EnumSet EnumSet.diff_of(&self, EnumSet s)\nfn bool EnumSet.has(&self, Enum v)\nfn EnumSet EnumSet.or_of(&self, EnumSet s)\nfn bool EnumSet.remove(&self, Enum v)\nfn void EnumSet.remove_all(&self, EnumSet s)\nfn void EnumSet.retain_all(&self, EnumSet s)\nfn usz? EnumSet.to_format(&set, Formatter* formatter) @dynamic\nfn String EnumSet.to_new_string(&set, Allocator allocator = allocator::heap()) @dynamic\nfn String EnumSet.to_tstring(&set) @dynamic\nfn EnumSet EnumSet.xor_of(&self, EnumSet s)\n```\n\n----------------------------------------\n\nTITLE: Vector 4D Operations and Matrix Functions in C3\nDESCRIPTION: Methods for 4D vector operations and matrix utility functions for both double and float precision. Includes magnitude clamping, distance calculation, movement, and matrix-related operations like look-at matrix construction.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_91\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4.clamp_mag(self, double min, double max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4.distance_sq(self, Vec4 v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec4 Vec4.towards(self, Vec4 target, double max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4f.clamp_mag(self, float min, float max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4f.distance_sq(self, Vec4f v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec4f.length_sq(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Vec4f Vec4f.towards(self, Vec4f target, float max_distance)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4 matrix4_look_at(Vec3 eye, Vec3 target, Vec3 up)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Matrix4f matrix4f_look_at(Vec3f eye, Vec3f target, Vec3f up)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ortho_normalize(Vec3f* v1, Vec3f* v2)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void ortho_normalized(Vec3* v1, Vec3* v2)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Division by Zero UB Detection in C3\nDESCRIPTION: Example showing how C3 handles potential division by zero undefined behavior. The compiler may optimize the code based on UB assumptions in release builds.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/undefined-behaviour.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nuint x = foo();\nuint z = 255 / x;\nreturn x != 0;\n```\n\n----------------------------------------\n\nTITLE: POSIX Platform Support\nDESCRIPTION: POSIX-compliant implementations of system operations and thread management.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_104\n\nLANGUAGE: c3\nCODE:\n```\ndistinct DIRPtr = void*;\ndistinct Pthread_t = void*;\nstruct Posix_dirent\n```\n\n----------------------------------------\n\nTITLE: String to Temporary WString Conversion in C3\nDESCRIPTION: Converts a String to a temporary WString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nfn WString? String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Accessing Struct Members in C3\nDESCRIPTION: Demonstrates how to access struct members using the 'membersof' property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nstruct Baz\n{\n    int x;\n    Foo* z;\n}\nString x = Baz.membersof[1].nameof; // \"z\"\n```\n\n----------------------------------------\n\nTITLE: Converting String to WString in C3\nDESCRIPTION: Function to convert a String to a WString using a specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_wstring(s, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: String to Short Integer Conversion in C3\nDESCRIPTION: Converts a String to a short integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_29\n\nLANGUAGE: c3\nCODE:\n```\nfn short? String.to_short(s, int base = 10) => s.to_integer(short, base);\n```\n\n----------------------------------------\n\nTITLE: Converting Quaternion to Matrix4f in C3\nDESCRIPTION: A macro that converts a quaternion pointer to a 4x4 floating-point matrix representation and returns the resulting Matrix4f.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_88\n\nLANGUAGE: c3\nCODE:\n```\nmacro Matrix4f Quaternion.to_matrixf(Quaternion* q)\n```\n\n----------------------------------------\n\nTITLE: Adding Two Quaternions in C3\nDESCRIPTION: A macro that adds two quaternions together and returns the result as a new quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_75\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.add(Quaternion a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: Configuring C3 Project Settings in JSON\nDESCRIPTION: This JSON5 snippet demonstrates the structure and available options for configuring a C3 project. It includes settings for language version, warnings, dependencies, authors, version, sources, targets, and various compilation options.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/project-config.md#2025-04-21_snippet_0\n\nLANGUAGE: json5\nCODE:\n```\n{\n  // Language version of C3.\n  \"langrev\": \"1\",\n  // Warnings used for all targets.\n  \"warnings\": [ \"no-unused\" ],\n  // Directories where C3 library files may be found.\n  \"dependency-search-paths\": [ \"lib\" ],\n  // Libraries to use for all targets.\n  \"dependencies\": [ ],\n  // Authors, optionally with email.\n  \"authors\": [ \"John Doe <john.doe@example.com>\" ],\n  // Version using semantic versioning.\n  \"version\": \"0.1.0\",\n  // Sources compiled for all targets.\n  \"sources\": [ \"src/**\" ],\n  // C sources if the project also compiles C sources\n  // relative to the project file.\n  // \"c-sources\": [ \"csource/**\" ],\n  // Include directories for C sources relative to the project file.\n  // \"c-include-dirs: [ \"csource/include\" ],\n  // Output location, relative to project file.\n  \"output\": \"../build\",\n  // Architecture and OS target.\n  // You can use 'c3c --list-targets' to list all valid targets,\n  // \"target\": \"windows-x64\",\n  // Current Target options:\n  //    android-aarch64 \n  //    elf-aarch64 elf-riscv32 elf-riscv64 elf-x86 elf-x64 elf-xtensa\n  //    mcu-x86 mingw-x64 netbsd-x86 netbsd-x64 openbsd-x86 openbsd-x64\n  //    freebsd-x86 freebsd-x64 ios-aarch64 \n  //    linux-aarch64 linux-riscv32 linux-riscv64 linux-x86 linux-x64 \n  //    macos-aarch64 macos-x64 \n  //    wasm32 wasm64 \n  //    windows-aarch64 windows-x64 \n  \"targets\": {\n    \"linux-x64\": {\n      // Executable or library.\n      \"type\": \"executable\",\n      // Additional libraries, sources\n      // and overrides of global settings here.\n    },\n  },\n  // Global settings.\n  // C compiler if the project also compiles C sources\n  // defaults to 'cc'.\n  \"cc\": \"cc\",\n  // CPU name, used for optimizations in the LLVM backend.\n  \"cpu\": \"generic\",\n  // Debug information, may be \"none\", \"full\" and \"line-tables\".\n  \"debug-info\": \"full\",\n  // FP math behaviour: \"strict\", \"relaxed\", \"fast\".\n  \"fp-math\": \"strict\",\n  // Link libc other default libraries.\n  \"link-libc\": true,\n  // Memory environment: \"normal\", \"small\", \"tiny\", \"none\".\n  \"memory-env\": \"normal\",\n  // Optimization: \"O0\", \"O1\", \"O2\", \"O3\", \"O4\", \"O5\", \"Os\", \"Oz\".\n  \"opt\": \"O0\",\n  // Code optimization level: \"none\", \"less\", \"more\", \"max\".\n  \"optlevel\": \"none\",\n  // Code size optimization: \"none\", \"small\", \"tiny\".\n  \"optsize\": \"none\",\n  // Relocation model: \"none\", \"pic\", \"PIC\", \"pie\", \"PIE\".\n  \"reloc\": \"none\",\n  // Trap on signed and unsigned integer wrapping for testing.\n  \"trap-on-wrap\": false,\n  // Turn safety (contracts, runtime bounds checking, null pointer checks etc).\n  \"safe\": true,\n  // Compile all modules together, enables more inlining.\n  \"single-module\": true,\n  // Use / don't use soft float, value is otherwise target default.\n  \"soft-float\": false,\n  // Strip unused code and globals from the output.\n  \"strip-unused\": true,\n  // The size of the symtab, which limits the amount\n  // of symbols that can be used. Should usually not be changed.\n  \"symtab\": 1048576,\n  // Use the system linker.\n  \"linker\": \"cc\",\n  // Include the standard library.\n  \"use-stdlib\": true,\n  // Set general level of x64 cpu: \"baseline\", \"ssse3\", \"sse4\", \"avx1\", \"avx2-v1\", \"avx2-v2\", \"avx512\", \"native\".\n  \"x86cpu\": \"native\",\n  // Set max type of vector use: \"none\", \"mmx\", \"sse\", \"avx\", \"avx512\", \"native\".\n  \"x86vec\": \"sse\",\n}\n```\n\n----------------------------------------\n\nTITLE: Module Section EBNF Definition\nDESCRIPTION: EBNF syntax definition for module sections in C3, including generic parameters and attributes. Shows the structure of module declarations with optional generic parameters and attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_54\n\nLANGUAGE: ebnf\nCODE:\n```\nmodule_section     ::= \"module\" path opt_generic_params? attributes? \";\"\ngeneric_param      ::= TYPE_IDENT | CONST_IDENT\nopt_generic_params ::= \"(<\" generic_param (\",\" generic_param)* \">)\"\n```\n\n----------------------------------------\n\nTITLE: Statement Syntax in C3\nDESCRIPTION: Defines the overall syntax for statements in the C3 language, including compound and non-compound statements\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nstmt               ::= compound_stmt | non_compound_stmt\nnon_compound_stmt  ::= assert_stmt | if_stmt | while_stmt | do_stmt | foreach_stmt | foreach_r_stmt\n                       | for_stmt | return_stmt | break_stmt | continue_stmt | var_stmt\n                       | declaration_stmt | defer_stmt | nextcase_stmt | asm_block_stmt\n                       | ct_echo_stmt | ct_error_stmt | ct_assert_stmt | ct_if_stmt | ct_switch_stmt\n                       | ct_for_stmt | ct_foreach_stmt | expr_stmt\n```\n\n----------------------------------------\n\nTITLE: POSIX Thread Type Definitions\nDESCRIPTION: Platform-specific thread-related type definitions for POSIX systems excluding Linux\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_116\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_attr_t = ulong[8];\ntypedef Pthread_cond_t = ulong[6];\ntypedef Pthread_condattr_t = ulong[8];\ntypedef Pthread_key_t = ulong;\ntypedef Pthread_mutex_t = ulong[8];\ntypedef Pthread_mutexattr_t = ulong[2];\ntypedef Pthread_once_t = ulong[2];\ntypedef Pthread_rwlock_t = ulong[25];\ntypedef Pthread_rwlockattr_t = ulong[3];\ntypedef Pthread_sched_param = ulong;\n```\n\n----------------------------------------\n\nTITLE: Bitstructs with Char Array Backing Types in C3\nDESCRIPTION: This code snippet shows how bitstructs can be backed by character arrays. It defines two bitstructs, `Test1` and `Test2`, both backed by `char[4]`, but `Test2` is specified as `@bigendian`. The example demonstrates how assigning values to the bitstruct fields affects the byte order in memory, and how the endianness impacts the output when iterating over the character array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Overview/types.md#2025-04-21_snippet_31\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nbitstruct Test1 : char[4]\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\nbitstruct Test2 : char[4] @bigendian\n{\n    ushort a : 0..15;\n    ushort b : 16..31;\n}\n\nfn void test()\n{\n    Test1 t1;\n    Test2 t2;\n    t1.a = t2.a = 0xABCD;\n    t1.b = t2.b = 0x789A;\n\n    char* c = (char*)&t1;\n    for (int i = 0; i < 4; i++)\n    {\n        // Prints CDAB9A78 on x86\n        io::printf(\"%X\", c[i]);\n    }\n    io::printn();\n\n    c = (char*)&t2;\n    for (int i = 0; i < 4; i++)\n    {\n        // Prints ABCD789A\n        io::printf(\"%X\", c[i]);\n    }\n    io::printn();\n}\n```\n```\n\n----------------------------------------\n\nTITLE: C3 Library Manifest Structure in JSON\nDESCRIPTION: Example manifest.json file showing the structure for a C3 library package. Demonstrates target-specific configurations including link flags, dependencies, and linked libraries for macOS and Windows platforms.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Misc Advanced/library-packaging.md#2025-04-21_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"provides\" : \"my_lib\",\n  \"execs\" : [],\n  \"targets\" : {\n    \"macos-x64\" : {\n      \"linkflags\" : [],\n      \"dependencies\" : [],\n      \"linked-libs\" : [\"my_lib_static\", \"Cocoa.framework\", \"c\"]\n    },\n    \"windows-x64\" : {\n      \"linkflags\" : [\"/stack:65536\"],\n      \"dependencies\" : [\"ms_my_extra\"],\n      \"linked-libs\" : [\"my_lib_static\", \"kernel32\"],\n      \"execs\" : [],\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Textual Include in C3\nDESCRIPTION: This snippet demonstrates how to include the contents of another file using the `$include` directive.  This is a simple textual inclusion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nfn testX(int i)\n{\n    return i + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Time Error Statement Syntax\nDESCRIPTION: Defines the syntax for a compile-time error statement in C3, which outputs a compile-time error with a given message when semantically checked. The parameter must evaluate to a constant string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_31\n\nLANGUAGE: c\nCODE:\n```\n\"ct_error_stmt      ::= \\\"$error\\\" constant_expr \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: String Concatenation Example\nDESCRIPTION: Demonstrates compile-time string concatenation in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_8\n\nLANGUAGE: c\nCODE:\n```\nString s = \"abc\" \"def\" \"ghi\";\n// This is equivalent to:\nString s = \"abcdefghi\";\n```\n\n----------------------------------------\n\nTITLE: Integer Types Reference\nDESCRIPTION: Lists all built-in integer types in C3 with their bit widths.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_10\n\nLANGUAGE: text\nCODE:\n```\nchar      unsigned 8-bit\nichar     signed 8-bit\nushort    unsigned 16-bit\nshort     signed 16-bit\nuint      unsigned 32-bit\nint       signed 32-bit\nulong     unsigned 64-bit\nlong      signed 64-bit\nuint128   unsigned 128-bit\nint128    singed 128-bit\n```\n\n----------------------------------------\n\nTITLE: Defining EBNF Operators for C3 Language Specification\nDESCRIPTION: Explanation of EBNF operators used in the C3 language specification, including alternation, grouping, option, and repetition. These operators are used to construct expressions in the language grammar.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_1\n\nLANGUAGE: EBNF\nCODE:\n```\n|   alternation\n()  grouping\n?  option (0 or 1 times)\n*  repetition (0 to n times)\n```\n\n----------------------------------------\n\nTITLE: Calculating Quaternion Length in C3\nDESCRIPTION: A macro function that calculates and returns the length (magnitude) of a quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_76\n\nLANGUAGE: c3\nCODE:\n```\nmacro Real Quaternion.length(Quaternion q)\n```\n\n----------------------------------------\n\nTITLE: Using $extnameof Function in C3\nDESCRIPTION: Shows how to use $extnameof to get the external name of types, variables, or functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/reflection.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nfn void testfn(int x) { }\nString a = $extnameof(g); // => \"test.bar.g\";\nstring b = $extnameof(testfn); // => \"test.bar.testfn\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Documentation Contracts in C3\nDESCRIPTION: Example demonstrating the usage of documentation contracts in C3, including function description, parameter documentation, contracts, and attributes. The code shows how to document a function with various annotations including @param, @require, and @deprecated.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/comments.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n<*\n Here are some docs.\n @param num_foo `The number of foos.`\n @require num_foo > 4\n @deprecated\n @mycustom 2\n*>\nvoid bar(int num_foo)\n{\n    io::printfn(\"%d\", num_foo);\n}\n```\n\n----------------------------------------\n\nTITLE: Spherical Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A function that performs spherical linear interpolation (slerp) between two quaternions based on a given amount. Provides smooth rotation interpolation and returns the interpolated quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_82\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.slerp(q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Copy of String in C3\nDESCRIPTION: Inline function to create a temporary copy of a String using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tcopy(s) => s.copy(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Stripping String in C3\nDESCRIPTION: Function to remove a specified needle string from both ends of a given string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.strip(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Array utility macros in C3 core library\nDESCRIPTION: Utility macros for array operations including concatenation, finding elements, and creating 2D slices. These macros provide convenience operations for array manipulation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_24\n\nLANGUAGE: c3\nCODE:\n```\nmacro concat_new(arr1, arr2, Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro index_of(array, element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro rindex_of(array, element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro slice2d(array, x = 0, xlen = 0, y = 0, ylen = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro tconcat(arr1, arr2)\n```\n\n----------------------------------------\n\nTITLE: OS-specific CPU Information in C3\nDESCRIPTION: Functions to retrieve the number of CPUs on Darwin and Linux systems. These provide system-specific information for resource management and parallel processing.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_99\n\nLANGUAGE: c3\nCODE:\n```\nfn uint num_cpu()\n```\n\n----------------------------------------\n\nTITLE: Textual Include Example in C3\nDESCRIPTION: Demonstrates how to use $include for file inclusion in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/modules.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n$include(\"Foo.x\");\n\nfn void test()\n{\n    io::printf(\"%d\", testX(2));\n}\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn testX(int i)\n{\n    return i + 1;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling for C3 Parser in C\nDESCRIPTION: This function handles error reporting for the C3 parser. It flushes stdout and prints the error message with a caret (^) pointing to the error location.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_22\n\nLANGUAGE: C\nCODE:\n```\nvoid yyerror(char *s)\n{\n\tfflush(stdout);\n\tprintf(\"\\n%*s\\n%*s\\n\", column, \"^\", column, s);\n}\n```\n\n----------------------------------------\n\nTITLE: Vector Type Syntax\nDESCRIPTION: Defines the syntax for vector types in C3, specifying the base type and length.  The base type of a vector must be boolean, an integer or a floating point type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_15\n\nLANGUAGE: text\nCODE:\n```\n\"vector_type        ::= type \\\"[<\\\" length \\\">]\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Subtracting Scalar from Each Component of Quaternion in C3\nDESCRIPTION: A macro that subtracts a real scalar value from each component of a quaternion and returns the result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_86\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.sub_each(Quaternion a, Real b)\n```\n\n----------------------------------------\n\nTITLE: Initializing Integer Constants in C3\nDESCRIPTION: Demonstrates different ways to initialize integer constants in C3, including decimal, octal, and hexadecimal notations. Also shows the use of underscores for improved readability.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\na = -2_000;\nb = 0o770;\nc = 0x7f7f7f;\n```\n\n----------------------------------------\n\nTITLE: Defining EBNF Syntax Rules for C3\nDESCRIPTION: Core EBNF production rules defining the syntax notation used throughout the specification.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_0\n\nLANGUAGE: ebnf\nCODE:\n```\nproduction  ::= PRODUCTION_NAME '::=' expression?\nexpression  ::= alternative (\"|\" alternative)*\nalternative ::= term term*\nterm        ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition\nset         ::= '[' (range | CHAR) (rang | CHAR)* ']'\nrange       ::= CHAR '-' CHAR\ngroup       ::= '(' expression ')'\noption      ::= expression '?'\nrepetition  ::= expression '*'\n```\n\n----------------------------------------\n\nTITLE: Implementing Complex Number Operations in C3\nDESCRIPTION: Macros for complex number arithmetic, providing basic operations like addition, subtraction, multiplication, division, and scaling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_70\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.add(self, Complex b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.add_each(self, Real b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.div(self, Complex b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.mul(self, Complex b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.scale(self, Real s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.sub(self, Complex b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Complex Complex.sub_each(self, Real b)\n```\n\n----------------------------------------\n\nTITLE: Using Distinct Types in C3\nDESCRIPTION: This code demonstrates how to create and use distinct types in C3 using the `distinct` keyword. Distinct types are type aliases that are treated as distinct from their underlying type, preventing implicit conversions. This example highlights the use of explicit casting to convert between distinct types and their underlying types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\n```c3\ndistinct MyId = int;\nfn void* get_by_id(MyId id) { ... }\n\nfn void test(MyId id)\n{\n    void* val = get_by_id(id); // Ok\n    void* val2 = get_by_id(1); // Literals convert implicitly\n    int a = 1;\n    // void* val3 = get_by_id(a); // ERROR expected a MyId\n    void* val4 = get_by_id((MyId)a); // Works\n    // a = id; // ERROR can't assign 'MyId' to 'int'\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Yacc Grammar for C3 Language\nDESCRIPTION: Defines the initial Yacc configuration with header includes, debug settings, and external function declarations for the C3 language parser\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_4\n\nLANGUAGE: yacc\nCODE:\n```\n%{\n\n#include <stdio.h>\n#define YYERROR_VERBOSE\nint yydebug = 1;\nextern char yytext[];\nextern int column;\nint yylex(void);\nvoid yyerror(char *s);\n%}\n```\n\n----------------------------------------\n\nTITLE: Cleaning, Building, and Running a C3 Project\nDESCRIPTION: Clean the project, rebuild it, and then run the resulting executable. This ensures a fresh build before execution.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nc3c clean-run [target]\n```\n\n----------------------------------------\n\nTITLE: POSIX-Specific Socket Operations in C3\nDESCRIPTION: POSIX-specific socket implementation details conditionally compiled for POSIX environments. Includes file descriptor-based socket handling and error conversion from POSIX errno values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_95\n\nLANGUAGE: c3\nCODE:\n```\ntypedef NativeSocket = inline Fd;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Posix_pollfd\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? NativeSocket.close(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool NativeSocket.is_non_blocking(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void? NativeSocket.set_non_blocking(self, bool non_blocking)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn fault convert_error(Errno error)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn fault socket_error()\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Macros\nDESCRIPTION: This snippet defines grammar rules for macros in C3, including macro parameters, trailing block parameters, and macro function bodies.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_12\n\nLANGUAGE: yacc\nCODE:\n```\ntrailing_block_param\n\t: AT_IDENT\n\t| AT_IDENT '(' ')'\n\t| AT_IDENT '(' parameters ')'\n\t;\n\nmacro_params\n\t: parameters\n\t| parameters ';' trailing_block_param\n\t| ';' trailing_block_param\n\t| empty\n\t;\n\nmacro_func_body\n\t: implies_body ';'\n\t| compound_statement\n\t;\n\nmacro_declaration\n    \t: MACRO macro_header '(' macro_params ')' opt_attributes macro_func_body\n\t;\n```\n\n----------------------------------------\n\nTITLE: Converting String to New WString in C3\nDESCRIPTION: Function to convert a String to a new WString using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Integer Literal Syntax\nDESCRIPTION: EBNF rules defining the syntax for integer literals including decimal, binary, octal, and hexadecimal formats.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_3\n\nLANGUAGE: ebnf\nCODE:\n```\nINTEGER         ::= DECIMAL_LIT | BINARY_LIT | OCTAL_LIT | HEX_LIT\nDECIMAL_LIT     ::= '0' | [1-9] ('_'* DECIMAL_DIGITS)?\nBINARY_LIT      ::= '0' [bB] '_'* BINARY_DIGITS\nOCTAL_LIT       ::= '0' [oO] '_'* OCTAL_DIGITS\nHEX_LIT         ::= '0' [xX] '_'* HEX_DIGITS\n\nBINARY_DIGIT    ::= [01]\nHEX_DIGIT       ::= [0-9a-fA-F]\n\nDECIMAL_DIGITS  ::= DIGIT ('_'* DIGIT)*\nBINARY_DIGITS   ::= BINARY_DIGIT ('_'* BINARY_DIGIT)*\nOCTAL_DIGITS    ::= OCTAL_DIGIT ('_'* OCTAL_DIGIT)*\nHEX_DIGITS      ::= HEX_DIGIT ('_'* HEX_DIGIT)*\n```\n\n----------------------------------------\n\nTITLE: Defer Statement Syntax\nDESCRIPTION: Defines the syntax for the `defer` statement, which allows specifying code to be executed at scope exit. It allows for optional `try` or `catch` clauses, and the defer body can contain multiple defer statements if it is a compound statement.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_27\n\nLANGUAGE: c\nCODE:\n```\n\ndefer_stmt         ::= \"defer\" (\"try\" | \"catch\")? stmt\n\n```\n\n----------------------------------------\n\nTITLE: High-Level Memory Allocation in C3\nDESCRIPTION: Macros for type-safe memory allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_54\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc($Type) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_aligned($Type) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_array($Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro alloc_array_aligned($Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new($Type, ...) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_aligned($Type, ...) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_array($Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro new_array_aligned($Type, usz elements) @nodiscard\n```\n\n----------------------------------------\n\nTITLE: String to Temporary UTF-16 Conversion in C3\nDESCRIPTION: Converts a String to a temporary UTF-16 encoded Char16 array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]? String.to_temp_utf16(s);\n```\n\n----------------------------------------\n\nTITLE: Triple and Tuple structures in C3\nDESCRIPTION: Defines Triple and Tuple structures for containing 3 and 2 values of different types, respectively. These are simple container types for grouping heterogeneous values.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nstruct Triple\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Tuple\n```\n\n----------------------------------------\n\nTITLE: Function Parameter Reflection in C3\nDESCRIPTION: Demonstrates accessing function parameter information using paramsof property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\ndef TestFunc = fn int(int x, double f);\nString s = TestFunc.paramsof[1].name; // \"f\"\ntypeid t = TestFunc.paramsof[1].type; // double.typeid\n```\n\n----------------------------------------\n\nTITLE: String to Temporary ZString Copy in C3\nDESCRIPTION: Creates a temporary ZString copy of a String using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_52\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString String.zstr_tcopy(s) => s.zstr_copy(allocator::temp()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Inline Assembly String in C3\nDESCRIPTION: This snippet shows how to insert inline assembly code directly as a string in C3. The assembly code is passed to the backend without modification.  It requires the C3 compiler to be able to handle the target assembly instruction set.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Misc Advanced/asm.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint x = 0;\nasm(\"nop\");\nint y = x;\n```\n\n----------------------------------------\n\nTITLE: Defining WString Type in C3\nDESCRIPTION: Defines the WString type as an inline Char16 pointer, typically used for UTF-16 encoded strings in applications requiring 16-bit character encoding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ntypedef WString = inline Char16*;\n```\n\n----------------------------------------\n\nTITLE: Rethrow Expression Syntax in C3 Language\nDESCRIPTION: This snippet describes the grammar for the rethrow expression in C3, specifying that it rethrows an optional expression while detailing the conditions under which it is valid.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_21\n\nLANGUAGE: C3\nCODE:\n```\nrethrow_expr       ::= expr \"!\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Unsigned Short Integer Operations in C3\nDESCRIPTION: A set of macros for unsigned short integers providing parity checking, overflow handling, saturation arithmetic, and array operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_69\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool ushort.is_even(ushort x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool ushort.is_odd(ushort x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort! ushort.overflow_add(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort! ushort.overflow_mul(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort! ushort.overflow_sub(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.sat_add(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.sat_mul(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.sat_shl(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort.sat_sub(ushort x, ushort y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].and(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_eq(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_ge(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_gt(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_le(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_lt(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ushort[<*>].comp_ne(ushort[<*>] x, ushort[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].max(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].min(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].or(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].product(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].sum(ushort[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort ushort[<*>].xor(ushort[<*>] x)\n```\n\n----------------------------------------\n\nTITLE: C3 Scripting with $exec\nDESCRIPTION: This snippet shows the scripting mode of `$exec`, where C3 files are compiled on the fly and executed.  The example compiles `foo.c3` and `bar.c3` from the `/scripts` directory (or the current directory for non-project builds) and invokes the resulting binary with the argument 'test'. This example relies on the existence of `foo.c3` and `bar.c3` files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// Compile foo.c3 and bar.c3 in the /scripts directory, invoke the resulting binary\n// with the argument 'test'\n$exec(\"foo.c3;bar.c3\", { \"test\" });\n\nfn void main()\n{\n\t...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Ternary, Elvis, and Orelse Expressions in C3 Language\nDESCRIPTION: This snippet defines the grammar rules for ternary, elvis, and orelse expressions in C3. It captures how these constructs are formed and their relationships with other expressions, emphasizing the conditional evaluation strategies used.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_18\n\nLANGUAGE: C3\nCODE:\n```\nternary_group_expr ::= suffix_group_expr | ternary_expr | elvis_expr | orelse_expr\nternary_expr       ::= or_expr \"?\" expr \":\" ternary_group_expr\nelvis_expr         ::= suffix_expr \"?:\" ternary_group_expr\norelse_expr       ::= suffix_expr \"??\" ternary_group_expr\n```\n\n----------------------------------------\n\nTITLE: String Manipulation Functions in C3\nDESCRIPTION: Implements various string manipulation functions such as concatenation, case conversion, searching, and splitting.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_59\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.concat(s1, String s2, Allocator allocator = allocator::heap())\nfn bool String.contains(s, String needle)\nfn void String.convert_ascii_to_lower(s)\nfn void String.convert_ascii_to_upper(s)\nfn String String.copy(s, Allocator allocator = allocator::heap())\nfn bool String.ends_with(string, String needle)\nfn void String.free(&s, Allocator allocator = allocator::heap())\nfn usz! String.index_of(s, String needle)\nfn usz! String.index_of_char(s, char needle)\nfn StringIterator String.iterator(s)\nfn String String.new_ascii_to_lower(s, Allocator allocator = allocator::heap())\nfn String String.new_ascii_to_upper(s, Allocator allocator = allocator::heap())\nfn usz! String.rindex_of(s, String needle)\nfn usz! String.rindex_of_char(s, char needle)\nfn String[] String.split(s, String needle, usz max = 0, Allocator allocator = allocator::heap())\nfn Splitter String.splitter(self, String split)\nfn bool String.starts_with(string, String needle)\nfn String String.strip(string, String needle)\nfn String String.strip_end(string, String needle)\nfn String String.tconcat(s1, String s2)\nfn String String.tcopy(s)\nfn String String.temp_ascii_to_lower(s, Allocator allocator = allocator::heap())\nfn String String.temp_ascii_to_upper(s)\nfn String String.trim(string, String to_trim = \"\\t\\n\\r \")\nfn String[] String.tsplit(s, String needle, usz max = 0)\nfn usz String.utf8_codepoints(s)\n```\n\n----------------------------------------\n\nTITLE: Explicit Cast Examples in C3\nDESCRIPTION: This C3 code snippet provides examples where explicit casts are required to resolve ambiguity when multiple conversion paths are possible. It highlights the need for clarity in specifying the intended type conversion to avoid unexpected behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/conversion.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n\"long h = a + (b + c);\n\n// Possible intention 1\nlong h = (long)(a + (b + c));\n\n// Possible intention 2\nlong h = (long)a + (long)(b + c);\n\n// Possible intention 3\nlong h = (long)a + ((long)b + (long)c);\"\n```\n\n----------------------------------------\n\nTITLE: Standard I/O Functions without LIBC Support in C3\nDESCRIPTION: Standard I/O functions for environments without LIBC support, providing alternative implementations for standard streams and character output.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_55\n\nLANGUAGE: c3\nCODE:\n```\nfn void putchar(char c) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stderr()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stdin()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn File* stdout()\n```\n\n----------------------------------------\n\nTITLE: Signal handling functions for Unix-like systems in C3\nDESCRIPTION: Signal handling functions for handling bus errors, segmentation faults, and panic conditions on Unix-like systems when running in safe mode with debug symbols.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_31\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_bus_error(CInt i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_panic(String message)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sig_segmentation_fault(CInt i)\n```\n\n----------------------------------------\n\nTITLE: Compiler Detection of Parameter Annotation Violations in C3\nDESCRIPTION: Shows a case where the compiler is likely to detect a violation of parameter annotations, resulting in a compile-time error.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param [&in] i\n*>\nfn void bad_func(int* i)\n{\n    *i = 2; // <- Compiler error: cannot write to \"in\" parameter\n}\n```\n\n----------------------------------------\n\nTITLE: Multiplying Quaternions in C3\nDESCRIPTION: A function that multiplies two quaternions and returns the resulting quaternion. Quaternion multiplication represents composition of rotations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_78\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.mul(a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: Network Operations and Socket Handling in C3\nDESCRIPTION: Functions and structures for network operations, including IP address handling, socket operations, and TCP/UDP connections. These functions provide a foundation for network programming in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_95\n\nLANGUAGE: c3\nCODE:\n```\nenum IpProtocol : char (AIFamily ai_family)\n\nfault NetError\n\nstruct InetAddress (Printable)\n\nfn bool InetAddress.is_any_local(InetAddress* addr)\n\nfn bool InetAddress.is_link_local(InetAddress* addr)\n\nfn bool InetAddress.is_loopback(InetAddress* addr)\n\nfn bool InetAddress.is_multicast(InetAddress* addr)\n\nfn bool InetAddress.is_multicast_global(InetAddress* addr)\n\nfn bool InetAddress.is_multicast_link_local(InetAddress* addr)\n\nfn bool InetAddress.is_multicast_node_local(InetAddress* addr)\n\nfn bool InetAddress.is_multicast_org_local(InetAddress* addr)\n\nfn bool InetAddress.is_multicast_site_local(InetAddress* addr)\n\nfn bool InetAddress.is_site_local(InetAddress* addr)\n\nfn usz! InetAddress.to_format(InetAddress* addr, Formatter* formatter) @dynamic\n\nfn String InetAddress.to_new_string(InetAddress* addr, Allocator allocator = allocator::heap()) @dynamic\n\nfn AddrInfo*! addrinfo(String host, uint port, AIFamily ai_family, AISockType ai_socktype) @if(os::SUPPORTS_INET)\n\nfn String! int_to_new_ipv4(uint val, Allocator allocator = allocator::heap())\n\nfn String! int_to_temp_ipv4(uint val)\n\nfn InetAddress! ipv4_from_str(String s)\n\nfn uint! ipv4toint(String s)\n\nfn InetAddress! ipv6_from_str(String s)\n```\n\n----------------------------------------\n\nTITLE: Presenting C3 Release Schedule in Markdown Table\nDESCRIPTION: This Markdown table displays the planned release schedule for C3 versions 0.7 through 1.0. It shows the expected release dates for major versions over the next few years.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/roadmap.md#2025-04-21_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Date       |  Release  |\n|------------|-----------|\n| 2025-04-01 |    0.7    |\n| 2026-04-01 |    0.8    |\n| 2027-04-01 |    0.9    |\n| 2028-04-01 |    1.0    |\n```\n\n----------------------------------------\n\nTITLE: Vector and Matrix Operations in C3\nDESCRIPTION: Functions and macros for vector and matrix operations, including angle calculations, vector transformations, cross products, and matrix-based operations like look-at matrices.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_94\n\nLANGUAGE: c3\nCODE:\n```\nmacro Vec2.angle(self, Vec2 v2)\n\nmacro Vec2.clamp_mag(self, double min, double max)\n\nmacro Vec2.distance_sq(self, Vec2 v2)\n\nmacro Vec2.length_sq(self)\n\nmacro Vec2.rotate(self, double angle)\n\nfn Vec2 Vec2.towards(self, Vec2 target, double max_distance)\n\nmacro Vec2.transform(self, Matrix4 mat)\n\nmacro Vec2f.angle(self, Vec2f v2)\n\nmacro Vec2f.clamp_mag(self, float min, float max)\n\nmacro Vec2f.distance_sq(self, Vec2f v2)\n\nmacro Vec2f.length_sq(self)\n\nmacro Vec2f.rotate(self, float angle)\n\nfn Vec2f Vec2f.towards(self, Vec2f target, float max_distance)\n\nmacro Vec2f.transform(self, Matrix4f mat)\n\nfn double Vec3.angle(self, Vec3 v2)\n\nfn Vec3 Vec3.barycenter(self, Vec3 a, Vec3 b, Vec3 c)\n\nmacro Vec3.clamp_mag(self, double min, double max)\n\nfn Vec3 Vec3.cross(self, Vec3 v2)\n\nmacro Vec3.distance_sq(self, Vec3 v2)\n\nmacro Vec3.length_sq(self)\n\nfn Vec3 Vec3.perpendicular(self)\n\nfn Vec3 Vec3.refract(self, Vec3 n, double r)\n\nfn Vec3 Vec3.rotate_axis(self, Vec3 axis, double angle)\n\nfn Vec3 Vec3.rotate_quat(self, Quaternion q)\n\nfn Vec3 Vec3.towards(self, Vec3 target, double max_distance)\n\nfn Vec3 Vec3.transform(self, Matrix4 mat)\n\nfn Vec3 Vec3.unproject(self, Matrix4 projection, Matrix4 view)\n\nfn float Vec3f.angle(self, Vec3f v2)\n\nfn Vec3f Vec3f.barycenter(self, Vec3f a, Vec3f b, Vec3f c)\n\nmacro Vec3f.clamp_mag(self, float min, float max)\n\nfn Vec3f Vec3f.cross(self, Vec3f v2)\n\nmacro Vec3f.distance_sq(self, Vec3f v2)\n\nmacro Vec3f.length_sq(self)\n\nfn Vec3f Vec3f.perpendicular(self)\n\nfn Vec3f Vec3f.refract(self, Vec3f n, float r)\n\nfn Vec3f Vec3f.rotate_axis(self, Vec3f axis, float angle)\n\nfn Vec3f Vec3f.rotate_quat(self, Quaternionf q)\n\nfn Vec3f Vec3f.towards(self, Vec3f target, float max_distance)\n\nfn Vec3f Vec3f.transform(self, Matrix4f mat)\n\nfn Vec3f Vec3f.unproject(self, Matrix4f projection, Matrix4f view)\n\nmacro Vec4.clamp_mag(self, double min, double max)\n\nmacro Vec4.distance_sq(self, Vec4 v2)\n\nmacro Vec4.length_sq(self)\n\nfn Vec4 Vec4.towards(self, Vec4 target, double max_distance)\n\nmacro Vec4f.clamp_mag(self, float min, float max)\n\nmacro Vec4f.distance_sq(self, Vec4f v2)\n\nmacro Vec4f.length_sq(self)\n\nfn Vec4f Vec4f.towards(self, Vec4f target, float max_distance)\n\nfn Matrix4 matrix4_look_at(Vec3 eye, Vec3 target, Vec3 up)\n\nfn Matrix4f matrix4f_look_at(Vec3f eye, Vec3f target, Vec3f up)\n\nfn void ortho_normalize(Vec3f* v1, Vec3f* v2)\n\nfn void ortho_normalized(Vec3* v1, Vec3* v2)\n```\n\n----------------------------------------\n\nTITLE: Vector Operations Example\nDESCRIPTION: Demonstrates element-wise vector operations in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_11\n\nLANGUAGE: c\nCODE:\n```\nint[<2>] a = { 1, 3 };\nint[<2>] b = { 2, 7 };\n\nint[<2>] c = a * b;\n// Equivalent to\nint[<2>] c = { a[0] * b[0], a[1] * b[1] };\n```\n\n----------------------------------------\n\nTITLE: String to UTF-16 Conversion in C3\nDESCRIPTION: Converts a String to a new UTF-16 encoded Char16 array using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]? String.to_new_utf16(s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Constants and Type Definitions\nDESCRIPTION: This snippet defines grammar rules for constant declarations and type definitions in C3, including function typedefs and generic parameters.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_16\n\nLANGUAGE: yacc\nCODE:\n```\nconst_declaration\n\t: CONST CONST_IDENT opt_attributes '=' expr ';'\n\t| CONST type CONST_IDENT opt_attributes '=' expr ';'\n\t;\n\nfunc_typedef\n    : FN optional_type fn_parameter_list\n    ;\n\nopt_distinct_inline\n\t: DISTINCT\n\t| DISTINCT INLINE\n\t| INLINE DISTINCT\n\t| INLINE\n\t| empty\n\t;\n\ngeneric_parameters\n\t: bit_expr\n\t| type\n\t| generic_parameters ',' bit_expr\n\t| generic_parameters ',' type\n\t;\n\ntypedef_type\n\t: func_typedef\n\t| type opt_generic_parameters\n\t;\n```\n\n----------------------------------------\n\nTITLE: Memory Management Functions\nDESCRIPTION: Standard memory allocation and manipulation functions including malloc, calloc, free, and memory operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void* malloc(usz size) @weak @extern(\"malloc\") @nostrip\nfn void* calloc(usz count, usz size) @weak @extern(\"calloc\") @nostrip\nfn void free(void*) @weak @extern(\"free\")\nfn void* realloc(void* ptr, usz size) @weak @extern(\"realloc\") @nostrip\n```\n\n----------------------------------------\n\nTITLE: Subtracting Quaternions in C3\nDESCRIPTION: A macro that subtracts one quaternion from another and returns the result as a new quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_85\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.sub(Quaternion a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Macro Execution for Constant Evaluation in C3\nDESCRIPTION: This snippet demonstrates how macros with only compile time parameters can be completely executed at compile time, allowing for constant folding.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nmacro @test($abc)\n{\n    return $abc * 2;\n}\n\nconst int MY_CONST = @test(2); // Will fold to \"4\"\n```\n\n----------------------------------------\n\nTITLE: Converting Quaternion to Matrix4f in C3\nDESCRIPTION: A macro function that converts a quaternion to a 4x4 float matrix representation and returns the matrix.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_86\n\nLANGUAGE: c3\nCODE:\n```\nmacro Matrix4f Quaternion.to_matrixf(Quaternion* q)\n```\n\n----------------------------------------\n\nTITLE: Vector Operations in C3\nDESCRIPTION: Demonstrates vector initialization and arithmetic operations in C3 using SIMD-based vectors.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nint[<*>] a = { 1, 2 };\nint[<2>] b = { 3, 8 };\nint[<2>] c = { 7, 2 };\nint[<2>] d = b * c;    // d is { 21, 16 }\n```\n\n----------------------------------------\n\nTITLE: Converting String to UTF-16 in C3\nDESCRIPTION: Functions to convert a String to UTF-16 encoded Char16 array, with options for new or temporary allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_29\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]! String.to_new_utf16(s, Allocator allocator = allocator::heap());\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]! String.to_temp_utf16(s);\n```\n\n----------------------------------------\n\nTITLE: Defining EBNF Notation for C3 Language Specification\nDESCRIPTION: Extended Backus-Naur Form (EBNF) notation used to specify the syntax of the C3 language. It defines the structure for productions, expressions, alternatives, terms, and various operators.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_0\n\nLANGUAGE: EBNF\nCODE:\n```\nproduction  ::= PRODUCTION_NAME '::=' expression?\nexpression  ::= alternative (\"|\" alternative)* \nalternative ::= term term*\nterm        ::= PRODUCTION_NAME | TOKEN | set | group | option | repetition\nset         ::= '[' (range | CHAR) (rang | CHAR)* ']'\nrange       ::= CHAR '-' CHAR \ngroup       ::= '(' expression ')'\noption      ::= expression '?'\nrepetition  ::= expression '*'\n```\n\n----------------------------------------\n\nTITLE: String to 128-bit Integer Conversion in C3\nDESCRIPTION: Converts a String to a 128-bit integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\nfn int128? String.to_int128(s, int base = 10) => s.to_integer(int128, base);\n```\n\n----------------------------------------\n\nTITLE: Windows-specific OS Functions (C3)\nDESCRIPTION: Type definitions and structures for Windows-specific operations, including process, thread, and memory management.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_109\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Win32_CRITICAL_SECTION = ulong[5];\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum Win32_ADDRESS_MODE\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum Win32_SYM_TYPE\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_ADDRESS64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_AMD64_CONTEXT @align(16)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_ARM64_NT_CONTEXT @align(16)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_ARM64_NT_NEON128\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_FILETIME\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_GUID\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGEHLP_LINE64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGEHLP_MODULE64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGE_DATA_DIRECTORY\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGE_FILE_HEADER\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGE_NT_HEADERS\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_IMAGE_OPTIONAL_HEADER64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_KDHELP64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_M128A @align(16)\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_MODLOAD_DATA\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_MODULEINFO\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_OVERLAPPED\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_PROCESS_INFORMATION\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_SECURITY_ATTRIBUTES\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_STACKFRAME64\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_STARTUPINFOEXW\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_STARTUPINFOW\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_SYMBOL_INFO\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_SYSTEM_INFO\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_UNICODE_STRING\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Win32_XMM_SAVE_AREA32\n```\n\n----------------------------------------\n\nTITLE: Compile Time Introspection in C3\nDESCRIPTION: This example demonstrates compile time introspection capabilities in C3, including accessing type information and member details.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nusz foo_alignment = Foo.alignof;\nusz foo_member_count = Foo.membersof.len;\nString foo_name = Foo.nameof;\n```\n\n----------------------------------------\n\nTITLE: Subtracting Quaternions in C3\nDESCRIPTION: A macro function that subtracts one quaternion from another and returns the resulting quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_83\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.sub(Quaternion a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: ZString Character Length in C3\nDESCRIPTION: Returns the number of characters in a ZString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_49\n\nLANGUAGE: c3\nCODE:\n```\nfn usz ZString.char_len(str);\n```\n\n----------------------------------------\n\nTITLE: Implementing Math Functions without LibC in C3\nDESCRIPTION: A collection of implementations for standard math functions when the C library is not available, including trigonometric, rounding, and power functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_74\n\nLANGUAGE: c3\nCODE:\n```\nfn double __cos(double x, double y) @extern(\"__cos\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float __cosdf(double x) @extern(\"__cosdf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int __rem_pio2(double x, double *y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int __rem_pio2_large(double* x, double* y, int e0, int nx, int prec)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int __rem_pio2f(float x, double *y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double __sin(double x, double y, int iy) @extern(\"__sin\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float __sindf(double x) @extern(\"__sindf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double __tan(double x, double y, int odd) @extern(\"__tan\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float __tandf(double x, int odd) @extern(\"__tandf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _atan(double x) @weak @extern(\"atan\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _atan2(double y, double x) @weak @extern(\"atan2\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _atan2f(float y, float x) @weak @extern(\"atan2f\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _atanf(float x) @weak @extern(\"atanf\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _ceil(double x) @weak @extern(\"ceil\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _ceilf(float x) @weak @extern(\"ceilf\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _cos(double x) @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _cosf(float x) @extern(\"cosf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _exp2(double x) @extern(\"exp2\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _exp2f(float x) @extern(\"exp2f\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _floor(double x) @weak @extern(\"floor\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _floorf(float x) @weak @extern(\"floorf\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _round(double x) @extern(\"round\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _roundf(float x) @extern(\"roundf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _scalbn(double x, int n) @weak @extern(\"scalbn\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _sinf(float x) @weak @extern(\"sinf\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double _trunc(double x) @weak @extern(\"trunc\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float _truncf(float x) @weak @extern(\"truncf\") @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double pow_broken(double x, double y) @extern(\"pow\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float powf_broken(float x, float f) @extern(\"powf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double sin(double x) @extern(\"sin\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sincos(double x, double *sin, double *cos) @extern(\"sincos\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double sincos_broken(double x) @extern(\"sincos\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void sincosf(float x, float *sin, float *cos) @extern(\"sincosf\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double tan(double x) @extern(\"tan\") @weak @nostrip\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float tanf(float x) @extern(\"tanf\") @weak @nostrip\n```\n\n----------------------------------------\n\nTITLE: String Literal Grammar\nDESCRIPTION: Defines the grammar for string literals in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_7\n\nLANGUAGE: text\nCODE:\n```\nSTRING_LIT      ::= \\x22 (CHAR_LIT_BYTE | UNICODE_CHAR)* \\x22\n```\n\n----------------------------------------\n\nTITLE: String Contains Check in C3\nDESCRIPTION: Checks if the string contains the specified needle.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.contains(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Implementing 'Element ref' Operator (&[]) in C3\nDESCRIPTION: This snippet demonstrates the implementation of the '&[]' operator for the Foo type, which returns a pointer to a double. This allows for reference-based access to elements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/operator-overloading.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn double* Foo.get_ref(&self, usz i) @operator(&[])\n{\n    return &self.x[i];\n}\n```\n\n----------------------------------------\n\nTITLE: Public Import in C3\nDESCRIPTION: This snippet demonstrates how to use `import <module> @public` to access another module's private symbols, allowing for ad-hoc visibility manipulation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n// File a.c3\nmodule a;\n\nfn void a_function() @private { ... }\n\n// File b.c3\nmodule b;\n\nfn void b_function() @private { ... }\n\n// File c.c3\nmodule c;\nimport a;\nimport b @public;\n\nfn void test()\n{\n    // Error! a_function() is private\n    a::a_function(); \n\n    // Allowed since `import b @public` allowed `b`\n    // to \"public\" in this context.\n    b::b_function(); \n}\n```\n\n----------------------------------------\n\nTITLE: Win32 Platform Support\nDESCRIPTION: Windows-specific structures and functions for system operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_103\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Win32_CRITICAL_SECTION = ulong[5];\nenum Win32_ADDRESS_MODE\nstruct Win32_ADDRESS64\n```\n\n----------------------------------------\n\nTITLE: Listing C3 Predefined Constants\nDESCRIPTION: This snippet lists all predefined constants in C3, which provide information about the current compilation context, such as file names, line numbers, and compilation date.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\n$$BENCHMARK_FNS  $$BENCHMARK_NAMES $$DATE\n$$FILE           $$FILEPATH        $$FUNC\n$$FUNCTION       $$LINE            $$LINE_RAW\n$$MODULE         $$TEST_FNS        $$TEST_NAMES\n$$TIME\n```\n\n----------------------------------------\n\nTITLE: DString Capacity and Size Management in C3\nDESCRIPTION: Functions for managing the capacity and size of a DString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_36\n\nLANGUAGE: c3\nCODE:\n```\nfn usz DString.capacity(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.chop(self, usz new_size)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.clear(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.reserve(&self, usz addition)\n```\n\n----------------------------------------\n\nTITLE: If Catch Example\nDESCRIPTION: Example showcasing `if-catch` which provides implicit unwrapping in the else clause.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_40\n\nLANGUAGE: c\nCODE:\n```\n\"int! a = foo();\\nint! b = foo();\\nif (catch a, b)\\n{\\n    // Do something\\n}\\nelse\\n{\\n    int x = a + b; // Valid, a and b are implicitly unwrapped.\\n}  \"\n```\n\n----------------------------------------\n\nTITLE: Defining C3 Grammar Rules for Compile-Time Operations\nDESCRIPTION: This snippet defines grammar rules for compile-time operations in C3, including assertions, includes, and echo statements that execute during compilation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_8\n\nLANGUAGE: yacc\nCODE:\n```\nct_assert_stmt\n\t: CT_ASSERT constant_expr ':' constant_expr ';'\n\t| CT_ASSERT constant_expr ';'\n\t| CT_ERROR constant_expr ';'\n\t;\n\nct_include_stmt\n\t: CT_INCLUDE string_expr ';'\n\t;\n\nct_echo_stmt\n\t: CT_ECHO constant_expr ';'\n```\n\n----------------------------------------\n\nTITLE: Defining Allocator Types and Interfaces in C3\nDESCRIPTION: Core type definitions and interfaces for memory allocation in C3, including the LibcAllocator typedef, AllocInitType enum, and the Allocator interface.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\ntypedef LibcAllocator (Allocator) = uptr;\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum AllocInitType\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault AllocationFailure\n```\n\nLANGUAGE: c3\nCODE:\n```\ninterface Allocator\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct AlignedBlock\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Allocation\n```\n\n----------------------------------------\n\nTITLE: Declaration Statement Syntax\nDESCRIPTION: Specifies the syntax for declaration statements, including the use of `tlocal` for thread-local storage and `static` for function-global storage. It details how to declare variables with optional initialization expressions and attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_23\n\nLANGUAGE: c\nCODE:\n```\n\ndeclaration_stmt   ::= const_declaration | local_decl_storage? optional_type decls_after_type \";\"\nlocal_decl_storage ::= \"tlocal\" | \"static\"\ndecls_after_type   ::= local_decl_after_type (\",\" local_decl_after_type)*\ndecl_after_type    ::= CT_IDENT (\"=\" constant_expr)? | IDENTIFIER opt_attributes (\"=\" expr)?\n\n```\n\n----------------------------------------\n\nTITLE: Capturing CPU Count in Windows (C3)\nDESCRIPTION: Function to get the number of CPUs on Windows systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_100\n\nLANGUAGE: c3\nCODE:\n```\nfn uint num_cpu()\n```\n\n----------------------------------------\n\nTITLE: Running Benchmarks for a C3 Project\nDESCRIPTION: Execute benchmarks on a specified target to measure performance.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nc3c bench [target]\n```\n\n----------------------------------------\n\nTITLE: Implementing Easing Functions in C3\nDESCRIPTION: A collection of easing functions for animation and interpolation, implementing various timing curves like linear, quadratic, cubic, sine, elastic, bounce, and more.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_71\n\nLANGUAGE: c3\nCODE:\n```\nfn float back_in(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float back_inout(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float back_out(float t, float b, float c, float d, float s = 1.70158f) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float bounce_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float bounce_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float bounce_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float circ_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float circ_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float circ_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float cubic_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float cubic_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float cubic_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float elastic_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float elastic_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float elastic_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float expo_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float expo_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float expo_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float linear_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float linear_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float linear_none(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float linear_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float quad_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float quad_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float quad_out(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float sine_in(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float sine_inout(float t, float b, float c, float d) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn float sine_out(float t, float b, float c, float d) @inline\n```\n\n----------------------------------------\n\nTITLE: Source Configuration in C3 Project\nDESCRIPTION: Example configuration in project.json that defines which source files should be included in the project, using a glob pattern to include all files in the src directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_4\n\nLANGUAGE: json5\nCODE:\n```\n...\n\"sources\": [ \"src/**\" ],\n...\n```\n\n----------------------------------------\n\nTITLE: Do-Without-While Loop in C3\nDESCRIPTION: Shows a do loop without while condition, which acts as if while(0). The function prints different messages based on input value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int x)\n{\n    do \n    {\n        if (!x) break;\n        io::printf(\"Hello \");\n    };\n    io::printf(\"World!\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Linux-specific Thread Primitives (C3)\nDESCRIPTION: Type definitions for Linux-specific thread primitives and synchronization objects.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_115\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_attr_t = ulong[7]; // 24 on 32bit\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_cond_t = ulong[6];\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_condattr_t = uint;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_key_t = uint;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_mutex_t = ulong[5]; // 24 on 32 bit\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_mutexattr_t = uint;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_once_t = int;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_rwlock_t = ulong[7]; // 32 on 3bit\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_rwlockattr_t = uint;\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef Pthread_sched_param = uint;\n```\n\n----------------------------------------\n\nTITLE: EBNF Operator Precedence\nDESCRIPTION: Defines the precedence of EBNF operators used in the syntax specification.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_1\n\nLANGUAGE: ebnf\nCODE:\n```\n|   alternation\n()  grouping\n?  option (0 or 1 times)\n*  repetition (0 to n times)\n```\n\n----------------------------------------\n\nTITLE: Substring Index in String in C3\nDESCRIPTION: Finds the index of the specified substring in the string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? String.index_of(s, String needle)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Macro Conditions with @if in C3\nDESCRIPTION: Shows how to use compile time evaluated macros in @if conditions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @foo($x) => $x > 2;\n\nint x @if(@foo(5)); // Will be included\nint y @if(@foo(0)); // Will not be included\n```\n\n----------------------------------------\n\nTITLE: DString Memory Management in C3\nDESCRIPTION: Functions for freeing memory used by DStrings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_44\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.free(&self)\n```\n\n----------------------------------------\n\nTITLE: Assembly Block Statement Syntax in C3\nDESCRIPTION: Defines the syntax for inline assembly blocks with complex expression handling\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nasm_block_stmt      ::= \"asm\" (\"(\" constant_expr \")\" | \"{\" asm_stmt* \"}\")\nasm_stmt            ::= asm_instr asm_exprs? \";\"\nasm_instr           ::= (\"int\" | IDENTIFIER) (\".\" IDENTIFIER)\nasm_expr            ::= CT_IDENT | CT_CONST_IDENT | \"&\"? IDENTIFIER | CONST_IDENT | FLOAT_LITERAL\n                        | INTEGER | \"(\" expr \")\" | \"[\" asm_addr \"]\"\nasm_addr            ::= asm_expr (additive_op asm_expr asm_addr_trail?)?\nasm_addr_trail      ::= \"*\" INTEGER (additive_op INTEGER)? | (shift_op | additive_op) INTEGER\n```\n\n----------------------------------------\n\nTITLE: Memory Tracking Utilities in C3\nDESCRIPTION: Utility for tracking memory allocations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_57\n\nLANGUAGE: c3\nCODE:\n```\nmacro TrackingEnv* get_tracking_env()\n```\n\n----------------------------------------\n\nTITLE: Enum Elements Count in C3\nDESCRIPTION: Demonstrates getting the number of elements in an enum using the elements property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nenum FooEnum\n{\n    BAR,\n    BAZ\n}\nint x = FooEnum.elements; // 2\n```\n\n----------------------------------------\n\nTITLE: Cleaning a C3 Project\nDESCRIPTION: Remove all build artifacts from a C3 project to ensure a clean state for future builds.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nc3c clean\n```\n\n----------------------------------------\n\nTITLE: I/O Utility Functions in C3\nDESCRIPTION: General I/O utility functions including stream operations, printing, reading, and writing with various formats and destinations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_53\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? available(InStream s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char[]? bprintf(char[] buffer, String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? copy_to(InStream in, OutStream dst, char[] buffer = {})\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void eprint(x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? eprintf(String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? eprintfn(String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void eprintn(x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? fprint(out, x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? fprintf(OutStream out, String format, args...)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? fprintfn(OutStream out, String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? fprintn(out, x = \"\")\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void print(x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? printf(String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? printfn(String format, args...) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void printn(x = \"\")\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? read_all(stream, char[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? read_any(stream, any ref)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? read_varint(stream, x_ptr)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String? readline(stream = io::stdin(), Allocator allocator = allocator::heap())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String? treadline(stream = io::stdin())\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? write_all(stream, char[] buffer)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? write_any(stream, any ref)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro usz? write_varint(stream, x)\n```\n\n----------------------------------------\n\nTITLE: Assignment Expression Grammar\nDESCRIPTION: Defines the grammar for assignment expressions in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_12\n\nLANGUAGE: text\nCODE:\n```\nassignment_expr    ::= ct_type_assign | unary_expr assignment_op expr\nct_type_assign     ::= ct_type_ident \"=\" type\nassignment_op      ::= \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\" | \"<<=\" | \">>=\" | \"&=\" | \"^=\" | \"|=\"\n```\n\n----------------------------------------\n\nTITLE: Converting String to UTF-16 in C3\nDESCRIPTION: Function to convert a String to a new UTF-16 encoded Char16 array using a specified allocator or the heap allocator by default.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]! String.to_new_utf16(s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Unsigned Long Array Operations in C3\nDESCRIPTION: A set of macros for performing operations on unsigned long arrays, including logical operations, comparisons, and arithmetic operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_67\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].and(ulong[<*>] x)\nmacro bool[<*>] ulong[<*>].comp_eq(ulong[<*>] x, ulong[<*>] y)\nmacro bool[<*>] ulong[<*>].comp_ge(ulong[<*>] x, ulong[<*>] y)\nmacro bool[<*>] ulong[<*>].comp_gt(ulong[<*>] x, ulong[<*>] y)\nmacro bool[<*>] ulong[<*>].comp_le(ulong[<*>] x, ulong[<*>] y)\nmacro bool[<*>] ulong[<*>].comp_lt(ulong[<*>] x, ulong[<*>] y)\nmacro bool[<*>] ulong[<*>].comp_ne(ulong[<*>] x, ulong[<*>] y)\nmacro ulong ulong[<*>].max(ulong[<*>] x)\nmacro ulong ulong[<*>].min(ulong[<*>] x)\nmacro ulong ulong[<*>].or(ulong[<*>] x)\nmacro ulong ulong[<*>].product(ulong[<*>] x)\nmacro ulong ulong[<*>].sum(ulong[<*>] x)\nmacro ulong ulong[<*>].xor(ulong[<*>] x)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Switch Statement in C3\nDESCRIPTION: Shows how to use $switch for multiple conditional branches at compile time.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/compiletime.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nmacro @foo($x, #y)\n{\n    $switch $x:\n        $case 1:\n            #y += $x * $x;\n        $case 2:\n            #y += $x;\n        $case 3:\n            #y *= $x;\n        $default:\n            #y -= $x;\n    $endswitch\n}\n```\n\n----------------------------------------\n\nTITLE: Using asm string for inline assembly in C3\nDESCRIPTION: This snippet demonstrates how to use an asm string to insert a single assembly instruction directly into C3 code. The assembly instruction is passed as a compile-time string without any modifications.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/asm.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint x = 0;\nasm(\"nop\");\nint y = x;\n```\n\n----------------------------------------\n\nTITLE: Windows-specific directory operations in C3\nDESCRIPTION: Windows-specific implementations of directory listing and recursive directory removal operations. These functions are only available when the WIN32 environment flag is set.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_61\n\nLANGUAGE: c3\nCODE:\n```\nfn PathList? native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_rmtree(Path path)\n```\n\n----------------------------------------\n\nTITLE: Variable Scoping in C3\nDESCRIPTION: Example of using @scope to create a local scope for variable modifications.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nint a = 3;\n\n@scope(a)\n{\n    a = 4;\n    a++;\n};\n\n// Prints a = 3\nio::printfn(\"a = %d\", a, b);\n```\n\n----------------------------------------\n\nTITLE: Path Manipulation and Operations\nDESCRIPTION: Comprehensive set of path manipulation functions including path creation, modification, inspection, and filesystem operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_67\n\nLANGUAGE: c3\nCODE:\n```\nenum MkdirPermissions\nenum PathEnv\nfault PathResult\nstruct Path (Printable)\nfn Path! Path.absolute(self, Allocator allocator = allocator::heap())\nfn Path! Path.append(self, String filename, Allocator allocator = allocator::heap())\nfn ZString Path.as_zstr(self)\nfn String Path.basename(self)\nfn String Path.dirname(self)\nfn bool Path.equals(self, Path p2)\nfn String! Path.extension(self)\nfn void Path.free(self)\nfn bool Path.has_suffix(self, String str)\nfn bool! Path.is_absolute(self)\nfn Path! Path.parent(self)\nfn String Path.root_directory(self)\nfn String Path.str_view(self) @inline\nfn Path! Path.tappend(self, String filename)\nfn usz! Path.to_format(&self, Formatter* formatter) @dynamic\nfn String Path.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\nfn String Path.volume_name(self)\nfn bool! Path.walk(self, PathWalker w, void* data)\nfn void! chdir(Path path)\nfn void! delete(Path path)\nfn bool exists(Path path)\nfn usz! file_size(Path path)\nfn Path! getcwd(Allocator allocator = allocator::heap())\nfn bool is_dir(Path path)\nfn bool is_file(Path path)\nmacro bool is_posix_separator(char c)\nmacro bool is_reserved_path_char(char c, PathEnv path_env = DEFAULT_PATH_ENV)\nmacro bool is_reserved_win32_path_char(char c)\nmacro bool is_separator(char c, PathEnv path_env = DEFAULT_PATH_ENV)\nmacro bool is_win32_separator(char c)\nfn PathList! ls(Path dir, bool no_dirs = false, bool no_symlinks = false, String mask = \"\", Allocator allocator = allocator::heap())\nfn bool! mkdir(Path path, bool recursive = false, MkdirPermissions permissions = NORMAL)\nfn Path! new(String path, Allocator allocator = allocator::heap(), PathEnv path_env = DEFAULT_PATH_ENV)\nfn Path! new_posix(String path, Allocator allocator = allocator::heap())\nfn Path! new_win32_wstring(WString path, Allocator allocator = allocator::heap())\nfn Path! new_windows(String path, Allocator allocator = allocator::heap())\nfn String! normalize(String path_str, PathEnv path_env = DEFAULT_PATH_ENV)\nfn bool! rmdir(Path path)\nfn void! rmtree(Path path)\nfn Path! temp_directory(Allocator allocator = allocator::heap())\nfn Path! temp_new(String path, PathEnv path_env = DEFAULT_PATH_ENV)\nfn Path! tgetcwd()\n```\n\n----------------------------------------\n\nTITLE: Windows Threading Interface in C3\nDESCRIPTION: Function and type declarations for Windows-specific threading and synchronization primitives in C3. Provides similar functionality to the POSIX version but with Windows-specific implementation details.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_107\n\nLANGUAGE: c3\nCODE:\n```\ndistinct NativeThread = inline Win32_HANDLE;\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct NativeConditionVariable\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct NativeMutex\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct NativeOnceFlag\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.broadcast(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.destroy(&cond) @maydiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.init(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.signal(&cond)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.wait(&cond, NativeMutex* mtx) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeConditionVariable.wait_timeout(&cond, NativeMutex* mtx, uint time) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.destroy(&mtx)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.init(&mtx, MutexType type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.lock(&mtx)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.lock_timeout(&mtx, usz ms)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool NativeMutex.try_lock(&mtx)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeMutex.unlock(&mtx)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void NativeOnceFlag.call_once(&flag, OnceFn func)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeThread.create(&thread, ThreadFn func, void* args)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! NativeThread.detach(thread) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool NativeThread.equals(thread, NativeThread other)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! NativeThread.join(thread)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void! native_sleep_nano(NanoDuration ns)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn NativeThread native_thread_current()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void native_thread_exit(int result) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void native_thread_yield()\n```\n\n----------------------------------------\n\nTITLE: Building the C3 Compiler with Make\nDESCRIPTION: Command to build the C3 compiler using make after CMake configuration. This compiles the source code into an executable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ make\n```\n\n----------------------------------------\n\nTITLE: Global Constants Definition in C3\nDESCRIPTION: Illustrates the naming convention for global constants which must start with A-Z after any optional '_'.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Fundamentals/naming.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nconst int A_VALUE = 12;\n```\n\n----------------------------------------\n\nTITLE: String to Long Integer Conversion in C3\nDESCRIPTION: Converts a String to a long integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\nfn long? String.to_long(s, int base = 10) => s.to_integer(long, base);\n```\n\n----------------------------------------\n\nTITLE: C3 Preprocessor Directives\nDESCRIPTION: Special preprocessor directives and compile-time operations in C3, prefixed with $\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n$alignof    $assert     $case       $default\n$defined    $echo       $embed      $exec\n$else       $endfor     $endforeach $endif\n$endswitch  $eval       $evaltype   $error\n$extnameof  $for        $foreach    $if\n$include    $nameof     $offsetof   $qnameof\n$sizeof     $stringify  $switch     $typefrom\n$typeof     $vacount    $vatype     $vaconst\n$vaarg      $vaexpr     $vasplat\n```\n\n----------------------------------------\n\nTITLE: Darwin (macOS) Time Functions in C3\nDESCRIPTION: Darwin-specific time functions for macOS platforms. Includes the macOS-specific structs and native clock implementation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_112\n\nLANGUAGE: c3\nCODE:\n```\nstruct Darwin_mach_timebase_info\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Clock native_clock()\n```\n\n----------------------------------------\n\nTITLE: Configuring C3 Compiler Build with CMake\nDESCRIPTION: Command to use CMake for configuring the C3 compiler build process. This sets up the build environment based on the CMakeLists in the parent directory.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ cmake ../\n```\n\n----------------------------------------\n\nTITLE: Optimized C3 Code for Release Build\nDESCRIPTION: This snippet demonstrates how the compiler may optimize the previous code in a release build, assuming that x cannot be zero to avoid undefined behaviour.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Rules/undefined-behaviour.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfoo();\nreturn true;\n```\n\n----------------------------------------\n\nTITLE: Optimized Release Build Code in C3\nDESCRIPTION: Shows how the compiler may optimize the previous code in release builds, assuming undefined behavior cannot occur.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/undefined-behaviour.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfoo();\nreturn true;\n```\n\n----------------------------------------\n\nTITLE: Native file operations in C3 with NO_LIBC environment setting\nDESCRIPTION: A collection of native file operations for C3 when the NO_LIBC environment flag is set. These functions provide basic file I/O capabilities including opening, reading, writing, seeking, and removing files.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_59\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? native_fopen(String filename, String mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_fread(CFile file, char[] buffer) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void*? native_freopen(void* file, String filename, String mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_fseek(void* file, isz offset, Seek seek_mode) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_ftell(CFile file) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? native_fwrite(CFile file, char[] buffer) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void? native_remove(String filename) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Path? native_temp_directory(Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Finding Index of Character from Start Index in String in C3\nDESCRIPTION: Function to find the index of a specified character in a string, starting from a given index.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! String.index_of_char_from(s, char needle, usz start_index);\n```\n\n----------------------------------------\n\nTITLE: Copying Data from Any Type in C3\nDESCRIPTION: Shows how to create a copy of data stored in an 'any' type using memory allocation and copying.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Generic Programming/anyinterfaces.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nvoid* data = malloc(a.type.sizeof);\nmem::copy(data, a.ptr, a.type.sizeof);\nany any_copy = any_make(data, a.type);\n```\n\n----------------------------------------\n\nTITLE: Asm block grammar example in C3\nDESCRIPTION: This snippet shows the general grammar structure for asm blocks in C3. It illustrates the format for assembly instructions and arguments within an asm block.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Misc Advanced/asm.md#2025-04-21_snippet_1\n\nLANGUAGE: asm\nCODE:\n```\ninstruction (arg (',' arg)*)?;\n```\n\n----------------------------------------\n\nTITLE: String to New UTF-16 Conversion in C3\nDESCRIPTION: Converts a String to a new UTF-16 encoded Char16 array using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_39\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]? String.to_new_utf16(s, Allocator allocator = allocator::heap());\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Number Generation in C3\nDESCRIPTION: Functions for generating random numbers using different algorithms (Sfc32, Sfc64, Sfc8, SimpleRandom). These functions generate various types of random values including integers, longs, shorts, and bytes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_92\n\nLANGUAGE: c3\nCODE:\n```\nfn uint Sfc32Random.next_int(&sfc) @dynamic\n\nfn uint128 Sfc32Random.next_int128(&self) @dynamic\n\nfn ulong Sfc32Random.next_long(&self) @dynamic\n\nfn ushort Sfc32Random.next_short(&self) @dynamic\n\nfn char Sfc64Random.next_byte(&self) @dynamic\n\nfn void Sfc64Random.next_bytes(&self, char[] bytes) @dynamic\n\nfn uint Sfc64Random.next_int(&self) @dynamic\n\nfn uint128 Sfc64Random.next_int128(&self) @dynamic\n\nfn ulong Sfc64Random.next_long(&self) @dynamic\n\nfn ushort Sfc64Random.next_short(&self) @dynamic\n\nfn char Sfc8Random.next_byte(&self) @dynamic\n\nfn void Sfc8Random.next_bytes(&self, char[] bytes) @dynamic\n\nfn uint Sfc8Random.next_int(&self) @dynamic\n\nfn uint128 Sfc8Random.next_int128(&self) @dynamic\n\nfn ulong Sfc8Random.next_long(&self) @dynamic\n\nfn ushort Sfc8Random.next_short(&self) @dynamic\n\nfn char SimpleRandom.next_byte(&self) @dynamic\n\nfn void SimpleRandom.next_bytes(&self, char[] bytes) @dynamic\n\nfn uint SimpleRandom.next_int(&self) @dynamic\n\nfn uint128 SimpleRandom.next_int128(&self) @dynamic\n\nfn ulong SimpleRandom.next_long(&self) @dynamic\n\nfn ushort SimpleRandom.next_short(&self) @dynamic\n\nfn void SimpleRandom.set_seed(&self, char[] seed) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Darwin/macOS Specific Implementation\nDESCRIPTION: Implementations specific to Darwin/macOS including Core Foundation and Objective-C bindings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_101\n\nLANGUAGE: c3\nCODE:\n```\nstruct Darwin_Dl_info\nstruct Darwin_segment_command_64\nfn String! executable_path(Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Building Release Version of C3 Compiler with Docker\nDESCRIPTION: Command to build a release version of the C3 compiler using Docker with Ubuntu 20.04. This creates an optimized executable for production use.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./build-with-docker.sh 20 Release\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for a C3 Project\nDESCRIPTION: Command to rebuild the documentation for a C3 project target. Note: this feature is not fully implemented yet.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nc3c docs [target]\n```\n\n----------------------------------------\n\nTITLE: Manual Installation of C3 Compiler on Arch Linux\nDESCRIPTION: Commands for manually cloning and installing the C3 compiler from AUR on Arch Linux using makepkg.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://aur.archlinux.org/c3c-git.git\ncd c3c-git\nmakepkg -si\n```\n\n----------------------------------------\n\nTITLE: Displaying Download Note in Markdown\nDESCRIPTION: This snippet uses Markdown syntax to create a note block encouraging users to download C3, with a link to the download page.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/roadmap.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n:::note[Want To Download C3?]\n[Download C3](/getting-started/prebuilt-binaries/), available on Mac, Windows and Linux.\n:::\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pure Function Annotation Limitations in C3\nDESCRIPTION: Illustrates a case where the compiler might not detect incorrect usage of the @pure annotation, potentially leading to unexpected behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nint i = 0;\n\ndef SecretFn = fn void();\n\nfn void bad_func()\n{\n    i = 2;\n}\n\n<*\n @pure\n*>\nfn void lying_func(SecretFn f)\n{\n    f(); // The compiler cannot reason about this!\n}\n\nfn void main()\n{\n    i = 1;\n    lying_func(&bad_func);\n    io::printf(\"%d\", i); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: Checking String Starts With Substring in C3\nDESCRIPTION: Function to check if a string starts with a specified needle string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.starts_with(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Stripping End of String in C3\nDESCRIPTION: Function to remove a specified needle string from the end of a given string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.strip_end(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Clock Handling Functions in C3\nDESCRIPTION: Functions for handling high-precision clocks in C3, including marking time points and measuring elapsed time.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_110\n\nLANGUAGE: c3\nCODE:\n```\nfn NanoDuration Clock.mark(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn NanoDuration Clock.to_now(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Clock now()\n```\n\n----------------------------------------\n\nTITLE: Local Visibility in C3\nDESCRIPTION: This snippet demonstrates how to declare a function with local visibility using the `@local` attribute. Local functions are only accessible within the file they are defined in.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\n// File foo.c3\nmodule foo;\nfn void abc() @private { }\nfn void de() @local { }\n\n// File foo2.c3\nmodule foo;\nfn void test()\n{\n    abc(); // Access of private in the same module is ok\n    // de(); <- Error: function is local to foo.c3\n}\n```\n\n----------------------------------------\n\nTITLE: Compiling and Running C3 Files\nDESCRIPTION: Command to compile C3 source files and immediately run the resulting executable. Useful for small programs or testing code snippets quickly.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Build Your Project/build-commands.mdx#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nc3c compile-run <file1> <file2> <file3>\n```\n\n----------------------------------------\n\nTITLE: Displaying Project Structure in Markdown\nDESCRIPTION: Shows the directory structure of the C3-Web project using ASCII tree representation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n```\n📦c3\n ┣ 📂public\n ┣ 📂src\n ┃ ┣ 📂components\n ┃ ┣ 📂content\n ┃ ┃ ┣ 📂docs\n ┃ ┃ ┃ ┗ 📂guide\n ┃ ┃ ┗ 📜config.js\n ┃ ┣ 📂pages\n ┃ ┃ ┗ 📜index.astro\n ┃ ┗ 📜env.d.ts\n ┣ 📜.gitignore\n ┣ 📜astro.config.mjs\n ┣ 📜package.json\n ┣ 📜tailwind.config.cjs\n ┗ 📜tsconfig.json\n```\n```\n\n----------------------------------------\n\nTITLE: Managing Temporary Allocations Across Scopes in C3\nDESCRIPTION: Shows how to retain a temporary allocation beyond its pool scope by using an external temporary allocator reference, allowing objects to survive after the pool is cleaned up.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\n// Store the temp allocator\nAllocator temp = allocator::temp();\n@pool(temp)\n{\n    // Note, 'allocator::temp() != temp' here!\n    void* some_mem = tmalloc(128);\n    // Allocate this on the external temp allocator\n    Foo* foo = allocator::new(temp, Foo);\n    foo.z = foo(some_mem);\n    // Now \"some_mem\" will be released,\n    // but the memory pointed to by \"foo\" is still valid.\n    return foo;\n};\n```\n\n----------------------------------------\n\nTITLE: Value Cloning in C3\nDESCRIPTION: Demonstrates shallow copying of values using @clone.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_12\n\nLANGUAGE: c3\nCODE:\n```\nFoo f = ...\n\nreturn @clone(f);\n```\n\n----------------------------------------\n\nTITLE: DString Temporary String Operations in C3\nDESCRIPTION: Functions for working with temporary DStrings allocated from the temp allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_42\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.tcopy(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String DString.tcopy_str(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.temp_concat(self, DString b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString DString.temp_init(&self, usz capacity = MIN_CAPACITY)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString temp_new(String s = \"\")\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DString temp_with_capacity(usz capacity)\n```\n\n----------------------------------------\n\nTITLE: Creating Build Directory for C3 Compiler\nDESCRIPTION: Commands to create and navigate to a build directory for the C3 compiler. This isolates build artifacts from the source code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c$ mkdir build\nMyMachine:c3c$ cd build/\n```\n\n----------------------------------------\n\nTITLE: Linux-specific OS Functions (C3)\nDESCRIPTION: Structures and functions specific to Linux operating systems, including ELF header definitions and backtrace symbolization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_104\n\nLANGUAGE: c3\nCODE:\n```\nstruct Elf32_Ehdr\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Elf32_Phdr\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Elf64_Ehdr\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Elf64_Phdr\n```\n\nLANGUAGE: c3\nCODE:\n```\nstruct Linux_Dl_info\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn BacktraceList? symbolize_backtrace(void*[] backtrace, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Volatile Memory Operations in C3\nDESCRIPTION: Demonstrates volatile load and store operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/index.mdx#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n// Both loads will always happen:\nint y = @volatile_load(my_global);\ny = @volatile_load(my_global);\n```\n\nLANGUAGE: c3\nCODE:\n```\n// Both stores will always happen:\n@volatile_store(y, 1);\n@volatile_store(y, 1);\n```\n\n----------------------------------------\n\nTITLE: Nextcase Statement Syntax\nDESCRIPTION: Defines the syntax for the `nextcase` statement, which allows jumping to another `switch` case. It includes optional labels and expressions to specify the target case.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\n\nnextcase_stmt      ::= \"nextcase\" ((label \":\")? (expr | \"default\"))? \";\"\n\n```\n\n----------------------------------------\n\nTITLE: Printing Values to Stdout in C3\nDESCRIPTION: This snippet demonstrates printing different types of values, including integers, floats, enums, and arrays, to stdout using the io::print function in the C3 language. It illustrates the flexibility of the print function with different data types for debugging purposes and appends a newline with printn.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/index.mdx#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nenum Heat \n{\n    WARM,\n    WARMER,\n    REALLY_WARM,\n}\n\nfn void main() \n{\n    int[<2>] vec = { 4, 2 };\n    Heat weather = WARM;\n    int[5] fib = { 0, 1, 1, 2, 3 };\n    String dialogue = \"secret\";\n\n    io::print(\"Hello\");   // Hello\n    io::print(20);        // 20\n    io::print(2.2);       // 2.200000\n    io::print(vec);       // [<4, 2>]\n    io::print(weather);   // WARM\n    io::print(fib);       // [0, 1, 1, 2, 3] \n    io::print(dialogue);  // secret\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Main Function for C3 Parser in C\nDESCRIPTION: This is the main entry point for the C3 parser. It calls yyparse() to start the parsing process and returns 0 upon completion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/grammar.md#2025-04-21_snippet_23\n\nLANGUAGE: C\nCODE:\n```\nint main(int argc, char *argv[])\n{\n\tyyparse();\n\treturn 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Logical Or Expression Syntax in C3\nDESCRIPTION: Defines the syntax for logical OR expressions with short-circuit evaluation\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Implementation Details/specification.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nor_group_expr      ::= and_group_expr | or_expr\nor_expr            ::= or_group_expr \"||\" and_group_expr\n```\n\n----------------------------------------\n\nTITLE: Backslash Escape Sequences\nDESCRIPTION: Lists the available backslash escape sequences for characters and string literals in C3, along with their corresponding hexadecimal values and meanings. Includes escapes for zero value, alert/bell, backspace, escape, form feed, newline, carriage return, horizontal tab, vertical tab, backslash, single quote, double quote, and hexadecimal/unicode character representations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_9\n\nLANGUAGE: text\nCODE:\n```\n\"\\0      0x00 zero value\n\\a      0x07 alert/bell\n\\b      0x08 backspace\n\\e      0x1B escape\n\\f      0x0C form feed\n\\n      0x0A newline\n\\r      0x0D carriage return\n\\t      0x09 horizontal tab\n\\v      0x0B vertical tab\n\\\\      0x5C backslash\n\\'      0x27 single quote '\n\\\"      0x22 double quote \"\n\\x      Escapes a single byte hex value\n\\u      Escapes a two byte unicode hex value \n\\U      Escapes a four byte unicode hex value\n\"\n```\n\n----------------------------------------\n\nTITLE: Path-Shortening in C3 Imports\nDESCRIPTION: A differential example showing how C3 allows shortening module paths. Instead of using the full path, you can use just the lowest level module name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/hello-world.md#2025-04-21_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n- std::io::printn(\"Hello, World!\");\n+ io::printn(\"Hello, World!\");\n\n```\n\n----------------------------------------\n\nTITLE: Implementing PrivatePriorityQueue in C3\nDESCRIPTION: Defines the PrivatePriorityQueue structure and its methods for managing a priority queue.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nstruct PrivatePriorityQueue (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type? PrivatePriorityQueue.first(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type PrivatePriorityQueue.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool PrivatePriorityQueue.is_empty(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz PrivatePriorityQueue.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap()) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type? PrivatePriorityQueue.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.push(&self, Type element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.temp_init(&self, usz initial_capacity = 16) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz? PrivatePriorityQueue.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String PrivatePriorityQueue.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\n----------------------------------------\n\nTITLE: File Reading with Optional Error Handling in C3\nDESCRIPTION: Illustrates a file reading function that returns an Optional result. It demonstrates error handling, rethrow operator usage, and scope-based resource management.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n<*\n Function modifies 'buffer'\n Returns an Optional with a 'char[]' result \n OR an empty Optional with an Excuse\n*>\nfn char[]! read_file(String filename, char[] buffer)\n{\n    // Return Excuse if opening a file failed, using Rethrow `!`\n    File file = file::open(filename, \"r\")!; \n\n    // At scope exit, close the file.\n    // Discard the Excuse from file.close() with (void) cast\n    defer (void)file.close(); \n\n    // Return Excuse if reading failed, using Rethrow `!`\n    file.read(buffer)!; \n    return buffer; // return a buffer result\n}\n\nfn void! test_read()\n{\n    char[] buffer = mem::new_array(char, 100);\n    defer free(buffer); // Free memory on scope exit\n\n    char[]! read_buffer = read_file(\"file_to_open.txt\", buffer);\n    // Catch the empty Optional and assign the Excuse \n    // to `excuse`\n    if (catch excuse = read_buffer) \n    {\n        io::printfn(\"Excuse found: %s\", excuse);\n        // Returning Excuse using the `?` suffix\n        return excuse?;\n    }\n\n    // `read_buffer` behaves like a normal variable here \n    // because the Optional being empty was handled by 'if (catch)'\n    // which automatically unwrapped 'read_buffer' at this point.\n    io::printfn(\"read_buffer: %s\", read_buffer);\n}\n\nfn void main()\n{\n    test_read()!!; // Panic on failure.\n}\n```\n\n----------------------------------------\n\nTITLE: Environment Enumerations in C3\nDESCRIPTION: Enumerations for detecting and working with different system environments.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_45\n\nLANGUAGE: c3\nCODE:\n```\nenum ArchType\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum CompilerOptLevel\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum MemoryEnvironment\n```\n\nLANGUAGE: c3\nCODE:\n```\nenum OsType\n```\n\n----------------------------------------\n\nTITLE: Socket and Poll Operations in C3\nDESCRIPTION: Functions and structures for socket operations and polling. These include socket options, reading and writing to sockets, and poll-based I/O operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_96\n\nLANGUAGE: c3\nCODE:\n```\ndistinct PollEvents = ushort;\n\ndistinct PollSubscribes = ushort;\n\nenum SocketOption : char (CInt value)\n\nstruct Poll\n\nstruct Socket (InStream, OutStream)\n\nmacro void @loop_over_ai(AddrInfo* ai; @body(NativeSocket fd, AddrInfo* ai))\n\nfn void! Socket.close(&self) @inline @dynamic\n\nfn void! Socket.destroy(&self) @dynamic\n\nfn bool! Socket.get_broadcast(&self)\n\nfn bool! Socket.get_dontroute(&self)\n\nfn bool! Socket.get_keepalive(&self)\n\nfn bool! Socket.get_oobinline(&self)\n\nfn bool! Socket.get_option(&self, SocketOption option)\n\nfn bool! Socket.get_reuseaddr(&self)\n\nfn usz! Socket.read(&self, char[] bytes) @dynamic\n\nfn char! Socket.read_byte(&self) @dynamic\n\nfn void! Socket.set_broadcast(&self, bool value)\n\nfn void! Socket.set_dontroute(&self, bool value)\n\nfn void! Socket.set_keepalive(&self, bool value)\n\nfn void! Socket.set_oobinline(&self, bool value)\n\nfn void! Socket.set_option(&self, SocketOption option, bool value)\n\nfn void! Socket.set_reuseaddr(&self, bool value)\n\nfn usz! Socket.write(&self, char[] bytes) @dynamic\n\nfn void! Socket.write_byte(&self, char byte) @dynamic\n\nmacro Socket new_socket(fd, ai)\n\nfn ulong! poll(Poll[] polls, Duration timeout)\n\nfn ulong! poll_ms(Poll[] polls, long timeout_ms)\n```\n\n----------------------------------------\n\nTITLE: TCP and UDP Socket Operations in C3\nDESCRIPTION: Functions for TCP and UDP socket operations, including server socket creation, client connections, and async operations. These provide high-level abstractions for network programming in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_98\n\nLANGUAGE: c3\nCODE:\n```\ndistinct TcpServerSocket = inline Socket;\n\ndistinct TcpSocket = inline Socket;\n\nfn TcpSocket! accept(TcpServerSocket* server_socket)\n\nfn TcpSocket! connect(String host, uint port, Duration timeout = 0, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n\nfn TcpSocket! connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n\nfn TcpSocket! connect_async_to(AddrInfo* ai, SocketOption... options)\n\nfn TcpSocket! connect_to(AddrInfo* ai, SocketOption... options)\n\nfn TcpServerSocket! listen(String host, uint port, uint backlog, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n\nfn TcpServerSocket! listen_to(AddrInfo* ai, uint backlog, SocketOption... options)\n\ndistinct UdpSocket = inline Socket;\n\nfn UdpSocket! connect(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n\nfn UdpSocket! connect_async(String host, uint port, SocketOption... options, IpProtocol ip_protocol = UNSPECIFIED)\n\nfn UdpSocket! connect_async_to(AddrInfo* ai, SocketOption... options)\n\nfn UdpSocket! connect_to(AddrInfo* ai, SocketOption... options)\n```\n\n----------------------------------------\n\nTITLE: Normalizing a Quaternion in C3\nDESCRIPTION: A macro function that normalizes a quaternion to unit length and returns the normalized quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_80\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.normalize(Quaternion q)\n```\n\n----------------------------------------\n\nTITLE: Building C3 Compiler with Docker on Ubuntu\nDESCRIPTION: Command to build the C3 compiler using a Docker container with Ubuntu 18.04. This provides a consistent build environment regardless of the host system.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Getting Started/compile.md#2025-04-21_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./build-with-docker.sh 18\n```\n\n----------------------------------------\n\nTITLE: Executing External Programs with $exec in C3\nDESCRIPTION: This snippet demonstrates the `$exec` feature in C3, which allows including the output of an external program (in this case, `echo`) as part of the C3 code.  The `echo` command is used to insert a string literal into the code, which is then printed by the `main` function.  This feature requires full trust level enabled via `--trust=full`.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\n// On Linux or MacOS this will insert 'String a = \\\"Hello world!\\\";'\n$exec(\"echo\", { \"String a = \\\"Hello world!\\\"\\;\" });\n\nfn void main()\n{\n\tio::printn(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Bit Manipulation Macros in C3 Language\nDESCRIPTION: This set of code snippets defines various macros for handling bit-level operations like counting leading/trailing zeros, rotating, and shifting bits for different data types such as char, int, long, etc. These macros assist in low-level data manipulation tasks, crucial for optimization and performance enhancement in applications requiring precise control over data arrangements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_4\n\nLANGUAGE: C3\nCODE:\n```\nmacro bswap(i) @builtin\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char char.fshl(hi, char lo, char shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char char.fshr(hi, char lo, char shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char char.rotl(self, char shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char char.rotr(self, char shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>] char[<*>].fshl(hi, char[<*>] lo, char[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>] char[<*>].fshr(hi, char[<*>] lo, char[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>] char[<*>].rotl(self, char[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro char[<*>] char[<*>].rotr(self, char[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar ichar.fshl(hi, ichar lo, ichar shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar ichar.fshr(hi, ichar lo, ichar shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar ichar.rotl(self, ichar shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar ichar.rotr(self, ichar shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].fshl(hi, ichar[<*>] lo, ichar[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].fshr(hi, ichar[<*>] lo, ichar[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].rotl(self, ichar[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ichar[<*>] ichar[<*>].rotr(self, ichar[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int int.fshl(hi, int lo, int shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int int.fshr(hi, int lo, int shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int int.rotl(self, int shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int int.rotr(self, int shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128 int128.fshl(hi, int128 lo, int128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128 int128.fshr(hi, int128 lo, int128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128 int128.rotl(self, int128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128 int128.rotr(self, int128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>] int128[<*>].fshl(hi, int128[<*>] lo, int128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>] int128[<*>].fshr(hi, int128[<*>] lo, int128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>] int128[<*>].rotl(self, int128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int128[<*>] int128[<*>].rotr(self, int128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>] int[<*>].fshl(hi, int[<*>] lo, int[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>] int[<*>].fshr(hi, int[<*>] lo, int[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>] int[<*>].rotl(self, int[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro int[<*>] int[<*>].rotr(self, int[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long long.fshl(hi, long lo, long shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long long.fshr(hi, long lo, long shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long long.rotl(self, long shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long long.rotr(self, long shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>] long[<*>].fshl(hi, long[<*>] lo, long[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>] long[<*>].fshr(hi, long[<*>] lo, long[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>] long[<*>].rotl(self, long[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro long[<*>] long[<*>].rotr(self, long[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro reverse(i)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short short.fshl(hi, short lo, short shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short short.fshr(hi, short lo, short shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short short.rotl(self, short shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short short.rotr(self, short shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>] short[<*>].fshl(hi, short[<*>] lo, short[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>] short[<*>].fshr(hi, short[<*>] lo, short[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>] short[<*>].rotl(self, short[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro short[<*>] short[<*>].rotr(self, short[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint uint.fshl(hi, uint lo, uint shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint uint.fshr(hi, uint lo, uint shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint uint.rotl(self, uint shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint uint.rotr(self, uint shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128 uint128.fshl(hi, uint128 lo, uint128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128 uint128.fshr(hi, uint128 lo, uint128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128 uint128.rotl(self, uint128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128 uint128.rotr(self, uint128 shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].fshl(hi, uint128[<*>] lo, uint128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].fshr(hi, uint128[<*>] lo, uint128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].rotl(self, uint128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint128[<*>] uint128[<*>].rotr(self, uint128[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>] uint[<*>].fshl(hi, uint[<*>] lo, uint[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>] uint[<*>].fshr(hi, uint[<*>] lo, uint[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>] uint[<*>].rotl(self, uint[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro uint[<*>] uint[<*>].rotr(self, uint[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong ulong.fshl(hi, ulong lo, ulong shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong ulong.fshr(hi, ulong lo, ulong shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong ulong.rotl(self, ulong shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong ulong.rotr(self, ulong shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].fshl(hi, ulong[<*>] lo, ulong[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].fshr(hi, ulong[<*>] lo, ulong[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].rotl(self, ulong[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ulong[<*>] ulong[<*>].rotr(self, ulong[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort.clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort.ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort ushort.fshl(hi, ushort lo, ushort shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort ushort.fshr(hi, ushort lo, ushort shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort.popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort ushort.rotl(self, ushort shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort ushort.rotr(self, ushort shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>].clz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>].ctz(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].fshl(hi, ushort[<*>] lo, ushort[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].fshr(hi, ushort[<*>] lo, ushort[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>].popcount(self)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].rotl(self, ushort[<*>] shift)\n```\n\nLANGUAGE: C3\nCODE:\n```\nmacro ushort[<*>] ushort[<*>].rotr(self, ushort[<*>] shift)\n```\n\n----------------------------------------\n\nTITLE: Module Definition for Non-Recursive Import Example\nDESCRIPTION: This snippet defines the `mylib` and `mylib::submod` modules used in the non-recursive import example. `mylib` contains the `only_want_this` function, while `mylib::submod` contains the `undesired_fn` function. This structure is designed to illustrate the effect of `@norecurse` in preventing the import of `undesired_fn`.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nmodule mylib;\nimport std::io;\nfn void only_want_this()\n{\n    io::printn(\"only_want_this\");\n}\n\nmodule mylib::submod;\nimport std::io;\nfn void undesired_fn()\n{\n    io::printn(\"undesired_fn\");\n}\n\nmodule my_code;\n// Using Non-recursive import undesired_fn not found\nimport mylib @norecurse; \n\n// Using Recursive import undesired_fn is found\n// import mylib;\n\nfn void main()\n{\n    mylib::only_want_this();\n    submod::undesired_fn(); // This should error\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Types in C3\nDESCRIPTION: This snippet defines a structure in C3, demonstrating the use of both named and anonymous sub-structures, sub-unions, and unions. It shows how to manage complex data encapsulation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\ndef Callback = fn int(char c);\n\nenum Status : int\n{\n    IDLE,\n    BUSY,\n    DONE,\n}\n\nstruct MyData\n{\n    char* name;\n    Callback open;\n    Callback close;\n    State status;\n\n    // named sub-structs (x.other.value)\n    struct other \n    {\n        int value;\n        int status;   // ok, no name clash with other status\n    }\n\n    // anonymous sub-structs (x.value)\n    struct \n    {\n        int value;\n        int status;   // error, name clash with other status in MyData\n    }\n\n    // anonymous union (x.person)\n    union \n    {\n        Person* person;\n        Company* company;\n    }\n\n    // named sub-unions (x.either.this)\n    union either \n    {\n        int this;\n        bool  or;\n        char* that;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: String Conversion Functions in C3\nDESCRIPTION: Provides functions for converting strings to various numeric types and between different string encodings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_60\n\nLANGUAGE: c3\nCODE:\n```\nfn double! String.to_double(s)\nfn float! String.to_float(s)\nfn ichar! String.to_ichar(s, int base = 10)\nfn int! String.to_int(s, int base = 10)\nfn int128! String.to_int128(s, int base = 10)\nfn long! String.to_long(s, int base = 10)\nfn Char16[]! String.to_new_utf16(s, Allocator allocator = allocator::heap())\nfn Char32[]! String.to_new_utf32(s, Allocator allocator = allocator::heap())\nfn WString! String.to_new_wstring(s, Allocator allocator = allocator::heap())\nfn short! String.to_short(s, int base = 10)\nfn Char16[]! String.to_temp_utf16(s)\nfn Char32[]! String.to_temp_utf32(s)\nfn WString! String.to_temp_wstring(s)\nfn char! String.to_uchar(s, int base = 10)\nfn uint! String.to_uint(s, int base = 10)\nfn uint128! String.to_uint128(s, int base = 10)\nfn ulong! String.to_ulong(s, int base = 10)\nfn ushort! String.to_ushort(s, int base = 10)\n```\n\n----------------------------------------\n\nTITLE: Defining and Using User-Defined Attributes in C3\nDESCRIPTION: This snippet demonstrates defining a user-defined attribute `@MyAttribute` that combines multiple built-in attributes. It shows how attributes in C3 can be used to add function-level configurations and optimizations. This is particularly useful under situations where multiple attributes are to be applied conditionally. The snippet also includes an example of an empty user-defined attribute which may be used for future flexibility.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/attributes.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\ndef @MyAttribute = { @noreturn @inline };\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo() @MyAttribute { /* */ }\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void foo() @noreturn @inline { /* */ }\n```\n\nLANGUAGE: c3\nCODE:\n```\ndef @MyAttributeEmpty = {};\n```\n\n----------------------------------------\n\nTITLE: Formatted Printing using io::printfn in C3\nDESCRIPTION: This snippet illustrates how to use the formatted printing function io::printfn to control the output format of different data types. It includes different format specifiers and demonstrates how to print the values in a formatted manner.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\nfn void main()\n{\n    int a = 1234;\n    ulong b = 0xFFAABBCCDDEEFF;\n    double d = 13.03e-04;\n    char[*] hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n    io::printfn(\"a was:                        %d\", a);\n    io::printfn(\"b in hex was:                 %x\", b);\n    io::printfn(\"d in scientific notation was: %e\", d);\n    io::printfn(\"Bytes as string:              %s\", (String)&hex);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Functions and Types From Other Modules in C3\nDESCRIPTION: This snippet illustrates how to use functions and types from other modules, including rules about namespace prefixes and ambiguity resolution.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\n// File a.c3\n\nmodule a;\n\nstruct Foo { ... }\nstruct Bar { ... }\nstruct TheAStruct { ... }\n\nfn void anAFunction() { ... }\n\n// File b.c3\n\nmodule b;\n\nstruct Foo { ... }\nstruct Bar { ... }\nstruct TheBStruct { ... }\n\nfn void aBFunction() { ... }\n\n// File c.c3\nmodule c;\nimport a, b;\n\nstruct TheCStruct { ... }\nstruct Bar { ... }\n\nfn void aCFunction() { ... }\n\nfn void test()\n{\n    TheAStruct stA;\n    TheBStruct stB;\n    TheCStruct stC;\n    // Name required to avoid ambiguity;\n    b::Foo stBFoo;\n    // Will always pick the current module's\n    // name.\n    Bar bar;\n    // Namespace required:\n    a::aAFunction();\n    b::aBFunction();\n    // A local symbol does not require it:\n    aCFunction();\n}\n```\n\n----------------------------------------\n\nTITLE: Enum with Multiple Associated Values in C3\nDESCRIPTION: This code snippet shows an example of associating multiple static values with enum values, including a struct. The example demonstrates accessing the struct fields associated with a specific enum value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct Position\n{\n    int x;\n    int y;\n}\n\nenum State : int (String desc, bool active, Position pos)\n{\n    WAITING    = { \"waiting\", false, { 1, 2} },\n    RUNNING    = { \"running\", true,  {12,22} },\n    TERMINATED = { \"ended\",   false, { 0, 0} },\n}\n\nfn void main()\n{\n    State process = State.RUNNING;\n    if (process.active)\n    {\n        io::printfn(\"Process is: %s\", process.desc);\n        io::printfn(\"Position x: %d\", process.pos.x);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Using Default Values with Optionals in C3\nDESCRIPTION: Shows how to use the '??' operator to provide default values when an Optional is empty. It compares a verbose approach with a more concise one.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-advanced.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn void test_bad() \n{\n    int regular_value;\n    int! optional_value = function_may_error();\n\n    // An empty Optional found in optional_value\n    if (catch optional_value) \n    {   \n        // Assign default result when empty.\n        regular_value = -1;\n    }\n\n    // A result was found in optional_value\n    if (try optional_value) \n    {\n        regular_value = optional_value;\n    }\n    io::printfn(\"The value was: %d\", regular_value);\n}\n\nfn void test_good() \n{\n    // Return '-1' when `foo_may_error()` is empty.\n    int regular_value = foo_may_error() ?? -1;\n\n    io::printfn(\"The value was: %d\", regular_value);\n}\n```\n\n----------------------------------------\n\nTITLE: OS-specific Network Operations in C3\nDESCRIPTION: OS-specific implementations for network operations, including socket handling for POSIX and Windows systems. These functions provide the low-level interface for network programming in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_97\n\nLANGUAGE: c3\nCODE:\n```\ndistinct AIFamily = CInt;\n\ndistinct AIFlags = CInt;\n\ndistinct AIProtocol = CInt;\n\ndistinct AISockType = CInt;\n\ndistinct SockAddrPtr = void*;\n\nstruct AddrInfo\n\ndistinct NativeSocket = inline Fd;\n\nstruct Posix_pollfd\n\nmacro void! NativeSocket.close(self)\n\nmacro bool NativeSocket.is_non_blocking(self)\n\nmacro void! NativeSocket.set_non_blocking(self, bool non_blocking)\n\nfn anyfault convert_error(Errno error)\n\nfn anyfault socket_error()\n\ndistinct NativeSocket = uptr;\n\nmacro void! NativeSocket.close(self)\n\nfn void! NativeSocket.set_non_blocking(self, bool non_blocking)\n\nfn anyfault convert_error(WSAError error)\n\nfn anyfault socket_error()\n```\n\n----------------------------------------\n\nTITLE: Defining Identifiers in C3 Language\nDESCRIPTION: EBNF production rules for different types of identifiers in C3, including regular identifiers, const identifiers, type identifiers, and compile-time identifiers. These rules define the structure and naming conventions for variables and types in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_4\n\nLANGUAGE: EBNF\nCODE:\n```\nIDENTIFIER      ::=  \"_\"* LC_LETTER ALPHANUM_US*\nCONST_IDENT     ::=  \"_\"* UC_LETTER UC_ALPHANUM_US*\nTYPE_IDENT      ::=  \"_\"* UC_LETTER UC_ALPHANUM_US* LC_LETTER ALPHANUM_US*\nCT_IDENT        ::=  \"$\" IDENTIFIER\nCT_CONST_IDENT  ::=  \"$\" CONST_IDENT\nCT_TYPE_IDENT   ::=  \"$\" TYPE_IDENT\nAT_TYPE_IDENT   ::=  \"@\" TYPE_IDENT\nPATH_SEGMENT    ::= \"_\"* LC_LETTER LC_ALPHANUM_US*\n```\n\n----------------------------------------\n\nTITLE: Examples of Valid and Invalid Integer Literals in C3\nDESCRIPTION: Examples demonstrating valid and invalid integer literal representations in C3. This includes decimal, octal, and hexadecimal notations, as well as the use of underscores for digit grouping.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_6\n\nLANGUAGE: C3\nCODE:\n```\n42\n4_2\n0_600\n0o600\n0O600           // second character is capital letter 'O'\n0xBadFace\n0xBad_Face\n0x_67_7a_2f_cc_40_c6\n170141183460469231731687303715884105727\n170_141183_460469_231731_687303_715884_105727\n\n0600            // Invalid, non zero decimal number may not start with 0 \n_42             // an identifier, not an integer literal\n42_             // invalid: _ must separate successive digits\n0_xBadFace      // invalid: _ must separate successive digits\n```\n\n----------------------------------------\n\nTITLE: Generic Stack Implementation in C3\nDESCRIPTION: Implements a generic stack data structure using C3's generic modules. The stack can hold elements of any type and provides push, pop, and empty operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nmodule stack(<Type>);\nstruct Stack\n{\n    usz capacity;\n    usz size;\n    Type* elems;\n}\n\n\nfn void Stack.push(Stack* this, Type element)\n{\n    if (this.capacity == this.size)\n    {\n        this.capacity = this.capacity ? this.capacity * 2 : 16;\n        this.elems = realloc(this.elems, Type.sizeof * this.capacity);\n    }\n    this.elems[this.size++] = element;\n}\n\nfn Type Stack.pop(Stack* this)\n{\n    assert(this.size > 0);\n    return this.elems[--this.size];\n}\n\nfn bool Stack.empty(Stack* this)\n{\n    return !this.size;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Methods in C3 with Struct Types\nDESCRIPTION: Demonstrates the syntax and usage of methods in C3 by associating functions with structs or enums. Methods enable logical organization of functions within type namespaces and facilitate OOP-style programming through dot syntax invocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/functions.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nstruct Point\n{\n    int x;\n    int y;\n}\n\nfn void Point.add(Point* p, int x) \n{\n    p.x += x;\n}\n\nfn void example() \n{\n    Point p = { 1, 2 };\n    p.add(10);\n    Point.add(&p, 10);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Listing C3 Built-in Attributes\nDESCRIPTION: This snippet enumerates all built-in attributes in C3, which are used to modify the behavior or properties of declarations, functions, or types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\n@align        @benchmark  @bigendian  @builtin\n@cdecl        @deprecated @dynamic    @export\n@extern       @extname    @inline     @interface\n@littleendian @local      @maydiscard @naked\n@nodiscard    @noinit     @noinline   @noreturn\n@nostrip      @obfuscate  @operator   @overlap\n@packed       @priority   @private    @public\n@pure         @reflect    @section    @stdcall\n@test         @unused     @used       @veccall\n@wasm         @weak       @winmain\n```\n\n----------------------------------------\n\nTITLE: Random Number Generator Method Declarations\nDESCRIPTION: Declares the core methods for each random number generator type including next_byte, next_bytes, next_int, next_long, next_short, and set_seed functions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_90\n\nLANGUAGE: c3\nCODE:\n```\nfn char Lcg128Random.next_byte(&self) @dynamic\nfn void Lcg128Random.next_bytes(&self, char[] bytes) @dynamic\nfn uint Lcg128Random.next_int(&self) @dynamic\nfn uint128 Lcg128Random.next_int128(&self) @dynamic\nfn ulong Lcg128Random.next_long(&self) @dynamic\nfn ushort Lcg128Random.next_short(&self) @dynamic\nfn void Lcg128Random.set_seed(&self, char[] input) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Listing C3 Reserved Keywords\nDESCRIPTION: This snippet enumerates all reserved keywords in the C3 programming language, including data types, control flow statements, and language-specific constructs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nvoid        bool        char        double\nfloat       float16     int128      ichar\nint         iptr        isz         long\nshort       uint128     uint        ulong\nuptr        ushort      usz         float128\nany         anyfault    typeid      assert\nasm         bitstruct   break       case\ncatch       const       continue    def\ndefault     defer       distinct    do\nelse        enum        extern      false\nfault       for         foreach     foreach_r\nfn          tlocal      if          inline\nimport      macro       module      nextcase\nnull        return      static      struct\nswitch      true        try         union\nvar         while\n```\n\n----------------------------------------\n\nTITLE: Memory Allocation Methods in C3\nDESCRIPTION: Demonstrates various ways to allocate memory for a single object in C3, including using malloc/calloc and higher-level convenience functions with different initialization options.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nFoo* f1 = malloc(Foo.sizeof);                   // No initialization\nFoo* f2 = calloc(Foo.sizeof);                   // Zero initialization\nFoo* f3 = mem::new(Foo);                        // Zero initialization\nFoo* f4 = mem::alloc(Foo);                      // No initialization\nFoo* f5 = mem::new(Foo, { 4, 10.0, .a = 123 }); // Initialized to argument\n```\n\n----------------------------------------\n\nTITLE: Dynamic Method Invocation with Any Type in C3\nDESCRIPTION: Demonstrates how to dynamically call methods on 'any' type objects based on their runtime type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nfn void whoareyou2(any a)\n{\n    // Query if the function exists\n    if (!&a.myname)\n    {\n        io::printn(\"I don't know who I am.\");\n        return;\n    }\n    // Dynamically call the function\n    io::printn(((MyName)a).myname());\n}\n\nfn void main()\n{\n    int i;\n    double d;\n    Bob bob;\n\n    any a = &i; \n    whoareyou2(a); // Prints \"I am int!\"\n    a = &d;\n    whoareyou2(a); // Prints \"I don't know who I am.\"\n    a = &bob;\n    whoareyou2(a); // Prints \"I am Bob!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Time Switch Statement Syntax\nDESCRIPTION: Defines the syntax for a compile-time switch statement in C3, which allows conditional execution of different cases based on a compile-time expression or type. It supports a default case and evaluates only the first matching case.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_33\n\nLANGUAGE: c\nCODE:\n```\n\"ct_switch_stmt     ::= \\\"$switch\\\" (\\\"(\\\" ct_expr_or_type \\\")\\\")? ct_case_stmt+ \\\"$endswitch\\\"\\nct_case_stmt       ::= (\\\"$default\\\" | \\\"$case\\\" ct_expr_or_type) \":\" stmt* \"\n```\n\n----------------------------------------\n\nTITLE: Base64 and Hex Data Literals in C3\nDESCRIPTION: The snippet demonstrates initializing arrays using Base64 and Hex data literals. This encoding allows for direct representation of data in memory layout. The examples show how to initialize character arrays with these literals.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nchar[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\";\nchar[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n```\n\n----------------------------------------\n\nTITLE: Implementing Foreach Support in C3\nDESCRIPTION: Shows how to implement the necessary operators ([] and len) to enable foreach iteration over custom types. Enables using the foreach syntax for custom containers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn double Foo.get(&self, usz i) @operator([])\n{\n    return self.x[i];\n}\n\nfn usz Foo.len(&self) @operator(len)\n{\n    return self.x.len;\n}\n\nfn void test(Foo f)\n{\n    // Print all elements in f\n    foreach (d : f)\n    {\n        io::printfn(\"%f\", d);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Struct Subtyping using Inline in C3\nDESCRIPTION: This code demonstrates struct subtyping in C3 using the `inline` keyword. An inline struct member allows creating a subtype that inherits the members of the parent struct.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\n```c3\nstruct ImportantPerson \n{\n    inline Person person;\n    String title;\n}\n\nfn void print_person(Person p)\n{\n    io::printfn(\"%s is %d years old.\", p.name, p.age);\n}\n\n\nfn void test()\n{\n    ImportantPerson important_person;\n    important_person.age = 25;\n    important_person.name = \"Jane Doe\";\n    important_person.title = \"Rockstar\";\n\n    // Only the first part of the struct is copied.\n    print_person(important_person); \n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Compound Literals Syntax in C3 Language\nDESCRIPTION: This snippet defines the grammar for compound literals in C3, explaining how they are structured and the implications of taking their addresses.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_25\n\nLANGUAGE: C3\nCODE:\n```\ncompound_literal   ::= (type) initializer_list\ninitializer_list   ::= '{' (initializer_param (',' initializer_param)* ','?)? '}'\ninitializer_param  ::= expression | designator '=' expression\ndesignator         ::= array_designator | range_designator | field_designator\narray_designator   ::= '[' expression ']'\nrange_designator   ::= '[' range_expression ']'\nfield_designator   ::= IDENTIFIER\nrange_expression   ::= (range_index)? '..' (range_index)?\nrange_index        ::= expression | '^' expression\n```\n\n----------------------------------------\n\nTITLE: Using Contracts for Function Validation in C3\nDESCRIPTION: This snippet shows how to use contracts in C3 for pre- and postcondition checking, enhancing reliability and correctness of function executions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @param foo \"the number of foos\" \n @require foo > 0, foo < 1000\n @return \"number of foos x 10\"\n @ensure return < 10000, return > 0\n*>\nfn int testFoo(int foo)\n{\n    return foo * 10;\n}\n\n<*\n @param array \"the array to test\"\n @param length \"length of the array\"\n @require length > 0\n*>\nfn int getLastElement(int* array, int length)\n{\n    return array[length - 1];\n}\n```\n\n----------------------------------------\n\nTITLE: Array Memory Allocation in C3\nDESCRIPTION: Shows different methods for allocating arrays in C3, from low-level malloc/calloc to higher-level helper functions that handle array size calculations and initialization.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\nFoo* foos1 = malloc(Foo.sizeof * len);    // No initialization\nFoo* foos2 = calloc(Foo.sizeof * len);    // Zero initialization\nFoo[] foos3 = mem::new_array(Foo, len);   // Zero initialization\nFoo[] foos4 = mem::alloc_array(Foo, len); // No initialization\n```\n\n----------------------------------------\n\nTITLE: Defining Typedefs with 'def' in C3\nDESCRIPTION: This snippet covers how to create a typedef in C3 using 'def'. It’s analogous to C's typedef but uses a slightly different syntax. Two typedefs ‘Int32’ and ‘Vector2’ are shown with their usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/types.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\ndef Int32 = int;\ndef Vector2 = float[<2>];\n\n/* ... */\n\nInt32 a = 1;\nint b = a;\n```\n\n----------------------------------------\n\nTITLE: Advanced Nextcase with Labels and Expressions\nDESCRIPTION: Shows advanced nextcase usage with expressions and labeled switches, enabling complex control flow and state machine-like behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nswitch MAIN: (enum_var)\n    case FOO:\n        switch (i)\n        {\n            case 1:\n                doSomething();\n                nextcase 3; // Jump to case 3\n            case 2:\n                doSomethingElse();\n            case 3:\n                nextcase rand(); // Jump to random case\n            default:\n                io::printn(\"Ended\");\n                nextcase MAIN: BAR;  // Jump to outer (MAIN) switch\n        } \n    case BAR:\n        io::printn(\"BAR\");\n    default:\n        break;\n}\n```\n\n----------------------------------------\n\nTITLE: Token Definitions for C3 Language Parsing\nDESCRIPTION: Comprehensive list of tokens used in the C3 language grammar, covering identifiers, literals, operators, keywords, and special constructs\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_5\n\nLANGUAGE: yacc\nCODE:\n```\n%token IDENT HASH_IDENT CT_IDENT CONST_IDENT\n%token TYPE_IDENT CT_TYPE_IDENT\n%token AT_TYPE_IDENT AT_IDENT CT_INCLUDE\n%token STRING_LITERAL INTEGER\n%token INC_OP DEC_OP SHL_OP SHR_OP LE_OP GE_OP EQ_OP NE_OP\n%token AND_OP OR_OP MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN ADD_ASSIGN\n%token SUB_ASSIGN SHL_ASSIGN SHR_ASSIGN AND_ASSIGN\n%token XOR_ASSIGN OR_ASSIGN VAR NUL ELVIS NEXTCASE ANYFAULT\n%token MODULE IMPORT DEF EXTERN\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Slices in C3\nDESCRIPTION: Demonstrates how to create and manipulate slices in C3 using array indexing notation. Shows slice creation, element access, and assignment operations, highlighting the different ways to specify slice ranges.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[100] a;\nint[] b = a[3..6]; // Or a[3:4]\nb[0] = 1;          // Same as a[3] = 1\n```\n\n----------------------------------------\n\nTITLE: Conditional Function Execution with Optionals\nDESCRIPTION: Illustrates how Optional arguments affect function execution and error propagation order.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn int test(int input, int input2) \n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int! first_optional = IoError.FILE_NOT_FOUND?;\n    int! second_optional = 7;\n\n    // Return first excuse we find\n    int! third_optional = test(first_optional, second_optional);\n    if (catch excuse = third_optional) \n    {\n        // excuse == IoError.FILE_NOT_FOUND\n        io::printfn(\"third_optional's Excuse: %s\", excuse); \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Top-Level Statement Structure in C3\nDESCRIPTION: Defines the overall structure of top-level statements in the C3 language, including modules, imports, function definitions, declarations, and compile-time constructs\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/grammar.md#2025-04-21_snippet_7\n\nLANGUAGE: c3-grammar\nCODE:\n```\ntop_level\n\t: module\n\t| import_decl\n\t| opt_extern func_definition\n\t| opt_extern const_declaration\n\t| opt_extern global_declaration\n\t| ct_assert_stmt\n\t| ct_echo_stmt\n\t| ct_include_stmt\n\t| tl_ct_if\n\t| tl_ct_switch\n\t| struct_declaration\n\t| fault_declaration\n\t| enum_declaration\n\t| macro_declaration\n\t| define_declaration\n\t| static_declaration\n```\n\n----------------------------------------\n\nTITLE: Defer Statement Example: Return Value Handling\nDESCRIPTION: Illustrates how a `defer` statement interacts with a `return` statement in C3, particularly how the expression in the return is evaluated before the deferred statement is executed. It gives equivalent expanded code.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_37\n\nLANGUAGE: c\nCODE:\n```\n\"int a = 0;\\ndefer a++;\\nreturn a;\\n// This is equivalent to\\nint a = 0;\\nint temp = a;\\na++;\\nreturn temp;\"\n```\n\n----------------------------------------\n\nTITLE: Labelled Break Example in C3\nDESCRIPTION: Demonstrates using labeled break to exit nested control structures. The example shows breaking out of a while loop to an outer if statement scope using a named label.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int i)\n{\n    if FOO: (i > 0)\n    {\n        while (1)\n        {\n            io::printfn(\"%d\", i);\n            // Break out of the top if statement.\n            if (i++ > 10) break FOO;\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Expression Evaluation Details for Ternary, Elvis, and Orelse\nDESCRIPTION: This snippet explains the evaluation mechanism for ternary, elvis, and orelse expressions. It elaborates on how expressions are evaluated conditionally based on boolean results and outlines the type conversion process to a unified type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_19\n\n\n\n----------------------------------------\n\nTITLE: Floating Point Types\nDESCRIPTION: Lists the built-in floating point types in C3, including float16, bfloat16, float (32-bit), double (64-bit), and float128. Indicates that float16, bfloat16, and float128 are optionally supported.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_14\n\nLANGUAGE: text\nCODE:\n```\n\"float16   IEEE 16-bit*\nbfloat16  Brainfloat*\nfloat     IEEE 32-bit\ndouble    IEEE 64-bit\nfloat128  IEEE 128-bit*\n\"\n```\n\n----------------------------------------\n\nTITLE: Bitstruct Definition in C3\nDESCRIPTION: Shows how C3 replaces C's bitfields with bitstructs that have well-defined encapsulating types and exact bit layouts.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Foo : short\n{  \n    int a : 0..2;\n    uint b : 3..6;\n    MyEnum c : 7..13;\n}\n\n// Simple form, only allowed when all fields are bools.\nstruct Flags : char\n{\n    bool has_hyperdrive;\n    bool has_tractorbeam;\n    bool has_plasmatorpedoes;\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Parameter Annotation Limitations in C3\nDESCRIPTION: Illustrates a case where the compiler might not detect incorrect usage of parameter annotations, potentially leading to unexpected behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/contracts.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void bad_func(int* i)\n{\n    *i = 2;\n}\n\n<*\n @param [&in] i\n*>\nfn void lying_func(int* i)\n{\n    bad_func(i); // The compiler might not check this!\n}\n\nfn void test()\n{\n    int a = 1;\n    lying_func(&a);\n    io::printf(\"%d\", a); // Might print 1!\n}\n```\n\n----------------------------------------\n\nTITLE: Assigning Values to Slices in C3\nDESCRIPTION: Shows how to use slice ranges for assignments, including assigning a single value to multiple elements and copying ranges between different parts of an array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\na[1..2] = 5;         // Assign 5 to a[1] and a[2]\na[1..3] = a[11..13]; // Copy 11-13 to 1-3\n```\n\n----------------------------------------\n\nTITLE: Object memory management and access methods in C3\nDESCRIPTION: A collection of methods for Object memory management, property access, type checking, and value manipulation in C3. These methods allow working with Object as a dynamic container with various data types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object*! Object.get(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* Object.get_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool! Object.get_bool(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool! Object.get_bool_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char! Object.get_char(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn char! Object.get_char_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String! Object.get_enum(&self, $EnumType, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro String! Object.get_enum_at(&self, $EnumType, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double! Object.get_float(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double! Object.get_float_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar! Object.get_ichar(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ichar! Object.get_ichar_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! Object.get_int(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int128! Object.get_int128(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int128! Object.get_int128_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int! Object.get_int_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Object.get_len(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long! Object.get_long(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn long! Object.get_long_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* Object.get_or_create_obj(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short! Object.get_short(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short! Object.get_short_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String! Object.get_string(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String! Object.get_string_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint! Object.get_uint(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128! Object.get_uint128(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint128! Object.get_uint128_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn uint! Object.get_uint_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong! Object.get_ulong(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ulong! Object.get_ulong_at(&self, usz index)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn short! Object.get_ushort(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort! Object.get_ushort_at(&self, usz index)\n```\n\n----------------------------------------\n\nTITLE: Defining Function Call Argument Resolution in C3 Language\nDESCRIPTION: This snippet outlines the rules for resolving function call arguments in C3, detailing the slots for regular, varargs, and named arguments, along with the validation steps for their correct usage.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_26\n\n\n\n----------------------------------------\n\nTITLE: Using SIMD Vectors in C3\nDESCRIPTION: Shows the basic usage of vector types in C3, which are designed for SIMD operations. Demonstrates vector creation, element-wise arithmetic, and assignment.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nint[<2>] pos = { 1, 3 };\nint[<2>] speed = { 5, 7 };\npos += speed;              // pos is now { 6, 10 }\n```\n\n----------------------------------------\n\nTITLE: Using Dynamic Arrays from the Standard Library in C3\nDESCRIPTION: This snippet demonstrates how to use dynamic arrays (List) from the standard library in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\ndef ListStr = List(<String>);\n\nfn void test()\n{\n    ListStr list_str;    \n\n    // Initialize the list on the heap.\n    list_str.new_init();    \n\n    list_str.push(\"Hello\");  // Add the string \"Hello\"\n    list_str.push(\"World\");\n\n    foreach (str : list_str)\n    {\n        io::printn(str);   // Prints \"Hello\", then \"World\"\n    }\n    String str = list_str[1]; // str == \"World\"\n    list_str.free();        // Free all memory associated with list.\n}\n```\n\n----------------------------------------\n\nTITLE: Using Temporary Allocator with Pool in C3\nDESCRIPTION: Demonstrates the temporary allocation system in C3 using the @pool macro. Temporary allocations inside the pool scope are automatically freed when execution exits the scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/index.mdx#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\n@pool()\n{\n    void* some_mem = tmalloc(128);\n    foo(some_mem);\n}; \n// Temporary allocations are automatically freed here.\n```\n\n----------------------------------------\n\nTITLE: Reverse Iteration Over Arrays in C3\nDESCRIPTION: This snippet demonstrates how to iterate over arrays in reverse order using foreach_r in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nfn void test()\n{\n    float[4] arr = { 1.0, 2.0 };\n    foreach_r (idx, item : arr)\n    {\n        // Prints 2.0, 1.0\n         io::printfn(\"item: %s\", item); \n    }\n\n    // Or equivalently, writing the types\n     foreach_r (int idx, float item : arr)\n    {\n        // Prints 2.0, 1.0\n         io::printfn(\"item: %s\", item); \n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Distinct Types Definition and Usage\nDESCRIPTION: Shows how to create and use distinct types, which are standalone types that don't implicitly convert to/from other types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Foo = int;\nFoo f = 0; // Valid since 0 converts to an int.\nf = f + 1;\nint i = 1;\n// f = f + i Error!\nf = f + (Foo)i; // Valid\n```\n\n----------------------------------------\n\nTITLE: Character Literal Grammar\nDESCRIPTION: Defines the grammar for character literals in C3, enclosed in single quotes and containing character literal bytes or Unicode characters.  Specifies that character literals can consist of 1, 2, 4, 8, or 16 bytes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_12\n\nLANGUAGE: text\nCODE:\n```\n\"CHARACTER_LIT   ::= \\\"'\\\" (CHAR_LIT_BYTE+) | UNICODE_CHAR \\\"'\\\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Defining Variables and Parameters in C3\nDESCRIPTION: This snippet illustrates the declaration of variables and parameters within a function in C3. Variables and parameters (except global constants) must start with a-z (after an optional initial `_`).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint theGlobal = 1;\n\nfn void foo(int x)\n{\n    Foo foo = getFoo(x);    \n    theGlobal++;\n}\n```\n\n----------------------------------------\n\nTITLE: PriorityQueue type definitions in C3\nDESCRIPTION: Defines PriorityQueue and PriorityQueueMax as distinct types based on a private implementation. The min queue orders elements in ascending order, while max queue uses descending order.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\ndistinct PriorityQueue = inline PrivatePriorityQueue(<Type, false>);\n```\n\nLANGUAGE: c3\nCODE:\n```\ndistinct PriorityQueueMax = inline PrivatePriorityQueue(<Type, true>);\n```\n\n----------------------------------------\n\nTITLE: Slice Operations with Temporary Arrays in C3\nDESCRIPTION: Demonstrates various ways to create and pass slices using temporary arrays in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(int[] y) { ... }\n\n// Using &&\ntest(&&(int[3]){ 1, 2, 3 });\n\n// Explicitly slicing:\ntest(((int[3]){ 1, 2, 3 })[..]);\n\n// Using a slice directly as a temporary:\ntest((int[]){ 1, 2, 3 });\n\n// Same as above but with inferred type:\ntest({ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Multiple Imports with @norecurse in C3\nDESCRIPTION: This snippet demonstrates importing multiple modules in a single line, with `@norecurse` applied to only one of them. Here, `lib1` is imported non-recursively, while `lib2` is imported normally (recursively).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\nimport lib1 @norecurse, lib2;\n```\n\n----------------------------------------\n\nTITLE: Compile Time Looping with $for in C3\nDESCRIPTION: This snippet illustrates how to use $for for compile time looping in C3, generating repeated code based on compile time variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmacro foo($a)\n{\n    $for (var $x = 0; $x < $a; $x++)\n        io::printfn(\"%d\", $x);     \n    $endfor\n}\n\nfn void test()\n{\n    foo(2);\n    // Expands to ->\n    // io::printfn(\"%d\", 0);     \n    // io::printfn(\"%d\", 1);         \n}\n```\n\n----------------------------------------\n\nTITLE: Optional Return Type Propagation\nDESCRIPTION: Shows how Optional arguments affect function return types and propagate through function calls.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nimport std::io;\n\nfn int test(int input) \n{\n    io::printn(\"test(): inside function body\");\n    return input;\n}\n\nfn void main(String[] args)\n{\n    int! optional_argument = 7;\n\n    // `optional_argument` makes returned `returned_optional` \n    // Optional too: \n    int! returned_optional = test(optional_argument);\n}\n```\n\n----------------------------------------\n\nTITLE: Using Generic Parameters in C3 Module Code\nDESCRIPTION: Illustrates how generic parameters can be used within a module as if they were well-defined symbols, including in struct definitions and function signatures.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo_test(<Type1, Type2>);\n\nstruct Foo \n{\n   Type1 a;\n}\n\nfn Type2 test(Type2 b, Foo* foo) \n{\n   return foo.a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Compile Time Echo Statement Syntax\nDESCRIPTION: Defines the syntax for a compile-time echo statement in C3, which outputs text during parsing and is then replaced by a NOP statement. The message must be a compile time constant string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_29\n\nLANGUAGE: c\nCODE:\n```\n\"ct_echo_stmt       ::= \\\"$echo\\\" constant_expr \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Changing Default Visibility in C3\nDESCRIPTION: This snippet shows how to change the default visibility of declarations within a module section using `@private` or `@local` after the module name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo @private;\n\nfn void ab_private() { ... } // Private\n\nmodule foo;\n\nfn void ab_public() { ... } // Public\n\nmodule bar;\nimport foo;\n\nfn void test()\n{\n    foo::ab_public(); // Works\n    // foo::ab_private(); <- Error, private method\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Element Set Operator []= in C3\nDESCRIPTION: Demonstrates implementation of the element set operator []= which enables setting values using array syntax. Allows assignment operations on custom container types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/operator-overloading.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void Foo.set(&self, usz i, double new_val) @operator([]=)\n{\n    return self.x[i] = new_val;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Suffix Expressions in C3 Language\nDESCRIPTION: This snippet defines the syntax rules for suffix expressions, illustrating how a fault is converted to an optional using syntactic constructs, and describes the impact of optionality.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_20\n\nLANGUAGE: C3\nCODE:\n```\nsuffix_group_exp   ::= or_group_expr | suffix_expr\nsuffix_expr        ::= or_group_expr \"?\" \"!\"?\n```\n\n----------------------------------------\n\nTITLE: Creating a Distribution Package for a C3 Project\nDESCRIPTION: Clean, build, and package the target for distribution. Will also run the target if it is an executable. Note that this feature is not fully implemented yet.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nc3c dist [target]\n```\n\n----------------------------------------\n\nTITLE: Object inspection and type checking methods in C3\nDESCRIPTION: Methods for inspecting Object properties and checking its type (array, map, bool, etc.). These methods help determine the nature of an Object without explicit typecasting.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.has_key(&self, String key)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_array(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_bool(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_empty(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_float(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_indexable(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_int(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_keyable(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_map(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_null(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool Object.is_string(&self) @inline\n```\n\n----------------------------------------\n\nTITLE: Object creation and utility functions in C3\nDESCRIPTION: Functions for creating new Object instances with different value types and extracting integer values from Objects. These functions provide factory methods for Object creation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nmacro get_integer_value(Object* value, $Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_bool(bool b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* new_enum(e, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_float(double f, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_int(int128 i, Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_null()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_obj(Allocator allocator)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Object* new_string(String s, Allocator allocator)\n```\n\n----------------------------------------\n\nTITLE: Displaying Download Note in Markdown\nDESCRIPTION: This snippet uses Markdown syntax to create a note block with a download link for C3. It provides a visual callout for users interested in downloading C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/roadmap.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n:::note[Want To Download C3?]\n[Download C3](/getting-started/prebuilt-binaries/), available on Mac, Windows and Linux.\n:::\n```\n\n----------------------------------------\n\nTITLE: Random Number Utility Macros in C3\nDESCRIPTION: Utility macros for random number generation, including seed creation, range-limited random values, and type-specific random values (bool, float, double). These complement the random number generator implementations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_88\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_random(random)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro make_seed($Type, char[] input)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int next(random, int max)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void next_bool(random)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro double next_double(random)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro float next_float(random)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int rand(int max) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void seed(random, seed)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void seed_entropy(random)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void seeder(char[] input, char[] out_buffer)\n```\n\n----------------------------------------\n\nTITLE: Distinct Inline Types Example\nDESCRIPTION: Demonstrates the use of distinct inline types which can implicitly convert to their base type but not from it.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\ndistinct CString = char*;\ndistinct ZString = inline char*;\n...\nCString abc = \"abc\";\nZString def = \"def\";\n// char* from_abc = abc; // Error!\nchar* from_def = def; // Valid!\n```\n\n----------------------------------------\n\nTITLE: Core built-in enums and faults in C3\nDESCRIPTION: Defines basic enumerations and fault types used by the C3 built-in functions. These types represent common error conditions and configuration options for system operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_27\n\nLANGUAGE: c3\nCODE:\n```\nenum PrefetchLocality\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault CastResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault IteratorResult\n```\n\nLANGUAGE: c3\nCODE:\n```\nfault SearchResult\n```\n\n----------------------------------------\n\nTITLE: Reflection Invocation in C3 (Proposed)\nDESCRIPTION: Shows a proposed syntax for retrieving and invoking dynamic methods by name using reflection.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\ndef VoidMethodFn = fn void(void*);\n\nfn void* int.test_something(&self) @dynamic\n{\n    io::printfn(\"Testing: %d\", *self);\n}\n\nfn void main()\n{\n    int z = 321;\n    any a = &z;\n    VoidMethodFn test_func = a.reflect(\"test_something\");\n    test_func(a); // Will print \"Testing: 321\"\n}\n```\n\n----------------------------------------\n\nTITLE: Defining DString Type in C3\nDESCRIPTION: Defines the DString type as a distinct void pointer implementing the OutStream interface. It serves as a dynamic string builder supporting various runtime string operations without manual memory allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\ndistinct DString (OutStream) = void*;\n```\n\n----------------------------------------\n\nTITLE: Any-switch Example in C3\nDESCRIPTION: Demonstrates how switch statements handle 'any' type expressions, implicitly converting the variable based on case types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_45\n\nLANGUAGE: c3\nCODE:\n```\nany a = abc();\nswitch (a)\n{\n    case int:\n        int b = *a;   // a is int*\n    case float:\n        float z = *a; // a is float*\n    case Bar:\n        Bar f = *a;   // a is Bar*\n    default:\n        // a is not unwrapped\n}              \n```\n\n----------------------------------------\n\nTITLE: Struct Methods for Dot Syntax in C3\nDESCRIPTION: This snippet illustrates how struct methods can be defined in C3, allowing for dot syntax calls to manipulate struct fields.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/examples.md#2025-04-21_snippet_11\n\nLANGUAGE: c3\nCODE:\n```\nstruct Foo\n{\n    int i;\n}\n\nfn void Foo.next(Foo* this)\n{\n    if (this) this.i++;\n}\n\nfn void test()\n{\n    Foo foo = { 2 };\n    foo.next();\n    foo.next();\n    // Prints 4\n    io::printfn(\"%d\", foo.i); \n}\n```\n\n----------------------------------------\n\nTITLE: String Literals in C3\nDESCRIPTION: Shows different ways to create string literals in C3, including raw strings with backticks and escaped strings.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nString three_lines = \n`multi\nline\nstring`;\n\nString foo = `C:\\foo\\bar.dll`;\nString bar = `\"Say ``hello``\"`;\n// Same as\nString foo = \"C:\\\\foo\\\\bar.dll\";\nString bar = \"\\\"Say `hello`\\\"\";\n```\n\n----------------------------------------\n\nTITLE: Adding Constraints to Generic Modules in C3\nDESCRIPTION: Demonstrates how to add optional constraints to generic modules using @require directives, improving compile-time error messages.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\n<*\n @require $assignable(1, TypeB) && $assignable(1, TypeC)\n @require $assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)\n*> \nmodule vector(<TypeA, TypeB, TypeC>);\n\n/* .. code  .. */\n```\n\n----------------------------------------\n\nTITLE: Core built-in macros in C3\nDESCRIPTION: Essential built-in macros for language-level operations like type conversion, error handling, and optimization hints. These macros provide compiler-level functionality for common operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_28\n\nLANGUAGE: c3\nCODE:\n```\nmacro char[] @as_char_view(&value) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro anyfault @catch(#expr) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @expect(#value, expected, $probability = 1.0) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @likely(bool #value, $probability = 1.0) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @ok(#expr) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @prefetch(void* ptr, PrefetchLocality $locality = VERY_NEAR, bool $write = false) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @scope(&variable; @body) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @swap(&a, &b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool @unlikely(bool #value, $probability = 1.0) @builtin\n```\n\n----------------------------------------\n\nTITLE: Defining Array Operations for Unsigned Long Integers in C3\nDESCRIPTION: A collection of macros that implement various aggregate operations on arrays of unsigned long integers, including bitwise operations, comparisons, and reductions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_68\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].and(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_eq(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_ge(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_gt(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_le(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_lt(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool[<*>] ulong[<*>].comp_ne(ulong[<*>] x, ulong[<*>] y)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].max(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].min(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].or(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].product(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].sum(ulong[<*>] x)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro ulong ulong[<*>].xor(ulong[<*>] x)\n```\n\n----------------------------------------\n\nTITLE: Declaring and Initializing Fixed-Size Arrays in C3\nDESCRIPTION: This snippet demonstrates how to declare and initialize fixed-size arrays in C3, including using the [*] syntax for size inference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[3] a = { 1, 2, 3 };\nint[*] b = { 4, 5, 6 }; // Type inferred to be int[3]\n```\n\n----------------------------------------\n\nTITLE: Defining String Type in C3\nDESCRIPTION: Defines the String type as a distinct inline char array, which is the typical string type to use in C3. It supports slicing, comparison, and length access through the .len operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\ndistinct String = inline char[];\n```\n\n----------------------------------------\n\nTITLE: Demonstrating If-catch Implicit Unwrap in C3\nDESCRIPTION: This snippet shows how if-catch can implicitly unwrap a variable in the outer scope if all code paths in the then-clause exit the scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_42\n\nLANGUAGE: c3\nCODE:\n```\nint! a = foo();\nif (catch a)\n{\n  return;\n}  \nint x = a; // Valid, a is implicitly unwrapped.\n```\n\n----------------------------------------\n\nTITLE: Defining Relational Expressions in C3 Language\nDESCRIPTION: This snippet captures the syntax for relational expressions, detailing the relational operators available in C3 and their role in constructing complex expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_22\n\nLANGUAGE: C3\nCODE:\n```\nrel_group_expr     ::= add_group_expr | relational_expr\nrelational_expr    ::= rel_group_expr relational_op add_group_expr\nrelational_op      ::= \"<\" | \">\" | \"<=\" | \">=\"\n```\n\n----------------------------------------\n\nTITLE: Private Visibility in C3\nDESCRIPTION: This snippet demonstrates how to declare a function as private using the `@private` attribute.  Private functions are only accessible within the module they are defined in.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_8\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\nfn void init() { .. }\n\nfn void open() @private { .. }\n```\n\n----------------------------------------\n\nTITLE: Base64 and Hex Data Literals in C3\nDESCRIPTION: Demonstrates how to use base64 and hexadecimal data literals to create character arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_base64 = b64\"SGVsbG8gV29ybGQh\";\n\n// The array below contains the characters \"Hello World!\"\nchar[*] hello_world_hex = x\"4865 6c6c 6f20 776f 726c 6421\";\n```\n\n----------------------------------------\n\nTITLE: DateTime Functions with LibC in C3\nDESCRIPTION: DateTime manipulation functions in C3 that are conditionally available when using LibC. Provides operations for date/time calculations, comparisons, and conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_111\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_days(&self, int days)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_hours(&self, int hours)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_minutes(&self, int minutes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_months(&self, int months)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_seconds(&self, int seconds)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_weeks(&self, int weeks)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime DateTime.add_years(&self, int years)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool DateTime.after(&self, DateTime compare) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool DateTime.before(&self, DateTime compare) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int DateTime.compare_to(&self, DateTime compare)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn double DateTime.diff_sec(self, DateTime from)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Duration DateTime.diff_us(self, DateTime from)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn int DateTime.diff_years(&self, DateTime from)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DateTime.set_date(&self, int year, Month month = JANUARY, int day = 1, int hour = 0, int min = 0, int sec = 0, int us = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DateTime.set_time(&self, Time time)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TzDateTime DateTime.to_local(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time DateTime.to_time(&self) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime from_date(int year, Month month = JANUARY, int day = 1, int hour = 0, int min = 0, int sec = 0, int us = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime from_time(Time time)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn DateTime now()\n```\n\n----------------------------------------\n\nTITLE: Defining a Test Function in C3\nDESCRIPTION: Example of a test function in C3 that is marked with the @test attribute. Such functions will be executed when running the 'c3c test' command.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn void test_fn() @test\n{\n    assert(true == true, \"true is definitely true\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing a New C3 Project\nDESCRIPTION: Create a new C3 project structure in the current directory with a specified project name and optional path. Templates can be specified using the --template parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nc3c init <project_name> [optional path]\n```\n\n----------------------------------------\n\nTITLE: Compile Time If Statement Syntax\nDESCRIPTION: Defines the syntax for a compile-time if statement in C3, which conditionally processes either the \"then\" or \"else\" branch based on a compile-time constant expression.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_32\n\nLANGUAGE: c\nCODE:\n```\n\"ct_if_stmt         ::= \\\"$if\\\" constant_expr \":\" stmt* (\\\"$else\\\" stmt*)? \\\"$endif\\\"\"\n```\n\n----------------------------------------\n\nTITLE: Multiple Defer Statements Order\nDESCRIPTION: Shows how multiple defer statements are executed in reverse order (last-to-first) when leaving a scope.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void test() \n{\n    io::printn(\"print first\");\n    defer io::printn(\"print third, defers execute in reverse order\");\n    defer io::printn(\"print second, defers execute in reverse order\");\n    return;\n}\n```\n\n----------------------------------------\n\nTITLE: Hashing and type manipulation functions in C3\nDESCRIPTION: Functions and macros for calculating hash values and manipulating types. These utilities support type comparison, hashing for various primitive types, and type conversions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_29\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint String.hash(String c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any.as_inner(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any.retype_to(&self, typeid type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro any_make(void* ptr, typeid type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro anycast(any v, $Type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bitcast(expr, $Type) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint bool.hash(bool b)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint char.hash(char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint char[].hash(char[] c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro int compare_to(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro enum_by_name($Type, String enum_name) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool equals(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* get_frameaddress(int n)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* get_returnaddress(int n)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro greater(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro greater_eq(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ichar.hash(ichar c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint int.hash(int i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint int128.hash(int128 i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro less(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro less_eq(a, b) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint long.hash(long i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro max(x, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro min(x, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint short.hash(short s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro swizzle(v, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro swizzle2(v, v2, ...) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint typeid.hash(typeid t)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint.hash(uint i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint uint128.hash(uint128 i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ulong.hash(ulong i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint ushort.hash(ushort s)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro uint void*.hash(void* ptr)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Constraint Violations in C3 Generics\nDESCRIPTION: Shows an example of how constraint violations in generic modules result in compile-time errors with descriptive messages.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\ndef testFunction = vector::testFunc(<Bar, float, int>);\n\n// This would give the error \n// --> Parameter(s) failed validation: \n//     @require \"$assignable((TypeB)1, TypeA) && $assignable((TypeC)1, TypeA)\" violated.\n```\n\n----------------------------------------\n\nTITLE: Implementing BitSet Operations in C3\nDESCRIPTION: Defines a BitSet struct and associated methods for bit manipulation, including getting, setting, and unsetting bits, as well as calculating cardinality and length.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nstruct BitSet\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz BitSet.cardinality(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool BitSet.get(&self, usz i) @operator([]) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz BitSet.len(&self) @operator(len) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitSet.set(&self, usz i)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitSet.set_bool(&self, usz i, bool value) @operator([]=) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void BitSet.unset(&self, usz i)\n```\n\n----------------------------------------\n\nTITLE: Utility Macros for Random Number Generation\nDESCRIPTION: Defines utility macros for type conversion and byte manipulation used by the random number generators.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_91\n\nLANGUAGE: c3\nCODE:\n```\nmacro ushort @char_to_short(#function)\nmacro ulong @int_to_long(#function)\nmacro uint128 @long_to_int128(#function)\nmacro @random_value_to_bytes(#function, char[] bytes)\nmacro uint @short_to_int(#function)\n```\n\n----------------------------------------\n\nTITLE: Self referencing initialization example\nDESCRIPTION: Example demonstrating that an init expression may refer to the **address** of the same variable that is declared, but not the **value** of the variable.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_41\n\nLANGUAGE: c\nCODE:\n```\n\"void* a = &a;  // Valid\\nint a = a + 1; // Invalid\"\n```\n\n----------------------------------------\n\nTITLE: Bitorder utilities in C3\nDESCRIPTION: Utility macros for handling bit ordering in arrays and types. Provides functions for reading and writing values with specific bit ordering considerations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_26\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_array_or_slice_of_char(bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool is_arrayptr_or_slice_of_char(bytes)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro is_bitorder($Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro read(bytes, $Type)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro write(x, bytes, $Type)\n```\n\n----------------------------------------\n\nTITLE: Compile Time Fibonacci Calculation in C3\nDESCRIPTION: This example shows a recursive macro that computes Fibonacci numbers at compile time using conditional compilation and compile time variables.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/compiletime.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nmacro long @fib(long $n)\n{\n    $if $n <= 1:\n        return $n;\n    $else\n        return @fib($n - 1) + @fib($n - 2);\n    $endif\n}\n```\n\n----------------------------------------\n\nTITLE: Slice Creation in C3\nDESCRIPTION: Shows how to create and use slices in C3, which are views into underlying arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nint[3] abc = { 1, 2, 3 }; \nint[] slice = &abc;       // A slice pointing to abc with length 3\n```\n\n----------------------------------------\n\nTITLE: Exporting C3 Functions for C Usage\nDESCRIPTION: Illustrates how to export C3 functions with custom names for use in C code using @export and @extern attributes.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/cinterop.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\nfn int square(int x) @export // @export ensures external visibility\n{\n    return x * x;\n}\n\nfn int square2(int x) @export(\"square\")\n{\n    return x * x;\n}\n```\n\n----------------------------------------\n\nTITLE: Private PriorityQueue implementation in C3\nDESCRIPTION: Internal implementation of PriorityQueue with methods for queue operations. Provides the core functionality for heap-based priority queues with customizable element ordering.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nstruct PrivatePriorityQueue (Printable)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! PrivatePriorityQueue.first(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.free(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type PrivatePriorityQueue.get(&self, usz index) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool PrivatePriorityQueue.is_empty(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz PrivatePriorityQueue.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.new_init(&self, usz initial_capacity = 16, Allocator allocator = allocator::heap()) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Type! PrivatePriorityQueue.pop(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.push(&self, Type element)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void PrivatePriorityQueue.temp_init(&self, usz initial_capacity = 16) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! PrivatePriorityQueue.to_format(&self, Formatter* formatter) @dynamic\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String PrivatePriorityQueue.to_new_string(&self, Allocator allocator = allocator::heap()) @dynamic\n```\n\n----------------------------------------\n\nTITLE: Break Statement Syntax\nDESCRIPTION: Defines the syntax for a break statement in C3, which allows exiting `while`, `for`, `do`, `foreach`, or `switch` scopes, optionally with a label.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_28\n\nLANGUAGE: c\nCODE:\n```\n\"break_stmt         ::= \\\"break\\\" label? \\\";\\\"\"\n```\n\n----------------------------------------\n\nTITLE: 2D Slice implementation in C3\nDESCRIPTION: Implementation of Slice2d structure for working with 2D array slices. Provides methods for iterating, accessing, and manipulating rectangular sections of 2D arrays.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_25\n\nLANGUAGE: c3\nCODE:\n```\nstruct Slice2d\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void Slice2d.@each(&self; @body(usz[<2>], Type))\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void Slice2d.@each_ref(&self; @body(usz[<2>], Type*))\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Slice2d.count(&self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Type[] Slice2d.get(self, usz idy) @operator([])\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz Slice2d.len(&self) @operator(len)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Slice2d Slice2d.slice(&self, isz x = 0, isz xlen = 0, isz y = 0, isz ylen = 0)\n```\n\n----------------------------------------\n\nTITLE: Resolving Ambiguities with Module Paths in C3\nDESCRIPTION: This snippet shows how to resolve ambiguities when different modules define symbols with the same name by using the full module path.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_6\n\nLANGUAGE: c3\nCODE:\n```\nmodule de;\nstruct Context\n{\n    void* ptr;\n}\n```\n\n----------------------------------------\n\nTITLE: Compile and Run Commands for C3\nDESCRIPTION: Terminal commands showing how to compile and run a C3 program using the c3c compiler, with example output.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/hello-world.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n$ c3c compile-run hello_world.c3\n> Program linked to executable 'hello_world'.\n> Launching hello_world...\n> Hello, World\n```\n\n----------------------------------------\n\nTITLE: Conditional Declaration Syntax in C3\nDESCRIPTION: Shows special case of multiple declarations in loop conditions where each variable must specify its type.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfor (int i = 0, int j = 1; i < 10; i++, j++) { ... }\n```\n\n----------------------------------------\n\nTITLE: Switch Statement Syntax in C3\nDESCRIPTION: Defines the syntax for the switch statement, including the optional label and condition expression.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_44\n\nLANGUAGE: c3\nCODE:\n```\nswitch_stmt        ::= \"switch\" (label \":\")? (\"(\" cond_expr \")\")? switch body\nswitch_body        ::= \"{\" case_clause* \"}\"\ncase_clause        ::= default_stmt | case_stmt\ndefault_stmt       ::= \"default\" \":\" stmt*\ncase_stmt          ::= \"case\" label? expr (\"..\" expr)? \":\" stmt*\n```\n\n----------------------------------------\n\nTITLE: Declaration Syntax in C3\nDESCRIPTION: Illustrates C3's restrictions on multiple declarations and initialization syntax compared to C. Shows both invalid and valid declaration patterns.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nint i, j = 1; // ERROR\nint a = 1;    // Ok\nint b, c;     // Ok\n```\n\n----------------------------------------\n\nTITLE: Integer Constants in C3\nDESCRIPTION: Demonstrates different ways to write integer constants in C3 including decimal, hexadecimal, and using underscores for readability.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\na = -2_000;\nb = 0o770;\nc = 0x7f7f7f;\n```\n\n----------------------------------------\n\nTITLE: Initializing a New C3 Project\nDESCRIPTION: This command creates a new C3 project directory with a basic structure. It uses the 'c3c init' command followed by the project name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nc3c init myc3project\n```\n\n----------------------------------------\n\nTITLE: Object manipulation methods in C3\nDESCRIPTION: Methods for modifying Object contents, including pushing values, setting properties, and formatting. These methods allow dynamic manipulation of Object data.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_17\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.push(&self, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.push_object(&self, Object* to_append)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.set(&self, String key, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Object* Object.set_at(&self, usz index, String key, value)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void Object.set_object_at(&self, usz index, Object* to_set)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! Object.to_format(&self, Formatter* formatter) @dynamic\n```\n\n----------------------------------------\n\nTITLE: While Statement Syntax Definition in C3\nDESCRIPTION: Defines the syntax for while loops in C3, showing the grammar rule including optional labels and condition expressions.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Implementation Details/specification.md#2025-04-21_snippet_50\n\nLANGUAGE: bnf\nCODE:\n```\nwhile_stmt         ::= \"while\" label? \"(\" cond_expr \")\" stmt\n```\n\n----------------------------------------\n\nTITLE: Defining Generic Modules in C3\nDESCRIPTION: Shows how to define a generic module with type parameters. Generic parameters follow the module name in angle brackets.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\n// TypeA, TypeB, TypeC are generic parameters.\nmodule vector(<TypeA, TypeB, TypeC>);\n```\n\n----------------------------------------\n\nTITLE: Building a C3 Project\nDESCRIPTION: This command builds the C3 project without running it. It uses 'c3c build' to compile the project targets defined in the project.json file.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nc3c build\n```\n\n----------------------------------------\n\nTITLE: Calling C Functions from C3\nDESCRIPTION: Demonstrates how to declare and call a C function (puts) from C3 code using the 'extern' keyword.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/cinterop.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nextern fn void puts(char*); // C \"puts\"\n\nfn void main()\n{\n    // This will call the \"puts\"\n    // function in the standard c lib.\n    puts(\"Hello, world!\"); \n}\n```\n\n----------------------------------------\n\nTITLE: Declaring Optional Types in C3\nDESCRIPTION: Demonstrates basic Optional declaration and initialization with both success and error cases.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint! a = 1; // Set the Optional to a result\n// Set the Optional to empty with a specific Excuse.\nint! b = IoError.FILE_NOT_FOUND?;\n```\n\n----------------------------------------\n\nTITLE: Implicit True Switch Statement\nDESCRIPTION: Shows how switch statements can omit the conditional expression, implicitly using (true) as the condition.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/statements.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\nswitch\n{\n    case foo() > 0:\n        bar();\n    case test() == 1:\n        baz();\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Running a Specific C3 Project Target\nDESCRIPTION: This command builds and runs a specific target in the C3 project. It uses 'c3c run' followed by the target name.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/projects.mdx#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nc3c run myc3project\n```\n\n----------------------------------------\n\nTITLE: Using the .len Property on Arrays in C3\nDESCRIPTION: This snippet shows how to get the length of arrays using the .len property in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint len1 = int[4].len; // 4\nint[3] a = { 1, 2, 3 };\nint len2 = a.len; // 3\nint[*] b = { 1, 2 };\nint len3 = b.len; // 2\n```\n\n----------------------------------------\n\nTITLE: Signed-Unsigned Comparison in C3\nDESCRIPTION: Demonstrates C3's safe signed-unsigned comparison behavior which differs from C's behavior.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/changesfromc.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\n// The code below would print \"Hello C3!\" in C3 and \"Hello C!\" in C.\nint i = -1;\nuint j = 1;\nif (i < j)\n{\n    printf(\"Hello C3!\\n\");\n}\nelse\n{\n    printf(\"Hello C!\\n\");\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Multi-Dimensional Arrays in C3\nDESCRIPTION: This snippet demonstrates how to access elements in multi-dimensional arrays in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/arrays.md#2025-04-21_snippet_10\n\nLANGUAGE: c3\nCODE:\n```\n// Uses: <type>[<x-size>][<y-size>]\nint[2][4] array = {\n    {1, 2},\n    {3, 4},\n    {5, 6},\n    {7, 8},\n};\n\n// Access fixed array using: array[<row>][<column>]\nint value = array[3][1]; // 8\n```\n\n----------------------------------------\n\nTITLE: Versionless Dynamic Loading in C3\nDESCRIPTION: This snippet demonstrates versionless dynamic loading using the `@dynamic` attribute and `@available` to optionally load dynamic libraries.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_19\n\nLANGUAGE: c3\nCODE:\n```\nimport maybe_dynlib;\nfn void testme2()\n{\n    if (@available(maybe_dynlib::testme))\n    {\n        dynlib::testme();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Varargs Function Forwarding in C3\nDESCRIPTION: Demonstrates how to forward variable arguments to another function using the splat operator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/FAQ/index.mdx#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test(String format, args...)\n{\n\tio::printfn(format, ...args);\n}\n\nfn void main()\n{\n\ttest(\"Format: %s %d\", \"Foo\", 123);\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Global Constants in C3\nDESCRIPTION: This code shows the declaration of a global constant in C3. Global constants must start with A-Z (after an optional initial `_`).\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/naming.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nconst int A_VALUE = 12;\n```\n\n----------------------------------------\n\nTITLE: Building a C3 Project\nDESCRIPTION: Build the project with an optional target specification. The built-in templates typically define 'debug' (default) and 'release' targets.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nc3c build [target]\n```\n\n----------------------------------------\n\nTITLE: C3 Array and Type Declaration Examples\nDESCRIPTION: Examples showing C3's left-to-right type declarations, array syntax, and type inference.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\nint[4]*[2] a;           // Array declaration\nint[*] x = { 1, 2 };     // Inferred array type\nfloat[<4>]              // SIMD vector type\nint[]                    // Slice type\n```\n\n----------------------------------------\n\nTITLE: Running Tests in a C3 Project\nDESCRIPTION: Execute all test functions marked with the @test attribute in the project's source directory as defined in project.json.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nc3c test\n```\n\n----------------------------------------\n\nTITLE: Bitfield Replacement with Bitstructs in C3\nDESCRIPTION: Demonstrates the new bitstruct syntax for creating bitfield-like structures with explicit bit ranges\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nbitstruct Foo : short\n{\n    int a : 0..2;\n    uint b : 3..6;\n    MyEnum c : 7..13;\n}\n```\n\n----------------------------------------\n\nTITLE: Textual Include in C3\nDESCRIPTION: This snippet demonstrates how to include the contents of another file using the `$include` directive.  This is a simple textual inclusion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/modules.md#2025-04-21_snippet_20\n\nLANGUAGE: c3\nCODE:\n```\nmodule foo;\n\n$include(\"Foo.x\");\n\nfn void test()\n{\n    io::printf(\"%d\", testX(2));\n}\n```\n\n----------------------------------------\n\nTITLE: Boolean Values in C3\nDESCRIPTION: Shows how to declare boolean values in C3. Booleans can be either true or false and are stored in a byte.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nbool b = true;\nbool f = false;\n```\n\n----------------------------------------\n\nTITLE: Defer Try Success Example\nDESCRIPTION: Demonstrates defer try execution when an Optional contains a successful result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/defer.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nfn void! test() \n{\n    defer try io::printn(\"✅ defer try run\"); \n    return;\n}\n\nfn void main(String[] args) \n{\n    (void)test();\n}\n```\n\n----------------------------------------\n\nTITLE: C3 Function Declaration Examples\nDESCRIPTION: Shows C3's function declaration syntax including named arguments and varargs.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfoo(name: a, len: 2)              // Named arguments\nfn void Type.method(Type* t) {}    // Type method\nType... argument                   // Typed varargs\nfoo(a, b, ...list)                // Splat operator\n```\n\n----------------------------------------\n\nTITLE: Converting Quaternion to Matrix4 in C3\nDESCRIPTION: A macro that converts a quaternion pointer to a 4x4 matrix representation and returns the resulting Matrix4.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_87\n\nLANGUAGE: c3\nCODE:\n```\nmacro Matrix4 Quaternion.to_matrix(Quaternion* q)\n```\n\n----------------------------------------\n\nTITLE: Copying Data from Any Type in C3\nDESCRIPTION: Shows how to create a copy of data stored in an 'any' type using runtime type information.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/anyinterfaces.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nvoid* data = malloc(a.type.sizeof);\nmem::copy(data, a.ptr, a.type.sizeof);\nany any_copy = any_make(data, a.type);    \n```\n\n----------------------------------------\n\nTITLE: Defining Object structure with Printable interface in C3\nDESCRIPTION: Defines the Object structure that implements the Printable interface, serving as a base for JSON-like object manipulation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_14\n\nLANGUAGE: c3\nCODE:\n```\nstruct Object (Printable)\n```\n\n----------------------------------------\n\nTITLE: Manual Installation of C3 Compiler on Arch Linux\nDESCRIPTION: Commands to manually clone and install the c3c compiler from the AUR on Arch Linux.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/prebuilt-binaries.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://aur.archlinux.org/c3c-git.git\ncd c3c-git\nmakepkg -si\n```\n\n----------------------------------------\n\nTITLE: C3 Array Range Operations\nDESCRIPTION: Demonstrates C3's array range initialization and manipulation syntax.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nint[256] x = { [0..128] = 1 }     // Range initialization\na[4..8] = 1;                      // Range assignment\na[4..8] = b[8..12];               // Slice assignment\na[^1]                             // Index from end\n```\n\n----------------------------------------\n\nTITLE: Creating New Split String in C3\nDESCRIPTION: Inline function to split a string and create a new array of strings using the heap allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_21\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.new_split(s, String needle, usz max = 0) => s.split(needle, max, allocator::heap()) @inline;\n```\n\n----------------------------------------\n\nTITLE: Normalized Linear Interpolation Between Quaternions in C3\nDESCRIPTION: A function that performs normalized linear interpolation (nlerp) between two quaternions based on an amount parameter.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_81\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.nlerp(Quaternion q1, Quaternion q2, Real amount)\n```\n\n----------------------------------------\n\nTITLE: Slice Raw Structure in C3\nDESCRIPTION: Defines the internal representation of a slice as a two-element struct containing a pointer and length.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/basic-types-and-values.md#2025-04-21_snippet_4\n\nLANGUAGE: c3\nCODE:\n```\nstruct SliceRaw\n{\n\tvoid* ptr;\n\tusz len;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic libc Type Definitions\nDESCRIPTION: Core type definitions from the C standard library including error handling and time structures\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\ndistinct Errno = inline CInt;\nstruct DivResult\nstruct LongDivResult\nstruct TimeSpec\nstruct Timespec\nstruct Tm\n```\n\n----------------------------------------\n\nTITLE: Adding Scalar to Each Component of Quaternion in C3\nDESCRIPTION: A macro that adds a real scalar value to each component of a quaternion and returns the result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_76\n\nLANGUAGE: c3\nCODE:\n```\nmacro Quaternion Quaternion.add_each(Quaternion a, Real b)\n```\n\n----------------------------------------\n\nTITLE: Function Pointer Aliasing in C3\nDESCRIPTION: Shows how to create function pointer aliases with the def statement, which is mandatory in C3.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/define.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\ndef Callback = fn void(int a, bool b);\n```\n\n----------------------------------------\n\nTITLE: Implementing Maybe Type in C3\nDESCRIPTION: Defines a Maybe struct for optional values and associated methods for creating and retrieving the value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_13\n\nLANGUAGE: c3\nCODE:\n```\nstruct Maybe\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro Type! Maybe.get(self)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Maybe value(Type val)\n```\n\n----------------------------------------\n\nTITLE: Multiplying Quaternions in C3\nDESCRIPTION: A function that performs quaternion multiplication between two quaternions and returns the result.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_80\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.mul(a, Quaternion b)\n```\n\n----------------------------------------\n\nTITLE: Creating Temporary Split String in C3\nDESCRIPTION: Function to split a string and create a temporary array of strings using the temporary allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_22\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tsplit(s, String needle, usz max = 0) => s.split(needle, max, allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Array Compound Literals in C3\nDESCRIPTION: Demonstrates array compound literal syntax in C3 with explicit type declaration.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Fundamentals/expressions.md#2025-04-21_snippet_2\n\nLANGUAGE: c3\nCODE:\n```\nfn void test2(int[3] x) { ... }\n\n...\n\ntest2((int[3]){ 1, 2, 3 });\n```\n\n----------------------------------------\n\nTITLE: Minimal Main Function in C3\nDESCRIPTION: Basic structure of an empty main function in C3, showing function declaration syntax with return type void.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/hello-world.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\nfn void main() {}\n```\n\n----------------------------------------\n\nTITLE: Generating Documentation for a C3 Project\nDESCRIPTION: Rebuild the documentation for a C3 project. This feature is noted as not yet implemented.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Build Your Project/build-commands.mdx#2025-04-21_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nc3c docs [target]\n```\n\n----------------------------------------\n\nTITLE: Parameterizing Modules with Constants in C3\nDESCRIPTION: Demonstrates how to parameterize a module with int or bool constants in addition to types.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/generics.md#2025-04-21_snippet_1\n\nLANGUAGE: c3\nCODE:\n```\n// module custom_type(<Type, VALUE>)  \nmodule custom_type(<float, 3>);\n```\n\n----------------------------------------\n\nTITLE: Windows-specific Directory Operations\nDESCRIPTION: Directory listing and recursive removal operations specific to Windows systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_66\n\nLANGUAGE: c3\nCODE:\n```\nfn PathList! native_ls(Path dir, bool no_dirs, bool no_symlinks, String mask, Allocator allocator)\nfn void! native_rmtree(Path path)\n```\n\n----------------------------------------\n\nTITLE: Windows Time Functions in C3\nDESCRIPTION: Windows-specific time functions in C3. Provides native clock and timestamp implementations for Windows systems.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_114\n\nLANGUAGE: c3\nCODE:\n```\nfn Clock native_clock()\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn Time native_timestamp()\n```\n\n----------------------------------------\n\nTITLE: Calculating Quaternion Length in C3\nDESCRIPTION: A macro that computes the length (magnitude) of a quaternion and returns it as a Real value.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_78\n\nLANGUAGE: c3\nCODE:\n```\nmacro Real Quaternion.length(Quaternion q)\n```\n\n----------------------------------------\n\nTITLE: Converting String to WString in C3\nDESCRIPTION: Functions to convert a String to WString, with options for new or temporary allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_31\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_wstring(s, Allocator allocator);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_new_wstring(s) => s.to_wstring(allocator::heap());\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn WString! String.to_temp_wstring(s) => s.to_wstring(allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Type Definition Changes in C3\nDESCRIPTION: Shows how 'typedef' is replaced by 'def' in C3, with additional macro-like capabilities\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_4\n\nLANGUAGE: c\nCODE:\n```\ntypedef Foo* FooPtr;\n#define println puts\n```\n\nLANGUAGE: c3\nCODE:\n```\ndef FooPtr = Foo*;\ndef println = puts;\n```\n\n----------------------------------------\n\nTITLE: Module Declaration and Visibility Example\nDESCRIPTION: Demonstrates module declaration syntax, visibility modifiers, and import statements in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/FAQ/allfeatures.md#2025-04-21_snippet_3\n\nLANGUAGE: C3\nCODE:\n```\nmodule my_module @private;\nmodule arr(<Type, LEN>);\nimport std::net, std::io;\n```\n\n----------------------------------------\n\nTITLE: Copying String in C3\nDESCRIPTION: Function to create a copy of a String using a specified allocator or the heap allocator by default.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_9\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.copy(s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Inverting a Quaternion in C3\nDESCRIPTION: A function that calculates and returns the inverse of a given quaternion.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_77\n\nLANGUAGE: c3\nCODE:\n```\nfn Quaternion Quaternion.invert(q)\n```\n\n----------------------------------------\n\nTITLE: Array Declaration and Manipulation in C3\nDESCRIPTION: Shows differences in array declaration, initialization, and pointer conversion between C and C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Overview/primer.md#2025-04-21_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nint x[2] = { 1, 2 };\nint *y = x;\n```\n\nLANGUAGE: c3\nCODE:\n```\nint[2] x = { 1, 2 };\nint* y = &x;\n```\n\n----------------------------------------\n\nTITLE: Defining PriorityQueue Types in C3\nDESCRIPTION: Defines PriorityQueue and PriorityQueueMax types using the PrivatePriorityQueue structure.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Standard Library/stdlib_refcard.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\ntypedef PriorityQueue = inline PrivatePriorityQueue{ Type, false };\n```\n\nLANGUAGE: c3\nCODE:\n```\ntypedef PriorityQueueMax = inline PrivatePriorityQueue{ Type, true };\n```\n\n----------------------------------------\n\nTITLE: Finding Index of Substring in String in C3\nDESCRIPTION: Function to find the index of a specified needle string within a string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_18\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! String.index_of(s, String needle)\n```\n\n----------------------------------------\n\nTITLE: C Language Interface Definition\nDESCRIPTION: Shows the C language interface for C3 Optional types and error handling.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/optionals-essential.md#2025-04-21_snippet_7\n\nLANGUAGE: c3\nCODE:\n```\n// C3 code:\nfn int! get_value();\n```\n\nLANGUAGE: c\nCODE:\n```\n// Corresponding C code:\nc3fault_t get_value(int *value_ref);\n```\n\n----------------------------------------\n\nTITLE: Bitwise and Shift Precedence Example in C3\nDESCRIPTION: Demonstrates the different precedence of bitwise and shift operations compared to arithmetic operations in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/precedence.md#2025-04-21_snippet_0\n\nLANGUAGE: c3\nCODE:\n```\na + b >> c + d\n```\n\nLANGUAGE: c3\nCODE:\n```\n(a + b) >> (c + d) // C (+ - are evaluated before >>)\na + (b >> c) + d   // C3 (>> is evaluated before + -)\n```\n\n----------------------------------------\n\nTITLE: Struct Member Access in C3\nDESCRIPTION: Shows how to access struct member information using membersof property.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Generic Programming/reflection.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\nstruct Baz\n{\n    int x;\n    Foo* z;\n}\nString x = Baz.membersof[1].nameof; // \"z\"\n```\n\n----------------------------------------\n\nTITLE: String to Unsigned Short Integer Conversion in C3\nDESCRIPTION: Converts a String to an unsigned short integer with an optional base.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_34\n\nLANGUAGE: c3\nCODE:\n```\nfn ushort? String.to_ushort(s, int base = 10) => s.to_integer(ushort, base);\n```\n\n----------------------------------------\n\nTITLE: DString Character Append Methods in C3\nDESCRIPTION: Functions for appending different character types to a DString.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_34\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_char(&self, char c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_char32(&self, Char32 c)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_chars(&self, String str)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_repeat(&self, char c, usz times)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_string(&self, DString str)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void DString.append_utf32(&self, Char32[] chars)\n```\n\n----------------------------------------\n\nTITLE: Concatenating Strings with Temporary Allocation in C3\nDESCRIPTION: Function to concatenate two strings using temporary allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_23\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tconcat(s1, String s2);\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn String String.tconcat(s1, String s2) => s1.concat(s2, allocator::temp());\n```\n\n----------------------------------------\n\nTITLE: Configuring CMake Build\nDESCRIPTION: Command to configure the CMake build system for C3 compiler.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nMyMachine:c3c/build$ cmake ../\n```\n\n----------------------------------------\n\nTITLE: Atomic Operations in C3\nDESCRIPTION: Functions and macros for atomic memory operations.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_48\n\nLANGUAGE: c3\nCODE:\n```\nmacro @atomic_load(&x, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void @atomic_store(&x, value, AtomicOrdering $ordering = SEQ_CONSISTENT, $volatile = false) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro compare_exchange(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT, bool $volatile = true, bool $weak = false, usz $alignment = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro compare_exchange_volatile(ptr, compare, value, AtomicOrdering $success = SEQ_CONSISTENT, AtomicOrdering $failure = SEQ_CONSISTENT)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @volatile_load(&x) @builtin\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @volatile_store(&x, y) @builtin\n```\n\n----------------------------------------\n\nTITLE: Cloning C3 Compiler Repository\nDESCRIPTION: Command to clone the C3 compiler source code from Github repository.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Getting Started/compile.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/c3lang/c3c.git\n```\n\n----------------------------------------\n\nTITLE: Memory Buffer Operations in C3\nDESCRIPTION: Functions for manipulating memory buffers.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_55\n\nLANGUAGE: c3\nCODE:\n```\nmacro void clear(void* dst, usz len, usz $dst_align = 0, bool $is_volatile = false, bool $inlined = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void clear_inline(void* dst, usz $len, usz $dst_align = 0, bool $is_volatile = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void copy(void* dst, void* src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false, bool $inlined = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void copy_inline(void* dst, void* src, usz $len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro bool equals(a, b, isz len = -1, usz $align = 0)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void move(void* dst, void* src, usz len, usz $dst_align = 0, usz $src_align = 0, bool $is_volatile = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void set(void* dst, char val, usz len, usz $dst_align = 0, bool $is_volatile = false)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void set_inline(void* dst, char val, usz $len, usz $dst_align = 0, bool $is_volatile = false)\n```\n\n----------------------------------------\n\nTITLE: Temporary Memory Allocation in C3\nDESCRIPTION: Functions and macros for temporary memory allocation.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_56\n\nLANGUAGE: c3\nCODE:\n```\nfn void* tcalloc(usz size, usz alignment = 0) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro temp_alloc($Type) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro temp_alloc_array($Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro temp_new($Type, ...) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro temp_new_array($Type, usz elements) @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void temp_pop(TempState old_state)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn TempState temp_push(TempAllocator* other = null)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* tmalloc(usz size, usz alignment = 0) @builtin @inline @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn void* trealloc(void* ptr, usz size, usz alignment = mem::DEFAULT_MEM_ALIGNMENT) @builtin @inline @nodiscard\n```\n\n----------------------------------------\n\nTITLE: Bitwise Operator Precedence Simplification\nDESCRIPTION: Shows the simplified and conflated precedence of bitwise operators in C3\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Rules/precedence.md#2025-04-21_snippet_3\n\nLANGUAGE: c3\nCODE:\n```\na | b ^ c & d\n```\n\nLANGUAGE: c3\nCODE:\n```\na | ((b ^ c) & d)  // C  (All bitwise operators have different precedence)\n((a | b) ^ c) & d  // C3 Error, requires parenthesis!\n```\n\n----------------------------------------\n\nTITLE: Checking String Ends With Substring in C3\nDESCRIPTION: Function to check if a string ends with a specified needle string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_15\n\nLANGUAGE: c3\nCODE:\n```\nfn bool String.ends_with(string, String needle);\n```\n\n----------------------------------------\n\nTITLE: Converting String to Temporary UTF-16 in C3\nDESCRIPTION: Function to convert a String to a temporary UTF-16 encoded Char16 array.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_5\n\nLANGUAGE: c3\nCODE:\n```\nfn Char16[]! String.to_temp_utf16(s);\n```\n\n----------------------------------------\n\nTITLE: Finding Index of Character in String in C3\nDESCRIPTION: Function to find the index of a specified character in a string.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_16\n\nLANGUAGE: c3\nCODE:\n```\nfn usz! String.index_of_char(s, char needle);\n```\n\n----------------------------------------\n\nTITLE: String to ZString Copy in C3\nDESCRIPTION: Creates a ZString copy of a String using the specified allocator.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Language Common/strings.md#2025-04-21_snippet_51\n\nLANGUAGE: c3\nCODE:\n```\nfn ZString String.zstr_copy(s, Allocator allocator = allocator::heap())\n```\n\n----------------------------------------\n\nTITLE: Memory Alignment Utilities in C3\nDESCRIPTION: Functions for handling memory alignment requirements.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_53\n\nLANGUAGE: c3\nCODE:\n```\nfn usz aligned_offset(usz offset, usz alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro void* aligned_pointer(void* ptr, usz alignment)\n```\n\nLANGUAGE: c3\nCODE:\n```\nfn bool ptr_is_aligned(void* ptr, usz alignment) @inline\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro type_alloc_must_be_aligned($Type)\n```\n\n----------------------------------------\n\nTITLE: Creating String Iterator in C3\nDESCRIPTION: Function to create an iterator for a String.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Language Common/strings.md#2025-04-21_snippet_32\n\nLANGUAGE: c3\nCODE:\n```\nfn StringIterator String.iterator(s);\n```\n\n----------------------------------------\n\nTITLE: Object Cloning in C3\nDESCRIPTION: Macros for cloning objects.\nSOURCE: https://github.com/c3lang/c3-web.git/blob/main/src/content/docs/Previous Versions/v0_6_8/Standard Library/stdlib_refcard.md#2025-04-21_snippet_51\n\nLANGUAGE: c3\nCODE:\n```\nmacro @clone(value) @builtin @nodiscard\n```\n\nLANGUAGE: c3\nCODE:\n```\nmacro @tclone(value) @builtin @nodiscard\n```"
  }
]