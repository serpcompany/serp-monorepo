[
  {
    "owner": "unnoq",
    "repo": "orpc",
    "content": "TITLE: Implementing API Router with TypeScript and oRPC Server\nDESCRIPTION: Example showing how to create an API router with CRUD operations for a Planet resource using oRPC server. Demonstrates input validation with Zod schemas, middleware usage for authentication, and type-safe handlers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/server/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { IncomingHttpHeaders } from 'node:http'\nimport { ORPCError, os } from '@orpc/server'\nimport { z } from 'zod'\n\nconst PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanet = os\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .handler(async ({ input }) => {\n    // your list code here\n    return [{ id: 1, name: 'name' }]\n  })\n\nexport const findPlanet = os\n  .input(PlanetSchema.pick({ id: true }))\n  .handler(async ({ input }) => {\n    // your find code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const createPlanet = os\n  .$context<{ headers: IncomingHttpHeaders }>()\n  .use(({ context, next }) => {\n    const user = parseJWT(context.headers.authorization?.split(' ')[1])\n\n    if (user) {\n      return next({ context: { user } })\n    }\n\n    throw new ORPCError('UNAUTHORIZED')\n  })\n  .input(PlanetSchema.omit({ id: true }))\n  .handler(async ({ input, context }) => {\n    // your create code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const router = { planet: { list: listPlanet, find: findPlanet, create: createPlanet } }\n```\n\n----------------------------------------\n\nTITLE: Creating an oRPC Client\nDESCRIPTION: TypeScript code for creating an oRPC client. It sets up a client with a fetch-based link and exports a type-safe client object for making RPC calls.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/getting-started.md#2025-04-21_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport type { RouterClient } from '@orpc/server'\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\n\nconst link = new RPCLink({\n  url: 'http://127.0.0.1:3000',\n  headers: { Authorization: 'Bearer token' },\n})\n\nexport const orpc: RouterClient<typeof router> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Creating oRPC Client with Fetch Link\nDESCRIPTION: Demonstrates how to create a type-safe oRPC client using the fetch link. The client is configured with a base URL and authentication headers, leveraging TypeScript to ensure end-to-end type safety.\nSOURCE: https://github.com/unnoq/orpc/blob/main/README.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { RouterClient } from '@orpc/server'\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\n\nconst link = new RPCLink({\n  url: 'http://127.0.0.1:3000',\n  headers: { Authorization: 'Bearer token' },\n})\n\nexport const orpc: RouterClient<typeof router> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Calling oRPC Procedures\nDESCRIPTION: TypeScript code demonstrating how to call oRPC procedures using the created client. It shows type-safety and auto-completion features.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/getting-started.md#2025-04-21_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst planet = await orpc.planet.find({ id: 1 })\n\norpc.planet.create\n```\n\n----------------------------------------\n\nTITLE: Defining App Router with oRPC and Zod\nDESCRIPTION: TypeScript code defining an app router using oRPC and Zod for schema validation. It includes procedures for listing, finding, and creating planets with input validation and error handling.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/getting-started.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport type { IncomingHttpHeaders } from 'node:http'\nimport { ORPCError, os } from '@orpc/server'\nimport { z } from 'zod'\n\nconst PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanet = os\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .handler(async ({ input }) => {\n    // your list code here\n    return [{ id: 1, name: 'name' }]\n  })\n\nexport const findPlanet = os\n  .input(PlanetSchema.pick({ id: true }))\n  .handler(async ({ input }) => {\n    // your find code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const createPlanet = os\n  .$context<{ headers: IncomingHttpHeaders }>()\n  .use(({ context, next }) => {\n    const user = parseJWT(context.headers.authorization?.split(' ')[1])\n\n    if (user) {\n      return next({ context: { user } })\n    }\n\n    throw new ORPCError('UNAUTHORIZED')\n  })\n  .input(PlanetSchema.omit({ id: true }))\n  .handler(async ({ input, context }) => {\n    // your create code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const router = {\n  planet: {\n    list: listPlanet,\n    find: findPlanet,\n    create: createPlanet\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an oRPC Client with Fetch Link in TypeScript\nDESCRIPTION: This code snippet demonstrates how to create an oRPC client using the fetch link implementation. It shows setting up authorization headers and creating clients for both router and contract-based APIs.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/client/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\nimport { ContractRouterClient } from '@orpc/contract'\nimport { RouterClient } from '@orpc/server'\n\nconst link = new RPCLink({\n  url: 'http://localhost:3000/rpc',\n  headers: () => ({\n    authorization: 'Bearer token',\n  }),\n  // fetch: <-- provide fetch polyfill fetch if needed\n})\n\n// Create a client for your router\nconst client: RouterClient<typeof router> = createORPCClient(link)\n// Or, create a client using a contract\nconst client: ContractRouterClient<typeof contract> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Defining API Contracts with oRPC and Zod in TypeScript\nDESCRIPTION: Demonstrates how to create an API contract using oRPC and Zod for schema validation. It defines schemas and contracts for listing, finding, and creating planets.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/contract/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanetContract = oc\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .output(z.array(PlanetSchema))\n\nexport const findPlanetContract = oc\n  .input(PlanetSchema.pick({ id: true }))\n  .output(PlanetSchema)\n\nexport const createPlanetContract = oc\n  .input(PlanetSchema.omit({ id: true }))\n  .output(PlanetSchema)\n\nexport const contract = {\n  planet: {\n    list: listPlanetContract,\n    find: findPlanetContract,\n    create: createPlanetContract,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC Packages\nDESCRIPTION: Commands for installing @orpc/server and @orpc/client using different package managers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/getting-started.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/server@latest @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/server@latest @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/server@latest @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/server@latest @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/server@latest npm:@orpc/client@latest\n```\n\n----------------------------------------\n\nTITLE: Defining oRPC Router with Schema Validation and Middleware\nDESCRIPTION: Demonstrates how to define an oRPC router with Zod schema validation, handler implementation, and middleware for authentication. The example shows CRUD operations for a planet resource with input validation and context handling.\nSOURCE: https://github.com/unnoq/orpc/blob/main/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { IncomingHttpHeaders } from 'node:http'\nimport { ORPCError, os } from '@orpc/server'\nimport { z } from 'zod'\n\nconst PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanet = os\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .handler(async ({ input }) => {\n    // your list code here\n    return [{ id: 1, name: 'name' }]\n  })\n\nexport const findPlanet = os\n  .input(PlanetSchema.pick({ id: true }))\n  .handler(async ({ input }) => {\n    // your find code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const createPlanet = os\n  .$context<{ headers: IncomingHttpHeaders }>()\n  .use(({ context, next }) => {\n    const user = parseJWT(context.headers.authorization?.split(' ')[1])\n\n    if (user) {\n      return next({ context: { user } })\n    }\n\n    throw new ORPCError('UNAUTHORIZED')\n  })\n  .input(PlanetSchema.omit({ id: true }))\n  .handler(async ({ input, context }) => {\n    // your create code here\n    return { id: 1, name: 'name' }\n  })\n\nexport const router = {\n  planet: {\n    list: listPlanet,\n    find: findPlanet,\n    create: createPlanet\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing RPCLink for oRPC Client in TypeScript\nDESCRIPTION: Basic setup for creating an RPCLink instance to communicate with an RPC server. This configures the URL endpoint, headers for authentication, and creates an oRPC client with the link.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/rpc-link.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\n\nconst link = new RPCLink({\n  url: 'http://localhost:3000/rpc',\n  headers: () => ({\n    'x-api-key': 'my-api-key'\n  }),\n  // fetch: <-- polyfill fetch if needed\n})\n\nexport const client: RouterClient<typeof router> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Setting up RPCHandler with Plugins and Error Handling in TypeScript\nDESCRIPTION: Example of initializing an RPCHandler with CORS plugin support and error handling interceptors. The code demonstrates how to create a handler instance and integrate it into a fetch function to process incoming requests with proper routing and context management.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/rpc-handler.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch' // or '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\nimport { onError } from '@orpc/server'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ],\n  interceptors: [\n    onError((error) => {\n      console.error(error)\n    })\n  ],\n})\n\nexport default async function fetch(request: Request) {\n  const { matched, response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if required\n  })\n\n  if (matched) {\n    return response\n  }\n\n  return new Response('Not Found', { status: 404 })\n}\n```\n\n----------------------------------------\n\nTITLE: Creating oRPC Client Configuration\nDESCRIPTION: Setup of an oRPC client using RPCLink with authentication headers and optional fetch polyfill. Demonstrates creation of both router-based and contract-based clients.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/client-side.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\nimport { RouterClient } from '@orpc/server'\nimport { ContractRouterClient } from '@orpc/contract'\n\nconst link = new RPCLink({\n  url: 'http://localhost:3000/rpc',\n  headers: () => ({\n    authorization: 'Bearer token',\n  }),\n  // fetch: <-- provide fetch polyfill fetch if needed\n})\n\n// Create a client for your router\nconst client: RouterClient<typeof router> = createORPCClient(link)\n// Or, create a client using a contract\nconst client: ContractRouterClient<typeof contract> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Defining API Endpoint with oRPC in TypeScript\nDESCRIPTION: This snippet demonstrates how to define an API endpoint using oRPC. It showcases various features like middleware usage, input validation, error handling, and compatibility with server actions and regular function calls.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/blog/v1-announcement.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst getting = os\n  .use(dbProvider)\n  .use(requiredAuth)\n  .use(rateLimit)\n  .use(analytics)\n  .use(sentryMonitoring)\n  .use(retry({ times: 3 }))\n  .route({ method: 'GET', path: '/getting/{id}' })\n  .input(z.object({ id: z.string() }))\n  .use(canGetting, input => input.id)\n  .errors({\n    SOME_TYPE_SAFE_ERROR: {\n      data: z.object({ something: z.string() })\n    }\n  })\n  .handler(async ({ input, errors, context }) => {\n    // do something\n  })\n  .actionable() // server action compatible\n  .callable() // regular function compatible\n```\n\n----------------------------------------\n\nTITLE: Complete Contract Implementation Example in TypeScript\nDESCRIPTION: A full implementation example of an oRPC contract showing how to implement multiple procedures and assemble them into a router for runtime contract enforcement.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/implement-contract.md#2025-04-21_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst os = implement(contract)\n\nexport const listPlanet = os.planet.list\n  .handler(({ input }) => {\n    return []\n  })\n\nexport const findPlanet = os.planet.find\n  .handler(({ input }) => {\n    return { id: 123, name: 'Planet X' }\n  })\n\nexport const createPlanet = os.planet.create\n  .handler(({ input }) => {\n    return { id: 123, name: 'Planet X' }\n  })\n\nexport const router = os.router({\n  planet: {\n    list: listPlanet,\n    find: findPlanet,\n    create: createPlanet,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Specs from Valibot Schemas in TypeScript\nDESCRIPTION: This code demonstrates how to generate OpenAPI specifications from Valibot schemas using the OpenAPIGenerator from @orpc/openapi and the ValibotToJsonSchemaConverter from @orpc/valibot. It shows generation from both a contract and a router.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/valibot/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAPIGenerator } from '@orpc/openapi'\nimport { experimental_ValibotToJsonSchemaConverter as ValibotToJsonSchemaConverter } from '@orpc/valibot'\n\nconst openAPIGenerator = new OpenAPIGenerator({\n  schemaConverters: [\n    new ValibotToJsonSchemaConverter()\n  ],\n})\n\nconst specFromContract = await openAPIGenerator.generate(contract, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n\nconst specFromRouter = await openAPIGenerator.generate(router, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Specifications with oRPC\nDESCRIPTION: Shows how to generate OpenAPI specifications from either a contract or router using the OpenAPIGenerator with the ZodToJsonSchemaConverter from @orpc/zod.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/zod/README.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAPIGenerator } from '@orpc/openapi'\nimport { ZodToJsonSchemaConverter } from '@orpc/zod'\n\nconst openAPIGenerator = new OpenAPIGenerator({\n  schemaConverters: [new ZodToJsonSchemaConverter()],\n})\n\nconst specFromContract = await openAPIGenerator.generate(contract, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n\nconst specFromRouter = await openAPIGenerator.generate(router, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing OpenAI Streaming with oRPC in TypeScript\nDESCRIPTION: This snippet demonstrates how to create an oRPC handler that streams OpenAI chat completions and how to consume the stream using an oRPC client. It uses the OpenAI API with GPT-4o model and implements an async generator to yield streaming responses.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/examples/openai-streaming.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport OpenAI from 'openai'\n\nconst openapi = new OpenAI()\n\nconst complete = os\n  .input(z.object({ content: z.string() }))\n  .handler(async function* ({ input }) {\n    const stream = await openapi.chat.completions.create({\n      model: 'gpt-4o',\n      messages: [{ role: 'user', content: input.content }],\n      stream: true,\n    })\n\n    yield* stream\n  })\n\nconst router = { complete }\n\nconst link = new RPCLink({\n  url: 'https://example.com/rpc',\n})\n\nconst client: RouterClient<typeof router> = createORPCClient(link)\n\nconst stream = await client.complete({ content: 'Hello, world!' })\n\nfor await (const chunk of stream) {\n  console.log(chunk.choices[0]?.delta?.content || '')\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe Error Handling in oRPC (TypeScript)\nDESCRIPTION: Shows how to define and use type-safe error handling in oRPC. It includes defining common errors, creating middleware, and handling errors in a type-safe manner using the .errors method.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/error-handling.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.errors({ // <-- common errors\n  RATE_LIMITED: {\n    data: z.object({\n      retryAfter: z.number(),\n    }),\n  },\n  UNAUTHORIZED: {},\n})\n\nconst rateLimit = base.middleware(async ({ next, errors }) => {\n  throw errors.RATE_LIMITED({\n    message: 'You are being rate limited',\n    data: { retryAfter: 60 }\n  })\n  return next()\n})\n\nconst example = base\n  .use(rateLimit)\n  .errors({\n    NOT_FOUND: {\n      message: 'The resource was not found', // <-- default message\n    },\n  })\n  .handler(async ({ input, errors }) => {\n    throw errors.NOT_FOUND()\n  })\n```\n\n----------------------------------------\n\nTITLE: Using Inline Middleware in oRPC with TypeScript\nDESCRIPTION: Shows how to define and use inline middleware within the .use method. This approach is useful for simple middleware functions that don't require separate definition.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .use(async ({ context, next }) => {\n    // Execute logic before the handler\n    return next()\n  })\n  .handler(async ({ context }) => {\n    // Handler logic\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing a Full Planet Service Contract in TypeScript\nDESCRIPTION: Provides a complete example of defining a contract for a Planet service, including schemas and multiple procedure contracts.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod'\nimport { oc } from '@orpc/contract'\n\nexport const PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanetContract = oc\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .output(z.array(PlanetSchema))\n\nexport const findPlanetContract = oc\n  .input(PlanetSchema.pick({ id: true }))\n  .output(PlanetSchema)\n\nexport const createPlanetContract = oc\n  .input(PlanetSchema.omit({ id: true }))\n  .output(PlanetSchema)\n\nexport const contract = {\n  planet: {\n    list: listPlanetContract,\n    find: findPlanetContract,\n    create: createPlanetContract,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Creating an oRPC Server with Node.js\nDESCRIPTION: TypeScript code for creating an oRPC server using Node.js. It sets up an HTTP server with CORS support and handles RPC requests using the defined router.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/getting-started.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { createServer } from 'node:http'\nimport { RPCHandler } from '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [new CORSPlugin()]\n})\n\nconst server = createServer(async (req, res) => {\n  const result = await handler.handle(req, res, {\n    context: { headers: req.headers }\n  })\n\n  if (!result.matched) {\n    res.statusCode = 404\n    res.end('No procedure matched')\n  }\n})\n\nserver.listen(\n  3000,\n  '127.0.0.1',\n  () => console.log('Listening on 127.0.0.1:3000')\n)\n```\n\n----------------------------------------\n\nTITLE: Combining Normal and Type-Safe Error Handling in oRPC (TypeScript)\nDESCRIPTION: Illustrates how to combine both normal and type-safe error handling approaches in oRPC. It shows defining errors, using them in middleware, and throwing both predefined and custom errors.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/error-handling.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.errors({ // <-- common errors\n  RATE_LIMITED: {\n    data: z.object({\n      retryAfter: z.number().int().min(1).default(1),\n    }),\n  },\n  UNAUTHORIZED: {},\n})\n\nconst rateLimit = base.middleware(async ({ next, errors }) => {\n  throw errors.RATE_LIMITED({\n    message: 'You are being rate limited',\n    data: { retryAfter: 60 }\n  })\n  // OR --- both are equivalent\n  throw new ORPCError('RATE_LIMITED', {\n    message: 'You are being rate limited',\n    data: { retryAfter: 60 }\n  })\n  return next()\n})\n\nconst example = base\n  .use(rateLimit)\n  .handler(async ({ input }) => {\n    throw new ORPCError('BAD_REQUEST') // <-- unknown error\n  })\n```\n\n----------------------------------------\n\nTITLE: Initializing oRPC Handler with Cloudflare Workers\nDESCRIPTION: Sets up an oRPC handler with CORS support for Cloudflare Workers environment. The code creates a fetch handler that processes RPC requests at the '/rpc' endpoint and returns a 404 response for unmatched routes. It includes context injection capability and uses the CORSPlugin for cross-origin requests.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/cloudflare-workers.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ]\n})\n\nexport default {\n  async fetch(request: Request, env: any, ctx: ExecutionContext): Promise<Response> {\n    const { matched, response } = await handler.handle(request, {\n      prefix: '/rpc',\n      context: {} // Provide initial context if needed\n    })\n\n    if (matched) {\n      return response\n    }\n\n    return new Response('Not found', { status: 404 })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler with Next.js App Router\nDESCRIPTION: Sets up an oRPC handler for Next.js App Router by creating route handlers for all HTTP methods. The handler processes requests with a specified prefix and optional context.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/nextjs.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nasync function handleRequest(request: Request) {\n  const { response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {}, // Provide initial context if needed\n  })\n\n  return response ?? new Response('Not found', { status: 404 })\n}\n\nexport const GET = handleRequest\nexport const POST = handleRequest\nexport const PUT = handleRequest\nexport const PATCH = handleRequest\nexport const DELETE = handleRequest\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Injection and Guarding in oRPC Middleware\nDESCRIPTION: Illustrates how middleware can be used to inject and guard context in oRPC. It shows context injection, authentication guarding, and context access within the handler.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst setting = os\n  .use(async ({ context, next }) => {\n    return next({\n      context: {\n        auth: await auth() // <-- inject auth payload\n      }\n    })\n  })\n  .use(async ({ context, next }) => {\n    if (!context.auth) { // <-- guard auth\n      throw new ORPCError('UNAUTHORIZED')\n    }\n\n    return next({\n      context: {\n        auth: context.auth // <-- override auth\n      }\n    })\n  })\n  .handler(async ({ context }) => {\n    console.log(context.auth) // <-- access auth\n  })\n```\n\n----------------------------------------\n\nTITLE: Combining Initial and Execution Context in oRPC with TypeScript\nDESCRIPTION: This snippet shows how to combine initial and execution contexts in oRPC. It demonstrates using initial context for environment-specific values and middleware for runtime data like user authentication and database connections.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/context.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$context<{ headers: Headers, env: { DB_URL: string } }>()\n\nconst requireAuth = base.middleware(async ({ context, next }) => {\n  const user = parseJWT(context.headers.get('authorization')?.split(' ')[1])\n\n  if (user) {\n    return next({ context: { user } })\n  }\n\n  throw new ORPCError('UNAUTHORIZED')\n})\n\nconst dbProvider = base.middleware(async ({ context, next }) => {\n  const client = new Client(context.env.DB_URL)\n\n  try {\n    await client.connect()\n    return next({ context: { db: client } })\n  }\n  finally {\n    await client.disconnect()\n  }\n})\n\nconst getting = base\n  .use(dbProvider)\n  .use(requireAuth)\n  .handler(async ({ context }) => {\n    console.log(context.db)\n    console.log(context.user)\n  })\n```\n\n----------------------------------------\n\nTITLE: Creating a Contract Router in TypeScript\nDESCRIPTION: Shows how to organize defined contracts into a structured hierarchy using a contract router.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const routerContract = {\n  example: exampleContract,\n  nested: {\n    example: exampleContract,\n  },\n}\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Specification from oRPC Router\nDESCRIPTION: Shows how to generate an OpenAPI specification from an oRPC router using the OpenAPIGenerator. The example includes configuring schema converters for Zod and defining API metadata.\nSOURCE: https://github.com/unnoq/orpc/blob/main/README.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAPIGenerator } from '@orpc/openapi'\nimport { ZodToJsonSchemaConverter } from '@orpc/zod'\n\nconst generator = new OpenAPIGenerator({\n  schemaConverters: [new ZodToJsonSchemaConverter()]\n})\n\nconst spec = await generator.generate(router, {\n  info: {\n    title: 'Planet API',\n    version: '1.0.0'\n  }\n})\n\nconsole.log(spec)\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Middleware in oRPC with TypeScript\nDESCRIPTION: Demonstrates how to create and use a basic middleware function in oRPC. The middleware intercepts the handler execution, allows for context modification, and can perform actions before and after the handler.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst authMiddleware = os\n  .$context<{ something?: string }>() // <-- define dependent-context\n  .middleware(async ({ context, next }) => {\n    // Execute logic before the handler\n\n    const result = await next({\n      context: { // Pass additional context\n        user: { id: 1, name: 'John' }\n      }\n    })\n\n    // Execute logic after the handler\n\n    return result\n  })\n\nconst example = os\n  .use(authMiddleware)\n  .handler(async ({ context }) => {\n    const user = context.user\n  })\n```\n\n----------------------------------------\n\nTITLE: Concatenating Multiple Middleware Functions in oRPC\nDESCRIPTION: Demonstrates how to combine multiple middleware functions using the .concat method. This allows for creating more complex middleware chains.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst concatMiddleware = aMiddleware\n  .concat(os.middleware(async ({ next }) => next()))\n  .concat(anotherMiddleware)\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler in Remix Route\nDESCRIPTION: This code snippet demonstrates how to set up an RPCHandler in a Remix route file. It creates a new RPCHandler instance and defines a loader function to handle incoming requests. The handler processes requests with a '/rpc' prefix and returns the response or a 404 Not Found status if no response is generated.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/remix.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nexport async function loader({ request }: LoaderFunctionArgs) {\n  const { response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  return response ?? new Response('Not Found', { status: 404 })\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up oRPC Server with OpenAPI and Scalar Integration\nDESCRIPTION: Creates an HTTP server that serves both the API endpoints and OpenAPI specification. Configures OpenAPI handler with CORS and Zod plugins, generates OpenAPI spec, and serves a Scalar-powered API client interface.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/scalar.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'node:http'\nimport { OpenAPIGenerator } from '@orpc/openapi'\nimport { OpenAPIHandler } from '@orpc/openapi/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\nimport { ZodSmartCoercionPlugin, ZodToJsonSchemaConverter } from '@orpc/zod'\n\nconst openAPIHandler = new OpenAPIHandler(router, {\n  plugins: [\n    new CORSPlugin(),\n    new ZodSmartCoercionPlugin(),\n  ],\n})\n\nconst openAPIGenerator = new OpenAPIGenerator({\n  schemaConverters: [\n    new ZodToJsonSchemaConverter(),\n  ],\n})\n\nconst server = createServer(async (req, res) => {\n  const { matched } = await openAPIHandler.handle(req, res, {\n    prefix: '/api',\n  })\n\n  if (matched) {\n    return\n  }\n\n  if (req.url === '/spec.json') {\n    const spec = await openAPIGenerator.generate(router, {\n      info: {\n        title: 'My Playground',\n        version: '1.0.0',\n      },\n      servers: [\n        { url: '/api' }, /** Should use absolute URLs in production */\n      ],\n      security: [{ bearerAuth: [] }],\n      components: {\n        securitySchemes: {\n          bearerAuth: {\n            type: 'http',\n            scheme: 'bearer',\n          },\n        },\n      },\n    })\n\n    res.writeHead(200, { 'Content-Type': 'application/json' })\n    res.end(JSON.stringify(spec))\n    return\n  }\n\n  const html = `\n    <!doctype html>\n    <html>\n      <head>\n        <title>My Client</title>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n        <link rel=\"icon\" type=\"image/svg+xml\" href=\"https://orpc.unnoq.com/icon.svg\" />\n      </head>\n      <body>\n        <script\n          id=\"api-reference\"\n          data-url=\"/spec.json\"\n          data-configuration=\"${JSON.stringify({\n            authentication: {\n              preferredSecurityScheme: 'bearerAuth',\n              http: {\n                bearer: { token: 'default-token' },\n              },\n            },\n          }).replaceAll('\"', '&quot;')}\">\n        </script>\n        <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n      </body>\n    </html>\n  `\n\n  res.writeHead(200, { 'Content-Type': 'text/html' })\n  res.end(html)\n})\n\nserver.listen(3000, () => {\n  console.log('Playground is available at http://localhost:3000')\n})\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC with Vue Query in TypeScript\nDESCRIPTION: Demonstrates how to use oRPC with Vue Query, including setting up queries, mutations, and query invalidation. It showcases typesafe API interactions and various configuration options.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/vue-query/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function Setup() {\n  const query = useQuery(orpc.planet.find.queryOptions({\n    input: { id: 123 }, // Specify input if needed\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  const query = useInfiniteQuery(orpc.planet.list.infiniteOptions({\n    input: (pageParam: number | undefined) => ({ limit: 10, offset: pageParam }),\n    context: { cache: true }, // Provide client context if needed\n    initialPageParam: undefined,\n    getNextPageParam: lastPage => lastPage.nextPageParam,\n  // additional options...\n  }))\n\n  const mutation = useMutation(orpc.planet.create.mutationOptions({\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  mutation.mutate({ name: 'Earth' })\n\n  const queryClient = useQueryClient()\n\n  // Invalidate all planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key(),\n  })\n\n  // Invalidate only regular (non-infinite) planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key({ type: 'query' })\n  })\n\n  // Invalidate the planet find query with id 123\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.find.key({ input: { id: 123 } })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Router Implementation in TypeScript\nDESCRIPTION: Demonstrates the basic setup of an oRPC router with simple ping/pong procedures and nested routing structure.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { os } from '@orpc/server'\n\nconst ping = os.handler(async () => 'ping')\nconst pong = os.handler(async () => 'pong')\n\nconst router = {\n  ping,\n  pong,\n  nested: { ping, pong }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Client Retry Plugin with oRPC Client\nDESCRIPTION: Demonstrates how to set up the Client Retry Plugin with an oRPC client. This example shows importing necessary components, configuring the RPCLink with the ClientRetryPlugin, and creating the client instance with retry functionality.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/client-retry.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\nimport { ClientRetryPlugin, ClientRetryPluginContext } from '@orpc/client/plugins'\n\ninterface ORPCClientContext extends ClientRetryPluginContext {}\n\nconst link = new RPCLink<ORPCClientContext>({\n  url: 'http://localhost:3000/rpc',\n  plugins: [\n    new ClientRetryPlugin({\n      default: { // Optional override for default options\n        retry: ({ path }) => {\n          if (path.join('.') === 'planet.list') {\n            return 2\n          }\n\n          return 0\n        }\n      },\n    }),\n  ],\n})\n\nconst client: RouterClient<typeof router, ORPCClientContext> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Mutations with oRPC and Tanstack Query\nDESCRIPTION: Use the mutationOptions utility to create options for mutations with hooks like useMutation. This allows executing mutations with type-safe inputs and handling responses.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst mutation = useMutation(orpc.planet.create.mutationOptions({\n  context: { cache: true }, // Provide client context if needed\n  // additional options...\n}))\n\nmutation.mutate({ name: 'Earth' })\n```\n\n----------------------------------------\n\nTITLE: Implementing Execution Context with Middleware in oRPC\nDESCRIPTION: This snippet illustrates how to implement execution context using middleware in oRPC. It shows the creation of a base context that uses middleware to add headers and cookies to the context during execution.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/context.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cookies, headers } from 'next/headers'\n\nconst base = os.use(async ({ next }) => next({\n  context: {\n    headers: await headers(),\n    cookies: await cookies(),\n  },\n}))\n\nconst getting = base.handler(async ({ context }) => {\n  context.cookies.set('key', 'value')\n})\n\nexport const router = { getting }\n```\n\n----------------------------------------\n\nTITLE: Using oRPC with React Query Hooks\nDESCRIPTION: Example showing how to use oRPC with React Query hooks including useQuery, useInfiniteQuery, and useMutation. Demonstrates query invalidation patterns and context handling.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/react-query/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function Example() {\n  const query = useQuery(orpc.planet.find.queryOptions({\n    input: { id: 123 }, // Specify input if needed\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  const query = useInfiniteQuery(orpc.planet.list.infiniteOptions({\n    input: (pageParam: number | undefined) => ({ limit: 10, offset: pageParam }),\n    context: { cache: true }, // Provide client context if needed\n    initialPageParam: undefined,\n    getNextPageParam: lastPage => lastPage.nextPageParam,\n  // additional options...\n  }))\n\n  const mutation = useMutation(orpc.planet.create.mutationOptions({\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  mutation.mutate({ name: 'Earth' })\n\n  const queryClient = useQueryClient()\n\n  // Invalidate all planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key(),\n  })\n\n  // Invalidate only regular (non-infinite) planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key({ type: 'query' })\n  })\n\n  // Invalidate the planet find query with id 123\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.find.key({ input: { id: 123 } })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Consuming oRPC API with Type-Safe Client\nDESCRIPTION: Shows how to use the type-safe oRPC client to make API calls. The example demonstrates calling the list procedure with proper input parameters while maintaining full type safety.\nSOURCE: https://github.com/unnoq/orpc/blob/main/README.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { orpc } from './client'\n\nconst planets = await orpc.planet.list({ limit: 10 })\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR-Compatible oRPC Client\nDESCRIPTION: Sets up an isomorphic oRPC client that works in both server-side and client-side contexts, handling headers appropriately for SSR.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/tanstack-start.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\nimport { ContractRouterClient } from '@orpc/contract'\nimport { getHeaders } from '@tanstack/react-start/server'\nimport { contract } from '@/lib/contract'\n\nexport const link = new RPCLink({\n  url: 'http://localhost:8080/rpc',\n  headers: () => {\n    // For server-side rendering\n    if (typeof window === 'undefined') {\n      return getHeaders()\n    }\n    // For client-side rendering\n    return {}\n  },\n})\n\nexport const api: ContractRouterClient<typeof contract> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Overriding Built-in Undefined Type Serializer in TypeScript\nDESCRIPTION: This example demonstrates how to override the built-in undefined type serializer. It creates a custom serializer that represents undefined as null in JSON and matches the built-in type number for undefined.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-json-serializer.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { StandardRPCCustomJsonSerializer } from '@orpc/client/standard'\n\nexport const undefinedSerializer: StandardRPCCustomJsonSerializer = {\n  type: 3, // Match the built-in undefined type. [!code highlight]\n  condition: data => data === undefined,\n  serialize: data => null, // JSON cannot represent undefined, so use null.\n  deserialize: data => undefined,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Procedure Contract in TypeScript\nDESCRIPTION: Demonstrates how to define a procedure contract using the @orpc/contract package and Zod for input and output validation.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod'\nimport { oc } from '@orpc/contract'\n\nexport const exampleContract = oc\n  .input(\n    z.object({\n      name: z.string(),\n      age: z.number().int().min(0),\n    }),\n  )\n  .output(\n    z.object({\n      id: z.number().int().min(0),\n      name: z.string(),\n      age: z.number().int().min(0),\n    }),\n  )\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe Validation Errors in TypeScript\nDESCRIPTION: This snippet demonstrates how to create type-safe validation errors in oRPC. It defines a base error schema and uses it to create a custom error handler that throws type-safe ORPCError instances for input validation failures.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/validation-errors.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { onError, ORPCError, os, ValidationError } from '@orpc/server'\nimport { z, ZodError } from 'zod'\nimport type { ZodIssue } from 'zod'\n\nconst base = os.errors({\n  INPUT_VALIDATION_FAILED: {\n    data: z.object({\n      formErrors: z.array(z.string()),\n      fieldErrors: z.record(z.string(), z.array(z.string()).optional()),\n    }),\n  },\n})\n\nconst example = base\n  .input(z.object({ id: z.string().uuid() }))\n  .handler(() => { /** do something */ })\n\nconst handler = new RPCHandler({ example }, {\n  clientInterceptors: [\n    onError((error) => {\n      if (\n        error instanceof ORPCError\n        && error.code === 'BAD_REQUEST'\n        && error.cause instanceof ValidationError\n      ) {\n        // If you only use Zod you can safely cast to ZodIssue[]\n        const zodError = new ZodError(error.cause.issues as ZodIssue[])\n\n        throw new ORPCError('INPUT_VALIDATION_FAILED', {\n          status: 422,\n          data: zodError.flatten(),\n          cause: error.cause,\n        })\n      }\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Node.js HTTP Server with oRPC Handler\nDESCRIPTION: Shows how to set up a Node.js HTTP server that uses the oRPC handler to process API requests. The example includes CORS plugin integration and basic request handling with context passing.\nSOURCE: https://github.com/unnoq/orpc/blob/main/README.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'node:http'\nimport { RPCHandler } from '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [new CORSPlugin()]\n})\n\nconst server = createServer(async (req, res) => {\n  const result = await handler.handle(req, res, {\n    context: { headers: req.headers }\n  })\n\n  if (!result.matched) {\n    res.statusCode = 404\n    res.end('No procedure matched')\n  }\n})\n\nserver.listen(\n  3000,\n  '127.0.0.1',\n  () => console.log('Listening on 127.0.0.1:3000')\n)\n```\n\n----------------------------------------\n\nTITLE: Initializing Server-Side oRPC Client\nDESCRIPTION: Creates and globally registers the server-side oRPC client that will be used during SSR. This file should only be imported on the server to prevent router logic from leaking to the client.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n'server only'\n\nimport { createRouterClient } from '@orpc/server'\n\nglobalThis.$client = createRouterClient(router, {\n  /**\n   * Provide initial context if needed.\n   *\n   * Because this client instance is shared across all requests,\n   * only include context that's safe to reuse globally.\n   * For per-request context, use middleware context or pass a function as the initial context.\n   */\n  context: async () => ({\n    headers: await headers(),\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Detailed Input Type Definition in oRPC (TypeScript)\nDESCRIPTION: Defines the type structure for detailed input mode, specifying the shape of params, query, body, and headers objects.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport type DetailedInput = {\n  params: Record<string, string> | undefined\n  query: any\n  body: any\n  headers: Record<string, string | string[] | undefined>\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Zod Schemas with oRPC Extensions\nDESCRIPTION: Demonstrates how to use the extended Zod schemas provided by @orpc/zod to validate URL, Blob, File, and RegExp instances, which aren't natively supported by Zod.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/zod/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { oz } from '@orpc/zod'\nimport { z } from 'zod'\n\nconst Example = z.object({\n  url: oz.url(),\n  blob: oz.blob(),\n  file: oz.file().type('image/png'),\n  regexp: oz.regexp(),\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Output Modification in oRPC Middleware\nDESCRIPTION: Shows how middleware can modify the output of a handler, such as implementing caching mechanisms. This example demonstrates caching based on input and path.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst cacheMid = os.middleware(async ({ context, next, path }, input, output) => {\n  const cacheKey = path.join('/') + JSON.stringify(input)\n\n  if (db.has(cacheKey)) {\n    return output(db.get(cacheKey))\n  }\n\n  const result = await next({})\n\n  db.set(cacheKey, result.output)\n\n  return result\n})\n```\n\n----------------------------------------\n\nTITLE: Validating Event Iterator Output with Schema\nDESCRIPTION: Using oRPC's built-in eventIterator helper with a Schema validation library to ensure events conform to an expected structure. This example validates that each event contains a message string property.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/event-iterator.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { eventIterator } from '@orpc/server'\n\nconst example = os\n  .output(eventIterator(z.object({ message: z.string() })))\n  .handler(async function* ({ input, lastEventId }) {\n    while (true) {\n      yield { message: 'Hello, world!' }\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Initializing oRPC React Query Utils\nDESCRIPTION: Setup code for creating oRPC React Query utilities with a configured client instance.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createORPCReactQueryUtils } from '@orpc/react-query'\n\nexport const orpc = createORPCReactQueryUtils(client)\n\norpc.planet.find.queryOptions({ input: { id: 123 } })\n```\n\n----------------------------------------\n\nTITLE: Customizing Error Responses in oRPC with TypeScript\nDESCRIPTION: This snippet demonstrates how to override default error mappings in oRPC. It shows creating custom errors with specific status codes and messages, both through the errors configuration and by throwing an ORPCError.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/error-handling.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .errors({\n    RANDOM_ERROR: {\n      status: 503, // <-- override default status\n      message: 'Default error message', // <-- override default message\n    },\n  })\n  .handler(() => {\n    throw new ORPCError('ANOTHER_RANDOM_ERROR', {\n      status: 502, // <-- override default status\n      message: 'Custom error message', // <-- override default message\n    })\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC with Vue and Pinia Colada\nDESCRIPTION: This code snippet demonstrates how to use oRPC with Pinia Colada for managing API requests. It shows how to create queries and mutations, specify input parameters, provide client context, and invalidate the query cache.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/vue-colada/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function Setup() {\n  const query = useQuery(orpc.planet.find.queryOptions({\n    input: { id: 123 }, // Specify input if needed\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  const mutation = useMutation(orpc.planet.create.mutationOptions({\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  mutation.mutate({ name: 'Earth' })\n\n  const queryCache = useQueryCache()\n\n  // Invalidate all planet queries\n  queryCache.invalidateQueries({\n    key: orpc.planet.key(),\n  })\n\n  // Invalidate the planet find query with id 123\n  queryCache.invalidateQueries({\n    key: orpc.planet.find.key({ input: { id: 123 } })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Metadata and Caching in oRPC Procedures (TypeScript)\nDESCRIPTION: This snippet demonstrates how to define metadata for oRPC procedures, implement a caching middleware, and use metadata to control caching behavior. It includes the definition of an ORPCMetadata interface, creation of a base handler with middleware, and an example procedure with caching enabled.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/metadata.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ORPCMetadata {\n  cache?: boolean\n}\n\nconst base = os\n  .$meta<ORPCMetadata>({}) // require define initial context [!code highlight]\n  .use(async ({ procedure, next, path }, input, output) => {\n    if (!procedure['~orpc'].meta.cache) {\n      return await next()\n    }\n\n    const cacheKey = path.join('/') + JSON.stringify(input)\n\n    if (db.has(cacheKey)) {\n      return output(db.get(cacheKey))\n    }\n\n    const result = await next()\n\n    db.set(cacheKey, result.output)\n\n    return result\n  })\n\nconst example = base\n  .meta({ cache: true }) // [!code highlight]\n  .handler(() => {\n    // Implement your procedure logic here\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Detailed Output Structure in oRPC (TypeScript)\nDESCRIPTION: Shows how to set up a handler with detailed output structure, returning an object with separate headers and body fields.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst detailedMode = os\n  .route({ outputStructure: 'detailed' })\n  .handler(async ({ input }) => {\n    return {\n      headers: { 'x-custom-header': 'value' },\n      body: { message: 'Hello, world!' },\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Setting Up oRPC Solid Query Utils\nDESCRIPTION: Initializing oRPC Solid Query utilities with a router client to enable query functionality.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/solid.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createORPCSolidQueryUtils } from '@orpc/solid-query'\n\nexport const orpc = createORPCSolidQueryUtils(client)\n\norpc.planet.find.queryOptions({ input: { id: 123 } })\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC with Hono Framework in TypeScript\nDESCRIPTION: This code demonstrates how to set up an oRPC handler with the Hono web framework. It shows the basic pattern of creating a Hono app, initializing an RPCHandler, and configuring a middleware to handle RPC requests with a specific prefix path.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/hono.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Hono } from 'hono'\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst app = new Hono()\n\nconst handler = new RPCHandler(router)\n\napp.use('/rpc/*', async (c, next) => {\n  const { matched, response } = await handler.handle(c.req.raw, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  if (matched) {\n    return c.newResponse(response.body, response)\n  }\n\n  await next()\n})\n\nexport default app\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Event Iterator in oRPC\nDESCRIPTION: A simple example of creating an asynchronous generator function that yields a new event every second. This demonstrates the basic pattern for implementing server-sent events in oRPC.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/event-iterator.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .handler(async function* ({ input, lastEventId }) {\n    while (true) {\n      yield { message: 'Hello, world!' }\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Type-Safe Error Handling with oRPC in TypeScript\nDESCRIPTION: Demonstrates how to define and handle typed errors in oRPC using the `safe` and `isDefinedError` utilities. The example creates a handler with a defined error type (`RATE_LIMIT_EXCEEDED`), then shows how to safely call it and handle different error scenarios with proper type inference.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/error-handling.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isDefinedError, safe } from '@orpc/client'\n\nconst doSomething = os\n  .input(z.object({ id: z.string() }))\n  .errors({\n    RATE_LIMIT_EXCEEDED: {\n      data: z.object({ retryAfter: z.number() })\n    }\n  })\n  .handler(async ({ input, errors }) => {\n    throw errors.RATE_LIMIT_EXCEEDED({ data: { retryAfter: 1000 } })\n\n    return { id: input.id }\n  })\n  .callable()\n\nconst [error, data, isDefined] = await safe(doSomething({ id: '123' }))\n// or const { error, data, isDefined } = await safe(doSomething({ id: '123' }))\n\nif (isDefinedError(error)) { // or isDefined\n  // handle known error\n  console.log(error.data.retryAfter)\n}\nelse if (error) {\n  // handle unknown error\n}\nelse {\n  // handle success\n  console.log(data)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring and Handling HTTP Redirect in oRPC OpenAPI (TypeScript)\nDESCRIPTION: This snippet shows how to configure a route for HTTP redirect using oRPC OpenAPI. It sets the success status to 307 (Temporary Redirect) and uses the 'detailed' output structure to include headers in the response.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/advanced/redirect-response.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst redirect = os\n  .route({\n    method: 'GET',\n    path: '/redirect',\n    successStatus: 307,\n    outputStructure: 'detailed'\n  })\n  .handler(async () => {\n    return {\n      headers: {\n        location: 'https://orpc.unnoq.com',\n      },\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Advanced Grouping with Context for Batched Requests in TypeScript\nDESCRIPTION: Creates a more complex BatchLinkPlugin configuration with multiple groups based on cache control. This allows for different caching strategies within batched requests, with context being passed to the fetch method.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\nimport { BatchLinkPlugin } from '@orpc/client/plugins'\n\ninterface ClientContext {\n  cache?: RequestCache\n}\n\nconst link = new RPCLink<ClientContext>({\n  url: 'http://localhost:3000/rpc',\n  method: ({ context }) => {\n    if (context?.cache) {\n      return 'GET'\n    }\n\n    return 'POST'\n  },\n  plugins: [\n    new BatchLinkPlugin({\n      groups: [\n        {\n          condition: ({ context }) => context?.cache === 'force-cache',\n          context: { // This context will be passed to the fetch method\n            cache: 'force-cache',\n          },\n        },\n        { // Fallback for all other requests - need put it at the end of list\n          condition: () => true,\n          context: {},\n        },\n      ],\n    }),\n  ],\n  fetch: (request, init, { context }) => globalThis.fetch(request, {\n    ...init,\n    cache: context?.cache,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Router Extension with Authentication Middleware\nDESCRIPTION: Shows how to extend a router with authentication middleware applied to all procedures.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = os.use(requiredAuth).router({\n  ping,\n  pong,\n  nested: {\n    ping,\n    pong,\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler with Next.js Pages Router\nDESCRIPTION: Configures an oRPC handler for Next.js Pages Router with body parsing disabled. This implementation handles API requests and returns a 404 response for unmatched routes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/nextjs.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/node'\n\nconst handler = new RPCHandler(router)\n\nexport const config = {\n  api: {\n    bodyParser: false,\n  },\n}\n\nexport default async (req, res) => {\n  const { matched } = await handler.handle(req, res, {\n    prefix: '/rpc',\n    context: {}, // Provide initial context if needed\n  })\n\n  if (matched) {\n    return\n  }\n\n  res.statusCode = 404\n  res.end('Not found')\n}\n```\n\n----------------------------------------\n\nTITLE: Using Built-in Middlewares in oRPC with TypeScript\nDESCRIPTION: Showcases the usage of built-in middlewares provided by oRPC for common use cases such as handling start, success, error, and finish events in the request lifecycle.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onError, onFinish, onStart, onSuccess } from '@orpc/server'\n\nconst ping = os\n  .use(onStart(() => {\n    // Execute logic before the handler\n  }))\n  .use(onSuccess(() => {\n    // Execute when the handler succeeds\n  }))\n  .use(onError(() => {\n    // Execute when the handler fails\n  }))\n  .use(onFinish(() => {\n    // Execute logic after the handler\n  }))\n  .handler(async ({ context }) => {\n    // Handler logic\n  })\n```\n\n----------------------------------------\n\nTITLE: Customizing Validation Errors with Middleware in TypeScript\nDESCRIPTION: This snippet shows how to use middleware to customize validation errors in oRPC. It creates a base middleware that handles both input and output validation errors, which can be applied to multiple procedures.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/validation-errors.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z, ZodError } from 'zod'\nimport type { ZodIssue } from 'zod'\nimport { onError, ORPCError, os, ValidationError } from '@orpc/server'\n\nconst base = os.use(onError((error) => {\n  if (\n    error instanceof ORPCError\n    && error.code === 'BAD_REQUEST'\n    && error.cause instanceof ValidationError\n  ) {\n    // If you only use Zod you can safely cast to ZodIssue[]\n    const zodError = new ZodError(error.cause.issues as ZodIssue[])\n\n    throw new ORPCError('INPUT_VALIDATION_FAILED', {\n      status: 422,\n      data: zodError.flatten(),\n      cause: error.cause,\n    })\n  }\n\n  if (\n    error instanceof ORPCError\n    && error.code === 'INTERNAL_SERVER_ERROR'\n    && error.cause instanceof ValidationError\n  ) {\n    throw new ORPCError('OUTPUT_VALIDATION_FAILED', {\n      cause: error.cause,\n    })\n  }\n}))\n\nconst getting = base\n  .input(z.object({ id: z.string().uuid() }))\n  .output(z.object({ id: z.string().uuid(), name: z.string() }))\n  .handler(async ({ input, context }) => {\n    return { id: input.id, name: 'name' }\n  })\n```\n\n----------------------------------------\n\nTITLE: Managing Context in oRPC Router Clients in TypeScript\nDESCRIPTION: Explains how to define and use client context to dynamically modify procedure behavior. This example shows conditional context creation based on a cache parameter, allowing for runtime behavior customization.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/server-side.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ClientContext {\n  cache?: boolean\n}\n\nconst ping = os.handler(() => 'pong')\nconst pong = os.handler(() => 'ping')\n\nconst client = createRouterClient({ ping, pong }, {\n  context: ({ cache }: ClientContext) => { // [!code highlight]\n    if (cache) {\n      return {} // <-- context when cache enabled\n    }\n\n    return {} // <-- context when cache disabled\n  }\n})\n\nconst result = await client.ping(undefined, { context: { cache: true } })\n```\n\n----------------------------------------\n\nTITLE: Validating File Objects with Zod in oRPC\nDESCRIPTION: This snippet demonstrates how to validate file uploads and downloads using z.instanceof(File) validators in oRPC. The handler logs the filename and returns the same file object that was passed in the input.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/file-upload-download.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .input(z.object({ file: z.instanceof(File) }))\n  .output(z.object({ file: z.instanceof(File) }))\n  .handler(async ({ input }) => {\n    console.log(input.file.name)\n    return { file: input.file }\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring oRPC Handler with Elysia Server\nDESCRIPTION: Sets up an Elysia server with an oRPC OpenAPIHandler to handle RPC requests at the /rpc endpoint. The handler processes incoming requests and returns appropriate responses, with a fallback 404 for unmatched routes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/elysia.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Elysia } from 'elysia'\nimport { OpenAPIHandler } from '@orpc/openapi/fetch'\n\nconst handler = new OpenAPIHandler(router)\n\nconst app = new Elysia()\n  .all('/rpc*', async ({ request }: { request: Request }) => {\n    const { response } = await handler.handle(request, {\n      prefix: '/rpc',\n    })\n\n    return response ?? new Response('Not Found', { status: 404 })\n  })\n  .listen(3000)\n\nconsole.log(\n  `🦊 Elysia is running at http://localhost:3000`\n)\n```\n\n----------------------------------------\n\nTITLE: Using Initial Context in oRPC Handler with TypeScript\nDESCRIPTION: This code shows how to use the initial context when handling a request in oRPC. It demonstrates passing the required context explicitly when creating an RPCHandler and handling a fetch request.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/context.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nexport default function fetch(request: Request) {\n  handler.handle(request, {\n    context: { // <-- you must pass initial context here\n      headers: request.headers,\n      env: {\n        DB_URL: '***'\n      }\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up oRPC with Node's HTTP2 Secure Server\nDESCRIPTION: Creates an HTTP/2 secure server using Node.js native http2 module and integrates it with oRPC. Configures the server with SSL certificates and uses RPCHandler with CORS plugin to process RPC requests at the '/rpc' endpoint.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/node.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSecureServer } from 'node:http2'\nimport { RPCHandler } from '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin(),\n  ],\n})\n\nconst server = createSecureServer({\n  key: fs.readFileSync('key.pem'),\n  cert: fs.readFileSync('cert.pem'),\n}, async (req, res) => {\n  const { matched } = await handler.handle(req, res, {\n    prefix: '/rpc',\n    context: {}, // Provide initial context if needed\n  })\n\n  if (matched) {\n    return\n  }\n\n  res.statusCode = 404\n  res.end('Not found')\n})\n\nserver.listen(3000, '127.0.0.1', () => console.log('Listening on 127.0.0.1:3000'))\n```\n\n----------------------------------------\n\nTITLE: Configuring Middleware Deduplication\nDESCRIPTION: Shows how to disable the built-in middleware deduplication feature through configuration options.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/dedupe-middleware.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$config({ dedupeLeadingMiddlewares: false })\n```\n\n----------------------------------------\n\nTITLE: Implementing CSRF Protection on Server-Side in TypeScript for oRPC\nDESCRIPTION: This snippet demonstrates how to set up CSRF protection on the server side using the SimpleCsrfProtectionHandlerPlugin. It creates an RPCHandler instance with the plugin configured.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/simple-csrf-protection.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { router } from './shared/planet'\nimport { SimpleCsrfProtectionHandlerPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new SimpleCsrfProtectionHandlerPlugin()\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler in Nuxt.js Server Routes\nDESCRIPTION: This code sets up an RPC handler for Nuxt.js server routes. It uses the RPCHandler from @orpc/server/node to handle RPC requests, with options for prefix and context. If no match is found, it returns a 404 response.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/nuxt.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/node'\n\nconst handler = new RPCHandler(router)\n\nexport default defineEventHandler(async (event) => {\n  const { matched } = await handler.handle(\n    event.node.req,\n    event.node.res,\n    {\n      prefix: '/rpc',\n      context: {}, // Provide initial context if needed\n    }\n  )\n\n  if (matched) {\n    return\n  }\n\n  setResponseStatus(event, 404, 'Not Found')\n  return 'Not found'\n})\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of Event Iterator in oRPC\nDESCRIPTION: Demonstrates how to create and iterate over an event iterator in an oRPC client. The code shows importing necessary components, defining a contract with an event iterator output, and using an asynchronous for-await loop to process each event from the stream.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/event-iterator.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst iterator = await client.streaming()\n\nfor await (const event of iterator) {\n  console.log(event.message)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC with Bun's HTTP Server in TypeScript\nDESCRIPTION: This code snippet demonstrates how to set up an oRPC handler with Bun's built-in HTTP server. It includes CORS plugin integration and handles RPC requests with a specified prefix. The handler can be any supported oRPC handler like RPCHandler or OpenAPIHandler.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/bun.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ]\n})\n\nBun.serve({\n  async fetch(request: Request) {\n    const { matched, response } = await handler.handle(request, {\n      prefix: '/rpc',\n      context: {} // Provide initial context if needed\n    })\n\n    if (matched) {\n      return response\n    }\n\n    return new Response('Not found', { status: 404 })\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Compact Output Structure in oRPC (TypeScript)\nDESCRIPTION: Demonstrates how to implement a handler with compact output structure, which returns only the body data directly.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst compactMode = os\n  .handler(async ({ input }) => {\n    return { message: 'Hello, world!' }\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Request Methods in RPCLink\nDESCRIPTION: Example of overriding the default POST method in RPCLink to use GET for specific procedures. This can be useful for enabling browser or CDN caching based on the procedure name or context.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/rpc-link.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\n\ninterface ClientContext {\n  cache?: RequestCache\n}\n\nconst link = new RPCLink<ClientContext>({\n  url: 'http://localhost:3000/rpc',\n  method: ({ context }, path) => {\n    if (context?.cache) {\n      return 'GET'\n    }\n\n    const lastSegment = path.at(-1)\n    if (lastSegment && /get|find|list|search/i.test(lastSegment)) {\n      return 'GET'\n    }\n\n    return 'POST'\n  },\n  fetch: (request, init, { context }) => globalThis.fetch(request, {\n    ...init,\n    cache: context?.cache,\n  }),\n})\n```\n\n----------------------------------------\n\nTITLE: Customizing Validation Errors with Client Interceptors in TypeScript\nDESCRIPTION: This snippet demonstrates how to use client interceptors to customize validation errors in oRPC. It handles both input and output validation errors, creating custom ORPCError instances with specific error codes and data.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/validation-errors.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { router } from './shared/planet'\nimport { onError, ORPCError, ValidationError } from '@orpc/server'\nimport { ZodError } from 'zod'\nimport type { ZodIssue } from 'zod'\n\nconst handler = new RPCHandler(router, {\n  clientInterceptors: [\n    onError((error) => {\n      if (\n        error instanceof ORPCError\n        && error.code === 'BAD_REQUEST'\n        && error.cause instanceof ValidationError\n      ) {\n        // If you only use Zod you can safely cast to ZodIssue[]\n        const zodError = new ZodError(error.cause.issues as ZodIssue[])\n\n        throw new ORPCError('INPUT_VALIDATION_FAILED', {\n          status: 422,\n          data: zodError.flatten(),\n          cause: error.cause,\n        })\n      }\n\n      if (\n        error instanceof ORPCError\n        && error.code === 'INTERNAL_SERVER_ERROR'\n        && error.cause instanceof ValidationError\n      ) {\n        throw new ORPCError('OUTPUT_VALIDATION_FAILED', {\n          cause: error.cause,\n        })\n      }\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Event Iterators in oRPC\nDESCRIPTION: Demonstrates proper error handling for event iterators, using try-catch blocks to handle errors that might occur during streaming. Specifically checks for ORPCError instances thrown by the server.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/event-iterator.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst iterator = await client.streaming()\n\ntry {\n  for await (const event of iterator) {\n    console.log(event.message)\n  }\n}\ncatch (error) {\n  if (error instanceof ORPCError) {\n    // Handle the error here\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Initial oRPC Routing Configuration\nDESCRIPTION: Demonstrates how to customize the initial oRPC routing settings using the .$route method.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/routing.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$route({ method: 'GET' })\n```\n\n----------------------------------------\n\nTITLE: Configuring Mutation Options for Pinia Colada\nDESCRIPTION: Shows how to use the mutationOptions method to create options for mutations, which can be used with hooks like useMutation.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst mutation = useMutation(orpc.planet.create.mutationOptions({\n  context: { cache: true }, // Provide client context if needed\n  // additional options...\n}))\n\nmutation.mutate({ name: 'Earth' })\n```\n\n----------------------------------------\n\nTITLE: Setting up oRPC with Node's HTTP Server\nDESCRIPTION: Creates an HTTP server using Node.js native http module and integrates it with oRPC. Uses RPCHandler with CORS plugin to process RPC requests at the '/rpc' endpoint, with a fallback for unmatched routes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/node.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'node:http'\nimport { RPCHandler } from '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ]\n})\n\nconst server = createServer(async (req, res) => {\n  const { matched } = await handler.handle(req, res, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  if (matched) {\n    return\n  }\n\n  res.statusCode = 404\n  res.end('Not found')\n})\n\nserver.listen(3000, '127.0.0.1', () => console.log('Listening on 127.0.0.1:3000'))\n```\n\n----------------------------------------\n\nTITLE: Initializing OpenAPI Handler with Node.js HTTP Server\nDESCRIPTION: This snippet demonstrates how to set up an OpenAPI handler using @orpc/openapi with a Node.js HTTP server. It includes CORS plugin integration and basic request handling.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/openapi/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'node:http'\nimport { OpenAPIHandler } from '@orpc/openapi/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new OpenAPIHandler(router, {\n  plugins: [new CORSPlugin()]\n})\n\nconst server = createServer(async (req, res) => {\n  const result = await handler.handle(req, res, {\n    context: { headers: req.headers }\n  })\n\n  if (!result.matched) {\n    res.statusCode = 404\n    res.end('No procedure matched')\n  }\n})\n\nserver.listen(3000, '127.0.0.1', () => console.log('Listening on 127.0.0.1:3000'))\n```\n\n----------------------------------------\n\nTITLE: Implementing DynamicLink for Flexible RPC Routing in TypeScript\nDESCRIPTION: This snippet demonstrates how to use DynamicLink to dynamically select between two RPCLink instances based on client context. It sets up links for cached and non-cached requests, and creates an oRPC client with the dynamic link.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/dynamic-link.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router } from './shared/planet'\nimport { RouterClient } from '@orpc/server'\nimport { RPCLink } from '@orpc/client/fetch'\nimport { createORPCClient, DynamicLink } from '@orpc/client'\n\ninterface ClientContext {\n  cache?: boolean\n}\n\nconst cacheLink = new RPCLink({\n  url: 'https://cache.example.com/rpc',\n})\n\nconst noCacheLink = new RPCLink({\n  url: 'https://example.com/rpc',\n})\n\nconst link = new DynamicLink<ClientContext>((options, path, input) => {\n  if (options.context?.cache) {\n    return cacheLink\n  }\n\n  return noCacheLink\n})\n\nconst client: RouterClient<typeof router, ClientContext> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Setting up StrictGetMethodPlugin in RPC Handler\nDESCRIPTION: Demonstrates how to initialize and configure the StrictGetMethodPlugin within the RPCHandler setup\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/strict-get-method.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { router } from './shared/planet'\nimport { StrictGetMethodPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new StrictGetMethodPlugin()\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Infinite Queries with oRPC and Tanstack Query\nDESCRIPTION: Use the infiniteOptions utility to configure infinite queries with hooks like useInfiniteQuery. The input parameter must be a function that accepts the page parameter and returns the query input.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst query = useInfiniteQuery(orpc.planet.list.infiniteOptions({\n  input: (pageParam: number | undefined) => ({ limit: 10, offset: pageParam }),\n  context: { cache: true }, // Provide client context if needed\n  initialPageParam: undefined,\n  getNextPageParam: lastPage => lastPage.nextPageParam,\n  // additional options...\n}))\n```\n\n----------------------------------------\n\nTITLE: Implementing Cleanup for Event Iterator\nDESCRIPTION: Using a try-finally block to perform cleanup when the connection ends. This pattern ensures resources are properly released whether the stream ends normally or due to errors/disconnection.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/event-iterator.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .handler(async function* ({ input, lastEventId }) {\n    try {\n      while (true) {\n        yield { message: 'Hello, world!' }\n        await new Promise(resolve => setTimeout(resolve, 1000))\n      }\n    }\n    finally {\n      console.log('Cleanup logic here')\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic HTTP Method Routing in oRPC\nDESCRIPTION: Demonstrates how to override the default POST method with custom HTTP methods, paths, and success status codes using the .route method.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/routing.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nos.route({ method: 'GET', path: '/example', successStatus: 200 })\nos.route({ method: 'POST', path: '/example', successStatus: 201 })\n```\n\n----------------------------------------\n\nTITLE: Setting up Context with ResponseHeadersPlugin in oRPC\nDESCRIPTION: Demonstrates how to extend the oRPC context with ResponseHeadersPluginContext and use the resHeaders object to set custom response headers. The example shows both middleware usage and direct handler access to response headers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/response-headers.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { os } from '@orpc/server'\n// ---cut---\nimport { ResponseHeadersPluginContext } from '@orpc/server/plugins'\n\ninterface ORPCContext extends ResponseHeadersPluginContext {}\n\nconst base = os.$context<ORPCContext>()\n\nconst example = base\n  .use(({ context, next }) => {\n    context.resHeaders?.set('x-custom-header', 'value')\n    return next()\n  })\n  .handler(({ context }) => {\n    context.resHeaders?.set('x-custom-header', 'value')\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Database Connection Deduplication with Context\nDESCRIPTION: Shows how to create a database provider middleware that uses context to prevent redundant database connections. The middleware checks if a connection already exists before creating a new one.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/dedupe-middleware.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst dbProvider = os\n  .$context<{ db?: Awaited<ReturnType<typeof connectDb>> }>()\n  .middleware(async ({ context, next }) => {\n    /**\n     * If db already exists, skip the connection.\n     */\n    const db = context.db ?? await connectDb()\n\n    return next({ context: { db } })\n  })\n```\n\n----------------------------------------\n\nTITLE: Lazy Router Implementation\nDESCRIPTION: Demonstrates lazy loading of router components for code splitting and improved performance.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = {\n  ping,\n  pong,\n  planet: os.lazy(() => import('./planet'))\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst PlanetSchema = z.object({\n  id: z.number().int().min(1),\n  name: z.string(),\n  description: z.string().optional(),\n})\n\nexport const listPlanet = os\n  .input(\n    z.object({\n      limit: z.number().int().min(1).max(100).optional(),\n      cursor: z.number().int().min(0).default(0),\n    }),\n  )\n  .handler(async ({ input }) => {\n    // your list code here\n    return [{ id: 1, name: 'name' }]\n  })\n\nexport default {\n  list: listPlanet,\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler in SolidStart Routes\nDESCRIPTION: This code sets up a catch-all route handler for oRPC requests in SolidStart. It creates an RPCHandler instance and implements HTTP method handlers that process incoming requests with the proper context and prefix configuration.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/solid-start.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { APIEvent } from '@solidjs/start/server'\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nasync function handle({ request }: APIEvent) {\n  const { response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  return response ?? new Response('Not Found', { status: 404 })\n}\n\nexport const GET = handle\nexport const POST = handle\nexport const PUT = handle\nexport const PATCH = handle\nexport const DELETE = handle\n```\n\n----------------------------------------\n\nTITLE: Using Query/Mutation Keys with oRPC\nDESCRIPTION: Generate QueryKey or MutationKey using the key utility for tasks like revalidating queries or checking mutation status. The key accepts partial deep input without requiring full input parameters.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryClient = useQueryClient()\n\n// Invalidate all planet queries\nqueryClient.invalidateQueries({\n  queryKey: orpc.planet.key(),\n})\n\n// Invalidate only regular (non-infinite) planet queries\nqueryClient.invalidateQueries({\n  queryKey: orpc.planet.key({ type: 'query' })\n})\n\n// Invalidate the planet find query with id 123\nqueryClient.invalidateQueries({\n  queryKey: orpc.planet.find.key({ input: { id: 123 } })\n})\n```\n\n----------------------------------------\n\nTITLE: Building a Router in TypeScript\nDESCRIPTION: Creating a router at the root level using the .router method that assembles all implemented procedures and ensures type checking and contract enforcement at runtime.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/implement-contract.md#2025-04-21_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst router = os.router({ // <-- Essential for full contract enforcement\n  planet: {\n    list: listPlanet,\n    find: findPlanet,\n    create: createPlanet,\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring BatchHandlerPlugin on the Server Side in TypeScript\nDESCRIPTION: Sets up the BatchHandlerPlugin on the server side by adding it to the RPCHandler's plugins array. This enables the server to process batched requests from clients.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { router } from './shared/planet'\nimport { BatchHandlerPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [new BatchHandlerPlugin()],\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Solid Query with oRPC\nDESCRIPTION: Example of creating a Solid Query using oRPC query options, demonstrating the required callback wrapper for Solid implementations.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/solid.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery } from '@tanstack/solid-query'\n\nconst query = createQuery(\n  () => orpc.planet.find.queryOptions({ input: { id: 123 } })\n)\n```\n\n----------------------------------------\n\nTITLE: Manually Stopping an Event Stream in oRPC\nDESCRIPTION: Shows how to gracefully terminate an event stream by calling the .return() method on the iterator. This allows for conditional stopping of the stream based on application logic.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/event-iterator.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst iterator = await client.streaming()\n\nfor await (const event of iterator) {\n  if (wantToStop) {\n    await iterator.return()\n    break\n  }\n\n  console.log(event.message)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CORSPlugin for oRPC in TypeScript\nDESCRIPTION: This code snippet demonstrates how to instantiate and configure the CORSPlugin for an oRPC handler. It shows setting up basic CORS configurations like origin validation and allowed HTTP methods.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/cors.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin({\n      origin: (origin, options) => origin,\n      allowMethods: ['GET', 'HEAD', 'PUT', 'POST', 'DELETE', 'PATCH'],\n      // ...\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing a Procedure Handler in TypeScript\nDESCRIPTION: Defining a procedure by attaching a handler to its corresponding contract definition, ensuring it adheres to the contract's specifications.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/implement-contract.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nexport const listPlanet = os.planet.list\n  .handler(({ input }) => {\n    // Your logic for listing planets\n    return []\n  })\n```\n\n----------------------------------------\n\nTITLE: Customizing Request Headers for Batched Requests in TypeScript\nDESCRIPTION: Configures the BatchLinkPlugin with a headers option to customize the headers sent with batched requests. This example sets an authorization header for all batched requests.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new RPCLink({\n  url: 'https://api.example.com/rpc',\n  plugins: [\n    new BatchLinkPlugin({\n      groups: [\n        {\n          condition: options => true,\n          context: {}\n        }\n      ],\n      headers: () => ({\n        authorization: 'Bearer 1234567890',\n      })\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring BatchLinkPlugin on the Client Side in TypeScript\nDESCRIPTION: Sets up the BatchLinkPlugin on the client side with a group configuration. Requests within the same group will be batched together, reducing network overhead.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\nimport { BatchLinkPlugin } from '@orpc/client/plugins'\n\nconst link = new RPCLink({\n  url: 'https://api.example.com/rpc',\n  plugins: [\n    new BatchLinkPlugin({\n      groups: [\n        {\n          condition: options => true,\n          context: {} // This context will represent the batch request and persist throughout the request lifecycle\n        }\n      ]\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Using Client Retry Plugin with Custom Configuration\nDESCRIPTION: Shows how to use the Client Retry Plugin with custom configuration when making a client call. This example demonstrates setting retry count, delay, retry conditions, and hooks for retry events.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/client-retry.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst planets = await client.planet.list({ limit: 10 }, {\n  context: {\n    retry: 3, // Maximum retry attempts\n    retryDelay: 2000, // Delay between retries in ms\n    shouldRetry: options => true, // Determines whether to retry based on the error\n    onRetry: (options) => {\n      // Hook executed on each retry\n\n      return (isSuccess) => {\n        // Execute after the retry is complete\n      }\n    },\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Applying Route Prefixes to Router Groups\nDESCRIPTION: Demonstrates how to use the .prefix method to prepend a common path to all procedures in a router that have explicitly defined paths.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/routing.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = os.prefix('/planets').router({\n  list: listPlanet,\n  find: findPlanet,\n  create: createPlanet,\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Client Context with RPCLink in TypeScript\nDESCRIPTION: Example of using client context to pass additional information when calling procedures. This allows for dynamically modifying RPCLink's behavior based on the context provided in each call.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/rpc-link.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router } from './shared/planet'\nimport { RouterClient } from '@orpc/server'\nimport { createORPCClient } from '@orpc/client'\nimport { RPCLink } from '@orpc/client/fetch'\n\ninterface ClientContext {\n  something?: string\n}\n\nconst link = new RPCLink<ClientContext>({\n  url: 'http://localhost:3000/rpc',\n  headers: async ({ context }) => ({\n    'x-api-key': context?.something ?? ''\n  })\n})\n\nconst client: RouterClient<typeof router, ClientContext> = createORPCClient(link)\n\nconst result = await client.planet.list(\n  { limit: 10 },\n  { context: { something: 'value' } }\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing CSRF Protection on Client-Side in TypeScript for oRPC\nDESCRIPTION: This snippet shows how to set up CSRF protection on the client side using the SimpleCsrfProtectionLinkPlugin. It creates an RPCLink instance with the plugin configured.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/simple-csrf-protection.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCLink } from '@orpc/client/fetch'\nimport { SimpleCsrfProtectionLinkPlugin } from '@orpc/client/plugins'\n\nconst link = new RPCLink({\n  url: 'https://api.example.com/rpc',\n  plugins: [\n    new SimpleCsrfProtectionLinkPlugin(),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC and Tanstack Query for Vue\nDESCRIPTION: Commands for installing @orpc/vue-query and @tanstack/vue-query using various package managers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/vue.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/vue-query@latest @tanstack/vue-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/vue-query@latest @tanstack/vue-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/vue-query@latest @tanstack/vue-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/vue-query@latest @tanstack/vue-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/vue-query@latest npm:@tanstack/vue-query@latest\n```\n\n----------------------------------------\n\nTITLE: Defining Path Parameters in oRPC Routes\nDESCRIPTION: Shows how to define path parameters in routes, including normal path parameters and path parameters that can match slashes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/routing.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nos.route({ path: '/example/{id}' })\n  .input(z.object({ id: z.string() }))\n\nos.route({ path: '/example/{+path}' }) // Matches slashes (/)\n  .input(z.object({ path: z.string() }))\n```\n\n----------------------------------------\n\nTITLE: Excluding Specific Procedures from Batching in TypeScript\nDESCRIPTION: Configures the BatchLinkPlugin with an exclude option to prevent specific procedures from being batched. This is useful for procedures that return unsupported data types like AsyncIteratorObject or File/Blob.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new RPCLink({\n  url: 'https://api.example.com/rpc',\n  plugins: [\n    new BatchLinkPlugin({\n      groups: [\n        {\n          condition: options => true,\n          context: {}\n        }\n      ],\n      exclude: ({ path }) => {\n        return ['planets/getImage', 'planets/subscribe'].includes(path.join('/'))\n      }\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Setting up OpenAPIHandler with Plugins and Interceptors\nDESCRIPTION: TypeScript code demonstrating how to set up an OpenAPIHandler instance with CORS plugin and error interceptor. It also shows how to handle requests and responses.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/openapi-handler.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAPIHandler } from '@orpc/openapi/fetch' // or '@orpc/server/node'\nimport { CORSPlugin } from '@orpc/server/plugins'\nimport { onError } from '@orpc/server'\n\nconst handler = new OpenAPIHandler(router, {\n  plugins: [new CORSPlugin()],\n  interceptors: [\n    onError(error => console.error(error))\n  ],\n})\n\nexport default async function fetch(request: Request) {\n  const { matched, response } = await handler.handle(request, {\n    prefix: '/api',\n    context: {} // Add initial context if needed\n  })\n\n  if (matched) {\n    response\n  }\n\n  return new Response('Not Found', { status: 404 })\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Serializer for User Class in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom serializer for a User class. It defines the User class with a toJSON method and creates a userSerializer object that implements the StandardOpenAPICustomJsonSerializer interface.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/advanced/openapi-json-serializer.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StandardOpenAPICustomJsonSerializer } from '@orpc/openapi-client/standard'\n\nexport class User {\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly email: string,\n    public readonly age: number,\n  ) {}\n\n  toJSON() {\n    return {\n      id: this.id,\n      name: this.name,\n      email: this.email,\n      age: this.age,\n    }\n  }\n}\n\nexport const userSerializer: StandardOpenAPICustomJsonSerializer = {\n  condition: data => data instanceof User,\n  serialize: data => data.toJSON(),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Lazy Router with Required Prefix\nDESCRIPTION: Shows how to combine a Lazy Router with OpenAPIHandler by setting the required prefix for lazy loading.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/routing.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = {\n  planet: os.prefix('/planets').lazy(() => import('./planet'))\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Multiple oRPC Clients\nDESCRIPTION: Example of combining multiple oRPC clients into a single object for organized access to different remote procedure sets.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/client-side.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst clientA: RouterClient<typeof routerA> = createORPCClient(linkA)\nconst clientB: RouterClient<typeof routerB> = createORPCClient(linkB)\nconst clientC: RouterClient<typeof routerC> = createORPCClient(linkC)\n\nexport const orpc = {\n  a: clientA,\n  b: clientB,\n  c: clientC,\n}\n```\n\n----------------------------------------\n\nTITLE: Calling oRPC Procedures\nDESCRIPTION: Example of calling remote procedures using the configured oRPC client, demonstrating type-safe procedure calls.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/client-side.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst planet = await client.planet.find({ id: 1 })\n\nclient.planet.create\n```\n\n----------------------------------------\n\nTITLE: Creating Callable oRPC Procedures in TypeScript\nDESCRIPTION: Demonstrates how to define a procedure with input validation and turn it into a callable function. This pattern allows procedures to be invoked directly like native functions with type safety.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/server-side.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { os } from '@orpc/server'\nimport { z } from 'zod'\n\nconst getProcedure = os\n  .input(z.object({ id: z.string() }))\n  .handler(async ({ input }) => ({ id: input.id }))\n  .callable({\n    context: {} // Provide initial context if needed\n  })\n\nconst result = await getProcedure({ id: '123' })\n```\n\n----------------------------------------\n\nTITLE: Integrating Custom Serializer with OpenAPIHandler and OpenAPIGenerator in TypeScript\nDESCRIPTION: This snippet shows how to use the custom userSerializer with OpenAPIHandler and OpenAPIGenerator. It demonstrates adding the custom serializer to the customJsonSerializers option for both classes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/advanced/openapi-json-serializer.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StandardOpenAPICustomJsonSerializer } from '@orpc/openapi-client/standard'\nimport { OpenAPIHandler } from '@orpc/openapi/fetch'\nimport { OpenAPIGenerator } from '@orpc/openapi'\ndeclare const router: Record<never, never>\ndeclare const userSerializer: StandardOpenAPICustomJsonSerializer\n// ---cut---\nconst handler = new OpenAPIHandler(router, {\n  customJsonSerializers: [userSerializer],\n})\n\nconst generator = new OpenAPIGenerator({\n  customJsonSerializers: [userSerializer],\n})\n```\n\n----------------------------------------\n\nTITLE: Calling oRPC Procedure Clients Directly\nDESCRIPTION: Shows how to use the call method to directly invoke an oRPC procedure client.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nconst result = orpc.planet.find.call({ id: 123 })\n```\n\n----------------------------------------\n\nTITLE: Creating oRPC React Context\nDESCRIPTION: Implementation of React context setup for oRPC React Query utilities with TypeScript type definitions.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createContext, use } from 'react'\nimport { RouterUtils } from '@orpc/react-query'\nimport { RouterClient } from '@orpc/server'\n\ntype ORPCReactUtils = RouterUtils<RouterClient<typeof router>>\n\nexport const ORPCContext = createContext<ORPCReactUtils | undefined>(undefined)\n\nexport function useORPC(): ORPCReactUtils {\n  const orpc = use(ORPCContext)\n  if (!orpc) {\n    throw new Error('ORPCContext is not set up properly')\n  }\n  return orpc\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up oRPC with Tanstack Query in Vue\nDESCRIPTION: Basic setup for integrating oRPC with Tanstack Query in a Vue application. It creates utility functions for queries and mutations.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/vue.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createORPCVueQueryUtils } from '@orpc/vue-query'\n\nexport const orpc = createORPCVueQueryUtils(client)\n\norpc.planet.find.queryOptions({ input: { id: 123 } })\n```\n\n----------------------------------------\n\nTITLE: Handling Requests with Execution Context in oRPC\nDESCRIPTION: This code demonstrates how to handle requests using execution context in oRPC. It shows that when using execution context, no manual context passing is required when creating the RPCHandler.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/context.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nexport default function fetch(request: Request) {\n  handler.handle(request) // <-- no need to pass anything more\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Serializer in RPC Handler and Client in TypeScript\nDESCRIPTION: This code snippet shows how to use a custom serializer in both the RPC handler and the RPC client link. The userSerializer is added to the customJsonSerializers option in both instances.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-json-serializer.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler = new RPCHandler(router, {\n  customJsonSerializers: [userSerializer], // [!code highlight]\n})\n\nconst link = new RPCLink({\n  url: 'https://example.com/rpc',\n  customJsonSerializers: [userSerializer], // [!code highlight]\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing skipToken for Query Disabling\nDESCRIPTION: Example of using skipToken to conditionally disable queries in Tanstack Query with oRPC.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { skipToken, useQuery } from '@tanstack/react-query'\n\nconst options = orpc.planet.find.queryOptions({\n  input: { id: 123 },\n})\n\nconst query = useQuery({\n  ...options,\n  queryFn: condition ? skipToken : options.queryFn,\n})\n```\n\n----------------------------------------\n\nTITLE: Basic oRPC Svelte Query Setup\nDESCRIPTION: Creates oRPC Svelte Query utilities from an existing client instance. This enables type-safe query generation for the router endpoints.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/svelte.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createORPCSvelteQueryUtils } from '@orpc/svelte-query'\n\nexport const orpc = createORPCSvelteQueryUtils(client)\n\norpc.planet.find.queryOptions({ input: { id: 123 } })\n//               ^|\n\n//\n```\n\n----------------------------------------\n\nTITLE: Adding Event Metadata for Client Reconnection\nDESCRIPTION: Adding event metadata such as event ID and retry interval using the withEventMeta helper. This allows clients to reconnect and resume the stream from the last received event when connection is lost.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/event-iterator.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { withEventMeta } from '@orpc/server'\n\nconst example = os\n  .handler(async function* ({ input, lastEventId }) {\n    if (lastEventId) {\n      // Resume streaming from lastEventId\n    }\n    else {\n      while (true) {\n        yield withEventMeta({ message: 'Hello, world!' }, { id: 'some-id', retry: 10_000 })\n        await new Promise(resolve => setTimeout(resolve, 1000))\n      }\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring oRPC Queries with Tanstack Query\nDESCRIPTION: Use the queryOptions utility to configure regular queries with Tanstack Query hooks like useQuery. This allows specifying input parameters and client context along with additional query options.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst query = useQuery(orpc.planet.find.queryOptions({\n  input: { id: 123 }, // Specify input if needed\n  context: { cache: true }, // Provide client context if needed\n  // additional options...\n}))\n```\n\n----------------------------------------\n\nTITLE: Creating Dual-Mode oRPC Client Library for SSR\nDESCRIPTION: Sets up a client module that uses globalThis to access a server-side client without bundling it into client code. Provides fallback to client-side oRPC implementation when running in the browser.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { RouterClient } from '@orpc/server'\nimport { RPCLink } from '@orpc/client/fetch'\nimport { createORPCClient } from '@orpc/client'\n\ndeclare global {\n  var $client: RouterClient<typeof router> | undefined\n}\n\nconst link = new RPCLink({\n  url: () => {\n    if (typeof window === 'undefined') {\n      throw new Error('RPCLink is not allowed on the server side.')\n    }\n\n    return new URL('/rpc', window.location.href)\n  },\n})\n\n/**\n * Fallback to client-side client if server-side client is not available.\n */\nexport const client: RouterClient<typeof router> = globalThis.$client ?? createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple oRPC Clients with Unique Keys\nDESCRIPTION: Example of creating multiple oRPC utility instances with unique base keys to prevent query/mutation key conflicts.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/solid.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst userORPC = createORPCSolidQueryUtils(userClient, {\n  path: ['user']\n})\nconst postORPC = createORPCSolidQueryUtils(postClient, {\n  path: ['post']\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Server Handler in TanStack Start API Routes\nDESCRIPTION: Sets up an oRPC handler using TanStack Start's API Routes functionality. Handles multiple HTTP methods and includes path prefix configuration.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/tanstack-start.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { createAPIFileRoute } from '@tanstack/start/api'\n\nconst handler = new RPCHandler(router)\n\nasync function handle({ request }: { request: Request }) {\n  const { response } = await handler.handle(request, {\n    prefix: '/api/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  return response ?? new Response('Not Found', { status: 404 })\n}\n\nexport const APIRoute = createAPIFileRoute('/api/rpc/$')({\n  GET: handle,\n  POST: handle,\n  PUT: handle,\n  PATCH: handle,\n  DELETE: handle,\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Compact Input Structure in oRPC (TypeScript)\nDESCRIPTION: Demonstrates how to define a route with compact input structure, which merges path parameters with query or body data into a single object.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst compactMode = os.route({\n  path: '/ping/{name}',\n  method: 'POST',\n})\n  .input(z.object({\n    name: z.string(),\n    description: z.string().optional(),\n  }))\n```\n\n----------------------------------------\n\nTITLE: Handling Type-Safe Errors with oRPC and Tanstack Query\nDESCRIPTION: Manage type-safe errors using the isDefinedError helper function, which provides type-safe error handling within mutation callbacks or when checking mutation state.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isDefinedError } from '@orpc/client'\n\nconst mutation = useMutation(orpc.planet.create.mutationOptions({\n  onError: (error) => {\n    if (isDefinedError(error)) {\n      // Handle the error here\n    }\n  }\n}))\n\nmutation.mutate({ name: 'Earth' })\n\nif (mutation.error && isDefinedError(mutation.error)) {\n  // Handle the error here\n}\n```\n\n----------------------------------------\n\nTITLE: Using oRPC Client in Server Components\nDESCRIPTION: Demonstrates how to use the dual-mode oRPC client in a Next.js Server Component to fetch data during SSR without requiring special handling.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport default async function PlanetListPage() {\n  const planets = await client.planet.list({ limit: 10 })\n\n  return (\n    <div>\n      {planets.map(planet => (\n        <div key={planet.id}>{planet.name}</div>\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Router Initial Context Type Inference\nDESCRIPTION: Shows how to infer initial context types from router procedures.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferRouterInitialContexts } from '@orpc/server'\n\nexport type InitialContexts = InferRouterInitialContexts<typeof router>\n\ntype FindPlanetInitialContext = InitialContexts['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Merging Router Segments on Client Side in TypeScript\nDESCRIPTION: This snippet shows how to merge individually exported router segments on the client side. It defines a Router interface and creates an oRPC client with the merged router type.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/exceeds-the-maximum-length-problem.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Router {\n  user: typeof userRouter\n  planet: typeof planetRouter\n  public: typeof publicRouter\n}\n\nexport const client: RouterClient<Router> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Configuring Client Retry Plugin for Event Iterator (SSE)\nDESCRIPTION: Shows how to configure the Client Retry Plugin for use with Event Iterator (Server-Sent Events). This example demonstrates setting up infinite retries to replicate the behavior of the EventSource API.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/client-retry.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst streaming = await client.streaming('the input', {\n  context: {\n    retry: Number.POSITIVE_INFINITY,\n  }\n})\n\nfor await (const message of streaming) {\n  console.log(message)\n}\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC Handler with Express.js\nDESCRIPTION: Sets up an Express.js server with oRPC integration using RPCHandler. The code configures CORS middleware and creates a route handler for RPC requests with a '/rpc' prefix. The server listens on port 3000 and includes middleware to handle both RPC and non-RPC requests.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/express.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport express from 'express'\nimport cors from 'cors'\nimport { RPCHandler } from '@orpc/server/node'\n\nconst app = express()\n\napp.use(cors())\n\nconst handler = new RPCHandler(router)\n\napp.use('/rpc*', async (req, res, next) => {\n  const { matched } = await handler.handle(req, res, {\n    prefix: '/rpc',\n    context: {},\n  })\n\n  if (matched) {\n    return\n  }\n\n  next()\n})\n\napp.listen(3000, () => console.log('Server listening on port 3000'))\n```\n\n----------------------------------------\n\nTITLE: Using oRPC Utils in React Components\nDESCRIPTION: Example of using oRPC utilities with Tanstack Query hooks in React components.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst orpc = useORPC()\n\nconst query = useQuery(orpc.planet.find.queryOptions({ input: { id: 123 } }))\n```\n\n----------------------------------------\n\nTITLE: Complex Example of Form Data with Bracket Notation (Bash)\nDESCRIPTION: This complex example demonstrates advanced usage of Bracket Notation in form data. It includes nested objects, arrays, sparse arrays, and file uploads.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://example.com/api/example \\\n  -F 'data[names][0][first]=John1' \\\n  -F 'data[names][0][last]=Doe1' \\\n  -F 'data[names][1][first]=John2' \\\n  -F 'data[names][1][last]=Doe2' \\\n  -F 'data[ages][0]=18' \\\n  -F 'data[ages][2]=25' \\\n  -F 'data[files][]=@/path/to/file1' \\\n  -F 'data[files][]=@/path/to/file2'\n```\n\n----------------------------------------\n\nTITLE: Setting up oRPC Vue Colada Utils\nDESCRIPTION: Initializes the oRPC Vue Colada utils with a client instance. This setup is required before using oRPC with Pinia Colada.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { createORPCVueColadaUtils } from '@orpc/vue-colada'\n\nexport const orpc = createORPCVueColadaUtils(client)\n\norpc.planet.find.queryOptions({ input: { id: 123 } })\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Serializer for User Type in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom serializer for a User class. It defines the User class with a toJSON method and creates a userSerializer object implementing the StandardRPCCustomJsonSerializer interface.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-json-serializer.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { StandardRPCCustomJsonSerializer } from '@orpc/client/standard'\n\nexport class User {\n  constructor(\n    public readonly id: string,\n    public readonly name: string,\n    public readonly email: string,\n    public readonly age: number,\n  ) {}\n\n  toJSON() {\n    return {\n      id: this.id,\n      name: this.name,\n      email: this.email,\n      age: this.age,\n    }\n  }\n}\n\nexport const userSerializer: StandardRPCCustomJsonSerializer = {\n  type: 21,\n  condition: data => data instanceof User,\n  serialize: data => data.toJSON(),\n  deserialize: data => new User(data.id, data.name, data.email, data.age),\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring oRPC Fetch Server Handler with CORS\nDESCRIPTION: Demonstrates setting up a basic oRPC handler using the Fetch API Server implementation with CORS support. The handler processes RPC requests at the '/rpc' endpoint and includes error handling for unmatched routes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/fetch-server.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ]\n})\n\nexport async function fetch(request: Request): Promise<Response> {\n  const { matched, response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  if (matched) {\n    return response\n  }\n\n  return new Response('Not found', { status: 404 })\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Client in TanStack Start Routes\nDESCRIPTION: Demonstrates how to use oRPC client in TanStack Start routes for data fetching and mutations, including loader implementation and component integration.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/tanstack-start.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFileRoute, useRouter } from '@tanstack/react-router'\nimport { client } from '@/lib/client'\n\nexport const Route = createFileRoute('/')({ \n  component: Home,\n  loader: async () => {\n    return await client.counter.get()\n  },\n})\n\nfunction Home() {\n  const router = useRouter()\n  const state = Route.useLoaderData()\n  const updateCount = async () => {\n    await client.counter.increment()\n    router.invalidate()\n  }\n  return (\n    <div>\n      <div>{state.value}</div>\n      <button type=\"button\" onClick={updateCount}>\n        Increment\n      </button>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Installing OpenAPILink Package\nDESCRIPTION: Package installation commands for different package managers to add @orpc/openapi-client dependency.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/openapi-client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/openapi-client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/openapi-client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/openapi-client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/openapi-client@latest\n```\n\n----------------------------------------\n\nTITLE: Inferring Contract Router Input Types in TypeScript\nDESCRIPTION: Demonstrates how to use utility types to automatically extract the expected input types for each procedure in the router.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferContractRouterInputs } from '@orpc/contract'\n\nexport type Inputs = InferContractRouterInputs<typeof contract>\n\ntype FindPlanetInput = Inputs['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC with TanStack Query and Suspense\nDESCRIPTION: Shows how to combine the optimized oRPC setup with TanStack Query for enhanced data fetching and state management with Suspense support.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport default function PlanetListPage() {\n  const { data: planets } = useSuspenseQuery(\n    orpc.planet.list.queryOptions({\n      input: { limit: 10 },\n    }),\n  )\n\n  return (\n    <div>\n      {planets.map(planet => (\n        <div key={planet.id}>{planet.name}</div>\n      ))}\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Using Deduped Database Provider Middleware\nDESCRIPTION: Demonstrates how to safely apply the deduped database provider middleware across multiple handlers and nested calls without creating redundant connections.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/dedupe-middleware.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst foo = os.use(dbProvider).handler(({ context }) => 'Hello World')\n\nconst bar = os.use(dbProvider).handler(({ context }) => {\n  /**\n   * Now when you call foo, the dbProvider middleware no need to connect to the database again.\n   */\n  const result = call(foo, 'input', { context })\n\n  return 'Hello World'\n})\n\n/**\n * Now even when `dbProvider` is applied multiple times, it still only connects to the database once.\n */\nconst router = os\n  .use(dbProvider)\n  .use(({ next }) => {\n    // Additional middleware logic\n    return next()\n  })\n  .router({\n    foo,\n    bar,\n  })\n```\n\n----------------------------------------\n\nTITLE: Creating a Router Client for Multiple oRPC Procedures in TypeScript\nDESCRIPTION: Demonstrates how to create a router-based client to access multiple procedures. This approach provides a clean interface for calling related procedures with shared context.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/server-side.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createRouterClient, os } from '@orpc/server'\n\nconst ping = os.handler(() => 'pong')\nconst pong = os.handler(() => 'ping')\n\nconst client = createRouterClient({ ping, pong }, {\n  context: {} // Provide initial context if needed\n})\n\nconst result = await client.ping()\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server for ORPC Playground in Node.js\nDESCRIPTION: This command starts the development server for the ORPC playground project. It uses npm to run the 'dev' script defined in the project's package.json file.\nSOURCE: https://github.com/unnoq/orpc/blob/main/playgrounds/contract-first/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: SolidJS Query Integration Example with oRPC\nDESCRIPTION: Demonstrates how to use oRPC with Solid Query for handling queries, infinite queries, mutations and query invalidation. Shows integration with the TanStack Query ecosystem and type-safe API calls.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/solid-query/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function Example() {\n  const query = createQuery(() => orpc.planet.find.queryOptions({\n    input: { id: 123 }, // Specify input if needed\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  const query = createInfiniteQuery(() => orpc.planet.list.infiniteOptions({\n    input: (pageParam: number | undefined) => ({ limit: 10, offset: pageParam }),\n    context: { cache: true }, // Provide client context if needed\n    initialPageParam: undefined,\n    getNextPageParam: lastPage => lastPage.nextPageParam,\n  // additional options...\n  }))\n\n  const mutation = createMutation(() => orpc.planet.create.mutationOptions({\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  mutation.mutate({ name: 'Earth' })\n\n  const queryClient = useQueryClient()\n\n  // Invalidate all planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key(),\n  })\n\n  // Invalidate only regular (non-infinite) planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key({ type: 'query' })\n  })\n\n  // Invalidate the planet find query with id 123\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.find.key({ input: { id: 123 } })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring Contract Router Output Types in TypeScript\nDESCRIPTION: Shows how to use utility types to infer the output types for each procedure in the router, ensuring correct handling of procedure results.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferContractRouterOutputs } from '@orpc/contract'\n\nexport type Outputs = InferContractRouterOutputs<typeof contract>\n\ntype FindPlanetOutput = Outputs['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Implementing oRPC Handler in SvelteKit Routes\nDESCRIPTION: This snippet shows how to create an oRPC handler in a SvelteKit route file. It sets up a fetch-based RPCHandler that works with all HTTP methods (GET, POST, PUT, PATCH, DELETE) and handles routing through the SvelteKit system with a '/rpc' prefix.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/svelte-kit.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { error } from '@sveltejs/kit'\nimport { RPCHandler } from '@orpc/server/fetch'\n\nconst handler = new RPCHandler(router)\n\nconst handle: RequestHandler = async ({ request }) => {\n  const { response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  return response ?? new Response('Not Found', { status: 404 })\n}\n\nexport const GET = handle\nexport const POST = handle\nexport const PUT = handle\nexport const PATCH = handle\nexport const DELETE = handle\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Context in oRPC with TypeScript\nDESCRIPTION: This snippet demonstrates how to define an initial context in oRPC, specifying required dependencies like headers and environment variables. It shows the creation of a base context and a handler that uses this context.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/context.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$context<{ headers: Headers, env: { DB_URL: string } }>()\n\nconst getting = base\n  .handler(async ({ context }) => {\n    console.log(context.env)\n  })\n\nexport const router = { getting }\n```\n\n----------------------------------------\n\nTITLE: Starting the ORPC Playground Development Server\nDESCRIPTION: Command to start the development server for the ORPC playground project. After running this command, you can access the application at localhost:3000.\nSOURCE: https://github.com/unnoq/orpc/blob/main/playgrounds/nextjs/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Sending RPC Input with File Upload in TypeScript\nDESCRIPTION: Demonstrates how to send input data including file uploads for an RPC call using FormData in TypeScript.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst form = new FormData()\n\nform.set('data', JSON.stringify({\n  json: {\n    name: 'Earth',\n    thumbnail: {},\n    images: [{}, {}]\n  },\n  meta: [[1, 'detached_at']],\n  maps: [['images', 0], ['images', 1]]\n}))\n\nform.set('0', new Blob([''], { type: 'image/png' }))\nform.set('1', new Blob([''], { type: 'image/png' }))\n\nconst response = await fetch('https://example.com/rpc/planet/create', {\n  method: 'POST',\n  body: form\n})\n```\n\n----------------------------------------\n\nTITLE: Basic OpenAPILink Setup\nDESCRIPTION: Initial setup of OpenAPILink with basic configuration including URL and headers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { JsonifiedClient } from '@orpc/openapi-client'\nimport type { ContractRouterClient } from '@orpc/contract'\nimport { createORPCClient } from '@orpc/client'\nimport { OpenAPILink } from '@orpc/openapi-client/fetch'\n\nconst link = new OpenAPILink(contract, {\n  url: 'http://localhost:3000/api',\n  headers: () => ({\n    'x-api-key': 'my-api-key',\n  }),\n})\n\nconst client: JsonifiedClient<ContractRouterClient<typeof contract>> = createORPCClient(link)\n```\n\n----------------------------------------\n\nTITLE: Creating an Implementer Instance in TypeScript\nDESCRIPTION: Using the implement function to convert a contract into a type-safe implementer instance that replaces the standard os from @orpc/server.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/implement-contract.md#2025-04-21_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { implement } from '@orpc/server'\n\nconst os = implement(contract) // fully replaces the os from @orpc/server\n```\n\n----------------------------------------\n\nTITLE: Handling Input in oRPC Middleware with TypeScript\nDESCRIPTION: Demonstrates how middleware can access and process input, enabling use cases like permission checks. It also shows how to map input when necessary.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/middleware.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst canUpdate = os.middleware(async ({ context, next }, input: number) => {\n  // Perform permission check\n  return next()\n})\n\nconst ping = os\n  .input(z.number())\n  .use(canUpdate)\n  .handler(async ({ input }) => {\n    // Handler logic\n  })\n\n// Mapping input if necessary\nconst pong = os\n  .input(z.object({ id: z.number() }))\n  .use(canUpdate, input => input.id)\n  .handler(async ({ input }) => {\n    // Handler logic\n  })\n```\n\n----------------------------------------\n\nTITLE: Implementing Lazy URL Definition in RPCLink\nDESCRIPTION: Example of defining a URL as a function in RPCLink to ensure compatibility with environments that may lack certain runtime APIs. This prevents server-side usage in this specific case.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/rpc-link.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new RPCLink({\n  url: () => {\n    if (typeof window === 'undefined') {\n      throw new Error('RPCLink is not allowed on the server side.')\n    }\n\n    return new URL('/rpc', window.location.href)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Middleware Execution Order in oRPC\nDESCRIPTION: This code snippet demonstrates how to configure the oRPC middleware execution order, ensuring all middlewares run after input validation and before output validation by setting the initial validation indices to negative infinity.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/lifecycle.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$config({\n  initialInputValidationIndex: Number.NEGATIVE_INFINITY,\n  initialOutputValidationIndex: Number.NEGATIVE_INFINITY,\n})\n```\n\n----------------------------------------\n\nTITLE: Using the 'call' Utility for oRPC Procedures in TypeScript\nDESCRIPTION: Shows how to use the 'call' helper function to invoke oRPC procedures. This alternative approach provides the same functionality as the callable method but with a different syntax.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/server-side.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod'\nimport { call, os } from '@orpc/server'\n\nconst getProcedure = os\n  .input(z.object({ id: z.string() }))\n  .handler(async ({ input }) => ({ id: input.id }))\n\nconst result = await call(getProcedure, { id: '123' }, {\n  context: {} // Provide initial context if needed\n})\n```\n\n----------------------------------------\n\nTITLE: Throwing ORPCError in oRPC Middleware and Handler (TypeScript)\nDESCRIPTION: Demonstrates how to use ORPCError in oRPC middleware and handler functions. It shows throwing custom errors with codes, messages, and additional data.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/error-handling.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst rateLimit = os.middleware(async ({ next }) => {\n  throw new ORPCError('RATE_LIMITED', {\n    message: 'You are being rate limited',\n    data: { retryAfter: 60 }\n  })\n  return next()\n})\n\nconst example = os\n  .use(rateLimit)\n  .handler(async ({ input }) => {\n    throw new ORPCError('NOT_FOUND')\n    throw new Error('Something went wrong') // <-- will be converted to INTERNAL_SERVER_ERROR\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring GET Method Route in TypeScript RPC Handler\nDESCRIPTION: Shows how to explicitly configure a route to accept GET requests using the os.route() method with method: 'GET' parameter\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/strict-get-method.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { os } from '@orpc/server'\n\nconst ping = os\n  .route({ method: 'GET' })\n  .handler(() => 'pong')\n```\n\n----------------------------------------\n\nTITLE: Creating Reactive Queries with Svelte Stores\nDESCRIPTION: Shows how to implement reactive queries using Svelte's derived stores to dynamically update query parameters based on store values.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/svelte.md#2025-04-21_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { createQuery } from '@tanstack/svelte-query'\nimport { derived, writable } from 'svelte/store'\n\nconst id = writable(123)\n\nconst query = createQuery(\n  derived(id, $id => orpc.planet.find.queryOptions({ input: { id: $id } })),\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating ResponseHeadersPlugin with RPCHandler in oRPC\nDESCRIPTION: Shows how to add the ResponseHeadersPlugin to an oRPC handler configuration. This setup injects the resHeaders object into the context of all procedure calls handled by this instance.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/response-headers.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ResponseHeadersPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new ResponseHeadersPlugin()\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Safe Error Handling with Custom ThrowableError Type\nDESCRIPTION: Demonstrates the recommended pattern for handling errors when throwableError is configured as a union type. This approach checks the isSuccess property to determine if an operation succeeded before handling errors.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/no-throw-literal.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst { error, data, isSuccess } = await safe(client('input'))\n\nif (!isSuccess) {\n  if (isDefinedError(error)) {\n    // handle type-safe error\n  }\n  // handle other errors\n}\nelse {\n  // handle success\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing Response Headers for Batched Responses in TypeScript\nDESCRIPTION: Configures the BatchHandlerPlugin with a headers option to customize the headers sent with batched responses. This example adds a custom header to all batched responses.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/plugins/batch-request-response.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { router } from './shared/planet'\nimport { BatchHandlerPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [new BatchHandlerPlugin({\n    headers: responses => ({\n      'some-header': 'some-value',\n    })\n  })],\n})\n```\n\n----------------------------------------\n\nTITLE: Defining RPC Router in TypeScript\nDESCRIPTION: Shows how to define an RPC router with a 'planet.create' procedure using TypeScript.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = {\n  planet: {\n    create: os.handler(() => {}) // [!code highlight]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Planet List Handler in TypeScript\nDESCRIPTION: Demonstrates how to create a mock implementation of a planet list handler using the oRPC Implementer. The example shows creating a fake handler that returns an empty array.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/mocking.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { implement, unlazyRouter } from '@orpc/server'\n\nconst fakeListPlanet = implement(router.planet.list).handler(() => [])\n```\n\n----------------------------------------\n\nTITLE: Customizing ThrowableError Type in oRPC Registry\nDESCRIPTION: Shows how to customize oRPC's error handling behavior by setting the throwableError type in the Registry interface. This enables type-safe error handling in oRPC applications.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/no-throw-literal.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ndeclare module '@orpc/server' { // or '@orpc/contract', or '@orpc/client'\n  interface Registry {\n    throwableError: Error // [!code highlight]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple oRPC Clients with Unique Base Keys\nDESCRIPTION: Demonstrates how to create multiple oRPC Vue Colada utils instances with unique base keys to avoid query/mutation key conflicts.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst userORPC = createORPCVueColadaUtils(userClient, {\n  path: ['user']\n})\nconst postORPC = createORPCVueColadaUtils(postClient, {\n  path: ['post']\n})\n```\n\n----------------------------------------\n\nTITLE: Handling Type-Safe Errors with oRPC\nDESCRIPTION: Demonstrates how to use the isDefinedError helper for type-safe error handling in oRPC mutations and queries.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport { isDefinedError } from '@orpc/client'\n\nconst mutation = useMutation(orpc.planet.create.mutationOptions({\n  onError: (error) => {\n    if (isDefinedError(error)) {\n      // Handle the error here\n    }\n  },\n}))\n\nmutation.mutate({ name: 'Earth' })\n\nif (mutation.error.value && isDefinedError(mutation.error.value)) {\n  // Handle the error here\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Detailed Input Structure in oRPC (TypeScript)\nDESCRIPTION: Shows how to set up a route with detailed input structure, separating the request into distinct objects for params, query, headers, and body.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst detailedMode = os.route({\n  path: '/ping/{name}',\n  method: 'POST',\n  inputStructure: 'detailed',\n})\n  .input(z.object({\n    params: z.object({ name: z.string() }),\n    query: z.object({ search: z.string() }),\n    body: z.object({ description: z.string() }).optional(),\n    headers: z.object({ 'x-custom-header': z.string() }),\n  }))\n```\n\n----------------------------------------\n\nTITLE: Terminating Event Iterator Stream\nDESCRIPTION: Using a return statement to signal the end of the stream. This example shows how to conditionally terminate the stream when a condition is met, which is useful for finite streams.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/event-iterator.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst example = os\n  .handler(async function* ({ input, lastEventId }) {\n    while (true) {\n      if (done) {\n        return\n      }\n\n      yield { message: 'Hello, world!' }\n      await new Promise(resolve => setTimeout(resolve, 1000))\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Preventing Query/Mutation Key Conflicts with Path Configuration\nDESCRIPTION: Demonstrates how to avoid key conflicts when using multiple clients by specifying unique base path arrays when creating utility instances.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/svelte.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst userORPC = createORPCSvelteQueryUtils(userClient, {\n  path: ['user']\n})\nconst postORPC = createORPCSvelteQueryUtils(postClient, {\n  path: ['post']\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Iterator Keep Alive in RPCLink\nDESCRIPTION: Configuration options for keeping Event Iterator connections alive by sending periodic ping comments to the server. This allows customization of the keep-alive functionality including enabling/disabling, interval timing, and custom content.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/rpc-link.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new RPCLink({\n  eventIteratorKeepAliveEnabled: true,\n  eventIteratorKeepAliveInterval: 5000, // 5 seconds\n  eventIteratorKeepAliveComment: '',\n})\n```\n\n----------------------------------------\n\nTITLE: Conceptual oRPC Client Setup for SSR Optimization\nDESCRIPTION: Demonstrates the conceptual approach for creating different oRPC clients for server-side and client-side use, showing how to leverage direct API calls on the server while falling back to network requests in the browser.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Use this for server-side calls\nconst orpc = createRouterClient(router)\n\n// Fallback to this for client-side calls\nconst orpc: RouterClient<typeof router> = createORPCClient(someLink)\n```\n\n----------------------------------------\n\nTITLE: Generating OpenAPI Specs with ArkType in oRPC\nDESCRIPTION: This snippet demonstrates how to use the ArkTypeToJsonSchemaConverter from @orpc/arktype to generate OpenAPI specifications from either a contract or a router. It shows the setup process and basic usage pattern for OpenAPI generation with ArkType schema validation.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/arktype/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { OpenAPIGenerator } from '@orpc/openapi'\nimport { experimental_ArkTypeToJsonSchemaConverter as ArkTypeToJsonSchemaConverter } from '@orpc/valibot'\n\nconst openAPIGenerator = new OpenAPIGenerator({\n  schemaConverters: [\n    new ArkTypeToJsonSchemaConverter()\n  ],\n})\n\nconst specFromContract = await openAPIGenerator.generate(contract, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n\nconst specFromRouter = await openAPIGenerator.generate(router, {\n  info: {\n    title: 'My App',\n    version: '0.0.0',\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Directly Calling oRPC Procedure Clients\nDESCRIPTION: Use the call method to directly invoke a procedure client, which serves as an alias for the corresponding procedure client function.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/basic.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst result = orpc.planet.find.call({ id: 123 })\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Iterator Keep Alive Settings in TypeScript\nDESCRIPTION: Configuration example for the Event Iterator keep-alive functionality in RPCHandler. The code shows how to customize ping intervals and content to maintain persistent connections for event streams.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/rpc-handler.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler = new RPCHandler(router, {\n  eventIteratorKeepAliveEnabled: true,\n  eventIteratorKeepAliveInterval: 5000, // 5 seconds\n  eventIteratorKeepAliveComment: '',\n})\n```\n\n----------------------------------------\n\nTITLE: Defining oRPC Contract with Zod Schema\nDESCRIPTION: Creates an oRPC contract using Zod schema validation for counter-related operations including get and increment endpoints.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/tanstack-start.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { oc } from '@orpc/contract'\nimport { z } from 'zod'\n\nexport const Count = z.object({\n  value: z.number().int().min(0),\n  updatedAt: z.date(),\n})\n\nexport const incrementCountContract = oc\n  .route({ method: 'POST', path: '/count:increment' })\n  .output(Count)\n\nexport const getCountContract = oc\n  .route({ method: 'GET', path: '/count' })\n  .output(Count)\n\nexport const contract = {\n  counter: { increment: incrementCountContract, get: getCountContract },\n}\n```\n\n----------------------------------------\n\nTITLE: Sending RPC Input via URL Query in TypeScript\nDESCRIPTION: Demonstrates how to send input data for an RPC call using URL query parameters in TypeScript.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = new URL('https://example.com/rpc/planet/create')\n\nurl.searchParams.append('data', JSON.stringify({\n  json: {\n    name: 'Earth',\n    detached_at: '2022-01-01T00:00:00.000Z'\n  },\n  meta: [[1, 'detached_at']]\n}))\n\nconst response = await fetch(url)\n```\n\n----------------------------------------\n\nTITLE: Lazy URL Configuration\nDESCRIPTION: Implementation of dynamic URL configuration for environment-specific compatibility.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new OpenAPILink({\n  url: () => {\n    if (typeof window === 'undefined') {\n      throw new Error('OpenAPILink is not allowed on the server side.')\n    }\n\n    return new URL('/api', window.location.href)\n  },\n})\n```\n\n----------------------------------------\n\nTITLE: Comparing Throw Literal vs Error Instance in TypeScript\nDESCRIPTION: Demonstrates the recommended practice of throwing Error instances instead of literal values. The bad example shows throwing a string literal, while the good example shows creating and throwing an Error object.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/no-throw-literal.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// eslint-disable-next-line no-throw-literal\nthrow 'error' // ✗ avoid\nthrow new Error('error') // ✓ recommended\n```\n\n----------------------------------------\n\nTITLE: Built-in Middleware Deduplication Examples\nDESCRIPTION: Shows various scenarios where built-in middleware deduplication applies or doesn't apply, demonstrating the conditions for automatic deduplication based on middleware order and subset rules.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/dedupe-middleware.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = os.use(logging).use(dbProvider).router({\n  ping: os.use(logging).use(dbProvider).use(auth).handler(({ context }) => 'ping'),\n  pong: os.use(logging).use(dbProvider).handler(({ context }) => 'pong'),\n\n  // ⛔ Deduplication does not occur:\n  diff_subset: os.use(logging).handler(({ context }) => 'ping'),\n  diff_order: os.use(dbProvider).use(logging).handler(({ context }) => 'pong'),\n  diff_leading: os.use(monitor).use(logging).use(dbProvider).handler(({ context }) => 'bar'),\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring API Route Base Path\nDESCRIPTION: Creates a base API route configuration for oRPC by extending the parameterized route configuration.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/tanstack-start.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createAPIFileRoute } from '@tanstack/start/api'\nimport { APIRoute as BaseAPIRoute } from './rpc.$'\n\nexport const APIRoute = createAPIFileRoute('/api/rpc')(BaseAPIRoute.methods)\n```\n\n----------------------------------------\n\nTITLE: CORS Configuration with OpenAPIHandler\nDESCRIPTION: Configuration for CORS policy to expose Content-Disposition header for file responses.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler = new OpenAPIHandler(router, {\n  plugins: [\n    new CORSPlugin({\n      exposeHeaders: ['Content-Disposition'],\n    }),\n  ],\n})\n```\n\n----------------------------------------\n\nTITLE: Event Iterator Keep Alive Configuration\nDESCRIPTION: Configuration options for maintaining Event Iterator connections through periodic ping messages.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst link = new OpenAPILink({\n  eventIteratorKeepAliveEnabled: true,\n  eventIteratorKeepAliveInterval: 5000, // 5 seconds\n  eventIteratorKeepAliveComment: '',\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Event Iterator Keep-Alive Settings\nDESCRIPTION: TypeScript code showing how to configure Event Iterator keep-alive settings for the OpenAPIHandler, including enabling/disabling pings, setting ping interval, and customizing ping comments.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/openapi-handler.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler = new OpenAPIHandler(router, {\n  eventIteratorKeepAliveEnabled: true,\n  eventIteratorKeepAliveInterval: 5000, // 5 seconds\n  eventIteratorKeepAliveComment: '',\n})\n```\n\n----------------------------------------\n\nTITLE: Parsing Form Data with Bracket Notation (JSON)\nDESCRIPTION: This JSON snippet illustrates how form data using Bracket Notation is parsed into a structured object. It shows the resulting nested object structure.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": {\n    \"first\": \"John\",\n    \"last\": \"Doe\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Exceeds the Maximum Length Error in TypeScript\nDESCRIPTION: This snippet shows the TypeScript error that occurs when the inferred type of a node exceeds the maximum length the compiler will serialize. It demonstrates a large router object that triggers this error.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/exceeds-the-maximum-length-problem.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @error: The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed.\nexport const router = {\n  // many procedures here\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Router Segments Individually in TypeScript\nDESCRIPTION: This code demonstrates how to export router segments individually to avoid the 'Exceeds the Maximum Length' error. It shows separate exports for user, planet, and public routers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/exceeds-the-maximum-length-problem.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const userRouter = { /** ... */ }\nexport const planetRouter = { /** ... */ }\nexport const publicRouter = { /** ... */ }\n```\n\n----------------------------------------\n\nTITLE: Using oRPC with Svelte Query\nDESCRIPTION: Demonstrates how to use oRPC with Svelte Query for type-safe API interactions. Shows query creation, infinite queries, mutations, and cache invalidation using the TanStack Query integration.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/svelte-query/README.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function Example() {\n  const query = createQuery(orpc.planet.find.queryOptions({\n    input: { id: 123 }, // Specify input if needed\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  const query = createInfiniteQuery(orpc.planet.list.infiniteOptions({\n    input: (pageParam: number | undefined) => ({ limit: 10, offset: pageParam }),\n    context: { cache: true }, // Provide client context if needed\n    initialPageParam: undefined,\n    getNextPageParam: lastPage => lastPage.nextPageParam,\n  // additional options...\n  }))\n\n  const mutation = createMutation(orpc.planet.create.mutationOptions({\n    context: { cache: true }, // Provide client context if needed\n  // additional options...\n  }))\n\n  mutation.mutate({ name: 'Earth' })\n\n  const queryClient = useQueryClient()\n\n  // Invalidate all planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key(),\n  })\n\n  // Invalidate only regular (non-infinite) planet queries\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.key({ type: 'query' })\n  })\n\n  // Invalidate the planet find query with id 123\n  queryClient.invalidateQueries({\n    queryKey: orpc.planet.find.key({ input: { id: 123 } })\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Query and Mutation Keys\nDESCRIPTION: Demonstrates how to use the key method to generate QueryKey or MutationKey for tasks like revalidating queries or checking mutation status.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nconst queryCache = useQueryCache()\n\n// Invalidate all planet queries\nqueryCache.invalidateQueries({\n  key: orpc.planet.key(),\n})\n\n// Invalidate the planet find query with id 123\nqueryCache.invalidateQueries({\n  key: orpc.planet.find.key({ input: { id: 123 } })\n})\n```\n\n----------------------------------------\n\nTITLE: RPC Success Response Example\nDESCRIPTION: Illustrates the structure of a successful RPC response, including HTTP status and JSON payload.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_5\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n  \"json\": {\n    \"id\": \"1\",\n    \"name\": \"Earth\",\n    \"detached_at\": \"2022-01-01T00:00:00.000Z\"\n  },\n  \"meta\": [[0, \"id\"], [1, \"detached_at\"]]\n}\n```\n\n----------------------------------------\n\nTITLE: Querying API with Bracket Notation in URL (Bash)\nDESCRIPTION: This example demonstrates how to use Bracket Notation in a URL query to send structured data to an API endpoint. It shows how to represent nested object properties.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl http://example.com/api/example?name[first]=John&name[last]=Doe\n```\n\n----------------------------------------\n\nTITLE: Router Input Type Inference\nDESCRIPTION: Shows how to infer input types from router procedures using TypeScript type utilities.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferRouterInputs } from '@orpc/server'\n\nexport type Inputs = InferRouterInputs<typeof router>\n\ntype FindPlanetInput = Inputs['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC Vue Colada and Pinia Colada\nDESCRIPTION: Commands for installing the required packages using different package managers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/vue-colada@latest @pinia/colada@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/vue-colada@latest @pinia/colada@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/vue-colada@latest @pinia/colada@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/vue-colada@latest @pinia/colada@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/vue-colada@latest npm:@pinia/colada@latest\n```\n\n----------------------------------------\n\nTITLE: Installing @orpc/contract Package\nDESCRIPTION: Shows various package manager commands to install the @orpc/contract package for different environments including npm, yarn, pnpm, bun, and deno.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/define-contract.md#2025-04-21_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @orpc/contract@latest\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @orpc/contract@latest\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm add @orpc/contract@latest\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun add @orpc/contract@latest\n```\n\nLANGUAGE: shell\nCODE:\n```\ndeno install npm:@orpc/contract@latest\n```\n\n----------------------------------------\n\nTITLE: Parsing URL Query with Bracket Notation (JSON)\nDESCRIPTION: This JSON snippet shows how the URL query using Bracket Notation is parsed into a structured object. It demonstrates the resulting nested object structure.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"name\": {\n    \"first\": \"John\",\n    \"last\": \"Doe\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Router Output Type Inference\nDESCRIPTION: Demonstrates output type inference from router procedures.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferRouterOutputs } from '@orpc/server'\n\nexport type Outputs = InferRouterOutputs<typeof router>\n\ntype FindPlanetOutput = Outputs['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC Client Package\nDESCRIPTION: Different package manager commands to install the @orpc/client package.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/client/client-side.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/client@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/client@latest\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with Package Managers\nDESCRIPTION: Commands for installing required packages (@orpc/solid-query and @tanstack/solid-query) using different package managers.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/solid.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/solid-query@latest @tanstack/solid-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/solid-query@latest @tanstack/solid-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/solid-query@latest @tanstack/solid-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/solid-query@latest @tanstack/solid-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/solid-query@latest npm:@tanstack/solid-query@latest\n```\n\n----------------------------------------\n\nTITLE: Executing RPC Call via cURL\nDESCRIPTION: Demonstrates how to make an RPC call using cURL, targeting the 'planet.create' procedure.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncurl https://example.com/rpc/planet/create\n```\n\n----------------------------------------\n\nTITLE: Router Current Context Type Inference\nDESCRIPTION: Demonstrates how to infer current context types that combine initial and execution contexts.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/router.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { InferRouterCurrentContexts } from '@orpc/server'\n\nexport type CurrentContexts = InferRouterCurrentContexts<typeof router>\n\ntype FindPlanetCurrentContext = CurrentContexts['planet']['find']\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with pnpm for oRPC\nDESCRIPTION: Command to install project dependencies using pnpm package manager. This is the first step after cloning the repository to set up the development environment.\nSOURCE: https://github.com/unnoq/orpc/blob/main/CONTRIBUTING.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC Server Package\nDESCRIPTION: Various package manager commands for installing the @orpc/server package which is required for implementing oRPC contracts on the server side.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/contract-first/implement-contract.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/server@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/server@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/server@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/server@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/server@latest\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC Svelte Query Dependencies\nDESCRIPTION: Commands for installing the required dependencies using different package managers including npm, yarn, pnpm, bun, and deno.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/svelte.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/svelte-query@latest @tanstack/svelte-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/svelte-query@latest @tanstack/svelte-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/svelte-query@latest @tanstack/svelte-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/svelte-query@latest @tanstack/svelte-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/svelte-query@latest npm:@tanstack/svelte-query@latest\n```\n\n----------------------------------------\n\nTITLE: Configuring Multiple oRPC Clients\nDESCRIPTION: Example of creating multiple oRPC React Query utilities with unique base keys to prevent query/mutation key conflicts.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst userORPC = createORPCReactQueryUtils(userClient, {\n  path: ['user']\n})\nconst postORPC = createORPCReactQueryUtils(postClient, {\n  path: ['post']\n})\n```\n\n----------------------------------------\n\nTITLE: Creating a Feature Branch in Git for oRPC Development\nDESCRIPTION: Git command to create and checkout a new branch for feature development. This follows the convention of prefixing feature branches with 'feature/'.\nSOURCE: https://github.com/unnoq/orpc/blob/main/CONTRIBUTING.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout -b feature/your-feature\n```\n\n----------------------------------------\n\nTITLE: Exporting Default Route Handler for Nuxt.js RPC\nDESCRIPTION: This code exports the default route handler for RPC in Nuxt.js. It's a simple re-export of the handler defined in the '[...]' file, allowing it to be used as the index route for RPC requests.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/nuxt.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport { default } from './[...]'\n```\n\n----------------------------------------\n\nTITLE: Installing oRPC and Tanstack Query Dependencies\nDESCRIPTION: Package installation commands for different package managers including npm, yarn, pnpm, bun and deno to add oRPC and Tanstack Query dependencies.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/react-query@latest @tanstack/react-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/react-query@latest @tanstack/react-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/react-query@latest @tanstack/react-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/react-query@latest @tanstack/react-query@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/react-query@latest npm:@tanstack/react-query@latest\n```\n\n----------------------------------------\n\nTITLE: Providing oRPC Context in React App\nDESCRIPTION: Example of setting up the oRPC context provider in a React application root component.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/react.md#2025-04-21_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nexport function App() {\n  const [client] = useState<RouterClient<typeof router>>(() => createORPCClient(link))\n  const [orpc] = useState(() => createORPCReactQueryUtils(client))\n\n  return (\n    <ORPCContext.Provider value={orpc}>\n      <YourApp />\n    </ORPCContext.Provider>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Running the oRPC Development Server with npm\nDESCRIPTION: Command to start the development server for the oRPC playground. This launches a local server that hosts the SvelteKit application.\nSOURCE: https://github.com/unnoq/orpc/blob/main/playgrounds/svelte-kit/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Installing OpenAPI Handler with Package Managers\nDESCRIPTION: Commands for installing the @orpc/openapi package using various package managers including npm, yarn, pnpm, bun, and deno.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/openapi-handler.md#2025-04-21_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @orpc/openapi@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @orpc/openapi@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @orpc/openapi@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @orpc/openapi@latest\n```\n\nLANGUAGE: sh\nCODE:\n```\ndeno install npm:@orpc/openapi@latest\n```\n\n----------------------------------------\n\nTITLE: Avoiding Query/Mutation Key Conflicts in oRPC\nDESCRIPTION: Demonstrates how to prevent key conflicts by passing unique base keys when creating oRPC utility functions for different clients.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/tanstack-query/vue.md#2025-04-21_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nconst userORPC = createORPCVueQueryUtils(userClient, {\n  path: ['user']\n})\nconst postORPC = createORPCVueQueryUtils(postClient, {\n  path: ['post']\n})\n```\n\n----------------------------------------\n\nTITLE: Running the oRPC Development Server\nDESCRIPTION: Command to start the development server for the oRPC playground environment. This launches the application locally for testing and development purposes.\nSOURCE: https://github.com/unnoq/orpc/blob/main/playgrounds/solid-start/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Extending OpenAPI Schema with Examples\nDESCRIPTION: Demonstrates how to extend a Zod schema with OpenAPI-specific information such as examples using the oz.openapi wrapper function.\nSOURCE: https://github.com/unnoq/orpc/blob/main/packages/zod/README.md#2025-04-21_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { oz } from '@orpc/zod'\nimport { z } from 'zod'\n\nconst InputSchema = oz.openapi(\n  z.object({\n    name: z.string(),\n  }),\n  {\n    examples: [\n      { name: 'Earth' },\n      { name: 'Mars' },\n    ],\n    // additional options...\n  }\n)\n```\n\n----------------------------------------\n\nTITLE: Cloning oRPC Playgrounds Locally with degit\nDESCRIPTION: Commands to clone various oRPC playground projects locally using npx degit. This allows developers to copy any of the available playground templates (Next.js, Nuxt.js, Solid Start, Svelte Kit, or Contract-First) to their local environment.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/playgrounds.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx degit unnoq/orpc/playgrounds/nextjs orpc-nextjs-playground\nnpx degit unnoq/orpc/playgrounds/nuxt orpc-nuxt-playground\nnpx degit unnoq/orpc/playgrounds/solid-start orpc-solid-start-playground\nnpx degit unnoq/orpc/playgrounds/svelte-kit orpc-svelte-kit-playground\nnpx degit unnoq/orpc/playgrounds/contract-first orpc-contract-first-playground\n```\n\n----------------------------------------\n\nTITLE: Using Query Options with Pinia Colada\nDESCRIPTION: Demonstrates how to use the queryOptions method to configure queries for use with Pinia Colada hooks like useQuery.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/pinia-colada.md#2025-04-21_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nconst query = useQuery(orpc.planet.find.queryOptions({\n  input: { id: 123 }, // Specify input if needed\n  context: { cache: true }, // Provide client context if needed\n  // additional options...\n}))\n```\n\n----------------------------------------\n\nTITLE: Running the NextJS Playground for oRPC Testing\nDESCRIPTION: Commands to navigate to the NextJS playground directory and start the development server. This allows for manual verification of changes in a real application environment.\nSOURCE: https://github.com/unnoq/orpc/blob/main/CONTRIBUTING.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncd playgrounds/nextjs\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Setting Up oRPC Playground Development Environment\nDESCRIPTION: Commands to install dependencies and start the development server for any oRPC playground project. After cloning a playground, these commands prepare the environment for local development.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/playgrounds.md#2025-04-21_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Exporting oRPC Route Handler from Index File\nDESCRIPTION: This code exports all the route handlers from the catch-all route file, making them available through the index route as well. This pattern allows for cleaner route organization in SolidStart.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/solid-start.md#2025-04-21_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport * from './[...rest]'\n```\n\n----------------------------------------\n\nTITLE: Starting the oRPC Development Server with npm\nDESCRIPTION: Command to start the development server for the oRPC and Nuxt.js playground. After running this command, the playground will be accessible at localhost:3000.\nSOURCE: https://github.com/unnoq/orpc/blob/main/playgrounds/nuxt/README.md#2025-04-21_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Sending RPC Input via Request Body using cURL\nDESCRIPTION: Shows how to send input data for an RPC call using the request body with cURL.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST https://example.com/rpc/planet/create \\\n  -H 'Content-Type: application/json' \\\n  -d '{\n    \"json\": {\n      \"name\": \"Earth\",\n      \"detached_at\": \"2022-01-01T00:00:00.000Z\"\n    },\n    \"meta\": [[1, \"detached_at\"]]\n  }'\n```\n\n----------------------------------------\n\nTITLE: RPC Error Response Example\nDESCRIPTION: Shows the structure of an error response in the RPC protocol, including HTTP status and error details.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/advanced/rpc-protocol.md#2025-04-21_snippet_6\n\nLANGUAGE: http\nCODE:\n```\nHTTP/1.1 500 Internal Server Error\nContent-Type: application/json\n\n{\n  \"json\": {\n    \"defined\": false,\n    \"code\": \"INTERNAL_SERVER_ERROR\",\n    \"status\": 500,\n    \"message\": \"Internal server error\",\n    \"data\": {}\n  },\n  \"meta\": []\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Server-Side oRPC Client in Next.js Layout\nDESCRIPTION: Shows how to import the server-side oRPC client in a Next.js layout file, ensuring it's only loaded on the server before any other code runs.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/best-practices/optimize-ssr.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@/lib/orpc.server'\n// Rest of the code\n```\n\n----------------------------------------\n\nTITLE: Client Context Implementation\nDESCRIPTION: Implementation of client context for dynamic procedure calls and OpenAPILink behavior modification.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/client/openapi-link.md#2025-04-21_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ClientContext {\n  something?: string\n}\n\nconst link = new OpenAPILink<ClientContext>(contract, {\n  url: 'http://localhost:3000/api',\n  headers: async ({ context }) => ({\n    'x-api-key': context?.something ?? ''\n  })\n})\n\nconst client: JsonifiedClient<ContractRouterClient<typeof contract, ClientContext>> = createORPCClient(link)\n\nconst result = await client.planet.list(\n  { limit: 10 },\n  { context: { something: 'value' } }\n)\n```\n\n----------------------------------------\n\nTITLE: Detailed Output Type Definition in oRPC (TypeScript)\nDESCRIPTION: Defines the type structure for detailed output mode, specifying the shape of headers and body objects.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type DetailedOutput = {\n  headers: Record<string, string | string[] | undefined>\n  body: any\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Initial Input/Output Structure in oRPC (TypeScript)\nDESCRIPTION: Demonstrates how to customize the initial oRPC input/output structure settings using the .$route method.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/input-output-structure.md#2025-04-21_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst base = os.$route({ inputStructure: 'detailed' })\n```\n\n----------------------------------------\n\nTITLE: Parsing Complex Form Data with Bracket Notation (JSON)\nDESCRIPTION: This JSON snippet shows how the complex form data using Bracket Notation is parsed into a structured object. It demonstrates nested objects, arrays, sparse arrays, and file uploads.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"data\": {\n    \"names\": [\n      { \"first\": \"John1\", \"last\": \"Doe1\" },\n      { \"first\": \"John2\", \"last\": \"Doe2\" }\n    ],\n    \"ages\": [\"18\", \"<empty>\", \"25\"],\n    \"files\": [\"<binary data>\", \"<binary data>\"]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering Comparison Table in Markdown\nDESCRIPTION: This markdown code snippet renders a comprehensive comparison table of features between oRPC and other RPC/REST solutions like tRPC and ts-rest. It uses checkmarks, yellow circles, and stop signs to indicate full support, partial support, and lack of support respectively.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/comparison.md#2025-04-21_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Feature                                      | oRPC docs                                                                                    | oRPC | tRPC | ts-rest |\n| -------------------------------------------- | -------------------------------------------------------------------------------------------- | ---- | ---- | ------- |\n| End-to-end Typesafe Input/Output             |                                                                                              | ✅   | ✅   | ✅      |\n| End-to-end Typesafe Errors                   | [1](/docs/client/error-handling), [2](/docs/error-handling#type%E2%80%90safe-error-handling) | ✅   | 🟡   | ✅      |\n| End-to-end Typesafe File/Blob                | [1](/docs/file-upload-download)                                                              | ✅   | 🟡   | 🛑      |\n| End-to-end Typesafe Streaming                | [1](/docs/event-iterator)                                                                    | ✅   | ✅   | 🛑      |\n| Tanstack Query Integration (React)           | [1](/docs/tanstack-query/react)                                                              | ✅   | ✅   | 🟡      |\n| Tanstack Query Integration (Vue)             | [1](/docs/tanstack-query/vue)                                                                | ✅   | 🛑   | 🟡      |\n| Tanstack Query Integration (Solid)           | [1](/docs/tanstack-query/solid)                                                              | ✅   | 🛑   | 🟡      |\n| Tanstack Query Integration (Svelte)          | [1](/docs/tanstack-query/svelte)                                                             | ✅   | 🛑   | 🛑      |\n| Vue Pinia Colada Integration                 | [1](/docs/pinia-colada)                                                                      | ✅   | 🛑   | 🛑      |\n| With Contract-First Approach                 | [1](/docs/contract-first/define-contract)                                                    | ✅   | 🛑   | ✅      |\n| Without Contract-First Approach              |                                                                                              | ✅   | ✅   | 🛑      |\n| OpenAPI Support                              | [1](/docs/openapi/openapi-handler)                                                           | ✅   | 🟡   | 🟡      |\n| OpenAPI Support for multiple schema          | [1](/docs/openapi/openapi-handler)                                                           | ✅   | 🛑   | 🛑      |\n| OpenAPI Bracket Notation Support             | [1](/docs/openapi/bracket-notation)                                                          | ✅   | 🛑   | 🛑      |\n| Server Actions Support                       | [1](/docs/server-action)                                                                     | ✅   | ✅   | 🛑      |\n| Lazy Router                                  | [1](/docs/router#lazy-router)                                                                | ✅   | ✅   | 🛑      |\n| Native Types (Date, URL, Set, Maps, ...)     | [1](/docs/rpc-handler#supported-data-types)                                                  | ✅   | 🟡   | 🛑      |\n| Streaming response (SSE)                     | [1](/docs/event-iterator)                                                                    | ✅   | ✅   | 🛑      |\n| Standard Schema (Zod, Valibot, ArkType, ...) |                                                                                              | ✅   | ✅   | 🛑      |\n| Built-in Plugins (CORS, CSRF, Retry, ...)    |                                                                                              | ✅   | 🛑   | 🛑      |\n| Batch Request/Response                       | [1](/docs/plugins/batch-request-response)                                                    | ✅   | ✅   | 🛑      |\n| WebSockets                                   | (working)                                                                                    | 🛑   | ✅   | 🛑      |\n| Nest.js integration                          |                                                                                              | 🛑   | 🟡   | ✅      |\n```\n\n----------------------------------------\n\nTITLE: Configuring VitePress Homepage for oRPC Documentation in YAML\nDESCRIPTION: YAML frontmatter configuration for the oRPC documentation homepage, defining the page title, description, layout, hero section with actions, and feature list highlighting oRPC's capabilities.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/index.md#2025-04-21_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ntitle: oRPC - Typesafe APIs Made Simple 🪄\ndescription: Easy to build APIs that are end-to-end type-safe and adhere to OpenAPI standards\ntitleTemplate: ':title'\nlayout: home\nhero:\n  name: oRPC\n  text: Typesafe APIs Made Simple 🪄\n  tagline: Easy to build APIs that are end-to-end type-safe and adhere to OpenAPI standards\n  image:\n    light: /code-light.png\n    dark: /code-dark.png\n    alt: oRPC Example\n  actions:\n    - theme: brand\n      text: Get Started\n      link: /docs/getting-started\n    - theme: alt\n      text: Playgrounds\n      link: /docs/playgrounds\nfeatures:\n  - icon: 🔗\n    title: End-to-End Type Safety\n    details: Ensure type-safe inputs, outputs, and errors from client to server.\n  - icon: 📘\n    title: First-Class OpenAPI\n    details: Built-in support that fully adheres to the OpenAPI standard.\n  - icon: 📝\n    title: Contract-First Development\n    details: Optionally define your API contract before implementation.\n  - icon: ⚙️\n    title: Framework Integrations\n    details: Seamlessly integrate with TanStack Query (React, Vue, Solid, Svelte), Pinia Colada, and more.\n  - icon: 🚀\n    title: Server Actions\n    details: Fully compatible with React Server Actions on Next.js, TanStack Start, and other platforms.\n  - icon: 🔠\n    title: Standard Schema Support\n    details: Works out of the box with Zod, Valibot, ArkType, and other schema validators.\n  - icon: 🗃️\n    title: Native Types\n    details: Supports native types like Date, File, Blob, BigInt, URL, and more.\n  - icon: ⏱️\n    title: Lazy Router\n    details: Enhance cold start times with our lazy routing feature.\n  - icon: 📡\n    title: SSE & Streaming\n    details: Enjoy full type-safe support for SSE and streaming.\n  - icon: 🌍\n    title: Multi-Runtime Support\n    details: Fast and lightweight on Cloudflare, Deno, Bun, Node.js, and beyond.\n  - icon: 🔌\n    title: Extendability\n    details: Easily extend functionality with plugins, middleware, and interceptors.\n  - icon: 🛡️\n    title: Reliability\n    details: Well-tested, TypeScript-based, production-ready, and MIT licensed.\n---\n```\n\n----------------------------------------\n\nTITLE: Integrating oRPC with Deno HTTP Server in TypeScript\nDESCRIPTION: This code demonstrates how to set up an oRPC handler with Deno's built-in HTTP server. It creates an RPC handler with CORS support, handles requests with a specified prefix path, and returns appropriate responses based on whether the request matched an RPC endpoint.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/integrations/deno.md#2025-04-21_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { RPCHandler } from '@orpc/server/fetch'\nimport { CORSPlugin } from '@orpc/server/plugins'\n\nconst handler = new RPCHandler(router, {\n  plugins: [\n    new CORSPlugin()\n  ]\n})\n\nDeno.serve(async (request) => {\n  const { matched, response } = await handler.handle(request, {\n    prefix: '/rpc',\n    context: {} // Provide initial context if needed\n  })\n\n  if (matched) {\n    return response\n  }\n\n  return new Response('Not found', { status: 404 })\n})\n```\n\n----------------------------------------\n\nTITLE: Sending Form Data with Bracket Notation (Bash)\nDESCRIPTION: This example shows how to use Bracket Notation in form data sent via a POST request. It demonstrates sending structured data as individual form fields.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/docs/openapi/bracket-notation.md#2025-04-21_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl -X POST http://example.com/api/example \\\n  -F 'name[first]=John' \\\n  -F 'name[last]=Doe'\n```\n\n----------------------------------------\n\nTITLE: Importing and Using Sponsors Component in Vue\nDESCRIPTION: Vue script setup block that imports and uses the FullSponsors component for displaying sponsor information on the oRPC documentation homepage.\nSOURCE: https://github.com/unnoq/orpc/blob/main/apps/content/index.md#2025-04-21_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport FullSponsors from './.vitepress/theme/components/FullSponsors.vue'\n</script>\n\n<FullSponsors />\n```"
  }
]