[
  {
    "owner": "messagepack-csharp",
    "repo": "messagepack-csharp",
    "content": "TITLE: Serializing and Deserializing Objects with MessagePack in C#\nDESCRIPTION: Shows how to use MessagePackSerializer to serialize an object to bytes, deserialize it back to an object, and convert the serialized data to JSON for debugging.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var mc = new MyClass\n        {\n            Age = 99,\n            FirstName = \"hoge\",\n            LastName = \"huga\",\n        };\n\n        byte[] bytes = MessagePackSerializer.Serialize(mc);\n        MyClass mc2 = MessagePackSerializer.Deserialize<MyClass>(bytes);\n\n        var json = MessagePackSerializer.ConvertToJson(bytes);\n        Console.WriteLine(json);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Serializable Class in C#\nDESCRIPTION: Demonstrates how to define a class for MessagePack serialization using attributes. The class includes serializable properties and an ignored member.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class MyClass\n{\n    [Key(0)]\n    public int Age { get; set; }\n\n    [Key(1)]\n    public string FirstName { get; set; }\n\n    [Key(2)]\n    public string LastName { get; set; }\n\n    [IgnoreMember]\n    public string FullName { get { return FirstName + LastName; } }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic MessagePack Object Serialization in C#\nDESCRIPTION: Demonstrates three different approaches to object serialization using MessagePackObject attribute with index keys, string keys, and property name keys. Shows how serialization output differs between approaches.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class Sample1\n{\n    [Key(0)]\n    public int Foo { get; set; }\n    [Key(1)]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject]\npublic class Sample2\n{\n    [Key(\"foo\")]\n    public int Foo { get; set; }\n    [Key(\"bar\")]\n    public int Bar { get; set; }\n}\n\n[MessagePackObject(keyAsPropertyName: true)]\npublic class Sample3\n{\n    // No need for a Key attribute\n    public int Foo { get; set; }\n\n    // If want to ignore a public member, you can use the  IgnoreMember attribute\n    [IgnoreMember]\n    public int Bar { get; set; }\n}\n\n// [10,20]\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample1 { Foo = 10, Bar = 20 }));\n\n// {\"foo\":10,\"bar\":20}\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample2 { Foo = 10, Bar = 20 }));\n\n// {\"Foo\":10}\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new Sample3 { Foo = 10, Bar = 20 }));\n```\n\n----------------------------------------\n\nTITLE: Correct MessagePack Serialization in C#\nDESCRIPTION: This snippet shows the correct implementation with both classes A and B properly attributed for MessagePack serialization. The Key attribute is added to the Count property in class B to ensure proper serialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack003.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0)]\n    public B b;\n}\n\n[MessagePackObject]\npublic class B {\n    [Key(0)]\n    public int Count;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring ASP.NET Core MVC with MessagePack Formatter\nDESCRIPTION: This code snippet shows how to configure ASP.NET Core MVC to use MessagePack for serialization, improving performance. It sets up both input and output formatters.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_19\n\nLANGUAGE: csharp\nCODE:\n```\npublic void ConfigureServices(IServiceCollection services)\n{\n    services.AddMvc().AddMvcOptions(option =>\n    {\n        option.OutputFormatters.Clear();\n        option.OutputFormatters.Add(new MessagePackOutputFormatter(ContractlessStandardResolver.Options));\n        option.InputFormatters.Clear();\n        option.InputFormatters.Add(new MessagePackInputFormatter(ContractlessStandardResolver.Options));\n    });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MessagePack Resolvers in C#\nDESCRIPTION: This snippet demonstrates how to create a composite resolver that includes various extension packages and the standard resolver. It shows how to set up options for MessagePack serialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\n// Set extensions to default resolver.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    // enable extension packages first\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finally use standard (default) resolver\n    StandardResolver.Instance\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Pass options every time or set as default\nMessagePackSerializer.DefaultOptions = options;\n```\n\n----------------------------------------\n\nTITLE: Enabling LZ4 Compression for MessagePack Serialization in C#\nDESCRIPTION: Demonstrates how to enable LZ4 compression for MessagePack serialization using a modified options object. This can achieve both fast performance and compact binary sizes.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nvar lz4Options = MessagePackSerializerOptions.Standard.WithCompression(MessagePackCompression.Lz4BlockArray);\nMessagePackSerializer.Serialize(obj, lz4Options);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Composite Resolver for MessagePack in C#\nDESCRIPTION: Illustrates how to create a custom composite resolver to optimize formatter lookups and achieve maximum performance. This approach avoids the overhead of dynamic resolver composition.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MyApplicationResolver : IFormatterResolver\n{\n    public static readonly IFormatterResolver Instance = new MyApplicationResolver();\n\n    // configure your custom resolvers.\n    private static readonly IFormatterResolver[] Resolvers = new IFormatterResolver[]\n    {\n    };\n\n    private MyApplicationResolver() { }\n\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return Cache<T>.Formatter;\n    }\n\n    private static class Cache<T>\n    {\n        public static IMessagePackFormatter<T> Formatter;\n\n        static Cache()\n        {\n            // configure your custom formatters.\n            if (typeof(T) == typeof(XXX))\n            {\n                Formatter = new ICustomFormatter();\n                return;\n            }\n\n            foreach (var resolver in Resolvers)\n            {\n                var f = resolver.GetFormatter<T>();\n                if (f != null)\n                {\n                    Formatter = f;\n                    return;\n                }\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing MessagePack Serialization Callbacks in C#\nDESCRIPTION: Demonstrates how to implement IMessagePackSerializationCallbackReceiver interface to receive callbacks before serialization and after deserialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class SampleCallback : IMessagePackSerializationCallbackReceiver\n{\n    [Key(0)]\n    public int Key { get; set; }\n\n    public void OnBeforeSerialize()\n    {\n        Console.WriteLine(\"OnBefore\");\n    }\n\n    public void OnAfterDeserialize()\n    {\n        Console.WriteLine(\"OnAfter\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Resolvers using CompositeResolver in C#\nDESCRIPTION: Demonstrates how to create a composite resolver using multiple individual resolvers, including custom and standard resolvers. This allows for flexible and extensible serialization behavior.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    // resolver custom types first\n    ReactivePropertyResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitResolver.Instance,\n    MessagePack.Unity.UnityResolver.Instance,\n\n    // finally use standard resolver\n    StandardResolver.Instance\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\n\n// Each time you serialize/deserialize, specify the options:\nbyte[] msgpackBytes = MessagePackSerializer.Serialize(myObject, options);\nT myObject2 = MessagePackSerializer.Deserialize<MyObject>(msgpackBytes, options);\n```\n\n----------------------------------------\n\nTITLE: Dynamic Deserialization with MessagePack in C#\nDESCRIPTION: Example of dynamic (untyped) deserialization using MessagePack, converting blob values to primitive types.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nvar model = new DynamicModel { Name = \"foobar\", Items = new[] { 1, 10, 100, 1000 } };\nvar blob = MessagePackSerializer.Serialize(model, ContractlessStandardResolver.Options);\n\nvar dynamicModel = MessagePackSerializer.Deserialize<dynamic>(blob, ContractlessStandardResolver.Options);\n\nConsole.WriteLine(dynamicModel[\"Name\"]); // foobar\nConsole.WriteLine(dynamicModel[\"Items\"][2]); // 100\n```\n\n----------------------------------------\n\nTITLE: Implementing a Custom IFormatterResolver in C#\nDESCRIPTION: Demonstrates how to create a custom IFormatterResolver with type caching for improved performance. This example includes a sample formatter for FileInfo objects.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\npublic class SampleCustomResolver : IFormatterResolver\n{\n    // Resolver should be singleton.\n    public static readonly IFormatterResolver Instance = new SampleCustomResolver();\n\n    private SampleCustomResolver()\n    {\n    }\n\n    // GetFormatter<T>'s get cost should be minimized so use type cache.\n    public IMessagePackFormatter<T> GetFormatter<T>()\n    {\n        return FormatterCache<T>.Formatter;\n    }\n\n    private static class FormatterCache<T>\n    {\n        public static readonly IMessagePackFormatter<T> Formatter;\n\n        // generic's static constructor should be minimized for reduce type generation size!\n        // use outer helper method.\n        static FormatterCache()\n        {\n            Formatter = (IMessagePackFormatter<T>)SampleCustomResolverGetFormatterHelper.GetFormatter(typeof(T));\n        }\n    }\n}\n\ninternal static class SampleCustomResolverGetFormatterHelper\n{\n    // If type is concrete type, use type-formatter map\n    static readonly Dictionary<Type, object> formatterMap = new Dictionary<Type, object>()\n    {\n        {typeof(FileInfo), new FileInfoFormatter()}\n        // add more your own custom serializers.\n    };\n\n    internal static object GetFormatter(Type t)\n    {\n        object formatter;\n        if (formatterMap.TryGetValue(t, out formatter))\n        {\n            return formatter;\n        }\n\n        // If type can not get, must return null for fallback mechanism.\n        return null;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Union Types with MessagePack in C#\nDESCRIPTION: Shows how to use Union attributes to serialize interface-typed and abstract class-typed objects with MessagePack.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePack.Union(0, typeof(FooClass))]\n[MessagePack.Union(1, typeof(BarClass))]\npublic interface IUnionSample\n{\n}\n\n[MessagePackObject]\npublic class FooClass : IUnionSample\n{\n    [Key(0)]\n    public int XYZ { get; set; }\n}\n\n[MessagePackObject]\npublic class BarClass : IUnionSample\n{\n    [Key(0)]\n    public string OPQ { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using MessagePackSerializer with StandardResolverAllowPrivate Options\nDESCRIPTION: Example showing how to serialize and deserialize using the StandardResolverAllowPrivate resolver with the new MessagePackSerializerOptions pattern.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar msgpack = MessagePackSerializer.Serialize(objectGraph, StandardResolverAllowPrivate.Options);\nvar deserializedGraph = MessagePackSerializer.Deserialize<MyType>(msgpack, StandardResolverAllowPrivate.Options);\n```\n\n----------------------------------------\n\nTITLE: Serializing Immutable Objects with MessagePack C#\nDESCRIPTION: Demonstrates serialization of readonly/immutable objects using constructor matching and SerializationConstructor attribute.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic struct Point\n{\n    [Key(0)]\n    public readonly int X;\n    [Key(1)]\n    public readonly int Y;\n\n    [SerializationConstructor]\n    public Point(int x)\n    {\n        this.X = x;\n        this.Y = -1;\n    }\n\n    // If not marked attribute, used this(most matched argument)\n    public Point(int x, int y)\n    {\n        this.X = x;\n        this.Y = y;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using MessagePackFormatterAttribute for Custom Serialization in C#\nDESCRIPTION: Illustrates how to use MessagePackFormatterAttribute to customize serialization for a class and individual properties. Includes examples of serializing private fields and implementing a custom int formatter.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackFormatter(typeof(CustomObjectFormatter))]\npublic class CustomObject\n{\n    string internalId;\n\n    public CustomObject()\n    {\n        this.internalId = Guid.NewGuid().ToString();\n    }\n\n    // serialize/deserialize internal field.\n    class CustomObjectFormatter : IMessagePackFormatter<CustomObject>\n    {\n        public void Serialize(ref MessagePackWriter writer, CustomObject value, MessagePackSerializerOptions options)\n        {\n            options.Resolver.GetFormatterWithVerify<string>().Serialize(ref writer, value.internalId, options);\n        }\n\n        public CustomObject Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        {\n            var id = options.Resolver.GetFormatterWithVerify<string>().Deserialize(ref reader, options);\n            return new CustomObject { internalId = id };\n        }\n    }\n}\n\n// per field, member\n\npublic class Int_x10Formatter : IMessagePackFormatter<int>\n{\n    public int Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        return reader.ReadInt32() * 10;\n    }\n\n    public void Serialize(ref MessagePackWriter writer, int value, MessagePackSerializerOptions options)\n    {\n        writer.WriteInt32(value * 10);\n    }\n}\n\n[MessagePackObject]\npublic class MyClass\n{\n    // You can attach custom formatter per member.\n    [Key(0)]\n    [MessagePackFormatter(typeof(Int_x10Formatter))]\n    public int MyProperty1 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Deserializing Multiple MessagePack Structures from Stream in C#\nDESCRIPTION: This C# function demonstrates how to efficiently deserialize multiple consecutive MessagePack data structures from a stream using MessagePackStreamReader.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_22\n\nLANGUAGE: csharp\nCODE:\n```\nstatic async Task<List<T>> DeserializeListFromStreamAsync<T>(Stream stream, CancellationToken cancellationToken)\n{\n    var dataStructures = new List<T>();\n    using (var streamReader = new MessagePackStreamReader(stream))\n    {\n        while (await streamReader.ReadAsync(cancellationToken) is ReadOnlySequence<byte> msgpack)\n        {\n            dataStructures.Add(MessagePackSerializer.Deserialize<T>(msgpack, cancellationToken: cancellationToken));\n        }\n    }\n\n    return dataStructures;\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Aggregate Resolver with CompositeResolver in C#\nDESCRIPTION: Demonstrates how to create a composite resolver combining a custom formatter with StandardResolver in MessagePack-CSharp v2.x. This example shows serialization and deserialization using the composite resolver.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nvar resolver = CompositeResolver.Create(\n    new IMessagePackFormatter[] { MyCustomFormatter.Instance },\n    new IFormatterResolver[] { StandardResolver.Instance }\n);\nvar options = MessagePackSerializerOptions.Standard.WithResolver(resolver);\nvar msgpack = MessagePackSerializer.Serialize(objectGraph, options);\nvar deserializedGraph = MessagePackSerializer.Deserialize<MyType>(msgpack, options);\n```\n\n----------------------------------------\n\nTITLE: Serializing C# 9 Record Types with MessagePack\nDESCRIPTION: Shows different ways to serialize C# 9 record types using MessagePack attributes.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\n// use key as property name\n[MessagePackObject(true)]public record Point(int X, int Y);\n\n// use property: to set KeyAttribute\n[MessagePackObject] public record Point([property:Key(0)] int X, [property: Key(1)] int Y);\n\n// Or use explicit properties\n[MessagePackObject]\npublic record Person\n{\n    [Key(0)]\n    public string FirstName { get; init; }\n\n    [Key(1)]\n    public string LastName { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Contractless Serialization in MessagePack C#\nDESCRIPTION: Demonstrates how to use MessagePack without explicit attributes using ContractlessStandardResolver for JSON.NET-like behavior.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class ContractlessSample\n{\n    public int MyProperty1 { get; set; }\n    public int MyProperty2 { get; set; }\n}\n\nvar data = new ContractlessSample { MyProperty1 = 99, MyProperty2 = 9999 };\nvar bin = MessagePackSerializer.Serialize(\n  data,\n  MessagePack.Resolvers.ContractlessStandardResolver.Options);\n\n// {\"MyProperty1\":99,\"MyProperty2\":9999}\nConsole.WriteLine(MessagePackSerializer.ConvertToJson(bin));\n\n// You can also set ContractlessStandardResolver as the default.\n// (Global state; Not recommended when writing library code)\nMessagePackSerializer.DefaultOptions = MessagePack.Resolvers.ContractlessStandardResolver.Options;\n\n// Now serializable...\nvar bin2 = MessagePackSerializer.Serialize(data);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Resolver Composition in C#\nDESCRIPTION: Shows how to create a custom resolver composition that replaces the enum resolver with DynamicEnumAsStringResolver and includes DynamicContractlessObjectResolver for JSON.NET-like lightweight serialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    MessagePack.Resolvers.BuiltinResolver.Instance,\n    MessagePack.Resolvers.AttributeFormatterResolver.Instance,\n\n    // replace enum resolver\n    MessagePack.Resolvers.DynamicEnumAsStringResolver.Instance,\n\n    MessagePack.Resolvers.DynamicGenericResolver.Instance,\n    MessagePack.Resolvers.DynamicUnionResolver.Instance,\n    MessagePack.Resolvers.DynamicObjectResolver.Instance,\n\n    MessagePack.Resolvers.PrimitiveObjectResolver.Instance,\n\n    // final fallback(last priority)\n    MessagePack.Resolvers.DynamicContractlessObjectResolver.Instance\n);\n```\n\n----------------------------------------\n\nTITLE: Serializing Private Members with MessagePack C#\nDESCRIPTION: Shows how to serialize private members using the AllowPrivate resolver options.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class PrivateSample\n{\n    [Key(0)]\n    int x;\n\n    public void SetX(int v)\n    {\n        x = v;\n    }\n\n    public int GetX()\n    {\n        return x;\n    }\n}\n\nvar data = new PrivateSample();\ndata.SetX(9999);\n\n// You can choose either StandardResolverAllowPrivate\n// or ContractlessStandardResolverAllowPrivate\nvar bin = MessagePackSerializer.Serialize(\n  data,\n  MessagePack.Resolvers.DynamicObjectResolverAllowPrivate.Options);\n```\n\n----------------------------------------\n\nTITLE: Implementing IMessagePackFormatter<T> Interface in C#\nDESCRIPTION: The IMessagePackFormatter<T> interface definition that is responsible for serializing a unique type in MessagePack-CSharp. This interface requires implementation of Serialize and Deserialize methods.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_23\n\nLANGUAGE: csharp\nCODE:\n```\npublic interface IMessagePackFormatter<T>\n{\n    void Serialize(ref MessagePackWriter writer, T value, MessagePackSerializerOptions options);\n    T Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options);\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring String Interning for MessagePack Serialization in C#\nDESCRIPTION: Demonstrates how to enable string interning for all string values during MessagePack deserialization using a custom resolver. This can improve performance when dealing with repetitive string data.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = MessagePackSerializerOptions.Standard.WithResolver(\n    CompositeResolver.Create(\n        new IMessagePackFormatter[] { new StringInterningFormatter() },\n        new IFormatterResolver[] { StandardResolver.Instance }));\n\nMessagePackSerializer.Deserialize<ClassOfStrings>(data, options);\n```\n\n----------------------------------------\n\nTITLE: Applying String Interning to Specific Fields in MessagePack Objects in C#\nDESCRIPTION: Shows how to apply string interning to specific fields of a MessagePack object using attributes. This allows for targeted performance optimization on fields likely to contain duplicate strings.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class ClassOfStrings\n{\n    [Key(0)]\n    [MessagePackFormatter(typeof(StringInterningFormatter))]\n    public string InternedString { get; set; }\n\n    [Key(1)]\n    public string OrdinaryString { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Custom FileInfo Formatter Implementation in C#\nDESCRIPTION: An example of a custom IMessagePackFormatter implementation for the FileInfo type that serializes it by its full path as a string. The implementation includes proper handling of null values and security depth tracking.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_24\n\nLANGUAGE: csharp\nCODE:\n```\n/// <summary>Serializes a <see cref=\"FileInfo\" /> by its full path as a string.</summary>\npublic class FileInfoFormatter : IMessagePackFormatter<FileInfo>\n{\n    public void Serialize(\n      ref MessagePackWriter writer, FileInfo value, MessagePackSerializerOptions options)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteString(value.FullName);\n    }\n\n    public FileInfo Deserialize(\n      ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return null;\n        }\n\n        options.Security.DepthStep(ref reader);\n\n        var path = reader.ReadString();\n\n        reader.Depth--;\n        return new FileInfo(path);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MessagePack Security Settings in C#\nDESCRIPTION: Demonstrates how to configure security settings for MessagePack serialization when dealing with untrusted data.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = MessagePackSerializerOptions.Standard\n    .WithSecurity(MessagePackSecurity.UntrustedData);\n\n// Pass the options explicitly for the greatest control.\nT object = MessagePackSerializer.Deserialize<T>(data, options);\n\n// Or set the security level as the default.\nMessagePackSerializer.DefaultOptions = options;\n```\n\n----------------------------------------\n\nTITLE: Registering IgnoreFormatter for Unsupported Types in MessagePack C#\nDESCRIPTION: Shows how to register IgnoreFormatter to handle types that cannot be serialized normally, causing them to be serialized as null. This example demonstrates using CompositeResolver to register formatters for reflection types.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\n// CompositeResolver can set custom formatter.\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new IMessagePackFormatter[]\n    {\n        // for example, register reflection infos (can not serialize)\n        new IgnoreFormatter<MethodBase>(),\n        new IgnoreFormatter<MethodInfo>(),\n        new IgnoreFormatter<PropertyInfo>(),\n        new IgnoreFormatter<FieldInfo>()\n    },\n    new IFormatterResolver[]\n    {\n        ContractlessStandardResolver.Instance\n    });\n```\n\n----------------------------------------\n\nTITLE: Correct MessagePack Formatter Implementation - C#\nDESCRIPTION: Proper implementation showing CustomBFormatter implementing IMessagePackFormatter<B> with required Serialize and Deserialize methods.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack006.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0), MessagePackFormatter(typeof(CustomBFormatter))]\n    public B b;\n}\n\npublic class CustomBFormatter : IMessagePackFormatter<B> {\n    void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n\n    B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing AOT formatter incompatibility by suppressing source generation in C#\nDESCRIPTION: This code snippet demonstrates how to fix the AOT formatter incompatibility by suppressing source generation for the problematic type using the SuppressSourceGeneration property.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack016.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n-[MessagePackObject]\n+[MessagePackObject(SuppressSourceGeneration = true)]\n public class A\n```\n\n----------------------------------------\n\nTITLE: Deserializing Multiple MessagePack Structures from Stream\nDESCRIPTION: Example of using MessagePackStreamReader to deserialize multiple consecutive messagepack structures from a stream efficiently.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nstatic async Task<List<T>> DeserializeListFromStreamAsync<T>(Stream stream, CancellationToken cancellationToken)\n{\n    var dataStructures = new List<T>();\n    using (var streamReader = new MessagePackStreamReader(stream))\n    {\n        while (await streamReader.ReadAsync(cancellationToken) is ReadOnlySequence<byte> msgpack)\n        {\n            dataStructures.Add(MessagePackSerializer.Deserialize<T>(msgpack, cancellationToken: cancellationToken));\n        }\n    }\n\n    return dataStructures;\n}\n```\n\n----------------------------------------\n\nTITLE: Complex Object Formatter with Multiple Fields in C#\nDESCRIPTION: A more complex IMessagePackFormatter implementation that handles a custom object with multiple fields. This formatter demonstrates proper array handling and shows the correct pattern for reading/writing multiple values using array headers.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_25\n\nLANGUAGE: csharp\nCODE:\n```\npublic class MySpecialObjectFormatter : IMessagePackFormatter<MySpecialObject>\n{\n    public void Serialize(\n      ref MessagePackWriter writer, MySpecialObject value, MessagePackSerializerOptions options)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteArrayHeader(2);\n        writer.WriteString(value.FullName);\n        writer.WriteString(value.Age);\n    }\n\n    public MySpecialObject Deserialize(\n      ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return null;\n        }\n\n        options.Security.DepthStep(ref reader);\n\n        string fullName = null;\n        int age = 0;\n\n        // Loop over *all* array elements independently of how many we expect,\n        // since if we're serializing an older/newer version of this object it might\n        // vary in number of elements that were serialized, but the contract of the formatter\n        // is that exactly one data structure must be read, regardless.\n        // Alternatively, we could check that the size of the array/map is what we expect\n        // and throw if it is not.\n        int count = reader.ReadArrayHeader();\n        for (int i = 0; i < count; i++)\n        {\n            switch (i)\n            {\n                case 0:\n                    fullName = reader.ReadString();\n                    break;\n                case 1:\n                    age = reader.ReadInt32();\n                    break;\n                default:\n                    reader.Skip();\n                    break;\n            }\n        }\n\n        reader.Depth--;\n        return new MySpecialObject(fullName, age);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from LZ4MessagePackSerializer to Standard Serializer\nDESCRIPTION: Shows how to update code from using the deprecated LZ4MessagePackSerializer to the new compression options in MessagePackSerializer.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n-byte[] buffer = LZ4MessagePackSerializer.Serialize(\"hi\");\n+static readonly lz4Options = MessagePackSerializerOptions.Standard.WithCompression(MessagePackCompression.Lz4BlockArray);\n+byte[] buffer = MessagePackSerializer.Serialize(\"hi\", lz4Options);\n```\n\n----------------------------------------\n\nTITLE: Recommended Static Options Implementation\nDESCRIPTION: Correct implementation using readonly static options with immutable Standard options.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack002.md#2025-04-23_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n    public static readonly MessagePackSerializerOptions MyOptions = MessagePackSerializerOptions.Standard;\n\n    void Bar()\n    {\n        MessagePackSerializer.Serialize(obj, MyOptions);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: MessagePack Formatter with Public Constructor\nDESCRIPTION: Corrected implementation that uses the default public constructor pattern, making the formatter instance accessible to the source generator.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack013.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass CustomBFormatter : IMessagePackFormatter<B> {\n    void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n\n    B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n}\n```\n\n----------------------------------------\n\nTITLE: Recommended Standard Options Usage\nDESCRIPTION: Correct implementation using immutable Standard options.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack002.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nMessagePackSerializer.Serialize(obj, MessagePackSerializerOptions.Standard);\n```\n\n----------------------------------------\n\nTITLE: MessagePack Formatter with Singleton Pattern\nDESCRIPTION: Alternative implementation using the singleton pattern with a static Instance field, providing accessor to the formatter instance while maintaining private constructor.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack013.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nclass CustomBFormatter : IMessagePackFormatter<B> {\n    public static readonly CustomBFormatter Instance = new();\n\n    private CustomBFormatter { } // hides the default public constructor\n\n    void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n\n    B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing and Deserializing Dynamic Objects with MessagePack C#\nDESCRIPTION: Shows how to create, serialize, and deserialize dynamic objects using ExpandoObject with MessagePack. The example demonstrates creating a dynamic object with various property types, serializing it to MessagePack format, converting to JSON, and then deserializing back to an ExpandoObject with property verification.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/ExpandoObject.md#2025-04-23_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\ndynamic expando = new ExpandoObject();\nexpando.Name = \"George\";\nexpando.Age = 18;\nexpando.Other = new { OtherProperty = \"foo\" };\n\nbyte[] bin = MessagePackSerializer.Serialize(expando, MessagePackSerializerOptions.Standard);\nthis.logger.WriteLine(MessagePackSerializer.ConvertToJson(bin)); // {\"Name\":\"George\",\"Age\":18,\"Other\":{\"OtherProperty\":\"foo\"}}\n\ndynamic expando2 = MessagePackSerializer.Deserialize<ExpandoObject>(bin, ExpandoObjectResolver.Options);\nAssert.Equal(expando.Name, expando2.Name);\nAssert.Equal(expando.Age, expando2.Age);\nAssert.NotNull(expando2.Other);\nAssert.Equal(expando.Other.OtherProperty, expando2.Other.OtherProperty);\n```\n\n----------------------------------------\n\nTITLE: Correct MessagePack Formatter Implementation with Null Handling\nDESCRIPTION: Proper implementation of a MessagePack formatter that correctly handles null references by using nullable reference types and explicit null checks.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack014.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass B { }\n\nclass CustomBFormatter : IMessagePackFormatter<B?> {\n    void Serialize(ref MessagePackWriter writer, B? value, MessagePackSerializerOptions options) {\n        if (value is null) {\n            writer.WriteNil();\n            return;\n        }\n\n        writer.WriteArrayHeader(0);\n    }\n\n    B? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options) {\n        if (reader.TryReadNil()) return null;\n\n        int count = reader.ReadArrayHeader();\n        for (int i = 0; i < count; i++)\n            reader.Skip();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Combining MessagePack Options with LZ4 Compression\nDESCRIPTION: Demonstrates how to combine a resolver with additional options like LZ4 compression using the fluent WithCompression method.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = StandardResolverAllowPrivate.Options.WithCompression(MessagePackCompression.Lz4BlockArray);\nvar msgpack = MessagePackSerializer.Serialize(objectGraph, options);\nvar deserializedGraph = MessagePackSerializer.Deserialize<MyType>(msgpack, options);\n```\n\n----------------------------------------\n\nTITLE: Enabling AOT formatter compatibility by using standard KeyAttribute in C#\nDESCRIPTION: This code snippet shows how to enable AOT formatter compatibility by replacing the custom CompositeKeyAttribute with the standard KeyAttribute, allowing proper source generation.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack016.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    [Key(\"A1\")]\n    public string Prop1 { get; set; }\n\n    [Key(\"A2\")]\n    public string Prop2 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect MessagePack Serialization Without Options\nDESCRIPTION: Example of problematic serialization pattern that relies on static default options which can be modified by other code in the AppDomain.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack001.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nMessagePackSerializer.Serialize(obj);\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom LoadType Method in MessagePackSerializerOptions in C#\nDESCRIPTION: Shows how to create a custom MessagePackSerializerOptions class that overrides the LoadType method. This is useful for customizing type loading behavior during deserialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass LoadTypeCustomizedOptions : MessagePackSerializerOptions\n{\n    internal LoadTypeCustomizedOptions(MessagePackSerializerOptions copyFrom)\n        : base(copyFrom)\n    {\n    }\n\n    internal LoadTypeCustomizedOptions(IFormatterResolver resolver)\n        : base(resolver)\n    {\n    }\n\n    public override Type LoadType(string typeName)\n    {\n        Type type = base.LoadType(typeName);\n        if (type == null)\n        {\n            // custom logic here\n        }\n\n        return type;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Serialization Performance in C#\nDESCRIPTION: This code snippet presents a benchmark comparison of serialization performance for various serialization libraries in C#. It includes different configurations of MessagePack for C#, as well as other popular serializers like ProtobufNet, Hyperion, and Json.NET.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |              IntKey |    84.11 ns |    NA |   1.00 | 0.0094 |      40 B |\n |           StringKey |   126.75 ns |    NA |   1.51 | 0.0341 |     144 B |\n |     Typeless_IntKey |   183.31 ns |    NA |   2.18 | 0.0265 |     112 B |\n |  Typeless_StringKey |   193.95 ns |    NA |   2.31 | 0.0513 |     216 B |\n |       MsgPackCliMap |   967.68 ns |    NA |  11.51 | 0.1297 |     552 B |\n |     MsgPackCliArray |   284.20 ns |    NA |   3.38 | 0.1006 |     424 B |\n |         ProtobufNet |   176.43 ns |    NA |   2.10 | 0.0665 |     280 B |\n |            Hyperion |   280.14 ns |    NA |   3.33 | 0.1674 |     704 B |\n |       ZeroFormatter |   149.95 ns |    NA |   1.78 | 0.1009 |     424 B |\n |       JsonNetString | 1,432.55 ns |    NA |  17.03 | 0.4616 |    1944 B |\n | JsonNetStreamWriter | 1,775.72 ns |    NA |  21.11 | 1.5526 |    6522 B |\n |           JilString |   547.51 ns |    NA |   6.51 | 0.3481 |    1464 B |\n |     JilStreamWriter |   778.78 ns |    NA |   9.26 | 1.4448 |    6066 B |\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableInt16Formatter in MessagePack-CSharp v2.x\nDESCRIPTION: Demonstrates the updated implementation of a custom formatter for nullable Int16 in MessagePack-CSharp v2.x. This version uses MessagePackWriter and MessagePackReader for improved efficiency.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nclass NullableInt16Formatter : IMessagePackFormatter<Int16?>\n{\n    public void Serialize(ref MessagePackWriter writer, Int16? value, MessagePackSerializerOptions options)\n    {\n        if (value == null)\n        {\n            writer.WriteNil();\n        }\n        else\n        {\n            writer.Write(value.Value);\n        }\n    }\n\n    public Int16? Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n    {\n        if (reader.TryReadNil())\n        {\n            return default;\n        }\n        else\n        {\n            return reader.ReadInt16();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Deserialization Performance in C#\nDESCRIPTION: This code snippet shows a benchmark comparison of deserialization performance for different serialization options in C#. It includes MessagePack for C# with various configurations, as well as other popular serializers like ProtobufNet, Hyperion, and Json.NET.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\n |              Method |        Mean | Error | Scaled |  Gen 0 | Allocated |\n |-------------------- |------------:|------:|-------:|-------:|----------:|\n |            M IntKey |    72.67 ns |    NA |   1.00 | 0.0132 |      56 B |\n |         M StringKey |   217.95 ns |    NA |   3.00 | 0.0131 |      56 B |\n |   M Typeless_IntKey |   176.71 ns |    NA |   2.43 | 0.0131 |      56 B |\n |M Typeless_StringKey |   378.64 ns |    NA |   5.21 | 0.0129 |      56 B |\n |       MsgPackCliMap | 1,355.26 ns |    NA |  18.65 | 0.1431 |     608 B |\n |     MsgPackCliArray |   455.28 ns |    NA |   6.26 | 0.0415 |     176 B |\n |         ProtobufNet |   265.85 ns |    NA |   3.66 | 0.0319 |     136 B |\n |            Hyperion |   366.47 ns |    NA |   5.04 | 0.0949 |     400 B |\n |       JsonNetString | 2,783.39 ns |    NA |  38.30 | 0.6790 |    2864 B |\n | JsonNetStreamReader | 3,297.90 ns |    NA |  45.38 | 1.4267 |    6000 B |\n |           JilString |   553.65 ns |    NA |   7.62 | 0.0362 |     152 B |\n |     JilStreamReader | 1,408.46 ns |    NA |  19.38 | 0.8450 |    3552 B |\n```\n\n----------------------------------------\n\nTITLE: Serializing Internal Members with MessagePackObject in C#\nDESCRIPTION: This code snippet shows a class with an internal member that requires AllowPrivate to be set for proper serialization. Without AllowPrivate, dynamically generated formatters may fail to serialize the type.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack015.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class MyData {\n    [Key(0)]\n    internal int Foo { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Generated MessagePack Resolver\nDESCRIPTION: Example of creating a custom resolver using the GeneratedMessagePackResolver attribute. This enables customizing the source-generated resolver that bundles together formatters for AOT compilation scenarios.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\n[GeneratedMessagePackResolver]\npartial class MyResolver\n{\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Internal Class with MessagePackObject in C#\nDESCRIPTION: This example demonstrates an internal class that needs AllowPrivate set on its MessagePackObject attribute. Even though the member is public, the internal class itself requires AllowPrivate for proper serialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack015.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\ninternal class MyData {\n    [Key(0)]\n    public int Foo { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect MessagePack Serialization in C#\nDESCRIPTION: This snippet demonstrates an incorrect implementation where the class B is not properly attributed for MessagePack serialization. This will cause issues when serializing instances of class A.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack003.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0)]\n    public B b;\n}\n\npublic class B {\n    public int Count;\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing MessagePackObject Serialization with AllowPrivate in C#\nDESCRIPTION: This snippet shows the correct way to set AllowPrivate on the MessagePackObject attribute. This allows serialization of internal members and classes, and enables analyzers to properly check non-public member annotations.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack015.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject(AllowPrivate = true)]\ninternal class MyData {\n    [Key(0)]\n    internal int Foo { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MessagePack with UnsafeBlitResolver for High-Performance Unity Serialization\nDESCRIPTION: Example of registering multiple resolvers for Unity applications, including UnityBlitWithPrimitiveArrayResolver for high-performance array serialization. This configuration enables extremely fast serialization of struct arrays commonly used in Unity.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\nStaticCompositeResolver.Instance.Register(\n    MessagePack.Unity.UnityResolver.Instance,\n    MessagePack.Unity.Extension.UnityBlitWithPrimitiveArrayResolver.Instance,\n    MessagePack.Resolvers.StandardResolver.Instance\n);\n\nvar options = MessagePackSerializerOptions.Standard.WithResolver(StaticCompositeResolver.Instance);\nMessagePackSerializer.DefaultOptions = options;\n```\n\n----------------------------------------\n\nTITLE: Fixing Inaccessible Nested Type for MessagePack Serialization in C#\nDESCRIPTION: This snippet shows the correct way to declare a nested type for MessagePack serialization by explicitly setting its visibility to 'internal'. This allows the source-generated formatter to access the type.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack012.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Outer {\n    [MessagePackObject]\n    internal class DataType { }\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing MessagePack Resolver with Unity Support\nDESCRIPTION: Code that runs at Unity initialization to register the UnityResolver with the default MessagePack options. This enables automatic serialization support for Unity-specific types like Vector3 and Quaternion.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\n[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.SubsystemRegistration)]\nprivate static void Init()\n{\n    MessagePackSerializer.DefaultOptions = MessagePackSerializerOptions.Standard.WithResolver(UnityResolver.InstanceWithStandardResolver);\n}\n```\n\n----------------------------------------\n\nTITLE: Correct MessagePack Serialization With Explicit Options\nDESCRIPTION: Recommended approach using explicit MessagePackSerializerOptions.Standard to ensure consistent serialization behavior regardless of global state.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack001.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nMessagePackSerializer.Serialize(obj, MessagePackSerializerOptions.Standard);\n```\n\n----------------------------------------\n\nTITLE: Using Custom MessagePackSerializerOptions for Deserialization in C#\nDESCRIPTION: Demonstrates how to use a custom MessagePackSerializerOptions instance for deserialization, which can be useful when custom type loading behavior is needed.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = new LoadTypeCustomizedOptions(MessagePackSerializerOptions.Standard);\nT value = MessagePackSerializer.Deserialize<T>(sequence, options);\n```\n\n----------------------------------------\n\nTITLE: Correct MessagePack Key Attribution\nDESCRIPTION: Proper implementation showing how to mark all public members for serialization using Key attributes with unique index values.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack004.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class C {\n    [Key(0)]\n    public int A { get; set; }\n\n    [Key(1)]\n    public int B { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid MessagePack Object Member Attribution\nDESCRIPTION: Example showing incorrect implementation where a public member lacks required MessagePack attributes. This pattern triggers the MsgPack004 analyzer warning.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack004.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class C {\n    [Key(0)]\n    public int A { get; set; }\n\n    public int B { get; set; } // MsgPack004\n}\n```\n\n----------------------------------------\n\nTITLE: MessagePack Member Exclusion\nDESCRIPTION: Alternative implementation showing how to explicitly exclude a public member from serialization using the IgnoreMember attribute.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack004.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class C {\n    [Key(0)]\n    public int A { get; set; }\n\n    [IgnoreMember]\n    public int B { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring MessagePack Resolver with PrimitiveArrayResolver\nDESCRIPTION: Code demonstrates how to set up a composite resolver that includes PrimitiveArrayResolver for optimized primitive array handling alongside the standard resolver.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/src/MessagePack.Experimental/HardwareIntrinsics/HardwareIntrinsics.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(new[] { PrimitiveArrayResolver.Instance, MessagePack.Resolvers.StandardResolver.Instance });\n```\n\n----------------------------------------\n\nTITLE: Alternative MessagePack Serialization Using Custom Formatter in C#\nDESCRIPTION: This snippet demonstrates an alternative approach using a custom formatter for class B. The MessagePackAssumedFormattable attribute is used to suppress the diagnostic, but it requires ensuring that the custom formatter is discoverable via the IFormatterResolver.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack003.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: MessagePackAssumedFormattable(typeof(B))]\n```\n\n----------------------------------------\n\nTITLE: Fix by Adding Explicit Key Attribute in MessagePack Serialization\nDESCRIPTION: Alternative solution using the Key attribute to assign a unique serialization key to the redefined property. This allows keeping the same property name in the code while ensuring unique names in the serialized format.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack018.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    public string Prop1 { get; set; }\n}\n\n[MessagePackObject]\npublic class B : A\n{\n    [Key(\"B_Prop1\")]\n    public new string Prop1 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Index Gap Handling in MessagePack C#\nDESCRIPTION: Shows how MessagePack handles non-sequential index keys by inserting null placeholders in the serialized output.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class IntKeySample\n{\n    [Key(3)]\n    public int A { get; set; }\n    [Key(10)]\n    public int B { get; set; }\n}\n\n// [null,null,null,0,null,null,null,null,null,null,0]\nConsole.WriteLine(MessagePackSerializer.SerializeToJson(new IntKeySample()));\n```\n\n----------------------------------------\n\nTITLE: Fix by Renaming Colliding Property in MessagePack Serialization\nDESCRIPTION: Solution to the name collision by renaming one of the properties to ensure uniqueness. This approach prevents serialization conflicts by ensuring each property has a distinct name.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack018.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    public string Prop1 { get; set; }\n}\n\n[MessagePackObject]\npublic class B : A\n{\n    public string Prop2 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Fixing Inaccessible Formatter in C#\nDESCRIPTION: This snippet demonstrates the correct way to declare a formatter as a nested type by explicitly using the 'internal' modifier. This fixes the issue flagged by the MsgPack010 analyzer.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack010.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nclass Outer {\n    internal class CustomBFormatter : IMessagePackFormatter<B> {\n        void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n            => throw new NotImplementedException();\n\n        B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n            => throw new NotImplementedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Usage with Default Options\nDESCRIPTION: Example of an anti-pattern using mutable default options that should be avoided.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack002.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nMessagePackSerializer.Serialize(obj, MessagePackSerializer.DefaultOptions);\n```\n\n----------------------------------------\n\nTITLE: Alternative Fix: Internal Visibility for Serializable Members in C#\nDESCRIPTION: An alternative solution to the MsgPack011 analyzer warning, changing the visibility of serializable members to 'internal' instead of using the 'partial' keyword.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack011.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0)]\n    internal B b;\n}\n```\n\n----------------------------------------\n\nTITLE: Incorrect MessagePack Formatter Implementation without Null Handling\nDESCRIPTION: Example of a problematic formatter implementation that doesn't handle null references, which triggers the MsgPack014 analyzer warning.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack014.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass B { }\n\nclass CustomBFormatter : IMessagePackFormatter<B> { // MsgPack014\n    void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options) {\n        writer.WriteArrayHeader(0);\n    }\n\n    B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options) {\n        int count = reader.ReadArrayHeader();\n        for (int i = 0; i < count; i++)\n            reader.Skip();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding MessagePackAssumedFormattable Attribute in C#\nDESCRIPTION: This code snippet demonstrates how to add the MessagePackAssumedFormattable attribute to a project for types that were previously listed in the MessagePackAnalyzer.json file. This is part of the migration process from MessagePack v2 to v3.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v2-v3.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[assembly: MessagePackAssumedFormattable(typeof(MyType1))]\n```\n\n----------------------------------------\n\nTITLE: Configuring MessagePack Resolver with UnsafeUnmanagedStructFormatter\nDESCRIPTION: Example showing how to create a CompositeResolver with UnsafeUnmanagedStructFormatter for Matrix4x4 type. The formatter is initialized with a type code of 96, which is embedded in the serialized byte sequence.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/src/MessagePack.Experimental/UnsafeUnmanagedStructFormatter/UnsafeUnmanagedStructFormatter.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nvar resolver = MessagePack.Resolvers.CompositeResolver.Create(\n    new[] { new UnsafeUnmanagedStructFormatter<Matrix4x4>(typeCode: 96) },\n    new[] { MessagePack.Resolvers.StandardResolver.Instance });\n```\n\n----------------------------------------\n\nTITLE: Problematic Static Mutable Options\nDESCRIPTION: Example showing incorrect implementation with mutable static options that can lead to issues.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack002.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n    public static MessagePackSerializerOptions MyOptions = MessagePackSerializerOptions.Standard;\n\n    void Bar()\n    {\n        MessagePackSerializer.Serialize(obj, MyOptions); // diagnostic flagged here\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating KeyAttribute-derived attribute usage in C#\nDESCRIPTION: This code snippet shows a class using a custom CompositeKeyAttribute derived from KeyAttribute, which causes incompatibility with AOT formatters.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack016.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    [CompositeKey(0, 1)]\n    public string Prop1 { get; set; }\n\n    [CompositeKey(0, 2)]\n    public string Prop2 { get; set; }\n}\n\npublic class CompositeKeyAttribute : KeyAttribute\n{\n    public CompositeKeyAttribute(byte level, int index)\n        : base(CreateKey(level, index)) { }\n\n    private static string CreateKey(byte level, int index)\n    {\n        var c = (char)('A' + level);\n        return c + index.ToString(\"x\");\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Invalid MessagePack Formatter Implementation - C#\nDESCRIPTION: Example of incorrect implementation where CustomBFormatter does not implement IMessagePackFormatter<T>, which will trigger the MsgPack006 diagnostic.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack006.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0), MessagePackFormatter(typeof(CustomBFormatter))]\n    public B b;\n}\n\npublic class CustomBFormatter {}\n```\n\n----------------------------------------\n\nTITLE: Implementing NullableInt16Formatter in MessagePack-CSharp v1.x\nDESCRIPTION: Shows the implementation of a custom formatter for nullable Int16 in MessagePack-CSharp v1.x. This formatter handles serialization and deserialization of Int16? values.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass NullableInt16Formatter : IMessagePackFormatter<Int16?>\n{\n    public int Serialize(ref byte[] bytes, int offset, Int16? value, IFormatterResolver formatterResolver)\n    {\n        if (value == null)\n        {\n            return MessagePackBinary.WriteNil(ref bytes, offset);\n        }\n        else\n        {\n            return MessagePackBinary.WriteInt16(ref bytes, offset, value.Value);\n        }\n    }\n\n    public Int16? Deserialize(byte[] bytes, int offset, IFormatterResolver formatterResolver, out int readSize)\n    {\n        if (MessagePackBinary.IsNil(bytes, offset))\n        {\n            readSize = 1;\n            return null;\n        }\n        else\n        {\n            return MessagePackBinary.ReadInt16(bytes, offset, out readSize);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing MessagePack Extension Packages in PowerShell\nDESCRIPTION: This PowerShell snippet shows how to install various MessagePack extension packages using the Package Manager Console in Visual Studio.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_20\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package MessagePack.ReactiveProperty\nInstall-Package MessagePack.UnityShims\nInstall-Package MessagePack.AspNetCoreMvcFormatter\n```\n\n----------------------------------------\n\nTITLE: Installing MessagePack Experimental Package in PowerShell\nDESCRIPTION: This PowerShell command installs the experimental package for MessagePack, which provides highly performant formatters.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/README.md#2025-04-23_snippet_21\n\nLANGUAGE: powershell\nCODE:\n```\nInstall-Package MessagePack.Experimental\n```\n\n----------------------------------------\n\nTITLE: Conditional DateTime Conversion in MessagePack-CSharp v2.x\nDESCRIPTION: In MessagePack-CSharp v2.x, DateTime.ToUniversalTime() is only called if DateTime.Kind is DateTimeKind.Local. This change affects the serialization of DateTimeKind.Unspecified values.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime.ToUniversalTime()\n```\n\n----------------------------------------\n\nTITLE: Creating MessagePackSerializerOptions Manually\nDESCRIPTION: Shows how to manually create MessagePackSerializerOptions by chaining multiple configuration options together.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migrating_v1-v2.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nvar options = MessagePackSerializerOptions.Standard\n    .WithCompression(MessagePackCompression.Lz4BlockArray)\n    .WithResolver(StandardResolverAllowPrivate.Instance);\n```\n\n----------------------------------------\n\nTITLE: Fixed MessagePackObject Class with Partial Modifier in C#\nDESCRIPTION: The recommended fix for the MsgPack011 analyzer warning, adding the 'partial' keyword to the class declaration to allow source-generated formatters to access private members.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack011.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic partial class A {\n    [Key(0)]\n    private B b;\n}\n```\n\n----------------------------------------\n\nTITLE: Documenting MsgPack008 AOT Limitations in Markdown\nDESCRIPTION: This markdown snippet explains that AOT source generated formatters in MessagePack for C# have certain limitations compared to dynamically generated formatters at runtime. It advises users to examine specific error messages to understand and correct issues.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack008.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# MsgPack008 AOT limitations\n\nAOT source generated formatters do not support certain features that formatters generated dynamically at runtime may support.\n\nThere are a variety of conditions that can produce this diagnostic.\nExamine the specific message to understand what is wrong and how to correct it.\n```\n\n----------------------------------------\n\nTITLE: Problematic MessagePack Serialization with Name Collision in Derived Class\nDESCRIPTION: Example showing a name collision problem when a derived class redefines a property from its base class without using a Key attribute in force map mode. This creates a serialization conflict since both properties would be serialized with the same name.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack018.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    public string Prop1 { get; set; }\n}\n\n[MessagePackObject]\npublic class B : A\n{\n    public new string Prop1 { get; set; } // Diagnostic reported here due to redefinition of Prop1\n}\n```\n\n----------------------------------------\n\nTITLE: Defining MessagePack C# Analyzer Rules in Markdown\nDESCRIPTION: This markdown snippet defines MessagePack C# analyzer rules for different releases. It includes tables with rule IDs, categories, severities, and notes for each rule.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/src/MessagePack.SourceGenerator/AnalyzerReleases.Shipped.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n## Release 2.1.80\n\n### New Rules\n\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack001 | Reliability | Disabled | MsgPack001SpecifyOptionsAnalyzer\nMsgPack002 | Reliability | Disabled | MsgPack002UseConstantOptionsAnalyzer\nMsgPack003 | Usage | Error | MsgPack00xMessagePackAnalyzer\nMsgPack004 | Usage | Error | Member needs Key or IgnoreMember attribute\nMsgPack005 | Usage | Error | MsgPack00xMessagePackAnalyzer\n\n## Release 2.3.73-alpha\n\n### New Rules\n\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack006 | Usage | Error | MsgPack00xMessagePackAnalyzer\n\n## Release 2.6.95-alpha\n\n### New Rules\n\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack007 | Usage | Error | MsgPack00xMessagePackAnalyzer\nMsgPack008 | Usage | Error | MsgPack00xMessagePackAnalyzer\n\n## Release 3.0.54-alpha\n\n### New Rules\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack009 | Usage | Error | MsgPack00xMessagePackAnalyzer\nMsgPack010 | Usage | Warning | Formatter is not accessible to the source generated resolver\nMsgPack011 | Usage | Error | MsgPack00xMessagePackAnalyzer\nMsgPack012 | Usage | Error | MsgPack00xMessagePackAnalyzer\n\n## Release 3.0.129-beta\n\n### New Rules\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack013 | Usage | Warning | Formatter has no accessible instance for the source generated resolver\n\n## Release 3.0.208-rc.1\n\n### New Rules\n\nRule ID | Category | Severity | Notes\n--------|----------|----------|-------\nMsgPack014 | Usage | Warning | Formatters of reference types should implement `IMessagePackFormatter<T?>`\nMsgPack015 | Usage | Warning | MessagePackObjectAttribute.AllowPrivate should be set\nMsgPack016 | Usage | Error | KeyAttribute-derived attributes are not supported by AOT formatters\nMsgPack017 | Usage | Warning | Property with init accessor and initializer\nMsgPack018 | Usage | Error | Unique names required in force map mode\n```\n\n----------------------------------------\n\nTITLE: Adding MessagePack-CI NuGet Feed in XML Configuration\nDESCRIPTION: This XML snippet shows how to add the MessagePack-CI feed to your nuget.config file. This allows you to access pre-release packages built in CI or PR builds for testing purposes.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/consume_ci.md#2025-04-23_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<add key=\"MessagePack-CI\" value=\"https://pkgs.dev.azure.com/ils0086/MessagePack-CSharp/_packaging/MessagePack-CI/nuget/v3/index.json\" />\n```\n\n----------------------------------------\n\nTITLE: Inaccessible Nested Type for MessagePack Serialization in C#\nDESCRIPTION: This snippet demonstrates an example of a nested type that is not accessible for MessagePack serialization due to its default private visibility. This pattern is flagged by the MsgPack012 analyzer.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack012.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Outer {\n    [MessagePackObject]\n    /*private*/ class DataType { }\n}\n```\n\n----------------------------------------\n\nTITLE: Running MessagePack C# Performance Test\nDESCRIPTION: Command to run the MessagePack C# performance test using the release build. This command is used in PerfView's Collect->Run dialog to generate ETL traces for analysis.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/sandbox/PerfNetFramework/README.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ndotnet run -c release --project .\\sandbox\\PerfNetFramework\\ -f net472 --no-build\n```\n\n----------------------------------------\n\nTITLE: Building MessagePack-CSharp with .NET CLI\nDESCRIPTION: Command to build the MessagePack-CSharp project using dotnet CLI with the NoVSIX platform parameter.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build /p:platform=NoVSIX\n```\n\n----------------------------------------\n\nTITLE: Inaccessible MessagePack Formatter Implementation\nDESCRIPTION: Example of an incorrect implementation where the formatter instance is inaccessible due to a private constructor. This pattern triggers the MsgPack013 analyzer warning.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack013.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass CustomBFormatter : IMessagePackFormatter<B> { // MsgPack013\n    private CustomBFormatter { } // hides the default public constructor\n\n    void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n\n    B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n        => throw new NotImplementedException();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Development Tools with PowerShell\nDESCRIPTION: PowerShell command for machine-wide installation of development tools with elevated privileges.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ninit -InstallLocality machine\n```\n\n----------------------------------------\n\nTITLE: Configuring Unshipped Analyzer Release Tracking\nDESCRIPTION: A configuration file that references the Roslyn analyzers documentation for release tracking. This file is used to manage and track unshipped analyzer releases in the MessagePack-CSharp project.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/src/MessagePack.SourceGenerator/AnalyzerReleases.Unshipped.md#2025-04-23_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\n; Unshipped analyzer release\n; https://github.com/dotnet/roslyn-analyzers/blob/main/src/Microsoft.CodeAnalysis.Analyzers/ReleaseTrackingAnalyzers.Help.md\n\n\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Inaccessible Formatter in C#\nDESCRIPTION: This snippet shows an example of a formatter that is inaccessible due to being declared as a nested type with default private visibility. This pattern is flagged by the MsgPack010 analyzer.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack010.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nclass Outer {\n    /*private*/ class CustomBFormatter : IMessagePackFormatter<B> { // MsgPack010\n        void Serialize(ref MessagePackWriter writer, B value, MessagePackSerializerOptions options)\n            => throw new NotImplementedException();\n\n        B Deserialize(ref MessagePackReader reader, MessagePackSerializerOptions options)\n            => throw new NotImplementedException();\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic MessagePackObject Class in C#\nDESCRIPTION: An example of a MessagePackObject class that will be flagged by the MsgPack011 analyzer due to a private serializable member without the 'partial' modifier.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack011.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A {\n    [Key(0)]\n    private B b;\n}\n```\n\n----------------------------------------\n\nTITLE: Using ExcludeFormatterFromSourceGeneratedResolver Attribute in MessagePack-CSharp\nDESCRIPTION: Example of the attribute that can be applied to formatters to exclude them from the source generated resolver, resolving collision issues.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack009.md#2025-04-23_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n[ExcludeFormatterFromSourceGeneratedResolver]\n```\n\n----------------------------------------\n\nTITLE: Problematic MessagePack Class Definition in C#\nDESCRIPTION: Example class showing problematic property initialization patterns with MessagePack serialization. The init accessor with default value causes unexpected behavior during deserialization.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack017.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n[MessagePackObject]\npublic class A\n{\n    [Key(\"Prop1\")]\n    public string Prop1 { get; init; } = \"This is the default.\"; // Diagnostic emitted here\n\n    [Key(\"Prop2\")]\n    public string Prop2 { get; set; } = \"Another default.\"\n\n    [Key(\"Prop3\")]\n    public string Prop3 { get; set; }\n}\n```\n\n----------------------------------------\n\nTITLE: Problematic Static Options Initialization\nDESCRIPTION: Example of incorrect static options initialization using mutable DefaultOptions.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack002.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Foo\n{\n    public static readonly MessagePackSerializerOptions MyOptions = MessagePackSerializer.DefaultOptions;\n```\n\n----------------------------------------\n\nTITLE: Referencing IMessagePackFormatter<T> Interface in MessagePack-CSharp\nDESCRIPTION: Reference to the interface that causes collisions when implemented by multiple formatters for the same type T.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack009.md#2025-04-23_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nIMessagePackFormatter<T>\n```\n\n----------------------------------------\n\nTITLE: Generated MessagePack Formatter Implementation in C#\nDESCRIPTION: Example of how the AOT source generator creates object initialization code, demonstrating why init properties cannot be conditionally set.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack017.md#2025-04-23_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Values here are replaced if a value is given in deserialized data.\nstring deserializedProp1Value = default(string);\nstring deserializedProp2Value = default(string);\n\n// Keep track of which values are actually specified.\nbool deserializedProp2Value_specified = false; \n\n// process msgpack data here, possibly replacing deserializedProp1Value with an actual value.\n\nA deserializedResult = new A\n{\n    Prop1 = deserializedProp1Value;\n}\n\nif (deserializedProp2Value_specified)\n    deserializedResult.Prop2 = deserializedProp2Value;\n\nreturn deserializedResult;\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Payload for MessagePack Deserialization\nDESCRIPTION: Example JSON payload used to demonstrate the deserialization behavior with init accessors.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/MsgPack017.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{ \"Prop3\": \"hello\" }\n```\n\n----------------------------------------\n\nTITLE: Restoring Dependencies for MessagePack-CSharp in Unity (Shell)\nDESCRIPTION: Commands to restore the .NET tools and NuGet packages required for MessagePack-CSharp in Unity projects. These commands should be run in the project directory before launching Unity.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/src/MessagePack.UnityClient/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet tool restore\n```\n\nLANGUAGE: shell\nCODE:\n```\ndotnet nugetforunity restore\n```\n\n----------------------------------------\n\nTITLE: MessagePack Analyzer Reference Table in Markdown\nDESCRIPTION: Markdown table listing all diagnostic analyzer IDs and their corresponding titles, with links to detailed documentation for each analyzer.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/analyzers/index.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nID | Title\n---|---\n[MsgPack001](MsgPack001.md) | Avoid static default for MessagePackSerializerOptions\n[MsgPack002](MsgPack002.md) | Avoid using a mutable static value for MessagePackSerializerOptions\n[MsgPack003](MsgPack003.md) | Use MessagePackObjectAttribute\n[MsgPack004](MsgPack004.md) | Attribute public members of MessagePack objects\n[MsgPack005](MsgPack005.md) | MessagePackObject validation\n[MsgPack006](MsgPack006.md) | Type must be of `IMessagePackFormatter`\n[MsgPack007](MsgPack007.md) | Deserializing constructors\n[MsgPack008](MsgPack008.md) | AOT limitations\n[MsgPack009](MsgPack009.md) | Colliding Formatters\n[MsgPack010](MsgPack010.md) | Inaccessible Formatter\n[MsgPack011](MsgPack011.md) | Partial type required\n[MsgPack012](MsgPack012.md) | Inaccessible data type\n[MsgPack013](MsgPack013.md) | Inaccessible formatter instance\n[MsgPack014](MsgPack014.md) | Nullable reference type formatter\n[MsgPack015](MsgPack015.md) | MessagePackObjectAttribute.AllowPrivate should be set\n[MsgPack016](MsgPack016.md) | KeyAttribute-derived attributes are not supported by AOT formatters\n[MsgPack017](MsgPack017.md) | Property with init accessor and initializer\n[MsgPack018](MsgPack018.md) | Unique names required in force map mode\n```\n\n----------------------------------------\n\nTITLE: Markdown Navigation Links for MessagePack Migration\nDESCRIPTION: Simple markdown links pointing to detailed migration guide documents for MessagePack version upgrades.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/doc/migration.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- [Migrating from MessagePack v1 to v2](migrating_v1-v2.md)\n- [Migrating from MessagePack v2 to v3](migrating_v2-v3.md)\n```\n\n----------------------------------------\n\nTITLE: Building MessagePack C# Project in Release Mode\nDESCRIPTION: Command to build the MessagePack C# project in release configuration for performance testing. This ensures that optimizations are turned on for accurate performance measurement.\nSOURCE: https://github.com/messagepack-csharp/messagepack-csharp/blob/master/sandbox/PerfNetFramework/README.md#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ndotnet build -c release  .\\sandbox\\PerfNetFramework\\\n```"
  }
]