[
  {
    "owner": "evyweb",
    "repo": "ioctopus",
    "content": "TITLE: Creating an IOC Container\nDESCRIPTION: Imports dependency tokens and creates a new IOC container instance that will be used to register and resolve dependencies.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DI } from './di';\n\nconst container: Container = createContainer();\n```\n\n----------------------------------------\n\nTITLE: Creating Injection Tokens with Symbols\nDESCRIPTION: Defines a set of symbols that serve as injection tokens for dependency identification. These tokens are used consistently throughout the application for binding and resolving dependencies.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const DI: InjectionTokens = {\n    DEP1: Symbol('DEP1'),\n    DEP2: Symbol('DEP2'),\n    LOGGER: Symbol('LOGGER'),\n    MY_SERVICE: Symbol('MY_SERVICE'),\n    MY_USE_CASE: Symbol('MY_USE_CASE'),\n    SIMPLE_FUNCTION: Symbol('SIMPLE_FUNCTION'),\n    CLASS_WITH_DEPENDENCIES: Symbol('CLASS_WITH_DEPENDENCIES'),\n    CLASS_WITHOUT_DEPENDENCIES: Symbol('CLASS_WITHOUT_DEPENDENCIES'),\n    HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES: Symbol('HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES'),\n    HIGHER_ORDER_FUNCTION_WITHOUT_DEPENDENCIES: Symbol('HIGHER_ORDER_FUNCTION_WITHOUT_DEPENDENCIES')\n} ;\n```\n\n----------------------------------------\n\nTITLE: Resolving Dependencies from the Container\nDESCRIPTION: Demonstrates how to retrieve registered dependencies from the container using the get method with proper type parameters.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nimport { DI } from './di';\n\n// Primitive\nconst dep1 = container.get<string>(DI.DEP1); // 'dependency1'\nconst dep2 = container.get<number>(DI.DEP2); // 42\n// or using strings\nconst dep1 = container.get<string>('DEP1'); // 'dependency1'\nconst dep2 = container.get<number>('DEP2'); // 42\n\n// Higher order function and class\nconst myUseCase = container.get<MyUseCaseInterface>(DI.MY_USE_CASE);\n// or using strings\nconst myUseCase = container.get<MyUseCaseInterface>('MY_USE_CASE');\nmyUseCase.execute();\n    \n// Simple function\nconst simpleFunction = container.get<SimpleFunctionType>(DI.SIMPLE_FUNCTION);\n// or using strings\nconst simpleFunction = container.get<SimpleFunctionType>('SIMPLE_FUNCTION');\nsimpleFunction('Hello World');\n\n// Curried function\nconst callMe = container.get<CurriedFunction>(DI.CURRIED_FUNCTION_WITH_DEPENDENCIES);\n// or using strings\nconst callMe = container.get<CurriedFunction>('CURRIED_FUNCTION_WITH_DEPENDENCIES');\ncallMe('John Doe');\n```\n\n----------------------------------------\n\nTITLE: Creating and Loading Modules in the Container\nDESCRIPTION: Shows how to organize dependencies into modules and load them into the container. Dependencies can be resolved across modules.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nconst module1 = createModule();\nmodule1.bind(DI.DEP1).toValue('dependency1');\n\nconst module2 = createModule();\nmodule2.bind(DI.DEP2).toValue(42);\n\nconst module3 = createModule();\nmodule3.bind(DI.MY_SERVICE).toHigherOrderFunction(MyService, {dep1: DI.DEP1, dep2: DI.DEP2});\n\nconst container = createContainer();\ncontainer.load(Symbol('module1'), module1);\ncontainer.load(Symbol('module2'), module2);\ncontainer.load(Symbol('module3'), module3);\n\nconst myService = container.get<MyServiceInterface>(DI.MY_SERVICE);\n```\n\n----------------------------------------\n\nTITLE: Binding Classes with Constructor Parameter Dependencies\nDESCRIPTION: Shows how to register classes that have constructor dependencies using an array of injection tokens to be resolved and injected at instantiation time.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyServiceClass implements MyServiceClassInterface {\n    constructor(\n        private readonly dep1: string,\n        private readonly dep2: number,\n    ) {}\n\n    runTask(): string {\n        return `Executing with dep1: ${this.dep1} and dep2: ${this.dep2}`;\n    }\n}\n\ncontainer.bind(DI.CLASS_WITH_DEPENDENCIES).toClass(MyServiceClass, [DI.DEP1, DI.DEP2]);\n\n// or using strings\ncontainer.bind('CLASS_WITH_DEPENDENCIES').toClass(MyServiceClass, ['DEP1', 'DEP2']);\n```\n\n----------------------------------------\n\nTITLE: Binding Classes with Object Dependencies\nDESCRIPTION: Demonstrates registering classes that take a single object of dependencies in their constructor, using named dependency mapping.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Dependencies {\n    dep1: string,\n    dep2: number\n}\n\nclass MyServiceClass implements MyServiceClassInterface {\n    constructor(private readonly dependencies: Dependencies) {}\n\n    runTask(): string {\n        return `Executing with dep1: ${this.dependencies.dep1} and dep2: ${this.dependencies.dep2}`;\n    }\n}\n\ncontainer.bind(DI.CLASS_WITH_DEPENDENCIES).toClass(MyServiceClass, {dep1: DI.DEP1, dep2: DI.DEP2});\n\n// or using strings\ncontainer.bind('CLASS_WITH_DEPENDENCIES').toClass(MyServiceClass, {dep1: 'DEP1', dep2: 'DEP2'});\n```\n\n----------------------------------------\n\nTITLE: Singleton Scope Implementation in TypeScript IOctopus\nDESCRIPTION: Demonstrates the singleton scope behavior where the same instance is returned for every dependency resolution.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_17\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.bind(DI.MY_SERVICE).toClass(MyServiceClass, [DI.DEP1, DI.DEP2]);\n// or\ncontainer.bind(DI.MY_SERVICE).toClass(MyServiceClass, [DI.DEP1, DI.DEP2], 'singleton');\n\nconst instance1 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\nconst instance2 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\n\nconsole.log(instance1 === instance2); // true\n```\n\n----------------------------------------\n\nTITLE: Transient Scope Implementation in TypeScript IOctopus\nDESCRIPTION: Shows the transient scope behavior where a new instance is created for each dependency resolution.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_18\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.bind(DI.MY_SERVICE).toClass(MyServiceClass, [DI.DEP1, DI.DEP2], 'transient');\n\nconst instance1 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\nconst instance2 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\n\nconsole.log(instance1 === instance2); // false\n```\n\n----------------------------------------\n\nTITLE: Scoped Scope Management in TypeScript IOctopus\nDESCRIPTION: Demonstrates scoped dependency resolution where instances are shared within a scope but different between scopes.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_19\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.bind(DI.MY_SERVICE).toClass(MyServiceClass, [DI.DEP1, DI.DEP2], 'scoped');\nconst instance1 = undefined;\nconst instance2 = undefined;\n\ncontainer.runInScope(() => {\n    instance1 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\n    instance2 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\n\n    console.log(instance1 === instance2); // true\n});\n\ncontainer.runInScope(() => {\n    const instance3 = container.get<MyServiceClassInterface>(DI.MY_SERVICE);\n\n    console.log(instance3 === instance1); // false\n});\n```\n\n----------------------------------------\n\nTITLE: Binding Factories to the Container\nDESCRIPTION: Demonstrates how to register factory functions for more complex dependency resolution that might require custom logic before instantiation.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.bind(DI.MY_USE_CASE).toFactory(() => {\n    // Do something before creating the instance\n     \n    // Then return the instance\n    return MyUseCase({\n        myService: container.get<MyService>(DI.MY_SERVICE)\n    });\n});\n\n// or using strings\ncontainer.bind('MY_USE_CASE').toFactory(() => {\n    // Do something before creating the instance\n     \n    // Then return the instance\n    return MyUseCase({\n        myService: container.get<MyService>('MY_SERVICE')\n    });\n});\n```\n\n----------------------------------------\n\nTITLE: Module Dependencies Override in TypeScript IOctopus\nDESCRIPTION: Demonstrates how to override module dependencies using multiple modules, where later loaded modules override dependencies from earlier ones. Shows binding values, functions and higher-order functions.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_15\n\nLANGUAGE: typescript\nCODE:\n```\nconst module1 = createModule();\nmodule1.bind(DI.DEP1).toValue('OLD dependency1');\nmodule1.bind(DI.MY_SERVICE).toFunction(sayHelloWorld);\n\nconst module2 = createModule();\nmodule2.bind(DI.DEP1).toValue('NEW dependency1');\n\nconst module3 = createModule();\nmodule3.bind(DI.MY_SERVICE).toHigherOrderFunction(MyService, {dep1: DI.DEP1, dep2: DI.DEP2});\n\nconst container = createContainer();\ncontainer.bind(DI.DEP2).toValue(42); // Default module\ncontainer.load(Symbol('module1'), module1);\ncontainer.load(Symbol('module2'), module2);\ncontainer.load(Symbol('module3'), module3);\n\n// The dependency DI.MY_SERVICE will be resolved with the higher order function and dep1 will be 'NEW dependency1'\nconst myService = container.get<MyServiceInterface>(DI.MY_SERVICE);\n```\n\n----------------------------------------\n\nTITLE: Unloading Modules in TypeScript IOctopus\nDESCRIPTION: Shows how to unload modules from the container, removing their dependencies and cached instances to maintain consistency.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_16\n\nLANGUAGE: typescript\nCODE:\n```\nconst module1 = createModule();\nmodule1.bind(DI.DEP1).toValue('dependency1');\n\nconst container = createContainer();\ncontainer.load(Symbol('module1'), module1);\n\ncontainer.unload(Symbol('module1'));\n\n// Will throw an error as the dependency is not registered anymore\nconst myService = container.get<string>(DI.DEP1);\n```\n\n----------------------------------------\n\nTITLE: Circular Dependency Detection in TypeScript IOctopus\nDESCRIPTION: Shows how IOctopus detects and handles circular dependencies to prevent infinite loops and stack overflow errors.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_20\n\nLANGUAGE: typescript\nCODE:\n```\nconst container = createContainer();\n\nconst A_TOKEN = Symbol('A');\nconst B_TOKEN = Symbol('B');\n\nclass A {\n    constructor(public b: B) {}\n}\n\nclass B {\n    constructor(public a: A) {}\n}\n\ncontainer.bind(A_TOKEN).toClass(A, [B_TOKEN]);\ncontainer.bind(B_TOKEN).toClass(B, [A_TOKEN]);\n\ncontainer.get(A_TOKEN); // Will throw: \"Circular dependency detected: Symbol(A) -> Symbol(B) -> Symbol(A)\"\n```\n\n----------------------------------------\n\nTITLE: Binding Higher Order Functions with Array Dependencies\nDESCRIPTION: Demonstrates registering higher order functions with dependencies using an array of injection tokens.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst MyServiceWithDependencies = (dep1: string, dep2: number): MyServiceWithDependenciesInterface => {\n    return {\n        runTask: () => {\n            // Do something with dep1 and dep2\n        }\n    };\n};\n\n// The dependencies will be listed in an array in the second parameter\ncontainer.bind(DI.HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES)\n    .toHigherOrderFunction(MyServiceWithDependencies, [DI.DEP1, DI.DEP2]);\n\n// or using strings\ncontainer.bind('HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES')\n    .toHigherOrderFunction(MyServiceWithDependencies, ['DEP1', 'DEP2']);\n```\n\n----------------------------------------\n\nTITLE: Binding Higher Order Functions with Object Dependencies\nDESCRIPTION: Shows how to register higher order functions that take an object of dependencies using named dependency mapping.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Dependencies {\n    dep1: string,\n    dep2: number\n}\n\nconst MyService = (dependencies: Dependencies): MyServiceInterface => {\n    return {\n        runTask: () => {\n            // Do something with dependencies.dep1 and dependencies.dep2\n        }\n    };\n};\n\n// The dependencies will be listed in an object in the second parameter\ncontainer.bind(DI.HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES)\n    .toHigherOrderFunction(MyService, {dep1: DI.DEP1, dep2: DI.DEP2});\n\n// or using strings\ncontainer.bind('HIGHER_ORDER_FUNCTION_WITH_DEPENDENCIES')\n    .toHigherOrderFunction(MyService, {dep1: 'DEP1', dep2: 'DEP2'});\n```\n\n----------------------------------------\n\nTITLE: Binding Curried Functions with Array Dependencies\nDESCRIPTION: Demonstrates registering curried functions that have dependencies using an array of injection tokens.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst myFunction = (dep1: string, dep2: number) => (name: string) => console.log(`${dep1} ${dep2} ${name}`);\n\ncontainer.bind(DI.CURRIED_FUNCTION_WITH_DEPENDENCIES)\n    .toCurry(myFunction, [DI.DEP1, DI.DEP2]);\n\n// or using strings\ncontainer.bind('CURRIED_FUNCTION_WITH_DEPENDENCIES')\n    .toCurry(myFunction, ['DEP1', 'DEP2']);\n```\n\n----------------------------------------\n\nTITLE: Binding Curried Functions with Object Dependencies\nDESCRIPTION: Shows how to register curried functions that take an object of dependencies using named dependency mapping.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Dependencies {\n    dep1: string,\n    dep2: number\n}\n\nconst myFunction = (dependencies: Dependencies) => (name: string) => console.log(`${dependencies.dep1} ${dependencies.dep2} ${name}`);\n\n// The dependencies will be listed in an object in the second parameter\ncontainer.bind(DI.CURRIED_FUNCTION_WITH_DEPENDENCIES)\n    .toCurry(myFunction, {dep1: DI.DEP1, dep2: DI.DEP2});\n\n// or using strings\ncontainer.bind('CURRIED_FUNCTION_WITH_DEPENDENCIES')\n    .toCurry(myFunction, {dep1: 'DEP1', dep2: 'DEP2'});\n```\n\n----------------------------------------\n\nTITLE: Binding Simple Functions to the Container\nDESCRIPTION: Shows how to register functions that don't have dependencies with the container using either symbol or string tokens.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst sayHelloWorld = () => console.log('Hello World');\n\ncontainer.bind(DI.SIMPLE_FUNCTION).toFunction(sayHelloWorld);\n\n// or using strings\ncontainer.bind('SIMPLE_FUNCTION').toFunction(sayHelloWorld);\n```\n\n----------------------------------------\n\nTITLE: Binding Classes Without Dependencies\nDESCRIPTION: Shows how to register classes that don't have any dependencies to the container.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nclass MyServiceClassWithoutDependencies implements MyServiceClassInterface {\n    runTask(): string {\n        return `Executing without dependencies`;\n    }\n}\n\ncontainer.bind(DI.CLASS_WITHOUT_DEPENDENCIES).toClass(MyServiceClassWithoutDependencies);\n    \n// or using strings\ncontainer.bind('CLASS_WITHOUT_DEPENDENCIES').toClass(MyServiceClassWithoutDependencies);\n```\n\n----------------------------------------\n\nTITLE: Binding Primitive Values to the Container\nDESCRIPTION: Demonstrates how to bind primitive values like strings and numbers to the container using either symbol or string tokens.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncontainer.bind(DI.DEP1).toValue('dependency1');\ncontainer.bind(DI.DEP2).toValue(42);\n\n// or using strings\ncontainer.bind('DEP1').toValue('dependency1');\ncontainer.bind('DEP2').toValue(42);\n```\n\n----------------------------------------\n\nTITLE: Installing IOctopus via NPM\nDESCRIPTION: Command to install the IOctopus package using npm package manager.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @evyweb/ioctopus\n```\n\n----------------------------------------\n\nTITLE: Markdown Changelog Document\nDESCRIPTION: Version history in semantic versioning format, detailing major, minor and patch changes across multiple releases of the IOctopus library.\nSOURCE: https://github.com/evyweb/ioctopus/blob/master/CHANGELOG.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @evyweb/ioctopus\n\n## 1.2.0\n\n### Minor Changes\n\n- Add strings as key for dependency binding\n- Add strings as key for module binding\n\n### Patch Changes\n- Update dev dependencies\n\n## 1.1.0\n\n### Minor Changes\n\n- Add Circular Dependency detection\n\n## 1.0.0\n\n### Major Changes\n\n- No breaking changes just first release\n\n### Minor Changes\n\n- Classes can now have dependency object too\n\n## 0.3.0\n\n### Minor Changes\n\n- Modules support\n- Scopes support\n\n## 0.2.2\n\n### Patch Changes\n\n- Update dev dependencies\n\n## 0.2.1\n\n### Patch Changes\n\n- update dependencies\n\n## 0.2.0\n\n### Minor Changes\n\n- function dependencies can now be defined using a dependency object\n\n## 0.1.0\n\n### Minor Changes\n\n- higher order function have their own api now\n\n## 0.0.1\n\n### Patch Changes\n\n- Higher order functions were solved as simple functions\n\n## 0.0.0\n\n### Minor Changes\n\n- add basic implementation\n```"
  }
]