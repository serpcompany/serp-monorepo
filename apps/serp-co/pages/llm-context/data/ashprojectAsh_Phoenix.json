[
  {
    "owner": "ash-project",
    "repo": "ash_phoenix",
    "content": "TITLE: Installing Phoenix and Creating a New Ash Phoenix Project\nDESCRIPTION: Commands for installing the Phoenix project generator and creating a new Phoenix project with Ash, AshPhoenix, and AshPostgres dependencies using the igniter.new mix task.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# install Phoenix project generator\n$ mix archive.install hex phx_new\n\n# generate Phoenix project\n$ mix igniter.new my_ash_phoenix_app --install ash,ash_phoenix,ash_postgres --with phx.new\n\n# cd into project\n$ cd my_ash_phoenix_app\n```\n\n----------------------------------------\n\nTITLE: Installing AshPhoenix Package in mix.exs\nDESCRIPTION: Code snippet showing how to add ash_phoenix dependency to a mix.exs file. It specifies version 2.2.0 as the minimum required version.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/README.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n{:ash_phoenix, \"~> 2.2.0\"}\n```\n\n----------------------------------------\n\nTITLE: Interacting with Ash Resources Using Verbose Syntax\nDESCRIPTION: Demonstrates CRUD operations on Ash resources using the verbose syntax with explicit changesets and queries. Shows creating, reading, updating, and deleting posts.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_8\n\nLANGUAGE: elixir\nCODE:\n```\n# create post\nnew_post =\n  MyAshPhoenixApp.Blog.Post\n  |> Ash.Changeset.for_create(:create, %{title: \"hello world\"})\n  |> Ash.create!()\n\n# read all posts\nMyAshPhoenixApp.Blog.Post\n|> Ash.Query.for_read(:read)\n|> Ash.read!()\n\n# get single post by id\nMyAshPhoenixApp.Blog.Post\n|> Ash.Query.for_read(:by_id, %{id: new_post.id})\n|> Ash.read_one!()\n\n# update post\nupdated_post =\n  new_post\n  |> Ash.Changeset.for_update(:update, %{content: \"hello to you too!\"})\n  |> Ash.update!()\n\n# delete post\nnew_post\n|> Ash.Changeset.for_destroy(:destroy)\n|> Ash.destroy!()\n```\n\n----------------------------------------\n\nTITLE: Interacting with Ash Resources Using Code Interface\nDESCRIPTION: Demonstrates CRUD operations on Ash resources using the simplified code interface defined in the domain. Shows the more concise way to create, read, update, and delete posts.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_9\n\nLANGUAGE: elixir\nCODE:\n```\n# create post\nnew_post = MyAshPhoenixApp.Blog.create_post!(%{title: \"hello world\"})\n\n# read post\nMyAshPhoenixApp.Blog.list_posts!()\n\n# get post by id\nMyAshPhoenixApp.Blog.get_post!(new_post.id)\n\n# update post\nupdated_post = MyAshPhoenixApp.Blog.update_post!(new_post, %{content: \"hello to you too!\"})\n\n# delete post\nMyAshPhoenixApp.Blog.destroy_post!(updated_post)\n```\n\n----------------------------------------\n\nTITLE: Complete LiveView Module with Sortable Form Implementation\nDESCRIPTION: A comprehensive LiveView module that demonstrates sorting, adding, and removing nested form elements. Includes hidden inputs for sort orders, checkboxes for adding/removing items, and event handlers for form validation and submission.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_15\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule MyApp.MyForm do\n  use MyAppWeb, :live_view\n\n  def render(assigns) do\n    ~H\"\"\"\n    <.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n      <.input field={@form[:email]} />\n\n      <!-- Use sortable.js to allow sorting nested input -->\n      <div id=\"location-list\" phx-hook=\"Sortable\">\n        <.inputs_for :let={location} field={@form[:locations]}>\n          <!-- inputs each nested location -->\n          <div data-sortable=\"true\">\n            <!-- AshPhoenix.Form automatically applies this sort -->\n            <input\n              type=\"hidden\"\n              name={\"#{@form.name}[_sort_locations][]\"}\n              value={location_form.index}\n            />\n\n            <.input field={location[:name]} />\n\n            <!-- AshPhoenix.Form automatically removes items when checked -->\n            <label>\n              <input\n                type=\"checkbox\"\n                name={\"#{@form.name}[_drop_locations][]\"}\n                value={location_form.index}\n                class=\"hidden\"\n              />\n\n              <.icon name=\"hero-x-mark\" />\n            </label>\n          </div>\n        </.inputs_for>\n\n        <!-- AshPhoenix.Form automatically appends a new item when checked -->\n        <label>\n          <input\n            type=\"checkbox\"\n            name={\"#{@form.name}[_add_locations]\"}\n            value=\"end\"\n            class=\"hidden\"\n          />\n          <.icon name=\"hero-plus\" />\n        </label>\n      </div>\n    </.form>\n    \"\"\"\n  end\n\n  def mount(_params, _session, socket) do\n    {:ok, assign(socket, form: MyApp.Operations.form_to_create_business())}\n  end\n\n  def handle_event(socket, \"validate\", %{\"form\" => params}) do\n    {:noreply, assign(socket, :form, AshPhoenix.Form.validate(socket.assigns.form, params))}\n  end\n\n  def handle_event(socket, \"submit\", %{\"form\" => params}) do\n    case AshPhoenix.Form.submit(socket.assigns.form, params: params) do\n      {:ok, business} ->\n        socket =\n          socket\n          |> put_flash(:success, \"Business created successfully\")\n          |> push_navigate(to: ~p\"/businesses/#{business.id}\")\n\n        {:noreply, socket}\n\n      {:error, form} ->\n        {:noreply, assign(socket, :form, form)}\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Creating a Post Resource with Ash\nDESCRIPTION: Defining a Post resource using Ash.Resource with AshPostgres data layer. Includes attribute definitions, action configurations, and Postgres table specifications.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/my_ash_phoenix_app/blog/post.ex\n\ndefmodule MyAshPhoenixApp.Blog.Post do\n  # Using Ash.Resource turns this module into an Ash resource.\n  use Ash.Resource,\n    # Tells Ash where the generated code interface belongs\n    domain: MyAshPhoenixApp.Blog,\n    # Tells Ash you want this resource to store its data in Postgres.\n    data_layer: AshPostgres.DataLayer\n\n  # The Postgres keyword is specific to the AshPostgres module.\n  postgres do\n    # Tells Postgres what to call the table\n    table \"posts\"\n    # Tells Ash how to interface with the Postgres table\n    repo MyAshPhoenixApp.Repo\n  end\n\n  actions do\n    # Exposes default built in actions to manage the resource\n    defaults [:read, :destroy]\n\n    create :create do\n      primary? true\n      # accept title as input\n      accept [:title]\n    end\n\n    update :update do\n      primary? true\n      # accept content as input\n      accept [:content]\n    end\n\n    # Defines custom read action which fetches post by id.\n    read :by_id do\n      # This action has one argument :id of type :uuid\n      argument :id, :uuid, allow_nil?: false\n      # Tells us we expect this action to return a single result\n      get? true\n      # Filters the `:id` given in the argument\n      # against the `id` of each element in the resource\n      filter expr(id == ^arg(:id))\n    end\n  end\n\n  # Attributes are simple pieces of data that exist in your resource\n  attributes do\n    # Add an autogenerated UUID primary key called `:id`.\n    uuid_primary_key :id\n    # Add a string type attribute called `:title`\n    attribute :title, :string do\n      # We don't want the title to ever be `nil`\n      allow_nil? false\n    end\n\n    # Add a string type attribute called `:content`\n    # If allow_nil? is not specified, then content can be nil\n    attribute :content, :string\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Configuring Ash Domains in Phoenix Application\nDESCRIPTION: Configuration snippet for specifying the Ash domains that the application uses. This sets up the Blog domain as a recognized domain in the application.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n# config/config.exs\n\nimport Config\n\nconfig :my_ash_phoenix_app,\n  ash_domains: [MyAshPhoenixApp.Blog]\n```\n\n----------------------------------------\n\nTITLE: Defining a Resource Action with Manage Relationship in Elixir\nDESCRIPTION: Example of defining a create action on a Business resource that accepts a name field and manages a locations relationship, allowing nested forms to be automatically inferred.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\n# on a `MyApp.Operations.Business` resource\ncreate :create do\n  accept [:name]\n\n  argument :locations, {:array, :map}\n\n  change manage_relationship(:locations, type: :create)\nend\n```\n\n----------------------------------------\n\nTITLE: Defining an Ash Domain for Blog\nDESCRIPTION: Elixir module defining the Blog domain which contains the Post resource. The domain defines interfaces for creating, listing, destroying, and retrieving posts by ID.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\n# lib/my_ash_phoenix_app/blog/blog.ex\n\ndefmodule MyAshPhoenixApp.Blog do\n  use Ash.Domain\n\n  resources do\n    resource MyAshPhoenixApp.Blog.Post do\n      # Define an interface for calling resource actions.\n      define :create_post, action: :create\n      define :list_posts, action: :read\n      define :destroy_post, action: :destroy\n      define :get_post, args: [:id], action: :by_id\n    end\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Union Resources and Type in Elixir\nDESCRIPTION: This code defines two resources (NormalContent and SpecialContent) and a Content union type that can represent either of them. The union is tagged with a :type field to distinguish between variants.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/union-forms.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\ndefmodule NormalContent do\n  use Ash.Resource, data_layer: :embedded\n\n  attributes do\n    attribute :body, :string, allow_nil?: false, public?: true\n  end\n\n  actions do\n    defaults [:read, create: [:body], update: [:body]]\n  end\nend\n\ndefmodule SpecialContent do\n  use Ash.Resource, data_layer: :embedded\n\n  attributes do\n    attribute :text, :string, allow_nil?: false, public?: true\n  end\n\n  actions do\n    defaults [:read, create: [:text], update: [:text]]\n  end\nend\n\ndefmodule Content do\n  use Ash.Type.NewType,\n    subtype_of: :union,\n    constraints: [\n      types: [\n        normal: [\n          type: NormalContent,\n          tag: :type,\n          tag_value: :normal\n        ],\n        special: [\n          type: SpecialContent,\n          tag: :type,\n          tag_value: :special\n        ]\n      ]\n    ]\nend\n```\n\n----------------------------------------\n\nTITLE: Generating LiveView Components with ash_phoenix.gen.live\nDESCRIPTION: Command to generate a LiveView interface for an Ash resource. This task creates all necessary LiveView components for managing Blog.Post resources, including forms, list views, and detail views.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nmix ash_phoenix.gen.live --domain MyAshPhoenixApp.Blog --resource MyAshPhoenixApp.Blog.Post\n```\n\n----------------------------------------\n\nTITLE: Defining Resources with Code Interface in Elixir\nDESCRIPTION: Example showing how to define resources with code interface definitions in a domain called MyApp.Accounts. This demonstrates setting up register and update actions with their arguments.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/dsls/DSL-AshPhoenix.md#2025-04-17_snippet_0\n\nLANGUAGE: elixir\nCODE:\n```\nresources do\n  resource MyApp.Accounts.User do\n    define :register_with_password, args: [:email, :password]\n    define :update_user, action: :update, args: [:email, :password]\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Manually Defining Nested Forms in AshPhoenix\nDESCRIPTION: Example of manually configuring nested forms using the forms option when creating an AshPhoenix.Form, specifying the resource and action for a nested location form.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nAshPhoenix.Form.for_create(\n  MyApp.Operations.Business, \n  :create, \n  forms: [\n    locations: [\n      type: :list,\n      resource: MyApp.Operations.Location,\n      create_action: :create\n    ]\n  ]\n)\n```\n\n----------------------------------------\n\nTITLE: Union Form Template with Type Selection in HEEx\nDESCRIPTION: This HEEx template shows how to implement a form for a union type. It includes a dropdown to select the union type and conditionally renders different form fields based on the selected type using the _union_type parameter.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/union-forms.md#2025-04-17_snippet_2\n\nLANGUAGE: heex\nCODE:\n```\n<.inputs_for :let={fc} field={@form[:content]}>\n  <!-- Dropdown for setting the union type -->\n  <.input\n    field={fc[:_union_type]}\n    phx-change=\"type-changed\"\n    type=\"select\"\n    options={[Normal: \"normal\", Special: \"special\"]}\n  />\n\n  <!-- switch on the union type to display a form -->\n  <%= case fc.params[\"_union_type\"] do %>\n    <% \"normal\" -> %>\n      <.input  type=\"text\" field={fc[:body]} />\n    <% \"special\" -> %>\n      <.input type=\"text\" field={fc[:text]} />\n  <% end %>\n</.inputs_for>\n```\n\n----------------------------------------\n\nTITLE: Loading Related Data for Update Forms in Elixir\nDESCRIPTION: Example showing how to load related data before creating an update form to ensure existing related resources are included in the form.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nbusiness = Ash.load!(business, :locations)\n\nform = AshPhoenix.Form.for_update(business, :update)\n```\n\n----------------------------------------\n\nTITLE: Setting up and Creating the Ash Database\nDESCRIPTION: Commands for setting up the Ash database using the ash.setup mix task, which creates the database for the application's repository.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ mix ash.setup\n\nRunning setup for AshPostgres.DataLayer...\nThe database for MyAshPhoenixApp.Repo has been created\n\n01:23:45.678 [info] Migrations already up\n```\n\n----------------------------------------\n\nTITLE: Generating Ash Migration Files\nDESCRIPTION: Command for generating an initial migration file for the Ash resources using the ash.codegen mix task.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ mix ash.codegen initial_migration\n\n# ... don't worry about other files it creates\n\nGenerating Migrations:\n* creating priv/repo/migrations/20230208045101_initial_migration.exs\n```\n\n----------------------------------------\n\nTITLE: Defining Ecto Migration for Ash Resources\nDESCRIPTION: Ecto migration module for creating the posts table with id, title, and content fields. Includes up/0 for migrating forward and down/0 for rolling back.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_6\n\nLANGUAGE: elixir\nCODE:\n```\n# priv/repo/migrations/20230208045101_initial_migration.exs\n\ndefmodule MyAshPhoenixApp.Repo.Migrations.InitialMigration do\n  use Ecto.Migration\n\n  # This function runs when migrating forward\n  def up do\n    # Creates the `:posts` table\n    create table(:posts, primary_key: false) do\n      # Adds primary key attribute `:id` of type `:uuid`\n      # null values are not allowed\n      add :id, :uuid, null: false, default: fragment(\"gen_random_uuid()\"), primary_key: true\n\n      # Adds attribute `:title` of type `:text`, null values are not allowed\n      add :title, :text, null: false\n      # Adds attribute `:content` of type `:text`, null values are allowed\n      add :content, :text\n    end\n  end\n\n  # This is the function that runs if you want to rollback the migration.\n  def down do\n    # Deletes the `:posts` table\n    drop table(:posts)\n  end\nend\n```\n\n----------------------------------------\n\nTITLE: Running Ash Migrations\nDESCRIPTION: Command for running the Ash migrations using the ash.migrate mix task to apply the database changes.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/tutorials/getting-started-with-ash-and-phoenix.md#2025-04-17_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n$ mix ash.migrate\n```\n\n----------------------------------------\n\nTITLE: Adding Nested Forms with Button and Event Handler in Phoenix\nDESCRIPTION: Example showing how to add a button that triggers a Phoenix event handler to programmatically add a nested form using AshPhoenix.Form.add_form.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_6\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <.inputs_for :let={location} field={@form[:locations]}>\n    <.input field={location[:name]} />\n  </.inputs_for>\n\n  <.button type=\"button\" phx-click=\"add-form\" phx-value-path={@form.name <> \"[locations]\"}>\n    <.icon name=\"hero-plus\" />\n  </.button>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Phoenix Event Handler for Adding Nested Forms\nDESCRIPTION: Elixir event handler that responds to the add-form event by using AshPhoenix.Form.add_form to add a new nested form with initial parameters.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_7\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"add-form\", %{\"path\" => path}, socket) do\n  form = AshPhoenix.Form.add_form(socket.assigns.form, path, params: %{\n    address: \"Put your address here!\"\n  })\n\n  {:noreply, assign(socket, :form, form)}\nend\n```\n\n----------------------------------------\n\nTITLE: Handling Union Type Changes in Ash Phoenix\nDESCRIPTION: This event handler shows how to change the type of a union in a form. It uses AshPhoenix.Form.remove_form/3 and AshPhoenix.Form.add_form/3 to replace the current form with a new form of the selected type.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/union-forms.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"type-changed\", %{\"_target\" => path} = params, socket) do\n  new_type = get_in(params, path)\n  # The last part of the path in this case is the field name\n  path = :lists.droplast(path)\n\n  form =\n    socket.assigns.form\n    |> AshPhoenix.Form.remove_form(path)\n    |> AshPhoenix.Form.add_form(path, params: %{\"_union_type\" => new_type})\n\n  {:noreply, assign(socket, :form, form)}\nend\n```\n\n----------------------------------------\n\nTITLE: Customizing Forms DSL in Elixir\nDESCRIPTION: Example of customizing form definitions using the forms DSL, specifically for a create_student action.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/dsls/DSL-AshPhoenix.md#2025-04-17_snippet_4\n\nLANGUAGE: elixir\nCODE:\n```\nforms do \n  # customize the generated `form_to_create_student` function\n  form :create_student, args: [:school_id]\nend\n```\n\n----------------------------------------\n\nTITLE: Using Form Builder for Updates in Elixir\nDESCRIPTION: Example demonstrating the use of form builder for update actions with parameters.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/dsls/DSL-AshPhoenix.md#2025-04-17_snippet_3\n\nLANGUAGE: elixir\nCODE:\n```\nMyApp.Accounts.form_to_update_user(params: %{\"email\" => \"placeholder@email\"})\n#=> %AshPhoenix.Form{}\n```\n\n----------------------------------------\n\nTITLE: Phoenix Template with Nested Inputs Using Phoenix.HTML.Form\nDESCRIPTION: HEEx template example showing how to use Phoenix's inputs_for component to create a form with nested inputs for related resources.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_2\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <.inputs_for :let={location} field={@form[:locations]}>\n    <.input field={location[:name]} />\n  </.inputs_for>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Implementing Up/Down Movement for Form Elements with AshPhoenix.Form\nDESCRIPTION: Event handlers for moving specific form elements up or down in a list. Uses AshPhoenix.Form.sort_forms with :increment and :decrement to change the position of a form element relative to others.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_14\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"move-up\", %{\"path\" => form_to_move}, socket) do\n  # decrement typically means \"move up\" visually\n  # because forms are rendered down the page ascending\n  form = AshPhoenix.Form.sort_forms(socket, form_to_move, :decrement)\n  {:noreply, assign(socket, form: form)}\nend\n\ndef handle_event(\"move-down\", %{\"path\" => form_to_move}, socket) do\n  # increment typically means \"move down\" visually\n  # because forms are rendered down the page ascending\n  form = AshPhoenix.Form.sort_forms(socket, form_to_move, :increment)\n  {:noreply, assign(socket, form: form)}\nend\n```\n\n----------------------------------------\n\nTITLE: Submitting Input for Related Resources in Elixir\nDESCRIPTION: Example of submitting input data for a business with nested locations, showing the data structure for nested resources.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\n%{name: \"Wally World\", locations: [%{name: \"HQ\", address: \"1 hq street\"}]}\n```\n\n----------------------------------------\n\nTITLE: Adding Nested Forms with Checkbox in Phoenix Template\nDESCRIPTION: HEEx template example showing how to add a hidden checkbox that triggers the addition of a new nested form when clicked, using the _add_locations parameter.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_5\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <.inputs_for :let={location} field={@form[:locations]}>\n    <.input field={location[:name]} />\n  </.inputs_for>\n\n  <label>\n    <input\n      type=\"checkbox\"\n      name={\"#{@form.name}[_add_locations]\"}\n      value=\"end\"\n      class=\"hidden\"\n    />\n    <.icon name=\"hero-plus\" />\n  </label>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Removing Nested Forms with Button and Event Handler in Phoenix\nDESCRIPTION: Example of using a button to trigger a Phoenix event that will programmatically remove a nested form using AshPhoenix.Form.remove_form.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_9\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <.inputs_for :let={location} field={@form[:locations]}>\n    <.input field={location[:name]} />\n\n    <.button type=\"button\" phx-click=\"remove-form\" phx-value-path={location.name}>\n      <.icon name=\"hero-x-mark\" />\n    </.button>\n  </.inputs_for>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Phoenix Event Handler for Removing Nested Forms\nDESCRIPTION: Elixir event handler that responds to the remove-form event by using AshPhoenix.Form.remove_form to remove a nested form at the specified path.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_10\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"remove-form\", %{\"path\" => path}, socket) do\n  form = AshPhoenix.Form.remove_form(socket.assigns.form, path)\n\n  {:noreply, assign(socket, :form, form)}\nend\n```\n\n----------------------------------------\n\nTITLE: Using Form Builder Without Options in Elixir\nDESCRIPTION: Basic usage example of the form builder function without any options specified.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/dsls/DSL-AshPhoenix.md#2025-04-17_snippet_1\n\nLANGUAGE: elixir\nCODE:\n```\nMyApp.Accounts.form_to_register_with_password()\n#=> %AshPhoenix.Form{}\n```\n\n----------------------------------------\n\nTITLE: Using Form Builder With Parameters in Elixir\nDESCRIPTION: Example showing how to use the form builder function with parameters provided for email.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/dsls/DSL-AshPhoenix.md#2025-04-17_snippet_2\n\nLANGUAGE: elixir\nCODE:\n```\nMyApp.Accounts.form_to_register_with_password(params: %{\"email\" => \"placeholder@email\"})\n#=> %AshPhoenix.Form{}\n```\n\n----------------------------------------\n\nTITLE: Removing Nested Forms with Checkbox in Phoenix Template\nDESCRIPTION: HEEx template showing how to add hidden checkboxes to each nested form that allow users to remove forms using the _drop_locations parameter.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_8\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <.inputs_for :let={location} field={@form[:locations]}>\n    <.input field={location[:name]} />\n\n    <label>\n      <input\n        type=\"checkbox\"\n        name={\"#{@form.name}[_drop_locations][]\"}\n        value={location.index}\n        class=\"hidden\"\n      />\n\n      <.icon name=\"hero-x-mark\" />\n    </label>\n  </.inputs_for>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: Handling Full Sort Order in Phoenix LiveView with AshPhoenix.Form\nDESCRIPTION: Event handler that processes a complete sort order provided by a client-side library like SortableJS. It takes a path to the form and an array of indices representing the new order.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_13\n\nLANGUAGE: elixir\nCODE:\n```\ndef handle_event(\"update-sorting\", %{\"path\" => path, \"indices\" => indices}, socket) do\n  form = AshPhoenix.Form.sort_forms(socket, path, indices)\n  {:noreply, assign(socket, form: form)}\nend\n```\n\n----------------------------------------\n\nTITLE: Sorting Nested Forms with Hidden Inputs in Phoenix Template\nDESCRIPTION: HEEx template showing how to implement drag-and-drop sorting of nested forms using hidden inputs with the _sort_locations parameter and SortableJS.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_12\n\nLANGUAGE: heex\nCODE:\n```\n<.simple_form for={@form} phx-change=\"validate\" phx-submit=\"submit\">\n  <.input field={@form[:email]} />\n\n  <div id=\"location-list\" phx-hook=\"Sortable\">\n    <.inputs_for :let={location} field={@form[:locations]}>\n      <div data-sortable=\"true\">\n        <input\n          type=\"hidden\"\n          name={\"#{@form.name}[_sort_locations][]\"}\n          value={location_form.index}\n        />\n\n        <.input field={location[:name]} />\n      </div>\n    </.inputs_for>\n</.form>\n```\n\n----------------------------------------\n\nTITLE: JavaScript Sortable Hook for Drag-and-Drop in Phoenix\nDESCRIPTION: JavaScript hook that integrates Sortable.js to enable drag-and-drop reordering of nested forms in a Phoenix LiveView application.\nSOURCE: https://github.com/ash-project/ash_phoenix/blob/main/documentation/topics/nested-forms.md#2025-04-17_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport Sortable from \"sortablejs\"\n\nexport const Sortable = {\n  mounted() {\n    new Sortable(this.el, {\n      animation: 150,\n      draggable: '[data-sortable=\"true\"]',\n      ghostClass: \"bg-yellow-100\",\n      dragClass: \"shadow-2xl\",\n      onEnd: (evt) => {\n        this.el.closest(\"form\").querySelector(\"input\").dispatchEvent(new Event(\"input\", {bubbles: true}))\n      }\n    })\n  }\n}\n...\n\nlet Hooks = {}\n\nHooks.Sortable = Sortable\n```"
  }
]