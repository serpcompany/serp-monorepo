[
  {
    "owner": "powershell",
    "repo": "powershell",
    "content": "TITLE: Getting Help for a Cmdlet - PowerShell\nDESCRIPTION: This command displays help information for a specified cmdlet at the command line. Replace `<cmdlet-name>` with the actual name of the cmdlet. The `Get-Help` cmdlet retrieves the help topic from the local help files or generates basic help if help files are not installed.\nSOURCE: https://github.com/powershell/powershell/blob/master/assets/default.help.txt#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-Help <cmdlet-name>\n```\n\n----------------------------------------\n\nTITLE: Searching Help Topics - PowerShell\nDESCRIPTION: This command searches all available help topics for a specific word or phrase. Replace `<search-term>` with the term you want to find within the help documentation. The `Get-Help` cmdlet searches the help files' content for the provided term and displays the matching help topics.\nSOURCE: https://github.com/powershell/powershell/blob/master/assets/default.help.txt#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-Help <search-term>\n```\n\n----------------------------------------\n\nTITLE: Basic Pester Test: Variable Assignment in PowerShell\nDESCRIPTION: Demonstrates a fundamental Pester test structure using `Describe` and `It` blocks. It assigns a value to a variable and uses the `Should -Be` assertion to verify the variable's value. This illustrates the core Arrange-Act-Assert pattern within a Pester test.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nDescribe \"A variable can be assigned and retrieved\" {\n    It \"Creates a variable and makes sure its value is correct\" {\n       $a = 1\n       $a | Should -Be 1\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Pester Error Handling: Inspecting ErrorRecord Properties in PowerShell\nDESCRIPTION: Demonstrates using the `-PassThru` parameter with `Should -Throw` in Pester to capture the `ErrorRecord` object. This allows further inspection of the error details, such as checking the `InnerException.NativeErrorCode` as shown in the example with `Invoke-WebRequest`.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\nIt \"InnerException sample\" {\n   $e = { Invoke-WebRequest https://expired.badssl.com/ } | Should -Throw -ErrorId \"WebCmdletWebResponseException,Microsoft.PowerShell.Commands.InvokeWebRequestCommand\" -PassThru\n   $e.Exception.InnerException.NativeErrorCode | Should -Be 12175\n}\n```\n\n----------------------------------------\n\nTITLE: Getting Help for a Conceptual Topic - PowerShell\nDESCRIPTION: This command displays help information for a conceptual topic, such as \"About_Modules\". Replace `<topic-name>` with the name of the conceptual topic you want to learn about. The `Get-Help` cmdlet uses the `About_` prefix to identify and retrieve conceptual help topics.\nSOURCE: https://github.com/powershell/powershell/blob/master/assets/default.help.txt#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-Help About_<topic-name>\n```\n\n----------------------------------------\n\nTITLE: Opening Online Help for a Cmdlet - PowerShell\nDESCRIPTION: This command opens the online help documentation for a specified cmdlet or function. Replace `<cmdlet-name>` with the actual name of the cmdlet you want help for. The command utilizes the Get-Help cmdlet with the `-Online` parameter to directly access the online version of the help topic in your default web browser.\nSOURCE: https://github.com/powershell/powershell/blob/master/assets/default.help.txt#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-Help <cmdlet-name> -Online\n```\n\n----------------------------------------\n\nTITLE: Pester Error Handling: Checking Specific Error IDs in PowerShell\nDESCRIPTION: Illustrates how to test for specific terminating errors using Pester's `Should -Throw -ErrorId` syntax. This example checks if `Get-Item` throws a `PathNotFound` error when accessing a non-existent file, asserting against the `FullyQualifiedErrorId` for culture-invariant testing. The `-ErrorAction Stop` parameter ensures the error terminates execution within the script block.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n...\nIt \"Get-Item on a nonexisting file should have error PathNotFound\" {\n    { Get-Item \"ThisFileCannotPossiblyExist\" -ErrorAction Stop } | Should -Throw -ErrorId \"PathNotFound,Microsoft.PowerShell.Commands.GetItemCommand\"\n}\n```\n\n----------------------------------------\n\nTITLE: Pester Parameterized Tests using TestCases in PowerShell\nDESCRIPTION: Illustrates how to create data-driven tests in Pester using the `-TestCases` parameter on the `It` block. An array of hashtables (`$testCases`) defines multiple input sets and expected results, which are passed as parameters to the `It` block's scriptblock for efficient testing of various scenarios.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n$testCases = @(\n    @{ a = 0; b = 1; ExpectedResult = 1 }\n    @{ a = 1; b = 0; ExpectedResult = 1 }\n    @{ a = 1; b = 1; ExpectedResult = 0 }\n    @{ a = 0; b = 0; ExpectedResult = 0 }\n    )\n\nDescribe \"A test\" {\n    It \"<a> -xor <b> should be <expectedresult>\" -TestCases $testCases {\n        param ($a, $b, $ExpectedResult)\n        $a -xor $b | Should -Be $ExpectedResult\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Update Get-ChildItem to Handle Symbolic Links and Errors\nDESCRIPTION: Improvements to the `Get-ChildItem` cmdlet include handling symbolic links during recursive searches without traversing their targets and continuing enumeration after encountering errors, making directory and file retrieval more resilient.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Updating PowerShell Help Files - PowerShell\nDESCRIPTION: This command downloads and installs the latest help files for PowerShell modules on your computer.  It requires administrative privileges to execute. The `Update-Help` cmdlet connects to the internet or a specified file share to retrieve the updated help content and stores it locally.\nSOURCE: https://github.com/powershell/powershell/blob/master/assets/default.help.txt#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nUpdate-Help\n```\n\n----------------------------------------\n\nTITLE: Generating and Visualizing HTML Coverage Reports with ReportGenerator in PowerShell\nDESCRIPTION: This snippet details the process of installing the ReportGenerator NuGet package, locating the ReportGenerator executable, running it to generate an HTML report from a coverage XML file, and then opening the resulting report in a browser. The workflow requires NuGet support in PowerShell and access to the coverage XML file. The main input is the coverage XML, and the output is an HTML directory viewable in any browser. Users should ensure the ReportGenerator version matches the installed package path.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_5\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Install ReportGenerator\nPS> Find-Package ReportGenerator `\n>> -ProviderName Nuget `\n>> -Source \"https://nuget.org/api/v2\" `\n>> | Install-Package -Scope CurrentUser\n\n# Get the ReportGenerator executable path\n# Make sure use the appropriate version number in the path\n$ReportGenExe = \"$HOME\\AppData\\Local\\PackageManagement\\NuGet\\Packages\\ReportGenerator.<version>\\tools\\ReportGenerator.exe\"\n\n# Run ReportGenerator\n& $ReportGenExe -report:coverage.xml -targetdir:C:\\temp\\Coverage\n\n# Finally, open the report in your browser\nInvoke-Item C:\\temp\\Coverage\\index.htm\n```\n\n----------------------------------------\n\nTITLE: Splitting File Paths using Split-Path -Extension/-LeafBase in PowerShell\nDESCRIPTION: Shows the usage of the new `-Extension` and `-LeafBase` switches for the `Split-Path` cmdlet. `-Extension` isolates the file extension, while `-LeafBase` isolates the filename without the extension.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_26\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Get only the extension\nSplit-Path -Path C:\\Temp\\MyFile.log -Extension\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Get the filename without the extension\nSplit-Path -Path C:\\Temp\\MyFile.log -LeafBase\n```\n\n----------------------------------------\n\nTITLE: Mocking Cmdlets in Pester Tests using PowerShell\nDESCRIPTION: Demonstrates how to use the `Mock` command in Pester to temporarily replace the behavior of an existing cmdlet (`Get-Random`) within a specific scope (`Context`). The `Mock` defines a script block that returns a fixed value (3), allowing the test to verify behavior with predictable dependencies.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\nContext \"Get-Random is not random\" {\n    Mock Get-Random { return 3 }\n\n    It \"Get-Random returns 3\" {\n        Get-Random | Should -Be 3\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running Specific Pester Tests PowerShell\nDESCRIPTION: This code shows how to run specific Pester tests using `Start-PSPester` and specifying a path. This allows you to focus on testing a particular area of the codebase or a specific test file. The -Path parameter allows specifying a directory or a file.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/testing-guidelines.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-PSPester -Path test/powershell/engine/Api\n```\n\n----------------------------------------\n\nTITLE: Using RelativeBasePath Parameter with Resolve-Path\nDESCRIPTION: Shows the usage of the newly added -RelativeBasePath parameter for Resolve-Path cmdlet, which resolves paths relative to a specified base path.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n# Example of using the new -RelativeBasePath parameter\nResolve-Path -Path \"folder1\", \"folder2\" -RelativeBasePath \"C:\\base\\path\"\n\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pester Execution Order with Free Code in PowerShell\nDESCRIPTION: A Pester test script designed to illustrate the execution order of different blocks (`Describe`, `Context`, `BeforeAll`, `AfterAll`, `BeforeEach`, `AfterEach`, `It`) and free-standing code within a `Describe` block. Uses `Write-Host` to trace the execution flow, highlighting potential issues with state management if code relies on free code executing in a specific sequence.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\nDescribe it {\n    Write-Host -For DarkRed \"Before Context\"\n    Context \"subsection\" {\n        Write-Host -for DarkRed \"Before BeforeAll\"\n        BeforeAll { write-host -for Blue \"In Context BeforeAll\" }\n        Write-Host -for DarkRed \"After BeforeAll\"\n\n        Write-Host -for DarkRed \"Before AfterAll\"\n        AfterAll { Write-Host -for Blue \"In Context AfterAll\" }\n        Write-Host -for DarkRed \"After AfterAll\"\n\n        BeforeEach { Write-Host -for Blue \"In BeforeEach\" }\n        AfterEach { Write-Host -for Blue \"In AfterEach\" }\n\n        Write-Host -for DarkRed \"Before It\"\n        It \"should not be a surprise\" {\n            1 | should -Be 1\n        }\n        Write-Host -for DarkRed \"After It\"\n    }\n    Write-Host -for DarkRed \"After Context\"\n    Write-Host -for DarkGreen \"Before Describe BeforeAll\"\n    BeforeAll { Write-Host -for DarkGreen \"In Describe BeforeAll\" }\n    AfterAll { Write-Host -for DarkGreen \"In Describe AfterAll\" }\n}\n```\n\n----------------------------------------\n\nTITLE: Pester Test with Value and Type Checking in PowerShell\nDESCRIPTION: Shows a Pester test with multiple `It` blocks within a `Describe` block. The first `It` block checks the value of a variable using `Should -Be`, while the second uses `Should -BeOfType` to verify the variable's data type (`System.Int32`).\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nDescribe \"One is really one\" {\n    It \"Compare 1 to 1\" {\n       $a = 1\n       $a | Should -Be 1\n    }\n    It \"1 is really an int\" {\n       $i = 1\n       $i | Should -BeOfType System.Int32\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Multi-line Strings with Normalized Line Endings in PowerShell\nDESCRIPTION: This snippet defines a normalizeEnds function to convert all line endings in a string to the Windows (\\r\\n) format using regex replacement. It then runs a Pester 'It' test to compare the output of Get-MultiLineString with an expected multi-line string, with both values normalized by the function to avoid platform-dependent line ending issues. This approach is useful for ensuring test reliability on environments with differing newline conventions; prerequisites include Pester and, optionally, a custom Get-MultiLineString function.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_10\n\nLANGUAGE: PowerShell\nCODE:\n```\nfunction normalizeEnds([string]$text)\n{\n    $text -replace \"`r`n?|`n\", \"`r`n\"\n}\n\nIt 'tests multi-line string' {\n    normalizeEnds (Get-MultiLineString) | Should -Be (normalizeEnds @'\nfirst line\nsecond line\n'@)\n}\n```\n\n----------------------------------------\n\nTITLE: Running Code Coverage Analysis with OpenCover in PowerShell\nDESCRIPTION: This snippet illustrates the complete pipeline to execute PowerShell tests with code coverage on Windows using OpenCover. Dependencies include an elevated PowerShell session, OpenCover module, PSPester, and PSTestTools. The workflow involves preparing the build directory, importing modules, building the code with code coverage enabled, restoring test dependencies, installing OpenCover in a temporary directory, and invoking the OpenCover module to perform test coverage analysis, outputting results as coverage.xml. Inputs are the build directory and test flags, while the output is the XML coverage report for further processing.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Go to your PowerShell build directory root\nPS> Set-Location \"C:\\Path\\to\\powershell\\build\\dir\"\n\n# Import the PowerShell build module\nPS> Import-Module .\\build.psm1\n\n# Build PowerShell. You may need to add other flags here like\n# -ResGen or -Restore\nPS> Start-PSBuild -Configuration CodeCoverage -Clean -PsModuleRestore\n\n# Now ensure Pester is installed\nPS> Restore-PSPester\n\n# We also need to build the test executor\nPS> Publish-PSTestTools\n\n# Import the OpenCover module\nPS> Import-Module $PWD\\test\\tools\\OpenCover\n\n# Install OpenCover to a temporary directory\nPS> Install-OpenCover -TargetDirectory $env:TEMP -Force\n\n# Finally, run the tests with code coverage analysis.\n# If you want to run only the continuous integration tests,\n# add -CIOnly, which will take less time\nPS> Invoke-OpenCover -OutputLog coverage.xml -OpenCoverPath $env:TEMP\\OpenCover\n```\n\n----------------------------------------\n\nTITLE: Building and Packaging PowerShell Core on Linux/macOS (PowerShell)\nDESCRIPTION: Demonstrates the PowerShell commands to install dependencies (`Start-PSBootstrap`), build PowerShell Core with specific options (`Start-PSBuild`), and create a package (`Start-PSPackage`) for a tagged release (e.g., v6.0.0-beta.1) on macOS or Linux. Assumes the `tools/packaging` module and `build.psm1` are available.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/maintainers/releasing.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n# Install dependencies\nStart-PSBootstrap -Package\n\n# Build for v6.0.0-beta.1 release\nStart-PSBuild -Clean -Crossgen -PSModuleRestore -ReleaseTag v6.0.0-beta.1\n\n# Create package for v6.0.0-beta.1 release\nStart-PSPackage -ReleaseTag v6.0.0-beta.1\n```\n\n----------------------------------------\n\nTITLE: Creating a global.json File for SDK Version\nDESCRIPTION: Commands to create a global.json file that specifies the required .NET Core SDK version to prevent issues with multiple SDK versions.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\ncd MyModule\ndotnet new globaljson --sdk-version 2.0.0\n```\n\n----------------------------------------\n\nTITLE: Using Environment Parameter with Start-Process\nDESCRIPTION: Demonstrates the new -Environment parameter added to Start-Process cmdlet, allowing specification of environment variables for the new process.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\n# Example of using the new -Environment parameter\nStart-Process -FilePath \"cmd.exe\" -Environment @{\"TEST_VAR\"=\"test_value\"; \"ANOTHER_VAR\"=\"another_value\"}\n\n```\n\n----------------------------------------\n\nTITLE: Installing PowerShell Core Directly from GitHub using wget\nDESCRIPTION: Commands for downloading and executing the PowerShell installation script directly from GitHub using wget. This method doesn't require downloading the script file to the local system first.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.sh-README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash <(wget -O - https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.sh) <ARGUMENTS>\n\nwget -O - https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.sh | bash -s <ARGUMENTS>\n```\n\n----------------------------------------\n\nTITLE: Installing Only PowerShell Core\nDESCRIPTION: Example command to install only PowerShell Core without any additional components like VSCode IDE, using the script directly from GitHub.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.sh-README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbash <(wget -O - https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.sh)\n```\n\n----------------------------------------\n\nTITLE: Enhance Type Inference in Tab Completion\nDESCRIPTION: This feature improves tab completion capability based on runtime variables, enabling more intelligent suggestions like completing process priorities using PowerShell objects. It enhances developer experience and script usability.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_4\n\n\n\n----------------------------------------\n\nTITLE: Creating Symbolic Links using New-Item in PowerShell\nDESCRIPTION: Illustrates how the `New-Item` cmdlet was fixed to allow creating symbolic links using the `-ItemType SymbolicLink` parameter. The `-Value` parameter specifies the target path, which can be a file, directory, or even a non-existent target.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_19\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Example: Create a symbolic link named MyLink pointing to TargetFile.txt\nNew-Item -ItemType SymbolicLink -Path .\\MyLink -Value .\\TargetFile.txt\n```\n\n----------------------------------------\n\nTITLE: Installing PowerShell Core with IDE\nDESCRIPTION: Example command to install PowerShell Core along with VSCode and PowerShell extension for VSCode, providing an integrated development environment.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.sh-README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbash <(wget -O - https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.sh) -includeide\n```\n\n----------------------------------------\n\nTITLE: Skipping Describe Block Tests Conditionally with Pester in PowerShell\nDESCRIPTION: This PowerShell script uses Pester's Describe, Context, and It blocks to group related tests and employs the $PSDefaultParameterValues automatic variable to dynamically skip all It block tests within a Describe block on non-Windows platforms. BeforeAll saves the current default parameter values, then, if not running on Windows, sets the 'it:skip' parameter to true so all contained tests are skipped. AfterAll restores the original defaults. This ensures platform-specific test logic executes or skips as intended; dependencies include Pester and the presence of both $IsWindows and $PSDefaultParameterValues.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_9\n\nLANGUAGE: PowerShell\nCODE:\n```\nDescribe \"Should not run these tests on non-Windows platforms\" {\n    BeforeAll {\n        $originalDefaultParameterValues = $PSDefaultParameterValues.Clone()\n        if ( ! $IsWindows ) {\n            $PSDefaultParameterValues[\"it:skip\"] = $true\n        }\n    }\n    AfterAll {\n        $global:PSDefaultParameterValues = $originalDefaultParameterValues\n    }\n    Context \"Block 1\" {\n        It \"This block 1 test 1\" {\n            1 | should -Be 1\n        }\n        It \"This is block 1 test 2\" {\n            1 | should -Be 1\n        }\n    }\n    Context \"Block 2\" {\n        It \"This block 2 test 1\" {\n            2 | should -Be 1\n        }\n        It \"This is block 2 test 2\" {\n            2 | should -Be 1\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting to PowerShell SSH Remoting on a Custom Port\nDESCRIPTION: Demonstrates using the newly added `-Port` parameter with `New-PSSession` to establish a PowerShell Remoting session over SSH to a host listening on a non-standard port (other than the default port 22).\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_22\n\nLANGUAGE: PowerShell\nCODE:\n```\nNew-PSSession -ComputerName MyRemoteHost -UserName MyUser -Port 2222\n```\n\n----------------------------------------\n\nTITLE: Packaging PowerShell Core on Windows (MSI/ZIP) (PowerShell)\nDESCRIPTION: Illustrates using the `Start-PSPackage` command in PowerShell to generate both MSI and ZIP packages for a specific release tag (e.g., v6.0.0-beta.1) on Windows. Requires specifying the target Windows runtime (`-WindowsRuntime`) like 'win7-x64' or 'win7-x86'.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/maintainers/releasing.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n# Create packages for v6.0.0-beta.1 release targeting Windows universal package.\n# 'win7-x64' / 'win7-x86' should be used for -WindowsRuntime.\nStart-PSPackage -Type msi -ReleaseTag v6.0.0-beta.1 -WindowsRuntime 'win7-x64'\nStart-PSPackage -Type zip -ReleaseTag v6.0.0-beta.1 -WindowsRuntime 'win7-x64'\n```\n\n----------------------------------------\n\nTITLE: Add Support for Spaces in File Paths on macOS/Linux\nDESCRIPTION: This fix allows commands like `Invoke-Item` to accept file paths containing spaces on macOS and Linux, improving usability and script correctness when handling such paths.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_13\n\n\n\n----------------------------------------\n\nTITLE: Using Pester TestDrive for Isolated File Operations in PowerShell\nDESCRIPTION: Example showcasing the Pester `TestDrive:` feature for performing file operations within a temporary, isolated scope. A function `Add-Footer` modifies a file created in `TestDrive:`, and the test verifies the file content using `Get-Content` and `Should -BeExactly`. The `TestDrive:` contents are automatically cleaned up after the `Describe` block finishes.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\nfunction Add-Footer($path, $footer) {\n   Add-Content $path -Value $footer\n}\n\nDescribe \"Add-Footer\" {\n   $testPath=\"TestDrive:\\test.txt\"\n   Set-Content $testPath -value \"my test text.\"\n   Add-Footer $testPath \"-Footer\"\n   $result = Get-Content $testPath\n\n   It \"adds a footer\" {\n       (-join $result) | Should -BeExactly \"my test text.-Footer\"\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Send-Greeting Cmdlet in C#\nDESCRIPTION: A C# implementation of a basic PowerShell cmdlet that sends a greeting message. The code defines a cmdlet class that inherits from the Cmdlet base class, with a mandatory Name parameter and a ProcessRecord method that outputs a greeting message.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/visual-studio-simple-example.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System.Management.Automation;  // PowerShell namespace.\n\nnamespace SendGreeting\n{\n    // Declare the class as a cmdlet and specify and\n    // appropriate verb and noun for the cmdlet name.\n    [Cmdlet(VerbsCommunications.Send, \"Greeting\")]\n    public class SendGreetingCommand : Cmdlet\n    {\n        // Declare the parameters for the cmdlet.\n        [Parameter(Mandatory = true)]\n        public string Name { get; set; }\n\n        // Override the ProcessRecord method to process\n        // the supplied user name and write out a\n        // greeting to the user by calling the WriteObject\n        // method.\n        protected override void ProcessRecord()\n        {\n            WriteObject(\"Hello \" + Name + \"!\");\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell PowerShell Core Backward Compatibility Enhancement\nDESCRIPTION: This section discusses the addition of Windows PowerShell 'PSModulePath' to PowerShell Core on Windows, allowing existing Windows PowerShell modules and scripts to work seamlessly within PowerShell Core. It highlights technical improvements, dependencies, and feedback collection efforts for long-term support.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Testing GET Method Endpoint in PowerShell\nDESCRIPTION: Shows how to make a basic GET request to the `/Get` endpoint. It uses `Invoke-RestMethod` and passes query parameters via the `-Body` parameter, which `Invoke-RestMethod` automatically appends for GET requests.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_26\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Get'\nInvoke-RestMethod -Uri $uri -Body @{TestField = 'TestValue'}\n```\n\n----------------------------------------\n\nTITLE: Creating and Pushing Annotated Git Release Tags (Git)\nDESCRIPTION: Provides the Git commands to create an annotated tag (`git tag -a`) with a specific version (e.g., v6.0.0-alpha.7) and a message containing release changelogs, followed by pushing all local tags (`git push --tags`) to the remote repository. This is crucial for marking release commits and triggering GitHub release processes.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/maintainers/releasing.md#_snippet_3\n\nLANGUAGE: git\nCODE:\n```\ngit tag -a v6.0.0-alpha.7 -m <message-here>\ngit push --tags\n```\n\n----------------------------------------\n\nTITLE: Enable Get-TimeZone on macOS and Linux\nDESCRIPTION: This platform-specific fix activates the `Get-TimeZone` cmdlet on macOS and Linux systems, expanding timezone functionality beyond Windows for cross-platform compatibility.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: PowerShell Script for Installing PowerShell Core with Various Options\nDESCRIPTION: This script automates the installation of PowerShell Core, supporting options like installing the latest preview or daily build, silent installation, and modifying system paths. It can be executed directly from a URL, and its features include version lookup, multiple installation methods, and customizable behavior through parameters.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.ps1-README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n# install-powershell.ps1\n\n## Features of install-powershell.ps1\n\n* Can be called directly from git\n* Optionally allows install of the latest Preview build\n* Optionally allows install of the Daily build\n* Optionally installs using the latest MSI\n* Automatically looks up latest version via git tags\n* Optionally installs silently\n* Optionally adds the install location to Path environment variable\n\n## Examples\n\n### Install PowerShell Core Daily Build\n\n```PowerShell\nInvoke-Expression \"& { $(Invoke-RestMethod 'https://aka.ms/install-powershell.ps1') } -daily\"\n```\n\n### Install PowerShell Core using the MSI installer\n\n```PowerShell\nInvoke-Expression \"& { $(Invoke-RestMethod 'https://aka.ms/install-powershell.ps1') } -UseMSI\"\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a PowerShell Cmdlet in C#\nDESCRIPTION: C# code example for a simple PowerShell cmdlet that writes timestamped messages. The class inherits from PSCmdlet and uses the Cmdlet attribute to define verb and noun.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Management.Automation;\n\nnamespace MyModule\n{\n    [Cmdlet(VerbsCommunications.Write, \"TimestampedMessage\")]\n    public class WriteTimestampedMessageCommand : PSCmdlet\n    {\n        [Parameter(Position=1)]\n        public string Message { get; set; } = string.Empty;\n\n        protected override void EndProcessing()\n        {\n            string timestamp = DateTime.Now.ToString(\"u\");\n            this.WriteObject($\"[{timestamp}] - {this.Message}\");\n            base.EndProcessing();\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Get-SecureRandom Cmdlet\nDESCRIPTION: This update adds the `Get-SecureRandom` cmdlet to PowerShell.  This cmdlet provides a cryptographically secure random number generator, improving security when generating random values.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Simulating Range Request with WebListener in PowerShell\nDESCRIPTION: This PowerShell script simulates a range request to download a file with resume support from the `/Resume/` endpoint. It uses `Invoke-WebRequest` to send a request with the `Range` header set to `bytes=0-`. The script retrieves the URL from `Get-WebListenerUrl` (assumed to be a helper function) and checks the response headers, including `X-WebListener-Has-Range`, `X-WebListener-Request-Range`, and `Content-Range`, demonstrating the server's handling of range requests. A dependency is the Get-WebListenerUrl function.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_28\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Resume'\n$response = Invoke-WebRequest -Uri $uri -Headers @{\"Range\" = \"bytes=0-\"}\n```\n\n----------------------------------------\n\nTITLE: Importing Build Module and Bootstrapping .NET CLI in PowerShell\nDESCRIPTION: This snippet demonstrates how to import the local build module and run the Start-PSBootstrap function to automatically install and configure the correct .NET CLI version required for building PowerShell. Prerequisites include the presence of the build.psm1 module in the current directory and execution policy allowing script execution. Input: None. Output: Installs and sets up .NET CLI, updating the environment if successful.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/windows-core.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSBootstrap\n```\n\n----------------------------------------\n\nTITLE: Cloning the PowerShell Repository (Shell)\nDESCRIPTION: Clones the main branch ('master') of the official PowerShell GitHub repository to your local machine.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/PowerShell/PowerShell.git --branch=master\n```\n\n----------------------------------------\n\nTITLE: Include GAC Assembly Loading Support in PowerShell Engine\nDESCRIPTION: Engine update introducing support for probing and loading assemblies directly from the GAC on Windows, enabling traditional Windows PowerShell modules with dependencies to run in PowerShell Core. It assists with module loading and compatibility with existing Windows modules.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_3\n\n\n\n----------------------------------------\n\nTITLE: Skipping Pester Tests on Windows\nDESCRIPTION: Shows how to use the `-Skip` parameter within a Pester `It` block to ensure a test only runs on non-Windows platforms (Linux or macOS). The skip condition checks if the automatic variable `$IsWindows` is true.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/powershell/README.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\nIt \"Should do something on Linux\" -Skip:$IsWindows { ... }\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Pull and Push Behavior (Shell)\nDESCRIPTION: Configures global Git settings to enforce fast-forward-only merges during pulls (`pull.ff only`) and to push the current branch only to a remote branch with the same name (`push.default current`). This helps maintain a cleaner history and prevents accidental pushes.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global pull.ff only\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global push.default current\n```\n\n----------------------------------------\n\nTITLE: Syncing Local Repository with Upstream Master (Shell)\nDESCRIPTION: Updates the local repository by fetching changes from all remotes, pruning obsolete remote branches, and then rebasing the current local branch onto the latest 'origin/master'. This integrates upstream changes while maintaining a linear history for the local feature branch.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n# fetch updates all remote branch references in the repository\n# --all : tells it to do it for all remotes (handy, when you use your fork)\n# -p : tells it to remove obsolete remote branch references (when they are removed from remote)\ngit fetch --all -p\n```\n\nLANGUAGE: sh\nCODE:\n```\n# rebase on origin/master will rewrite your branch history\ngit rebase origin/master\n```\n\n----------------------------------------\n\nTITLE: Simulating Retries in PowerShell\nDESCRIPTION: This PowerShell script tests the `/Retry/{sessionId}/{failureCode}/{failureCount}` endpoint, which simulates failures for a specified number of times and then returns a 200 OK status. It utilizes `Invoke-WebRequest` and sets parameters for `failureCode`, `failureCount`, and `sessionid`. The script also specifies a `MaximumRetryCount` and `RetryIntervalSec` to handle the simulated failures. The response body is examined to confirm the number of failures that occurred.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_31\n\nLANGUAGE: powershell\nCODE:\n```\n$response = Invoke-WebRequest -Uri 'http://127.0.0.1:8083/Retry?failureCode=599&failureCount=2&sessionid=100&' -MaximumRetryCount 2 -RetryIntervalSec 1\n```\n\n----------------------------------------\n\nTITLE: Skipping Pester Tests on Non-Windows Platforms\nDESCRIPTION: Illustrates how to use the `-Skip` parameter within a Pester `It` block to ensure a test only runs on the Windows platform. The skip condition checks if the automatic variables `$IsLinux` or `$IsMacOS` are true.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/powershell/README.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nIt \"Should do something on Windows\" -Skip:($IsLinux -Or $IsMacOS) { ... }\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Whitespace Handling and Merge/Rebase Helpers (Shell)\nDESCRIPTION: Sets several global Git configurations: ignore whitespace changes (`apply.ignoreWhitespace change`), enable reuse recorded resolution (`rerere.enabled true`) for repeated merge conflicts, automatically update resolved conflicts (`rerere.autoUpdate true`), and use a three-way merge for `git am` (`am.threeWay true`). These settings aid in managing whitespace differences and streamlining conflict resolution.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global apply.ignoreWhitespace change\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global rerere.enabled true\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global rerere.autoUpdate true\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global am.threeWay true\n```\n\n----------------------------------------\n\nTITLE: Testing Client Certificate Authentication in PowerShell\nDESCRIPTION: Demonstrates how to test client certificate authentication. It uses `Get-WebListenerClientCertificate` to retrieve a certificate and `Invoke-RestMethod` to send a request to the `/Cert` endpoint, attaching the certificate to the request.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_8\n\nLANGUAGE: powershell\nCODE:\n```\n$certificate = Get-WebListenerClientCertificate\n$uri = Get-WebListenerUrl -Test 'Cert' -Https\nInvoke-RestMethod -Uri $uri -Certificate $certificate\n```\n\n----------------------------------------\n\nTITLE: Running Pester Tests PowerShell\nDESCRIPTION: This snippet demonstrates how to execute Pester tests using the `Start-PSPester` function from the `build.psm1` module.  It covers running all CI tests, and tests within a specific path or file. It requires the build.psm1 module which must be in the same directory as the test script or you must specify the full path.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/testing-guidelines.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSPester\n```\n\n----------------------------------------\n\nTITLE: Importing and Testing the Module in PowerShell Core\nDESCRIPTION: PowerShell commands to import the compiled module DLL and test the created cmdlet in PowerShell Core.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\ncd 'bin/Debug/netstandard2.0'\nImport-Module ./MyModule.dll\nWrite-TimestampedMessage \"Test message.\"\n```\n\n----------------------------------------\n\nTITLE: Comparing File-Level Code Coverage with Compare-FileCoverage in PowerShell\nDESCRIPTION: This snippet demonstrates comparison of code coverage for a specific file using Compare-FileCoverage, including both reference and difference coverage objects. It outputs the coverage rates for the selected file before and after changes and the calculated delta. Requires two code coverage runs with their data loaded, and the target file's name as a parameter.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS> Compare-FileCoverage -ReferenceCoverage $cov2 -DifferenceCoverage $cov1 -FileName LanguagePrimitives.cs\n\nFileName              ReferenceCoverage DifferenceCoverage CoverageDelta\n--------              ----------------- ------------------ -------------\nLanguagePrimitives.cs 53.68             69.03              15.34\n```\n\n----------------------------------------\n\nTITLE: Comparing Code Coverage Results with Compare-CodeCoverage in PowerShell\nDESCRIPTION: This snippet shows how to compare two code coverage runs using the Compare-CodeCoverage cmdlet, importing coverage data from two XML files created by OpenCover. It highlights how to evaluate changes in coverage metrics per assembly, including both sequence and branch coverage and their respective deltas. Dependencies include the OpenCover module and two prior runs of coverage data. Inputs are the XML coverage files, and output is a comparison table for assemblies.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS> $cov1 = Get-CodeCoverage ./coverage1.xml\nPS> $cov2 = Get-CodeCoverage ./coverage2.xml\nPS> Compare-CodeCoverage -Run1 $cov1 -Run2 $cov2\n\nAssemblyName                              Sequence SequenceDelta Branch BranchDelta\n------------                              -------- ------------- ------ -----------\nMicrosoft.PowerShell.Security                20.09        -30.12  17.32      -31.63\nMicrosoft.PowerShell.Commands.Management     43.39          9.10  43.05       11.59\nSystem.Management.Automation                 45.04        -10.63  41.23      -11.07\nMicrosoft.PowerShell.Commands.Utility        21.39        -47.22  20.14      -46.47\nMicrosoft.PowerShell.Commands.Diagnostics        0        -51.91      0      -48.62\nMicrosoft.PowerShell.ConsoleHost             23.32        -22.28  21.58      -22.47\npwsh                                           100          0.00    100        0.00\nMicrosoft.WSMan.Management                   57.73         48.23  53.02       43.22\nMicrosoft.WSMan.Runtime                      80.33        -19.67  80.95      -19.05\nMicrosoft.PowerShell.CoreCLR.Eventing         2.03        -32.74   1.88      -26.01\n```\n\n----------------------------------------\n\nTITLE: Using ShellExecute for Opening Files/URIs in PowerShell\nDESCRIPTION: Describes the change in `Start-Process`, `Invoke-Item`, and `Get-Help -Online` to use the underlying operating system's `ShellExecute` function. This ensures these cmdlets use standard file associations and the default browser.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_25\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Opens the help topic in the default browser\nGet-Help Get-Process -Online\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Opens the specified file with its associated application\nStart-Process .\\MyDocument.docx\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Opens the specified file with its associated application (similar to Start-Process)\nInvoke-Item .\\MySpreadsheet.xlsx\n```\n\n----------------------------------------\n\nTITLE: Running xUnit Tests via PowerShell and .NET CLI\nDESCRIPTION: Demonstrates how to run the full set of xUnit tests for the PowerShell Core project using the `Start-PSxUnit` PowerShell command and the `dotnet test` CLI with optional filtering parameters. Dependencies include having a self-hosted PowerShell copy for `Start-PSxUnit` and the .NET SDK installed for `dotnet test`. The filter parameter enables selective running of tests based on test names or fully qualified names, aiding targeted test execution.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/xUnit/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\ndotnet test -c Release --filter \"FullyQualifiedName~UnitTest1   # Runs tests which have UnitTest1 in FullyQualifiedName\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\ndotnet test --filter Name~TestMethod1   # Runs tests whose name contains TestMethod1\n```\n\n----------------------------------------\n\nTITLE: Testing Resume Without Range Headers in PowerShell\nDESCRIPTION: This PowerShell script tests the `/Resume/NoResume` endpoint, which ignores the `Range` header and always returns the full 20 bytes. It utilizes `Invoke-WebRequest` to send an HTTP request and verifies the response headers to confirm that the `X-WebListener-Has-Range` is false and the `Content-Length` is 20. This tests the scenario where range headers are provided but are ignored.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_30\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Resume' -TestValue 'NoResume'\n$response = Invoke-WebRequest -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Add Windows PowerShell PSModulePath Default on Windows\nDESCRIPTION: This changelog entry details an engine update that automatically includes the Windows PowerShell PSModulePath in PowerShell Core on Windows, facilitating module discovery and compatibility with existing Windows modules. It is part of broader efforts to enable easier module loading across environments.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_1\n\n\n\n----------------------------------------\n\nTITLE: Defining NuGet Package Sources Using XML Configuration - XML\nDESCRIPTION: This XML snippet represents the full contents of a 'nuget.config' file required to set up package sources for NuGet in a .NET or PowerShell environment. No external dependencies are needed beyond a NuGet-compatible toolchain; simply place the file at the project root. The file clears any existing sources and ensures only 'nuget.org' is used, disabling all other sources, with no additional parameters required. This file is essential for controlling where packages are retrieved from, which is especially useful in enterprise or isolated environments.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/host-powershell/sample/NuGet.config.md#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<configuration>\n  <packageSources>\n    <clear />\n    <add key=\"nuget.org\" value=\"https://api.nuget.org/v3/index.json\" /> \n  </packageSources>\n  <disabledPackageSources>\n    <clear />\n  </disabledPackageSources>\n</configuration>\n```\n\n----------------------------------------\n\nTITLE: Launching Development PowerShell Process for Testing\nDESCRIPTION: Demonstrates how to correctly launch a new PowerShell process using the development build (`pwsh` located in `$PsHome`) for testing purposes. It emphasizes using the `-noprofile` switch to avoid interference from user/system profiles and executes a sample command, piping the output to a Pester assertion (`Should Be`).\nSOURCE: https://github.com/powershell/powershell/blob/master/test/powershell/README.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\n    $powershell = Join-Path -Path $PsHome -ChildPath \"pwsh\"\n    & $powershell -noprofile -command \"ExampleCommand\" | Should Be \"ExampleOutput\"\n```\n\n----------------------------------------\n\nTITLE: Disallowing Negative Values in Get-Content -Head and -Tail\nDESCRIPTION: This update disallows negative values for the `-Head` and `-Tail` parameters of the `Get-Content` cmdlet.  This prevents unexpected behavior when attempting to retrieve the first or last N lines of a file.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_0\n\n\n\n----------------------------------------\n\nTITLE: Adding the ProgressAction Common Parameter in PowerShell\nDESCRIPTION: A breaking change that adds the -ProgressAction parameter to the common parameters in PowerShell, allowing users to control how progress information is displayed.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\n# Example of using the new -ProgressAction common parameter\nGet-ChildItem -Path C:\\ -Recurse -ProgressAction SilentlyContinue\n\n```\n\n----------------------------------------\n\nTITLE: Opening PowerShell Session and Building PowerShell\nDESCRIPTION: This snippet instructs to launch PowerShell via 'pwsh' and execute 'Start-PSBuild -UseNuGetOrg' to compile PowerShell targeting macOS. It specifies the location of the resulting built PowerShell binary.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/macos.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-PSBuild -UseNuGetOrg\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for GET Method Test\nDESCRIPTION: An example JSON response returned by the `/Get` endpoint when a GET request is received. It includes details about the request such as origin IP, the requested URL (including query parameters), the method (GET), any query arguments, and request headers.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_27\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"origin\": \"127.0.0.1\",\n  \"url\": \"http://localhost:8083/Get?TestField=TestValue\",\n  \"method\": \"GET\",\n  \"args\": {\n    \"TestField\": \"TestValue\"\n  },\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Microsoft Windows 10.0.15063; en-US) PowerShell/6.0.0\",\n    \"Connection\": \"Keep-Alive\",\n    \"Host\": \"localhost:8083\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Fix Import-Module to Support NestedModules and RootModules on Linux\nDESCRIPTION: This correction ensures that `Import-Module` can correctly load modules with `NestedModules` and `RootModules` parameters on non-Windows platforms, improving module import reliability across platforms.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_12\n\n\n\n----------------------------------------\n\nTITLE: Support Backgrounding Pipelines with Ampersand (&)\nDESCRIPTION: This feature enables running PowerShell pipelines as background jobs when ending the command with '&'. It returns a job object that can be managed with `*-Job` cmdlets and copies variables into the job environment, facilitating job control and multitasking.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Fixing 'Too many open files' Error in macOS\nDESCRIPTION: This snippet provides a command 'ulimit -n 2048' to temporarily increase the open files limit in the shell, which is necessary due to a known NuGet bug affecting 'dotnet restore'. To make the change permanent, add the command to your shell's profile script. It is recommended to execute this before running build commands to avoid errors.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/macos.md#_snippet_2\n\nLANGUAGE: Bash\nCODE:\n```\nulimit -n 2048\n```\n\n----------------------------------------\n\nTITLE: Using String Interpolation in PowerShell/C#\nDESCRIPTION: The release notes mention a performance improvement through using interpolated strings across multiple PR numbers (19002, 19003, 18977, etc.). This is a C# coding practice that improves string concatenation performance.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// Example of string interpolation syntax\nstring name = \"PowerShell\";\nstring version = \"7.4.0\";\n\n// Old way\nstring message = \"Welcome to \" + name + \" version \" + version;\n\n// New way with interpolation\nstring betterMessage = $\"Welcome to {name} version {version}\";\n\n```\n\n----------------------------------------\n\nTITLE: Testing Negotiate Authentication in PowerShell\nDESCRIPTION: Demonstrates how to perform a Negotiate authentication test. It uses `Invoke-RestMethod` with the `-UseDefaultCredential` parameter to send the request to the `/Auth/Negotiate` endpoint, leveraging the default credentials of the current user, and skips certificate checks.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Auth' -TestValue 'Negotiate' -Https\nInvoke-RestMethod -Uri $uri -UseDefaultCredential -SkipCertificateCheck\n```\n\n----------------------------------------\n\nTITLE: Support Link Header Pagination in Web Cmdlets\nDESCRIPTION: This update enhances web cmdlets like Invoke-WebRequest and Invoke-RestMethod to handle pagination via HTTP Link headers, providing easier navigation through paginated APIs with parameters like `-FollowRelLink` and ensuring URLs are absolute for script robustness.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Building PowerShell Using the Build Module in PowerShell\nDESCRIPTION: This example imports the build.psm1 module and runs Start-PSBuild with Clean, PSModuleRestore, and UseNuGetOrg parameters to build PowerShell from source. Assumes dependencies are met and the repository is positioned correctly. Input: None. Output: Built PowerShell binaries available in the designated output path.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/windows-core.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSBuild -Clean -PSModuleRestore -UseNuGetOrg\n```\n\n----------------------------------------\n\nTITLE: Starting WebListener using PowerShell Module\nDESCRIPTION: Demonstrates how to start the WebListener server using a dedicated PowerShell module. It involves importing the module and calling the `Start-WebListener` cmdlet with specified ports for HTTP and different TLS versions of HTTPS.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nImport-Module .\\build.psm1\nPublish-PSTestTools\n$Listener = Start-WebListener -HttpPort 8083 -HttpsPort 8084 -Tls11Port 8085 -TlsPort 8086\n```\n\n----------------------------------------\n\nTITLE: Configure Git Credential Helper\nDESCRIPTION: This command configures Git to use the 'store' credential helper globally.  The store helper caches your credentials in plaintext on your system.  This is a convenient option for authentication, but it stores credentials insecurely.  This command is a prerequisite for using Git for authentication without having to type credentials every time.  The output of this command doesn't indicate any change.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/basics.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global credential.helper store\n```\n\n----------------------------------------\n\nTITLE: Building the .NET Standard Module\nDESCRIPTION: Command to build the .NET Standard 2.0 class library project which creates the DLL file for the PowerShell module.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet build\n```\n\n----------------------------------------\n\nTITLE: Bootstrap PowerShell build environment\nDESCRIPTION: This PowerShell snippet imports the build module and then calls `Start-PSBootstrap` to set up the build environment. The function adds the LLVM package feed, installs dependencies, uninstalls old .NET CLI versions, and downloads the .NET Core SDK.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/linux.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSBootstrap\n```\n\n----------------------------------------\n\nTITLE: Starting WebListener with Ports - PowerShell\nDESCRIPTION: This snippet demonstrates how to import the WebListener module and start the WebListener application. It configures the listener to use specific ports for HTTP, HTTPS (TLS 1.2), TLS 1.1, and generic TLS connections. The module automatically generates necessary self-signed certificates upon startup.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/Modules/WebListener/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module .\build.psm1\nPublish-PSTestTools\n$Listener = Start-WebListener -HttpPort 8083 -HttpsPort 8084 -Tls11Port 8085 -TlsPort 8086\n```\n\n----------------------------------------\n\nTITLE: Verifying .NET Core CLI Version\nDESCRIPTION: Command to check the installed version of the .NET Core CLI. The version should be 2.0.0 or higher for this tutorial.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet --version\n```\n\n----------------------------------------\n\nTITLE: Disabling PowerShell Core Console Host Telemetry\nDESCRIPTION: Shows the file path that needs to be deleted to opt-out of the console host telemetry introduced in PowerShell Core 6.0 Beta 1. Deleting this file, even before the first run of PowerShell, bypasses this specific telemetry collection.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_15\n\nLANGUAGE: PowerShell\nCODE:\n```\n$PSHome\\DELETE_ME_TO_DISABLE_CONSOLEHOST_TELEMETRY\n```\n\n----------------------------------------\n\nTITLE: Using Import-Module and Start-PSBootstrap in PowerShell\nDESCRIPTION: This snippet demonstrates how to import the build module in PowerShell and initiate the bootstrap process with Start-PSBootstrap, which installs dependencies like OpenSSL, GNU WGet, and the .NET Core SDK by using package managers Homebrew or MacPorts.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/macos.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSBootstrap\n```\n\n----------------------------------------\n\nTITLE: Adding PowerShell Standard Library Reference\nDESCRIPTION: Command to add the PowerShellStandard.Library NuGet package which provides the System.Management.Automation assembly for PowerShell cmdlet development.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet add package PowerShellStandard.Library --version 3.0.0-preview-01\n```\n\n----------------------------------------\n\nTITLE: Testing NTLM Authentication in PowerShell\nDESCRIPTION: Shows how to perform an NTLM authentication test. It uses `Invoke-RestMethod` with the `-UseDefaultCredential` parameter to send the request to the `/Auth/NTLM` endpoint, utilizing the default credentials of the current user, and skips certificate checks.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_6\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Auth' -TestValue 'NTLM' -Https\nInvoke-RestMethod -Uri $uri -UseDefaultCredential -SkipCertificateCheck\n```\n\n----------------------------------------\n\nTITLE: Testing Basic Authentication in PowerShell\nDESCRIPTION: Shows how to perform a Basic authentication test against the WebListener. It uses `Get-Credential` to prompt for username and password and `Invoke-RestMethod` to send the request to the `/Auth/Basic` endpoint with the acquired credentials, skipping certificate checks.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\n$credential = Get-Credential\n$uri = Get-WebListenerUrl -Test 'Auth' -TestValue 'Basic' -Https\nInvoke-RestMethod -Uri $uri -Credential $credential -SkipCertificateCheck\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Gzip Compression Test\nDESCRIPTION: An example JSON response returned by the `/Compression/Gzip` endpoint. The content is similar to the `/Get` test response, including origin, headers (potentially including compression-related headers if supported), and the URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_16\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"args\": {},\n  \"origin\": \"127.0.0.1\",\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT; Microsoft Windows 10.0.15063 ; en-US) PowerShell/6.0.0\",\n    \"Host\": \"localhost:8083\"\n  },\n  \"url\": \"http://localhost:8083/Compression/Gzip\"\n}\n```\n\n----------------------------------------\n\nTITLE: Run ClearlyDefined PowerShell Script for Testing\nDESCRIPTION: Executes the `ClearlyDefined.ps1` script with the `-test` switch. This mode checks if all necessary license data is present in ClearlyDefined for generating the PowerShell license without triggering a harvest. The script will write verbose messages about missing data and throw an error if any data is incomplete.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/clearlyDefined/readme.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n./ClearlyDefined.ps1 -test\n```\n\n----------------------------------------\n\nTITLE: Running ASP.NET Core WebListener with dotnet\nDESCRIPTION: Provides the necessary bash commands to build and run the WebListener application using the .NET Core SDK. It involves restoring dependencies, publishing the application, navigating to the output directory, and executing the DLL with required arguments for certificate path, password, and HTTP/HTTPS ports.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet restore\ndotnet publish --output bin --configuration Release\ncd bin\ndotnet WebListener.dll ServerCert.pfx password 8083 8084 8085 8086\n```\n\n----------------------------------------\n\nTITLE: Build PowerShell using Start-PSBuild\nDESCRIPTION: This PowerShell snippet imports the build module and then calls the `Start-PSBuild` function to build PowerShell. The `-UseNuGetOrg` parameter is used to specify the NuGet feed.  This requires that the toolchain is properly set up before running.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/linux.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSBuild -UseNuGetOrg\n```\n\n----------------------------------------\n\nTITLE: Stopping the UnixSocket Listener in PowerShell\nDESCRIPTION: This snippet shows the command to stop the previously started UnixSocket listener. It calls the 'Stop-UnixSocket' cmdlet, which presumably handles the necessary cleanup and termination of the socket listener process initiated by 'Start-UnixSocket'.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/Modules/UnixSocket/README.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\nStop-UnixSocket\n```\n\n----------------------------------------\n\nTITLE: Bypassing System Proxy with Web Cmdlets in PowerShell\nDESCRIPTION: Illustrates using the `-NoProxy` switch, added to web cmdlets like `Invoke-WebRequest` and `Invoke-RestMethod`. This switch instructs the cmdlet to ignore any system-wide proxy server configuration for that specific web request.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_27\n\nLANGUAGE: PowerShell\nCODE:\n```\nInvoke-WebRequest -Uri https://example.com -NoProxy\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nInvoke-RestMethod -Uri https://api.example.com/data -NoProxy\n```\n\n----------------------------------------\n\nTITLE: Testing Deflate Compression in PowerShell\nDESCRIPTION: Demonstrates how to make a request to the endpoint designed to test Deflate compression. It calls the `/Compression/Deflate` endpoint using `Invoke-RestMethod` to retrieve the response, which should be Deflate-compressed if the client supports it.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Compression' -TestValue 'Deflate'\nInvoke-RestMethod -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Testing Image Parsing DOS Endpoint in PowerShell\nDESCRIPTION: Demonstrates how to call the `/Dos` endpoint specifically to test the image parsing regex vulnerability. It appends query parameters `dosType` and `dosLength` to the URL before calling `Invoke-RestMethod`.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_21\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Dos' -query @{\n                dosType='img'\n                dosLength='5000'\n            }\nInvoke-RestMethod -Uri $uri -Body $body -Method 'Delete'\n```\n\n----------------------------------------\n\nTITLE: Creating a .NET Standard Class Library Project\nDESCRIPTION: Command to create a new class library project using the .NET Core CLI. The project targets .NET Standard 2.0 by default.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet new classlib --name MyModule\n```\n\n----------------------------------------\n\nTITLE: Testing Gzip Compression in PowerShell\nDESCRIPTION: Shows how to make a request to the endpoint designed to test Gzip compression. It calls the `/Compression/Gzip` endpoint using `Invoke-RestMethod` to retrieve the response, which should be Gzip-compressed if the client supports it.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_15\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Compression' -TestValue 'Gzip'\nInvoke-RestMethod -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Testing Request Delay in PowerShell\nDESCRIPTION: Demonstrates how to test the delay functionality of the server. It calls the `/Delay` endpoint with a value of '5' using `Invoke-RestMethod`, causing the server to wait for 5 seconds before returning the response.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_17\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Delay' -TestValue '5'\nInvoke-RestMethod -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Testing DELETE Method in PowerShell\nDESCRIPTION: Shows how to send a DELETE request to the `/Delete` endpoint. It creates a JSON body using `ConvertTo-Json` and sends it along with the DELETE method using `Invoke-RestMethod`.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_19\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Delete'\n$Body = @{id = 12345} | ConvertTo-Json -Compress\nInvoke-RestMethod -Uri $uri -Body $body -Method 'Delete'\n```\n\n----------------------------------------\n\nTITLE: Creating xUnit Test Namespace in C# for PowerShell Core\nDESCRIPTION: Shows the recommended structure for declaring xUnit test namespaces in C# for the PowerShell Core project. Tests should use namespaces starting with `PSTests` to maintain organization and consistency with the project conventions. No additional dependencies are required beyond standard C# and xUnit setup. This snippet provides a minimal namespace declaration template.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/xUnit/README.md#_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\nnamespace PSTests.YourNameSpace\n{\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell Benchmark Regression Detection Example\nDESCRIPTION: Example of running benchmarks against current codebase and a specific PS version, then comparing results using Compare-BenchmarkResult with a 1% threshold to detect performance changes.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n## Run benchmarks targeting the current code base\nPS:1> Start-Benchmarking -Filter *script* -Artifacts C:\\arena\\tmp\\BenchmarkDotNet.Artifacts\\current\\\n\n## Run benchmarks targeting the 7.1.3 version of PS package\nPS:2> Start-Benchmarking -Filter *script* -Artifacts C:\\arena\\tmp\\BenchmarkDotNet.Artifacts\\7.1.3 -TargetPSVersion 7.1.3\n\n## Compare the results using 5% threshold\nPS:3> Compare-BenchmarkResult -BaseResultPath C:\\arena\\tmp\\BenchmarkDotNet.Artifacts\\7.1.3\\ -DiffResultPath C:\\arena\\tmp\\BenchmarkDotNet.Artifacts\\current\\ -Threshold 1%\nsummary:\nbetter: 4, geomean: 1.057\ntotal diff: 4\n\nNo Slower results for the provided threshold = 1% and noise filter = 0.3ns.\n\n| Faster                                                                           | base/diff | Base Median (ns) | Diff Median (ns) | Modality|\n| -------------------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| --------:|\n| Engine.Scripting.InvokeMethod(Script: \"$fs=New-Object -ComObject scripting.files |      1.07 |         50635.77 |         47116.42 |         |\n| Engine.Scripting.InvokeMethod(Script: \"$sh=New-Object -ComObject Shell.Applicati |      1.07 |       1063085.23 |        991602.08 |         |\n| Engine.Scripting.InvokeMethod(Script: \"'String'.GetType()\")                      |      1.06 |          1329.93 |          1252.51 |         |\n| Engine.Scripting.InvokeMethod(Script: \"[System.IO.Path]::HasExtension('')\")      |      1.02 |          1322.04 |          1297.72 |         |\n\nNo file given\n```\n\n----------------------------------------\n\nTITLE: Running Type Catalog Generation Manually in PowerShell Build\nDESCRIPTION: Commands to manually run the TypeCatalogGen tool that generates a catalog of C# types used for type resolution in PowerShell. This shows how to generate the CorePsTypeCatalog.cs file.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd ../TypeCatalogGen\ndotnet restore\ndotnet run ../System.Management.Automation/CoreCLR/CorePsTypeCatalog.cs powershell.inc\n```\n\n----------------------------------------\n\nTITLE: Using NoHeader Parameter with CSV Cmdlets in PowerShell\nDESCRIPTION: Shows the usage of the newly added -NoHeader parameter for ConvertTo-Csv and Export-Csv cmdlets, which allows generating CSV output without the header row.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n# Example of using the new -NoHeader parameter\n$data = @(\n    [PSCustomObject]@{Name=\"John\"; Age=30}\n    [PSCustomObject]@{Name=\"Jane\"; Age=28}\n)\n\n# Export CSV without headers\n$data | Export-Csv -Path \"users.csv\" -NoHeader\n\n```\n\n----------------------------------------\n\nTITLE: Running PowerShell Benchmarks in Interactive Mode\nDESCRIPTION: Command to run the benchmarks in interactive mode using dotnet CLI, where the user will be prompted to select which benchmarks to run.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release -f net6.0\n```\n\n----------------------------------------\n\nTITLE: Making Install-PowerShellRemoting Handle Empty String\nDESCRIPTION: The `Install-PowerShellRemoting.ps1` script is updated to handle an empty string provided for the `PowerShellHome` parameter. This change ensures that the script functions correctly when this parameter is not explicitly set or has no value, enhancing its robustness.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.0.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nMake `Install-PowerShellRemoting.ps1` handle empty string in `PowerShellHome` parameter (#10526) (Thanks @Orca88!)\n```\n\n----------------------------------------\n\nTITLE: Building Native Unix Binaries for PowerShell\nDESCRIPTION: PowerShell command to build the native Unix binaries for Linux x64 or macOS platforms, which is required for the libpsl-native component used in PowerShell Core on Unix systems.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\n## Build targeting linux-x64 or macOS\nStart-BuildNativeUnixBinaries\n```\n\n----------------------------------------\n\nTITLE: Listing Available PowerShell Benchmarks\nDESCRIPTION: Command to list all available benchmarks in either flat or tree format using the dotnet CLI.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release -f net6.0 --list [flat/tree]\n```\n\n----------------------------------------\n\nTITLE: Filtering PowerShell Benchmarks with Glob Pattern\nDESCRIPTION: Command to filter benchmarks using a glob pattern applied to namespace.typeName.methodName and list them in flat format.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release -f net6.0 --filter *script* --list flat\n```\n\n----------------------------------------\n\nTITLE: Launching PowerShell Core as an Interactive Shell\nDESCRIPTION: Shows how to use the '-i' command-line switch to explicitly indicate that PowerShell Core (pwsh) is being launched as an interactive shell. This can be important for compatibility when configuring PowerShell as a default shell on Unix systems.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_17\n\nLANGUAGE: Shell\nCODE:\n```\npwsh -i\n```\n\n----------------------------------------\n\nTITLE: Skipping auto-loading PSReadLine on Windows\nDESCRIPTION: This snippet outlines the implementation of skipping `PSReadLine` auto-loading on Windows systems, specifically when the NVDA screen reader is active. This adjustment helps to avoid potential conflicts or performance issues between the screen reader and the PowerShell console, leading to a better user experience for visually impaired users.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.0.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nSkip auto-loading `PSReadLine` on Windows if the [NVDA screen reader](https://www.nvaccess.org/about-nvda/) is active (#10385)\n```\n\n----------------------------------------\n\nTITLE: Start-Benchmarking PowerShell Function Syntax\nDESCRIPTION: Syntax for the Start-Benchmarking function from the perf.psm1 module, showing the three different parameter sets available for running benchmarks.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_4\n\nLANGUAGE: powershell\nCODE:\n```\nStart-Benchmarking [-TargetFramework <string>] [-List <string>] [-Filter <string[]>] [-Artifacts <string>] [-KeepFiles] [<CommonParameters>]\n\nStart-Benchmarking [-TargetPSVersion <string>] [-Filter <string[]>] [-Artifacts <string>] [-KeepFiles] [<CommonParameters>]\n\nStart-Benchmarking -Runtime <string[]> [-Filter <string[]>] [-Artifacts <string>] [-KeepFiles] [<CommonParameters>]\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for NTLM Authentication\nDESCRIPTION: An example JSON response returned by the `/Auth/NTLM` endpoint. It includes details about the request, such as headers (including the NTLM Authorization header), origin IP, and the requested URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_7\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"headers\":{\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Microsoft Windows 10.0.15063; en-US) PowerShell/6.0.0\",\n        \"Connection\": \"Keep-Alive\",\n        \"Authorization\": \"NTLM jjaguasgtisi7tiqkagasjjajvs\",\n        \"Host\": \"localhost:8084\"\n    },\n    \"origin\": \"127.0.0.1\",\n    \"args\": {},\n    \"url\": \"https://localhost:8084/Auth/NTLM\"\n}\n```\n\n----------------------------------------\n\nTITLE: Installing PowerShell Core with IDE and Interactive Testing\nDESCRIPTION: Example command to install PowerShell Core with VSCode IDE and perform interactive testing which requires human interaction during the installation process.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.sh-README.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbash <(wget -O - https://raw.githubusercontent.com/PowerShell/PowerShell/master/tools/install-powershell.sh) -includeide -interactivetesting\n```\n\n----------------------------------------\n\nTITLE: Testing Charset Parsing DOS Endpoint in PowerShell\nDESCRIPTION: Shows how to call the `/Dos` endpoint specifically to test the charset parsing regex vulnerability. It appends query parameters `dosType` and `dosLength` to the URL before calling `Invoke-RestMethod`.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_23\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Dos' -query @{\n                dosType='charset'\n                dosLength='5000'\n            }\nInvoke-RestMethod -Uri $uri -Body $body -Method 'Delete'\n```\n\n----------------------------------------\n\nTITLE: Creating a Hotfix Branch from a Tag (Shell)\nDESCRIPTION: Creates and checks out a new local branch named 'vors/hotfix' starting from the currently checked-out commit, which is typically a tag checked out in a DETACHED HEAD state. This is useful for creating hotfixes based on a specific release version.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ngit checkout -b vors/hotfix\n```\n\n----------------------------------------\n\nTITLE: Change Positional Parameters for PowerShell Executable\nDESCRIPTION: This update modifies the default positional parameter from '-Command' to '-File' for 'powershell.exe', improving script execution and shebang support on non-Windows platforms. Users can still specify '-c' or '-Command' explicitly when needed.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_2\n\n\n\n----------------------------------------\n\nTITLE: Stopping WebListener - PowerShell\nDESCRIPTION: This snippet shows how to stop the running WebListener application instance that was previously started by the module. This command terminates the listener process or resource managed by the module.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/Modules/WebListener/README.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nStop-WebListener\n```\n\n----------------------------------------\n\nTITLE: Declaring PowerShell SDK Package References in XML\nDESCRIPTION: This XML snippet demonstrates how to declare package references for the PowerShell SDK and related modules within a .csproj file.  It's a key part of setting up a project to use PowerShell and its associated components for development.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/FAQ.md#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<ItemGroup>\n  <PackageReference Include=\"Microsoft.PowerShell.SDK\" Version=\"7.3.5\" />\n  <PackageReference Include=\"Microsoft.PowerShell.Commands.Diagnostics\" Version=\"7.3.5\" />\n  <PackageReference Include=\"Microsoft.WSMan.Management\" Version=\"7.3.5\"/>\n</ItemGroup>\n```\n\n----------------------------------------\n\nTITLE: Copying the netstandard.dll for Windows PowerShell Compatibility\nDESCRIPTION: PowerShell commands to copy the netstandard.dll implementation assembly to the module directory for compatibility with Windows PowerShell on systems without .NET Framework 4.7.1.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_7\n\nLANGUAGE: powershell\nCODE:\n```\ncd 'path-to-where-you-copied-module.dll'\nCopy-Item 'C:\\Program Files\\dotnet\\sdk\\<version-number>\\Microsoft\\Microsoft.NET.Build.Extensions\\net461\\lib\\netstandard.dll' .\n```\n\n----------------------------------------\n\nTITLE: UpdateDotnetRuntime Script Path Addition\nDESCRIPTION: This snippet describes adding the .NET SDK installation path to the current process path within the UpdateDotnetRuntime.ps1 tool. This ensures the script can locate and use the .NET SDK without requiring global environment configuration.  The expected input is an existing .NET SDK installation, and the output is an updated process path.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.1.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nAdd the `.NET SDK` installation path to the current process path in `tools/UpdateDotnetRuntime.ps1` (#12525)\n```\n\n----------------------------------------\n\nTITLE: Enum.HasFlags C#\nDESCRIPTION: This code snippet refers to the usage of Enum.HasFlags for checking if an enum value has a specific flag set in C#.  This provides a more readable and type-safe way to perform flag checks compared to bitwise operations. It improves code clarity and reduces the potential for errors.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nUse `Enum.HasFlags` part 1\n```\n\n----------------------------------------\n\nTITLE: Using Wildcards (Globbing) with Native Commands on Unix in PowerShell\nDESCRIPTION: Demonstrates the added support for native command globbing on Unix platforms in PowerShell Core. This allows wildcards like '*' to be interpreted by PowerShell before passing arguments to native executables.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_16\n\nLANGUAGE: Shell\nCODE:\n```\nls *.txt\n```\n\n----------------------------------------\n\nTITLE: Engine Updates and Fixes in PowerShell 6.2.0-preview.3\nDESCRIPTION: List of engine updates and fixes in PowerShell 6.2.0-preview.3, including startup time improvement, formatting fixes, addition of experimental feature cmdlets, and various bug fixes related to module exports, configuration access, connection security, and trusted execution.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.2.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Engine Updates and Fixes\n\n# Improve PowerShell startup time by 24% (#8341) (#8396)\n# Remove extra newlines from formatting which resulted in unnecessary double newlines (#8247)\n# Add Enable-ExperimentalFeature and Disable-ExperimentalFeature cmdlets (#8318)\n# Fix Export-ModuleMember bug for a ScriptBlock having no context (#8363)\n# Fix race condition to access powershell.config.json (#8249)\n# Add SkipCA and SkipCN check requirement to WinRM/OMI HTTPS connection (#8279)\n# Add fix for Start-Job initialization script which should not be executed as trusted in system lockdown (#8284)\n```\n\n----------------------------------------\n\nTITLE: Use static DateTime.UnixEpoch C#\nDESCRIPTION: This code snippet illustrates the usage of the static DateTime.UnixEpoch property in C# code. This provides a more efficient and standardized way to access the Unix epoch time, improving code readability and maintainability. It reduces redundant calculations and promotes consistent usage of the epoch time.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_9\n\nLANGUAGE: C#\nCODE:\n```\nUse static DateTime.UnixEpoch\n```\n\n----------------------------------------\n\nTITLE: Running ResGen Manually in PowerShell Build Process\nDESCRIPTION: Commands to run the custom ResGen tool manually to generate strongly typed resource access classes from .resx files. This is a preliminary step in the PowerShell build process.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd src/ResGen\ndotnet restore\ndotnet run\n```\n\n----------------------------------------\n\nTITLE: Direct Installation of .NET CLI Using PowerShell\nDESCRIPTION: Demonstrates calling Install-Dotnet directly from the build module to remove previous .NET CLI installations and install the required version for PowerShell Core. Requires module build.psm1 and sufficient permissions. Input: None. Output: Targeted installation of .NET CLI for build compatibility.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/windows-core.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nInstall-Dotnet\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Brotli Compression Test\nDESCRIPTION: An example JSON response returned by the `/Compression/Brotli` endpoint. The content is similar to the `/Get` test response, including origin, headers (potentially including compression-related headers if supported), and the URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_12\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"args\": {},\n  \"origin\": \"127.0.0.1\",\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT; Microsoft Windows 10.0.15063 ; en-US) PowerShell/6.0.0\",\n    \"Host\": \"localhost:8083\"\n  },\n  \"url\": \"http://localhost:8083/Compression/Brotli\"\n}\n```\n\n----------------------------------------\n\nTITLE: Profiling PowerShell Benchmarks with ETW\nDESCRIPTION: Command to profile the benchmarked code and produce an ETW trace file using the dotnet CLI.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/benchmarks/README.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndotnet run -c Release -f net6.0 --filter *script* --profiler ETW\n```\n\n----------------------------------------\n\nTITLE: Collect PowerShell Trace with PerfView (PowerShell)\nDESCRIPTION: Runs the `Invoke-PerfviewPS.ps1` script to collect a performance trace for a specified PowerShell command (`echo 1`), outputting to `perfviewdata.etl`. It then opens the collected `.etl` file using `perfview.exe`. Requires PerfView and the `Invoke-PerfviewPS.ps1` script.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/performance/README.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nInvoke-PerfviewPS.ps1 -scenario { echo 1 }\nperfview .\\perfviewdata.etl\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Delay Test\nDESCRIPTION: An example JSON response returned by the `/Delay` endpoint after the specified delay. It is similar to the `/Get` test response, including origin, headers, and the URL with the delay parameter.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_18\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"args\": {\n  },\n  \"origin\": \"127.0.0.1\",\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT; Windows NT 10.0; en-US) WindowsPowerShell/5.1.15063.608\",\n    \"Host\": \"localhost:8083\"\n  },\n  \"url\": \"http://localhost:8083/Delay/5\"\n}\n```\n\n----------------------------------------\n\nTITLE: Updating .NET package references in PowerShell codebase\nDESCRIPTION: Various references to .NET package version updates, including Microsoft.CodeAnalysis.CSharp, Microsoft.NET.Test.Sdk, and other dependencies used in the PowerShell project.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.3.md#_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n- Update `Microsoft.CodeAnalysis.CSharp` version (#16138)\n- Bump Microsoft.CodeAnalysis.NetAnalyzers (#16070)\n- Update .NET to `6.0.100-rc.1.21458.32` (#16066)\n- Bump `Microsoft.CodeAnalysis.NetAnalyzers` (#16045)\n- Update .NET SDK version from `6.0.100-rc.1.21430.44` to `6.0.100-rc.1.21455.2` (#16041)\n- Bump Microsoft.CodeAnalysis.CSharp from 4.0.0-3.final to 4.0.0-4.21430.4 (#16036)\n- Bump .NET to `6.0.100-rc.1.21430.44` (#16028)\n```\n\n----------------------------------------\n\nTITLE: Building PowerShell Core on Windows (PowerShell)\nDESCRIPTION: Shows the PowerShell commands to install dependencies (`Start-PSBootstrap`) and build PowerShell Core (`Start-PSBuild`) for a specific release tag (e.g., v6.0.0-beta.1) on Windows. Specifies the target runtime (`-Runtime win7-x64`) and ensures a release configuration (`-Configuration Release`).\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/maintainers/releasing.md#_snippet_1\n\nLANGUAGE: powershell\nCODE:\n```\n# Install dependencies\nStart-PSBootstrap -Package\n\n# Build for v6.0.0-beta.1 release targeting Windows universal package, set -Runtime to win7-x64\nStart-PSBuild -Clean -CrossGen -PSModuleRestore -Runtime win7-x64 -Configuration Release -ReleaseTag v6.0.0-beta.1\n```\n\n----------------------------------------\n\nTITLE: Fix ConvertFrom-Json to Handle Arrays with Newlines\nDESCRIPTION: Bug fix allowing `ConvertFrom-Json` to correctly deserialize JSON data that arrives in an array of strings from the pipeline, especially when the JSON string contains newlines, ensuring data integrity.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Using CommandWithArgs Parameter with pwsh\nDESCRIPTION: Demonstrates the new -CommandWithArgs parameter added to pwsh, which allows passing a command with arguments to PowerShell.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n# Example of using the new -CommandWithArgs parameter\npwsh -CommandWithArgs \"Get-Process\" \"-Name\" \"pwsh\"\n\n```\n\n----------------------------------------\n\nTITLE: PowerShell Command Line Options in Documentation\nDESCRIPTION: Command line options for PowerShell that were updated in the documentation, including configuration file options and interactive mode settings.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_17\n\nLANGUAGE: Markdown\nCODE:\n```\nConfigurationFile\n```\n\nLANGUAGE: Markdown\nCODE:\n```\n-NonInteractive\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Autocorrect (Shell)\nDESCRIPTION: Sets the global Git configuration to automatically correct simple command typos (e.g., 'stats' to 'status') after a short delay (-1 value).\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global help.autoCorrect -1\n```\n\n----------------------------------------\n\nTITLE: Add GitCommitId to PowerShell Banner\nDESCRIPTION: Engine update that displays the current Git commit ID in the PowerShell prompt banner, allowing users to quickly identify the core build version without running additional commands. This improves version tracking and troubleshooting.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_5\n\n\n\n----------------------------------------\n\nTITLE: Using Hashtable Tab Completion for Select-Object -Property in PowerShell\nDESCRIPTION: Shows the syntax context where enhanced tab completion for hashtable keys was added. When defining calculated properties for `Select-Object` using `@{ Name=...; Expression=... }`, pressing Tab after `@` or within the hashtable provides completions.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_21\n\nLANGUAGE: PowerShell\nCODE:\n```\nGet-Process | Select-Object -Property @{<tab>\n```\n\n----------------------------------------\n\nTITLE: Running a Specific Pester Test File PowerShell\nDESCRIPTION: This demonstrates how to run a specific Pester test file using `Start-PSPester` and specifying the file's path. This is useful for targeted testing of individual test files.  It requires the `build.psm1` module to be loaded.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/testing-guidelines.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-PSPester -Path test/powershell/engine/Api/XmlAdapter.Tests.ps1\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Client Certificate Details\nDESCRIPTION: An example JSON response from the `/Cert` endpoint when a client certificate is successfully received. It contains details extracted from the certificate, such as status, issuer name, subject name, validity dates, and thumbprint.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_9\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Status\": \"OK\",\n  \"IssuerName\": \"E=randd@adatum.com, CN=adatum.com, OU=R&D, O=A. Datum Corporation, L=Redmond, S=Washington, C=US\",\n  \"SubjectName\": \"E=randd@adatum.com, CN=adatum.com, OU=R&D, O=A. Datum Corporation, L=Redmond, S=Washington, C=US\",\n  \"NotAfter\": \"2044-12-26T12:16:46-06:00\",\n  \"Issuer\": \"E=randd@adatum.com, CN=adatum.com, OU=R&D, O=A. Datum Corporation, L=Redmond, S=Washington, C=US\",\n  \"Subject\": \"E=randd@adatum.com, CN=adatum.com, OU=R&D, O=A. Datum Corporation, L=Redmond, S=Washington, C=US\",\n  \"NotBefore\": \"2017-08-10T13:16:46-05:00\",\n  \"Thumbprint\": \"2DECF1348FF21B780F45D316A039B5EB4C6312F7\"\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Custom Error Messages for Validation Attributes\nDESCRIPTION: Highlights the update to `ValidatePatternAttribute`, `ValidateSetAttribute`, and `ValidateScriptAttribute` allowing developers to specify custom error messages. This enhances user experience by providing more specific feedback when parameter validation fails.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_24\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Conceptual Example in a function parameter\nparam(\n    [ValidatePattern(\"^[a-z]+$\", ErrorMessage = \"Value must contain only lowercase letters.\")]\n    [string]$MyParameter\n)\n```\n\n----------------------------------------\n\nTITLE: Collect PowerShell Trace with WPR (PowerShell)\nDESCRIPTION: Uses `wpr.exe` from the Windows Performance Toolkit to start tracing with a custom profile (`PowerShell.wprp`), executes a simple PowerShell command (`echo 1`), stops the trace to an ETL file (`PowerShellTrace.etl`), and then opens the collected trace in `wpa.exe` with a specific analysis profile (`PowerShell.wpaProfile`). Requires the Windows Performance Toolkit (WPT) and the specified profile files.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/performance/README.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n$PowerShellGitRepo = \"D:\\PowerShell\"\nwpr -start $PowerShellGitRepo\\tools\\performance\\PowerShell.wprp -filemode\npwsh.exe -NoProfile -Command \"echo 1\"\nwpr -stop PowerShellTrace.etl\nwpa -i wpa://.\\PowerShellTrace.etl?profile=$PowerShellGitRepo\\tools\\performance\\PowerShell.wpaProfile\n```\n\n----------------------------------------\n\nTITLE: Finding packages in PowerShell UpdateDotnetRuntime.ps1 script\nDESCRIPTION: Updates to the UpdateDotnetRuntime.ps1 script for handling package sources and ignoring errors from Find-Package cmdlet.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.3.md#_snippet_3\n\nLANGUAGE: markdown\nCODE:\n```\n- Ignore error from `Find-Package` (#15999)\n- Find packages separately for each source in `UpdateDotnetRuntime.ps1` script (#15998)\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for DELETE Method Test\nDESCRIPTION: An example JSON response returned by the `/Delete` endpoint when a DELETE request is received. It confirms the request method was DELETE and includes headers, origin, URL, arguments, and the data sent in the request body.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_20\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"method\": \"DELETE\",\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Microsoft Windows 10.0.15063; en-US) PowerShell/6.0.0\",\n    \"Connection\": \"Keep-Alive\",\n    \"Host\": \"localhost:8083\",\n    \"Content-Length\": \"12\"\n  },\n  \"origin\": \"127.0.0.1\",\n  \"url\": \"http://localhost:8083/Delete\",\n  \"args\": {},\n  \"data\": \"{\\\"id\\\":12345}\"\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell Script for Catalog Testing\nDESCRIPTION: A straightforward PowerShell script that tests the catalog functionality by listing or verifying catalog contents. It requires PowerShell environment and appropriate permissions to access catalog resources. The script's output helps determine if the catalog operates correctly.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/powershell/Modules/Microsoft.PowerShell.Security/TestData/CatalogTestData/TestFileCatalog.txt#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nText File to test catalog\n```\n\n----------------------------------------\n\nTITLE: Running Benchmark Comparison Tool using .NET CLI\nDESCRIPTION: This command executes the benchmark comparison tool, comparing results stored in specified directories (`C:\\results\\windows` and `C:\\results\\ubuntu`). It sets a threshold of 1% for statistical testing and filters the results to show the top 10 differences.  Dependencies include the .NET SDK and the benchmark comparison tool.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/perf/dotnet-tools/ResultsComparer/README.md#_snippet_0\n\nLANGUAGE: cmd\nCODE:\n```\ndotnet run --base \"C:\\results\\windows\" --diff \"C:\\results\\ubuntu\" --threshold 1% --top 10\n```\n\n----------------------------------------\n\nTITLE: Downloading Partial Content in PowerShell\nDESCRIPTION: This PowerShell script simulates a partial download from the `/Resume/Bytes/{NumberBytes}` endpoint. It uses `Invoke-WebRequest` to request a specific number of bytes from the file. The URL is constructed by calling the `Get-WebListenerUrl` function with parameters for the endpoint being tested. The script is testing functionality to retrieve a specific number of bytes (e.g., 5) from the total 20 available and checks that the response's `Content-Length` reflects the partial content.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_29\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Resume' -TestValue 'Bytes/5'\n$response = Invoke-WebRequest -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Starting the UnixSocket Listener in PowerShell\nDESCRIPTION: This snippet demonstrates how to start the UnixSocket listener using the provided PowerShell module. It first imports the 'build.psm1' module, optionally publishes PSTestTools (likely a dependency or setup step), and then executes the 'Start-UnixSocket' cmdlet, storing the listener object in the '$Listener' variable.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/Modules/UnixSocket/README.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\nImport-Module .\\build.psm1\nPublish-PSTestTools\n$Listener = Start-UnixSocket\n```\n\n----------------------------------------\n\nTITLE: Generating Resources using Start-ResGen PowerShell\nDESCRIPTION: This command directly calls the `Start-ResGen` script. It is used to explicitly generate C# bindings for resource files, which is helpful when encountering resource-related compilation errors. It ensures that resources are properly processed and available during the build.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/dev-process/resx-files.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-ResGen\n```\n\n----------------------------------------\n\nTITLE: Viewing Command Help for Coverage Comparison Cmdlets in PowerShell\nDESCRIPTION: This snippet provides commands to access full documentation and parameter usage for the Compare-CodeCoverage and Compare-FileCoverage cmdlets. By running Get-Help with the -Full parameter, users can explore detailed cmdlet usage, prerequisites, and options. Requires that the cmdlets are available and imported from the OpenCover or associated module.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nPS> Get-Help Compare-CodeCoverage -Full\n# Or\nPS> Get-Help Compare-FileCoverage -Full\n```\n\n----------------------------------------\n\nTITLE: Example Output of Pester Execution Order Test\nDESCRIPTION: Shows the console output generated by running the Pester execution order demonstration script. This output clearly visualizes the sequence in which `BeforeAll`, `Context`, `BeforeEach`, `It`, `AfterEach`, `AfterAll`, and free code statements are executed, confirming the behavior explained in the text.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/WritingPesterTests.md#_snippet_8\n\nLANGUAGE: plaintext\nCODE:\n```\nPS# invoke-pester c:\\temp\\pester.demo.tests.ps1\nDescribing it\nIn Describe BeforeAll\nBefore Context\n   Context subsection\nIn Context BeforeAll\nBefore BeforeAll\nAfter BeforeAll\nBefore AfterAll\nAfter AfterAll\nBefore It\nIn BeforeEach\n    [+] should not be a surprise 79ms\nIn AfterEach\nAfter It\nIn Context AfterAll\nAfter Context\nBefore Describe BeforeAll\nIn Describe AfterAll\nTests completed in 79ms\nPassed: 1 Failed: 0 Skipped: 0 Pending: 0\n```\n\n----------------------------------------\n\nTITLE: Examining Code Coverage Data with Get-CodeCoverage in PowerShell\nDESCRIPTION: This snippet demonstrates how to import, store, and examine code coverage data collected by OpenCover, using the Get-CodeCoverage cmdlet from the OpenCover module. Coverage results are stored in the coverage.xml file and loaded into a variable for review. Summary statistics and assembly-level breakdowns are then displayed using object properties and Format-Table. Requires importing the OpenCover module and having generated coverage results as XML. The input is the coverage XML file, and outputs include both summary and per-assembly coverage statistics.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/getting-code-coverage.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Collect the coverage data using Get-CodeCoverage from the OpenCover\n# module that was imported above. This operation is generally expensive\n# to compute, so worth storing in a variable\nPS> $coverageData = Get-CodeCoverage .\\coverage.xml\n\n# Take a look at a summary of the results\nPS> $coverageData.CoverageSummary\n\nNumSequencePoints       : 298237\nVisitedSequencePoints   : 125949\nNumBranchPoints         : 101477\nVisitedBranchPoints     : 39389\nSequenceCoverage        : 42.23\nBranchCoverage          : 38.82\nMaxCyclomaticComplexity : 393\nMinCyclomaticComplexity : 1\nVisitedClasses          : 1990\nNumClasses              : 3187\nVisitedMethods          : 15115\nNumMethods              : 32517\n\n# You can also view results by assembly\nPS> $coverageData.Assembly | Format-Table AssemblyName,Branch,Sequence\n\nAssemblyName                              Branch Sequence\n------------                              ------ --------\npwsh                                      100    100\nMicrosoft.PowerShell.ConsoleHost          21.58  23.32\nSystem.Management.Automation              41.22  45.01\nMicrosoft.PowerShell.CoreCLR.Eventing     1.88   2.03\nMicrosoft.PowerShell.Security             17.32  20.09\nMicrosoft.PowerShell.Commands.Utility     20.14  21.39\nMicrosoft.PowerShell.Commands.Management  43.05  43.39\nMicrosoft.WSMan.Management                52.58  56.98\nMicrosoft.WSMan.Runtime                   80.95  80.33\nMicrosoft.PowerShell.Commands.Diagnostics 0      0\n```\n\n----------------------------------------\n\nTITLE: Referencing PowerShell Components in Build Updates\nDESCRIPTION: Various references to PowerShell components and dependencies that were updated in the build process, including assembly references, version numbers, and package dependencies.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_16\n\nLANGUAGE: Markdown\nCODE:\n```\nMicrosoft.PowerShell.Commands.Utility\n```\n\nLANGUAGE: Markdown\nCODE:\n```\nMicrosoft.PowerShell.Native\n```\n\nLANGUAGE: Markdown\nCODE:\n```\nSystem.Runtime.CompilerServices.Unsafe\n```\n\nLANGUAGE: Markdown\nCODE:\n```\nmetadata.json\n```\n\nLANGUAGE: Markdown\nCODE:\n```\npwsh.deps.json\n```\n\nLANGUAGE: Markdown\nCODE:\n```\npenimc_cor3.dll\n```\n\nLANGUAGE: Markdown\nCODE:\n```\nSecurity.types.ps1xml\n```\n\nLANGUAGE: Markdown\nCODE:\n```\nDotnetRuntimeMetadata.json\n```\n\n----------------------------------------\n\nTITLE: Installing PowerShell Core from Local Copy\nDESCRIPTION: Command for executing the PowerShell installation script from a local copy. This requires first downloading the script to your local system.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/install-powershell.sh-README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash install-powershell.sh <ARGUMENTS>\n```\n\n----------------------------------------\n\nTITLE: Building libpsl-native Unix Binaries with PowerShell\nDESCRIPTION: This PowerShell command snippet shows how to start the build process of native Unix binaries targeting the linux-arm platform using the Start-BuildNativeUnixBinaries function with the -BuildLinuxArm switch. The build process outputs platform-specific native libraries used by PowerShell. This snippet assumes that the build environment has PowerShell core and the appropriate build scripts loaded. The output includes the libpsl-native.so binary placed under src/powershell-unix after a successful build. Dependencies include having the PowerShell build system setup correctly and relevant build tools installed.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\nStart-BuildNativeUnixBinaries -BuildLinuxArm\n```\n\n----------------------------------------\n\nTITLE: Reference to PowerShell MarkdownRender package in build notes\nDESCRIPTION: Reference to the Microsoft.PowerShell.MarkdownRender package that was bumped in a PowerShell release. This appears in a bullet point from the build improvements section.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.2.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\nMicrosoft.PowerShell.MarkdownRender\n```\n\n----------------------------------------\n\nTITLE: StringSplitOptions.TrimEntries C#\nDESCRIPTION: This code snippet highlights the usage of StringSplitOptions.TrimEntries when splitting strings in C#. This simplifies code by automatically trimming whitespace from the resulting substrings, eliminating the need for manual trimming and reducing the risk of errors related to leading or trailing whitespace.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_12\n\nLANGUAGE: C#\nCODE:\n```\nMake use of StringSplitOptions.TrimEntries when possible\n```\n\n----------------------------------------\n\nTITLE: Representing INVALID_HANDLE_VALUE in C# for PowerShell Internals\nDESCRIPTION: Illustrates the correct C# code `IntPtr(-1)` used within PowerShell's source code to represent the `INVALID_HANDLE_VALUE` constant, contrasting it with the incorrect `IntPtr.Zero`. This fix ensures proper handling of invalid file handles.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nIntPtr(-1)\n```\n\n----------------------------------------\n\nTITLE: Install PowerShell package using script\nDESCRIPTION: This shell script installs the PowerShell package on Linux. It's assumed you've cloned the PowerShell repository and are in its root directory.  It sets up the environment for subsequent PowerShell commands.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/linux.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./tools/install-powershell.sh\n\npwsh\n```\n\n----------------------------------------\n\nTITLE: Reference to build.psm1 PowerShell module\nDESCRIPTION: Reference to the build.psm1 module file that was fixed to find the required .NET SDK version when a higher version is installed.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.2.md#_snippet_3\n\nLANGUAGE: plaintext\nCODE:\n```\nbuild.psm1\n```\n\n----------------------------------------\n\nTITLE: Accessing ValidRootDrives from ValidateDriveAttribute via API\nDESCRIPTION: Mentions the addition of the public `ValidRootDrives` property to the `ValidateDriveAttribute` class in the PowerShell API. This allows developers to programmatically discover the allowed drives specified by this validation attribute using reflection or objects like `ParameterMetadata` or `PSVariable`.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\n// Conceptual C# access\nParameterMetadata paramInfo = ...;\nValidateDriveAttribute validateDrive = paramInfo.Attributes.OfType<ValidateDriveAttribute>().FirstOrDefault();\nif (validateDrive != null)\n{\n    string[] validDrives = validateDrive.ValidRootDrives;\n    // Use validDrives\n}\n```\n\n----------------------------------------\n\nTITLE: PowerShell .NET Version Update Reference\nDESCRIPTION: Code snippets showing .NET version references used in PowerShell updates. Includes version numbers for the main .NET SDK update, the crossgen2 tool, and the NJsonSchema package.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.2.md#_snippet_4\n\nLANGUAGE: PowerShell\nCODE:\n```\nv6.0.0-preview.6\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nosx-arm64\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-PSBootstrap\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\ncrossgen2\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\nNJsonSchema\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n10.4.4\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n10.4.5\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\ndotnet-install\n```\n\n----------------------------------------\n\nTITLE: Reference to removed DLL file in PowerShell build\nDESCRIPTION: Reference to a DLL file that should not be removed from the PowerShell build. This appears in a bullet point from the build improvements section.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.2.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npenimc_cor3.dll\n```\n\n----------------------------------------\n\nTITLE: Switching install-powershell.sh to /etc/os-release\nDESCRIPTION: The `install-powershell.sh` script now utilizes `/etc/os-release` instead of `/etc/lsb-release`. This change aims to improve the script's compatibility and information gathering capabilities by leveraging a more modern and standardized system file for operating system identification.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.0.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\nSwitch from `/etc/lsb-release` to `/etc/os-release` in `install-powershell.sh` (#10773) (Thanks @Himura2la!)\n```\n\n----------------------------------------\n\nTITLE: Publishing .NET Core Sample Application - PowerShell\nDESCRIPTION: This command is used to build and publish the sample .NET Core application for distribution. It targets the 'release' configuration and utilizes runtime identifiers specified within the project's .csproj file.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/host-powershell/README.md#_snippet_0\n\nLANGUAGE: powershell\nCODE:\n```\ndotnet publish .\\MyApp --configuration release\n```\n\n----------------------------------------\n\nTITLE: Reference to release tools PowerShell module\nDESCRIPTION: Reference to the releaseTools.psm1 module file that was updated with team member information. This appears in a bullet point from the build improvements section.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.2.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nreleaseTools.psm1\n```\n\n----------------------------------------\n\nTITLE: Running TypeCatalogGen Build Script (Bash)\nDESCRIPTION: Executes the `build.sh` script using the current shell. This script is responsible for running the `TypeCatalogGen.exe` utility under Mono on Linux, utilizing the `dotnet-cli` to identify runtime assemblies. The primary output is the `CorePsTypeCatalog.cs` file.\nSOURCE: https://github.com/powershell/powershell/blob/master/src/TypeCatalogGen/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./build.sh\n```\n\n----------------------------------------\n\nTITLE: Configuring Git Log Output Format (Shell)\nDESCRIPTION: Sets global Git configuration to use abbreviated commit hashes (`log.abbrevCommit true`) and display reference names (like branches/tags) concisely (`log.decorate short`) in log outputs for improved readability.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/README.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global log.abbrevCommit true\n```\n\nLANGUAGE: sh\nCODE:\n```\ngit config --global log.decorate short\n```\n\n----------------------------------------\n\nTITLE: Testing the Module in Windows PowerShell with netstandard.dll\nDESCRIPTION: PowerShell commands to import and test the module in Windows PowerShell after copying the netstandard.dll implementation assembly.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/cmdlet-example/command-line-simple-example.md#_snippet_8\n\nLANGUAGE: powershell\nCODE:\n```\nImport-Module .\\MyModule.dll\nWrite-TimestampedMessage \"Test message.\"\n```\n\n----------------------------------------\n\nTITLE: PowerShell Cmdlets Support Status Table in Markdown\nDESCRIPTION: A markdown table listing PowerShell cmdlets with their delivery status on Linux and Windows platforms, along with test coverage information. The table includes over 200 cmdlets organized alphabetically.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/testing-guidelines/PowerShellCoreTestStatus.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Name | Linux | Windows | Test Coverage |\n|---|---|---|:---:|\n|Get-Acl||delivered||\n|Set-Acl||delivered||\n|Export-Alias|delivered|delivered|yes|\n|Get-Alias|delivered|delivered|adhoc|\n|Import-Alias|delivered|delivered|yes|\n|New-Alias|delivered|delivered|yes|\n|Set-Alias|delivered|delivered|yes|\n|Compress-Archive|delivered|delivered|yes|\n|Expand-Archive|delivered|delivered|yes|\n|Register-ArgumentCompleter|delivered|delivered|yes|\n|Get-AuthenticodeSignature||delivered||\n|Set-AuthenticodeSignature||delivered||\n|Export-BinaryMiLog||delivered||\n|Import-BinaryMiLog||delivered||\n|Get-ChildItem|delivered|delivered|yes|\n|Get-CimAssociatedInstance||delivered||\n|Get-CimClass||delivered|yes|\n|Register-CimIndicationEvent||delivered||\n|Get-CimInstance||delivered||\n|New-CimInstance||delivered||\n|Remove-CimInstance||delivered||\n|Set-CimInstance||delivered||\n|Invoke-CimMethod||delivered||\n|Get-CimSession||delivered||\n|New-CimSession||delivered||\n|Remove-CimSession||delivered||\n|New-CimSessionOption||delivered||\n|Export-Clixml|delivered|delivered|yes|\n|Import-Clixml|delivered|delivered|yes|\n|Find-Command|delivered|delivered|adhoc|\n|Get-Command|delivered|delivered|yes|\n|Invoke-Command|delivered|delivered|yes|\n|Measure-Command|delivered|delivered|yes|\n|Rename-Computer||delivered||\n|Restart-Computer||delivered||\n|Stop-Computer||delivered||\n|Get-ComputerInfo||delivered||\n|Test-Connection||delivered||\n|Add-Content|delivered|delivered|yes|\n|Clear-Content|delivered|delivered|yes|\n|Get-Content|delivered|delivered|yes|\n|Set-Content|delivered|delivered|yes|\n|Get-Credential|delivered|delivered|adhoc|\n|ConvertFrom-Csv|delivered|delivered|yes|\n|ConvertTo-Csv|delivered|delivered|yes|\n|Export-Csv|delivered|delivered|yes|\n|Import-Csv|delivered|delivered|yes|\n|Get-Culture|delivered|delivered|yes|\n|Format-Custom|delivered|delivered|yes|\n|Get-Date|delivered|delivered|yes|\n|Set-Date|delivered|delivered||\n|Write-Debug|delivered|delivered|yes|\n|Wait-Debugger|delivered|delivered||\n|Out-Default|delivered|delivered|adhoc|\n|Find-DscResource|delivered|delivered||\n|Register-EngineEvent|delivered|delivered|yes|\n|Write-Error|delivered|delivered|yes|\n|Get-Event|delivered|delivered|yes|\n|New-Event|delivered|delivered|yes|\n|Remove-Event|delivered|delivered|yes|\n|Unregister-Event|delivered|delivered|yes|\n|Wait-Event|delivered|delivered|yes|\n|Get-EventSubscriber|delivered|delivered|yes|\n|Get-ExecutionPolicy|delivered|delivered|yes|\n|Set-ExecutionPolicy|delivered|delivered|yes|\n|Invoke-Expression|delivered|delivered|yes|\n|Out-File|delivered|delivered|yes|\n|Unblock-File||delivered||\n|New-FileCatalog||delivered|yes|\n|Test-FileCatalog||delivered|yes|\n|Get-FileHash|delivered|delivered|yes|\n|Export-FormatData|delivered|delivered|yes|\n|Get-FormatData|delivered|delivered|yes|\n|Update-FormatData|delivered|delivered|yes|\n|New-Guid|delivered|delivered|yes|\n|Get-Help|delivered|delivered|yes|\n|Save-Help|delivered|delivered|adhoc|\n|Update-Help|delivered|delivered|adhoc|\n|Format-Hex|delivered|delivered|yes|\n|Add-History|delivered|delivered|adhoc|\n|Clear-History|delivered|delivered|adhoc|\n|Get-History|delivered|delivered|adhoc|\n|Invoke-History|delivered|delivered|adhoc|\n|Get-Host|delivered|delivered|yes|\n|Out-Host|delivered|delivered|yes|\n|Read-Host|delivered|delivered|adhoc|\n|Write-Host|delivered|delivered|yes|\n|Write-Information|delivered|delivered|adhoc|\n|Get-InstalledModule|delivered|delivered|yes|\n|Get-InstalledScript|delivered|delivered||\n|Clear-Item|delivered|delivered|adhoc|\n|Copy-Item|delivered|delivered|yes|\n|Get-Item|delivered|delivered|yes|\n|Invoke-Item|delivered|delivered|yes|\n|Move-Item|delivered|delivered|adhoc|\n|New-Item|delivered|delivered|yes|\n|Remove-Item|delivered|delivered|yes|\n|Rename-Item|delivered|delivered|adhoc|\n|Set-Item|delivered|delivered|adhoc|\n|Clear-ItemProperty|delivered|delivered|adhoc|\n|Copy-ItemProperty|delivered|delivered|adhoc|\n|Get-ItemProperty|delivered|delivered|yes|\n|Move-ItemProperty|delivered|delivered||\n|New-ItemProperty|delivered|delivered|adhoc|\n|Remove-ItemProperty|delivered|delivered|adhoc|\n|Rename-ItemProperty|delivered|delivered|adhoc|\n|Set-ItemProperty|delivered|delivered|yes|\n|Get-ItemPropertyValue|delivered|delivered||\n|Debug-Job|delivered|delivered|adhoc|\n|Get-Job|delivered|delivered|adhoc|\n|Receive-Job|delivered|delivered|yes|\n|Remove-Job|delivered|delivered|adhoc|\n|Start-Job|delivered|delivered|yes|\n|Stop-Job|delivered|delivered|adhoc|\n|Wait-Job|delivered|delivered|adhoc|\n|ConvertFrom-Json|delivered|delivered|yes|\n|ConvertTo-Json|delivered|delivered|yes|\n|Format-List|delivered|delivered|yes|\n|Get-LocalGroup||delivered||\n|New-LocalGroup||delivered||\n|Remove-LocalGroup||delivered||\n|Rename-LocalGroup||delivered||\n|Set-LocalGroup||delivered||\n|Add-LocalGroupMember||delivered||\n|Get-LocalGroupMember||delivered||\n|Remove-LocalGroupMember||delivered||\n|Import-LocalizedData|delivered|delivered|yes|\n|Disable-LocalUser||delivered||\n|Enable-LocalUser||delivered||\n|Get-LocalUser||delivered||\n|New-LocalUser||delivered||\n|Remove-LocalUser||delivered||\n|Rename-LocalUser||delivered||\n|Set-LocalUser||delivered||\n|Get-Location|delivered|delivered|yes|\n|Pop-Location|delivered|delivered|yes|\n|Push-Location|delivered|delivered|yes|\n|Set-Location|delivered|delivered|yes|\n|Get-LogProperties||delivered||\n|Set-LogProperties||delivered||\n|Add-Member|delivered|delivered|yes|\n|Get-Member|delivered|delivered|yes|\n|Find-Module|delivered|delivered|adhoc|\n|Get-Module|delivered|delivered|yes|\n|Import-Module|delivered|delivered|yes|\n|Install-Module|delivered|delivered|adhoc|\n|New-Module|delivered|delivered|yes|\n|Publish-Module|delivered|delivered||\n|Remove-Module|delivered|delivered|yes|\n|Save-Module|delivered|delivered|adhoc|\n|Uninstall-Module|delivered|delivered||\n|Update-Module|delivered|delivered||\n|New-ModuleManifest|delivered|delivered|yes|\n|Test-ModuleManifest|delivered|delivered||\n|Update-ModuleManifest|delivered|delivered||\n|Export-ModuleMember|delivered|delivered|yes|\n|Out-Null|delivered|delivered|yes|\n|Compare-Object|delivered|delivered|yes|\n|ForEach-Object|delivered|delivered|yes|\n|Group-Object|delivered|delivered|yes|\n|Measure-Object|delivered|delivered|yes|\n|New-Object|delivered|delivered|yes|\n|Select-Object|delivered|delivered|yes|\n|Sort-Object|delivered|delivered|yes|\n|Tee-Object|delivered|delivered|yes|\n|Where-Object|delivered|delivered|yes|\n|Register-ObjectEvent|delivered|delivered|yes|\n|Write-Output|delivered|delivered|yes|\n|Find-Package|delivered|delivered|yes|\n|Get-Package|delivered|delivered|yes|\n|Install-Package|delivered|delivered|yes|\n|Save-Package|delivered|delivered|yes|\n|Uninstall-Package|delivered|delivered|yes|\n|Find-PackageProvider|delivered|delivered|yes|\n|Get-PackageProvider|delivered|delivered|yes|\n|Import-PackageProvider|delivered|delivered|yes|\n|Install-PackageProvider|delivered|delivered|yes|\n|Get-PackageSource|delivered|delivered|yes|\n|Register-PackageSource|delivered|delivered|yes|\n|Set-PackageSource|delivered|delivered|yes|\n|Unregister-PackageSource|delivered|delivered|yes|\n|Convert-Path|delivered|delivered|adhoc|\n|Join-Path|delivered|delivered|yes|\n|Resolve-Path|delivered|delivered|adhoc|\n|Split-Path|delivered|delivered|yes|\n|Test-Path|delivered|delivered|yes|\n|Import-PowerShellDataFile|delivered|delivered|yes|\n|Debug-Process|delivered|delivered||\n|Get-Process|delivered|delivered|yes|\n|Start-Process|delivered|delivered|yes|\n|Stop-Process|delivered|delivered|yes|\n|Wait-Process|delivered|delivered||\n|Write-Progress|delivered|delivered|yes|\n|Disable-PSBreakpoint|delivered|delivered||\n|Enable-PSBreakpoint|delivered|delivered||\n|Get-PSBreakpoint|delivered|delivered|yes|\n|Remove-PSBreakpoint|delivered|delivered|yes|\n|Set-PSBreakpoint|delivered|delivered|yes|\n|Get-PSCallStack|delivered|delivered|adhoc|\n|Set-PSDebug|delivered|delivered|yes|\n|Get-PSDrive|delivered|delivered|yes|\n|New-PSDrive|delivered|delivered|yes|\n|Remove-PSDrive|delivered|delivered|yes|\n|Enter-PSHostProcess|delivered|delivered|yes|\n|Exit-PSHostProcess|delivered|delivered|yes|\n|Get-PSHostProcessInfo|delivered|delivered|fails on Linux|\n|Get-PSProvider|delivered|delivered|yes|\n|Get-PSReadlineKeyHandler|delivered|delivered|yes|\n|Remove-PSReadlineKeyHandler|delivered|delivered||\n|Set-PSReadlineKeyHandler|delivered|delivered|yes|\n|Get-PSReadlineOption|delivered|delivered|yes|\n|Set-PSReadlineOption|delivered|delivered|yes|\n|Get-PSRepository|delivered|delivered||\n|Register-PSRepository|delivered|delivered||\n|Set-PSRepository|delivered|delivered||\n|Unregister-PSRepository|delivered|delivered||\n|New-PSRoleCapabilityFile|delivered|delivered||\n|Connect-PSSession|delivered|delivered|adhoc|\n|Disconnect-PSSession|delivered|delivered|adhoc|\n|Enter-PSSession|delivered|delivered|adhoc|\n|Exit-PSSession|delivered|delivered|adhoc|\n|Get-PSSession|delivered|delivered|adhoc|\n|New-PSSession|delivered|delivered|yes|\n|Receive-PSSession|delivered|delivered|adhoc|\n|Remove-PSSession|delivered|delivered|yes|\n|Get-PSSessionCapability|delivered|delivered||\n|Disable-PSSessionConfiguration|delivered|delivered||\n|Enable-PSSessionConfiguration|delivered|delivered||\n|Get-PSSessionConfiguration|delivered|delivered||\n|Register-PSSessionConfiguration|delivered|delivered|yes|\n|Set-PSSessionConfiguration|delivered|delivered||\n|Unregister-PSSessionConfiguration|delivered|delivered|yes|\n|New-PSSessionConfigurationFile|delivered|delivered|yes|\n|Test-PSSessionConfigurationFile|delivered|delivered||\n|New-PSSessionOption|delivered|delivered||\n|Disable-PSTrace||delivered||\n|Enable-PSTrace||delivered||\n|New-PSTransportOption|delivered|delivered||\n|Disable-PSWSManCombinedTrace||delivered||\n|Enable-PSWSManCombinedTrace||delivered||\n|Get-Random|delivered|delivered|yes|\n|Invoke-RestMethod|delivered|delivered|yes|\n|Find-RoleCapability|delivered|delivered||\n|Debug-Runspace|delivered|delivered||\n|Get-Runspace|delivered|delivered|yes|\n```\n\n----------------------------------------\n\nTITLE: Example HTML Response for Image Parsing DOS Test\nDESCRIPTION: The beginning of the HTML response returned by the `/Dos?dosType=img` endpoint. This specific output pattern, followed by padding, is designed to potentially exploit a regex vulnerability in the client or server parsing HTML tags.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_22\n\nLANGUAGE: html\nCODE:\n```\n<img\n```\n\n----------------------------------------\n\nTITLE: Breaking Changes in PowerShell 6.2.0-preview.3\nDESCRIPTION: Details of breaking changes in PowerShell 6.2.0-preview.3, including removal of -ListAvailable switch from Get-ExperimentalFeature and modification of Debug parameter behavior to set DebugPreference to Continue instead of Inquire.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.2.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Breaking Changes\n\n# Get-ExperimentalFeature no longer has -ListAvailable switch (#8318)\n# Debug parameter now sets DebugPreference to Continue instead of Inquire (#8195)\n```\n\n----------------------------------------\n\nTITLE: Using Unix Globbing Patterns with Rename-Item in PowerShell\nDESCRIPTION: Highlights the fix enabling `Rename-Item` to correctly process paths containing Unix-style globbing patterns (wildcards) on relevant platforms, allowing for more flexible file renaming operations.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_20\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Conceptual example: Rename files matching a pattern\nRename-Item -Path ./data*.log -NewName { $_.Name -replace '.log','.txt' }\n```\n\n----------------------------------------\n\nTITLE: Accessing Telemetry Data via $PSVersionTable in PowerShell\nDESCRIPTION: Illustrates accessing the OS description and Git commit ID, which are collected for telemetry in PowerShell Core 6.0 Beta 1, using properties of the built-in $PSVersionTable variable. These specific values are sent to help improve PowerShell.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_14\n\nLANGUAGE: PowerShell\nCODE:\n```\n$PSVersionTable.OSDescription\n```\n\nLANGUAGE: PowerShell\nCODE:\n```\n$PSVersionTable.GitCommitId\n```\n\n----------------------------------------\n\nTITLE: Configure Git to use SSH for HTTPS URLs\nDESCRIPTION: This command configures Git to use SSH protocol for HTTPS Git URLs. It instructs Git to replace HTTPS URLs to GitHub with SSH URLs.  This is useful if you prefer to use SSH keys instead of a username and password to authenticate with GitHub over HTTPS.  The command uses the `insteadOf` configuration to rewrite the URLs. The output is the same of the previous code snippet.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/git/basics.md#_snippet_1\n\nLANGUAGE: none\nCODE:\n```\ngit config --global url.git@github.com:.insteadOf https://github.com/\n```\n\n----------------------------------------\n\nTITLE: Testing Brotli Compression in PowerShell\nDESCRIPTION: Shows how to make a request to the endpoint designed to test Brotli compression. It calls the `/Compression/Brotli` endpoint using `Invoke-RestMethod` to retrieve the response, which should be Brotli-compressed if the client supports it.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_11\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Compression' -TestValue 'Brotli'\nInvoke-RestMethod -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Fix Path Length Limit on Unix Platforms\nDESCRIPTION: This fix allows PowerShell Core to handle long file paths exceeding the 260-character limit on Unix systems, improving compatibility and file management in environments with deep directory hierarchies.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_6\n\n\n\n----------------------------------------\n\nTITLE: Testing UTF-8 Encoding Endpoint in PowerShell\nDESCRIPTION: Demonstrates how to make a request to the `/Encoding/Utf8` endpoint. It uses `Invoke-RestMethod` to retrieve content that is specifically encoded using UTF-8.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_25\n\nLANGUAGE: powershell\nCODE:\n```\n$uri = Get-WebListenerUrl -Test 'Encoding' -TestValue 'Utf8'\nInvoke-RestMethod -Uri $uri\n```\n\n----------------------------------------\n\nTITLE: Executing PowerShell Script with Path\nDESCRIPTION: This command executes a PowerShell script (`script.ps1`) after setting the PATH environment variable. The `PATH` is modified to include the absolute path to the PowerShell application base directory. The script assumes that the `/usr/bin/env` utility can execute `runps-file.sh`.  This method allows users to specify the PowerShell executable location or use a custom PowerShell installation to execute the specified script.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/shebang/README.txt#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nPATH=$PATH:/absolute/path/to/powershell/app_base ./script.ps1\n```\n\n----------------------------------------\n\nTITLE: Running Pester Tests for PowerShell Using the Build Module\nDESCRIPTION: This PowerShell code imports the build.psm1 module and invokes Start-PSPester with the UseNuGetOrg parameter to execute the project's cross-platform Pester test suite. Requires that Pester and other test dependencies are available. Input: None. Output: Runs the test suite and reports results.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/windows-core.md#_snippet_3\n\nLANGUAGE: PowerShell\nCODE:\n```\nImport-Module ./build.psm1\nStart-PSPester -UseNuGetOrg\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Deflate Compression Test\nDESCRIPTION: An example JSON response returned by the `/Compression/Deflate` endpoint. The content is similar to the `/Get` test response, including origin, headers (potentially including compression-related headers if supported), and the URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_14\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"args\": {},\n  \"origin\": \"127.0.0.1\",\n  \"headers\": {\n    \"User-Agent\": \"Mozilla/5.0 (Windows NT; Microsoft Windows 10.0.15063 ; en-US) PowerShell/6.0.0\",\n    \"Host\": \"localhost:8083\"\n  },\n  \"url\": \"http://localhost:8083/Compression/Deflate\"\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Negotiate Authentication\nDESCRIPTION: An example JSON response returned by the `/Auth/Negotiate` endpoint. It includes details about the request, such as headers (including the Negotiate Authorization header), origin IP, and the requested URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_5\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"headers\":{\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Microsoft Windows 10.0.15063; en-US) PowerShell/6.0.0\",\n        \"Connection\": \"Keep-Alive\",\n        \"Authorization\": \"Negotiate jjaguasgtisi7tiqkagasjjajvs\",\n        \"Host\": \"localhost:8084\"\n    },\n    \"origin\": \"127.0.0.1\",\n    \"args\": {},\n    \"url\": \"https://localhost:8084/Auth/Negotiate\"\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Basic Authentication\nDESCRIPTION: An example JSON response returned by the `/Auth/Basic` endpoint when a successful Basic authentication header is included in the request. It mirrors the structure of the `/Get` test response, including request headers, origin IP, arguments, and the requested URL.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"headers\":{\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Microsoft Windows 10.0.15063; en-US) PowerShell/6.0.0\",\n        \"Connection\": \"Keep-Alive\",\n        \"Authorization\": \"Basic dGVzdHVzZXI6dGVzdHBhc3N3b3Jk\",\n        \"Host\": \"localhost:8084\"\n    },\n    \"origin\": \"127.0.0.1\",\n    \"args\": {},\n    \"url\": \"https://localhost:8084/Auth/Basic\"\n}\n```\n\n----------------------------------------\n\nTITLE: Example JSON Response for Failed Client Certificate Test\nDESCRIPTION: An example JSON response from the `/Cert` endpoint when no client certificate is provided in the request. It simply indicates that the client certificate status is 'FAILED'.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_10\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"Status\": \"FAILED\"\n}\n```\n\n----------------------------------------\n\nTITLE: Run ClearlyDefined PowerShell Script for Harvesting\nDESCRIPTION: Executes the `ClearlyDefined.ps1` script with the `-Harvest` switch. This mode triggers the data harvesting process within ClearlyDefined for the relevant packages. The script will output the result of the harvest request from the ClearlyDefined service.\nSOURCE: https://github.com/powershell/powershell/blob/master/tools/clearlyDefined/readme.md#_snippet_1\n\nLANGUAGE: PowerShell\nCODE:\n```\n./ClearlyDefined.ps1 -Harvest\n```\n\n----------------------------------------\n\nTITLE: Generating TypeCatalog MSBuild Target File for PowerShell Build\nDESCRIPTION: Shell commands that create a custom MSBuild target file and execute it to generate the powershell.inc file, which contains paths to PowerShell's dependency DLLs for the type catalog.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ntargetFile=\"Microsoft.PowerShell.SDK/obj/Microsoft.PowerShell.SDK.csproj.TypeCatalog.targets\"\ncat > $targetFile <<-\"EOF\"\n<Project>\n    <Target Name=\"_GetDependencies\"\n            DependsOnTargets=\"ResolveAssemblyReferencesDesignTime\">\n        <ItemGroup>\n            <_RefAssemblyPath Include=\"%(_ReferencesFromRAR.HintPath)%3B\"  Condition=\" '%(_ReferencesFromRAR.NuGetPackageId)' != 'Microsoft.Management.Infrastructure' \"/>\n        </ItemGroup>\n        <WriteLinesToFile File=\"$(_DependencyFile)\" Lines=\"@(_RefAssemblyPath)\" Overwrite=\"true\" />\n    </Target>\n</Project>\nEOF\ndotnet msbuild Microsoft.PowerShell.SDK/Microsoft.PowerShell.SDK.csproj /t:_GetDependencies \"/property:DesignTimeBuild=true;_DependencyFile=$(pwd)/TypeCatalogGen/powershell.inc\" /nologo\n```\n\n----------------------------------------\n\nTITLE: Building Native Windows Binaries for PowerShell\nDESCRIPTION: PowerShell command to build the native Windows binaries with specific configuration and architecture settings. This example builds the release flavor targeting arm64 architecture.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/building/internals.md#_snippet_3\n\nLANGUAGE: powershell\nCODE:\n```\nStart-BuildNativeWindowsBinaries -Configuration Release -Arch x64_arm64\n```\n\n----------------------------------------\n\nTITLE: Converting Text Resources to XML Resources in PowerShell\nDESCRIPTION: This command converts `.txt` resource files to `.resx` files using the `Convert-TxtResourceToXml` function. The `-Path` parameter specifies the directory containing the `.txt` files. The resulting `.resx` files are placed in the same directory as the original `.txt` files.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/dev-process/resx-files.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\n# example, converting all .txt resources under src\\Microsoft.WSMan.Management\\resources\nConvert-TxtResourceToXml -Path src\\Microsoft.WSMan.Management\\resources\n```\n\n----------------------------------------\n\nTITLE: Generating Resources using Start-PSBuild PowerShell\nDESCRIPTION: This command calls the `Start-PSBuild` script with the `-ResGen` parameter. It triggers the generation of C# bindings for resource files within the project. This is a common part of the regular build process.\nSOURCE: https://github.com/powershell/powershell/blob/master/docs/dev-process/resx-files.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nStart-PSBuild -ResGen\n```\n\n----------------------------------------\n\nTITLE: Replace string.Join(string) with string.Join(char) C#\nDESCRIPTION: This code snippet demonstrates replacing calls to string.Join(string) with string.Join(char) in C# code. This optimization improves performance by avoiding unnecessary string allocations when joining strings using a single character delimiter.  It results in more efficient memory usage and faster execution.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_11\n\nLANGUAGE: C#\nCODE:\n```\nReplace some `string.Join(string)` calls with `string.Join(char)`\n```\n\n----------------------------------------\n\nTITLE: Replace DllImport with LibraryImport C#\nDESCRIPTION: This code snippet highlights the replacement of DllImport with LibraryImport in C# code. This change modernizes the way external libraries are imported and used within the PowerShell codebase, leveraging the benefits of LibraryImport such as improved type safety and performance.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_8\n\nLANGUAGE: C#\nCODE:\n```\nReplace DllImport with LibraryImport\n```\n\n----------------------------------------\n\nTITLE: LINQ Order() C#\nDESCRIPTION: This snippet shows using LINQ Order() methods instead of OrderBy(static x => x) in C#.  The Order() method provides a more concise and efficient way to sort collections when the sorting criteria is the natural ordering of the elements. This leads to improved code readability and potentially better performance.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nUse new LINQ Order() methods instead of OrderBy(static x => x)\n```\n\n----------------------------------------\n\nTITLE: Use MemoryExtensions.IndexOfAny C#\nDESCRIPTION: This code snippet refers to the usage of MemoryExtensions.IndexOfAny in C# code. This method is used for efficiently searching for multiple characters within a memory region, which can improve performance when parsing strings or other data structures. It is used in areas such as SessionStateInternal and WildcardPattern.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_10\n\nLANGUAGE: C#\nCODE:\n```\nUse MemoryExtensions.IndexOfAny\n```\n\n----------------------------------------\n\nTITLE: UTF8Encoding(false) to Encoding.Default C#\nDESCRIPTION: This snippet shows replacing UTF8Encoding(false) with Encoding.Default in C#. Using Encoding.Default provides better compatibility with the system's default encoding. It adjusts to the system configuration, unlike UTF8Encoding which forces UTF-8 encoding, potentially leading to encoding issues if the system doesn't use UTF-8 as default.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.4.md#_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nReplace `UTF8Encoding(false)` with `Encoding.Default`\n```\n\n----------------------------------------\n\nTITLE: Example HTML Response for Charset Parsing DOS Test\nDESCRIPTION: The beginning of the HTML response returned by the `/Dos?dosType=charset` endpoint. This specific output pattern, followed by padding, is designed to potentially exploit a regex vulnerability related to parsing character set declarations in HTML.\nSOURCE: https://github.com/powershell/powershell/blob/master/test/tools/WebListener/README.md#_snippet_24\n\nLANGUAGE: html\nCODE:\n```\n<meta\n```\n\n----------------------------------------\n\nTITLE: Checking pwsh.exe and pwsh in daily version\nDESCRIPTION: The functionality to check 'pwsh.exe' and 'pwsh' is added in the daily version on Windows. This check is crucial for ensuring the correct version is being used, especially in a development environment, to prevent versioning conflicts and ensure the correct functionality is implemented.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.0.md#_snippet_2\n\nLANGUAGE: PowerShell\nCODE:\n```\nCheck `pwsh.exe` and `pwsh` in daily version on Windows (#10738) (Thanks @centreboard!)\n```\n\n----------------------------------------\n\nTITLE: Fixing Tab Completion for Import-Module -Name\nDESCRIPTION: Mentions a fix for a tab completion bug that previously prevented completing module names when using `Import-Module -N<tab>` (using the alias `-N` for `-Name`).\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/6.0.md#_snippet_28\n\nLANGUAGE: PowerShell\nCODE:\n```\n# Tab completion now works correctly after typing:\nImport-Module -N<tab>\n```\n\n----------------------------------------\n\nTITLE: Remove Unused Script\nDESCRIPTION: This snippet removes the New-DockerTestBuild.ps1 script.  This likely simplifies the codebase and reduces maintenance overhead.  No inputs or outputs are directly visible in the context, but the script's removal may affect Docker-related testing.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.1.md#_snippet_0\n\nLANGUAGE: PowerShell\nCODE:\n```\nRemove unused `New-DockerTestBuild.ps1` (#12610) (Thanks @RDIL!)\n```\n\n----------------------------------------\n\nTITLE: Moving from PkgES to 1ES hosted agents in PowerShell build pipeline\nDESCRIPTION: Reference to migration of CI/CD agents from PkgES to 1ES hosted agents for PowerShell build processes.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.3.md#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n- Move from `PkgES` hosted agents to 1ES hosted agents (#16023)\n```\n\n----------------------------------------\n\nTITLE: Referencing XML code tag in documentation\nDESCRIPTION: A note about changing XML documentation tag from 'snippet' to 'code' in the codebase comments.\nSOURCE: https://github.com/powershell/powershell/blob/master/CHANGELOG/7.3.md#_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n- Change `snippet` tag to `code` tag in XML comments (#16106)\n```"
  }
]