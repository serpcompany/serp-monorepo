[
  {
    "owner": "zmkfirmware",
    "repo": "zmk",
    "content": "TITLE: Key Press Behavior Binding - DTS\nDESCRIPTION: Demonstrates how to bind the 'key press' behavior (`kp`) to a key position in a ZMK keymap file.  The `A` specifies which keycode should be used for that key position. Requires `behaviors.dtsi` and `dt-bindings/zmk/keys.h` includes to resolve the `&kp` and `A` identifiers respectively.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&kp A\n```\n\n----------------------------------------\n\nTITLE: Defining a Combo in ZMK DeviceTree\nDESCRIPTION: This code snippet demonstrates how to define a combo in the ZMK firmware's DeviceTree configuration. It sets the compatible property to \"zmk,combos\", defines the key positions that trigger the combo, sets a timeout, and specifies the resulting binding (in this case, the ESC key).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/combos.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    combos {\n        compatible = \"zmk,combos\";\n        combo_esc {\n            timeout-ms = <50>;\n            key-positions = <0 1>;\n            bindings = <&kp ESC>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Momentary Layer Activation\nDESCRIPTION: This snippet demonstrates how to activate a layer momentarily while a key is held down. The `&mo` behavior is used with a parameter specifying the layer number to enable. In this example, layer 3 (the 4th layer) is activated when the key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&mo 3\n```\n\n----------------------------------------\n\nTITLE: Defining Layer Numbers\nDESCRIPTION: This snippet demonstrates how to define layer numbers using `#define` directives. This allows for more readable and maintainable keymaps, as you can refer to layers by name instead of by their numerical index. It shows an example of defining `DEFAULT`, `LOWER`, and `RAISE` layers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n#define DEFAULT 0\n#define LOWER   1\n#define RAISE   2\n```\n\n----------------------------------------\n\nTITLE: Custom Layer-Tap Behavior Definition\nDESCRIPTION: This example shows how to define a custom layer-tap behavior. It includes the `compatible` property, `#binding-cells`, `flavor`, `tapping-term-ms`, `bindings`, and `display-name` properties. If copied as is, it will overwrite the predefined behavior, so the documentation recommends renaming it. Bindings are specified using momentary-layer and keypress behaviors.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/behaviors.h>\n\n/ {\n    behaviors {\n        lt: layer_tap {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"tap-preferred\";\n            tapping-term-ms = <200>;\n            bindings = <&mo>, <&kp>;\n            display-name = \"Layer-Tap\";\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Grave Escape Mod-Morph Configuration in ZMK\nDESCRIPTION: This snippet configures a mod-morph behavior named `grave_escape`.  When the bound key is pressed alone, it sends the Escape keycode. When pressed with Shift or GUI modifiers held, it sends the Grave keycode.  It defines the compatible type, bindings for the default and modified keycodes, and the modifiers that trigger the modified behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mod-morph.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        gresc: grave_escape {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp ESC>, <&kp GRAVE>;\n            mods = <(MOD_LGUI|MOD_LSFT|MOD_RGUI|MOD_RSFT)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Mod-Tap Behavior Definition\nDESCRIPTION: This example demonstrates how to define a custom mod-tap behavior. It includes the `compatible` property, `#binding-cells`, `flavor`, `tapping-term-ms`, `bindings`, and `display-name` properties.  If copied as is, it will overwrite the predefined behavior, so the documentation recommends renaming it.  Bindings are specified using keypress behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/behaviors.h>\n\n/ {\n    behaviors {\n        mt: mod_tap {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"hold-preferred\";\n            tapping-term-ms = <200>;\n            bindings = <&kp>, <&kp>;\n            display-name = \"Mod-Tap\";\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Defining ZMK Keymap Layers in DTS\nDESCRIPTION: This code defines the keymap structure for ZMK firmware using Devicetree syntax (DTS). It specifies the compatible keymap and defines three layers: 'default_layer' (Base), 'abc', and 'xyz'. Each layer contains key bindings that map physical keys to specific actions like key presses (&kp) and layer switching (&mo).  The '&trans' action represents a transparent key, passing the key press through to the layer below.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymap-example.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        default_layer { // Layer 0\n            display-name = \"Base\";\n// ----------------------------------------------\n// |      Z      |        M       |      K      |\n// |    &mo 1    |   LEFT SHIFT   |    &mo 2    |\n            bindings = <\n                &kp Z    &kp M       &kp K\n                &mo 1    &kp LSHIFT  &mo 2\n            >;\n        };\n        abc { // Layer 1\n            display-name = \"ABC\";\n// ----------------------------------------------\n// |      A      |       B       |       C      |\n// |    &trans   |    &trans     |     &trans   |\n            bindings = <\n                &kp A     &kp B     &kp C\n                &trans    &trans    &trans\n            >;\n        };\n        xyz { // Layer 2\n            display-name = \"XYZ\";\n// ----------------------------------------------\n// |        X       |      Y       |      Z     |\n// |   LEFT CTRL    |  LEFT ALT    |   &trans   |\n            bindings = <\n                &kp X        &kp Y       &kp Z\n                &kp LCTRL    &kp LALT    &trans\n            >;\n        };\n    };\n```\n\n----------------------------------------\n\nTITLE: Pausing Macro Execution Until Release (DTS)\nDESCRIPTION: This code demonstrates the use of `&macro_pause_for_release` to split the execution of a macro between the press and release events. In this example, the macro presses a layer key and LSHIFT on press, and releases them on release. This allows for momentary layer activation combined with a modifier.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\nbindings\n    = <&macro_press &mo 1 &kp LSHFT>\n    , <&macro_pause_for_release>\n    , <&macro_release &mo 1 &kp LSHFT>\n    ;\n```\n\n----------------------------------------\n\nTITLE: Layer-Tap Behavior Binding Example\nDESCRIPTION: This example demonstrates how to bind the `&lt` behavior to a key. When the key is held, layer 3 is activated. When tapped, the SPACE keycode is sent. This assumes that `&lt` is a predefined layer-tap behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&lt 3 SPACE\n```\n\n----------------------------------------\n\nTITLE: Kscan Configuration for Split Keyboard (Right)\nDESCRIPTION: This code snippet configures the column GPIOs for the right half of a split keyboard.  It includes the shared `dtsi` file and overrides the `kscan0` node to define the specific column pins.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n#include \"my_keyboard.dtsi\" // The shared dtsi file is included in the overlay\n\n// Label of the kscan node in the dtsi\n&kscan0 {\n    col-gpios\n        = <&pro_micro 10 GPIO_ACTIVE_HIGH>\n        , <&pro_micro 11 GPIO_ACTIVE_HIGH>\n        , <&pro_micro 13 GPIO_ACTIVE_HIGH>\n        ;\n};\n```\n\n----------------------------------------\n\nTITLE: Mod-Tap Behavior Binding - DTS\nDESCRIPTION: Illustrates how to bind the 'mod-tap' behavior (`mt`) with two parameters: modifier and keycode, to a key position. `LSHIFT` is the modifier used for the \"hold\" behavior, and `D` is the keycode sent when triggering the \"tap\" behavior. Depends on the includes `#include <behaviors.dtsi>` and `#include <dt-bindings/zmk/keys.h>`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&mt LSHIFT D\n```\n\n----------------------------------------\n\nTITLE: Momentary Layer on Hold, Toggle Layer on Tap Example\nDESCRIPTION: This example implements a momentary-layer on hold and a toggle-layer on tap using a C-preprocessor macro and a custom hold-tap behavior. It defines a `MO_TOG(layer)` macro that applies the `&mo` behavior when held and the `&tog` behavior when tapped. It then applies this behavior to specific layers in the keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/keys.h>\n#include <behaviors.dtsi>\n\n#define MO_TOG(layer) &mo_tog layer layer   // Macro to apply momentary-layer-on-hold/toggle-layer-on-tap to a specific layer\n\n/ {\n    behaviors {\n        mo_tog: behavior_mo_tog {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"hold-preferred\";\n            tapping-term-ms = <200>;\n            bindings = <&mo>, <&tog>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                &mo_tog 2 1     // &mo 2 on hold, &tog 1 on tap\n                MO_TOG(3)       // &mo 3 on hold, &tog 3 on tap\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Including RGB Header in Keymap - DTS\nDESCRIPTION: Includes the `dt-bindings/zmk/rgb.h` header in the keymap file. This header provides definitions for RGB actions like `RGB_TOG`, `RGB_HUI`, etc., which can be used to control the RGB underglow. This is a required step to use the provided RGB actions.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/underglow.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/rgb.h>\n```\n\n----------------------------------------\n\nTITLE: Direct GPIO Kscan Devicetree Example\nDESCRIPTION: This is an example devicetree configuration for a direct GPIO keyboard scan using the zmk,kscan-gpio-direct compatible. It configures two input GPIOs with active low and pull-up resistors, enabling them as a wake-up source.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/kscan.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\nkscan0: kscan {\n        compatible = \"zmk,kscan-gpio-direct\";\n        wakeup-source;\n        input-gpios\n            = <&pro_micro 4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n            , <&pro_micro 5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n            ;\n    };\n```\n\n----------------------------------------\n\nTITLE: Overriding per-sensor settings in Devicetree - ZMK\nDESCRIPTION: This code snippet demonstrates how to override settings for individual sensors by adding ordered nested nodes within the `sensors` node in the Devicetree.  This allows for different `triggers-per-rotation` values for each sensor, providing fine-grained control.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/encoders.md#_snippet_1\n\nLANGUAGE: devicetree\nCODE:\n```\n&sensors {\n    left_config {\n        triggers-per-rotation = <18>;\n    };\n\n    right_config {\n        triggers-per-rotation = <24>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Physical Layout with Keys Example in DTS\nDESCRIPTION: Example of a physical layout with the `keys` property defined, suitable for ZMK Studio. It includes width, height, x, y, rotation, rotation x, and rotation y for each key. The example shows a 2x2 macropad layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n#include <physical_layouts.dtsi>\n\n/ {\n    macropad_physical_layout: macropad_physical_layout {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Macro Pad\";\n        transform = <&default_transform>;\n        kscan = <&kscan0>;\n        keys  //                     w   h    x    y     rot    rx    ry\n            = <&key_physical_attrs 100 100    0    0       0     0     0>\n            , <&key_physical_attrs 100 100  100    0       0     0     0>\n            , <&key_physical_attrs 100 100    0  100       0     0     0>\n            , <&key_physical_attrs 100 100  100  100       0     0     0>\n            ;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Macro in ZMK (DTS)\nDESCRIPTION: This code snippet demonstrates how to define a basic macro in a ZMK keymap.  It includes setting the `compatible` property to \"zmk,behavior-macro\" and defining the `bindings` to be executed when the macro is activated.  The macro presses and releases the LSHFT key, and taps Z, M, and K keys.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    macros {\n        zed_em_kay: zed_em_kay {\n            compatible = \"zmk,behavior-macro\";\n            #binding-cells = <0>;\n            bindings\n                = <&macro_press &kp LSHFT>\n                , <&macro_tap &kp Z &kp M &kp K>\n                , <&macro_release &kp LSHFT>\n                ;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kconfig.shield for Split Keyboard\nDESCRIPTION: This snippet demonstrates the `Kconfig.shield` file content for a split keyboard. It defines shield configurations for both left and right halves using `SHIELD_MY_KEYBOARD_LEFT` and `SHIELD_MY_KEYBOARD_RIGHT` and uses `shields_list_contains` to set the flags based on the respective shield names.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_2\n\nLANGUAGE: kconfig\nCODE:\n```\n# No whitespace after the comma or in your part name!\nconfig SHIELD_MY_KEYBOARD_LEFT\n    def_bool $(shields_list_contains,my_keyboard_left)\n\n# No whitespace after the comma or in your part name!\nconfig SHIELD_MY_KEYBOARD_RIGHT\n    def_bool $(shields_list_contains,my_keyboard_right)\n```\n\n----------------------------------------\n\nTITLE: Configuring GPIO Matrix Kscan in Devicetree (DTS)\nDESCRIPTION: This snippet demonstrates how to configure a GPIO matrix keyboard scan using devicetree in ZMK. It defines the compatible, wakeup-source, diode-direction, and GPIO pins for rows and columns. It is compatible with `compatible = \"zmk,kscan-gpio-matrix\"`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/kscan.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n    kscan0: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        wakeup-source;\n        diode-direction = \"col2row\";\n        col-gpios\n            = <&pro_micro 4 GPIO_ACTIVE_HIGH>\n            , <&pro_micro 5 GPIO_ACTIVE_HIGH>\n            ;\n        row-gpios\n            = <&pro_micro 6 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&pro_micro 7 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            ;\n    };\n```\n\n----------------------------------------\n\nTITLE: Layer Definition - DTS\nDESCRIPTION: Illustrates how to define a layer within a keymap node, including its bindings. Includes `bindings` property that maps behavior bindings to each key position. `&kp Z` etc. are the key press behaviors bound to respective keys.  Assumes that `#include <behaviors.dtsi>` and `#include <dt-bindings/zmk/keys.h>` have been used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\nkeymap {\n    compatible = \"zmk,keymap\";\n\n    default_layer { // Layer 0\n        display-name = \"Base\";\n// ----------------------------------------------\n// |     Z     |     M     |     K     |\n// |     A     |     B     |     C     |\n        bindings = <\n            &kp Z    &kp M    &kp K\n            &kp A    &kp B    &kp C\n        >;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Autoshift Hold-Tap Behavior and Keymap Example\nDESCRIPTION: This example demonstrates how to implement Autoshift using a C-preprocessor macro and a custom hold-tap behavior. It defines an `AS(keycode)` macro that applies the `LSHIFT` modifier when held and performs a keypress when tapped.  It defines an `auto_shift` behavior and applies it to the QWERTY keys in the default layer using the `AS()` macro.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/keys.h>\n#include <behaviors.dtsi>\n\n#define AS(keycode) &as LS(keycode) keycode     // Autoshift Macro\n\n/ {\n    behaviors {\n        as: auto_shift {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            tapping_term_ms = <135>;\n            quick_tap_ms = <0>;\n            flavor = \"tap-preferred\";\n            bindings = <&kp>, <&kp>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                AS(Q) AS(W) AS(E) AS(R) AS(T) AS(Y) // Autoshift applied for QWERTY keys\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring SPI for WS2812 on nRF52\nDESCRIPTION: This snippet demonstrates how to configure an SPI interface for a WS2812 LED strip on an nRF52-based board. It includes pinctrl configuration for SPI3, setting up the SPI interface itself, and defining the WS2812 LED strip properties like chain length and color mapping. The example uses P0.06 as the data pin.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/underglow.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/led/led.h>\n\n&pinctrl {\n    spi3_default: spi3_default {\n        group1 {\n            psels = <NRF_PSEL(SPIM_MOSI, 0, 6)>;\n        };\n    };\n\n    spi3_sleep: spi3_sleep {\n        group1 {\n            psels = <NRF_PSEL(SPIM_MOSI, 0, 6)>;\n            low-power-enable;\n        };\n    };\n};\n\n&spi3 {\n    compatible = \"nordic,nrf-spim\";\n    status = \"okay\";\n\n    pinctrl-0 = <&spi3_default>;\n    pinctrl-1 = <&spi3_sleep>;\n    pinctrl-names = \"default\", \"sleep\";\n\n    led_strip: ws2812@0 {\n        compatible = \"worldsemi,ws2812-spi\";\n\n        /* SPI */\n        reg = <0>; /* ignored, but necessary for SPI bindings */\n        spi-max-frequency = <4000000>;\n\n        /* WS2812 */\n        chain-length = <10>; /* number of LEDs */\n        spi-one-frame = <0x70>;\n        spi-zero-frame = <0x40>;\n        color-mapping = <LED_COLOR_ID_GREEN\n                         LED_COLOR_ID_RED\n                         LED_COLOR_ID_BLUE>;\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Encoder Sensor Bindings Configuration\nDESCRIPTION: This code snippet demonstrates how to configure sensor bindings for encoders in ZMK firmware. It defines the `sensor-bindings` property with clockwise (CW) and counter-clockwise (CCW) keycodes.  `BINDING` can be a user-defined behavior or `&inc_dec_kp` for key presses.  The keycodes are activated upon encoder rotation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/encoders.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\nsensor-bindings = <BINDING [CW_KEY] [CCW_KEY]>;\n\n```\n\n----------------------------------------\n\nTITLE: Modifier Definition for Mod-Morph in ZMK\nDESCRIPTION: This snippet demonstrates how to define the modifiers that trigger the morphed behavior of a mod-morph. It specifies the modifiers using a bitwise OR combination.  Available modifiers include Left/Right Shift, Control, Alt, and GUI.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mod-morph.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\nmods = <(MOD_LGUI|MOD_LSFT|MOD_RGUI|MOD_RSFT)>;\n```\n\n----------------------------------------\n\nTITLE: Bootloader Reset Behavior Binding - Devicetree\nDESCRIPTION: This snippet shows how to bind the bootloader reset behavior to a key in the devicetree.  The `&bootloader` reference is used to reset the keyboard and enter bootloader mode, allowing for flashing a new firmware. No parameters are required for this behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/reset.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&bootloader\n```\n\n----------------------------------------\n\nTITLE: Inputting Unicode Sequences in ZMK (Windows)\nDESCRIPTION: This macro demonstrates how to input Unicode characters using ZMK on Windows by sending Alt key codes. Specifically, it shows how to enter the \"£\" symbol. It presses and releases the left Alt key, then taps the number pad keys to input the Alt code sequence.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_12\n\nLANGUAGE: dts\nCODE:\n```\nwait-ms = <40>;\ntap-ms = <40>;\nbindings\n    = <&macro_press   &kp LALT>\n    , <&macro_tap     &kp KP_N0 &kp KP_N1 &kp KP_N6 &kp KP_N3>\n    , <&macro_release &kp LALT>\n    ;\n\n```\n\n----------------------------------------\n\nTITLE: Assigning Kscan and Transform to Physical Layout in DTS\nDESCRIPTION: Shows how to assign a kscan driver and matrix transform to a physical layout.  `kscan` is only necessary if different physical layouts use different kscans.  The `transform` property is required for all layouts. This is done in the keyboard's main DTS file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&physical_layout0 {\n    kscan = <&kscan0>; // Label of the kscan node this layout uses\n    transform = <&default_transform>; // Label of the matrix transform this layout uses\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Keymap - DTS\nDESCRIPTION: This example shows how to define a keymap for a keyboard in ZMK. It includes the necessary header files, sets the compatible string, and defines a default layer with bindings corresponding to the matrix transform. The keymap order must match the matrix transform.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_17\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n#include <dt-bindings/zmk/keys.h>\n\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        default_layer { // Layer 0\n            // -------------------------------------\n            // |     Z     |     M     |     K     |\n            // |     A     |     B     |     C     |\n            // |     D     |     E     |     F     |\n            bindings = <\n                &kp Z    &kp M    &kp K\n                &kp A    &kp B    &kp C\n                &kp D    &kp E    &kp F\n            >;\n        };\n    };\n };\n```\n\n----------------------------------------\n\nTITLE: Configuring I2C0 Pins for nRF52840\nDESCRIPTION: This snippet configures the pins for I2C0 (TWIM) on the nRF52840 for both default and sleep states. It sets P0.7 as SDA and P0.27 as SCL, enabling low-power mode during sleep.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_18\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for i2c0 device, default state */\n    i2c0_default: i2c0_default {\n        group1 {\n            psels = <NRF_PSEL(TWIM_SDA, 0, 7)>, <NRF_PSEL(TWIM_SCL, 0, 27)>;\n        };\n    };\n\n    i2c0_sleep: i2c0_sleep {\n        group1 {\n            psels = <NRF_PSEL(TWIM_SDA, 0, 7)>, <NRF_PSEL(TWIM_SCL, 0, 27)>;\n            low-power-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Mod-Tap Behavior Binding Example\nDESCRIPTION: This example demonstrates how to bind the `&mt` behavior to a key. When the key is held, the LSHIFT keycode is sent. When tapped, the A keycode is sent. This assumes that `&mt` is a predefined mod-tap behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&mt LSHIFT A\n```\n\n----------------------------------------\n\nTITLE: Kconfig.defconfig for Split Keyboard\nDESCRIPTION: This snippet presents the `Kconfig.defconfig` file for a split keyboard. It configures the central side (left) by setting `ZMK_KEYBOARD_NAME` and `ZMK_SPLIT_ROLE_CENTRAL`. It also enables `ZMK_SPLIT` for both left and right sides.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_4\n\nLANGUAGE: kconfig\nCODE:\n```\nif SHIELD_MY_KEYBOARD_LEFT\n\n# Name must be less than 16 characters long!\nconfig ZMK_KEYBOARD_NAME\n    default \"My Keyboard\"\n\nconfig ZMK_SPLIT_ROLE_CENTRAL\n    default y\n\nendif\n\nif SHIELD_MY_KEYBOARD_LEFT || SHIELD_MY_KEYBOARD_RIGHT\n\nconfig ZMK_SPLIT\n    default y\n\nendif\n```\n\n----------------------------------------\n\nTITLE: Enabling hold-while-undecided-linger in ZMK\nDESCRIPTION: This snippet demonstrates how to enable the `hold-while-undecided-linger` option within a ZMK keymap. This feature ensures a smoother transition between hold and tap behaviors when they activate the same modifier, avoiding a double-tap effect.  It requires a `&mt` (hold-tap) node to be defined.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_17\n\nLANGUAGE: dts\nCODE:\n```\n&mt {\n    hold-while-undecided-linger;\n};\n```\n\n----------------------------------------\n\nTITLE: Shift Register SPI Device Configuration in ZMK .overlay\nDESCRIPTION: This Device Tree overlay snippet demonstrates how to configure a shift register as an SPI device within the ZMK firmware.  It defines the compatible device, status, GPIO controller, SPI frequency, register number, GPIO cell count, and the number of GPIOs provided by the shift register. `cs-gpios` is critical for device selection on the SPI bus. `ngpios` should be adjusted based on the number of daisy-chained shift registers (multiples of 8).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/shift-registers.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&xiao_spi {\n    status = \"okay\";\n    cs-gpios = <&xiao_d 9 GPIO_ACTIVE_LOW>;\n    shifter: 595@0 {\n        compatible = \"zmk,gpio-595\";\n        status = \"okay\";\n        gpio-controller;\n        spi-max-frequency = <200000>;\n        reg = <0>;\n        #gpio-cells = <2>;\n        ngpios = <8>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Composing Behaviors in a Macro (DTS)\nDESCRIPTION: This code demonstrates how to compose multiple behaviors within a macro's `bindings`. It includes examples such as switching to a layer (`&to 1`), toggling backlight (`&bl BL_ON`), and outputting keycodes (`&kp`).  Each behavior is executed sequentially when the macro is triggered.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\nbindings\n    = <&to 1>\n    , <&bl BL_ON>\n    , <&kp Z &kp M &kp K &kp EXCLAMATION>\n    ;\n```\n\n----------------------------------------\n\nTITLE: Layer Activation with Modifier Macro (DTS)\nDESCRIPTION: This defines a parameterized macro `lm` (Layer Modifier) that combines layer activation with a modifier key press.  It utilizes `macro_param_1to1` and `macro_param_2to1` to pass layer and keycode parameters. The `macro_pause_for_release` pauses execution until the key is released. This macro can activate a layer and press a modifier at the same time.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\nlm: lm {\n    compatible = \"zmk,behavior-macro-two-param\";\n    wait-ms = <0>;\n    tap-ms = <0>;\n    #binding-cells = <2>;\n    bindings\n        = <&macro_param_1to1>\n        , <&macro_press &mo MACRO_PLACEHOLDER>\n        , <&macro_param_2to1>\n        , <&macro_press &kp MACRO_PLACEHOLDER>\n        , <&macro_pause_for_release>\n        , <&macro_param_2to1>\n        , <&macro_release &kp MACRO_PLACEHOLDER>\n        , <&macro_param_1to1>\n        , <&macro_release &mo MACRO_PLACEHOLDER>\n        ;\n};\n```\n\n----------------------------------------\n\nTITLE: Including backlight definitions in ZMK\nDESCRIPTION: This code snippet demonstrates how to include the `dt-bindings/zmk/backlight.h` header in a ZMK keymap file. This header provides definitions for various backlight actions, such as turning the backlight on or off, toggling it, and adjusting its brightness. Including this header allows the user to reference these actions in their keymap configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/backlight.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n#include <dt-bindings/zmk/backlight.h>\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform - Non-standard Matrix - DTS\nDESCRIPTION: This devicetree overlay shows how to use a matrix transform to correct for a non-standard matrix, such as a duplex matrix. The matrix transform maps the physical rows and columns to the desired key layout. Requires the zmk,matrix-transform compatible node. Defines kscan node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/layout.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &kscan0;\n        zmk,matrix-transform = &default_transform;\n    };\n\n    kscan0: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        // define row-gpios with 12 elements and col-gpios with 8...\n    };\n\n    default_transform: matrix_transform {\n        compatible = \"zmk,matrix-transform\";\n        rows = <6>;\n        columns = <16>;\n        // ESC F1 F2 F3   ...\n        // `   1  2  3    ...\n        // Tab  Q  W  E   ...\n        // Caps  A  S  D  ...\n        // Shift  Z  X  C ...\n        // Ctrl Alt       ...\n        map = <\n            RC(0,0) RC(1,0) RC(0,1) RC(1,1)       // ...\n            RC(2,0) RC(3,0) RC(2,1) RC(3,1)       // ...\n            RC(4,0)   RC(5,0) RC(4,1) RC(5,1)     // ...\n            RC(6,0)     RC(7,0) RC(6,1) RC(7,1)   // ...\n            RC(8,0)       RC(9,0) RC(8,1) RC(9,1) // ...\n            RC(10,0) RC(11,0)                     // ...\n        >;\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Setting Wait Time Between Macro Actions (DTS)\nDESCRIPTION: This snippet shows how to configure the wait time between actions within a macro. The initial wait time can be set with `wait-ms = <value>;`. The wait time can be dynamically changed within the macro's `bindings` using `&macro_wait_time <value>`.  The wait time is in milliseconds.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\nwait-ms = <10>;\nbindings\n    = <&kp F &kp A &kp S &kp T>\n    , <&macro_wait_time 500>\n    , <&kp S &kp L &kp O &kp W>\n    ;\n```\n\n----------------------------------------\n\nTITLE: pinctrl Configuration for I2C in DTS - DTS\nDESCRIPTION: Defines the `pinctrl` configuration for the I2C bus.  The `i2c0_default` and `i2c0_sleep` configurations specify the pin assignments and power settings for the I2C bus in different modes.  This configuration uses `NRF_PSEL` to define the pins, allowing for flexibility in pin configuration and power management.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n       i2c0_default: i2c0_default {\n               group1 {\n                       psels = <NRF_PSEL(TWIM_SDA, 0, 17)>,\n                               <NRF_PSEL(TWIM_SCL, 0, 20)>;\n               };\n       };\n\n       i2c0_sleep: i2c0_sleep {\n               group1 {\n                       psels = <NRF_PSEL(TWIM_SDA, 0, 17)>,\n                               <NRF_PSEL(TWIM_SCL, 0, 20)>;\n                       low-power-enable;\n               };\n       };\n};\n```\n\n----------------------------------------\n\nTITLE: Layer-Tap Configuration Example\nDESCRIPTION: This example demonstrates how to adjust the default `tapping-term-ms` property of the layer-tap behavior. The `tapping-term-ms` property determines how long a key must be pressed to trigger the hold behavior. This example sets it to 200ms.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&lt {\n    tapping-term-ms = <200>; // This is the value already set by default\n};\n```\n\n----------------------------------------\n\nTITLE: Alias Assignment - DTS\nDESCRIPTION: This snippet shows how to create an alias for the `spi0` node using the label `my_alias_spi`. Aliases can provide compatibility with other boards or interconnects and simplify personal use. It provides an alternative name for referencing the same node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\nmy_alias_spi: &spi0 {};\n```\n\n----------------------------------------\n\nTITLE: Overriding general sensor settings in Devicetree - ZMK\nDESCRIPTION: This code snippet shows how to override general settings for sensors, specifically the `triggers-per-rotation`, by updating the exported `sensors` node in the Devicetree. This allows customization of encoder behavior globally.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/encoders.md#_snippet_0\n\nLANGUAGE: devicetree\nCODE:\n```\n&sensors {\n    triggers-per-rotation = <18>;\n};\n```\n\n----------------------------------------\n\nTITLE: Including Physical Layout Definitions - DTS\nDESCRIPTION: This code snippet shows how to include a separate file containing physical layout definitions (e.g., `my_keyboard-layouts.dtsi`) into the main device tree overlay file (`my_keyboard.overlay` or `my_keyboard.dtsi`).  This is recommended for ZMK Studio support.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_13\n\nLANGUAGE: dts\nCODE:\n```\n#include \"my_keyboard-layouts.dtsi\"\n```\n\n----------------------------------------\n\nTITLE: Enabling retro-tap in ZMK\nDESCRIPTION: This snippet demonstrates how to enable the `retro-tap` option within a ZMK keymap. With `retro-tap` enabled, the tap behavior is triggered only when the hold-tap key is released without any other key being pressed in the meantime. The hold behavior is only activated after another key is pressed. It requires a `&mt` (hold-tap) node to be defined.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_18\n\nLANGUAGE: dts\nCODE:\n```\n&mt {\n    retro-tap;\n};\n```\n\n----------------------------------------\n\nTITLE: ZMK Behavior Driver API definition in C\nDESCRIPTION: This C code defines the `behavior_driver_api` struct, which exposes the `parameter_metadata` for the behavior driver when `CONFIG_ZMK_BEHAVIOR_METADATA` is enabled. The `binding_pressed` and `binding_released` functions are also part of this API.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_5\n\nLANGUAGE: c\nCODE:\n```\nstatic const struct behavior_driver_api behavior_bt_driver_api = {\n    .binding_pressed = on_keymap_binding_pressed,\n    .binding_released = on_keymap_binding_released,\n#if IS_ENABLED(CONFIG_ZMK_BEHAVIOR_METADATA)\n    .parameter_metadata = &metadata,\n#endif // IS_ENABLED(CONFIG_ZMK_BEHAVIOR_METADATA)\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Backlight in DTS\nDESCRIPTION: This snippet shows how to define the backlight properties in the Device Tree Source (DTS) file. It includes defining the `pwmleds` node with the `compatible` property and configuring the PWM settings for the LED, including the period and polarity.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    backlight: pwmleds {\n        compatible = \"pwm-leds\";\n        pwm_led_0 {\n            pwms = <&pwm0 0 PWM_MSEC(10) PWM_POLARITY_NORMAL>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Home-Row Mod Left Behavior Definition\nDESCRIPTION: This example shows how to define a custom home-row mod left behavior. It uses the \"balanced\" flavor and defines properties like `require-prior-idle-ms`, `tapping-term-ms`, `quick-tap-ms`, `bindings`, `hold-trigger-key-positions`, and `hold-trigger-on-release`. This snippet requires the `zmk,behavior-hold-tap` compatible property.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        hml: home_row_mod_left {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"balanced\";\n            require-prior-idle-ms = <150>;\n            tapping-term-ms = <280>;\n            quick-tap-ms = <175>;\n            bindings = <&kp>, <&kp>;\n            hold-trigger-key-positions = < ... >; // List of keys on the right side of the keyboard\n            hold-trigger-on-release;\n        };\n        hmr: home_row_mod_right {\n            compatible = \"zmk,behavior-hold-tap\";\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"balanced\";\n            require-prior-idle-ms = <150>;\n            tapping-term-ms = <280>;\n            quick-tap-ms = <175>;\n            bindings = <&kp>, <&kp>;\n            hold-trigger-key-positions = < ... >; // List of keys on the left side of the keyboard\n            hold-trigger-on-release;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Modifying LED Chain Length - Devicetree - DTS\nDESCRIPTION: This snippet modifies the `chain-length` property of the `led_strip` node in the devicetree.  It is used to configure the number of RGB LEDs on each half of a split keyboard.  Adjusting this value is necessary when the default configuration does not match the actual number of LEDs installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/lighting.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&led_strip {\n    chain-length = <21>;\n};\n```\n\n----------------------------------------\n\nTITLE: Wired Split Devicetree Configuration\nDESCRIPTION: This code snippet demonstrates how to configure a wired split keyboard in the devicetree. It defines a `wired_split` node with the compatible string `\"zmk,wired-split\"` and assigns a UART device to it, such as `&pro_micro_serial`. This configuration enables communication between the split keyboard halves via a wired connection.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/split.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    wired_split {\n        compatible = \"zmk,wired-split\";\n        device = <&pro_micro_serial>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Mod-Tap Configuration Example\nDESCRIPTION: This example shows how to adjust the default `tapping-term-ms` property of the mod-tap behavior. The `tapping-term-ms` property determines how long a key must be pressed to trigger the hold behavior. This example sets it to 200ms.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&mt {\n    tapping-term-ms = <200>; // This is the value already set by default\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring a GPIO Key in ZMK\nDESCRIPTION: This code snippet demonstrates how to define a GPIO key in a ZMK firmware device tree source (.dts) file. It configures a \"soft_off_gpio_key\" that triggers when GPIO pin 2 on gpio0 is pulled low, typically by connecting the pin to ground via a switch. The 'GPIO_ACTIVE_LOW' flag indicates that the key is activated when the pin is low, and 'GPIO_PULL_UP' enables an internal pull-up resistor.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_gpio-key-direct.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    keys {\n        compatible = \"gpio-keys\";\n        soft_off_gpio_key: soft_off_gpio_key {\n            gpios = <&gpio0 2 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Encoder in ZMK Devicetree\nDESCRIPTION: This code snippet defines the encoder's properties in the device tree file. It includes the compatible property, GPIO pins for A and B signals, the number of steps, and the initial status.  Replace PIN_A and PIN_B with the appropriate GPIO pin definitions.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/encoders.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\nleft_encoder: encoder_left {\n        compatible = \"alps,ec11\";\n        a-gpios = <PIN_A (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        b-gpios = <PIN_B (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        steps = <80>;\n        status = \"disabled\";\n    };\n```\n\n----------------------------------------\n\nTITLE: Binding for Left Click Mouse Press\nDESCRIPTION: This example shows how to configure a behavior binding to send a left click press when the binding is triggered.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&mkp LCLK\n```\n\n----------------------------------------\n\nTITLE: Configuring Soft Off Hold Time - Devicetree\nDESCRIPTION: This snippet shows how to configure the `hold-time-ms` property for the soft off behavior. Setting this property requires the key to be held for a specified duration (in milliseconds) before the keyboard is turned off. It also shows the location within the keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/soft-off.md#_snippet_1\n\nLANGUAGE: devicetree\nCODE:\n```\n&soft_off {\n    hold-time-ms = <5000>; // Only turn off it the key is held for 5 seconds or longer.\n};\n\n/ {\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Toggling Output Between USB and Bluetooth\nDESCRIPTION: This code snippet demonstrates how to configure a behavior binding to toggle between preferring USB and Bluetooth output.  The `&out` reference indicates the output selection behavior, and `OUT_TOG` specifies that the output should toggle between USB and Bluetooth on each activation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/outputs.md#_snippet_3\n\nLANGUAGE: DTS\nCODE:\n```\n&out OUT_TOG\n```\n\n----------------------------------------\n\nTITLE: Defining a Physical Layout in ZMK - DTS\nDESCRIPTION: This code snippet defines a physical layout for a keyboard in ZMK, including the compatible string, display name, kscan node, and matrix transform. It should be placed in `my_keyboard.overlay` for unibody keyboards or `my_keyboard.dtsi` for splits.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_12\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    physical_layout0: physical_layout_0 { // First physical layout, use different naming for other layouts\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Default Layout\";\n        kscan = <&kscan0>; // Label of the kscan node, optional if all layouts use the same\n        transform = <&default_transform>; // Label of the matrix transform for this layout\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Setting interrupt flavor for hold-tap - DTS\nDESCRIPTION: This example sets the interrupt flavor for a hold-tap behavior to \"balanced\". The 'balanced' flavor triggers the hold behavior only when `tapping-term-ms` has expired or another key is pressed and released while the hold-tap is held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_11\n\nLANGUAGE: DTS\nCODE:\n```\n&mt {\n    flavor = \"balanced\";\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a Wired Split Device - DTS\nDESCRIPTION: This snippet defines a node for wired split keyboard support, specifying the compatible string and the UART device used for communication between the halves.  This should only be included for wired split keyboards. Requires a predefined or pinctrl configured UART.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_16\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    wired_split {\n        compatible = \"zmk,wired-split\";\n        device = <&pro_micro_serial>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Replacing GPIO pin in kscan input-gpios (ZMK DTS)\nDESCRIPTION: This snippet demonstrates how to replace a specific GPIO pin within the `input-gpios` property of the `kscan` node in your `.keymap` file. This example replaces `&pro_micro 6` with `&gpio0 8`, effectively remapping the kscan to use a different pin.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/hardware-issues.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&kscan0 {\n    input-gpios\n        = <&pro_micro 7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        , <&gpio0 8 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        , <&pro_micro 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        ;\n};\n```\n\n----------------------------------------\n\nTITLE: Select Previous Profile - DTS\nDESCRIPTION: This code snippet shows how to switch to the previous Bluetooth profile in the ZMK firmware. The profile selection cycles, returning to the last profile after the first one.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/bluetooth.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&bt BT_PRV\n```\n\n----------------------------------------\n\nTITLE: Devicetree Hold Tap Configuration\nDESCRIPTION: Configures the hold-tap behavior in the devicetree, specifying bindings for hold and tap behaviors, flavor (hold-preferred, balanced, tap-preferred, tap-unless-interrupted), tapping term, quick tap, require prior idle, retro tap, hold while undecided, hold while undecided linger, hold trigger key positions, and hold trigger on release.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_4\n\nLANGUAGE: YAML\nCODE:\n```\n#binding-cells: <2>\nbindings: phandle, phandle\nflavor: \"hold-preferred\"\ntapping-term-ms: int\nquick-tap-ms: int\nrequire-prior-idle-ms: int\netro-tap: bool\nhold-while-undecided: bool\nhold-while-undecided-linger: bool\nhold-trigger-key-positions: array\nhold-trigger-on-release: bool\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Caps Word Instances in DTS\nDESCRIPTION: This snippet demonstrates how to define multiple caps word instances within a Device Tree Source (DTS) file, allowing the usage of different codes to break the caps. The `continue-list` is set to `UNDERSCORE` for this instance.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/caps-word.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    prog_caps: prog_caps {\n        compatible = \"zmk,behavior-caps-word\";\n        #binding-cells = <0>;\n        continue-list = <UNDERSCORE>;\n    };\n\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Basic Physical Layout Definition in DTS\nDESCRIPTION: Defines a basic physical layout with compatible property and display name.  It requires a matrix transform and optionally a kscan driver which are usually defined in the main keyboard configuration file.  This is a minimal layout definition useful as a starting point.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    physical_layout0: physical_layout_0 {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Default Layout\";\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Wakeup Source for Deep Sleep\nDESCRIPTION: This DeviceTree snippet demonstrates how to enable a `kscan` node as a wakeup source for deep sleep in ZMK firmware. Adding the `wakeup-source` property to the `kscan` node allows it to wake the keyboard from deep sleep. It is recommended to add this property even if deep sleep is not currently used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/low-power-states.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        diode-direction = \"col2row\";\n        wakeup-source;\n\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Conditional Layers in ZMK using Device Tree Syntax\nDESCRIPTION: This snippet demonstrates how to configure conditional layers within a ZMK `.keymap` file using Device Tree Syntax (DTS). It defines a conditional layer named `tri_layer` that activates layer 3 when both layers 1 and 2 are active. The `compatible` property indicates that this node is for ZMK conditional layers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/conditional-layers.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    conditional_layers {\n        compatible = \"zmk,conditional-layers\";\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kyria Encoder Configuration Example\nDESCRIPTION: This code snippet provides an example of a complete `sensor-bindings` configuration for a Kyria keyboard with two encoders.  The left encoder is configured to control volume up and down (C_VOL_UP, C_VOL_DN), while the right encoder sends Page Up (PG_UP) or Page Down (PG_DN).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/encoders.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\nsensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN &inc_dec_kp PG_UP PG_DN>;\n\n```\n\n----------------------------------------\n\nTITLE: To Layer Activation\nDESCRIPTION: This snippet shows how to switch to a specific layer, disabling all other layers except the default layer. The `&to` behavior is used with a parameter indicating the layer number to activate. This example switches to layer 3 (the 4th layer).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&to 3\n```\n\n----------------------------------------\n\nTITLE: Keymap - Skipping Unused Positions - DTS\nDESCRIPTION: This devicetree overlay defines a keymap that corresponds to the matrix transform in the previous example. It assigns keycodes to the positions defined in the matrix transform. This allows the keyboard to function with the correct key assignments despite unused positions in the physical matrix. Requires the zmk,keymap compatible node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/layout.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n// numpad.keymap\n/\n{\n    keymap {\n        compatible = \"zmk,keymap\";\n        default {\n            bindings = <\n                &kp KP_NUM &kp KP_DIV &kp KP_MULT &kp KP_MINUS\n                &kp KP_N7  &kp KP_N8  &kp KP_N9   &kp KP_PLUS\n                &kp KP_N4  &kp KP_N5  &kp KP_N6\n                &kp KP_N1  &kp KP_N2  &kp KP_N3   &kp KP_ENTER\n                &kp KP_N0             &kp KP_DOT\n            >;\n        };\n    }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining SPI Pointing Device in Device Tree\nDESCRIPTION: This code snippet demonstrates how to define a pointing device connected via SPI in a ZMK device tree overlay file. It sets the compatible property, SPI parameters, and GPIO pins for the device, specifically for a Cirque Pinnacle glidepoint trackpad.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&pro_micro_spi {\n    status = \"okay\";\n    cs-gpios = <&pro_micro 19 GPIO_ACTIVE_LOW>;\n\n    glidepoint: glidepoint@0 {\n        compatible = \"cirque,pinnacle\";\n        reg = <0>;\n        spi-max-frequency = <1000000>;\n        status = \"okay\";\n        dr-gpios = <&pro_micro 5 (GPIO_ACTIVE_HIGH)>;\n\n        sensitivity = \"4x\";\n        sleep;\n        no-taps;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Tapping Term Configuration Example\nDESCRIPTION: This example shows how to configure the `tapping-term-ms` property for a mod-tap behavior. The `tapping-term-ms` value defines how long a key must be pressed to trigger the \"hold\" behavior. This example sets it to 140ms.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n&mt {\n    tapping-term-ms = <140>;\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Encoder Instance in ZMK Devicetree\nDESCRIPTION: This code snippet enables a specific encoder instance in the devicetree. This should be placed in the .dts or .overlay file and *not* in the shared .dtsi file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/encoders.md#_snippet_3\n\nLANGUAGE: DTS\nCODE:\n```\n&left_encoder {\n    status = \"okay\";\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Soft Off Wakers in DTS\nDESCRIPTION: This code snippet shows how to define the `soft_off_wakers` node in the Device Tree Source (DTS) file. This is necessary for the ZMK soft off process to enable the defined device as part of the soft off procedure so it can wake the keyboard from soft off when pressed. The `wakeup-sources` property points to the devices that should be enabled during shutdown.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/soft-off-setup.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    soft_off_wakers {\n        compatible = \"zmk,soft-off-wakeup-sources\";\n        wakeup-sources = <&wakeup_scan>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Example Matrix Transform Device Tree Node\nDESCRIPTION: Example of a matrix transform node within a device tree file.  It specifies the number of columns and rows, as well as a keymap. This needs to be copied into `my_keyboard_dongle.overlay`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\ndefault_transform: keymap_transform_0 {\n        compatible = \"zmk,matrix-transform\";\n        columns = <14>;\n        rows = <5>;\n\n        map = <\n            // Lots of RC(r,c) macros\n        >;\n    };\n```\n\n----------------------------------------\n\nTITLE: Clear Paired Host - DTS\nDESCRIPTION: This code snippet demonstrates how to clear the paired host for the currently selected Bluetooth profile using the `BT_CLR` command within a keymap. This will remove the bond information between the keyboard and the host.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/bluetooth.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&bt BT_CLR\n```\n\n----------------------------------------\n\nTITLE: Defining a GPIO Key with Devicetree in ZMK\nDESCRIPTION: This snippet shows how to define a GPIO key within the Devicetree in ZMK firmware. It configures a key named 'soft_off_gpio_key' that uses GPIO0 pin 2. The 'GPIO_ACTIVE_HIGH' flag indicates the key is activated when the pin is high, and 'GPIO_PULL_DOWN' enables a pull-down resistor.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_gpio-key-matrix.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keys {\n        compatible = \"gpio-keys\";\n        soft_off_gpio_key: soft_off_gpio_key {\n            gpios = <&gpio0 2 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Set specific backlight brightness in ZMK\nDESCRIPTION: This code snippet shows how to set a specific brightness level for the backlight using the `BL_SET` action. The `&bl` behavior binding is used, with `BL_SET` as the first parameter and the desired brightness level (50 in this example) as the second parameter. This will set the backlight to 50% brightness.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/backlight.md#_snippet_2\n\nLANGUAGE: DTS\nCODE:\n```\n&bl BL_SET 50\n```\n\n----------------------------------------\n\nTITLE: Configure Battery Sensor in Device Tree - DTS\nDESCRIPTION: This snippet demonstrates how to configure a battery sensor using the device tree in ZMK. It adds a `zmk,battery` property to the `chosen` node and references the sensor node, in this case `vbatt`. The sensor node is configured to use the `zmk,battery-nrf-vddh` driver.  This allows ZMK to read the battery voltage and estimate the battery level.  The compatible string tells Zephyr and ZMK what driver to use for this node. Ensure your board supports the nrf-vddh voltage reading.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/battery.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    chosen {\n      zmk,battery = &vbatt;\n    };\n\n    vbatt: vbatt {\n        compatible = \"zmk,battery-nrf-vddh\";\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Keymap Node Definition - DTS\nDESCRIPTION: Explains how to define the keymap node within the root devicetree node. The node needs the property `compatible = \"zmk,keymap\"` to be recognized by ZMK. Layer nodes are nested under this node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\nkeymap {\n    compatible = \"zmk,keymap\";\n\n    // Layer nodes go here!\n};\n```\n\n----------------------------------------\n\nTITLE: Select Next Profile - DTS\nDESCRIPTION: This code snippet shows how to switch to the next available Bluetooth profile in the ZMK firmware. The profile selection cycles, returning to the first profile after the last one.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/bluetooth.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&bt BT_NXT\n```\n\n----------------------------------------\n\nTITLE: Configuring I2C0 Pins for RP2040\nDESCRIPTION: This snippet configures the pins for I2C0 on the RP2040. It uses the rpi-pico-rp2040-pinctrl.h header for pin definitions and sets P4 as SDA and P5 as SCL, enabling input and schmitt trigger on both pins.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_20\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for the i2c0 \"default\" state */\n    i2c0_default: i2c0_default {\n        group1 {\n            pinmux = <I2C0_SDA_P4>, <I2C0_SCL_P5>;\n            input-enable;\n            input-schmitt-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kscan Configuration for Split Keyboard (Left)\nDESCRIPTION: This code snippet configures the column GPIOs for the left half of a split keyboard. It includes the shared `dtsi` file and overrides the `kscan0` node to define the specific column pins.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n#include \"my_keyboard.dtsi\" // The shared dtsi file is included in the overlay\n\n// Label of the kscan node in the dtsi\n&kscan0 {\n    col-gpios\n        = <&pro_micro 19 GPIO_ACTIVE_HIGH>\n        , <&pro_micro 18 GPIO_ACTIVE_HIGH>\n        , <&pro_micro 15 GPIO_ACTIVE_HIGH>\n        ;\n};\n```\n\n----------------------------------------\n\nTITLE: Modifying kscan input-gpios in .keymap (ZMK DTS)\nDESCRIPTION: This snippet shows how to modify the `input-gpios` property within the `kscan` node in your `.keymap` file to remap a broken GPIO pin to a new working pin. This involves changing the pin assignment from the original MCU (e.g., Pro Micro) to a different GPIO pin (e.g., on a nRF MCU).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/hardware-issues.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&kscan0 {\n    input-gpios\n        = <&pro_micro 7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        , <&pro_micro 6 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        , <&pro_micro 9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n        ;\n};\n```\n\n----------------------------------------\n\nTITLE: Keymap Includes - DTS\nDESCRIPTION: Shows the necessary includes for a ZMK keymap file. `#include <behaviors.dtsi>` defines the available behaviors, and `#include <dt-bindings/zmk/keys.h>` provides definitions for keycodes and modifiers. These includes allow referencing the key press behavior with `&kp` and using keycodes like `A` and modifiers like `LSHIFT`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n#include <dt-bindings/zmk/keys.h>\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Tap-Dance Counter in ZMK\nDESCRIPTION: This code snippet defines a basic tap-dance behavior named `td0` that outputs the number of times the key is pressed, from 1 to 3. It utilizes the `zmk,behavior-tap-dance` compatible and sets up bindings for key presses N1, N2, and N3. The `tapping-term-ms` is set to 200ms. The keymap then assigns this tap-dance to a key on the default layer.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/tap-dance.mdx#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n#include <dt-bindings/zmk/keys.h>\n\n/ {\n    behaviors {\n        td0: tap_dance_0 {\n            compatible = \"zmk,behavior-tap-dance\";\n            #binding-cells = <0>;\n            tapping-term-ms = <200>;\n            bindings = <&kp N1>, <&kp N2>, <&kp N3>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        default_layer {\n            bindings = <\n                &td0\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Continue List for Caps Word Behavior in DTS\nDESCRIPTION: This snippet shows how to configure the `continue-list` property within the `&caps_word` behavior in a Device Tree Source (DTS) file.  This overrides the default continue list, specifying which keys will keep caps word active. In this case, UNDERSCORE and MINUS.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/caps-word.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&caps_word {\n    continue-list = <UNDERSCORE MINUS>;\n};\n\n/ {\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Transparent Behavior Binding in ZMK\nDESCRIPTION: This snippet defines the 'transparent' behavior binding in ZMK.  It allows key presses/releases to be passed down to the next active layer. The behavior is referenced by `&trans` and takes no parameters.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/misc.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&trans\n```\n\n----------------------------------------\n\nTITLE: Position Map Definition in DTS\nDESCRIPTION: Defines a position map for transferring keybindings between layouts when switching via ZMK Studio. It specifies the physical layout and corresponding key positions for each layout. Marking the map as `complete` prevents ZMK Studio from automatically inferring bindings for unmapped keys.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    position_map {\n        compatible = \"zmk,physical-layout-position-map\";\n        complete; // Optional, see 'Example non-complete position map'\n        layout1: layout1 {\n            physical-layout = <&physical_layout1>;\n            positions = <...>; // List of positions to map\n        };\n        layout2: layout2 {\n            physical-layout = <&physical_layout2>;\n            positions = <...>; // List of positions to map\n        };\n        // Additional layout child nodes\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Default Encoder Bindings in ZMK Keymap\nDESCRIPTION: This code snippet adds default encoder behavior bindings to the keymap file.  It utilizes `inc_dec_kp` to increment/decrement keypresses (volume up and down in this example)\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/encoders.md#_snippet_4\n\nLANGUAGE: DTS\nCODE:\n```\nsensor-bindings = <&inc_dec_kp C_VOL_UP C_VOL_DN>;\n```\n\n----------------------------------------\n\nTITLE: Using Macro Controls for Activation Modes (DTS)\nDESCRIPTION: This snippet demonstrates the use of macro controls (`&macro_press`, `&macro_tap`, `&macro_release`) to modify the activation mode of bindings within a macro. It shows how to hold a modifier key, tap other keys, and then release the modifier key.  This enables fine-grained control over the execution of macro behaviors.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\nbindings\n    = <&macro_press &kp LSHFT>\n    , <&macro_tap &kp Z &kp M &kp K>\n    , <&macro_release &kp LSHFT>\n    ;\n```\n\n----------------------------------------\n\nTITLE: Activate Sticky Layer in ZMK Device Tree\nDESCRIPTION: This snippet demonstrates how to activate layer 1 as a sticky layer using the `&sl` behavior binding in a ZMK device tree source file. The layer remains active until another key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-layer.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&sl 1\n```\n\n----------------------------------------\n\nTITLE: Binding for Down Mouse Movement\nDESCRIPTION: This example configures a behavior binding to send a down mouse movement event to the host when pressed or held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n&mmv MOVE_DOWN\n```\n\n----------------------------------------\n\nTITLE: Including Layout and Assigning Transform (DTS)\nDESCRIPTION: This snippet demonstrates including a physical layout from a ZMK shared layout file and assigning the matrix transform to it. It is critical to ensure the node label of the physical layout (e.g., `physical_layout0`) is correctly adjusted to match the label used in the included `.dtsi` file.  This snippet also contains the chosen node to select the layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n#include <layouts/<layout_name>.dtsi>\n\n&physical_layout0 {\n    transform = <&default_transform>;\n};\n\n/ {\n    chosen {\n        zmk,kscan = &mock_kscan;\n        zmk,physical-layout = &physical_layout0;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling Encoder in ZMK Configuration\nDESCRIPTION: This code snippet shows the lines to add to the configuration file to enable or disable the encoder functionality in the ZMK firmware. These lines must be uncommented to enable the encoder.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/encoders.md#_snippet_0\n\nLANGUAGE: INI\nCODE:\n```\n# Uncomment to enable encoder\n# CONFIG_EC11=y\n# CONFIG_EC11_TRIGGER_GLOBAL_THREAD=y\n```\n\n----------------------------------------\n\nTITLE: Enabling PIO-based UART Instance for RP2040\nDESCRIPTION: This snippet enables the PIO-based UART instance for RP2040. It sets the status to \"okay\", defines the compatible string, assigns the pin control configuration, and sets the initial baud rate to 115200.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_17\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&pio0 {\n    status = \"okay\";\n\n    pio0_uart: serial {\n        status = \"okay\";\n        compatible = \"raspberrypi,pico-uart-pio\";\n        pinctrl-0 = <&pio0_uart_default>;\n        pinctrl-names = \"default\";\n        current-speed = <115200>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: New I2C bus setup with pinctrl in DTS - DTS\nDESCRIPTION: Demonstrates the new I2C bus setup using the `pinctrl` system in Zephyr. The `pinctrl-0`, `pinctrl-1`, and `pinctrl-names` properties reference the `pinctrl` configuration for the I2C bus.  This allows for unified pin configuration, supporting multiple modes like sleep, and promotes reusability across architectures.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n &i2c0 {\n    compatible = \"nordic,nrf-twi\";\n    pinctrl-0 = <&i2c0_default>;\n    pinctrl-1 = <&i2c0_sleep>;\n    pinctrl-names = \"default\", \"sleep\";\n };\n```\n\n----------------------------------------\n\nTITLE: Adding PWM Device in DTS\nDESCRIPTION: This snippet demonstrates how to add the PWM device to the Device Tree Source (DTS) file and assign the defined pinctrl definitions to it.  This enables the PWM peripheral and configures the pin states for normal operation and sleep modes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&pwm0 {\n    status = \"okay\";\n    pinctrl-0 = <&pwm0_default>;\n    pinctrl-1 = <&pwm0_sleep>;\n    pinctrl-names = \"default\", \"sleep\";\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling RGB Underglow - Kconfig - INI\nDESCRIPTION: This snippet enables the RGB underglow feature and specifies the WS2812 LED strip in the ZMK configuration. It's added to the `.conf` file for your board or shield to activate RGB underglow functionality. This configuration is necessary for controlling RGB LED strips connected to the keyboard.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/lighting.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_RGB_UNDERGLOW=y\n# Use the STRIP config specific to the LEDs you're using\nCONFIG_WS2812_STRIP=y\n```\n\n----------------------------------------\n\nTITLE: Configuring Kscan Composite Driver in Devicetree\nDESCRIPTION: This Devicetree snippet configures a Kscan composite driver to combine a matrix driver and a direct GPIO driver. It defines the number of rows and columns, includes both drivers, and applies a row offset to prevent overlap between the matrix and direct GPIO keys. The kscan composite is assigned as the chosen kscan.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/kscan.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &kscan0;\n    };\n\n    kscan0: kscan_composite {\n        compatible = \"zmk,kscan-composite\";\n        rows = <4>;\n        columns = <3>;\n\n        // Include the matrix driver\n        matrix {\n            kscan = <&kscan1>;\n        };\n\n        // Include the direct GPIO driver...\n        direct {\n            kscan = <&kscan2>;\n            row-offset = <3>; // ...and shift it to not overlap\n        };\n    };\n\n    kscan1: kscan_matrix {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        // define 3x3 matrix here...\n    };\n\n    kscan2: kscan_direct {\n        compatible = \"zmk,kscan-gpio-direct\";\n        // define 2 direct GPIOs here...\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Adjusting Cradio Pin Arrangement in DTS\nDESCRIPTION: This DTS code snippet demonstrates how to adjust the pin arrangement for a Cradio keyboard in the keymap file. It reorders the `input-gpio` definition within the `&kscan0` block to swap the positions of the Q and B keys.  The code configures GPIO pins on the `pro_micro` controller with `GPIO_ACTIVE_LOW` and `GPIO_PULL_UP` settings.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/cradio/README.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/* Adjusted Cradio pin arrangement */\n/* The position of Q and B keys have been swapped */\n&kscan0 {\n    input-gpios\n    = <&pro_micro  6 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 18 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 19 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 20 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 21 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 15 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 14 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 16 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro 10 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  2 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  3 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  4 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  5 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  7 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  8 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    , <&pro_micro  9 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    ;\n};\n```\n\n----------------------------------------\n\nTITLE: Select Specific Profile - DTS\nDESCRIPTION: This code snippet demonstrates how to select a specific Bluetooth profile using the `BT_SEL` command and a profile number. Note that profile numbering is zero-based, so `1` selects the second profile.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/bluetooth.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n&bt BT_SEL 1\n```\n\n----------------------------------------\n\nTITLE: Using Shift Register Pins in Kscan Configuration\nDESCRIPTION: This snippet shows how to configure the keyboard scan matrix (`kscan`) to use pins from the shift register. It defines a `kscan` node with `compatible = \"zmk,kscan-gpio-matrix\"` and specifies the `col-gpios` using the `&shifter X` syntax, where `X` is the pin number on the shift register. The diode direction and GPIO active state must be configured according to the physical wiring of the keyboard matrix.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/shift-registers.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\nkscan0: kscan_0 {\n    compatible = \"zmk,kscan-gpio-matrix\";\n    diode-direction = \"col2row\";\n    col-gpios\n        = <&shifter 7 GPIO_ACTIVE_HIGH>\n        , <&shifter 6 GPIO_ACTIVE_HIGH>\n        , <&shifter 5 GPIO_ACTIVE_HIGH>\n        , <&shifter 4 GPIO_ACTIVE_HIGH>\n        , <&shifter 3 GPIO_ACTIVE_HIGH>\n        , <&shifter 2 GPIO_ACTIVE_HIGH>\n    ;\n};\n```\n\n----------------------------------------\n\nTITLE: Binding a Macro to a Keymap Layer (DTS)\nDESCRIPTION: This snippet illustrates how to bind a previously defined macro to a specific layer in a ZMK keymap. It references the macro by its node label (`&zed_em_kay`) within the `bindings` of a layer definition.  The macro will be triggered when the bound key is pressed on the specified layer.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\nraise_layer {\n        bindings = <&zed_em_kay>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Pinctrl Node Modification - DTS\nDESCRIPTION: This snippet demonstrates how to modify the `pinctrl` node in a DTS file to configure pin control settings. The changes are applied within the `pinctrl` node, allowing for customization of pin configurations. This is the starting point for configuring pin control.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* your modifications go here */\n};\n```\n\n----------------------------------------\n\nTITLE: Example Metadata File\nDESCRIPTION: Example of a `corne.zmk.yml` file demonstrating the structure and properties of a ZMK hardware metadata file. It showcases the `file_format`, `id`, `name`, `type`, `url`, `requires`, `exposes`, `features`, and `siblings` properties.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nfile_format: \"1\"\nid: corne\nname: Corne\ntype: shield\nurl: https://github.com/foostan/crkbd/\nrequires:\n  - pro_micro\nexposes:\n  - i2c_oled\nfeatures:\n  - keys\n  - display\nsiblings:\n  - corne_left\n  - corne_right\n```\n\n----------------------------------------\n\nTITLE: Position Map for Macropad with 4x5 Layout - DTS\nDESCRIPTION: This code defines a position map for a 4x5 macropad layout. The `positions` array lists the positions for each key, arranged in a grid-like format for readability. The `physical-layout` property references the corresponding physical layout node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_10\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map {\n        // Other properties\n\n        macropad_map: macropad {\n            physical-layout = <&macropad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10 11>\n                , <12 13 14 15>\n                , <16 17 18 19>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Modifying Devicetree Property (DTS)\nDESCRIPTION: Shows how to modify an existing Devicetree property by referencing its label, changing the `debounce-press-ms` property of the `kscan0` node to 0.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&kscan0 {\n    debounce-press-ms = <0>;\n};\n```\n\n----------------------------------------\n\nTITLE: Grave Escape Behavior Binding in ZMK\nDESCRIPTION: This snippet shows how to use the pre-configured `&gresc` (grave escape) behavior in a key binding.  No parameters are required for this specific behavior. This makes it easily reusable in keymaps.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mod-morph.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&gresc\n```\n\n----------------------------------------\n\nTITLE: Setting the Chosen Node for Physical Layout - DTS\nDESCRIPTION: This snippet sets the `zmk,physical-layout` property of the `chosen` node to point to a specific physical layout.  This designates the default physical layout. It is generally placed in the `my_keyboard.overlay` or `my_keyboard.dtsi` file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_14\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,physical-layout = &physical_layout0;\n        // Other chosen items\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: SPI Device Configuration - DTS\nDESCRIPTION: This snippet shows how to configure SPI devices as child nodes within the `spi0` bus node. It sets the `compatible` property, defines the `reg` property for chip select, and sets the `spi-max-frequency` property. It also defines `cs-gpios`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_10\n\nLANGUAGE: dts\nCODE:\n```\n&spi0 {\n    cs-gpios = <&gpio0 15 GPIO_ACTIVE_LOW>, <&gpio0 17 GPIO_ACTIVE_LOW>;\n    device1: device@0 {\n        compatible = \"manufacturer,device\";\n        reg = <0>;\n        spi-max-frequency = <1000000>; /* conservatively set to 1MHz */\n    };\n    device2: device@1 {\n        compatible = \"manufacturer,device\";\n        reg = <1>;\n        spi-max-frequency = <1000000>; /* conservatively set to 1MHz */\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Key Toggle Behavior Binding Example (DTS)\nDESCRIPTION: This code snippet demonstrates how to bind the key toggle behavior (`&kt`) to a specific keycode, in this case, the left Alt key (`LALT`). When the behavior is activated, it will toggle the press state of the LALT key.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-toggle.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&kt LALT\n```\n\n----------------------------------------\n\nTITLE: Kscan Configuration for Unibody Keyboard\nDESCRIPTION: This code snippet demonstrates a Kscan configuration for a simple 3x3 macropad matrix on a unibody keyboard. It defines the GPIO pins used for scanning key presses and releases, specifying the diode direction and wakeup source.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan0: kscan0 {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        diode-direction = \"col2row\";\n        wakeup-source;\n\n        col-gpios\n            = <&pro_micro 15 GPIO_ACTIVE_HIGH>\n            , <&pro_micro 14 GPIO_ACTIVE_HIGH>\n            , <&pro_micro 16 GPIO_ACTIVE_HIGH>\n            ;\n\n        row-gpios\n            = <&pro_micro 19 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&pro_micro 20 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&pro_micro 21 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            ;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Include Bluetooth Binding Header - DTS\nDESCRIPTION: This code snippet demonstrates how to include the Bluetooth binding header file in a Device Tree Source (DTS) file. This header provides definitions for Bluetooth-related actions like clearing bonds (BT_CLR).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/bluetooth.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/bt.h>\n```\n\n----------------------------------------\n\nTITLE: Configuring SPI via PIO for WS2812 on RP2040\nDESCRIPTION: This snippet illustrates setting up an SPI interface using PIO (Programmable I/O) for a WS2812 LED strip on a sparkfun_pro_micro_rp2040 board. It includes pinctrl configuration for PIO0, defining the PIO instance with clock and GPIO settings, and configuring the WS2812 LED strip properties. The example uses GP0 as the data pin.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/underglow.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/led/led.h>\n\n&pinctrl {\n    pio0_spi0_default: pio0_spi0_default {\n        group1 {\n            pinmux = <PIO0_P0>;\n        };\n    };\n};\n\n&pio0 {\n    status = \"okay\";\n\n    pio0_spi0: pio0_spi0 {\n        pinctrl-0 = <&pio0_spi0_default>;\n        pinctrl-names = \"default\";\n\n        compatible = \"raspberrypi,pico-spi-pio\";\n        #address-cells = <1>;\n        #size-cells = <0>;\n        clocks = <&system_clk>;\n        clock-frequency = <4000000>;\n\n        clk-gpios = <&gpio0 10 GPIO_ACTIVE_HIGH>;     /* Must be defined. Select a pin that is not used elsewhere. */\n        mosi-gpios = <&pro_micro 1 GPIO_ACTIVE_HIGH>; /* Data In pin. */\n        miso-gpios = <&pro_micro 1 GPIO_ACTIVE_HIGH>; /* Must be defined. Re-using the DI pin is OK for WS2812. */\n\n        led_strip: ws2812@0 {\n            compatible = \"worldsemi,ws2812-spi\";\n\n            /* SPI */\n            reg = <0>; /* ignored, but necessary for SPI bindings */\n            spi-max-frequency = <4000000>;\n\n            /* WS2812 */\n            chain-length = <10>; /* number of LEDs */\n            spi-one-frame = <0x70>;\n            spi-zero-frame = <0x40>;\n            color-mapping = <LED_COLOR_ID_GREEN\n                             LED_COLOR_ID_RED\n                             LED_COLOR_ID_BLUE>;\n        };\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Adding Encoders to Sensors List in ZMK Devicetree\nDESCRIPTION: This code snippet adds the defined encoders to the list of sensors in the device tree file. The order in which the encoders are added here determines the order in which their behavior is defined in the keymap. The `triggers-per-rotation` property sets the default number of triggers per rotation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/encoders.md#_snippet_2\n\nLANGUAGE: DTS\nCODE:\n```\nsensors: sensors {\n        compatible = \"zmk,keymap-sensors\";\n        sensors = <&left_encoder &right_encoder>;\n        triggers-per-rotation = <20>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Enabling EC11 Encoders in ZMK\nDESCRIPTION: These configurations enable EC11 rotary encoders in the ZMK firmware.  `CONFIG_EC11` enables the encoder driver, and `CONFIG_EC11_TRIGGER_GLOBAL_THREAD` configures the trigger to run in the global thread context.  These lines need to be added to your `prj.conf` file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/bdn9/README.md#_snippet_1\n\nLANGUAGE: kconfig\nCODE:\n```\nCONFIG_EC11=y\nCONFIG_EC11_TRIGGER_GLOBAL_THREAD=y\n```\n\n----------------------------------------\n\nTITLE: Enabling UART0 Instance for nRF52840\nDESCRIPTION: This snippet enables the UART0 instance in the main device tree file. It includes the pin control configuration defined in the pinctrl file and assigns the \"default\" name to the configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_13\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&uart0 {\n    pinctrl-0 = <&uart0_default>;\n    pinctrl-names = \"default\";\n};\n```\n\n----------------------------------------\n\nTITLE: Hold-tap configuration example with node labels - DTS\nDESCRIPTION: This configures a hold-tap behavior. It maps the 'caps' node label to a keycode on hold and the 'caps_word' behavior on tap. A dummy parameter '0' is passed, as the behaviors accept no parameters.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_10\n\nLANGUAGE: DTS\nCODE:\n```\n&caps CAPS 0\n```\n\n----------------------------------------\n\nTITLE: Importing Physical Layout and Assigning Transform (DTS)\nDESCRIPTION: This code snippet demonstrates how to import a physical layout file, assign a matrix transform to it, and select it in the `chosen` node of a device tree source file.  It assumes a physical layout defined in `my_keyboard-layouts.dtsi`. The `physical_layout0` and `default_transform` labels should match the definition in the imported file and the matrix transform node respectively.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n#import \"my_keyboard-layouts.dtsi\"\n\n&physical_layout0 {\n    transform = <&default_transform>;\n};\n\n/ {\n    chosen {\n        zmk,kscan = &mock_kscan;\n        zmk,physical-layout = &physical_layout0;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating and activating a Python virtual environment\nDESCRIPTION: Creates a new Python 3 virtual environment named `.venv` and activates it.  Subsequent commands will operate within this environment. The second code block activates the venv in a shell.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m venv .venv\n```\n\nLANGUAGE: sh\nCODE:\n```\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Include External Power Header - DTS\nDESCRIPTION: This code snippet includes the `dt-bindings/zmk/ext_power.h` header file in a DTS (Device Tree Source) file. This header provides definitions for external power control commands such as `EXT_POWER_OFF_CMD`, `EXT_POWER_ON_CMD`, and `EXT_POWER_TOGGLE_CMD` that can be used in keymap configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/power.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/ext_power.h>\n```\n\n----------------------------------------\n\nTITLE: Adding Input Listener to Device Tree\nDESCRIPTION: This code snippet shows how to add an input listener to the device tree, which is necessary to process events from the pointing device and send them to the host. The listener is assigned to the specified device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    glidepoint_listener {\n        compatible = \"zmk,input-listener\";\n        device = <&glidepoint>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Backlight to Chosen Node in DTS\nDESCRIPTION: This snippet shows how to add the backlight node to the chosen node in the root of the Device Tree Source (DTS) file. This step associates the backlight definition with the ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,backlight = &backlight;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Adding Input Processor to Listener\nDESCRIPTION: This code snippet demonstrates how to add an input processor to the input listener. In this specific example, it inverts and swaps the X/Y axes using `zip_xy_transform`. This is useful for adjusting the input from pointing devices that may be physically rotated or have other orientation issues.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/input_transform.h>\n\n/ {\n    glidepoint_listener {\n        compatible = \"zmk,input-listener\";\n        device = <&glidepoint>;\n        input-processors = <&zip_xy_transform (INPUT_TRANSFORM_XY_SWAP | INPUT_TRANSFORM_X_INVERT | INPUT_TRANSFORM_Y_INVERT)>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling hold-while-undecided for hold-tap - DTS\nDESCRIPTION: This enables the `hold-while-undecided` property for a hold-tap behavior. When enabled, the hold behavior will immediately be held on hold-tap press and will release before the behavior is sent if it resolves to a tap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_16\n\nLANGUAGE: DTS\nCODE:\n```\n&mt {\n    hold-while-undecided;\n};\n```\n\n----------------------------------------\n\nTITLE: Toggle RGB Underglow - DTS\nDESCRIPTION: This snippet demonstrates how to bind the `RGB_TOG` action to a key, allowing the user to toggle the RGB underglow on and off.  It utilizes the `&rgb_ug` behavior binding, referencing the RGB underglow.  No specific dependencies beyond the included header are needed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/underglow.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&rgb_ug RGB_TOG\n```\n\n----------------------------------------\n\nTITLE: Layer-Specific Input Processor Override in DTS\nDESCRIPTION: This snippet shows how to define a layer-specific override for the input processors. When layer `1` is active, the trackpad will use the `zip_xy_to_scroll_mapper` processor instead of the base processor.  The `input/processors.dtsi` file must be included.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/usage.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n#include <input/processors.dtsi>\n\n&trackpad_listener {\n    input-processors = <&zip_xy_scaler 3 2>;\n\n    scroller {\n        layers = <1>;\n        input-processors = <&zip_xy_to_scroll_mapper>;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Adding XIAO Tester Build to build.yaml (ZMK)\nDESCRIPTION: This snippet demonstrates how to add a tester build configuration for a Seeed Studio XIAO-compatible board to the `build.yaml` file in your `zmk-config` folder. This creates a firmware for testing GPIO pins using the XIAO tester shield.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/hardware-issues.mdx#_snippet_1\n\nLANGUAGE: yml\nCODE:\n```\ninclude:\n  # -------------------\n  # Your keyboards here\n  # -------------------\n  - board: seeeduino_xiao_ble # Replace with the Xiao-compatible board you're using\n    shield: tester_xiao\n```\n\n----------------------------------------\n\nTITLE: Initializing and updating west\nDESCRIPTION: Initializes the `west` tool and updates the project to fetch necessary modules, including Zephyr.  Requires `west` to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nwest init -l app/\n```\n\nLANGUAGE: sh\nCODE:\n```\nwest update\n```\n\n----------------------------------------\n\nTITLE: Sticky Key Behavior Devicetree Binding\nDESCRIPTION: Describes the device tree binding for the `zmk,behavior-sticky-key` compatible. It details properties such as `#binding-cells`, `bindings` (phandles), `release-after-ms`, `quick-release`, `lazy`, and `ignore-modifiers` to configure the sticky key behavior. It forwards one parameter it receives to the parameter of the behavior specified in `bindings`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Essential Components of a New Driver in C\nDESCRIPTION: This code snippet outlines the basic structure of a new driver file for a ZMK behavior, written in C. It includes defining `DT_DRV_COMPAT`, necessary dependencies (device.h, drivers/behavior.h, logging/log.h, zmk/behavior.h), optional data and config structs, an optional initialization function, an API structure, and the behavior definition using `BEHAVIOR_DT_INST_DEFINE`. The behavior driver file is located at `app/src/behaviors/behavior_<behavior_name>.c`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n#define DT_DRV_COMPAT zmk_<behavior_name>\n\n// Dependencies\n#include <zephyr/device.h>\n#include <drivers/behavior.h>\n#include <zephyr/logging/log.h>\n\n#include <zmk/behavior.h>\n\nLOG_MODULE_DECLARE(zmk, CONFIG_ZMK_LOG_LEVEL);\n\n#if DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT)\n\n// Instance-Unique Data Struct (Optional)\nstruct behavior_<behavior_name>_data {\n    bool example_data_param1;\n    bool example_data_param2;\n    bool example_data_param3;\n};\n\n// Instance-Unique Config Struct (Optional)\nstruct behavior_<behavior_name>_config {\n    bool example_config_param1;\n    bool example_config_param2;\n    bool example_config_param3;\n};\n\n// Initialization Function (Optional)\nstatic int <behavior_name>_init(const struct device *dev) {\n    return 0;\n};\n\n// API Structure\nstatic const struct behavior_driver_api <behavior_name>_driver_api = {\n\n};\n\nBEHAVIOR_DT_INST_DEFINE(0,                                                    // Instance Number (Equal to 0 for behaviors that don't require multiple instances,\n                                                                              //                  Equal to n for behaviors that do make use of multiple instances)\n                        <behavior_name>_init, NULL,                           // Initialization Function, Power Management Device Pointer (Both Optional)\n                        &<behavior_name>_data, &<behavior_name>_config,       // Behavior Data Pointer, Behavior Configuration Pointer (Both Optional)\n                        POST_KERNEL, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,     // Initialization Level, Device Priority\n                        &<behavior_name>_driver_api);                         // API Structure\n\n#endif /* DT_HAS_COMPAT_STATUS_OKAY(DT_DRV_COMPAT) */\n```\n\n----------------------------------------\n\nTITLE: Enable USB Logging via west build - Shell\nDESCRIPTION: This snippet demonstrates how to enable USB logging when building ZMK firmware locally using the `west build` command. The `-S` or `--snippet` flag is used to include the `zmk-usb-logging` snippet during the build process. This allows developers to capture and analyze debug output during development.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b nice_nano_v2 -S zmk-usb-logging -- -DSHIELD=\"corne_left\"\n```\n\n----------------------------------------\n\nTITLE: Devicetree Binding Example in YAML\nDESCRIPTION: This snippet shows an example of a devicetree binding YAML file for a hold-tap behavior in ZMK. It defines the compatible string, includes a parameter definition file, and specifies properties such as bindings, tapping-term-ms, flavor, and retro-tap. This file is located at `app/dts/bindings/behaviors/zmk,behavior-hold-tap.yaml`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n# Copyright (c) 2020 The ZMK Contributors\n# SPDX-License-Identifier: MIT\n\n// highlight-next-line\ndescription: Hold or Tap behavior\n\n// highlight-next-line\ncompatible: \"zmk,behavior-hold-tap\"\n\n// highlight-next-line\ninclude: two_param.yaml\n\n// highlight-next-line\nproperties:\n  bindings:\n    type: phandles\n    required: true\n  tapping-term-ms:\n    type: int\n  tapping_term_ms: # deprecated\n    type: int\n  quick-tap-ms:\n    type: int\n    default: -1\n  quick_tap_ms: # deprecated\n    type: int\n  flavor:\n    type: string\n    required: false\n    default: \"hold-preferred\"\n    enum:\n      - \"hold-preferred\"\n      - \"balanced\"\n      - \"tap-preferred\"\n      - \"tap-unless-interrupted\"\n  retro-tap:\n    type: boolean\n  hold-trigger-key-positions:\n    type: array\n    required: false\n    default: []\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Physical Layouts in DTS\nDESCRIPTION: Defines multiple physical layouts, useful when a keyboard has configurable physical arrangements (e.g., removable columns). It includes definitions for different layouts, each with its own transform, kscan, and optional keys property. `physical_layouts.dtsi` is needed only if the `keys` property is used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n// Needed if and only if keys property is used\n#include <physical_layouts.dtsi>\n\n/ {\n    default_layout: default_layout {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Default Layout\";\n        transform = <&default_transform>;\n        kscan = <&kscan0>;\n        keys = <...>; // List of key positions, optional\n    };\n\n    alt_layout: alt_layout {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Alternate Layout\";\n        transform = <&alt_transform>;\n        kscan = <&alt_kscan0>;\n        keys = <...>; // List of key positions, optional\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kconfig Battery Reporting Options\nDESCRIPTION: These Kconfig options control battery level detection and reporting. `CONFIG_ZMK_BATTERY_REPORTING` enables or disables battery level detection/reporting. `CONFIG_ZMK_BATTERY_REPORT_INTERVAL` sets the reporting interval in seconds.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/battery.md#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_ZMK_BATTERY_REPORTING\nCONFIG_ZMK_BATTERY_REPORT_INTERVAL\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Code Mapper Instance\nDESCRIPTION: This example defines a new code mapper instance called 'zip_click_to_middle_click_mapper' that maps the left mouse button to the middle mouse button. It uses the compatible property 'zmk,input-processor-code-mapper' and sets the type to INPUT_EV_KEY. The map property defines the mapping from INPUT_BTN_0 to INPUT_BTN_2.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/code-mapper.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <zephyr/dt-bindings/input/input-event-codes.h>\n\n/ {\n    input_processors {\n        zip_click_to_middle_click_mapper: zip_click_to_middle_click_mapper {\n            compatible = \"zmk,input-processor-code-mapper\";\n            #input-processor-cells = <0>;\n            type = <INPUT_EV_KEY>;\n            map = <INPUT_BTN_0 INPUT_BTN_2>;\n        };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Driver/Bus Node Adjustment for nRF52840 - DTS\nDESCRIPTION: This snippet shows how to adjust the `spi0` node for the nRF52840 microcontroller, assigning the previously defined `spi0_default` and `spi0_sleep` pinctrl states. It uses `pinctrl-0`, `pinctrl-1`, and `pinctrl-names` properties to associate the pin configurations with the `default` and `sleep` states. It also changes the compatible property.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n&spi0 {\n    compatible = \"nordic,nrf-spim\";\n    pinctrl-0 = <&spi0_default>;\n    pinctrl-1 = <&spi0_sleep>;\n    pinctrl-names = \"default\", \"sleep\";\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring build.yml for ZMK Dongle (YAML)\nDESCRIPTION: This YAML snippet shows how to configure the `build.yml` file for a ZMK dongle. It includes the board and shield configurations for the dongle itself (`nice_nano_v2` and `my_keyboard_dongle`) and shows how to add CMake arguments to existing keyboard configurations to turn them into peripherals.  Peripheral configurations include `-DCONFIG_ZMK_SPLIT=y` and `-DCONFIG_ZMK_SPLIT_ROLE_CENTRAL=n` to configure the original keyboard as a central split keyboard half.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_8\n\nLANGUAGE: yaml\nCODE:\n```\ninclude:\n  # -----------------------------------------\n  # Your other keyboard parts here\n  # -----------------------------------------\n  # Change the board appropriately, you can use any board\n  - board: nice_nano_v2\n    shield: my_keyboard_dongle\n  - board: nice_nano_v2\n    shield: settings_reset\n  # Add these cmake-args to the peripherals you wish to use with the dongle\n  - board: nice_nano_v2\n    shield: my_keyboard\n    cmake-args: -DCONFIG_ZMK_SPLIT=y -DCONFIG_ZMK_SPLIT_ROLE_CENTRAL=n\n```\n\n----------------------------------------\n\nTITLE: Setting Output to Bluetooth\nDESCRIPTION: This code snippet demonstrates how to configure a behavior binding to prefer sending keyboard output to the current Bluetooth profile. The `&out` reference indicates the output selection behavior, and `OUT_BLE` specifies that the Bluetooth profile should be the preferred output.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/outputs.md#_snippet_2\n\nLANGUAGE: DTS\nCODE:\n```\n&out OUT_BLE\n```\n\n----------------------------------------\n\nTITLE: Configuring PIO-based UART Pins for RP2040\nDESCRIPTION: This snippet configures the pins for a PIO-based UART on the RP2040.  It sets P0 as UART0 TX and P1 as UART0 RX using PIO0, including input enable and pull-up resistor for the RX pin.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_16\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for the uart0 \"default\" state */\n    pio0_uart_default: pio0_uart_default {\n        /* tx pin, NAME IS NOT ARBITRARY */\n        tx_pins {\n            /* configure P0 as UART0 TX */\n            pinmux = <PIO0_P0>;\n            };\n        /* rx pin, NAME IS NOT ARBITRARY */\n        rx_pins {\n            /* configure P1 as UART0 RX */\n            pinmux = <PIO0_P1>;\n            /* enable input on pin 1 */\n            input-enable;\n            bias-pull-up;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: ZMK Event Listener and Subscription Example (Tap Dance)\nDESCRIPTION: This code snippet demonstrates how to define a listener and subscription for a ZMK event using the `ZMK_LISTENER` and `ZMK_SUBSCRIPTION` macros. It showcases the structure required to respond to a `zmk_position_state_changed` event within the ZMK firmware, including the callback function that executes when the event occurs. The `tap_dance_position_state_changed_listener` function will be invoked when a key position changes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nstatic int tap_dance_position_state_changed_listener(const zmk_event_t *eh);\n\nZMK_LISTENER(behavior_tap_dance, tap_dance_position_state_changed_listener);\nZMK_SUBSCRIPTION(behavior_tap_dance, zmk_position_state_changed);\n\nstatic int tap_dance_position_state_changed_listener(const zmk_event_t *eh){\n    // Do stuff...\n}\n```\n\n----------------------------------------\n\nTITLE: Soft Reset Behavior Binding - Devicetree\nDESCRIPTION: This snippet shows how to bind the soft reset behavior to a key in the devicetree. The `&sys_reset` reference is used to trigger a reset of the keyboard, restarting the currently flashed firmware. No parameters are required for this behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/reset.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&sys_reset\n```\n\n----------------------------------------\n\nTITLE: Removing split-peripheral-off-on-press Flag - Devicetree\nDESCRIPTION: This snippet demonstrates how to remove the `split-peripheral-off-on-press` flag from the soft off behavior configuration. Removing this flag allows the peripheral half of a split keyboard to delay entering the soft off state, potentially leading to reliability issues. Use with caution.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/soft-off.md#_snippet_2\n\nLANGUAGE: devicetree\nCODE:\n```\n&soft_off {\n    /delete-property/ split-peripheral-off-on-press;\n};\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform Offset for Split Keyboard (Right)\nDESCRIPTION: This code snippet defines the column offset for the right half of a split keyboard. It adjusts the matrix transform to account for the number of columns on the left side.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_11\n\nLANGUAGE: dts\nCODE:\n```\n&default_transform { // Offset of 3 because the left side has 3 columns\n    col-offset = <3>;\n};\n```\n\n----------------------------------------\n\nTITLE: Toggle External Power - DTS\nDESCRIPTION: This code snippet demonstrates how to use the `&ext_power` behavior binding to toggle external power in a DTS file. The `EP_TOG` parameter is used to specify the 'toggle' command. When triggered, this behavior will switch the external power supply between on and off states.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/power.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&ext_power EP_TOG\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform for Unibody Keyboard\nDESCRIPTION: This code snippet defines the matrix transform for a 3x3 macropad matrix in a unibody keyboard overlay file. It maps row and column events to key positions using the `RC()` macro.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/matrix_transform.h> // Put this with the other includes at the top of your overlay\n\n/ {\n    default_transform: keymap_transform0 {\n        compatible = \"zmk,matrix-transform\";\n        columns = <3>; // Length of the \"col-gpios\" array\n        rows = <3>; // Length of the \"row-gpios\" array\n        map = <\n        //   Key 1 | Key 2 | Key 3\n            RC(0,0) RC(0,1) RC(0,2)\n        //   Key 4 | Key 5 | Key 6\n            RC(1,0) RC(1,1) RC(1,2)\n        //   Key 7 | Key 8 | Key 9\n            RC(2,0) RC(2,1) RC(2,2)\n        >;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Peripheral Configuration for Split Keyboard\nDESCRIPTION: This snippet shows the peripheral part's overlay configuration for a split keyboard setup with a pointing device.  It includes the shared .dtsi file which defines the input listener.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n// Pull in the shared configuration\n#include \"<keyboard>.dtsi\"\n```\n\n----------------------------------------\n\nTITLE: Defining Key Press Behavior Binding in DTS\nDESCRIPTION: This code snippet shows an example of defining a key press behavior binding using the `&kp` reference. The parameter `A` specifies that the 'A' keycode should be sent when the bound key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-press.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&kp A\n```\n\n----------------------------------------\n\nTITLE: Including a behavior in behaviors.dtsi\nDESCRIPTION: This code snippet shows how to include a newly defined behavior in the `app/dts/behaviors.dtsi` file. This makes the behavior accessible to the device tree, allowing users to incorporate it into their keymaps.  The `#include` directive includes the `.dtsi` file for the new behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_10\n\nLANGUAGE: DTS\nCODE:\n```\n#include <behaviors/key_press.dtsi>\n#include <behaviors/transparent.dtsi>\n#include <behaviors/none.dtsi>\n#include <behaviors/mod_tap.dtsi>\n#include <behaviors/layer_tap.dtsi>\n#include <behaviors/gresc.dtsi>\n#include <behaviors/sticky_key.dtsi>\n#include <behaviors/momentary_layer.dtsi>\n#include <behaviors/toggle_layer.dtsi>\n#include <behaviors/to_layer.dtsi>\n#include <behaviors/reset.dtsi>\n#include <behaviors/sensor_rotate_key_press.dtsi>\n#include <behaviors/rgb_underglow.dtsi>\n#include <behaviors/bluetooth.dtsi>\n#include <behaviors/ext_power.dtsi>\n#include <behaviors/outputs.dtsi>\n#include <behaviors/caps_word.dtsi>\n#include <behaviors/key_repeat.dtsi>\n#include <behaviors/backlight.dtsi>\n#include <behaviors/macros.dtsi>\n// highlight-next-line\n#include <behaviors/new_behavior_instance.dtsi>\n```\n\n----------------------------------------\n\nTITLE: Configuring Usage Pages for Key Repeat in ZMK DTS\nDESCRIPTION: This snippet demonstrates how to configure the key_repeat behavior to capture and repeat keycodes from different HID usage pages, such as the Consumer page, in addition to the default Key page.  This is useful for repeating media keys or other non-standard keyboard inputs.  The `usage-pages` property is updated to include the desired HID usage pages.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-repeat.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&key_repeat {\n    usage-pages = <HID_USAGE_KEY HID_USAGE_CONSUMER>;\n};\n\n/ {\n    keymap {\n        ...\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining the underglow in ZMK chosen node\nDESCRIPTION: This snippet shows how to add the defined `led_strip` node to the `chosen` node in the root devicetree. This step is essential for ZMK firmware to recognize and use the configured LED strip for underglow functionality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/underglow.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,underglow = &led_strip;\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Keycode with a built-in Modifier in ZMK\nDESCRIPTION: This example shows how a keycode, in this case DOLLAR, can be defined with a pre-existing left shift modifier applied to the 'NUMBER_4' key. This avoids repetitive code when specific combinations are frequently used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/modifiers.mdx#_snippet_4\n\nLANGUAGE: ZMK\nCODE:\n```\nDOLLAR = LS(NUMBER_4)\n```\n\n----------------------------------------\n\nTITLE: Using Predefined Layouts in DTS\nDESCRIPTION: Demonstrates how to use a predefined layout from the ZMK repository.  It imports the layout and then assigns the `transform` and `kscan` properties. This approach simplifies layout definitions by reusing existing configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n#include <layouts/cuddlykeyboards/ferris.dtsi>\n\n// Assigning suitable kscan and matrix transforms\n&cuddlykeyboards_ferris_layout {\n    transform = <&default_transform>;\n    kscan = <&kscan0>;\n};\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform - Skipping Unused Positions - DTS\nDESCRIPTION: This devicetree overlay demonstrates how to define a matrix transform to skip unused positions in a keyboard matrix, allowing users to avoid setting them to `&none` in keymaps. It includes a `kscan` definition and a `default_transform` node that maps logical keymap positions to physical row and column positions. The example shows a numpad layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/layout.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n// numpad.overlay\n/\n{\n    chosen {\n        zmk,kscan = &kscan0;\n        zmk,matrix-transform = &default_transform;\n    };\n\n    kscan0: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        // define row-gpios with 5 elements and col-gpios with 4...\n    };\n\n    default_transform: matrix_transform {\n        compatible = \"zmk,matrix-transform\";\n        rows = <5>;\n        columns = <4>;\n        // ┌───┬───┬───┬───┐\n        // │NUM│ / │ * │ - │\n        // ├───┼───┼───┼───┤\n        // │ 7 │ 8 │ 9 │ + │\n        // ├───┼───┼───┤   │\n        // │ 4 │ 5 │ 6 │   │\n        // ├───┼───┼───┼───┤\n        // │ 1 │ 2 │ 3 │RET│\n        // ├───┴───┼───┤   │\n        // │ 0     │ . │   │\n        // └───────┴───┴───┘\n        map = <\n            RC(0,0) RC(0,1) RC(0,2) RC(0,3)\n            RC(1,0) RC(1,1) RC(1,2) RC(1,3)\n            RC(2,0) RC(2,1) RC(2,2)\n            RC(3,0) RC(3,1) RC(3,2) RC(3,3)\n            RC(4,0)         RC(4,1)\n        >;\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Defining Parameterized Macros (DTS)\nDESCRIPTION: This snippet illustrates how to define parameterized macros in ZMK firmware using the `compatible` property to specify the number of parameters.  It shows examples for macros with 0, 1, and 2 parameters. `#binding-cells` must match the number of parameters.  The parameter count dictates the \"compatible\" property value.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    macros {\n        // 0 params macro\n        my_macro: my_macro {\n            // ...\n            compatible = \"zmk,behavior-macro\";\n            #binding-cells = <0>; // Must be 0\n            bindings = /* ... */;\n        };\n\n        // 1 param macro\n        my_one_param_macro: my_one_param_macro {\n            // ...\n            compatible = \"zmk,behavior-macro-one-param\";\n            #binding-cells = <1>; // Must be 1\n            bindings = /* ... */;\n        };\n\n        // 2 params macro\n        my_two_param_macro: my_two_param_macro {\n            // ...\n            compatible = \"zmk,behavior-macro-two-param\";\n            #binding-cells = <2>; // Must be 2\n            bindings = /* ... */;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kconfig Configuration Example (INI)\nDESCRIPTION: This snippet shows a sample Kconfig file used for configuring global settings in ZMK, demonstrating how to enable features or hardware devices using `CONFIG_XYZ=value` assignments.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_SLEEP=y\nCONFIG_EC11=y\nCONFIG_EC11_TRIGGER_GLOBAL_THREAD=y\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform for Split Keyboard (Shared)\nDESCRIPTION: This code snippet defines the shared matrix transform for a split keyboard in a `dtsi` file. It maps row and column events to key positions using the `RC()` macro and includes a comment about adding `#include <dt-bindings/zmk/matrix_transform.h>` to the top of the file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_10\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/matrix_transform.h> // Put this with the other includes at the top of your dtsi\n\n/ {\n    default_transform: keymap_transform0 {\n        compatible = \"zmk,matrix-transform\";\n        columns = <6>;\n        rows = <3>;\n        map = <\n        //  LKey 1 |LKey 2 |LKey 3      RKey 1 |RKey 2 |RKey 3\n            RC(0,0) RC(0,1) RC(0,2)     RC(0,3) RC(0,4) RC(0,5)\n        //  LKey 4 |LKey 5 |LKey 6      RKey 4 |RKey 5 |RKey 6\n            RC(1,0) RC(1,1) RC(1,2)     RC(1,3) RC(1,4) RC(1,5)\n        //  LKey 7 |LKey 8 |LKey 9      RKey 7 |RKey 8 |RKey 9\n            RC(2,0) RC(2,1) RC(2,2)     RC(2,3) RC(2,4) RC(2,5)\n        >;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Kscan Sideband Behavior Configuration\nDESCRIPTION: This device tree snippet configures the kscan sideband behavior driver. It defines a node that is compatible with \"zmk,kscan-sideband-behaviors\" and includes properties for the kscan driver to be decorated (`kscan`) and the specific behavior to trigger (`soft_off`). The `column` and `row` properties within the `soft_off` node correspond to the location of the added soft-off input in the kscan matrix.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-matrix.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    side_band_behavior_triggers: side_band_behavior_triggers {\n        compatible = \"zmk,kscan-sideband-behaviors\";\n        wakeup-source;\n        kscan = <&kscan>;\n        soft_off {\n            column = <0>;\n            row = <2>;\n            bindings = <&hw_soft_off>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: SPI Pinctrl Configuration for nRF52840 - DTS\nDESCRIPTION: This snippet shows an example of configuring SPI pins for the nRF52840 microcontroller within the `pinctrl` node. It defines the `spi0_default` and `spi0_sleep` states, assigning specific pins (P0.01, P0.02, P0.03) to SPI functions (SCK, MOSI, MISO) using the `NRF_PSEL` macro. The `low-power-enable` property is also used for the sleep state.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for spi0 device, default state */\n    spi0_default: spi0_default {\n        /* node name is arbitrary */\n        group1 {\n            /* main role: configure P0.01 as SPI clock, P0.02 as SPI MOSI, P0.03 as SPI MISO */\n            psels = <NRF_PSEL(SPIM_SCK, 0, 1)>,\n                    <NRF_PSEL(SPIM_MOSI, 0, 2)>,\n                    <NRF_PSEL(SPIM_MISO, 0, 3)>;\n        };\n    };\n\n    /* configuration for spi0 device, sleep state */\n    spi0_sleep: spi0_sleep {\n        group1 {\n            /* main role: configure P0.01 as SPI clock, P0.02 as SPI MOSI, P0.03 as SPI MISO */\n            psels = <NRF_PSEL(SPIM_SCK, 0, 1)>,\n                    <NRF_PSEL(SPIM_MOSI, 0, 2)>,\n                    <NRF_PSEL(SPIM_MISO, 0, 3)>;\n            low-power-enable;\n        };\n    };\n\n};\n```\n\n----------------------------------------\n\nTITLE: RGB Underglow Devicetree Configuration (DTS)\nDESCRIPTION: This snippet shows how to configure RGB underglow in a board's devicetree file (`.dts`) for Zephyr 3.0. It requires including `<dt-bindings/led/led.h>` and adding a `color-mapping` property to the `led_strip` node. The `color-mapping` property specifies the order of color data sent to the LEDs.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\nled_strip: ws2812@0 {\n  compatible = \"worldsemi,ws2812-spi\";\n\n  /* SPI */\n  reg = <0>; /* ignored, but necessary for SPI bindings */\n  spi-max-frequency = <4000000>;\n\n  /* WS2812 */\n  chain-length = <10>; /* number of LEDs */\n  spi-one-frame = <0x70>;\n  spi-zero-frame = <0x40>;\n  color-mapping = <LED_COLOR_ID_GREEN\n                   LED_COLOR_ID_RED\n                   LED_COLOR_ID_BLUE>;\n};\n```\n\n----------------------------------------\n\nTITLE: Binding for Left Mouse Scroll\nDESCRIPTION: This example configures a behavior binding to send a scroll left event to the host when pressed or held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_10\n\nLANGUAGE: dts\nCODE:\n```\n&msc SCRL_LEFT\n```\n\n----------------------------------------\n\nTITLE: Eager Debouncing Approximation in ZMK\nDESCRIPTION: This code snippet showcases an approximation of eager debouncing by setting the key press debounce time to zero and the key release debounce time to a larger value. This aims to minimize latency for key presses while still debouncing key releases for stability. Setting press to 1 is an alternative to protect from noise spikes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/debouncing.md#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_KSCAN_DEBOUNCE_PRESS_MS=0\nCONFIG_ZMK_KSCAN_DEBOUNCE_RELEASE_MS=5\n```\n\n----------------------------------------\n\nTITLE: Installing GCC Multilib for POSIX Target - Shell\nDESCRIPTION: Installs the gcc-multilib package on Debian-based systems. This package provides the necessary compiler tools to target 32-bit POSIX environments, a prerequisite for building ZMK firmware targeting the native_posix board.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/posix-board.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\napt install -y gcc-multilib\n```\n\n----------------------------------------\n\nTITLE: Defining Physical Layout in Base File (DTS)\nDESCRIPTION: This snippet defines a physical layout directly within the base overlay file. It includes setting the `compatible` property, a display name, the matrix transform, and a placeholder for key positions. The transform label `default_transform` must correspond to an existing matrix transform node. This configuration is designed for use within the overlay file for the keyboard dongle.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &mock_kscan;\n        zmk,physical-layout = &physical_layout0;\n    };\n\n    physical_layout0: physical_layout_0 {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Default Layout\";\n        transform = <&default_transform>;\n        keys = <...>; // Long list of key positions\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Set Specific HSB Color for Underglow - DTS\nDESCRIPTION: This snippet shows how to set a specific HSB (Hue, Saturation, Brightness) color for the RGB underglow using the `RGB_COLOR_HSB` action. In this example, a green color is set (Hue: 128, Saturation: 100, Brightness: 100).  It relies on the `&rgb_ug` behavior binding and the `RGB_COLOR_HSB` definition from the included header. Values are limited to H <= 360, S <= 100, B <= 100.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/underglow.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&rgb_ug RGB_COLOR_HSB(128,100,100)\n```\n\n----------------------------------------\n\nTITLE: Mod-Morph Keymap Example (COLON/SEMI)\nDESCRIPTION: This DeviceTree snippet defines a mod-morph behavior that swaps the COLON and SEMI keycodes when a shift modifier is active. It illustrates how the `keep-mods` property enhances mod-morphs by allowing the use of keycodes that were previously incompatible with the triggering modifiers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-10-05-zmk-sotf-6.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n        col_semi: colon_semicolon {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp COLON>, <&kp SEMI>;\n            mods = <(MOD_LSFT|MOD_RSFT)>;\n        };\n```\n\n----------------------------------------\n\nTITLE: Configure Kconfig.defconfig for ZMK Keyboard Dongle\nDESCRIPTION: This code snippet defines the Kconfig.defconfig settings for a ZMK keyboard dongle. It sets the keyboard name, configures the dongle as the central role in a split keyboard setup, specifies the number of peripherals, and defines maximum connection and paired devices. The `SHIELD_MY_KEYBOARD_DONGLE` value must match the Kconfig.shield configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_1\n\nLANGUAGE: kconfig\nCODE:\n```\nif SHIELD_MY_KEYBOARD_DONGLE\n\n# Max 16 characters in keyboard name\nconfig ZMK_KEYBOARD_NAME\n    default \"My Board\"\n\nconfig ZMK_SPLIT_ROLE_CENTRAL\n    default y\n\nconfig ZMK_SPLIT\n    default y\n\n# Set this to the number of peripherals your dongle will have.\n# For a unibody, this would be 1. If you have left and right halves, set it to 2, etc.\nconfig ZMK_SPLIT_BLE_CENTRAL_PERIPHERALS\n    default 1\n\n# Set this to ZMK_SPLIT_BLE_CENTRAL_PERIPHERALS + your desired number of BT profiles (default is 5)\nconfig BT_MAX_CONN\n    default 6\n\n# Set this to the same number as BT_MAX_CONN\nconfig BT_MAX_PAIRED\n    default 6\n\nendif\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Backlight LEDs in Pinctrl DTS\nDESCRIPTION: This snippet demonstrates how to configure pin control for multiple backlight LEDs in the pinctrl node of the Device Tree Source (DTS) file.  Each LED is assigned a separate PWM channel.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    // Other Pinctrl definitions go here\n    pwm0_default: pwm0_default {\n        group1 {\n            psels = <NRF_PSEL(PWM_OUT0, 0, 20)>, // LED 0\n                    <NRF_PSEL(PWM_OUT1, 0, 22)>, // LED 1\n                    <NRF_PSEL(PWM_OUT2, 0, 24)>; // LED 2\n        };\n    };\n    pwm0_sleep: pwm0_sleep {\n        group1 {\n            psels = <NRF_PSEL(PWM_OUT0, 0, 20)>, // LED 0\n                    <NRF_PSEL(PWM_OUT1, 0, 22)>, // LED 1\n                    <NRF_PSEL(PWM_OUT2, 0, 24)>; // LED 2\n            low-power-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: USB Device Tree Overlay - DTS\nDESCRIPTION: This snippet demonstrates how to add the `zephyr_udc0` label to the USB node in a device tree source (DTS) file.  This is necessary when creating custom board definitions to ensure that USB logging is enabled and functional. This configuration allows the system to recognize the USB device for logging purposes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\nzephyr_udc0: &usbd {\n    status = \"okay\";\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Backlight LEDs in DTS\nDESCRIPTION: This snippet demonstrates how to define multiple backlight LEDs within the `pwmleds` node in the Device Tree Source (DTS) file. Each LED is configured with its respective PWM channel and settings.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\nbacklight: pwmleds {\n    compatible = \"pwm-leds\";\n    pwm_led_0: pwm_led_0 {\n        pwms = <&pwm0 0 PWM_MSEC(10) PWM_POLARITY_NORMAL>;\n    };\n    pwm_led_1: pwm_led_1 {\n        pwms = <&pwm0 1 PWM_MSEC(10) PWM_POLARITY_NORMAL>;\n    };\n    pwm_led_2: pwm_led_2 {\n        pwms = <&pwm0 2 PWM_MSEC(10) PWM_POLARITY_NORMAL>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Flashing ZMK Firmware with West\nDESCRIPTION: This command flashes the built ZMK firmware to the Ferris 0.2 keyboard using the `west flash` tool. It assumes the board is in bootloader mode (activated by pressing the reset button) and specifies the build directory as `build/ferris`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/ferris/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwest flash -d build/ferris\n```\n\n----------------------------------------\n\nTITLE: Defining a Macro in ZMK DTS\nDESCRIPTION: This code snippet demonstrates how to define a macro in ZMK's device tree source (DTS) format. The macro `layer_color_macro` is configured to change the underglow color when a layer is activated or deactivated. It utilizes `macro_press`, `macro_tap`, `macro_pause_for_release`, and `macro_release` behaviors. The `wait-ms` and `tap-ms` properties control timing within the macro.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-10-zmk-sotf-5.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\nZMK_MACRO(layer_color_macro,\n  wait-ms = <0>;\n  tap-ms = <0>;\n  bindings\n      = <&macro_press &mo 1>\n      , <&macro_tap &rgb_ug RGB_COLOR_HSB(128,100,100)>\n      , <&macro_pause_for_release>\n      , <&macro_release &mo 1>\n      , <&macro_tap &rgb_ug RGB_COLOR_HSB(300,100,50)>;\n)\n```\n\n----------------------------------------\n\nTITLE: Defining PWM Pin Control in DTS\nDESCRIPTION: This snippet shows how to define pin control settings for PWM in a Device Tree Source (DTS) file. It includes default and sleep states for the PWM pin, configuring the pin selection (psels) using the NRF_PSEL macro.  The pin numbers will vary based on the MCU.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    // Other pinctrl definitions for other hardware\n    pwm0_default: pwm0_default {\n        group1 {\n            psels = <NRF_PSEL(PWM_OUT0, 1, 13)>;\n        };\n    };\n    pwm0_sleep: pwm0_sleep {\n        group1 {\n            psels = <NRF_PSEL(PWM_OUT0, 1, 13)>;\n            low-power-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling PWM for Backlight in Kconfig\nDESCRIPTION: This code snippet demonstrates how to enable Pulse Width Modulation (PWM) and LED PWM in the Kconfig.defconfig file for ZMK backlight support. These configurations are essential for controlling the brightness of the backlight LEDs.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/lighting/backlight.mdx#_snippet_0\n\nLANGUAGE: kconfig\nCODE:\n```\nif ZMK_BACKLIGHT\n\nconfig PWM\n    default y\n\nconfig LED_PWM\n    default y\n\nendif # ZMK_BACKLIGHT\n```\n\n----------------------------------------\n\nTITLE: Enabling ZMK Pointing Feature\nDESCRIPTION: This configuration snippet enables the pointer functionality in ZMK. It requires setting `CONFIG_ZMK_POINTING=y` in the project's configuration file.  Enabling this feature modifies the HID report descriptor, which may require re-pairing Bluetooth devices.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/pointing.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nCONFIG_ZMK_POINTING=y\n```\n\n----------------------------------------\n\nTITLE: Devicetree Key Toggle Configuration\nDESCRIPTION: Configures the key toggle behavior via devicetree, enabling specification of the toggle mode (on, off, or flip).  The `#binding-cells` property must be `<1>`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_6\n\nLANGUAGE: YAML\nCODE:\n```\n#binding-cells: <1>\ntoggle-mode: \"flip\"\n```\n\n----------------------------------------\n\nTITLE: Tap Dance Behavior Devicetree Binding\nDESCRIPTION: Describes the device tree binding for the `zmk,behavior-tap-dance` compatible.  It defines properties such as `#binding-cells`, `bindings` (phandle array), and `tapping-term-ms` to configure the tap dance behavior. The `bindings` property specifies a list of behaviors to select from based on the number of taps.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_10\n\n\n\n----------------------------------------\n\nTITLE: Toggling External Power in Keymap - DTS\nDESCRIPTION: This code snippet demonstrates how to toggle the external power in a ZMK keymap. The `&ext_power EP_TOG` code uses the external power behavior to turn on or off the power supplied to external hardware components such as RGB underglow or OLED displays.  This functionality depends on boards like nRFMicro and nice!nano that have specialized hardware for power control.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-11-09-zmk-sotf-3.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&ext_power EP_TOG\n```\n\n----------------------------------------\n\nTITLE: Devicetree Behavior Metadata\nDESCRIPTION: Defines the `display-name` property for behaviors in the devicetree. This property is used to specify the name of the layer, for use with a display or ZMK Studio.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\ndisplay-name\n```\n\n----------------------------------------\n\nTITLE: Flashing Firmware Using West Flash\nDESCRIPTION: Flashes the built firmware to the keyboard using the `west flash` command. This requires the board to be in DFU mode and that the development is not within a Docker environment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nwest flash\n```\n\n----------------------------------------\n\nTITLE: Enable USB Logging via build.yaml - YAML\nDESCRIPTION: This snippet shows how to enable USB logging in ZMK firmware when using GitHub Actions by adding the `snippet: zmk-usb-logging` line to the `build.yaml` file. This configuration ensures that logging is enabled for the specific build, allowing developers to capture and analyze debug output.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ninclude:\n  - board: nice_nano_v2\n    shield: corne_left\n    snippet: zmk-usb-logging\n```\n\n----------------------------------------\n\nTITLE: User-Defined Scaler Instance (DTS)\nDESCRIPTION: Defines a user-defined scaler instance named `zip_wheel_scaler` to scale wheel events. It sets the compatible property, input processor cells, type (INPUT_EV_REL), codes (INPUT_REL_WHEEL), and enables tracking of remainders. Requires including the `input-event-codes.h` header file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/scaler.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include <zephyr/dt-bindings/input/input-event-codes.h>\n\n/ {\n    input_processors {\n        zip_wheel_scaler: zip_wheel_scaler {\n            compatible = \"zmk,input-processor-scaler\";\n            #input-processor-cells = <2>;\n            type = <INPUT_EV_REL>;\n            codes = <INPUT_REL_WHEEL>;\n            track-remainders;\n        };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: New Sensor Node Configuration DTS\nDESCRIPTION: Demonstrates the updated sensor node configuration with the `triggers-per-rotation` property. This defines how many times the encoder should trigger the behavior in the keymap per full rotation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-06-18-encoder-refactors.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n    sensors {\n        compatible = \"zmk,keymap-sensors\";\n        sensors = <&left_encoder &right_encoder>;\n        triggers-per-rotation = <20>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Example Configuration Files\nDESCRIPTION: This shows the required file structure within the `config` directory of your `zmk-config` folder for supporting multiple keyboards. It needs `<keyboard>.conf` and `<keyboard>.keymap` files for each keyboard.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/customization.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ncorne.conf\ncorne.keymap\nlily58.conf\nlily58.keymap\n```\n\n----------------------------------------\n\nTITLE: Running Setup Script with PowerShell\nDESCRIPTION: This command uses PowerShell to download and execute the ZMK setup script from the zmk.dev website. It's designed for Windows environments where PowerShell is readily available.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup.mdx#_snippet_2\n\nLANGUAGE: powershell\nCODE:\n```\npowershell -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://zmk.dev/setup.ps1'))\"\n```\n\n----------------------------------------\n\nTITLE: Toggle Mode Kscan Devicetree Example\nDESCRIPTION: Example devicetree configuration using toggle-mode. This is used to avoid battery drain when switches are left in the pressed state.  Assumes the common pole of the switch is connected to ground with an SP3T switch.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/kscan.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\nkscan_sp3t_toggle: kscan_sp3t_toggle {\n        compatible = \"zmk,kscan-gpio-direct\";\n        toggle-mode;\n\n        input-gpios\n        = <&pro_micro 4 GPIO_ACTIVE_LOW>\n        , <&pro_micro 3 GPIO_ACTIVE_LOW>\n        , <&pro_micro 2 GPIO_ACTIVE_LOW>\n        ;\n    };\n```\n\n----------------------------------------\n\nTITLE: Enabling Caps Word Behavior in Device Tree Source (DTS)\nDESCRIPTION: This snippet demonstrates how to enable the caps word behavior by referencing it with `&caps_word` in a Device Tree Source (DTS) file. This enables the default caps word behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/caps-word.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&caps_word\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v2 Custom Keymap with ZMK\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v2 keyboard using a custom keymap. It adds the `-DZMK_CONFIG` parameter to specify the path to the custom keymap configuration file. Ensure to replace `C:/dev/zmk/[yourName]/leeloo_v2/config` with the correct path to your custom configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/right_v2 -p -b nice_nano_v2 -- -DSHIELD=leeloo_rev2_right -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo_v2/config\"\nwest build -d build/left_v2 -p -b nice_nano_v2 -- -DSHIELD=leeloo_rev2_left -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo_v2/config\"\n```\n\n----------------------------------------\n\nTITLE: Non-Complete Position Map - DTS\nDESCRIPTION: This example demonstrates a non-`complete` position map, which only defines mappings for keys with differing physical characteristics. This is a more concise way to define mappings, especially when most keys share the same physical properties. This approach saves flash space.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_14\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map3 {\n        compatible = \"zmk,physical-layout-position-map\";\n\n        macropad_map: macropad {\n            physical-layout = <&macropad_layout>;\n            positions = <7 15 16>;\n        };\n\n        numpad_map: numpad {\n            physical-layout = <&numpad_layout>;\n            positions = <7 14 15>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Devicetree Battery Sensor Node\nDESCRIPTION: This Devicetree property specifies the node for the battery sensor driver. The `zmk,battery` property in the `/chosen` node defines the path to the battery sensor node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/battery.md#_snippet_1\n\nLANGUAGE: Devicetree\nCODE:\n```\nzmk,battery\n```\n\n----------------------------------------\n\nTITLE: Configure GPIO Key Wakeup Trigger - Devicetree\nDESCRIPTION: This snippet configures a `wakeup_scan` node in the device tree to enable waking the keyboard from a soft off state when the specified GPIO key is pressed. It sets the compatible string, the trigger GPIO using a label (`soft_off_gpio_key`), and designates the node as a wakeup source.  The `extra-gpios` property specifies additional GPIOs associated with the keys used to wake the keyboard.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_soft-off-waker.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    wakeup_scan: wakeup_scan {\n        compatible = \"zmk,gpio-key-wakeup-trigger\";\n        trigger = <&soft_off_gpio_key>;\n        wakeup-source;\n        extra-gpios = <&gpio0 12 GPIO_ACTIVE_HIGH>\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring UART0 Pins for nRF52840\nDESCRIPTION: This snippet configures the pins for UART0 on the nRF52840 using the device tree. It sets up P0.1 as TX, P0.2 as RTS, P0.3 as RX, and P0.4 as CTS, including pull-up resistors for RX and CTS.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_12\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for uart0 device, default state */\n    uart0_default: uart0_default {\n        group1 {\n            /* configure P0.1 as UART_TX and P0.2 as UART_RTS */\n            psels = <NRF_PSEL(UART_TX, 0, 1)>, <NRF_PSEL(UART_RTS, 0, 2)>;\n        };\n        group2 {\n            /* configure P0.3 as UART_RX and P0.4 as UART_CTS */\n            psels = <NRF_PSEL(UART_RX, 0, 3)>, <NRF_PSEL(UART_CTS, 0, 4)>;\n            /* both P0.3 and P0.4 are configured with pull-up */\n            bias-pull-up;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling I2C0 Instance for nRF52840\nDESCRIPTION: This snippet enables the I2C0 (TWIM) instance for nRF52840. It sets the compatible string to \"nordic,nrf-twim\", status to \"okay\", assigns both default and sleep pin control configurations, and sets the clock frequency to I2C_BITRATE_FAST.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_19\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&i2c0 {\n    compatible = \"nordic,nrf-twim\"; // I2C controller instead of generic\n    status = \"okay\";\n    pinctrl-0 = <&i2c0_default>;\n    pinctrl-1 = <&i2c0_sleep>;\n    pinctrl-names = \"default\", \"sleep\";\n    clock-frequency = <I2C_BITRATE_FAST>;\n\n    /* Nodes using the bus go here */\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a GPIO Key in DTS\nDESCRIPTION: This Device Tree Snippet defines a GPIO key named `soft_off_gpio_key` within the `keys` node. It specifies the GPIO pin to be used, along with its active state and pull-up/down configuration. The GPIO settings should match those in the kscan for proper functionality. The specified pin should be the MCU input pin of the switch used for waking from soft off.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_gpio-key-wakeup.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    keys {\n        compatible = \"gpio-keys\";\n        soft_off_gpio_key: soft_off_gpio_key {\n            gpios = <&gpio0 2 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Input Processors to Mouse Movement\nDESCRIPTION: This example demonstrates how to apply input processors to the `&mmv` behavior using `&mmv_input_listener`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n&mmv_input_listener {\n    input-processors = <&zip_temp_layer 2 2000>;\n}\n```\n\n----------------------------------------\n\nTITLE: RP2040 Pinctrl Include\nDESCRIPTION: Includes the pinctrl header file for the RP2040 MCU in the `<my-board>-pinctrl.dtsi` file. This header provides definitions for pin control configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/pinctrl/rpi-pico-rp2040-pinctrl.h>\n```\n\n----------------------------------------\n\nTITLE: Adding Sensor Bindings to Keymap\nDESCRIPTION: This code snippet adds sensor bindings to a keymap layer.  The `sensor-bindings` array maps encoder actions to specific keycodes. In this example, turning the left encoder increments/decrements page up/down, the middle encoder controls volume, and the right encoder controls previous/next track. The `inc_dec_kp` refers to a macro or function that handles incrementing/decrementing the keycodes. This section is added to the appropriate layer in the keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/bdn9/README.md#_snippet_3\n\nLANGUAGE: devicetree\nCODE:\n```\nsensor-bindings = <&inc_dec_kp PG_UP PG_DN &inc_dec_kp M_VOLU M_VOLD &inc_dec_kp C_PREV C_NEXT>;\n```\n\n----------------------------------------\n\nTITLE: Assigning Base Input Processor in DTS\nDESCRIPTION: This snippet demonstrates how to assign a base input processor (zip_xy_scaler) to the trackpad listener in the device tree source (DTS) file.  This processor will always be active and will scale the trackpad values.  It requires including the `input/processors.dtsi` file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/usage.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n#include <input/processors.dtsi>\n\n&trackpad_listener {\n    input-processors = <&zip_xy_scaler 3 2>;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding settings_reset shield to build.yaml - YAML\nDESCRIPTION: This code snippet demonstrates how to add a `settings_reset` shield configuration to your `build.yaml` file in your `zmk-config` repository. This is necessary to generate a firmware that resets all settings on your keyboard, including Bluetooth profiles and RGB settings. This is useful for resolving pairing issues with split keyboards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/connection-issues.mdx#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\ninclude:\n  - board: nice_nano_v2\n    shield: corne_left\n  - board: nice_nano_v2\n    shield: corne_right\n  - board: nice_nano_v2\n    shield: settings_reset\n```\n\n----------------------------------------\n\nTITLE: Configuring quick-tap-ms for hold-tap - DTS\nDESCRIPTION: This snippet configures the `quick-tap-ms` property for a hold-tap behavior, setting it to 150 milliseconds. If the hold-tap key is pressed again within 150ms of the first press, it will always trigger the tap behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_12\n\nLANGUAGE: DTS\nCODE:\n```\n&mt {\n    quick-tap-ms = <150>;\n};\n```\n\n----------------------------------------\n\nTITLE: Configure Build Matrix - YAML\nDESCRIPTION: Configures the build matrix using a `build.yaml` file in the repository. This file defines the board and shield combinations to be built.  It allows for simple combinations using `board` and `shield` arrays or more complex configurations using the `include` property. This provides flexibility in defining the build targets.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n# This file generates the GitHub Actions matrix\n# For simple board + shield combinations, add them\n# to the top level board and shield arrays, for more\n# control, add individual board + shield combinations to\n# the `include` property, e.g:\n#\n# board: [ \"nice_nano_v2\" ]\n# shield: [ \"corne_left\", \"corne_right\" ]\n# include:\n#   - board: bdn9_rev2\n#   - board: nice_nano_v2\n#     shield: reviung41\n#\n---\n\n```\n\n----------------------------------------\n\nTITLE: SPI Pinctrl Configuration for RP2040 - DTS\nDESCRIPTION: This snippet illustrates configuring SPI pins for the RP2040 microcontroller. It defines the `spi0_default` state and assigns pins P18, P19, and P16 to SPI0 functions (SCK, MOSI, MISO) using the `pinmux` property. It also enables input on pin P16 using `input-enable`. A separate `pio0_spi_default` configures pins for use with PIO0.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for spi0 device, default state */\n    spi0_default: spi0_default {\n        group1 {\n            /* configure P18 as SPI0 clock, P19 as SPI0 MOSI */\n            pinmux = <SPI0_SCK_P18>, <SPI0_TX_P19>;\n        };\n        group2 {\n            /* configure P16 as SPI0 MISO */\n            pinmux = <SPI0_RX_P16>;\n            /* enable input on pin 1 */\n            input-enable;\n        };\n    };\n\n    /* configuration for an spi device using PIO0, default state  */\n    pio0_spi_default: pio0_spi_default {\n        group1 {\n            /* Configure P13 and P14 for PIO, to be used for MOSI and SCK */\n            pinmux = <PIO0_P13>, <PIO0_P14>;\n        };\n        group2 {\n            /* Configure P16 for PIO to be used for MISO with input */\n            pinmux = <PIO0_P12>;\n            input-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enable UF2 Builds in Kconfig (INI)\nDESCRIPTION: This snippet shows how to enable UF2 builds by adding `CONFIG_BUILD_OUTPUT_UF2=y` to the `<board>_defconfig` file.  This will cause Zephyr to generate a UF2 image during the build process. This requires removing the old custom CMakeLists.txt file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_BUILD_OUTPUT_UF2=y\n```\n\n----------------------------------------\n\nTITLE: Kconfig.shield for Unibody Keyboard\nDESCRIPTION: This snippet demonstrates the `Kconfig.shield` file content for a unibody keyboard. It defines a shield configuration using `SHIELD_MY_KEYBOARD` and uses `shields_list_contains` to set the flag based on the shield name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_1\n\nLANGUAGE: kconfig\nCODE:\n```\n# No whitespace after the comma or in your keyboard name!\nconfig SHIELD_MY_KEYBOARD\n    def_bool $(shields_list_contains,my_keyboard)\n```\n\n----------------------------------------\n\nTITLE: Add West Flash Support - CMake\nDESCRIPTION: This CMake snippet adds support for flashing via `west flash` to a custom board that supports a UF2 bootloader. By including the `uf2.board.cmake` file from the Zephyr base, the board gains the functionality to be flashed directly using the `west flash` command.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-02-09-zephyr-3-5.md#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ninclude(${ZEPHYR_BASE}/boards/common/uf2.board.cmake)\n```\n\n----------------------------------------\n\nTITLE: Enabling Backlight - Kconfig - INI\nDESCRIPTION: This snippet enables the backlight feature in the ZMK configuration.  Adding `CONFIG_ZMK_BACKLIGHT=y` to the `.conf` file activates backlight functionality for controlling single-color LEDs connected to the keyboard. Backlight allows for brightness control of LEDs placed through or under switches.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/lighting.md#_snippet_2\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_BACKLIGHT=y\n```\n\n----------------------------------------\n\nTITLE: Building Default Keymap with nice!view Support (ZMK)\nDESCRIPTION: These commands build the ZMK firmware for the left and right halves of the Leeloo-Micro keyboard with support for nice!view displays using the default keymap. It leverages the `west build` tool with the `nice_nano_v2` board and specifies the `leeloo_micro_left`, `nice_view_adapter`, and `nice_view` shields. The commands are meant for a shell environment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo_micro/README.md#_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_micro_left nice_view_adapter nice_view\"\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_micro_right nice_view_adapter nice_view\"\n```\n\n----------------------------------------\n\nTITLE: Pristine Building ZMK Firmware\nDESCRIPTION: Builds ZMK firmware with the pristine build option enabled. This removes all existing files in the build directory before regenerating them, ensuring a clean build. The `-p` or `--pristine` flag enables the option.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nwest build -p -b nice_nano_v2 -- -DSHIELD=kyria_left\n```\n\n----------------------------------------\n\nTITLE: Global Debounce Configuration in ZMK\nDESCRIPTION: This code snippet shows how to configure global debounce settings for key press and release events in the ZMK firmware using the `.conf` file. It adjusts the debounce time for all kscan drivers unless overridden by per-driver settings. Values must be less than or equal to 16383.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/debouncing.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_KSCAN_DEBOUNCE_PRESS_MS=3\nCONFIG_ZMK_KSCAN_DEBOUNCE_RELEASE_MS=3\n```\n\n----------------------------------------\n\nTITLE: Defining Behavior Parameter Metadata Sets in C\nDESCRIPTION: This C code defines the behavior parameter metadata for a ZMK behavior, including values for commands with and without additional parameters. It specifies display names, parameter types, and values, and then groups these into metadata sets for use by the ZMK Studio UI.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\n#if IS_ENABLED(CONFIG_ZMK_BEHAVIOR_METADATA)\n// Set up the values for commands that take no additional parameter.\nstatic const struct behavior_parameter_value_metadata no_arg_values[] = {\n    {\n        .display_name = \"Next Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_NXT_CMD,\n    },\n    {\n        .display_name = \"Previous Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_PRV_CMD,\n    },\n    {\n        .display_name = \"Clear All Profiles\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_CLR_ALL_CMD,\n    },\n    {\n        .display_name = \"Clear Selected Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_CLR_CMD,\n    },\n};\n\n// Set up the \"no arg\" metadata set.\nstatic const struct behavior_parameter_metadata_set no_args_set = {\n    .param1_values = no_arg_values,\n    .param1_values_len = ARRAY_SIZE(no_arg_values),\n};\n\n// Set up the possible param1 values for commands that take a profile index for param2\nstatic const struct behavior_parameter_value_metadata prof_index_param1_values[] = {\n    {\n        .display_name = \"Select Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_SEL_CMD,\n    },\n    {\n        .display_name = \"Disconnect Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_VALUE,\n        .value = BT_DISC_CMD,\n    },\n};\n\n// Set up the param2 value metadata for the valid range of possible profiles to pick from.\nstatic const struct behavior_parameter_value_metadata prof_index_param2_values[] = {\n    {\n        .display_name = \"Profile\",\n        .type = BEHAVIOR_PARAMETER_VALUE_TYPE_RANGE,\n        .range = {.min = 0, .max = ZMK_BLE_PROFILE_COUNT},\n    },\n};\n\n// Set up the metadata set for the commands that take a profile for the second parameter.\nstatic const struct behavior_parameter_metadata_set profile_index_metadata_set = {\n    .param1_values = prof_index_param1_values,\n    .param1_values_len = ARRAY_SIZE(prof_index_param1_values),\n    .param2_values = prof_index_param2_values,\n    .param2_values_len = ARRAY_SIZE(prof_index_param2_values),\n};\n\n// Finally, expose all the sets in the top level aggregate structure.\nstatic const struct behavior_parameter_metadata_set metadata_sets[] = {no_args_set,\n                                                                       profile_index_metadata_set};\n\nstatic const struct behavior_parameter_metadata metadata = {\n    .sets_len = ARRAY_SIZE(metadata_sets),\n    .sets = metadata_sets,\n};\n\n#endif // IS_ENABLED(CONFIG_ZMK_BEHAVIOR_METADATA)\n```\n\n----------------------------------------\n\nTITLE: Setting the Chosen Node for Kscan - DTS\nDESCRIPTION: This snippet sets both the `zmk,kscan` and `zmk,physical-layout` properties of the `chosen` node. If all physical layouts use the same `kscan` node, you can skip setting the `kscan` property on each layout and instead assign it via the chosen node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_15\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &kscan0;\n        zmk,physical-layout = &physical_layout0;\n        // Other chosen items\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Binding Key Repeat Behavior in ZMK DTS\nDESCRIPTION: This snippet shows how to bind the key_repeat behavior within a ZMK device tree source file. It's used to enable the key repeat functionality, which repeats the last sent keycode.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-repeat.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&key_repeat\n```\n\n----------------------------------------\n\nTITLE: Configuring Variable Sensor Rotation Behavior in ZMK with DeviceTree\nDESCRIPTION: This snippet demonstrates how to configure the variable sensor rotation behavior in ZMK firmware using DeviceTree syntax.  It uses the \"zmk,behavior-sensor-rotate-var\" compatible string, binds the key press behavior twice, and then utilizes it in the `sensor-bindings` property of a keymap layer. Rotating clockwise sends PG_UP, while rotating counter-clockwise sends PG_DN.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sensor-rotate.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        rot_kp: sensor_rotate_kp {\n            compatible = \"zmk,behavior-sensor-rotate-var\";\n            #sensor-binding-cells = <2>;\n            bindings = <&kp>, <&kp>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n        base {\n            ...\n            sensor-bindings = <&rot_kp PG_UP PG_DN>;\n        }\n    }\n};\n```\n\n----------------------------------------\n\nTITLE: Position Map for Corne Keyboard - DTS\nDESCRIPTION: This code showcases a position map for mapping between the 5-column and 6-column Corne keyboard layouts. The 6-column layout is designated as the reference. The `physical-layout` property specifies the corresponding physical layout for each map.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_15\n\nLANGUAGE: dts\nCODE:\n```\nfoostan_corne_lossless_position_map {\n        compatible = \"zmk,physical-layout-position-map\";\n\n        complete;\n\n        twelve_map: twelve {\n            physical-layout = <&foostan_corne_6col_layout>;\n            positions\n                = < 0  1  2  3  4  5  6  7  8  9 10 11>\n                , <12 13 14 15 16 17 18 19 20 21 22 23>\n                , <24 25 26 27 28 29 30 31 32 33 34 35>\n                , <         36 37 38 39 40 41         >;\n        };\n\n        ten_map: ten {\n            physical-layout = <&foostan_corne_5col_layout>;\n            positions\n                = <41  0  1  2  3  4  5  6  7  8  9 40>\n                , <39 10 11 12 13 14 15 16 17 18 19 38>\n                , <37 20 21 22 23 24 25 26 27 28 29 36>\n                , <         30 31 32 33 34 35         >;\n        };\n    };\n```\n\n----------------------------------------\n\nTITLE: Disable GATT Subscription Enforcement - INI\nDESCRIPTION: Disables GATT subscription enforcement in the Zephyr configuration. This configuration is set as `CONFIG_BT_GATT_ENFORCE_SUBSCRIPTION=n`. This resolves a bug in Windows related to battery reporting when using Bluetooth, working around an issue introduced in Zephyr 3.2.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_BT_GATT_ENFORCE_SUBSCRIPTION=n\n```\n\n----------------------------------------\n\nTITLE: Devicetree Configuration Example (DTS)\nDESCRIPTION: This snippet illustrates a Devicetree file used to describe the hardware and define keymaps in ZMK, using nodes and properties to configure the keyboard.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &kscan0;\n    };\n\n    kscan0: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Docker Volume for ZMK Modules\nDESCRIPTION: Creates a Docker volume named 'zmk-modules' and binds it to a specified local directory. This allows the container to access ZMK modules. Requires Docker to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ndocker volume create --driver local -o o=bind -o type=none \\\n  -o device=\"/absolute/path/to/zmk-modules/parent/\" zmk-modules\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit with pip\nDESCRIPTION: This snippet shows how to install the pre-commit package using pip3, the Python package installer. It assumes that Python is already installed on the system. If the installation fails, it suggests verifying the Python installation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/pre-commit.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install pre-commit\n```\n\n----------------------------------------\n\nTITLE: Configure West to Generate Compilation Database with ZMK Config Path\nDESCRIPTION: This command configures the `west` tool to instruct CMake to generate a compilation database while preserving the ZMK config path. This database contains information about the project's build process, allowing IDEs like Visual Studio Code to provide better code completion and other features. The command needs to be run in the ZMK repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/ide-integration.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwest config build.cmake-args -- \"-DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DZMK_CONFIG=/path/to/zmk-config/config\"\n```\n\n----------------------------------------\n\nTITLE: Installing west globally with pip3 (Ubuntu/Mac)\nDESCRIPTION: Installs the `west` tool globally using `pip3` with the `--user` flag on Ubuntu and macOS. Requires Python 3 and pip3 to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\npip3 install --user -U west\n```\n\n----------------------------------------\n\nTITLE: Conditional Target Sources and Linker Sections CMake\nDESCRIPTION: This snippet conditionally sets the target sources and linker sections based on whether the device is configured as the central or peripheral half of the split keyboard. If `CONFIG_ZMK_SPLIT_ROLE_CENTRAL` is enabled, it uses `central.c` and `zmk-split-transport-central.ld`. Otherwise, it uses `peripheral.c` and `zmk-split-transport-peripheral.ld`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nif (CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n    target_sources(app PRIVATE central.c)\n    zephyr_linker_sources(SECTIONS ../../include/linker/zmk-split-transport-central.ld)\nelse()\n    target_sources(app PRIVATE peripheral.c)\n    zephyr_linker_sources(SECTIONS ../../include/linker/zmk-split-transport-peripheral.ld)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Enable External Power - DTS\nDESCRIPTION: This code snippet demonstrates how to use the `&ext_power` behavior binding to enable external power in a DTS file.  The `EP_ON` parameter is used to specify the 'enable' command. When triggered, this behavior will activate the external power supply.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/power.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&ext_power EP_ON\n```\n\n----------------------------------------\n\nTITLE: Devicetree Error: Undeclared Key Binding\nDESCRIPTION: This error indicates a problem with key bindings, such as behavior nodes (`&kp` or `&mt`) having an incorrect number of parameters. The error message refers to `devicetree_generated.h` and indicates an \"undeclared here\" error.  The example shows an issue in position `12` of the `symbol_layer` in the keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/building-issues.md#_snippet_2\n\nLANGUAGE: text\nCODE:\n```\n/__w/zmk-config/zmk-config/build/zephyr/include/generated/devicetree_generated.h:3756:145: error: 'DT_N_S_keymap_S_symbol_layer_P_bindings_IDX_12_PH_P_label' undeclared here (not in a function); did you mean 'DT_N_S_keymap_S_symbol_layer_P_bindings_IDX_16_PH'?\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v1 Default Keymap with nice!view\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v1 keyboard using the default keymap and enabling support for nice!view displays. The `-DSHIELD` parameter now includes `nice_view_adapter` and `nice_view` in addition to the base shield name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_left nice_view_adapter nice_view\"\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_right nice_view_adapter nice_view\"\n```\n\n----------------------------------------\n\nTITLE: Enabling nice!view SPI in keymap File\nDESCRIPTION: This code snippet shows how to enable the nice!view display by uncommenting the SPI configuration block in the `leeloo[_rev2].keymap` file. The forward slashes `//` need to be removed to activate the `nice_view_spi` configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_4\n\nLANGUAGE: kconfig\nCODE:\n```\nnice_view_spi: &spi0 {\n    cs-gpios = <&pro_micro 4 GPIO_ACTIVE_HIGH>;\n};\n```\n\n----------------------------------------\n\nTITLE: Check Python Version (Shell)\nDESCRIPTION: This command checks the installed Python version to ensure it's 3.10 or newer, as required by ZMK CLI. It handles potential variations in command names (`python` vs. `python3`).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npython3 --version\n```\n\n----------------------------------------\n\nTITLE: Sticky Key Behavior Binding with Complex Keycode\nDESCRIPTION: This snippet illustrates how to bind a sticky key behavior to a more complex keycode using the `&sk` reference in a device tree source file. The example uses a combination of left GUI, left shift, left Alt and left Ctrl. The keycode is passed as a parameter.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-key.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n&sk LG(LS(LA(LCTRL)))\n```\n\n----------------------------------------\n\nTITLE: Disable External Power - DTS\nDESCRIPTION: This code snippet shows how to use the `&ext_power` behavior binding to disable external power in a DTS file. The `EP_OFF` parameter specifies the 'disable' command. When triggered, this behavior will deactivate the external power supply.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/power.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&ext_power EP_OFF\n```\n\n----------------------------------------\n\nTITLE: Configure Kconfig.shield for ZMK Keyboard Dongle\nDESCRIPTION: This code snippet defines a Kconfig shield configuration for a ZMK keyboard dongle. It uses the `shields_list_contains` function to conditionally enable the shield based on whether the keyboard name is present in the shields list. Replace `SHIELD_MY_KEYBOARD_DONGLE` and `my_keyboard_dongle` with your specific keyboard identifiers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_0\n\nLANGUAGE: kconfig\nCODE:\n```\n# No whitespace after the comma or in the keyboard name!\nconfig SHIELD_MY_KEYBOARD_DONGLE\n    def_bool $(shields_list_contains,my_keyboard_dongle)\n```\n\n----------------------------------------\n\nTITLE: Building From zmk-config Folder\nDESCRIPTION: Builds ZMK firmware using configuration files from a `zmk-config` folder.  The `-DZMK_CONFIG` define specifies the path to the `config` folder within the `zmk-config` directory.  This allows users to build with their custom keymaps and settings.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b nice_nano -- -DSHIELD=kyria_left \\\n  -DZMK_CONFIG=\"C:/Users/myUser/Documents/Github/zmk-config/config\"\n```\n\n----------------------------------------\n\nTITLE: Defining Metadata in YAML\nDESCRIPTION: This code snippet provides an example of the YAML structure used for hardware metadata in ZMK. It includes information such as the file format version, keyboard ID, name, type, URL, required components, exposed features, and siblings.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_18\n\nLANGUAGE: yaml\nCODE:\n```\nfile_format: \"1\"\nid: corne\nname: Corne\ntype: shield\nurl: https://github.com/foostan/crkbd/\nrequires: [pro_micro]\nexposes: [i2c_oled]\nfeatures:\n  - keys\n  - display\nsiblings:\n  - corne_left\n  - corne_right\n```\n\n----------------------------------------\n\nTITLE: New I2C Configuration with Pinctrl\nDESCRIPTION: This DTS snippet demonstrates the updated method of configuring I2C using pinctrl, referencing named pinctrl configurations for default and sleep states.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n&i2c0 {\n\tcompatible = \"nordic,nrf-twi\";\n\tpinctrl-0 = <&i2c0_default>;\n\tpinctrl-1 = <&i2c0_sleep>;\n\tpinctrl-names = \"default\", \"sleep\";\n};\n```\n\n----------------------------------------\n\nTITLE: Adding extra layers in keymap.dts\nDESCRIPTION: This snippet shows how to add extra layers to the ZMK keymap that will be available for use in ZMK Studio. By defining layers with `status = \"reserved\";`, these layers will be ignored in regular ZMK builds but can be configured and used through ZMK Studio. `display-name` and `bindings` are omitted for these layers because they will be defined via ZMK Studio.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/studio.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        base {\n            display-name = \"Base\";\n            bindings = // etc.\n        };\n\n        fn_layer {\n            display-name = \"Fn\";\n            bindings = // etc.\n        };\n\n        extra1 {\n            status = \"reserved\";\n        };\n\n        extra2 {\n            status = \"reserved\";\n        };\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: ZMK Studio Unlock Behavior Binding - DTS\nDESCRIPTION: This code snippet demonstrates how to bind the `&studio_unlock` behavior in a ZMK device tree source (DTS) file.  Binding this behavior enables ZMK Studio to make changes to the device's configuration. No parameters are required for this behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/studio-unlock.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&studio_unlock\n```\n\n----------------------------------------\n\nTITLE: Building Left Side of Split Keyboard\nDESCRIPTION: Builds ZMK firmware for the left side of a split keyboard, specifying a separate build directory. This avoids overwriting the firmware for the right side. The `-d` flag specifies the build directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nwest build -d build/left -b nice_nano_v2 -- -DSHIELD=kyria_left\n```\n\n----------------------------------------\n\nTITLE: Defining a behavior in a .dtsi file\nDESCRIPTION: This code snippet demonstrates how to define a keyboard behavior in a `.dtsi` file for ZMK firmware.  It showcases the structure of a behavior definition, including the compatible property, binding cells, bindings, and modifiers.  The `/omit-if-no-ref/` directive is essential for optional behavior inclusion.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_8\n\nLANGUAGE: DTS\nCODE:\n```\n/*\n * Copyright (c) 2020 The ZMK Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n\n#include <dt-bindings/zmk/keys.h>\n\n/ {\n    behaviors {\n        /omit-if-no-ref/ gresc: grave_escape {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp ESC>, <&kp GRAVE>;\n            mods = <(MOD_LGUI|MOD_LSFT|MOD_RGUI|MOD_RSFT)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Two Axis Input Behavior Devicetree Binding\nDESCRIPTION: Describes the device tree binding for the `zmk,behavior-input-two-axis` compatible. It specifies properties like `#binding-cells`, `x-input-code`, `y-input-code`, `trigger-period-ms`, `delay-ms`, `time-to-max-speed-ms`, and `acceleration-exponent` to configure two-axis input behavior for generating X/Y and scroll input events.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_11\n\n\n\n----------------------------------------\n\nTITLE: Configure Soft Off Behavior Instance in ZMK (DTS)\nDESCRIPTION: This code snippet shows how to create a `hw_soft_off` behavior instance within the `behaviors` node of a ZMK firmware's device tree overlay (.overlay or .dts) file.  It sets the `compatible` property to \"zmk,behavior-soft-off\" to associate it with the soft-off behavior. It includes configuration options such as `split-peripheral-off-on-press` for reliability and `hold-time-ms` to define the key press hold duration required to trigger the soft-off state. This instance can then be referenced in keymaps.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_soft-off-behavior.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    behaviors {\n        hw_soft_off: hw_soft_off {\n            compatible = \"zmk,behavior-soft-off\";\n            #binding-cells = <0>;\n            split-peripheral-off-on-press; // Turn peripheral off immediately for reliability\n            hold-time-ms = <2000>; // Only turn off if the key is held for 2 seconds or longer.\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Self-contained Keyboard File Structure\nDESCRIPTION: This code snippet showcases the typical file structure found in a self-contained keyboard definition within the ZMK firmware. It includes Kconfig files, devicetree files, a keymap file, a CMake file, and a metadata file.  The files are located under `<board_root>/boards/<arch>/<keyboard_name>/`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/index.mdx#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n<keyboard_name>\n├── Kconfig.board\n├── Kconfig.defconfig\n├── <board_name>_defconfig\n├── <board_name>.dts\n├── <keyboard_name>.keymap\n├── board.cmake\n└── <keyboard_name>.zmk.yml\n```\n\n----------------------------------------\n\nTITLE: Keeping selective behaviors in keymap.dts\nDESCRIPTION: This snippet demonstrates how to selectively include only specific behaviors in the ZMK firmware build when ZMK Studio is enabled. By undefining `ZMK_BEHAVIORS_KEEP_ALL` and then defining `ZMK_BEHAVIORS_KEEP_SK`, `ZMK_BEHAVIORS_KEEP_MT`, and `ZMK_BEHAVIORS_KEEP_KT`, only the `&sk`, `&mt`, and `&kt` behaviors will be included in the firmware. This is used to have more control over what behaviors are built.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/studio.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n#undef ZMK_BEHAVIORS_KEEP_ALL\n\n#define ZMK_BEHAVIORS_KEEP_SK\n#define ZMK_BEHAVIORS_KEEP_MT\n#define ZMK_BEHAVIORS_KEEP_KT\n\n#include <behaviors.dtsi>\n```\n\n----------------------------------------\n\nTITLE: Enable USB Logging via Kconfig - INI\nDESCRIPTION: This snippet shows how to enable USB logging by setting the `CONFIG_ZMK_USB_LOGGING` Kconfig symbol to `y` in the `config/<your_keyboard>.conf` file, or other config files. This method is used if the `zmk-usb-logging` snippet is not supported.  This also sets the ZMK logging level to debug.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_5\n\nLANGUAGE: ini\nCODE:\n```\n# Turn on logging, and set ZMK logging to debug output\nCONFIG_ZMK_USB_LOGGING=y\n```\n\n----------------------------------------\n\nTITLE: Installing west using pip\nDESCRIPTION: Installs the `west` tool using `pip`.  `west` is used for managing Zephyr projects. Requires `pip` to be installed and configured.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\npip install west\n```\n\n----------------------------------------\n\nTITLE: Using Macro Parameters in Bindings (DTS)\nDESCRIPTION: This code shows how to use parameter controls (e.g., `&macro_param_1to1`) to pass parameters into behaviors within a macro's `bindings`. The `MACRO_PLACEHOLDER` is a convention that should be used to make it clear the actual value is overwritten by the macro parameter.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\nbindings = <&macro_param_1to1>, <&kp MACRO_PLACEHOLDER>;\n```\n\n----------------------------------------\n\nTITLE: Building and Flashing nRF5340 Network Core Firmware\nDESCRIPTION: Builds and flashes the firmware for the nRF5340 development kit's network core. This is required for dual-chip Bluetooth boards where the Bluetooth host and controller run on separate processors.  The firmware only needs to be updated when upgrading to a new Zephyr version.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ncd zephyr/samples/bluetooth/hci_rpmsg\nwest build -b nrf5340dk_nrf5340_cpunet\nwest flash\n```\n\n----------------------------------------\n\nTITLE: Binding for Down Mouse Scroll\nDESCRIPTION: This example configures a behavior binding to send a scroll down event to the host when pressed or held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n&msc SCRL_DOWN\n```\n\n----------------------------------------\n\nTITLE: Building ZMK for Onboard MCU Keyboard\nDESCRIPTION: Builds ZMK firmware for a keyboard with an onboard MCU. The `-b` flag specifies the Zephyr board, which corresponds to the keyboard. The built firmware can then be flashed to the device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b planck_rev6\n```\n\n----------------------------------------\n\nTITLE: Update GitHub Actions Build Configuration - YAML\nDESCRIPTION: This snippet demonstrates how to update the `.github/workflows/build.yml` file in a user config repository to use the shared ZMK build configuration for Zephyr 3.5. It replaces the existing content to reference the `zmkfirmware/zmk/.github/workflows/build-user-config.yml@main` workflow. This ensures the user config utilizes the correct Docker image for building.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-02-09-zephyr-3-5.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\non: [push, pull_request, workflow_dispatch]\n\njobs:\n  build:\n    uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main\n```\n\n----------------------------------------\n\nTITLE: Driver/Bus Node Adjustment for RP2040 - DTS\nDESCRIPTION: This snippet demonstrates adjusting the `spi0` node for the RP2040 microcontroller, assigning the `spi0_default` pinctrl state. It uses the `pinctrl-0` and `pinctrl-names` properties to associate the pin configuration with the `default` state.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n&spi0 {\n    pinctrl-0 = <&spi0_default>;\n    pinctrl-names = \"default\";\n};\n```\n\n----------------------------------------\n\nTITLE: Modifying Devicetree Property without Label (DTS)\nDESCRIPTION: Demonstrates modifying a Devicetree property when a node doesn't have a label, writing a new tree structure to override existing properties, setting `debounce-press-ms` of the `kscan` node to 0.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan {\n        debounce-press-ms = <0>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Mouse Velocities\nDESCRIPTION: This snippet shows how to override the default movement and scrolling max velocities before including the `dt-bindings/zmk/pointing.h` header.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\n#define ZMK_POINTING_DEFAULT_MOVE_VAL 1500  // default: 600\n#define ZMK_POINTING_DEFAULT_SCRL_VAL 20    // default: 10\n\n#include <dt-bindings/zmk/pointing.h>\n```\n\n----------------------------------------\n\nTITLE: Defining Position Map for 2x2 Macropad - DTS\nDESCRIPTION: This snippet shows how to define a position map for a 2x2 macropad. The `positions` array maps each key to a numerical position, corresponding to the `keys` property of its physical layout. The physical layout is referenced using the `physical-layout` property.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map {\n        // Other properties\n\n        macropad_map: macropad {\n            physical-layout = <&macropad_layout>;\n            positions // This is equivalent to `positions = <0 1 2 3>;`, reshaped for readability\n                = < 0  1 >\n                , < 2  3 >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Including physical_layouts.dtsi for Keys Property in DTS\nDESCRIPTION: Includes the `physical_layouts.dtsi` file. This is necessary to use the `keys` property, which defines the physical attributes of each key position for ZMK Studio support. It is required when creating layouts that will be used with ZMK Studio.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include <physical_layouts.dtsi>\n```\n\n----------------------------------------\n\nTITLE: Applying Modifiers to Keycodes in Keymap - DTS\nDESCRIPTION: This code snippet demonstrates how to apply modifiers to keycodes in a ZMK keymap.  It uses the `&kp` behavior along with a modifier and keycode. For example, `LC(C)` sends `Control + c` when pressed. The feature allows for \"shifted keycodes\", where a modifier and a number can produce a symbol, such as `LS(N1)` to send `!`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-11-09-zmk-sotf-3.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&kp LC(C)\n```\n\n----------------------------------------\n\nTITLE: Adding Python scripts directory to PATH (Powershell)\nDESCRIPTION: Adds the Python scripts directory to the PATH environment variable on Windows using PowerShell.  This ensures that globally installed Python scripts are accessible.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_13\n\nLANGUAGE: powershell\nCODE:\n```\n$Scripts = python -c \"import sysconfig; print(sysconfig.get_path('scripts'))\"\n$Path = [Environment]::GetEnvironmentVariable('PATH', 'User')\n[Environment]::SetEnvironmentVariable('PATH', \"$Path;$Scripts\", 'User')\n$env:PATH += \";$Scripts\"\n```\n\n----------------------------------------\n\nTITLE: Using Locale-Specific Key Codes in Keymap (DTS)\nDESCRIPTION: This snippet demonstrates how to use locale-specific key codes defined in the included header file within a ZMK keymap.  It is shown using German keycodes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-01-05-zmk-tools.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n#include \"keys_de.h\"\n\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                &kp DE_Q &kp DE_W &kp DE_E &kp DE_R &kp DE_T &kp DE_Z ...\n            >;\n        };\n    }\n};\n\n```\n\n----------------------------------------\n\nTITLE: Module Management Commands (Shell)\nDESCRIPTION: These commands demonstrate how to add, remove, list, and update ZMK modules. Modules extend the functionality of ZMK with new keyboards, behaviors, and features.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nzmk module add     # Add a module\nzmk module remove  # Remove an installed module\nzmk module list    # List the installed modules\nzmk update         # Update the local copies of ZMK and modules to their latest versions\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware for BDN9\nDESCRIPTION: This command builds the ZMK firmware for the BDN9 keyboard using the West build tool. It specifies the board as 'bdn9_rev2' and sets the build directory to 'build/bdn9'. The '-p' flag enables pristine builds.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/bdn9/README.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\nwest build -p -d build/bdn9 --board bdn9_rev2\n```\n\n----------------------------------------\n\nTITLE: Building Custom Keymap for Leeloo-Micro (ZMK)\nDESCRIPTION: These commands build the ZMK firmware for the left and right halves of the Leeloo-Micro keyboard using a custom keymap. It utilizes `west build` with the `nice_nano_v2` board, specifying the `leeloo_micro_left` and `leeloo_micro_right` shields, and sets the `ZMK_CONFIG` variable to the path of the custom keymap configuration file. This command assumes a shell environment and requires `west` tool to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo_micro/README.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=leeloo_micro_right -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo_micro/config\"\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=leeloo_micro_left -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo_micro/config\"\n```\n\n----------------------------------------\n\nTITLE: Installing Zephyr dependencies globally with pip (Windows)\nDESCRIPTION: Installs Zephyr dependencies globally using `pip` from the `requirements-base.txt` file. This is specific for Windows.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\npip install -r zephyr/scripts/requirements-base.txt\n```\n\n----------------------------------------\n\nTITLE: Enabling ZMK Studio in build.yaml\nDESCRIPTION: This snippet demonstrates how to enable the `studio-rpc-usb-uart` snippet and the `ZMK_STUDIO` Kconfig setting in the `build.yaml` file for a ZMK keyboard build. This is necessary for enabling ZMK Studio support for your keyboard firmware. The example shows a split keyboard configuration where the snippet and setting are applied only to the left side.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/studio.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\ninclude:\n  - board: nice_nano_v2\n    shield: corne_left\n    snippet: studio-rpc-usb-uart\n    cmake-args: -DCONFIG_ZMK_STUDIO=y\n  - board: nice_nano_v2\n    shield: corne_right\n```\n\n----------------------------------------\n\nTITLE: Building with Specified Build Directory\nDESCRIPTION: Builds ZMK firmware using a specified build directory. This can be used to avoid conflicts between different builds. The `-d` flag specifies the build directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nwest build -d <build_dir>\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Transformer Instance - DTS\nDESCRIPTION: This code snippet demonstrates how to define a custom instance of the transform input processor within a Device Tree Source (DTS) overlay file. It defines a node named `my_rotation_event_transform` with properties such as `compatible`, `#input-processor-cells`, `type`, `x-codes`, and `y-codes` to configure the processor. This custom instance can then be used to transform specific rotation events, RX and RY, within the defined event type, `INPUT_EV_REL`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/transformer.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include <zephyr/dt-bindings/input/input-event-codes.h>\n\n/ {\n    input_processors {\n        my_rotation_event_transform: my_rotation_event_transform {\n            compatible = \"zmk,input-processor-transform\";\n            #input-processor-cells = <1>;\n            type = <INPUT_EV_REL>;\n            x-codes = <INPUT_REL_RX>;\n            y-codes = <INPUT_REL_RY>;\n        };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling SPI in ZMK .defconfig\nDESCRIPTION: This code snippet shows how to enable SPI communication in the ZMK firmware configuration file (`.defconfig`). Enabling SPI is a prerequisite for using shift registers as they communicate via the SPI bus.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/shift-registers.md#_snippet_0\n\nLANGUAGE: kconfig\nCODE:\n```\nconfig SPI\n    default y\n```\n\n----------------------------------------\n\nTITLE: Conditional Subdirectory Inclusion in ZMK (CMake)\nDESCRIPTION: This CMake command conditionally includes the `zmk_debounce` subdirectory in the build process. It checks if the `CONFIG_ZMK_DEBOUNCE` Kconfig option is enabled. If it is, the `zmk_debounce` subdirectory is added; otherwise, it is skipped. This allows for modular inclusion of features based on the configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/lib/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_ZMK_DEBOUNCE zmk_debounce)\n```\n\n----------------------------------------\n\nTITLE: Conditional Status Screen Source Inclusion\nDESCRIPTION: This CMake command conditionally adds `status_screen.c` to the application's source files if both `CONFIG_ZMK_DISPLAY` and `CONFIG_ZMK_DISPLAY_STATUS_SCREEN_BUILT_IN` configuration options are enabled. This includes a built-in status screen functionality when available.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_DISPLAY_STATUS_SCREEN_BUILT_IN app PRIVATE status_screen.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring Zephyr environment variables (Raspberry OS)\nDESCRIPTION: Configures Zephyr with environment variables to use the ARM cross-compile toolchain on Raspberry Pi OS.  This involves setting `ZEPHYR_TOOLCHAIN_VARIANT` and `CROSS_COMPILE` in the `~/.zephyrrc` file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\nexport ZEPHYR_TOOLCHAIN_VARIANT=cross-compile\nexport CROSS_COMPILE=/usr/bin/arm-none-eabi-\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v1 Custom Keymap with ZMK\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v1 keyboard with a custom keymap. It extends the default build by adding the `-DZMK_CONFIG` parameter, which specifies the path to the custom keymap configuration file. Replace `C:/dev/zmk/[yourName]/leeloo/config` with the actual path.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=leeloo_right -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo/config\"\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=leeloo_left -DZMK_CONFIG=\"C:/dev/zmk/[yourName]/leeloo/config\"\n```\n\n----------------------------------------\n\nTITLE: Applying Input Processors to Mouse Button Press\nDESCRIPTION: This example demonstrates how to apply input processors to the `&mkp` behavior using `&mkp_input_listener`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n&mkp_input_listener {\n    input-processors = <&zip_temp_layer 2 2000>;\n}\n```\n\n----------------------------------------\n\nTITLE: USB Logging Devicetree Configuration (DTS)\nDESCRIPTION: This snippet shows how to configure USB logging using the CDC ACM device in the devicetree. It adds a `cdc_acm_uart` node under the `usbd` device and creates a `zephyr,console` alias in the `chosen` node, pointing to the `cdc_acm_uart` node. This enables USB logging in Zephyr 3.0.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&usbd {\n  status = \"okay\";\n  cdc_acm_uart: cdc_acm_uart {\n    compatible = \"zephyr,cdc-acm-uart\";\n  };\n};\n\n```\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n  chosen {\n    ...\n    zephyr,console = &cdc_acm_uart;\n  };\n  ...\n};\n```\n\n----------------------------------------\n\nTITLE: Peripheral Overlay for Input Split Device\nDESCRIPTION: This snippet shows the peripheral part's overlay configuration for a split keyboard setup with a pointing device using input split. It includes the shared .dtsi file, and updates the input split device with the pointing device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n// Pull in the shared configuration\n#include \"<keyboard>.dtsi\"\n\n// Node from the previous Input Device section\n&pro_micro_spi {\n    /* ... */\n\n    glidepoint: glidepoint@0 {\n        /* ... */\n    };\n};\n\n// Overrides for the input-split child node\n&glidepoint_split {\n    device = <&glidepoint>;\n\n    // Optional\n    input-processors = <&zip_xy_transform (INPUT_TRANSFORM_XY_SWAP | INPUT_TRANSFORM_X_INVERT | INPUT_TRANSFORM_Y_INVERT)>;\n};\n```\n\n----------------------------------------\n\nTITLE: ZMK West Manifest with Alternative Branch\nDESCRIPTION: This YAML configuration shows how to use a forked repository and a specific branch to test features. It modifies the `zmk` project to point to the forked repository and the specified branch.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/modules.mdx#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  remotes:\n    - name: zmkfirmware\n      url-base: https://github.com/zmkfirmware\n    - name: forkedzmk\n      url-base: https://github.com/forkedzmk\n  projects:\n    - name: zmk\n      remote: forkedzmk\n      revision: specificpr\n      import: app/west.yml\n  self:\n    path: config\n```\n\n----------------------------------------\n\nTITLE: Advanced Mouse Scroll Configuration\nDESCRIPTION: This snippet shows the default settings for the `&msc` behavior, an instance of `zmk,behavior-input-two-axis`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_13\n\nLANGUAGE: dts\nCODE:\n```\n&msc {\n    x-input-code = <INPUT_REL_HWHEEL>;\n    y-input-code = <INPUT_REL_WHEEL>;\n    time-to-max-speed-ms = <300>;\n    acceleration-exponent = <0>;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Mod-Morph Behavior in ZMK\nDESCRIPTION: This code snippet demonstrates how to define a mod-morph behavior in ZMK's Devicetree configuration. It shows the standard, verbose way of creating a behavior node with properties like `compatible`, `#binding-cells`, `bindings`, and `mods`. This is the typical boilerplate that the `zmk-nodefree-config` project aims to simplify.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-12-17-nodefree-config.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    behaviors {\n        dot_colon: dot_colon_behavior {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp DOT>, <&kp COLON>;\n            mods = <(MOD_LSFT|MOD_RSFT)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Activating a Python virtual environment (CMD)\nDESCRIPTION: Activates a Python virtual environment on Windows using the Command Prompt.  Assumes the virtual environment is located in the `.venv` directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n.venv\\Scripts\\activate.bat\n```\n\n----------------------------------------\n\nTITLE: Building ZMK locally with ZMK Studio support\nDESCRIPTION: This snippet shows how to build ZMK firmware locally with ZMK Studio support using the `west build` command.  It includes the `studio-rpc-usb-uart` snippet and sets the `CONFIG_ZMK_STUDIO` Kconfig option. This command is used when building the firmware from the command line.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/studio.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwest build -d build/cl_studio -b nice_nano_v2 \\\n  -S studio-rpc-usb-uart -- -DSHIELD=corne_left -DCONFIG_ZMK_STUDIO=y\n```\n\n----------------------------------------\n\nTITLE: Accessing Behavior Data in C\nDESCRIPTION: This C code shows how to access the behavior-specific data associated with a behavior instance. It retrieves the device and then the data struct from the keybinding.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\nconst struct device *dev = zmk_behavior_get_binding(binding->behavior_dev);\nstruct behavior_<behavior_name>_data *data = dev->data;\n```\n\n----------------------------------------\n\nTITLE: Configuring Matrix Transform in ZMK\nDESCRIPTION: This snippet configures the matrix transform in ZMK firmware to enable the 1x2u layout for the REVIUNG34 keyboard. It adds a `chosen` node with a `zmk,matrix-transform` property pointing to the `single_2u_transform` label.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/reviung34/README.md#_snippet_0\n\nLANGUAGE: devicetree\nCODE:\n```\n/ {\n    chosen {\n        zmk,matrix-transform = &single_2u_transform;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Update GitHub Actions Build Workflow - YAML\nDESCRIPTION: Updates the `.github/workflows/build.yml` file in a user configuration repository to use the shared ZMK build configuration. This ensures the repository leverages the correct Docker image for building with Zephyr 3.2. The file is replaced with a reference to the shared ZMK build workflow.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\non: [push, pull_request, workflow_dispatch]\n\njobs:\n  build:\n    uses: zmkfirmware/zmk/.github/workflows/build-user-config.yml@main\n```\n\n----------------------------------------\n\nTITLE: Central Overlay for Input Split Device\nDESCRIPTION: This code enables the input listener on the central side when using an input split device configuration, receiving the events from the peripheral.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<keyboard>.dtsi\"\n\n&glidepoint_listener {\n    status = \"okay\";\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing Position Map Node - DTS\nDESCRIPTION: This code snippet demonstrates how to create the parent node for defining a position map in a Device Tree Source (DTS) file. The `compatible` property identifies the node as a ZMK physical layout position map. The `complete` property is optional and indicates whether all key positions are mapped.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map {\n        compatible = \"zmk,physical-layout-position-map\";\n        complete; // Optional, see 'Example non-complete position map'\n\n        // Child node 1 here\n\n        // Child node 2 here\n\n        // ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: NRFX QDEC Configuration DTS\nDESCRIPTION: Example of configuring the NRFX QDEC driver for encoders on Nordic MCUs. This includes pin control settings and encoder-specific configuration with `steps` and pinctrl definitions.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-06-18-encoder-refactors.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    qdec_default: qdec_default {\n        group1 {\n            psels = <NRF_PSEL(QDEC_A, 1, 11)>,\n                    <NRF_PSEL(QDEC_B, 1, 10)>;\n            bias-pull-up;\n        };\n    };\n};\n\n// Set up the QDEC hardware based driver and give it the same label as the deleted node.\nencoder: &qdec0 {\n    status = \"okay\";\n    led-pre = <0>;\n    steps = <80>;\n    pinctrl-0 = <&qdec_default>;\n    pinctrl-names = \"default\";\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard Sensor Rotation Behavior in ZMK with DeviceTree\nDESCRIPTION: This snippet demonstrates how to configure the standard sensor rotation behavior in ZMK firmware using DeviceTree syntax. It binds the RGB Underglow Behavior to change RGB brightness based on the direction of sensor rotation. Rotating clockwise increases brightness (RGB_BRI), and counter-clockwise decreases brightness (RGB_BRD).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sensor-rotate.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        rgb_encoder: rgb_encoder {\n            compatible = \"zmk,behavior-sensor-rotate\";\n            #sensor-binding-cells = <0>;\n            bindings = <&rgb_ug RGB_BRI>, <&rgb_ug RGB_BRD>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        base {\n            ...\n            sensor-bindings = <&rgb_encoder>;\n        }\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Setting Output to USB\nDESCRIPTION: This code snippet demonstrates how to configure a behavior binding to prefer sending keyboard output to USB. The `&out` reference indicates the output selection behavior, and `OUT_USB` specifies that USB should be the preferred output.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/outputs.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n&out OUT_USB\n```\n\n----------------------------------------\n\nTITLE: Enabling NVS Logging\nDESCRIPTION: This snippet demonstrates how to enable logging for the NVS (Non-Volatile Storage) module in the ZMK firmware. Setting the `CONFIG_NVS_LOG_LEVEL_DBG` to `y` in the `.conf` file allows for detailed debugging information from the NVS module, which is useful for troubleshooting issues related to settings storage.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-10-03-bootloader-fix.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\nCONFIG_NVS_LOG_LEVEL_DBG=y\n```\n\n----------------------------------------\n\nTITLE: Define a Zephyr library (CMake)\nDESCRIPTION: This snippet defines a Zephyr library. It doesn't specify any sources or include directories directly, but it serves as a base for adding sources and include directories in subsequent conditional blocks.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/corneish_zen/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Kscan Configuration for Split Keyboard (Shared)\nDESCRIPTION: This code snippet shows the shared Kscan configuration for a split keyboard in a `dtsi` file. It defines common row GPIOs for both halves of the keyboard, which reduces duplication and simplifies configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan0: kscan0 {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        diode-direction = \"col2row\";\n        wakeup-source;\n\n        row-gpios\n            = <&pro_micro 6 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&pro_micro 7 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&pro_micro 8 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            ;\n\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Root Devicetree Node - DTS\nDESCRIPTION: Demonstrates the basic structure of the root devicetree node in a ZMK keymap file.  All other keymap nodes must be nested inside of it. This node encapsulates the entire keymap configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/index.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    // Everything else goes here!\n};\n```\n\n----------------------------------------\n\nTITLE: Configuration Commands (Shell)\nDESCRIPTION: These commands are used to manage the ZMK CLI's configuration settings, allowing users to list, print, set, and unset configuration values.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\nzmk config                 # List all settings\nzmk config <name>          # Print the value of the setting <name>\nzmk config <name> <value>  # Set <name> to <value>\nzmk config --unset <name>  # Remove the setting <name>\n```\n\n----------------------------------------\n\nTITLE: Devicetree Caps Word Configuration\nDESCRIPTION: Configures the caps word behavior via devicetree, allowing customization of the continue list (keycodes that don't deactivate caps lock) and modifiers to apply when caps word is active. The `continue-list` implicitly includes alphanumeric characters.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_2\n\nLANGUAGE: YAML\nCODE:\n```\n#binding-cells: <0>\ncontinue-list: <UNDERSCORE BACKSPACE DELETE>\nmods: <MOD_LSFT>\n```\n\n----------------------------------------\n\nTITLE: Keymap Example with Code Completion (DTS)\nDESCRIPTION: This snippet demonstrates the code completion features of ZMK Tools in a `.keymap` file. It shows how the extension suggests behaviors and key codes, and automatically adds necessary include headers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-01-05-zmk-tools.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                &\n            >;\n        };\n    };\n};\n\n```\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                &kp\n            >;\n        };\n    };\n};\n\n```\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n#include <dt-bindings/zmk/keys.h>\n/ {\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                &kp A\n            >;\n        };\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Starting the Docusaurus Development Server with npm\nDESCRIPTION: This snippet demonstrates how to start the Docusaurus development server with `npm start`. This allows you to preview your documentation changes locally in a web browser.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm start\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Output Status Widget\nDESCRIPTION: This snippet conditionally includes `output_status.c` into the application build if `CONFIG_ZMK_WIDGET_OUTPUT_STATUS` is defined. The source file is added as a private source to the 'app' target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/widgets/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_WIDGET_OUTPUT_STATUS app PRIVATE output_status.c)\n```\n\n----------------------------------------\n\nTITLE: Conditional Wired Subdirectory Inclusion CMake\nDESCRIPTION: This snippet conditionally includes the wired subdirectory if the `CONFIG_ZMK_SPLIT_WIRED` configuration option is enabled. This enables wired connection support for split keyboards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nif (CONFIG_ZMK_SPLIT_WIRED)\n    add_subdirectory(wired)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Conditionally add icon source files based on widget configurations (CMake)\nDESCRIPTION: This snippet conditionally adds icon source files to the Zephyr library based on whether specific widgets (Battery, Peripheral, Output, Layer) are enabled. The file paths point to icon files in the widgets/icons directory. The `zephyr_library_sources` command adds these sources to the library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/corneish_zen/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_ZMK_DISPLAY)\n  if(CONFIG_CUSTOM_WIDGET_BATTERY_STATUS)\n    zephyr_library_sources(widgets/icons/batt_100.c)\n    zephyr_library_sources(widgets/icons/batt_100_chg.c)\n    zephyr_library_sources(widgets/icons/batt_75.c)\n    zephyr_library_sources(widgets/icons/batt_75_chg.c)\n    zephyr_library_sources(widgets/icons/batt_50.c)\n    zephyr_library_sources(widgets/icons/batt_50_chg.c)\n    zephyr_library_sources(widgets/icons/batt_25.c)\n    zephyr_library_sources(widgets/icons/batt_25_chg.c)\n    zephyr_library_sources(widgets/icons/batt_5.c)\n    zephyr_library_sources(widgets/icons/batt_5_chg.c)\n    zephyr_library_sources(widgets/icons/batt_0.c)\n    zephyr_library_sources(widgets/icons/batt_0_chg.c)\n  endif()\n  if(CONFIG_CUSTOM_WIDGET_PERIPHERAL_STATUS)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_right.c)\n    zephyr_library_sources(widgets/icons/bluetooth_disconnected_right.c)\n  endif()\n  if(CONFIG_CUSTOM_WIDGET_OUTPUT_STATUS)\n    zephyr_library_sources(widgets/icons/USB_connected.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_1.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_2.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_3.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_4.c)\n    zephyr_library_sources(widgets/icons/bluetooth_connected_5.c)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising_1.c)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising_2.c)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising_3.c)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising_4.c)\n    zephyr_library_sources(widgets/icons/bluetooth_advertising_5.c)\n    zephyr_library_sources(widgets/icons/bluetooth_disconnected_right.c)\n  endif()\n  if(CONFIG_CUSTOM_WIDGET_LAYER_STATUS)\n    zephyr_library_sources(widgets/icons/layers.c)\n    zephyr_library_sources(widgets/icons/layers2.c)\n  endif()\n  if(NOT CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n    zephyr_library_sources(widgets/icons/zenlogo.c)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks for Prettier\nDESCRIPTION: This snippet shows how to install pre-commit hooks to automatically run Prettier to format documentation files before each commit. It uses `pip3` to install `pre-commit` and then runs the `pre-commit install` command to set up the hooks in the local Git repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/CONTRIBUTING.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip3 install pre-commit\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: User-Defined Temporary Layer Instance (Devicetree)\nDESCRIPTION: This example demonstrates defining a new instance of the temporary layer input processor in the device tree. It sets the `compatible` property, defines `#input-processor-cells`, and sets user-defined properties like `require-prior-idle-ms` and `excluded-positions`. The `require-prior-idle-ms` property makes the layer activate only after 2000ms of idle time.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/temp-layer.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <zephyr/dt-bindings/input/input-event-codes.h>\n\n/ {\n    /omit-if-no-ref/ zip_temp_layer: zip_temp_layer {\n        compatible = \"zmk,input-processor-temp-layer\";\n        #input-processor-cells = <2>;\n        require-prior-idle-ms = <2000>;\n        excluded-positions = <1 2 3>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Devicetree for Voltage Divider Battery Sensor\nDESCRIPTION: This Devicetree configuration is used for the `zmk,battery-voltage-divider` compatible. It requires using Zephyr's voltage divider documentation for the specific configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/battery.md#_snippet_2\n\nLANGUAGE: Devicetree\nCODE:\n```\ncompatible = \"zmk,battery-voltage-divider\"\n```\n\n----------------------------------------\n\nTITLE: Conditional Layers Configuration in ZMK DTS\nDESCRIPTION: This snippet configures conditional layers in ZMK using the device tree source (DTS) format.  The `tri_layer` conditional layer is defined such that when layers 1 and 2 are active (`if-layers = <1 2>`), then layer 3 is also activated (`then-layer = <3>`). This feature provides a way to automatically activate layers based on the state of other layers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-10-zmk-sotf-5.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    conditional_layers {\n        compatible = \"zmk,conditional-layers\";\n        tri_layer {\n            if-layers = <1 2>;\n            then-layer = <3>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Define a phandle array with multiple blocks in Devicetree\nDESCRIPTION: This example shows how to define a phandle array in a devicetree file using multiple blocks. The array contains node references and numbers.  This is a variation on a phandle array.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\nproperty = <&none>, <&mo 1>;\n```\n\n----------------------------------------\n\nTITLE: Building with Kconfig Flags\nDESCRIPTION: Builds ZMK firmware with a Kconfig flag enabled. This allows customizing the firmware with specific settings. The `-- -DCONFIG_ZMK_SLEEP=y` argument passes the Kconfig flag to the build system.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b planck_rev6 -- -DCONFIG_ZMK_SLEEP=y\n```\n\n----------------------------------------\n\nTITLE: Add Source Files to Zephyr Library\nDESCRIPTION: Specifies the source file `pinmux.c` for the Zephyr library. This indicates that the `pinmux.c` file contains the implementation for the library's functionality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/mikoto/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources(pinmux.c)\n```\n\n----------------------------------------\n\nTITLE: Configuring UART0 Pins for RP2040\nDESCRIPTION: This snippet configures the pins for UART0 on the RP2040. It utilizes the rpi-pico-rp2040-pinctrl.h header for pin definitions and sets P0 as UART0 TX and P1 as UART0 RX, enabling input on P1.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_14\n\nLANGUAGE: dts\nCODE:\n```\n&pinctrl {\n    /* configuration for the usart0 \"default\" state */\n    uart0_default: uart0_default {\n        group1 {\n            /* configure P0 as UART0 TX */\n            pinmux = <UART0_TX_P0>;\n            };\n        group2 {\n            /* configure P1 as UART0 RX */\n            pinmux = <UART0_RX_P1>;\n            /* enable input on pin 1 */\n            input-enable;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Including GPIO Demux Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_gpio_demux.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_GPIO_DEMUX` Kconfig option is defined. This driver handles keyboard scanning using GPIO with a demultiplexer.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_5\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_GPIO_DEMUX kscan_gpio_demux.c)\n```\n\n----------------------------------------\n\nTITLE: Kscan Matrix with Soft Off Input\nDESCRIPTION: This device tree snippet supplements the existing kscan matrix with an additional row for a soft-off input. The added row entry specifies the GPIO pin and its flags. The transform must be present without changing the matrix transform after adding this row. This allows triggering a soft-off behavior based on the state of this additional input.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-matrix.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        diode-direction = \"col2row\";\n        wakeup-source;\n\n        col-gpios\n            = <&gpio0 12 GPIO_ACTIVE_HIGH>\n            , <&gpio1 9  GPIO_ACTIVE_HIGH>\n            ;\n        row-gpios\n            = <&gpio0 19 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&gpio0 4  (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&gpio0 2  (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            ;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Include Input Transform Header - DTS\nDESCRIPTION: This code snippet demonstrates how to include the `input_transform.h` header file in a Device Tree Source (DTS) file. This header provides definitions for various input transform flags used by the transformer input processor in ZMK firmware. This is necessary to utilize the provided transforms like `INPUT_TRANSFORM_XY_SWAP`, `INPUT_TRANSFORM_X_INVERT` and `INPUT_TRANSFORM_Y_INVERT`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/transformer.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/input_transform.h>\n```\n\n----------------------------------------\n\nTITLE: Key Toggle Configuration with Toggle Mode (DTS)\nDESCRIPTION: This code snippet demonstrates how to configure a new key toggle behavior with a specific toggle mode (`toggle-mode`).  Here, a behavior named `kt_on` is created, which only toggles the key on (presses it) and ignores the off state.  The compatible string `zmk,behavior-key-toggle` indicates that this is a key toggle behavior, and `#binding-cells = <1>` is required.  `display-name` is used for display purposes in tools.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-toggle.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        kt_on: key_toggle_on_only {\n            compatible = \"zmk,behavior-key-toggle\";\n            #binding-cells = <1>;\n            display-name = \"Key Toggle On\";\n            toggle-mode = \"on\";\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: STM32 Clock Configuration (DTS)\nDESCRIPTION: This snippet demonstrates configuring the clock settings for an STM32 board in the devicetree.  It configures the HSI clock, PLL, and RCC nodes. It also requires that the corresponding clock/PLL settings are removed from the `<board>_defconfig` file.  This example uses the HSI clock as the PLL source.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n&clk_hsi {\n  status = \"okay\";\n};\n\n&pll {\n  prediv = <1>;\n  mul = <12>;\n  clocks = <&clk_hsi>;\n  status = \"okay\";\n};\n\n&rcc {\n  clocks = <&pll>;\n  clock-frequency = <DT_FREQ_M(72)>;\n  ahb-prescaler = <1>;\n  apb1-prescaler = <2>;\n};\n```\n\n----------------------------------------\n\nTITLE: Initialize ZMK Repository (Shell)\nDESCRIPTION: These commands navigate to a directory and initialize a ZMK repository using the `zmk init` command.  This sets up the environment for working with ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ncd ~/Documents\nzmk init\n```\n\n----------------------------------------\n\nTITLE: Add Conditional Zephyr Library Sources\nDESCRIPTION: This command conditionally adds a source file to the Zephyr library based on the value of the `CONFIG_EC11_TRIGGER` configuration option. If `CONFIG_EC11_TRIGGER` is defined, `ec11_trigger.c` will be included as a source file. This likely adds trigger-based functionality to the EC11 driver.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/ec11/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_EC11_TRIGGER ec11_trigger.c)\n```\n\n----------------------------------------\n\nTITLE: Devicetree for nRF VDDH Battery Sensor\nDESCRIPTION: This Devicetree configuration is used for the `zmk,battery-nrf-vddh` compatible. It has no configuration options in the Devicetree.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/battery.md#_snippet_3\n\nLANGUAGE: Devicetree\nCODE:\n```\ncompatible = \"zmk,battery-nrf-vddh\"\n```\n\n----------------------------------------\n\nTITLE: Defining Item ID and Name\nDESCRIPTION: Demonstrates how to define the ID and name of the hardware item. The `id` property is the unique identifier, and the `name` property is the human-readable display name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nid: corne\nname: Corne\n```\n\n----------------------------------------\n\nTITLE: Updating Docker Image in GitHub Actions YAML\nDESCRIPTION: This snippet describes how to update the Docker image tag in the `.github/workflows/build.yml` file of a ZMK user configuration repository. This is necessary to ensure continued compatibility with the ZMK codebase on Zephyr 3.0. The change involves replacing `zmkfirmware/zmk-build-arm:2.5` with `zmkfirmware/zmk-build-arm:stable`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-03-08-zephyr-3-0-upgrade-prep.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n- Open `.github/workflows/build.yml` in your editor/IDE\n- Change `zmkfirmware/zmk-build-arm:2.5` to `zmkfirmware/zmk-build-arm:stable` wherever it is found\n```\n\n----------------------------------------\n\nTITLE: Enabling NKRO HID Report Type in ZMK Configuration\nDESCRIPTION: This code snippet demonstrates how to enable NKRO (N-Key Rollover) HID report type in ZMK by adding the `CONFIG_ZMK_HID_REPORT_TYPE_NKRO=y` line to your `.conf` file. NKRO allows all simultaneously pressed keys to be registered by the host device, overcoming the limitations of standard USB keyboard protocols. Note: This snippet is intended for placement in a `.conf` file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-10-zmk-sotf-5.md#_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_HID_REPORT_TYPE_NKRO=y\n```\n\n----------------------------------------\n\nTITLE: Per-Driver Debounce Configuration in ZMK\nDESCRIPTION: This code snippet demonstrates how to configure per-driver debounce settings for key press and release events within a specific kscan node using Devicetree. It adjusts the debounce time for a particular driver instance. Values must be less than or equal to 16383.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/debouncing.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&kscan0 {\n    debounce-press-ms = <3>;\n    debounce-release-ms = <3>;\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Mod-Morph Behavior with ZMK_BEHAVIOR Macro\nDESCRIPTION: This code snippet shows how the `ZMK_BEHAVIOR` macro from the `zmk-nodefree-config` project simplifies the definition of the mod-morph behavior. It eliminates the boilerplate code required for creating the behavior node and setting its properties, making the configuration more readable and less error-prone.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-12-17-nodefree-config.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\nZMK_BEHAVIOR(dot_colon, mod_morph,\n    bindings = <&kp DOT>, <&kp COLON>;\n    mods = <(MOD_LSFT|MOD_RSFT)>;\n)\n```\n\n----------------------------------------\n\nTITLE: Change Directory to App Subdirectory\nDESCRIPTION: Changes the current directory to the `app` subdirectory of the ZMK checkout. This is a necessary step before building or flashing ZMK firmware, as the build process expects to be run from this location. Failing to do so will result in an error.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd app\n```\n\n----------------------------------------\n\nTITLE: Including GPIO Charlieplex Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_gpio_charlieplex.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_GPIO_CHARLIEPLEX` Kconfig option is defined. This driver handles keyboard scanning using a GPIO charlieplexing configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_3\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_GPIO_CHARLIEPLEX kscan_gpio_charlieplex.c)\n```\n\n----------------------------------------\n\nTITLE: Building Podman Container Image\nDESCRIPTION: Builds a container image from a Dockerfile using Podman.  Creates a reusable image for the ZMK development environment. Requires Podman to be installed and a Dockerfile present.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\npodman build -t <container-name> -f Dockerfile </path/to/.devcontainer>\n```\n\n----------------------------------------\n\nTITLE: Cloning ZMK repository using Git\nDESCRIPTION: Clones the ZMK source repository from GitHub. Requires Git to be installed and configured.  Navigates into the cloned repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/zmkfirmware/zmk.git\n```\n\nLANGUAGE: sh\nCODE:\n```\ncd zmk\n```\n\n----------------------------------------\n\nTITLE: RP2040 PIO Configuration - DTS\nDESCRIPTION: This snippet shows how to configure the RP2040 PIO block for SPI usage. It enables the `pio0` node, assigns the `pio0_spi_default` pinctrl state, and sets the `compatible` property. The code also defines properties such as `clocks`, `clock-frequency`, `miso-gpios`, `clk-gpios`, `mosi-gpios`, and `cs-gpios`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_11\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&pio0 {\n    /* enables this PIO block */\n    status = \"okay\";\n    pio0_spi: pio0_spi {\n        /* Assign pinctrl to node */\n        pinctrl-0 = <&pio0_spi_default>;\n        pinctrl-names = \"default\";\n        compatible = \"raspberrypi,pico-spi-pio\";\n        #address-cells = <1>;\n        #size-cells = <0>;\n        clocks = <&system_clk>;\n        clock-frequency = <4000000>;\n        /* These pins should be the same as in pinctrl */\n        miso-gpios = <&gpio0 12 0>;\n        clk-gpios = <&gpio0 14 GPIO_ACTIVE_HIGH>;\n        mosi-gpios = <&gpio0 15 GPIO_ACTIVE_HIGH>;\n\n        cs-gpios = <...>; // List of chip select gpios, one for each device\n        /* Nodes using the bus go here */\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Define Zephyr Library\nDESCRIPTION: This command declares a Zephyr library, which groups together source files and other dependencies into a reusable module. This is a standard way to organize code within Zephyr projects.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/ec11/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: BEHAVIOR_DT_INST_DEFINE Macro Example (Hold Tap)\nDESCRIPTION: This code snippet illustrates the use of the `BEHAVIOR_DT_INST_DEFINE` macro in the context of a hold-tap behavior. It shows how to define a behavior instance, including the configuration structure, initialization function, and driver API. The `DT_INST_FOREACH_STATUS_OKAY` macro iterates through the device tree nodes to create multiple instances of the behavior. This example provides the config for a behavior instance with id `n`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\n#define KP_INST(n)                                                                                 \\\n    static const struct behavior_hold_tap_config behavior_hold_tap_config_##n = {                  \\\n        .tapping_term_ms = DT_INST_PROP(n, tapping_term_ms),                                       \\\n        .hold_behavior_dev = DT_PROP(DT_INST_PHANDLE_BY_IDX(n, bindings, 0), label),               \\\n        .tap_behavior_dev = DT_PROP(DT_INST_PHANDLE_BY_IDX(n, bindings, 1), label),                \\\n        .quick_tap_ms = DT_INST_PROP(n, quick_tap_ms),                                             \\\n        .flavor = DT_ENUM_IDX(DT_DRV_INST(n), flavor),                                             \\\n        .retro_tap = DT_INST_PROP(n, retro_tap),                                                   \\\n        .hold_trigger_key_positions = DT_INST_PROP(n, hold_trigger_key_positions),                 \\\n        .hold_trigger_key_positions_len = DT_INST_PROP_LEN(n, hold_trigger_key_positions),         \\\n    };                                                                                             \\\n    BEHAVIOR_DT_INST_DEFINE(n, behavior_hold_tap_init, NULL, NULL, &behavior_hold_tap_config_##n,    \\\n                            APPLICATION, CONFIG_KERNEL_INIT_PRIORITY_DEFAULT,                        \\\n                            &behavior_hold_tap_driver_api);\n\nDT_INST_FOREACH_STATUS_OKAY(KP_INST)\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server\nDESCRIPTION: This command starts a local development server for the ZMK website. It uses Docusaurus 2's built-in development server, enabling hot reloading for live updates. The command requires npm to be installed and the dependencies installed via 'npm ci'.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/README.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ npm start\n```\n\n----------------------------------------\n\nTITLE: Installing Pre-commit Hooks for Clang-Format\nDESCRIPTION: This snippet shows how to install pre-commit hooks to automatically run `clang-format` to format C/C++ source code before each commit. It uses `pip3` to install `pre-commit` and then runs the `pre-commit install` command to set up the hooks in the local Git repository. This ensures consistent code formatting across the project.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/CONTRIBUTING.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip3 install pre-commit\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Rendering Supported Keyboards List using JavaScript\nDESCRIPTION: This JavaScript snippet filters keyboard metadata based on whether the 'studio' feature is included in the keyboard's feature list. It then generates an unordered list (<ul>) with list items (<li>) for each supported keyboard, displaying the keyboard's name.  It utilizes the `Metadata` imported from a JSON file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-11-11-zmk-studio-mvp-ga.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n{(function() {\nreturn (\n\n<ul>\n  {Metadata.filter((m) => (m.features || []).includes(\"studio\")).map((m) => {\n    return <li key={m.id}>{m.name}</li>;\n  })}\n</ul>\n); }())}\n```\n\n----------------------------------------\n\nTITLE: Configuration Files Location in West Build Logs\nDESCRIPTION: This snippet shows how the West build command logs the configuration files found and used during the build process. This is useful for verifying which configuration files are being included and whether the correct files are being used. It shows an example from GitHub Actions where the `corneish_zen.conf` file is used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/building-issues.md#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n+ west build -s zmk/app -d /tmp/tmp.8cJefinXCb -b corneish_zen_v2_left -- -DZMK_CONFIG=/tmp/zmk-config/config -DZMK_EXTRA_MODULES=/__w/zmk-config/zmk-config\n...\n-- ZMK Config Kconfig: /tmp/zmk-config/config/corneish_zen.conf\n...\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include MAX17048 Subdirectory in ZMK\nDESCRIPTION: This snippet utilizes the CMake function `add_subdirectory_ifdef` to conditionally include the `max17048` subdirectory in the ZMK project. The inclusion depends on the `CONFIG_ZMK_MAX17048` Kconfig option being enabled.  This enables modular inclusion of the MAX17048 battery gauge support.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_ZMK_MAX17048 max17048)\n```\n\n----------------------------------------\n\nTITLE: Creating a Zephyr Library in CMake\nDESCRIPTION: This line creates a Zephyr library, which is a collection of compiled code that can be linked into other Zephyr applications or libraries. It allows for modular code organization and reuse of components across different parts of the firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/battery/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Pinctrl Configuration Example\nDESCRIPTION: This Device Tree Snippet (DTS) configures pinctrl settings for UART0 and I2C0 peripherals, including default and sleep states using NRF_PSEL macros for pin selection and enabling low-power mode during sleep.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n/*\n * Copyright (c) 2022 The ZMK Contributors\n * SPDX-License-Identifier: MIT\n */\n\n&pinctrl {\n\t\tuart0_default: uart0_default {\n\t\t\tgroup1 {\n\t\t\t\tpsels = <NRF_PSEL(UART_RX, 0, 8)>;\n\t\t\t\tbias-pull-up;\n\t\t\t};\n\t\t\tgroup2 {\n\t\t\t\tpsels = <NRF_PSEL(UART_TX, 0, 6)>;\n\t\t\t};\n\t\t};\n\n\t\tuart0_sleep: uart0_sleep {\n\t\t\tgroup1 {\n\t\t\t\tpsels = <NRF_PSEL(UART_RX, 0, 8)>,\n\t\t\t\t\t\t<NRF_PSEL(UART_TX, 0, 6)>;\n\t\t\t\tlow-power-enable;\n\t\t\t};\n\t\t};\n\n\t\ti2c0_default: i2c0_default {\n\t\t\tgroup1 {\n\t\t\t\tpsels = <NRF_PSEL(TWIM_SDA, 0, 17)>,\n\t\t\t\t\t\t<NRF_PSEL(TWIM_SCL, 0, 20)>;\n\t\t\t};\n\t\t};\n\n\t\ti2c0_sleep: i2c0_sleep {\n\t\t\tgroup1 {\n\t\t\t\tpsels = <NRF_PSEL(TWIM_SDA, 0, 17)>,\n\t\t\t\t\t\t<NRF_PSEL(TWIM_SCL, 0, 20)>;\n\t\t\t\tlow-power-enable;\n\t\t\t};\n\t\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Updating CMakeLists.txt for a New ZMK Behavior\nDESCRIPTION: This CMakeLists.txt snippet shows how to add a new behavior driver to the ZMK firmware build.  It adds the source file to the `target_sources` list for the `app` target based on whether split keyboard is enabled and the split role.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_7\n\nLANGUAGE: txt\nCODE:\n```\nif ((NOT CONFIG_ZMK_SPLIT) OR CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n  target_sources(app PRIVATE src/behaviors/behavior_key_press.c)\n  target_sources(app PRIVATE src/behaviors/behavior_hold_tap.c)\n  target_sources(app PRIVATE src/behaviors/behavior_sticky_key.c)\n  target_sources(app PRIVATE src/behaviors/behavior_caps_word.c)\n  target_sources(app PRIVATE src/behaviors/behavior_key_repeat.c)\n  target_sources(app PRIVATE src/behaviors/behavior_momentary_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_mod_morph.c)\n  target_sources(app PRIVATE src/behaviors/behavior_outputs.c)\n  target_sources(app PRIVATE src/behaviors/behavior_tap_dance.c)\n  target_sources(app PRIVATE src/behaviors/behavior_toggle_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_to_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_transparent.c)\n  target_sources(app PRIVATE src/behaviors/behavior_none.c)\n  target_sources(app PRIVATE src/behaviors/behavior_sensor_rotate_key_press.c)\n  target_sources(app PRIVATE src/combo.c)\n  target_sources(app PRIVATE src/conditional_layer.c)\n  target_sources(app PRIVATE src/keymap.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Defining Interconnect Requires/Exposes\nDESCRIPTION: Illustrates how to define the interconnect requirements and exposures for boards and shields. The `requires` property specifies the interconnects needed by the shield, and the `exposes` property specifies the interconnects exposed by the board.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_5\n\nLANGUAGE: yaml\nCODE:\n```\nrequires:\n  - pro_micro\nexposes:\n  - i2c_oled\n```\n\n----------------------------------------\n\nTITLE: Building Static Website Content\nDESCRIPTION: This command builds the static website content for deployment. It uses Docusaurus 2 to generate optimized HTML, CSS, and JavaScript files in the 'build' directory. It requires npm to be installed and the dependencies installed via 'npm ci'.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/README.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ npm build\n```\n\n----------------------------------------\n\nTITLE: Nested Mod-Morphs for Complex Logic in ZMK\nDESCRIPTION: This snippet demonstrates how to nest mod-morph behaviors to create more complex conditional logic for key actions. The `morph_ABC` behavior outputs A by default, B when Shift is held, and C when Shift and Control are both held. This is achieved by making `morph_BC` a morphed binding within `morph_ABC`, such that it only activates if Shift is held.  `morph_BC` then outputs B normally, and C if Control is held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mod-morph.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        morph_BC: morph_BC {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp B>, <&kp C>;\n            mods = <(MOD_LCTL|MOD_RCTL)>;\n        };\n        morph_ABC: morph_ABC {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp A>, <&morph_BC>;\n            mods = <(MOD_LSFT|MOD_RSFT)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling I2C0 Instance for RP2040\nDESCRIPTION: This snippet enables the I2C0 instance for RP2040. It sets the status to \"okay\", assigns the pin control configuration, and sets the clock frequency to I2C_BITRATE_STANDARD.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_21\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&i2c0 {\n    status = \"okay\";\n    pinctrl-0 = <&i2c0_default>;\n    pinctrl-names = \"default\";\n    clock-frequency = <I2C_BITRATE_STANDARD>;\n\n    /* Nodes using the bus go here */\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Docker Volume for ZMK Config\nDESCRIPTION: Creates a Docker volume named 'zmk-config' and binds it to a specified local directory.  This allows the container to access the ZMK configuration files. Requires Docker to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ndocker volume create --driver local -o o=bind -o type=none \\\n  -o device=\"/absolute/path/to/zmk-config/\" zmk-config\n```\n\n----------------------------------------\n\nTITLE: Sending Keycode Sequences in ZMK\nDESCRIPTION: This code snippet defines a ZMK macro to send a sequence of keycodes. The `wait-ms` and `tap-ms` parameters are set to 40ms to avoid HID notification grouping issues. It sends \"ZMK\", a space, and \"ROCKS\" as separate keycode sequences.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_11\n\nLANGUAGE: dts\nCODE:\n```\nwait-ms = <40>;\ntap-ms = <40>;\nbindings\n    = <&kp Z &kp M &kp K>\n    , <&kp SPACE>\n    , <&kp R &kp O &kp C &kp K &kp S>\n    ;\n\n```\n\n----------------------------------------\n\nTITLE: Building With External Modules\nDESCRIPTION: Builds ZMK firmware including code from external modules. This facilitates out-of-tree management and versioning of boards, shields, and code. The `ZMK_EXTRA_MODULES` define specifies the path to the external module(s). Multiple modules can be separated by semicolons.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b nice_nano_v2 -- -DSHIELD=vendor_shield -DZMK_EXTRA_MODULES=\"C:/Users/myUser/Documents/my-vendor-keebs-module\"\n```\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b nice_nano_v2 -- -DSHIELD=vendor_shield -DZMK_EXTRA_MODULES=\"C:/Users/myUser/Documents/my-vendor-keebs-module;C:/Users/myUser/Documents/my-other-keebs-module\"\n```\n\n----------------------------------------\n\nTITLE: Including Locale-Specific Key Definitions (DTS)\nDESCRIPTION: This snippet shows how to include a locale-specific header file generated by ZMK Locale Generator in a ZMK keymap file.  It requires downloading the appropriate header file from the ZMK Locale Generator releases page and placing it in the same directory as your keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-01-05-zmk-tools.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include \"keys_de.h\"\n\n/ {\n    ...\n};\n\n```\n\n----------------------------------------\n\nTITLE: Install Python on Windows 11 (Shell)\nDESCRIPTION: This command installs Python 3 on Windows 11 using the `winget` package manager. It's an alternative to downloading and installing Python from the official website.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nwinget install python3\n```\n\n----------------------------------------\n\nTITLE: Running ZMK Firmware Locally - Shell\nDESCRIPTION: Executes the compiled ZMK firmware located at `./build/zephyr/zmk.exe`. This command starts the firmware in a local environment, allowing for testing and iteration on features.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/posix-board.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n./build/zephyr/zmk.exe\n```\n\n----------------------------------------\n\nTITLE: Adding wired.c source file\nDESCRIPTION: This CMake command adds `wired.c` as a source file to the `app` target. It is marked as `PRIVATE`, meaning it's only used during the build process of the `app` target and not exposed to other targets linking against it.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/wired/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(app PRIVATE wired.c)\n```\n\n----------------------------------------\n\nTITLE: Including Zephyr Include Directories in CMake\nDESCRIPTION: This line includes the current directory in the Zephyr include directories, allowing the project to find header files located within it. This is essential for referencing local definitions and structures in the project's source code.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/battery/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_include_directories(.)\n```\n\n----------------------------------------\n\nTITLE: Old Encoder Configuration (Deprecated) DTS\nDESCRIPTION: Demonstrates the deprecated method for configuring encoders in ZMK using the `resolution` property. This configuration specifies the number of encoder pulses that trigger the sensor behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-06-18-encoder-refactors.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n    left_encoder: encoder_left {\n        compatible = \"alps,ec11\";\n        a-gpios = <&pro_micro 21 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        b-gpios = <&pro_micro 20 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        resolution = <4>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Define Target Sources for ZMK App\nDESCRIPTION: This CMake command defines the target sources for the ZMK application. These sources are compiled and linked into the final application binary. It includes message framing, RPC core logic, behavior and keymap subsystems.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/studio/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources(app PRIVATE msg_framing.c)\ntarget_sources(app PRIVATE rpc.c)\ntarget_sources(app PRIVATE core.c)\ntarget_sources(app PRIVATE behavior_subsystem.c)\ntarget_sources(app PRIVATE core_subsystem.c)\ntarget_sources(app PRIVATE keymap_subsystem.c)\n```\n\n----------------------------------------\n\nTITLE: Barebones Physical Layout (DTS)\nDESCRIPTION: This snippet demonstrates how to add a basic physical layout without the `keys` property to a `my_keyboard_dongle.overlay` file, suitable for scenarios where ZMK Studio is not in use. This includes setting the `compatible` property, a display name, and the matrix transform.  The chosen node is also included to select the created layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    physical_layout0: physical_layout_0 {\n        compatible = \"zmk,physical-layout\";\n        display-name = \"Default Layout\";\n        transform = <&default_transform>;\n    };\n};\n\n/ {\n    chosen {\n        zmk,kscan = &mock_kscan;\n        zmk,physical-layout = &physical_layout0;  // New item added\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring ZMK Display and Fonts\nDESCRIPTION: This snippet shows how to disable the custom nice!view widget and use the built-in ZMK status screen. It also configures the default fonts for the display, specifying Montserrat 26 as the default font size.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nice_view/README.md#_snippet_0\n\nLANGUAGE: conf\nCODE:\n```\nCONFIG_ZMK_DISPLAY_STATUS_SCREEN_BUILT_IN=y\nCONFIG_ZMK_LV_FONT_DEFAULT_SMALL_MONTSERRAT_26=y\nCONFIG_LV_FONT_DEFAULT_MONTSERRAT_26=y\n```\n\n----------------------------------------\n\nTITLE: Define Zephyr Library\nDESCRIPTION: Defines a Zephyr library named 'zephyr_library'. This function declares a library module within the Zephyr RTOS build system, enabling the inclusion of this module's functionality in other parts of the firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/lib/zmk_debounce/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central with Device ID and Start Delay\nDESCRIPTION: This command executes the `ble_test_central.exe` application, specifying device ID 3 using the `-d` parameter and setting a 1300ms delay before starting using the `-wait_on_start` parameter. This allows the target device time to initialize before the central application attempts to connect.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/first-and-second-profile-paired-then-send-data/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=3 -wait_on_start=1300\n```\n\n----------------------------------------\n\nTITLE: Defining an Advanced Tap-Dance with Nested Mod-Tap in ZMK\nDESCRIPTION: This code snippet defines an advanced tap-dance behavior named `td_mt` that includes a nested mod-tap. A single tap outputs `CAPSLOCK` and a hold outputs `LSHIFT`, while two taps output `LCTRL`. It uses `zmk,behavior-tap-dance` compatible, sets `tapping-term-ms` to 200ms, and defines bindings for the mod-tap `LSHIFT CAPSLOCK` and the key press `LCTRL`. The keymap then uses this tap-dance on a key in the default layer.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/tap-dance.mdx#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <behaviors.dtsi>\n#include <dt-bindings/zmk/keys.h>\n\n/ {\n    behaviors {\n        td_mt: tap_dance_mod_tap {\n            compatible = \"zmk,behavior-tap-dance\";\n            #binding-cells = <0>;\n            tapping-term-ms = <200>;\n            bindings = <&mt LSHIFT CAPSLOCK>, <&kp LCTRL>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        default_layer {\n            bindings = <\n                &td_mt\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include Battery Subdirectory in ZMK\nDESCRIPTION: This snippet uses the CMake function `add_subdirectory_ifdef` to conditionally include the `battery` subdirectory in the ZMK project. The inclusion is dependent on the `CONFIG_ZMK_BATTERY` Kconfig option being enabled. This allows for the battery functionality to be added modularly.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_ZMK_BATTERY battery)\n```\n\n----------------------------------------\n\nTITLE: Defining URL\nDESCRIPTION: Shows how to define the URL for the hardware item. The `url` property should contain the canonical URL for more information about the board/shield.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nurl: https://github.com/foostan/crkbd/\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion using target_sources_ifdef\nDESCRIPTION: This code snippet uses the `target_sources_ifdef` macro to conditionally include C source files based on whether specific ZMK configuration options are defined. The macro takes three arguments: the configuration option, the target application, and the path to the source file.  If the configuration option is defined, the source file is added to the target's sources. The keyword PRIVATE makes the sources available only to the current CMakeLists.txt scope.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/pointing/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_LISTENER app PRIVATE input_listener.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_PROCESSOR_TRANSFORM app PRIVATE input_processor_transform.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_PROCESSOR_SCALER app PRIVATE input_processor_scaler.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_PROCESSOR_TEMP_LAYER app PRIVATE input_processor_temp_layer.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_PROCESSOR_CODE_MAPPER app PRIVATE input_processor_code_mapper.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_PROCESSOR_BEHAVIORS app PRIVATE input_processor_behaviors.c)\ntarget_sources_ifdef(CONFIG_ZMK_POINTING_SMOOTH_SCROLLING app PRIVATE resolution_multipliers.c)\ntarget_sources_ifdef(CONFIG_ZMK_INPUT_SPLIT app PRIVATE input_split.c)\n```\n\n----------------------------------------\n\nTITLE: Defining Item Type\nDESCRIPTION: Explains how to define the type of hardware item. The `type` property can be set to `board`, `shield`, or `interconnect`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_3\n\nLANGUAGE: yaml\nCODE:\n```\ntype: shield\n```\n\n----------------------------------------\n\nTITLE: Enabling ZMK Pointing Feature\nDESCRIPTION: This configuration option enables the ZMK mouse feature, which is required to use any of the mouse emulation behaviors.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_0\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_POINTING=y\n```\n\n----------------------------------------\n\nTITLE: Defining Zephyr Linker Sources\nDESCRIPTION: This snippet defines Zephyr linker sources for specific sections of the firmware, including behaviors, events, and behavior local ID map, which affects how the firmware is linked and organized in memory. The linker sources are defined conditionally based on Kconfig options.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_linker_sources(SECTIONS include/linker/zmk-behaviors.ld)\nzephyr_linker_sources(RODATA include/linker/zmk-events.ld)\n\nif(CONFIG_ZMK_BEHAVIOR_LOCAL_IDS)\n  zephyr_linker_sources(DATA_SECTIONS include/linker/zmk-behavior-local-id-map.ld)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Central Configuration for Split Keyboard Pointing Device\nDESCRIPTION: This snippet shows the central part's overlay configuration for a split keyboard setup with a pointing device. It includes the shared .dtsi file, enables the previously disabled input listener, and assigns the pointing device node to the listener.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n// Pull in the shared configuration\n#include \"<keyboard>.dtsi\"\n\n// Node from the previous Input Device section\n&pro_micro_spi {\n    /* ... */\n\n    glidepoint: glidepoint@0 {\n        /* ... */\n    };\n};\n\n// Overrides for the input listener node\n&glidepoint_listener {\n    status = \"okay\";\n    device = <&glidepoint>;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Permanent CMake Arguments\nDESCRIPTION: Configures permanent CMake arguments for `west build`. These arguments will be used for all subsequent builds. The `west config` command is used to set the `build.cmake-args` configuration option.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nwest config build.cmake-args -- -DSHIELD=kyra_left\n```\n\nLANGUAGE: sh\nCODE:\n```\nwest config build.cmake-args \\\n  -- \"-DSHIELD=kyra_left -DZMK_CONFIG=/absolute/path/to/zmk-config\"\n```\n\n----------------------------------------\n\nTITLE: Connecting to a Running Docker Container\nDESCRIPTION: Lists running Docker containers and connects to one using `docker exec`.  This allows executing commands inside the container's environment. Requires Docker to be installed and a container to be running.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\ndocker ps                                                   # List containers\ndocker exec -w /workspaces/zmk -it <container_id> /bin/bash # Connect\n```\n\n----------------------------------------\n\nTITLE: Installing Python venv package on Ubuntu\nDESCRIPTION: Installs the `python3-venv` package using `apt` on Ubuntu. This allows the creation of Python virtual environments.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt install python3-venv\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware for native_posix_64 - Shell\nDESCRIPTION: Builds the ZMK firmware targeting the `native_posix_64` board using the `west build` command. The `--pristine` flag ensures a clean build, and `-DZMK_CONFIG=tests/none/normal/` specifies the configuration file to use. This command prepares the executable for local execution.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/posix-board.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwest build --pristine --board native_posix_64 -- -DZMK_CONFIG=tests/none/normal/\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion - CMake\nDESCRIPTION: Conditionally includes the `max17048.c` source file in the Zephyr library if the `CONFIG_ZMK_MAX17048` Kconfig option is enabled. If it is disabled, an empty file is included instead.  This allows for compiling different functionality based on the Kconfig configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/max17048/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_MAX17048  max17048.c)\nzephyr_library_sources_ifndef(CONFIG_ZMK_MAX17048 ${ZEPHYR_BASE}/misc/empty_file.c)\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central Executable\nDESCRIPTION: This command executes the `ble_test_central.exe` executable. It uses parameters to configure the device discovery delay (`-d=2`), a wait time on start (`-wait_on_start=1300`), and enables writing HID indicators on discovery (`-write_hid_indicators_on_discovery`).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/set-hid-indicators/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -wait_on_start=1300 -write_hid_indicators_on_discovery\n```\n\n----------------------------------------\n\nTITLE: Defining Zephyr Syscall Headers\nDESCRIPTION: This snippet defines the Zephyr syscall headers for different drivers used in ZMK. It exposes functionality from the drivers as system calls, allowing user-space applications to safely interact with hardware and other system resources.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_syscall_header(${APPLICATION_SOURCE_DIR}/include/drivers/behavior.h)\nzephyr_syscall_header(${APPLICATION_SOURCE_DIR}/include/drivers/input_processor.h)\nzephyr_syscall_header(${APPLICATION_SOURCE_DIR}/include/drivers/ext_power.h)\n```\n\n----------------------------------------\n\nTITLE: Linting Documentation with npm\nDESCRIPTION: This snippet demonstrates how to lint the documentation files using `npm run lint`. Linting helps identify potential errors and enforce code quality standards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpm run lint\n```\n\n----------------------------------------\n\nTITLE: Combining Left Control and Right Alt modifiers in ZMK\nDESCRIPTION: This snippet combines the left control and right alt modifiers with the 'B' key. The resulting output depends on the specific keymap configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/modifiers.mdx#_snippet_2\n\nLANGUAGE: ZMK\nCODE:\n```\n&kp LC(RA(B))\n```\n\n----------------------------------------\n\nTITLE: Devicetree Error: Lacks #binding-cells\nDESCRIPTION: This error indicates potential problems with incorrect parameters for specific bindings within the devicetree. The error message references `empty_file.c` and indicates a missing `#binding-cells` property. This can be triggered by incorrect binding syntax, such as using `&kp BT_SEL 0` instead of `&bt BT_SEL 0`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/building-issues.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\ndevicetree error: <Node /soc/gpio@50000300 in '/tmp/tmp.vJq9sMwkcY/zephyr/misc/empty_file.c'> lacks #binding-cells\n```\n\n----------------------------------------\n\nTITLE: Building Custom Keymap with nice!view Support (ZMK)\nDESCRIPTION: These commands build the ZMK firmware for the left and right halves of the Leeloo-Micro keyboard with support for nice!view displays using a custom keymap. It calls `west build` with the `nice_nano_v2` board, specifying the `leeloo_micro_left`, `nice_view_adapter`, and `nice_view` shields, and sets the `ZMK_CONFIG` variable to the path of the custom keymap configuration file. It targets a shell environment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo_micro/README.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_micro_left nice_view_adapter nice_view\" -DZMK_CONFIG=\"/workspaces/zmk-config/[yourName]/leeloo_micro/config\"\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_micro_right nice_view_adapter nice_view\" -DZMK_CONFIG=\"/workspaces/zmk-config/[yourName]/leeloo_micro/config\"\n```\n\n----------------------------------------\n\nTITLE: Example NVS Log Output\nDESCRIPTION: This log output shows the NVS module's behavior during the test. The `fs_nvs` logs indicate the number of sectors, allocation wrappers, data wrappers, and flash erases. Observing these logs helps in identifying potential issues with how NVS manages flash memory, specifically in relation to sector erases that led to the bootloader corruption.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-10-03-bootloader-fix.md#_snippet_4\n\nLANGUAGE: log\nCODE:\n```\n[00:00:00.000,671] <inf> fs_nvs: 8 Sectors of 4096 bytes\n[00:00:00.000,671] <inf> fs_nvs: alloc wra: 3, f70\n[00:00:00.000,671] <inf> fs_nvs: data wra: 3, f40\n// A bunch of effect cycle spam\n[00:02:34.781,188] <dbg> fs_nvs: Erasing flash at fd000, len 4096\n// A bunch more effect cycle spam\n[00:06:42.219,970] <dbg> fs_nvs: Erasing flash at ff000, len 4096\n// A bunch more effect cycle spam\n// KABOOM - bootloader issue\n```\n\n----------------------------------------\n\nTITLE: Including GPIO Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_gpio.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_GPIO_DRIVER` Kconfig option is defined. This driver handles keyboard scanning using GPIO pins.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_GPIO_DRIVER kscan_gpio.c)\n```\n\n----------------------------------------\n\nTITLE: Setting Compiler Options\nDESCRIPTION: This snippet sets a compiler option to treat all warnings as fatal errors, ensuring that the build process fails if any warnings are encountered.  This aids in maintaining code quality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_6\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_cc_option(-Wfatal-errors)\n```\n\n----------------------------------------\n\nTITLE: Including GPIO Matrix Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_gpio_matrix.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_GPIO_MATRIX` Kconfig option is defined. This driver handles keyboard scanning using a GPIO matrix.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_2\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_GPIO_MATRIX kscan_gpio_matrix.c)\n```\n\n----------------------------------------\n\nTITLE: Increasing BLE transmit power - INI\nDESCRIPTION: This code snippet demonstrates how to increase the transmit power of the keyboard's BLE radio. This can help improve connection strength between the keyboard and the host, especially in cases of poor quality BLE hardware or obstructions. The value can range from MINUS_20 to PLUS_8, with PLUS_8 being recommended for connection issues.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/connection-issues.mdx#_snippet_2\n\nLANGUAGE: INI\nCODE:\n```\nCONFIG_BT_CTLR_TX_PWR_PLUS_8=y\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v1 Default Keymap with ZMK\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v1 keyboard using the default keymap. It utilizes the `west build` tool, specifying the board as `nice_nano_v2` and setting the shield to `leeloo_left` or `leeloo_right` respectively. The output is placed in the `build/left` and `build/right` directories.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=leeloo_left\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=leeloo_right\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with npm\nDESCRIPTION: This snippet shows how to build the documentation using `npm run build`. This command generates the static files needed for deployment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\n```\n\n----------------------------------------\n\nTITLE: Custom Sticky Key Behavior Creation\nDESCRIPTION: This snippet demonstrates creating a new, named sticky key behavior (`skq`) with specific configurations, including `quick-release` and `ignore-modifiers`.  This allows more fine-grained control over sticky key behavior. This snippet also requires a keymap section in the root node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-key.md#_snippet_3\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    behaviors {\n      skq: sticky_key_quick_release {\n        compatible = \"zmk,behavior-sticky-key\";\n        #binding-cells = <1>;\n        bindings = <&kp>;\n        release-after-ms = <1000>;\n        quick-release;\n        ignore-modifiers;\n      };\n    };\n\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: CMake Verification Toolchain Output Example\nDESCRIPTION: An example of the output from the command `cmake -P zephyr/cmake/verify-toolchain.cmake`. The important values are `ZEPHYR_SDK_INSTALL_DIR` which is used to find the compiler.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/ide-integration.mdx#_snippet_3\n\nLANGUAGE: text\nCODE:\n```\n-- ZEPHYR_TOOLCHAIN_VARIANT: zephyr\n-- SDK_VERSION: 0.15.2\n-- ZEPHYR_SDK_INSTALL_DIR  : /home/marvin/.local/zephyr-sdk-0.15.2\n```\n\n----------------------------------------\n\nTITLE: Enabling UART0 Instance for RP2040\nDESCRIPTION: This snippet enables the UART0 instance in the main device tree file for the RP2040.  It references the pin control configuration defined in the pinctrl file, assigning it the name \"default\".\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_15\n\nLANGUAGE: dts\nCODE:\n```\n#include \"<board>-pinctrl.dtsi\"\n\n&uart0 {\n    pinctrl-0 = <&uart0_default>;\n    pinctrl-names = \"default\";\n};\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central with Device ID\nDESCRIPTION: This command executes the `ble_test_central.exe` application, specifying device ID 2 using the `-d` parameter. The application will start and attempt to connect to the specified device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/first-and-second-profile-paired-then-send-data/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2\n```\n\n----------------------------------------\n\nTITLE: Creating a Python virtual environment\nDESCRIPTION: Creates a new Python virtual environment named `.venv`. Requires Python to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npython -m venv .venv\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v2 Default Keymap with nice!view\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v2 keyboard using the default keymap and enabling support for nice!view displays. The `-DSHIELD` parameter includes `nice_view_adapter` and `nice_view` alongside the standard shield name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/left_v2 -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_rev2_left nice_view_adapter nice_view\"\nwest build -d build/right_v2 -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_rev2_right nice_view_adapter nice_view\"\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Sources\nDESCRIPTION: This snippet specifies the source files for the previously defined Zephyr library. It depends on the existence of 'pinmux.c' and the correct configuration of the Zephyr build environment. It adds 'pinmux.c' as a source file to be compiled into the Zephyr library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/puchi_ble/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources(pinmux.c)\n```\n\n----------------------------------------\n\nTITLE: Set Zephyr Include Directories\nDESCRIPTION: This command adds the current directory to the list of include directories for the Zephyr build system. This allows the build system to find header files located in the current directory during compilation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/ec11/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_include_directories(.)\n```\n\n----------------------------------------\n\nTITLE: Define a GPIO array in Devicetree\nDESCRIPTION: This example shows how to define a GPIO array in a devicetree file. Each item in the array consists of a GPIO node label, an index, and configuration flags. The flags are defined in Zephyr's GPIO documentation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\nsome-gpios = \n    <&gpio0 0 GPIO_ACTIVE_HIGH>,\n    <&gpio0 1 (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>\n    ;\n```\n\n----------------------------------------\n\nTITLE: Installing Zephyr dependencies with pip\nDESCRIPTION: Installs additional dependencies from Zephyr's `requirements-base.txt` file using `pip`.  Requires `pip` to be installed and configured.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\npip install -r zephyr/scripts/requirements-base.txt\n```\n\n----------------------------------------\n\nTITLE: Checking Dev Container CLI Version\nDESCRIPTION: Checks the installed version of the Dev Container CLI.  Verifies that the CLI is properly installed and accessible. Requires the Dev Container CLI to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\ndevcontainer --version\n```\n\n----------------------------------------\n\nTITLE: Managing Podman Containers and Volumes\nDESCRIPTION: Commands to list, stop, and remove Podman containers and volumes.  Used to clean up outdated or unnecessary container instances and storage volumes. Requires Podman to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\npodman ps                    # List containers\npodman stop \"<container-id>\" # Stop the container\npodman rm   \"<container-id>\" # Remove the container\n\npodman volume ls                 # List volumes\npodman volume rm \"<volume-name>\" # Remove volume\n```\n\n----------------------------------------\n\nTITLE: Enable KScan Sideband Behavior - DTS\nDESCRIPTION: This snippet configures the KScan sideband behavior by wrapping the wakeup scan driver. It defines a `side_band_behavior_triggers` node with the `zmk,kscan-sideband-behaviors` compatible property. The `kscan` property specifies the kscan driver to use, and `auto-enable` and `wakeup-source` enable automatic enabling and wakeup functionality, respectively.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-wakeup-direct.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    side_band_behavior_triggers: side_band_behavior_triggers {\n        compatible = \"zmk,kscan-sideband-behaviors\";\n        kscan = <&wakeup_scan>;\n        auto-enable;\n        wakeup-source;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Input Processors to Mouse Scroll\nDESCRIPTION: This example demonstrates how to apply input processors to the `&msc` behavior using `&msc_input_listener`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_11\n\nLANGUAGE: dts\nCODE:\n```\n&msc_input_listener {\n    input-processors = <&zip_temp_layer 2 2000>;\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional Subdirectory Inclusion\nDESCRIPTION: This CMake command conditionally includes the `widgets/` subdirectory in the application build process if the `CONFIG_ZMK_DISPLAY` configuration option is enabled.  This allows inclusion of display widgets code only when a display is configured.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_ZMK_DISPLAY widgets/)\n```\n\n----------------------------------------\n\nTITLE: Sofle Shield Board Overlay Example\nDESCRIPTION: Shows the directory structure for the sofle shield, with nested board overlay files for nice_nano, nice_nano_v2, nrfmicro_11 and nrfmicro_13.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nboards/shields/sofle/\n├── boards/\n│   ├── nice_nano.overlay\n│   ├── nice_nano_v2.overlay\n│   ├── nrfmicro_11.overlay\n│   └── nrfmicro_13.overlay\n└── <sofle shield defining files>\n```\n\n----------------------------------------\n\nTITLE: Push Changes to GitHub (Shell)\nDESCRIPTION: These commands add, commit, and push changes to a GitHub repository, triggering a firmware build. This is the standard Git workflow for deploying ZMK firmware changes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\ngit add .\ngit commit\ngit push\n```\n\n----------------------------------------\n\nTITLE: Define a path to a node using a string in Devicetree\nDESCRIPTION: This example demonstrates how to define a path to a node using a string representing the node's path in a devicetree file. This is an alternative way to refer to a node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\nproperty = \"/path/to/some/node\";\n```\n\n----------------------------------------\n\nTITLE: Toggle backlight on/off in ZMK\nDESCRIPTION: This snippet demonstrates how to configure a key to toggle the backlight on or off using the `BL_TOG` action. The `&bl` behavior binding is used, and `BL_TOG` is passed as the first parameter. This action will switch the backlight state between on and off each time the key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/backlight.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n&bl BL_TOG\n```\n\n----------------------------------------\n\nTITLE: Building Right Side of Split Keyboard\nDESCRIPTION: Builds ZMK firmware for the right side of a split keyboard, specifying a separate build directory. This avoids overwriting the firmware for the left side. The `-d` flag specifies the build directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nwest build -d build/right -b nice_nano_v2 -- -DSHIELD=kyria_right\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Battery Status Widget\nDESCRIPTION: This snippet conditionally includes `battery_status.c` into the application build if `CONFIG_ZMK_WIDGET_BATTERY_STATUS` is defined. The source file is added as a private source to the 'app' target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/widgets/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_WIDGET_BATTERY_STATUS app PRIVATE battery_status.c)\n```\n\n----------------------------------------\n\nTITLE: Append flags to EXTRA_DTC_FLAGS in CMake\nDESCRIPTION: This CMake command appends the \"-qq\" flag to the EXTRA_DTC_FLAGS variable. The EXTRA_DTC_FLAGS variable is used by the device tree compiler (DTC) during the build process. The \"-qq\" flag reduces the verbosity of the DTC output.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/preonic/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND EXTRA_DTC_FLAGS \"-qq\")\n```\n\n----------------------------------------\n\nTITLE: Exporting Zephyr CMake package with west\nDESCRIPTION: Exports the Zephyr CMake package, allowing CMake to automatically load boilerplate code for building Zephyr applications.  Requires `west` to be initialized.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nwest zephyr-export\n```\n\n----------------------------------------\n\nTITLE: Copyright header for drivers (.c) and predefined use-cases (.dtsi)\nDESCRIPTION: This is the required copyright header to be included in all new driver (``.c``) and predefined use-case (``.dtsi``) files created for ZMK.  Remember to update the year `XXXX`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_12\n\nLANGUAGE: C\nCODE:\n```\n/*\n// highlight-next-line\n * Copyright (c) XXXX The ZMK Contributors\n *\n * SPDX-License-Identifier: MIT\n */\n```\n\n----------------------------------------\n\nTITLE: Defining Combos in ZMK Keymap\nDESCRIPTION: This code snippet demonstrates how to define a combo in a ZMK keymap file. Combos allow you to trigger a keycode by pressing multiple keys simultaneously.  The example sends the ESC keycode when both the first and second positions on the keyboard are pressed. The timeout-ms parameter specifies the maximum time allowed between key presses for the combo to be recognized.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2021-01-27-zmk-sotf-4.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    combos {\n        compatible = \"zmk,combos\";\n        combo_esc {\n            timeout-ms = <50>;\n            key-positions = <0 1>;\n            bindings = <&kp ESC>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Peripheral Status Widget\nDESCRIPTION: This snippet conditionally includes `peripheral_status.c` into the application build if `CONFIG_ZMK_WIDGET_PERIPHERAL_STATUS` is defined. The source file is added as a private source to the 'app' target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/widgets/CMakeLists.txt#_snippet_2\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_WIDGET_PERIPHERAL_STATUS app PRIVATE peripheral_status.c)\n```\n\n----------------------------------------\n\nTITLE: Update Docker Image Tag in Workflow - YAML\nDESCRIPTION: Updates the Docker image tag in a custom GitHub Actions workflow.  This changes the image from `zmkfirmware/zmk-build-arm:2.5` to `zmkfirmware/zmk-build-arm:stable`. This ensures that the workflow uses the stable Docker image for building the ZMK firmware, particularly for Zephyr 3.2.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\n- name: ${{ steps.variables.outputs.display-name }} DTS File\n  if: ${{ always() }}\n  run: |\n    if [ -f \"build/zephyr/${{ matrix.board }}.pre.tmp\" ]; then cat -n build/zephyr/${{ matrix.board }}.pre.tmp; fi\n    if [ -f \"build/zephyr/zephyr.dts\" ]; then cat -n build/zephyr/zephyr.dts\"; fi\n```\n\n----------------------------------------\n\nTITLE: Position Map for Numpad with Missing Keys - DTS\nDESCRIPTION: This example shows a position map for a numpad layout with some missing keys. Note the empty positions in the `positions` array, represented by whitespace. This snippet references the `numpad_layout` and establishes the relationship between physical keys and logical positions.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_11\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map {\n        // Other properties\n\n        numpad_map: numpad {\n            physical-layout = <&numpad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10   >\n                , <11 12 13 14>\n                , <15    16   >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Setting core.editor for ZMK CLI\nDESCRIPTION: This command sets the `core.editor` configuration option for the ZMK CLI, defining the command-line tool to use for editing code with the `zmk code` command. The example configures Visual Studio Code to always open a new window.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\nzmk config core.editor \"code --new-window\"\n```\n\n----------------------------------------\n\nTITLE: Adding Pro Micro Tester Build to build.yaml (ZMK)\nDESCRIPTION: This snippet demonstrates how to add a tester build configuration for a Pro Micro-compatible board to the `build.yaml` file in your `zmk-config` folder. This allows you to build a firmware image specifically for testing the GPIO pins on your keyboard using the tester shield.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/hardware-issues.mdx#_snippet_0\n\nLANGUAGE: yml\nCODE:\n```\ninclude:\n  # -------------------\n  # Your keyboards here\n  # -------------------\n  - board: nice_nano_v2 # Replace with the Pro Micro-compatible board you're using\n    shield: tester_pro_micro\n```\n\n----------------------------------------\n\nTITLE: Creating Zephyr Library - CMake\nDESCRIPTION: Defines a Zephyr library, which is a collection of source files compiled into a reusable module within the Zephyr RTOS environment. This allows for modular code organization and reuse in the ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/max17048/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Shared Input Split Configuration for Peripheral Pointing Device\nDESCRIPTION: This code defines a `zmk,input-split` device in the shared .dtsi file for a split keyboard, necessary when the pointing device is on the peripheral. It also includes the disabled input listener and ensures correct address cell configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    split_inputs {\n        #address-cells = <1>;\n        #size-cells = <0>;\n\n        glidepoint_split: glidepoint_split@0 {\n            compatible = \"zmk,input-split\";\n            reg = <0>;\n        };\n    };\n\n    glidepoint_listener: glidepoint_listener {\n        compatible = \"zmk,input-listener\";\n        status = \"disabled\";\n        device = <&glidepoint_split>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Conditionally add source files for display widgets (CMake)\nDESCRIPTION: This snippet conditionally adds source files for battery status, output status, layer status, and peripheral status widgets to the `app` target, based on the corresponding Kconfig options. The source files are located in the `widgets` directory and are added as private sources.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/corneish_zen/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_ZMK_DISPLAY)\n  target_sources_ifdef(CONFIG_CUSTOM_WIDGET_BATTERY_STATUS app PRIVATE widgets/battery_status.c)\n  target_sources_ifdef(CONFIG_CUSTOM_WIDGET_OUTPUT_STATUS app PRIVATE widgets/output_status.c)\n  target_sources_ifdef(CONFIG_CUSTOM_WIDGET_LAYER_STATUS app PRIVATE widgets/layer_status.c)\n  target_sources_ifdef(CONFIG_CUSTOM_WIDGET_PERIPHERAL_STATUS app PRIVATE widgets/peripheral_status.c)\n\n  add_subdirectory_ifdef(CONFIG_ZMK_DISPLAY_STATUS_SCREEN_CUSTOM widgets/icons)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Binding Soft Off Behavior - Devicetree\nDESCRIPTION: This snippet demonstrates how to bind the soft off behavior using the `&soft_off` reference in your devicetree configuration. This allows you to associate a key press with the soft off functionality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/soft-off.md#_snippet_0\n\nLANGUAGE: devicetree\nCODE:\n```\n&soft_off\n```\n\n----------------------------------------\n\nTITLE: Building Default Keymap for Leeloo-Micro (ZMK)\nDESCRIPTION: These commands build the ZMK firmware for the left and right halves of the Leeloo-Micro keyboard using the default keymap. It uses the `west build` tool with the `nice_nano_v2` board and specifies the `leeloo_micro_left` and `leeloo_micro_right` shields respectively. These commands are executed in a shell environment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo_micro/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=leeloo_micro_left\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=leeloo_micro_right\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Definition\nDESCRIPTION: Defines a Zephyr library using the `zephyr_library()` function. This indicates that the current directory contains library sources that should be compiled as part of a Zephyr module or application.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/nrfmicro/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Using Multiple Predefined Layouts in DTS\nDESCRIPTION: Shows how to use multiple predefined layouts, typically for a 60% keyboard with ANSI, ISO, All1u, and HHKB variants. It includes each layout's DTS file and assigns the corresponding transform and kscan nodes to each layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n#include <layouts/common/60percent/all1u.dtsi>\n#include <layouts/common/60percent/ansi.dtsi>\n#include <layouts/common/60percent/hhkb.dtsi>\n#include <layouts/common/60percent/iso.dtsi>\n\n\n// Assigning suitable kscan and matrix transforms\n&layout_60_ansi {\n    transform = <&ansi_transform>;\n    kscan = <&ansi_kscan>;\n};\n\n&layout_60_iso {\n    transform = <&iso_transform>;\n    kscan = <&iso_kscan>;\n};\n\n&layout_60_all1u {\n    transform = <&all_1u_transform>;\n    kscan = <&all_1u_kscan>;\n};\n\n&layout_60_hhkb {\n    transform = <&hhkb_transform>;\n    kscan = <&hhkb_kscan>;\n};\n```\n\n----------------------------------------\n\nTITLE: Updating Kscan Chosen Value in DTS\nDESCRIPTION: This code snippet shows how to update the `zmk,kscan` chosen value in the Device Tree Source (DTS) file. This is required when integrating the dedicated GPIO pin into a key switch combination using a direct kscan. The snippet points the kscan to the new kscan instance.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/soft-off-setup.mdx#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    chosen {\n        ...\n        zmk,kscan = &side_band_behavior_triggers;\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Advanced Mouse Move Configuration\nDESCRIPTION: This snippet shows the default settings for the `&mmv` behavior, an instance of `zmk,behavior-input-two-axis`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_12\n\nLANGUAGE: dts\nCODE:\n```\n&mmv {\n    x-input-code = <INPUT_REL_X>;\n    y-input-code = <INPUT_REL_Y>;\n    time-to-max-speed-ms = <300>;\n    acceleration-exponent = <1>;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating a ZMK Module Name in zephyr/module.yml\nDESCRIPTION: This code snippet shows the recommended naming convention for the ZMK module in the `zephyr/module.yml` file. It emphasizes using the prefix `zmk-keyboard-` followed by the keyboard name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: zmk-keyboard-<keyboard_name>\n```\n\n----------------------------------------\n\nTITLE: Cloning ZMK Repository with Git\nDESCRIPTION: Clones the ZMK source code repository from GitHub to a local directory.  This is the first step in setting up the development environment. Requires Git to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone https://github.com/zmkfirmware/zmk.git\n```\n\n----------------------------------------\n\nTITLE: Disabling Rotary Encoder in ZMK\nDESCRIPTION: This snippet disables the rotary encoder functionality in ZMK. It sets `CONFIG_EC11` and `CONFIG_EC11_TRIGGER_GLOBAL_THREAD` to 'n', preventing the encoder from being initialized and used. This is necessary if the Nibble keyboard was built without an encoder. Add these configurations to the local nibble config file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nibble/README.md#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_EC11=n\nCONFIG_EC11_TRIGGER_GLOBAL_THREAD=n\n```\n\n----------------------------------------\n\nTITLE: Copyright header for devicetree bindings (.yaml)\nDESCRIPTION: This is the required copyright header to be included in all new devicetree binding files (``.yaml``) created for ZMK. Remember to update the year `XXXX`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_11\n\nLANGUAGE: YAML\nCODE:\n```\n// highlight-next-line\n# Copyright (c) XXXX The ZMK Contributors\n# SPDX-License-Identifier: MIT\n```\n\n----------------------------------------\n\nTITLE: Fixing Memory Allocation in DTS files (diff)\nDESCRIPTION: This code snippet shows the diff of changes made to the device tree source (.dts) files.  It adjusts the memory regions allocated for the code and storage partitions to avoid overlapping with the bootloader's memory region. This ensures the bootloader operates correctly without being overwritten by the settings system.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-10-03-bootloader-fix.md#_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n        code_partition: partition@26000 {\n-           reg = <0x00026000 0x000d2000>;\n+           reg = <0x00026000 0x000c6000>;\n        };\n\n\n-       storage_partition: partition@f8000 {\n+       storage_partition: partition@ec000 {\n-           reg = <0x000f8000 0x00008000>;\n+           reg = <0x000ec000 0x00008000>;\n        };\n```\n\n----------------------------------------\n\nTITLE: Conditional Bluetooth Subdirectory Inclusion CMake\nDESCRIPTION: This snippet conditionally includes the Bluetooth subdirectory if the `CONFIG_ZMK_SPLIT_BLE` configuration option is enabled. This allows enabling Bluetooth support for split keyboards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif (CONFIG_ZMK_SPLIT_BLE)\n    add_subdirectory(bluetooth)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware for Nice!60\nDESCRIPTION: This command builds the ZMK firmware for the Nice!60 keyboard. It utilizes the `west build` command with specific parameters to configure the build process for the target keyboard.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/nice60/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwest build -p -b nice60\n```\n\n----------------------------------------\n\nTITLE: GitHub Actions DTS File Deletion (YAML)\nDESCRIPTION: This snippet removes the DTS output step from a GitHub Actions workflow file (`build.yml`). It's no longer needed after the Zephyr 3.0 update.  This prevents errors during the build process. The snippet should be located and removed from the `build.yml` file in the `.github/workflows/` directory of the user config repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n  - name: ${{ steps.variables.outputs.display-name }} DTS File\n    if: ${{ always() }}\n    run: |\n      if [ -f \"build/zephyr/${{ matrix.board }}.pre.tmp\" ]; then cat -n build/zephyr/${{ matrix.board }}.pre.tmp; fi\n      if [ -f \"build/zephyr/zephyr.dts\" ]; then cat -n build/zephyr/zephyr.dts; fi\n```\n\n----------------------------------------\n\nTITLE: Combined Position Map: Macropad & Numpad (Numpad Ref) - DTS\nDESCRIPTION: This snippet presents a combined position map using the numpad (with fewer keys) as the reference.  The macropad layout's missing positions are handled but this approach is less common. The `physical-layout` property points to the respective physical layouts.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_13\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map2 {\n        compatible = \"zmk,physical-layout-position-map\";\n        complete;\n\n        macropad_map: macropad {\n            physical-layout = <&macropad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10   >\n                , <12 13 14 15>\n                , <16    18   >;\n        };\n\n        numpad_map: numpad {\n            physical-layout = <&numpad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10   >\n                , <11 12 13 14>\n                , <15    16   >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion\nDESCRIPTION: This CMake command conditionally adds `main.c` to the application's source files if the `CONFIG_ZMK_DISPLAY` configuration option is enabled. This ensures that display-related code is included only when a display is configured.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_DISPLAY app PRIVATE main.c)\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories in CMake\nDESCRIPTION: This snippet uses the `add_subdirectory` function to add 'drivers' and 'lib' as subdirectories to the CMake project. This incorporates the CMakeLists.txt files present in those directories into the main project build process.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(drivers)\n```\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(lib)\n```\n\n----------------------------------------\n\nTITLE: Include Zephyr Drivers Directory\nDESCRIPTION: Adds the `${ZEPHYR_BASE}/drivers` directory to the include paths for the Zephyr library. This allows the library to access driver-related header files provided by Zephyr RTOS.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/mikoto/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_include_directories(${ZEPHYR_BASE}/drivers)\n```\n\n----------------------------------------\n\nTITLE: Enabling hold-trigger-on-release for hold-tap - DTS\nDESCRIPTION: This enables the `hold-trigger-on-release` property for a hold-tap behavior.  This means that the keys listed in `hold-trigger-key-positions` will produce a tap when released before `tapping-term-ms` expires, rather than when pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_15\n\nLANGUAGE: DTS\nCODE:\n```\n&mt {\n    hold-trigger-on-release;\n};\n```\n\n----------------------------------------\n\nTITLE: Install ZMK CLI (Shell)\nDESCRIPTION: These commands install ZMK CLI using `pipx` and then verify the installation by running `zmk --help`. This is the core installation step.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\npipx install zmk\nzmk --help\n```\n\n----------------------------------------\n\nTITLE: Create Dongle Overlay File for ZMK\nDESCRIPTION: This code snippet defines a device tree overlay file for a ZMK keyboard dongle. It includes the matrix transform, and introduces a mock kscan since the dongle itself has no keys. The `zmk,kscan` property in the chosen node is set to the mock kscan.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/dongle.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/matrix_transform.h>\n\n/ {\n    chosen {\n        zmk,kscan = &mock_kscan;\n    };\n\n    mock_kscan: mock_kscan_0 {\n        compatible = \"zmk,kscan-mock\";\n        columns = <0>;\n        rows = <0>;\n        events = <0>;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Conditionally include source files based on ZMK config\nDESCRIPTION: This CMake code block conditionally includes source files into the 'app' target based on the values of `CONFIG_ZMK_SPLIT_ROLE_CENTRAL` and `CONFIG_ZMK_SPLIT_BLE_CENTRAL_BATTERY_LEVEL_PROXY`.  It checks if the configuration options are set, and if so, adds the specified C source files to the build.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/bluetooth/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nif (NOT CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n  target_sources(app PRIVATE service.c)\n  target_sources(app PRIVATE peripheral.c)\nendif()\nif (CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n  target_sources(app PRIVATE central.c)\nendif()\n\nif (CONFIG_ZMK_SPLIT_BLE_CENTRAL_BATTERY_LEVEL_PROXY)\n  target_sources(app PRIVATE central_bas_proxy.c)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Add Zephyr Library Sources\nDESCRIPTION: This command specifies the source files to be included in the Zephyr library. In this case, `ec11.c` is added as a source file for the library.  This source file likely implements rotary encoder functionality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/ec11/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources(ec11.c)\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware for S40NC Keyboard\nDESCRIPTION: This command uses the West build tool to build the ZMK firmware for the s40nc board. The `-p` flag cleans the build directory before building, and `-b s40nc` specifies the target board as s40nc.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/s40nc/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwest build -p -b s40nc\n```\n\n----------------------------------------\n\nTITLE: Kscan Matrix Definition\nDESCRIPTION: This device tree snippet defines a kscan matrix with row and column GPIOs. It specifies the compatible string, diode direction, and wakeup source. The col-gpios and row-gpios properties define the GPIO pins used to read the matrix state, including their respective GPIO flags.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-matrix.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    kscan: kscan {\n        compatible = \"zmk,kscan-gpio-matrix\";\n        diode-direction = \"col2row\";\n        wakeup-source;\n\n        col-gpios\n            = <&gpio0 12 GPIO_ACTIVE_HIGH>\n            , <&gpio1 9  GPIO_ACTIVE_HIGH>\n            ;\n        row-gpios\n            = <&gpio0 19 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            , <&gpio0 4  (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN)>\n            ;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Split Set HID Peripheral Executable\nDESCRIPTION: This command executes the `tests_ble_split_set-hid-indicators_peripheral.exe` executable. It sets the device discovery delay using the `-d=3` parameter, configuring the peripheral device for HID indicator testing.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/set-hid-indicators/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./tests_ble_split_set-hid-indicators_peripheral.exe -d=3\n```\n\n----------------------------------------\n\nTITLE: Using Sticky Keys/Mods in ZMK Keymap\nDESCRIPTION: This code snippet demonstrates how to use sticky keys in a ZMK keymap. Sticky keys, also known as one-shot modifiers, allow you to press a modifier key (like Ctrl, Shift, Alt) once, and it will remain active for the next keypress. &sk followed by a keycode name creates a sticky key/modifier. &sl followed by a layer name applies that layer until a key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2021-01-27-zmk-sotf-4.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&sk LEFT_CONTROL\n```\n\nLANGUAGE: dts\nCODE:\n```\n&sl NAV\n```\n\n----------------------------------------\n\nTITLE: Amend Zephyr Library\nDESCRIPTION: This line uses the `zephyr_library_amend()` function to amend the current Zephyr library. This function is part of the Zephyr build system and allows for modifying existing libraries.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/gpio/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_amend()\n```\n\n----------------------------------------\n\nTITLE: Old I2C bus setup in DTS - DTS\nDESCRIPTION: Shows the old I2C bus setup in ZMK using devicetree source properties.  The `sda-pin` and `scl-pin` properties directly define the pins for the I2C bus, which has been replaced by the pinctrl system in newer versions. This example showcases the previous method of pin configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n&i2c0 {\n    compatible = \"nordic,nrf-twi\";\n    sda-pin = <17>;\n    scl-pin = <20>;\n};\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central with Debug Level and Halt\nDESCRIPTION: This command executes the `ble_test_central.exe` application with a specified debug level of 2 and instructs it to halt execution after bonding. This is likely used for debugging bonding procedures.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/bond-to-cleared-profile/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -halt_after_bonding\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Peripheral Test 1\nDESCRIPTION: This command executes a BLE peripheral test executable, part of a multiple-peripherals setup for split keyboards. The `-d=3` argument likely specifies a device ID or debug level. It's intended to test the ZMK firmware's ability to handle multiple BLE peripherals in a split configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/multiple-peripherals/siblings.txt#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n./tests_ble_split_multiple-peripherals_peripheral1.exe -d=3\n```\n\n----------------------------------------\n\nTITLE: Layer Switching with Underglow Color Change in ZMK\nDESCRIPTION: This code snippet configures a ZMK macro to switch layers and change the underglow color when pressed and released. It utilizes `&macro_press` for layer activation, `&macro_tap` to change the underglow, `&macro_pause_for_release` to wait for key release, and `&macro_release` to revert layer activation. The RGB color is defined using `RGB_COLOR_HSB`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_10\n\nLANGUAGE: dts\nCODE:\n```\nwait-ms = <0>;\ntap-ms = <0>;\nbindings\n    = <&macro_press &mo 1>\n    , <&macro_tap &rgb_ug RGB_COLOR_HSB(128,100,100)>\n    , <&macro_pause_for_release>\n    , <&macro_release &mo 1>\n    , <&macro_tap &rgb_ug RGB_COLOR_HSB(300,100,50)>;\n\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include Source File\nDESCRIPTION: This line conditionally includes the `il0323.c` source file in the Zephyr library if the `CONFIG_IL0323` configuration option is defined. The `zephyr_library_sources_ifdef` function likely adds `il0323.c` to the library's source files only when the condition is met. This allows for modularity and feature toggling within the ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/display/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_IL0323 il0323.c)\n```\n\n----------------------------------------\n\nTITLE: BLE Test Central - Device Selection\nDESCRIPTION: This command executes `ble_test_central.exe` specifying the device with ID 2 and halts after bonding. The `-d=2` parameter indicates the device ID to connect to.  `-halt_after_bonding` instructs the program to stop after a successful bonding process.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/dont-bond-to-taken-profile/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -halt_after_bonding\n```\n\n----------------------------------------\n\nTITLE: Global Sticky Key Configuration\nDESCRIPTION: This snippet shows how to configure default settings for all sticky keys, including `release-after-ms` and `quick-release`. It also demonstrates how to remove the `ignore-modifiers` property.  This configuration applies to all sticky keys which might not be appropriate in all scenarios.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-key.md#_snippet_2\n\nLANGUAGE: DTS\nCODE:\n```\n&sk {\n    release-after-ms = <2000>;\n    quick-release;\n    /delete-property/ ignore-modifiers;\n};\n```\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling nice!view SPI in leeloo_micro.keymap (ZMK)\nDESCRIPTION: This code snippet shows the modification required in the `leeloo_micro.keymap` file to enable the nice!view display.  It involves uncommenting the `nice_view_spi` block by removing the forward slashes. This configuration assigns the chip select GPIO pin for the SPI communication with the nice!view display.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo_micro/README.md#_snippet_2\n\nLANGUAGE: Text\nCODE:\n```\nnice_view_spi: &spi0 {\n    cs-gpios = <&pro_micro 4 GPIO_ACTIVE_HIGH>;\n};\n```\n\n----------------------------------------\n\nTITLE: Toggle Layer Activation\nDESCRIPTION: This snippet demonstrates how to toggle a layer on or off. If the layer is currently disabled, it will be enabled, and vice versa. The `&tog` behavior is used with a parameter specifying the layer number to toggle.  In this example, layer 3 (the 4th layer) is toggled.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&tog 3\n```\n\n----------------------------------------\n\nTITLE: Setting user.home for ZMK CLI\nDESCRIPTION: This command sets the `user.home` configuration option for the ZMK CLI, specifying the default repository path when the current working directory is not within a ZMK config repository. This is crucial for directing the CLI to the correct configuration files.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\nzmk config user.home ~/Documents/zmk-config\n```\n\n----------------------------------------\n\nTITLE: Running Setup Script with Wget\nDESCRIPTION: This command uses wget to download the ZMK setup script from the zmk.dev website and then executes it using bash. It is an alternative to using curl for downloading and running the setup script.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup.mdx#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbash -c \"$(wget https://zmk.dev/setup.sh -O -)\" '' --wget\n```\n\n----------------------------------------\n\nTITLE: Install pipx (Shell)\nDESCRIPTION: These commands install `pipx` using `pip` and ensure it's added to the system's PATH. This setup is crucial for isolating ZMK CLI's dependencies.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\npython3 -m pip install --user pipx\npython3 -m pipx ensurepath\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central with Debug Level and Start Wait\nDESCRIPTION: This command executes the `ble_test_central.exe` application with a specified debug level of 3 and instructs it to wait 1300 milliseconds after start. This might be used to simulate delays or allow time for other components to initialize before proceeding.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/bond-to-cleared-profile/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=3 -wait_on_start=1300\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Central Test\nDESCRIPTION: This command executes a BLE central test executable. The `-d=2` argument likely specifies a device ID or debug level for the test execution.  It's part of a larger testing suite for BLE functionality in the ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/multiple-peripherals/siblings.txt#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n./ble_test_central.exe -d=2\n```\n\n----------------------------------------\n\nTITLE: Wrapping KScan with Sideband Behavior in DTS\nDESCRIPTION: This Device Tree snippet defines a KScan sideband behavior trigger. It wraps an existing KScan driver (`&wakeup_scan`) defined elsewhere.  `auto-enable` enables the driver automatically. `wakeup-source` marks this as a wake-up source. The `soft_off` child node specifies the column and row of the key to trigger the `&hw_soft_off` binding.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-direct.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    side_band_behavior_triggers: side_band_behavior_triggers {\n        compatible = \"zmk,kscan-sideband-behaviors\";\n\n        kscan = <&wakeup_scan>;\n        auto-enable;\n        wakeup-source;\n\n        soft_off {\n            column = <0>;\n            row = <0>;\n            bindings = <&hw_soft_off>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Defining File Format\nDESCRIPTION: Shows how to define the file format in the metadata file.  The `file_format` property should be set to \"1\".\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nfile_format: \"1\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Bootloader Size\nDESCRIPTION: This calculation determines the size of flash memory used by the bootloader. It subtracts the bootloader's start address from the end of flash memory to find the bootloader's size, which is crucial for properly re-allocating the settings flash area.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-10-03-bootloader-fix.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n0x100000 (end of flash) - 0x0F4000 (start of bootloader) = 0xC000 (48KB)\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Split Peripheral Test Executable\nDESCRIPTION: This command executes the `tests_ble_split_run-peripheral-behavior_peripheral.exe` executable. The `-d=3` parameter sets the debug level to 3, indicating a possibly higher level of debug output than the central test.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/run-peripheral-behavior/siblings.txt#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./tests_ble_split_run-peripheral-behavior_peripheral.exe -d=3\n```\n\n----------------------------------------\n\nTITLE: BLE Central Test Execution\nDESCRIPTION: Executes the `ble_test_central.exe` application with specific command-line arguments to control its behavior. The `-d=2` argument likely sets the debug level to 2. `-skip_set_security_on_connect` disables security settings on connection. `-read_hid_report_on_connect` enables reading HID reports immediately after connecting, and `-skip_discovery_on_connect` bypasses device discovery during connection.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/security/read-hid-after-connect-with-auto-sec/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -skip_set_security_on_connect -read_hid_report_on_connect -skip_discovery_on_connect\n```\n\n----------------------------------------\n\nTITLE: Building Additional Keyboards with YAML\nDESCRIPTION: This YAML snippet demonstrates how to configure GitHub Actions to build firmware for multiple keyboard configurations using the `build.yml` file in the `zmk-config` repository. It includes configurations for Corne and Lily58 keyboards with different nice!nano versions. The `include` section lists the board and shield combinations to be built.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/customization.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\ninclude:\n  - board: nice_nano\n    shield: corne_left\n  - board: nice_nano\n    shield: corne_right\n  - board: nice_nano_v2\n    shield: lily58_left\n  - board: nice_nano_v2\n    shield: lily58_right\n```\n\n----------------------------------------\n\nTITLE: Naming a ZMK Module in module.yml\nDESCRIPTION: This snippet shows how to define the name of a ZMK module within the zephyr/module.yml file. The module name should follow the convention: zmk-<type>-<description> where type can be keyboard, component, behavior, driver, feature or vfx. This name uniquely identifies the module within the ZMK ecosystem.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/module-creation.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: <your module name>\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include EC11 Subdirectory in ZMK\nDESCRIPTION: This snippet employs the CMake function `add_subdirectory_ifdef` to conditionally include the `ec11` subdirectory in the ZMK project.  The inclusion is dependent on the `CONFIG_EC11` Kconfig option being enabled, allowing for modular integration of EC11 encoder support.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_EC11 ec11)\n```\n\n----------------------------------------\n\nTITLE: Using 'process-next' Property for Input Processors in DTS\nDESCRIPTION: This snippet shows how to use the `process-next` property to allow other processors to be checked and applied even if the current node's layer filter matches.  When layer `1` is active, both the `zip_xy_to_scroll_mapper` and the base `zip_xy_scaler` will be applied. `input/processors.dtsi` must be included.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/usage.md#_snippet_2\n\nLANGUAGE: DTS\nCODE:\n```\n#include <input/processors.dtsi>\n\n&trackpad_listener {\n    input-processors = <&zip_xy_scaler 3 2>;\n\n    scroller {\n        layers = <1>;\n        input-processors = <&zip_xy_to_scroll_mapper>;\n        process-next;\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Kconfig.defconfig for Unibody Keyboard\nDESCRIPTION: This snippet shows the `Kconfig.defconfig` file for a unibody keyboard. It sets the `ZMK_KEYBOARD_NAME` configuration option within a conditional block based on the `SHIELD_MY_KEYBOARD` flag.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/new-shield.mdx#_snippet_3\n\nLANGUAGE: kconfig\nCODE:\n```\nif SHIELD_MY_KEYBOARD\n\n# Name must be less than 16 characters long!\nconfig ZMK_KEYBOARD_NAME\n    default \"My Keyboard\"\n\nendif\n```\n\n----------------------------------------\n\nTITLE: Amend Zephyr Library\nDESCRIPTION: This snippet amends an existing Zephyr library. It doesn't take any parameters and modifies an existing Zephyr library based on the surrounding build environment.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/input/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_amend()\n```\n\n----------------------------------------\n\nTITLE: Omitting specific behaviors in keymap.dts\nDESCRIPTION: This snippet demonstrates how to omit a specific behavior from the ZMK firmware build. By defining `ZMK_BEHAVIORS_OMIT_KT` before including `behaviors.dtsi`, the `&kt` behavior will be excluded from the build, which is useful to reduce the size of the built firmware or to explicitly remove unused behaviors.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/studio.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n#define ZMK_BEHAVIORS_OMIT_KT\n\n#include <behaviors.dtsi>\n```\n\n----------------------------------------\n\nTITLE: Creating Podman Volume for ZMK Modules\nDESCRIPTION: Creates a Podman volume named 'zmk-modules' and binds it to a specified local directory. This allows the container to access ZMK modules. Requires Podman to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\npodman volume create --driver local -o o=bind -o type=none \\\n  -o device=\"/absolute/path/to/zmk-modules/parent/\" zmk-modules\n```\n\n----------------------------------------\n\nTITLE: ZMK Convenience C Macro Usage\nDESCRIPTION: This code snippet shows how to use the `ZMK_MACRO` C macro in ZMK to simplify the declaration of a zero-parameter macro. It specifies the macro name and properties within the macro definition. This simplifies the process, especially for basic macros.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_13\n\nLANGUAGE: dts\nCODE:\n```\nZMK_MACRO(my_zero_param_macro,\n        wait-ms = <30>;\n        tap-ms = <40>;\n        bindings = <&kp Z &kp M &kp K>;\n    )\n\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware with West\nDESCRIPTION: This command builds the ZMK firmware for the Ferris 0.2 keyboard using the `west build` tool. It specifies the board as `ferris_rev02` and sets the output directory to `build/ferris`. The `-p` flag enables precompiled headers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/ferris/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nwest build -p -d build/ferris --board ferris_rev02\n```\n\n----------------------------------------\n\nTITLE: Executing ble_test_central with Device ID and Halt After Bonding\nDESCRIPTION: This command executes the ble_test_central.exe application. It specifies the device ID using the -d option and sets the application to halt after bonding using the -halt_after_bonding option. This is useful for testing the bonding functionality with a particular device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/bond-clear-then-bond-second-client/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -halt_after_bonding\n```\n\n----------------------------------------\n\nTITLE: Initial Commit Log\nDESCRIPTION: This code snippet shows the initial commit log for the ZMK firmware project. It provides information such as the commit hash, author, date, and a list of files that were added or modified in the initial commit. It also shows the number of insertions made in each file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-21-zmk-2yo.md#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\ncommit 85c8be89dea8f7a00e8efb06d38e2b32f3459935\nAuthor: Pete Johanson <peter@peterjohanson.com>\nDate:   Tue Apr 21 16:20:34 2020 -0400\n\n    Initial work.\n\n .gitignore     |  1 +\n .gitmodules    |  3 +++\n CMakeLists.txt | 40 +++++++++++++++++++++++++++++++++++++++\n src/main.c     | 60 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n src/zmk_lib.h  |  7 +++++++\n zephyr-rust    |  1 +\n 6 files changed, 112 insertions(+)\n```\n\n----------------------------------------\n\nTITLE: Old I2C Configuration\nDESCRIPTION: This DTS snippet shows the old way of configuring I2C without pinctrl, directly assigning the SDA and SCL pins.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-04-06-zephyr-3-2.md#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\n&i2c0 {\n\tcompatible = \"nordic,nrf-twi\";\n\tsda-pin = <15>;\n\tscl-pin = <17>;\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Docusaurus Dependencies with npm\nDESCRIPTION: This snippet shows how to install Docusaurus dependencies using `npm ci`. This command is essential for setting up the environment to work on the ZMK documentation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm ci\n```\n\n----------------------------------------\n\nTITLE: Check Git Version (Shell)\nDESCRIPTION: This command checks if Git is installed and prints its version number. It's a preliminary step to ensure Git is available before proceeding with ZMK CLI installation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit --version\n```\n\n----------------------------------------\n\nTITLE: Including Composite Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_composite.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_COMPOSITE_DRIVER` Kconfig option is defined. This driver combines multiple scanning methods.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_7\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_COMPOSITE_DRIVER kscan_composite.c)\n```\n\n----------------------------------------\n\nTITLE: Defining a Wake-Up Scan with GPIO Direct in DTS\nDESCRIPTION: This Device Tree Snippet defines a wake-up scan using the GPIO direct KScan driver. The `compatible` property specifies the driver to use. `input-keys` refers to a GPIO key defined elsewhere (`&soft_off_gpio_key`). `wakeup-source` marks this scan as a wake-up source, allowing the system to wake up from a low-power state when this key is pressed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-direct.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    wakeup_scan: wakeup_scan {\n        compatible = \"zmk,kscan-gpio-direct\";\n        input-keys = <&soft_off_gpio_key>;\n        wakeup-source;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v2 Custom Keymap with nice!view\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v2 keyboard with a custom keymap and support for nice!view displays. It combines the `-DSHIELD` parameter for display support with the `-DZMK_CONFIG` parameter for custom keymap configuration.  Replace `/workspaces/zmk-config/[yourName]/leeloo_v2/config` with the correct path to your custom config.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/left -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_rev2_left nice_view_adapter nice_view\" -DZMK_CONFIG=\"/workspaces/zmk-config/[yourName]/leeloo_v2/config\"\nwest build -d build/right -p -b nice_nano_v2 -- -DSHIELD=\"leeloo_rev2_right nice_view_adapter nice_view\" -DZMK_CONFIG=\"/workspaces/zmk-config/[yourName]/leeloo_v2/config\"\n```\n\n----------------------------------------\n\nTITLE: Rendering Vendor Sponsors List with JavaScript\nDESCRIPTION: This JavaScript snippet dynamically generates a list of vendor sponsors, categorized by sponsorship level. It maps through an array of sponsor data, creating HTML elements for each sponsor, including their logo (with light and dark mode variants) and a link to their website. The HTML elements are styled with CSS for layout.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-11-11-zmk-studio-mvp-ga.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n{(function() {\nconst sponsors = [\n{\nlevel: \"Platinum\",\nvendors: [\n{\nname: \"nice!keyboards / typeractive\",\nimg: niceAndTyperactive,\ndarkModeImg: niceAndTyperactiveDarkMode,\nurl: \"https://typeractive.xyz/\",\n},\n{\nname: \"Kinesis\",\nimg: kinesis,\ndarkModeImg: kinesisDarkMode,\nurl: \"https://kinesis-ergo.com/\",\n},\n],\n},\n{\nlevel: \"Gold+\",\nvendors: [\n{\nname: \"CannonKeys\",\nimg: cannonKeys,\ndarkModeImg: cannonKeysDarkMode,\nurl: \"https://cannonkeys.com/\",\n},\n{\nname: \"Keychron\",\nimg: keychron,\ndarkModeImg: keychronDarkMode,\nurl: \"https://keychron.com/\",\n},\n],\n},\n{\nlevel: \"Gold\",\nvendors: [\n{\nname: \"Little Keyboards\",\nimg: littleKeyboards,\ndarkModeImg: littleKeyboardsDarkMode,\nurl: \"https://littlekeyboards.com/\",\n},\n{\nname: \"Keebmaker\",\nimg: keebmaker,\ndarkModeImg: keebmakerDarkMode,\nurl: \"https://keebmaker.com/\",\n},\n],\n},\n{\nlevel: \"Silver\",\nvendors: [\n{\nname: \"keeb.io\",\nimg: keebio,\nurl: \"https://keeb.io/\",\n},\n{\nname: \"Mode Designs\",\nimg: mode,\ndarkModeImg: modeDarkMode,\nurl: \"https://modedesigns.com/\",\n},\n],\n},\n{\nlevel: \"Bronze\",\nvendors: [\n{\nname: \"deskhero\",\nimg: deskHero,\ndarkModeImg: deskHeroDarkMode,\nurl: \"https://deskhero.ca/\",\n},\n{\nname: \"PhaseByte\",\nimg: phaseByte,\nurl: \"https://phasebyte.com/\",\n},\n{\nname: \"Mechlovin'\",\nimg: mechlovin,\ndarkModeImg: mechlovinDarkMode,\nurl: \"https://mechlovin.studio/\",\n},\n],\n},\n{\nlevel: \"Additional\",\nvendors: [\n{\nname: \"splitkb.com\",\nimg: splitkb,\ndarkModeImg: splitkbDarkMode,\nurl: \"https://splitkb.com/\",\n},\n{\nname: \"keycapsss\",\nimg: keycapsss,\ndarkModeImg: keycapsssDarkMode,\nurl: \"https://keycapsss.com/\",\n},\n{\nname: \"mekibo\",\nimg: mekibo,\ndarkModeImg: mekiboDarkMode,\nurl: \"https://mekibo.com/\",\n},\n],\n},\n];\n\nreturn sponsors.map(g => {\nreturn (\n\n  \n    <h4>{g.level} Level</h4>\n    \n      \n        \n      \n      {g.vendors.map((v) => {\n        return (\n          \n            \n              light: v.img,\n              dark: v.darkModeImg || v.img,\n            }}\n          />\n          \n        );\n      })}\n    \n  \n);\n}); }())}\n```\n\n----------------------------------------\n\nTITLE: Verify Toolchain with CMake\nDESCRIPTION: This command uses CMake to verify the toolchain being used for building the ZMK firmware. It prints information such as the Zephyr SDK version and the installation directory, which are necessary to configure the C/C++ extension in Visual Studio Code. This command should be run from VS Code's integrated terminal in the ZMK repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/ide-integration.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncmake -P zephyr/cmake/verify-toolchain.cmake\n```\n\n----------------------------------------\n\nTITLE: Defining Module Dependencies in west.yml\nDESCRIPTION: This YAML snippet illustrates how to define module dependencies using a west manifest file (west.yml). The snippet shows how to specify remote repositories and projects, including the `import` field to include further west manifest files from the remote module. This allows automatic tooling to fetch the modules when building firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/module-creation.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  remotes:\n    - name: remote-name\n      url-base: https://github.com/remote-name\n  projects:\n    # Together with the above defined remote, this refers to a module located at\n    # https://github.com/remote-name/repository-name\n    - name: repository-name\n      remote: remote-name\n      # This points to a west manifest file in the remote module for further imports\n      import: west.yml\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: This command installs the necessary dependencies for the ZMK website using npm. It ensures a clean and consistent installation based on the project's package-lock.json file.  It requires npm to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/README.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ npm ci\n```\n\n----------------------------------------\n\nTITLE: Formatting Documentation with Prettier using npm\nDESCRIPTION: This snippet shows how to format the documentation files using Prettier with `npm run prettier:format`. This ensures consistent code style across the documentation.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prettier:format\n```\n\n----------------------------------------\n\nTITLE: Including Output Defines in Keymap\nDESCRIPTION: This code snippet shows how to include the `dt-bindings/zmk/outputs.h` header file in your keymap file.  This header provides definitions for output selection commands such as `OUT_USB`, `OUT_BLE`, and `OUT_TOG`. This allows you to reference these actions directly in your keymap configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/outputs.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n#include <dt-bindings/zmk/outputs.h>\n```\n\n----------------------------------------\n\nTITLE: Adding Subdirectories Conditionally\nDESCRIPTION: This snippet conditionally adds subdirectories to the build based on Kconfig options, allowing modularization of the firmware and inclusion of optional features like display and settings.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_4\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory(src/display/)\nadd_subdirectory_ifdef(CONFIG_SETTINGS src/settings/)\n```\n\n----------------------------------------\n\nTITLE: Enable ZMK snippet in local build command\nDESCRIPTION: This shell command demonstrates how to enable a ZMK snippet when performing a local build.  The `-S` flag specifies the name of the snippet to include in the build.  The command builds for the `nrfmicro_13_52833` board, includes the `nrf52833-nosd` snippet, and sets the `SHIELD` definition to `corne_left`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/system.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nwest build -b nrfmicro_13_52833 -S nrf52833-nosd -- -DSHIELD=corne_left\n```\n\n----------------------------------------\n\nTITLE: Connect to USB Logging on macOS - Shell\nDESCRIPTION: This snippet shows how to connect to the USB CDC ACM device exposed by the ZMK firmware on macOS using `tio`. The command assumes the device is at `/dev/tty.usbmodem14401`.  The user needs appropriate permissions, hence `sudo`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nsudo tio /dev/tty.usbmodem14401\n```\n\n----------------------------------------\n\nTITLE: Install Python 3.10 on Ubuntu 20.04 (Shell)\nDESCRIPTION: These commands add the `deadsnakes` PPA and install Python 3.10 on Ubuntu 20.04 or older. This is necessary if the default Python version is older than 3.10.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nsudo add-apt-repository ppa:deadsnakes/ppa\nsudo apt install python3.10\n```\n\n----------------------------------------\n\nTITLE: Conditional Display Configuration in CMake\nDESCRIPTION: This CMake code snippet conditionally includes source files based on ZMK display and Nice View widget configurations. It checks for `CONFIG_ZMK_DISPLAY` and `CONFIG_NICE_VIEW_WIDGET_STATUS` and, if true, includes necessary directories and sources. The snippet also includes conditional logic for split keyboards, including different widgets for central and peripheral roles.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nice_view/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nif(CONFIG_ZMK_DISPLAY AND CONFIG_NICE_VIEW_WIDGET_STATUS)\n  zephyr_library_include_directories(${CMAKE_SOURCE_DIR}/include)\n  zephyr_library_sources(custom_status_screen.c)\n  zephyr_library_sources(widgets/bolt.c)\n  zephyr_library_sources(widgets/util.c)\n\n  if(NOT CONFIG_ZMK_SPLIT OR CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n    zephyr_library_sources(widgets/status.c)\n  else()\n    zephyr_library_sources(widgets/art.c)\n    zephyr_library_sources(widgets/peripheral_status.c)\n  endif()\nendif()\n```\n\n----------------------------------------\n\nTITLE: BLE Test Central - Delayed Startup\nDESCRIPTION: This command runs `ble_test_central.exe` targeting device ID 3 and waits for 1300 milliseconds after start. The `-d=3` parameter sets the device ID, and `-wait_on_start=1300` introduces a delay after the application starts to allow for setup tasks before proceeding with the test.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/dont-bond-to-taken-profile/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=3 -wait_on_start=1300\n```\n\n----------------------------------------\n\nTITLE: Running ESLint for Linting\nDESCRIPTION: This snippet runs ESLint to lint code and ensure consistent code style, and identify potential errors.  It uses the command `npm run lint`, assuming `npm` is configured and the `lint` script is defined in the `package.json` file. This allows developers to verify their changes adhere to the established code style guidelines.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/CONTRIBUTING.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm run lint\n```\n\n----------------------------------------\n\nTITLE: Using Transformer with Flags - DTS\nDESCRIPTION: This snippet shows how to use a transformer instance with specific transformation flags. The `&zip_xy_transform` instance is being called with a combination of `INPUT_TRANSFORM_X_INVERT` and `INPUT_TRANSFORM_Y_INVERT` flags, which will invert the X and Y values of the targeted input events. This is a common pattern when using predefined transformer instances.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/transformer.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&zip_xy_transform (INPUT_TRANSFORM_X_INVERT | INPUT_TRANSFORM_Y_INVERT)\n```\n\n----------------------------------------\n\nTITLE: Setting Tap Time for Macro Actions (DTS)\nDESCRIPTION: This snippet shows how to configure the tap time for actions within a macro. The initial tap time can be set with `tap-ms = <value>;`. The tap time can be dynamically changed within the macro's `bindings` using `&macro_tap_time <value>`.  The tap time is in milliseconds.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_6\n\nLANGUAGE: dts\nCODE:\n```\nbindings\n    = <&macro_tap_time 10>\n    , <&kp S &kp H &kp O &kp R &kp T>\n    , <&macro_tap_time 500>\n    , <&kp L &kp O &kp N &kp G>\n    ;\n```\n\n----------------------------------------\n\nTITLE: Configure Wakeup Scan using GPIO Key - DTS\nDESCRIPTION: This snippet configures the wakeup scan using a direct kscan driver and a GPIO key. It defines a `wakeup_scan` node with the `zmk,kscan-gpio-direct` compatible property and specifies the input key using the `input-keys` property. The `wakeup-source` property enables wakeup functionality.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/includes/_sideband-wakeup-direct.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n/ {\n    wakeup_scan: wakeup_scan {\n        compatible = \"zmk,kscan-gpio-direct\";\n        input-keys = <&soft_off_gpio_key>;\n        wakeup-source;\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Definition\nDESCRIPTION: This snippet defines a Zephyr library. It does not require external dependencies beyond Zephyr RTOS' CMake infrastructure. This line specifies that a Zephyr library should be created and configured within the build system.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/puchi_ble/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Initializing CMake and Zephyr\nDESCRIPTION: This snippet initializes the CMake environment, sets Zephyr-specific configurations, and finds the Zephyr package to integrate Zephyr's build system. It also defines extra modules for ZMK and sets the project name.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.13.1)\n\nset(CONFIG_APPLICATION_DEFINED_SYSCALL true)\n\nset(ZEPHYR_BOARD_ALIASES \"boards/aliases.cmake\")\nset(ZEPHYR_EXTRA_MODULES \"${ZMK_EXTRA_MODULES};${CMAKE_CURRENT_SOURCE_DIR}/module;${CMAKE_CURRENT_SOURCE_DIR}/keymap-module\")\n\n# Find Zephyr. This also loads Zephyr's build system.\nfind_package(Zephyr REQUIRED HINTS ../zephyr)\nproject(zmk)\n```\n\n----------------------------------------\n\nTITLE: Using `&to` Layer Behavior in ZMK Keymap\nDESCRIPTION: This code snippet shows how to use the `&to` layer behavior in a ZMK keymap.  The `&to` behavior allows you to completely replace the active layer with a new one.  This is commonly used to switch between different base layers, such as QWERTY and DVORAK.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2021-01-27-zmk-sotf-4.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&to NAV\n```\n\n----------------------------------------\n\nTITLE: Add include directories to Zephyr library (CMake)\nDESCRIPTION: This snippet adds several include directories to the Zephyr library. These include directories point to the LVGL module directory, the base LVGL library, the custom status screen include directory, the Zephyr base drivers, and the project's include directory. These are necessary for compiling the Zephyr library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/corneish_zen/CMakeLists.txt#_snippet_3\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_include_directories(${ZEPHYR_LVGL_MODULE_DIR})\nzephyr_library_include_directories(${ZEPHYR_BASE}/lib/gui/lvgl/)\nzephyr_library_sources_ifdef(CONFIG_ZMK_DISPLAY custom_status_screen.c)\nzephyr_library_sources(${ZEPHYR_BASE}/misc/empty_file.c)\nzephyr_library_include_directories(${CMAKE_SOURCE_DIR}/include)\nzephyr_library_include_directories(${ZEPHYR_BASE}/drivers)\n```\n\n----------------------------------------\n\nTITLE: Using Pre-defined Behaviors Instance\nDESCRIPTION: This snippet shows how to override the `bindings` property of the pre-defined `&zip_button_behaviors` instance to trigger different behaviors for mouse button clicks. It demonstrates mapping left, right, and middle clicks to specific key presses A, B, and C respectively.  This requires assigning it to an [input listener](usage.md).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/behaviors.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n&zip_button_behaviors {\n    bindings = <&kp A &kp B &kp C>;\n};\n```\n\n----------------------------------------\n\nTITLE: Applying Left Shift Modifier in ZMK\nDESCRIPTION: This snippet applies the left shift modifier to the 'A' key. This will output a capitalized 'A'.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/modifiers.mdx#_snippet_1\n\nLANGUAGE: ZMK\nCODE:\n```\n&kp LS(A)\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit hooks in ZMK repo\nDESCRIPTION: This snippet demonstrates how to install pre-commit hooks into a Git repository, specifically the ZMK repository. It installs hooks for both the 'commit' and 'commit-msg' stages. This will trigger pre-commit checks on every commit.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/pre-commit.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\npre-commit install --hook-type commit-msg\n```\n\n----------------------------------------\n\nTITLE: Conventional Commit Message Example\nDESCRIPTION: This example demonstrates the proper format for a conventional commit message, including the type, scope, summary, body, and git trailers, as per the ZMK project's requirements.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/pull-requests.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nfeat(boards): Add numpad layouts\n\nAdded physical layouts for the following variants of numpads:\n\n- With and without extra top row\n- 2U plus key or 1U plus and backspace keys\n- 2U 0 key or 1U 0 and 00 keys\n- Full 1U grid/macropad layout\n\nOther layouts exist, such as \"southpaw\" horizontally mirrored layouts,\nand layouts with a fifth column, but those seem to be much less common.\n```\n\n----------------------------------------\n\nTITLE: Configure Sticky Layer Release Delay in ZMK Device Tree\nDESCRIPTION: This snippet configures the `release-after-ms` property for a sticky layer in a ZMK device tree source file. This property sets the delay (in milliseconds) after which the sticky layer is automatically released if no other key is pressed.  The example shows setting the delay to 2000ms.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-layer.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&sl {\n    release-after-ms = <2000>;\n};\n\n/ {\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Toggle Layer with specific mode\nDESCRIPTION: This configuration demonstrates how to define a new behavior to toggle a layer specifically 'on' or 'off'. The `toggle-mode` property is set to either `\"on\"` or `\"off\"` to achieve the desired behavior.  This requires creating a new behavior definition.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        tog_on: toggle_layer_on_only {\n            compatible = \"zmk,behavior-toggle-layer\";\n            #binding-cells = <1>;\n            display-name = \"Toggle Layer On\";\n            toggle-mode = \"on\";\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Adding include directories to Zephyr library\nDESCRIPTION: This snippet adds an include directory (`${ZEPHYR_BASE}/drivers`) to the Zephyr library.  The zephyr_library_include_directories macro adds the specified directory to the library's include path, allowing the source files to access header files located in that directory. `${ZEPHYR_BASE}` is likely a CMake variable pointing to the Zephyr RTOS base directory. This allows the library to access Zephyr driver headers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/glove80/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_include_directories(${ZEPHYR_BASE}/drivers)\n```\n\n----------------------------------------\n\nTITLE: Configure Zephyr Linker Sources\nDESCRIPTION: This CMake command configures Zephyr linker sources by specifying the linker description files. These files define how different sections of the ZMK RPC subsystem are linked during the build process. It adds sections related to data sections, subsystems, handlers, settings reset, event mappers, and transport.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/studio/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_linker_sources(DATA_SECTIONS ../../include/linker/zmk-rpc-subsystems.ld)\nzephyr_linker_sources(SECTIONS ../../include/linker/zmk-rpc-subsystem-handlers.ld)\nzephyr_linker_sources(SECTIONS ../../include/linker/zmk-rpc-subsystem-settings-reset.ld)\nzephyr_linker_sources(SECTIONS ../../include/linker/zmk-rpc-event-mappers.ld)\nzephyr_linker_sources(SECTIONS ../../include/linker/zmk-rpc-transport.ld)\n```\n\n----------------------------------------\n\nTITLE: Combined Position Map: Macropad & Numpad (Macropad Ref) - DTS\nDESCRIPTION: This code demonstrates a combined position map for both a macropad and a numpad, using the macropad as the reference layout (with more keys). Missing keys in the numpad layout are mapped to the highest available positions from the macropad layout, counting backwards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/physical-layouts.md#_snippet_12\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    keypad_position_map1 {\n        compatible = \"zmk,physical-layout-position-map\";\n        complete;\n\n        macropad_map: macropad {\n            physical-layout = <&macropad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10 11>\n                , <12 13 14 15>\n                , <16 17 18 19>;\n        };\n\n        numpad_map: numpad {\n            physical-layout = <&numpad_layout>;\n            positions\n                = < 0  1  2  3>\n                , < 4  5  6  7>\n                , < 8  9 10 19>\n                , <11 12 13 14>\n                , <15 18 16 17>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Sticky Key Behavior Binding Example\nDESCRIPTION: This snippet demonstrates how to bind a sticky key behavior to a specific keycode using the `&sk` reference in a device tree source file.  The example shows binding left shift.  The keycode is passed as a parameter.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/sticky-key.md#_snippet_0\n\nLANGUAGE: DTS\nCODE:\n```\n&sk LSHIFT\n```\n\n----------------------------------------\n\nTITLE: ZMK West Manifest with Modules A and B\nDESCRIPTION: This YAML configuration adds two external modules (Module A and Module B) to the ZMK build. It defines remotes for both modules and includes them as projects within the west manifest.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/modules.mdx#_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  remotes:\n    - name: zmkfirmware\n      url-base: https://github.com/zmkfirmware\n    - name: module_a_base\n      url-base: https://github.com/alice\n    - name: module_b_base\n      url-base: https://github.com/bob\n  projects:\n    - name: zmk\n      remote: zmkfirmware\n      revision: main\n      import: app/west.yml\n    - name: module_a\n      remote: module_a_base\n      revision: main\n    - name: module_b\n      remote: module_b_base\n      revision: main\n      import: west.yml\n  self:\n    path: config\n```\n\n----------------------------------------\n\nTITLE: Including Pre-defined Input Processors in ZMK\nDESCRIPTION: This code snippet demonstrates how to include pre-defined input processors in a ZMK keymap or overlay file.  Including this file makes a variety of pre-defined processors available for use in the keymap configuration. These processors can then be used to modify input events from pointing devices.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/index.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <input/processors.dtsi>\n```\n\n----------------------------------------\n\nTITLE: Applying Multiple Modifiers to Caps Word Behavior in DTS\nDESCRIPTION: This snippet illustrates how to apply multiple modifiers to the `mods` property within the `&caps_word` behavior in a Device Tree Source (DTS) file. This overrides the default MOD_LSFT modifier, allowing you to combine multiple modifiers.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/caps-word.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n&caps_word {\n    mods = <(MOD_LSFT | MOD_LALT)>;\n};\n\n/ {\n    keymap {\n        ...\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Include Directories\nDESCRIPTION: Adds an include directory to the Zephyr library using the `zephyr_library_include_directories()` function.  `${ZEPHYR_BASE}/drivers` is added as an include directory, which allows the code in the library to include header files located in that directory. This is typically done to make Zephyr drivers available to the library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/nrfmicro/CMakeLists.txt#_snippet_2\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_include_directories(${ZEPHYR_BASE}/drivers)\n```\n\n----------------------------------------\n\nTITLE: Building ZMK for Addon MCU Keyboard\nDESCRIPTION: Builds ZMK firmware for a keyboard that uses an addon MCU board. The `-b` flag specifies the MCU board, and the `-- -DSHIELD` argument specifies the keyboard PCB being used as a shield. The built firmware can then be flashed to the device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nwest build -b proton_c -- -DSHIELD=kyria_left\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Settings Reset\nDESCRIPTION: This code uses `target_sources_ifdef` to conditionally include C source files for different settings reset mechanisms. The inclusion depends on the Kconfig options such as `CONFIG_SETTINGS_NONE`, `CONFIG_SETTINGS_FCB`, `CONFIG_SETTINGS_FILE`, `CONFIG_SETTINGS_NVS`, and `CONFIG_ZMK_SETTINGS_RESET_ON_START`. Each option corresponds to a different method for resetting settings in the ZMK firmware, allowing flexible storage backend selection.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/settings/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_SETTINGS_NONE app PRIVATE reset_settings_none.c)\ntarget_sources_ifdef(CONFIG_SETTINGS_FCB app PRIVATE reset_settings_fcb.c)\ntarget_sources_ifdef(CONFIG_SETTINGS_FILE app PRIVATE reset_settings_file.c)\ntarget_sources_ifdef(CONFIG_SETTINGS_NVS app PRIVATE reset_settings_nvs.c)\n\ntarget_sources_ifdef(CONFIG_ZMK_SETTINGS_RESET_ON_START app PRIVATE reset_settings_on_start.c)\n```\n\n----------------------------------------\n\nTITLE: Starting Dev Container with CLI\nDESCRIPTION: Starts a Dev Container using the Dev Container CLI, specifying the workspace folder. This initializes the development environment within the container.  Requires the Dev Container CLI and a devcontainer.json file in the workspace.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\ndevcontainer up --workspace-folder \"/absolute/path/to/zmk\"\n```\n\n----------------------------------------\n\nTITLE: Parameterized Macro Example (Quoted Letter)\nDESCRIPTION: This DeviceTree snippet defines a parameterized macro that encloses a given keycode within double quotes.  It requires the `zmk,behavior-macro-one-param` compatible property and utilizes `macro_param_1to1` to insert the parameter into the sequence of key presses.  It allows for more modular macro definitions in keymaps.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-10-05-zmk-sotf-6.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n        ql: quoted_letter {\n            #binding-cells = <1>;\n            compatible = \"zmk,behavior-macro-one-param\";\n            bindings =\n                <&kp DQT>,\n                <&macro_param_1to1 &kp MACRO_PLACEHOLDER>,\n                <&kp DQT>;\n        };\n```\n\n----------------------------------------\n\nTITLE: Adding Target Sources for Application\nDESCRIPTION: This section adds source files to the \"app\" target, which represents the main application in the ZMK firmware. Source files are added conditionally based on Kconfig options. All the source files are added as PRIVATE.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_include_directories(app PRIVATE include)\ntarget_sources(app PRIVATE src/stdlib.c)\ntarget_sources(app PRIVATE src/activity.c)\ntarget_sources(app PRIVATE src/behavior.c)\ntarget_sources_ifdef(CONFIG_ZMK_KSCAN_SIDEBAND_BEHAVIORS app PRIVATE src/kscan_sideband_behaviors.c)\ntarget_sources(app PRIVATE src/matrix_transform.c)\ntarget_sources(app PRIVATE src/physical_layouts.c)\ntarget_sources(app PRIVATE src/sensors.c)\ntarget_sources_ifdef(CONFIG_ZMK_WPM app PRIVATE src/wpm.c)\ntarget_sources(app PRIVATE src/event_manager.c)\ntarget_sources_ifdef(CONFIG_ZMK_PM app PRIVATE src/pm.c)\ntarget_sources_ifdef(CONFIG_ZMK_EXT_POWER app PRIVATE src/ext_power_generic.c)\ntarget_sources_ifdef(CONFIG_ZMK_GPIO_KEY_WAKEUP_TRIGGER app PRIVATE src/gpio_key_wakeup_trigger.c)\ntarget_sources(app PRIVATE src/events/activity_state_changed.c)\ntarget_sources(app PRIVATE src/events/position_state_changed.c)\ntarget_sources(app PRIVATE src/events/sensor_event.c)\ntarget_sources_ifdef(CONFIG_ZMK_WPM app PRIVATE src/events/wpm_state_changed.c)\ntarget_sources_ifdef(CONFIG_USB_DEVICE_STACK app PRIVATE src/events/usb_conn_state_changed.c)\ntarget_sources(app PRIVATE src/behaviors/behavior_reset.c)\ntarget_sources_ifdef(CONFIG_ZMK_EXT_POWER app PRIVATE src/behaviors/behavior_ext_power.c)\ntarget_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SOFT_OFF app PRIVATE src/behaviors/behavior_soft_off.c)\nadd_subdirectory_ifdef(CONFIG_ZMK_POINTING src/pointing/)\nif ((NOT CONFIG_ZMK_SPLIT) OR CONFIG_ZMK_SPLIT_ROLE_CENTRAL)\n  target_sources(app PRIVATE src/hid.c)\n  target_sources(app PRIVATE src/behaviors/behavior_key_press.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_KEY_TOGGLE app PRIVATE src/behaviors/behavior_key_toggle.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_HOLD_TAP app PRIVATE src/behaviors/behavior_hold_tap.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_STICKY_KEY app PRIVATE src/behaviors/behavior_sticky_key.c)\n  target_sources(app PRIVATE src/behaviors/behavior_caps_word.c)\n  target_sources(app PRIVATE src/behaviors/behavior_key_repeat.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_MACRO app PRIVATE src/behaviors/behavior_macro.c)\n  target_sources(app PRIVATE src/behaviors/behavior_momentary_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_mod_morph.c)\n  target_sources(app PRIVATE src/behaviors/behavior_outputs.c)\n  target_sources(app PRIVATE src/behaviors/behavior_toggle_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_to_layer.c)\n  target_sources(app PRIVATE src/behaviors/behavior_transparent.c)\n  target_sources(app PRIVATE src/behaviors/behavior_none.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SENSOR_ROTATE app PRIVATE src/behaviors/behavior_sensor_rotate.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SENSOR_ROTATE_VAR app PRIVATE src/behaviors/behavior_sensor_rotate_var.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_SENSOR_ROTATE_COMMON app PRIVATE src/behaviors/behavior_sensor_rotate_common.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_MOUSE_KEY_PRESS app PRIVATE src/behaviors/behavior_mouse_key_press.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_STUDIO_UNLOCK app PRIVATE src/behaviors/behavior_studio_unlock.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_INPUT_TWO_AXIS app PRIVATE src/behaviors/behavior_input_two_axis.c)\n  target_sources(app PRIVATE src/combo.c)\n  target_sources_ifdef(CONFIG_ZMK_BEHAVIOR_TAP_DANCE app PRIVATE src/behaviors/behavior_tap_dance.c)\n  target_sources(app PRIVATE src/behavior_queue.c)\n  target_sources(app PRIVATE src/conditional_layer.c)\n  target_sources(app PRIVATE src/endpoints.c)\n  target_sources(app PRIVATE src/events/endpoint_changed.c)\n  target_sources(app PRIVATE src/hid_listener.c)\n  target_sources(app PRIVATE src/keymap.c)\n  target_sources(app PRIVATE src/events/layer_state_changed.c)\n  target_sources(app PRIVATE src/events/modifiers_state_changed.c)\n  target_sources(app PRIVATE src/events/keycode_state_changed.c)\n  target_sources_ifdef(CONFIG_ZMK_HID_INDICATORS app PRIVATE src/hid_indicators.c)\n\n  if (CONFIG_ZMK_BLE)\n    target_sources(app PRIVATE src/events/ble_active_profile_changed.c)\n    target_sources(app PRIVATE src/behaviors/behavior_bt.c)\n    target_sources(app PRIVATE src/ble.c)\n    target_sources(app PRIVATE src/hog.c)\n  endif()\nendif()\n\ntarget_sources_ifdef(CONFIG_ZMK_RGB_UNDERGLOW app PRIVATE src/behaviors/behavior_rgb_underglow.c)\ntarget_sources_ifdef(CONFIG_ZMK_BACKLIGHT app PRIVATE src/behaviors/behavior_backlight.c)\n\ntarget_sources_ifdef(CONFIG_ZMK_BATTERY_REPORTING app PRIVATE src/events/battery_state_changed.c)\ntarget_sources_ifdef(CONFIG_ZMK_BATTERY_REPORTING app PRIVATE src/battery.c)\n\ntarget_sources_ifdef(CONFIG_ZMK_HID_INDICATORS app PRIVATE src/events/hid_indicators_changed.c)\n\ntarget_sources_ifdef(CONFIG_ZMK_SPLIT app PRIVATE src/events/split_peripheral_status_changed.c)\nadd_subdirectory_ifdef(CONFIG_ZMK_SPLIT src/split)\n\ntarget_sources_ifdef(CONFIG_USB_DEVICE_STACK app PRIVATE src/usb.c)\ntarget_sources_ifdef(CONFIG_ZMK_USB app PRIVATE src/usb_hid.c)\ntarget_sources_ifdef(CONFIG_ZMK_RGB_UNDERGLOW app PRIVATE src/rgb_underglow.c)\ntarget_sources_ifdef(CONFIG_ZMK_BACKLIGHT app PRIVATE src/backlight.c)\ntarget_sources_ifdef(CONFIG_ZMK_LOW_PRIORITY_WORK_QUEUE app PRIVATE src/workqueue.c)\ntarget_sources(app PRIVATE src/main.c)\n```\n\n----------------------------------------\n\nTITLE: Enable ZMK snippet in build.yaml\nDESCRIPTION: This YAML snippet demonstrates how to enable a ZMK snippet in the `build.yaml` file.  The `snippet` key specifies the name of the snippet to include in the build process.  This configuration applies to the `nrfmicro_13_52833` board and utilizes the `corne_left` shield.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/system.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n- board: nrfmicro_13_52833\n  snippet: nrf52833-nosd\n  shield: corne_left\n```\n\n----------------------------------------\n\nTITLE: Define a phandle array in Devicetree\nDESCRIPTION: This example shows how to define a phandle array in a devicetree file. The array can contain node references and numbers. Mathematical expressions are allowed within parenthesis. Values can also be split into multiple blocks.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\nproperty = <&none &mo 1>;\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Include Directories\nDESCRIPTION: This snippet adds an include directory for the Zephyr library. It depends on the ZEPHYR_BASE environment variable being correctly set to the Zephyr base directory. This adds the Zephyr drivers directory to the include path, allowing the library to find necessary header files.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/puchi_ble/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_include_directories(${ZEPHYR_BASE}/drivers)\n```\n\n----------------------------------------\n\nTITLE: Installing west globally with pip (Windows)\nDESCRIPTION: Installs the `west` tool globally using `pip` on Windows. Requires Python and pip to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\npip install -U west\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for Layer Status Widget\nDESCRIPTION: This snippet conditionally includes `layer_status.c` into the application build if `CONFIG_ZMK_WIDGET_LAYER_STATUS` is defined. The source file is added as a private source to the 'app' target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/widgets/CMakeLists.txt#_snippet_3\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_WIDGET_LAYER_STATUS app PRIVATE layer_status.c)\n```\n\n----------------------------------------\n\nTITLE: Backspace to Delete Mod-Morph with `keep-mods` in ZMK\nDESCRIPTION: This snippet shows how to configure a mod-morph behavior to change Backspace to Delete with Shift modifiers, and uses `keep-mods` to keep the Right Shift modifier.  When LEFT_SHIFT + BACKSPACE are pressed, it morphs into DELETE.  When RIGHT_SHIFT + BACKSPACE are pressed, it morphs into RIGHT_SHIFT + DELETE. The `keep-mods` property ensures the RIGHT_SHIFT modifier is sent along with the DELETE keycode.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mod-morph.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        bspc_del: backspace_delete {\n            compatible = \"zmk,behavior-mod-morph\";\n            #binding-cells = <0>;\n            bindings = <&kp BACKSPACE>, <&kp DELETE>;\n            mods = <(MOD_LSFT|MOD_RSFT)>;\n            keep-mods = <(MOD_RSFT)>;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Including ZMK Pointing Header\nDESCRIPTION: This includes the `dt-bindings/zmk/pointing.h` header file, which provides definitions for HID mouse button and move/scroll speed values.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/pointing.h>\n```\n\n----------------------------------------\n\nTITLE: Scaler Instance Definition (DTS)\nDESCRIPTION: Defines a scaler instance named `zip_xy_scaler` with a multiplier of 1 and a divisor of 3. This reduces X/Y movement speed to one-third. It uses Device Tree Syntax (DTS).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/scaler.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&zip_xy_scaler 1 3\n```\n\n----------------------------------------\n\nTITLE: Installing ZMK Tools VS Code Extension\nDESCRIPTION: This snippet shows the command to install the ZMK Tools extension in Visual Studio Code. It is intended to be run within the VS Code command palette after opening a ZMK config repository in github.dev.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-01-05-zmk-tools.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\next install spadin.zmk-tools\n```\n\n----------------------------------------\n\nTITLE: Using Defined Layer Numbers\nDESCRIPTION: This snippet demonstrates how to use the `#define` directives to refer to layers in the keymap configuration. This provides readability. The example demonstrates using a defined macro `LOWER` to reference to the layer 1, using the `&mo` behavior.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/layers.md#_snippet_5\n\nLANGUAGE: dts\nCODE:\n```\n&mo LOWER  // equivalent to &mo 1\n```\n\n----------------------------------------\n\nTITLE: Kconfig Hold Tap Configuration\nDESCRIPTION: Defines Kconfig options related to the hold-tap behavior, including the maximum number of simultaneous held hold-taps and the maximum number of system events to capture while deferring a hold or tap decision resolution.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_3\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_ZMK_BEHAVIOR_HOLD_TAP_MAX_HELD\nCONFIG_ZMK_BEHAVIOR_HOLD_TAP_MAX_CAPTURED_EVENTS\n```\n\n----------------------------------------\n\nTITLE: Connect to USB Logging on Linux - Shell\nDESCRIPTION: This snippet shows how to connect to the USB CDC ACM device exposed by the ZMK firmware on Linux using `tio`.  The command assumes the device is at `/dev/ttyACM0`.  The user needs appropriate permissions, hence `sudo`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/usb-logging.mdx#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nsudo tio /dev/ttyACM0\n```\n\n----------------------------------------\n\nTITLE: Appending Extra DTC Flags in CMake\nDESCRIPTION: This snippet appends the \"-qq\" flag to the `EXTRA_DTC_FLAGS` variable in CMake. The `-qq` flag is used to reduce the verbosity of the Device Tree Compiler (DTC) by suppressing warnings and non-essential messages. This configuration affects how device tree source files are compiled during the build process.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/planck/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nlist(APPEND EXTRA_DTC_FLAGS \"-qq\")\n```\n\n----------------------------------------\n\nTITLE: ZMK West Manifest with Module A\nDESCRIPTION: This YAML configuration demonstrates how to add an external module (Module A) to the ZMK build using the west manifest. It defines a remote for the module and adds it as a project.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/modules.mdx#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  remotes:\n    - name: zmkfirmware\n      url-base: https://github.com/zmkfirmware\n    - name: module_a_base\n      url-base: https://github.com/alice\n  projects:\n    - name: zmk\n      remote: zmkfirmware\n      revision: main\n      import: app/west.yml\n    - name: module_a\n      remote: module_a_base\n      revision: main\n  self:\n    path: config\n```\n\n----------------------------------------\n\nTITLE: Activating a Python virtual environment (Powershell)\nDESCRIPTION: Activates a Python virtual environment on Windows using PowerShell.  Assumes the virtual environment is located in the `.venv` directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_5\n\nLANGUAGE: powershell\nCODE:\n```\n.venv\\Scripts\\Activate.ps1\n```\n\n----------------------------------------\n\nTITLE: Running Podman Container\nDESCRIPTION: Runs a container from a specified image using Podman, configuring volumes and ports.  Starts the ZMK development environment inside the container. Requires Podman to be installed and a container image to be available.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\npodman run -it --rm \\\n  --security-opt label=disable \\\n  --workdir /workspaces/zmk \\\n  -v /path/to/zmk:/workspaces/zmk \\\n  -v /path/to/zmk-config:/workspaces/zmk-config \\   # Removeable\n  -v /path/to/zmk-modules:/workspaces/zmk-modules \\ # Removeable\n  -p 3000:3000 \\\n  <container-name> /bin/bash\n```\n\n----------------------------------------\n\nTITLE: Activating GUI keycode in ZMK\nDESCRIPTION: This code snippet demonstrates how to activate and release the left GUI key using the ZMK firmware. It acts like any other keycode in the system.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/modifiers.mdx#_snippet_0\n\nLANGUAGE: ZMK\nCODE:\n```\n&kp LEFT_GUI\n```\n\n----------------------------------------\n\nTITLE: Temporary Layer Activation Example (Devicetree)\nDESCRIPTION: This example demonstrates how to use the pre-defined `&zip_temp_layer` instance to enable layer 2 (the third layer) for 2000 milliseconds (2 seconds) upon receiving input events from a pointing device.  This is configured in the device tree.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/temp-layer.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&zip_temp_layer 2 2000\n```\n\n----------------------------------------\n\nTITLE: Adding Include Directories in CMake\nDESCRIPTION: This snippet uses the `zephyr_include_directories` function to add the specified 'include' directory to the project's include path. This allows the project to find header files located in this directory.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_include_directories(include)\n```\n\n----------------------------------------\n\nTITLE: Old Sensor Node Configuration DTS\nDESCRIPTION: Shows the old sensor node configuration, selecting encoders for use. This snippet illustrates how encoders were previously integrated into the keymap sensors.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-06-18-encoder-refactors.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n    sensors {\n        compatible = \"zmk,keymap-sensors\";\n        sensors = <&left_encoder &right_encoder>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Managing Docker Containers and Volumes\nDESCRIPTION: Commands to list, stop, and remove Docker containers and volumes. This allows for cleaning up old containers and volumes. Requires Docker to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ndocker ps                    # List containers\ndocker stop \"<container-id>\" # Stop the container\ndocker rm   \"<container-id>\" # Remove the container\n\ndocker volume ls                 # List volumes\ndocker volume rm \"<volume-name>\" # Remove volume\n```\n\n----------------------------------------\n\nTITLE: Device Tree Usage of Pre-defined Code Mapper Instance\nDESCRIPTION: This snippet shows how to use a pre-defined code mapper instance (zip_xy_to_scroll_mapper) in a device tree.  The instance name is referenced directly.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/code-mapper.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&zip_xy_to_scroll_mapper\n```\n\n----------------------------------------\n\nTITLE: Configuring Min/Max Underglow Brightness in ZMK\nDESCRIPTION: This snippet configures the minimum and maximum underglow brightness in ZMK by setting `CONFIG_ZMK_RGB_UNDERGLOW_BRT_MIN` and `CONFIG_ZMK_RGB_UNDERGLOW_BRT_MAX` in the `.conf` file. The values are specified as percentages of the full brightness range. This helps prevent setting brightness to zero or consuming excessive power at maximum brightness.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-10-zmk-sotf-5.md#_snippet_4\n\nLANGUAGE: ini\nCODE:\n```\nCONFIG_ZMK_RGB_UNDERGLOW_BRT_MIN=20\nCONFIG_ZMK_RGB_UNDERGLOW_BRT_MAX=80\n```\n\n----------------------------------------\n\nTITLE: Positional Hold-tap with hold-preferred flavor - DTS\nDESCRIPTION: This example defines a positional hold-tap behavior with the `hold-preferred` flavor. It enables positional hold-tap using `hold-trigger-key-positions`, which is set to `<1>`, indicating that only the key at position 1 will trigger the hold behavior if pressed before `tapping-term-ms` expires.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_14\n\nLANGUAGE: DTS\nCODE:\n```\n#include <dt-bindings/zmk/keys.h>\n#include <behaviors.dtsi>\n\n/ {\n    behaviors {\n        pht: positional_hold_tap {\n            compatible = \"zmk,behavior-hold-tap\";\n            #binding-cells = <2>;\n            flavor = \"hold-preferred\";\n            tapping-term-ms = <400>;\n            quick-tap-ms = <200>;\n            bindings = <&kp>, <&kp>;\n            hold-trigger-key-positions = <1>;    // <---[[the W key]]\n        };\n    };\n    keymap {\n        compatible = \"zmk,keymap\";\n        default_layer {\n            bindings = <\n                //  position 0         position 1       position 2\n                &pht LEFT_SHIFT Q        &kp W            &kp E\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling a Node - DTS\nDESCRIPTION: This snippet demonstrates how to enable the `spi0` node by setting its `status` property to \"okay\". This activates the node, allowing it to be used in the system. Most nodes are disabled by default.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_9\n\nLANGUAGE: dts\nCODE:\n```\n&spi0 {\n    status = \"okay\";\n};\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Central\nDESCRIPTION: This command executes the ble_test_central.exe application, which is likely used for testing Bluetooth Low Energy (BLE) central functionality within the ZMK firmware project. The `-d=2` parameter likely specifies the device ID or some other device-related setting for the test.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/connnect-and-output-to-selection/siblings.txt#_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n./ble_test_central.exe -d=2\n```\n\n----------------------------------------\n\nTITLE: Edit Keymap and Config Files (Shell)\nDESCRIPTION: These commands demonstrate how to open ZMK configuration files using the `zmk code` command with different arguments. This allows editing keymaps, config files, and the build configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\nzmk code                    # Open the repo directory in an editor\nzmk code <keyboard>         # Open <keyboard>.keymap in an editor\nzmk code --conf <keyboard>  # Open <keyboard>.conf in an editor\nzmk code --build            # Open build.yaml in an editor\n```\n\n----------------------------------------\n\nTITLE: New Encoder Configuration DTS\nDESCRIPTION: Illustrates the new encoder configuration method using the `steps` property to define the number of pulses per rotation. This snippet is part of the refactored sensor configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2023-06-18-encoder-refactors.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n    left_encoder: encoder_left {\n        compatible = \"alps,ec11\";\n        a-gpios = <&pro_micro 21 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        b-gpios = <&pro_micro 20 (GPIO_ACTIVE_HIGH | GPIO_PULL_UP)>;\n        steps = <80>;\n    };\n```\n\n----------------------------------------\n\nTITLE: Devicetree Key Repeat Configuration\nDESCRIPTION: Configures the key repeat behavior through the devicetree, allowing specification of HID usage pages to track for key repeat functionality. It defaults to tracking HID key codes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_5\n\nLANGUAGE: YAML\nCODE:\n```\n#binding-cells: <0>\nusage-pages: <HID_USAGE_KEY>\n```\n\n----------------------------------------\n\nTITLE: Defining Siblings\nDESCRIPTION: Shows how to define the siblings for a hardware item. The `siblings` array contains the hardware IDs of the siblings that combine into a logical device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/hardware-metadata-files.md#_snippet_6\n\nLANGUAGE: yaml\nCODE:\n```\nid: corne\nsiblings:\n  - corne_left\n  - corne_right\n```\n\n----------------------------------------\n\nTITLE: Binding for Mouse Button 4 Press\nDESCRIPTION: This example shows how to configure a behavior binding to send a press of the fourth mouse button when triggered.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n&mkp MB4\n```\n\n----------------------------------------\n\nTITLE: Executing ble_test_central with Device ID and Wait on Start\nDESCRIPTION: This command executes the ble_test_central.exe application. It specifies the device ID using the -d option and sets a wait on start timeout using the -wait_on_start option. The timeout is set to 1300 milliseconds. This is useful for testing the startup sequence with a particular device.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/bond-clear-then-bond-second-client/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=3 -wait_on_start=1300\n```\n\n----------------------------------------\n\nTITLE: Deleting Devicetree Property (DTS)\nDESCRIPTION: Shows how to delete a Devicetree property that has already been set to true and needs to be overriden to false.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_4\n\nLANGUAGE: dts\nCODE:\n```\n/delete-property/ the-property-name;\n```\n\n----------------------------------------\n\nTITLE: Define a path to a node using a label in Devicetree\nDESCRIPTION: This example demonstrates how to define a path to a node using a node reference (label) in a devicetree file. This is one way to refer to a node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/index.md#_snippet_8\n\nLANGUAGE: dts\nCODE:\n```\nproperty = &label;\n```\n\n----------------------------------------\n\nTITLE: Define Zephyr Library\nDESCRIPTION: Defines a Zephyr library using the `zephyr_library()` function. This creates a reusable module within the Zephyr RTOS environment for ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/mikoto/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Initializing Zephyr Workspace with West\nDESCRIPTION: Initializes and updates a Zephyr workspace using the West tool. Sets up the project environment and downloads necessary dependencies. Must be executed from inside the container after it has been started and connected to.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\nwest init -l app/ # Initialization\nwest update       # Update modules\n```\n\n----------------------------------------\n\nTITLE: Adding source file to Zephyr library\nDESCRIPTION: This snippet specifies the source file (`usb_serial_number.c`) to be included in the previously defined Zephyr library. The zephyr_library_sources macro takes the source file as an argument and adds it to the library's compilation units. This file likely contains code related to USB serial number generation or handling.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/glove80/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_sources(usb_serial_number.c)\n```\n\n----------------------------------------\n\nTITLE: Sensor Rotate Behavior Devicetree Binding\nDESCRIPTION: Describes the device tree binding for the `zmk,behavior-sensor-rotate` compatible. It specifies properties like `#sensor-binding-cells`, `bindings` (phandles), and `tap-ms` to configure sensor rotation behavior.  The `bindings` property must include any behavior parameters.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_7\n\n\n\n----------------------------------------\n\nTITLE: Composite Keyboard File Structure\nDESCRIPTION: This code snippet illustrates the file structure used for composite keyboards in the ZMK firmware.  It includes Kconfig files, a devicetree overlay file, a keymap file, and a metadata file. The files are located under `<board_root>/boards/shields/<keyboard_name>/`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/index.mdx#_snippet_1\n\nLANGUAGE: Text\nCODE:\n```\n<keyboard_name>\n├── Kconfig.shield\n├── Kconfig.defconfig\n├── <shield_name>.overlay\n├── <keyboard_name>.keymap\n└── <keyboard_name>.zmk.yml\n```\n\n----------------------------------------\n\nTITLE: Devicetree Files Location in West Build Logs\nDESCRIPTION: This snippet demonstrates how the West build command logs the devicetree files found and used during the build. This is helpful to confirm that the correct board and keymap devicetree files are being utilized. It shows the board DTS file and the keymap file being located by the build.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/building-issues.md#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\n+ west build -s zmk/app -d /tmp/tmp.8cJefinXCb -b corneish_zen_v2_left -- -DZMK_CONFIG=/tmp/zmk-config/config -DZMK_EXTRA_MODULES=/__w/zmk-config/zmk-config\n...\n-- Found BOARD.dts: /tmp/zmk-config/zmk/app/boards/arm/corneish_zen/corneish_zen_v2_left.dts\n-- Found devicetree overlay: /tmp/zmk-config/config/corneish_zen.keymap\n...\n```\n\n----------------------------------------\n\nTITLE: Shortened behavior name in .dtsi\nDESCRIPTION: This code demonstrates how to shorten the behavior name when its locality is not set to `BEHAVIOR_LOCALITY_CENTRAL` in the ZMK firmware. The name must be 8 characters or less to ensure it can be invoked on peripheral halves of split keyboards.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/new-behavior.mdx#_snippet_9\n\nLANGUAGE: DTS\nCODE:\n```\n// Behavior can be invoked on peripherals, so name must be <= 8 characters.\n/omit-if-no-ref/ gresc: gresc { ... };\n```\n\n----------------------------------------\n\nTITLE: Checking Podman Version\nDESCRIPTION: Checks the installed version of Podman.  Confirms the installation and accessibility of the Podman containerization tool. Requires Podman to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\npodman --version\n```\n\n----------------------------------------\n\nTITLE: Combining Left Shift and Left Alt Modifiers in ZMK\nDESCRIPTION: This snippet combines the left shift and left alt modifier keys.  This can be used to create custom modifier combinations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/modifiers.mdx#_snippet_3\n\nLANGUAGE: ZMK\nCODE:\n```\n&kp LS(LALT)\n```\n\n----------------------------------------\n\nTITLE: Running Setup Script with Curl\nDESCRIPTION: This command uses curl to download and execute the ZMK setup script directly from the zmk.dev website. It automates the creation of a user configuration repository for ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup.mdx#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbash -c \"$(curl -fsSL https://zmk.dev/setup.sh)\"\n```\n\n----------------------------------------\n\nTITLE: Configure Conditional Target Sources (UART)\nDESCRIPTION: This CMake command conditionally adds the UART RPC transport source file to the ZMK application, based on the `CONFIG_ZMK_STUDIO_TRANSPORT_UART` configuration option.  If the config option is enabled, `uart_rpc_transport.c` is compiled.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/studio/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_STUDIO_TRANSPORT_UART app PRIVATE uart_rpc_transport.c)\n```\n\n----------------------------------------\n\nTITLE: Kconfig Behavior Queue Size\nDESCRIPTION: Defines the maximum number of behaviors that can be queued from a macro or other complex behavior within the ZMK firmware. The default value is 64.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_ZMK_BEHAVIORS_QUEUE_SIZE\n```\n\n----------------------------------------\n\nTITLE: Creating Podman Volume for ZMK Config\nDESCRIPTION: Creates a Podman volume named 'zmk-config' and binds it to a specified local directory. This allows the container to access the ZMK configuration files. Requires Podman to be installed.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/container.mdx#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npodman volume create --driver local -o o=bind -o type=none \\\n -o device=\"/absolute/path/to/zmk-config/\" zmk-config\n```\n\n----------------------------------------\n\nTITLE: Building ZMK Firmware with nice!view Adapter\nDESCRIPTION: This command builds the ZMK firmware for the nice_nano_v2 board, incorporating the lily58_left shield, the nice_view_adapter, and the nice_view display.  It uses the West build tool and specifies the shield configuration using the -DSHIELD option. This allows combining a standard keyboard layout with the nice!view display through the adapter.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nice_view_adapter/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nwest build -b nice_nano_v2 -- -DSHIELD=\"lily58_left nice_view_adapter nice_view\"\n```\n\n----------------------------------------\n\nTITLE: Amending Zephyr Library\nDESCRIPTION: This line amends the Zephyr library, likely adding or modifying its behavior. It is a general instruction that could affect many parts of the Zephyr RTOS framework, though the specific implications depend on the context of this build configuration.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_amend()\n```\n\n----------------------------------------\n\nTITLE: Install pipx on macOS (Shell)\nDESCRIPTION: These commands install `pipx` on macOS using Homebrew and ensure it's added to the system's PATH.  It provides a macOS specific method for installing pipx.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nbrew install pipx\npipx ensurepath\n```\n\n----------------------------------------\n\nTITLE: Enabling Encoders in Devicetree\nDESCRIPTION: This devicetree snippet enables the left, middle, and right encoders by setting their status to \"okay\". It also assigns the encoder nodes to the `sensors` property.  This assumes the encoder nodes are already defined as `left_encoder`, `mid_encoder`, and `right_encoder`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/bdn9/README.md#_snippet_2\n\nLANGUAGE: devicetree\nCODE:\n```\n&sensors {\n     status = \"okay\";\n     sensors = <&left_encoder &mid_encoder &right_encoder>;\n};\n\n&left_encoder { status = \"okay\"; };\n&mid_encoder { status = \"okay\"; };\n&right_encoder { status = \"okay\"; };\n```\n\n----------------------------------------\n\nTITLE: Including GPIO Direct Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_gpio_direct.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_GPIO_DIRECT` Kconfig option is defined. This driver handles keyboard scanning using direct GPIO connections.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_4\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_GPIO_DIRECT kscan_gpio_direct.c)\n```\n\n----------------------------------------\n\nTITLE: Checking Documentation Formatting with Prettier using npm\nDESCRIPTION: This snippet shows how to check the formatting of the documentation files using Prettier with `npm run prettier:check`. This verifies that the files are correctly formatted before submitting a pull request.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/contributing/documentation.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prettier:check\n```\n\n----------------------------------------\n\nTITLE: Scaler Instance Definition (DTS)\nDESCRIPTION: Defines a scaler instance named `zip_xy_scaler` with a multiplier of 2 and a divisor of 1. This doubles all X/Y movement.  It uses Device Tree Syntax (DTS).\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/scaler.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n&zip_xy_scaler 2 1\n```\n\n----------------------------------------\n\nTITLE: Including Mock Kscan Driver Source\nDESCRIPTION: This line conditionally includes the `kscan_mock.c` source file in the Zephyr library if the `CONFIG_ZMK_KSCAN_MOCK_DRIVER` Kconfig option is defined. This driver likely provides a mock or test implementation for keyboard scanning.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/kscan/CMakeLists.txt#_snippet_6\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_KSCAN_MOCK_DRIVER kscan_mock.c)\n```\n\n----------------------------------------\n\nTITLE: Installing Zephyr dependencies globally with pip3 (Ubuntu/Mac)\nDESCRIPTION: Installs Zephyr dependencies globally using `pip3` with the `--user` flag from the `requirements-base.txt` file. This is specific for Ubuntu and macOS.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_14\n\nLANGUAGE: sh\nCODE:\n```\npip3 install --user -r zephyr/scripts/requirements-base.txt\n```\n\n----------------------------------------\n\nTITLE: Configure West to Generate Compilation Database (CMake)\nDESCRIPTION: This command configures the `west` tool to instruct CMake to generate a compilation database. This database contains information about the project's build process, allowing IDEs like Visual Studio Code to provide better code completion and other features. The command needs to be run in the ZMK repository. This will overwrite existing CMake arguments unless all arguments are provided in quotes.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/ide-integration.mdx#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nwest config build.cmake-args -- -DCMAKE_EXPORT_COMPILE_COMMANDS=ON\n```\n\n----------------------------------------\n\nTITLE: Configuring nanopb for ZMK Studio RPC\nDESCRIPTION: This snippet configures nanopb (Protocol Buffers) for use with the ZMK Studio RPC feature.  It includes nanopb, disables default CPP generation, generates C++ files from the proto definitions, adds the binary directory to the include path, includes proto source and headers into the app, and finally adds the studio subdirectory to the build.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/CMakeLists.txt#_snippet_5\n\nLANGUAGE: CMake\nCODE:\n```\nif (CONFIG_ZMK_STUDIO_RPC)\n  # For some reason this is failing if run from a different sub-file.\n  list(APPEND CMAKE_MODULE_PATH ${ZEPHYR_BASE}/modules/nanopb)\n\n  include(nanopb)\n\n    # Turn off the default nanopb behavior\n  set(NANOPB_GENERATE_CPP_STANDALONE OFF)\n\n  nanopb_generate_cpp(proto_srcs proto_hdrs RELPATH ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}\n                        ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/studio.proto\n                        ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/meta.proto\n                        ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/core.proto\n                        ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/behaviors.proto\n                        ${ZEPHYR_ZMK_STUDIO_MESSAGES_MODULE_DIR}/proto/zmk/keymap.proto\n  )\n\n  target_include_directories(app PUBLIC ${CMAKE_CURRENT_BINARY_DIR})\n  target_sources(app PRIVATE ${proto_srcs} ${proto_hdrs})\n\n  add_subdirectory(src/studio)\nendif()\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files to Zephyr Library in CMake\nDESCRIPTION: This set of lines adds source files to the Zephyr library being configured. It includes a common battery management source file and conditionally includes other source files based on Kconfig options such as CONFIG_ZMK_BATTERY_NRF_VDDH and CONFIG_ZMK_BATTERY_VOLTAGE_DIVIDER. These options determine which battery measurement techniques are used.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/battery/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_library_sources(battery_common.c)\nzephyr_library_sources_ifdef(CONFIG_ZMK_BATTERY_NRF_VDDH battery_nrf_vddh.c)\nzephyr_library_sources_ifdef(CONFIG_ZMK_BATTERY_VOLTAGE_DIVIDER battery_voltage_divider.c)\n```\n\n----------------------------------------\n\nTITLE: Sensor Rotate Variable Behavior Devicetree Binding\nDESCRIPTION: Describes the device tree binding for the `zmk,behavior-sensor-rotate-var` compatible.  It specifies properties like `#sensor-binding-cells`, `bindings` (phandle array), and `tap-ms` to configure sensor rotation behavior. The `bindings` property must exclude any behavior parameters. This behavior forwards parameters to the specified behaviors in `bindings`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/behaviors.md#_snippet_8\n\n\n\n----------------------------------------\n\nTITLE: Conditionally Include Mock Sensor Encoder Subdirectory in ZMK\nDESCRIPTION: This snippet employs the CMake function `add_subdirectory_ifdef` to conditionally include the `encoder_mock` subdirectory in the ZMK project. The inclusion is contingent upon the `CONFIG_ZMK_SENSOR_ENCODER_MOCK` Kconfig option being enabled. This allows for modular integration of a mock sensor encoder.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\nadd_subdirectory_ifdef(CONFIG_ZMK_SENSOR_ENCODER_MOCK encoder_mock)\n```\n\n----------------------------------------\n\nTITLE: Authenticate with GitHub CLI (Shell)\nDESCRIPTION: This command authenticates with GitHub using the GitHub CLI. This is required before pushing changes to a GitHub repository.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_13\n\nLANGUAGE: sh\nCODE:\n```\ngh auth login\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include Source File\nDESCRIPTION: This snippet conditionally includes the `input_mock.c` source file in the Zephyr library. It depends on the `CONFIG_ZMK_INPUT_MOCK` configuration option. If this option is enabled, the `input_mock.c` file will be compiled and linked into the library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/input/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_ZMK_INPUT_MOCK input_mock.c)\n```\n\n----------------------------------------\n\nTITLE: Zephyr Library Sources Definition\nDESCRIPTION: Specifies the source files for the Zephyr library using the `zephyr_library_sources()` function. In this case, `pinmux.c` is identified as a source file for the library.  This allows the build system to compile the C file and link it with other parts of the project.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/nrfmicro/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_sources(pinmux.c)\n```\n\n----------------------------------------\n\nTITLE: Binding for Left Mouse Movement\nDESCRIPTION: This example configures a behavior binding to send a left mouse movement event to the host when pressed or held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/mouse-emulation.md#_snippet_7\n\nLANGUAGE: dts\nCODE:\n```\n&mmv MOVE_LEFT\n```\n\n----------------------------------------\n\nTITLE: Configure Conditional Target Sources (BLE)\nDESCRIPTION: This CMake command conditionally adds the GATT (BLE) RPC transport source file to the ZMK application, based on the `CONFIG_ZMK_STUDIO_TRANSPORT_BLE` configuration option. If the config option is enabled, `gatt_rpc_transport.c` is compiled.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/studio/CMakeLists.txt#_snippet_3\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_STUDIO_TRANSPORT_BLE app PRIVATE gatt_rpc_transport.c)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include GPIO 595 Source\nDESCRIPTION: This line conditionally includes the `gpio_595.c` source file into the Zephyr library if the `CONFIG_GPIO_595` Kconfig option is enabled. This allows for using a GPIO expander driver.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/gpio/CMakeLists.txt#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_GPIO_595 gpio_595.c)\n```\n\n----------------------------------------\n\nTITLE: Check pipx Version (Shell)\nDESCRIPTION: This command checks if `pipx` is installed. Pipx is recommended for installing ZMK CLI to avoid conflicts with other Python packages.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\npipx --version\n```\n\n----------------------------------------\n\nTITLE: Conditional Source Inclusion for WPM Status Widget\nDESCRIPTION: This snippet conditionally includes `wpm_status.c` into the application build if `CONFIG_ZMK_WIDGET_WPM_STATUS` is defined. The source file is added as a private source to the 'app' target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/display/widgets/CMakeLists.txt#_snippet_4\n\nLANGUAGE: Kconfig\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_WIDGET_WPM_STATUS app PRIVATE wpm_status.c)\n```\n\n----------------------------------------\n\nTITLE: Conditionally adding peripheral.c source file\nDESCRIPTION: This CMake command conditionally adds `peripheral.c` as a source file to the `app` target, only if `CONFIG_ZMK_SPLIT_ROLE_CENTRAL` is not defined. It is marked as `PRIVATE`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/wired/CMakeLists.txt#_snippet_2\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifndef(CONFIG_ZMK_SPLIT_ROLE_CENTRAL app PRIVATE peripheral.c)\n```\n\n----------------------------------------\n\nTITLE: None Behavior Binding in ZMK\nDESCRIPTION: This snippet defines the 'none' behavior binding in ZMK.  It swallows key presses/releases, preventing them from being passed down to the next active layer. The behavior is referenced by `&none` and takes no parameters.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/misc.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n&none\n```\n\n----------------------------------------\n\nTITLE: Including keys.h Header in DTS for Keycode Defines\nDESCRIPTION: This code snippet demonstrates how to include the `dt-bindings/zmk/keys.h` header file in a Device Tree Source (DTS) file.  Including this header makes predefined keycode constants such as `A`, `N1`, etc., available for use in defining key behaviors in the keymap.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/key-press.md#_snippet_0\n\nLANGUAGE: dts\nCODE:\n```\n#include <dt-bindings/zmk/keys.h>\n```\n\n----------------------------------------\n\nTITLE: Defining a Zephyr library\nDESCRIPTION: This snippet uses the zephyr_library macro to define a library. It's likely part of a CMake build configuration for a Zephyr-based project, ZMK firmware in this instance. This is the start to defining a compilation unit for the Zephyr RTOS.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/arm/glove80/CMakeLists.txt#_snippet_0\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library()\n```\n\n----------------------------------------\n\nTITLE: Adding ~/.local/bin to PATH (Ubuntu)\nDESCRIPTION: Adds the `~/.local/bin` directory to the PATH environment variable on Ubuntu, ensuring that globally installed scripts are accessible. Updates the `.bashrc` file and sources it.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\necho 'export PATH=~/.local/bin:\"$PATH\"' >> ~/.bashrc\n```\n\nLANGUAGE: sh\nCODE:\n```\nsource ~/.bashrc\n```\n\n----------------------------------------\n\nTITLE: Install Git on Windows 11 (Shell)\nDESCRIPTION: This command installs Git on Windows 11 using the `winget` package manager. It provides an alternative installation method for Windows users.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/user-setup-cli.mdx#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nwinget install git.git\n```\n\n----------------------------------------\n\nTITLE: CMake: Project Setup and Source Inclusion\nDESCRIPTION: This CMake snippet sets up a Zephyr-based project named `ble_test_central`. It requires CMake version 3.20.0 or higher and utilizes the `find_package` command to locate the Zephyr SDK.  The snippet then uses `FILE(GLOB)` to collect all C source files in the `src/` directory and adds them to the `app` target.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/central/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\ncmake_minimum_required(VERSION 3.20.0)\nfind_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})\nproject(ble_test_central)\n\nFILE(GLOB app_sources src/*.c)\ntarget_sources(app PRIVATE ${app_sources})\n\n# zephyr_library_include_directories(${ZEPHYR_BASE}/samples/bluetooth)\n```\n\n----------------------------------------\n\nTITLE: Conditionally adding central.c source file\nDESCRIPTION: This CMake command conditionally adds `central.c` as a source file to the `app` target, only if `CONFIG_ZMK_SPLIT_ROLE_CENTRAL` is defined. It is also marked as `PRIVATE`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/src/split/wired/CMakeLists.txt#_snippet_1\n\nLANGUAGE: CMake\nCODE:\n```\ntarget_sources_ifdef(CONFIG_ZMK_SPLIT_ROLE_CENTRAL app PRIVATE central.c)\n```\n\n----------------------------------------\n\nTITLE: Default ZMK West Manifest\nDESCRIPTION: This YAML snippet defines the default ZMK west manifest configuration. It specifies the remote repository for ZMK firmware, the project details, and the import path for additional configurations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/features/modules.mdx#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nmanifest:\n  remotes:\n    - name: zmkfirmware\n      url-base: https://github.com/zmkfirmware\n  projects:\n    - name: zmk\n      remote: zmkfirmware\n      revision: main\n      import: app/west.yml\n  self:\n    path: config\n```\n\n----------------------------------------\n\nTITLE: Building with Only Build Directory Specified\nDESCRIPTION: Builds ZMK firmware using only the build directory, after an initial build with all arguments. This leverages cached build outputs and reduces build times.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/build-flash.mdx#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nwest build -d build/left\n```\n\n----------------------------------------\n\nTITLE: Amend Zephyr Library\nDESCRIPTION: This line amends a Zephyr library.  It's a build system function likely defined by Zephyr to modify an existing library definition. It does not take any arguments in this specific instance.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/display/CMakeLists.txt#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_amend()\n```\n\n----------------------------------------\n\nTITLE: Devicetree Error: Missing Semicolon in Keymap\nDESCRIPTION: This error indicates a missing semicolon (;) or comma (,) at a specific line in the `<keyboard>.keymap` file. The error message provides the line number where the issue occurs, but the column number might not directly correspond to the column number in your editor due to preprocessor expansion. The example shows a missing semicolon at line 109 of `cradio.keymap`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/building-issues.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\ndevicetree error: /__w/zmk-config/zmk-config/config/cradio.keymap:109 (column 4): parse error: expected ';' or ','\n```\n\n----------------------------------------\n\nTITLE: Setting Include Directory - CMake\nDESCRIPTION: Adds the current directory to the Zephyr include path, allowing the compiler to find header files located in the same directory as the CMakeLists.txt file. This is essential for resolving dependencies within the ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/sensor/max17048/CMakeLists.txt#_snippet_0\n\nLANGUAGE: CMake\nCODE:\n```\nzephyr_include_directories(.)\n```\n\n----------------------------------------\n\nTITLE: Conditionally Include GPIO MAX7318 Source\nDESCRIPTION: This line conditionally includes the `gpio_max7318.c` source file into the Zephyr library if the `CONFIG_GPIO_MAX7318` Kconfig option is enabled. This enables the use of the MAX7318 GPIO expander driver.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/drivers/gpio/CMakeLists.txt#_snippet_2\n\nLANGUAGE: Kconfig\nCODE:\n```\nzephyr_library_sources_ifdef(CONFIG_GPIO_MAX7318 gpio_max7318.c)\n```\n\n----------------------------------------\n\nTITLE: Defining a User Behaviors Instance\nDESCRIPTION: This example defines a new instance of the behaviors input processor, mapping the left mouse button code (`INPUT_BTN_1`) to trigger a paste action (LC(V), which is Left Control + V). It illustrates how to use the `compatible`, `codes`, and `bindings` properties to customize the processor's behavior. Requires `#include <zephyr/dt-bindings/input/input-event-codes.h>`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/input-processors/behaviors.md#_snippet_1\n\nLANGUAGE: DTS\nCODE:\n```\n#include <zephyr/dt-bindings/input/input-event-codes.h>\n\n/ {\n    input_processors {\n        zip_right_click_trigger_paste: zip_right_click_trigger_paste {\n            compatible = \"zmk,input-processor-behaviors\";\n            #input-processor-cells = <0>;\n            codes    = <INPUT_BTN_1>;\n            bindings = <&kp LC(V)  >;\n        };\n    };\n}\n```\n\n----------------------------------------\n\nTITLE: Add Source Files to Zephyr Library\nDESCRIPTION: Specifies the source files that constitute the 'zephyr_library'. In this case, it adds `debounce.c` as a source file. This means the debounce functionality implemented in this file will be compiled and linked as part of the defined Zephyr library.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/module/lib/zmk_debounce/CMakeLists.txt#_snippet_1\n\nLANGUAGE: cmake\nCODE:\n```\nzephyr_library_sources(debounce.c)\n```\n\n----------------------------------------\n\nTITLE: Shared Input Listener Configuration for Split Keyboard\nDESCRIPTION: This code snippet demonstrates the shared configuration for an input listener in a split keyboard setup. The listener is initially disabled but defined with a compatible property, allowing keymaps to reference it without causing errors during the peripheral build. It's meant to be included in both central and peripheral overlay files.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pointing.mdx#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    glidepoint_listener: glidepoint_listener {\n        compatible = \"zmk,input-listener\";\n        status = \"disabled\";\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: nRF52840 Pinctrl Include Chain\nDESCRIPTION: Shows the chain of includes within the Nordic nRF52840 DTS files to ultimately pull in the pinctrl header file. This ensures pin control definitions are available.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/hardware-integration/pinctrl.mdx#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\nnrf-pinctrl.h -> nrf_common.dtsi -> nrf52840.dtsi -> nrf52840_qiaa.dtsi\n```\n\n----------------------------------------\n\nTITLE: Installing ARM cross-compile toolchain (Raspberry OS)\nDESCRIPTION: Installs the `gcc-arm-none-eabi` cross-compile toolchain on Raspberry Pi OS, enabling compilation for ARM microcontrollers. This toolchain is necessary for building ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/development/local-toolchain/setup/native.mdx#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\nsudo apt install gcc-arm-none-eabi\n```\n\n----------------------------------------\n\nTITLE: Building Leeloo v2 Default Keymap with ZMK\nDESCRIPTION: These commands build the ZMK firmware for the left and right sides of the Leeloo v2 keyboard using the default keymap. Similar to the v1 build, it uses `west build`, specifying the board as `nice_nano_v2` and setting the shield to `leeloo_rev2_left` or `leeloo_rev2_right`. Output directories are `build/left_v2` and `build/right_v2`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/leeloo/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwest build -d build/left_v2 -p -b nice_nano_v2 -- -DSHIELD=leeloo_rev2_left\nwest build -d build/right_v2 -p -b nice_nano_v2 -- -DSHIELD=leeloo_rev2_right\n```\n\n----------------------------------------\n\nTITLE: Display Selection Devicetree Configuration (DTS)\nDESCRIPTION: This snippet demonstrates how to select the display device using the `chosen` node in the devicetree.  It creates a `zephyr,display` alias that points to the display node (`oled`). This is necessary for LVGL to correctly identify and use the display. This snippet assumes the display node is named `oled`.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-02-zephyr-3-0.md#_snippet_2\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n  chosen {\n    zephyr,display = &oled;\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Create Build Configuration File - YAML\nDESCRIPTION: This YAML snippet represents the `build.yaml` file used to define the GitHub Actions matrix for building ZMK firmware. It allows specifying board and shield combinations to build, providing control over the build process. The file can include simple board/shield arrays or more complex include properties for individual combinations.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2024-02-09-zephyr-3-5.md#_snippet_1\n\nLANGUAGE: YAML\nCODE:\n```\n# This file generates the GitHub Actions matrix\n# For simple board + shield combinations, add them\n# to the top level board and shield arrays, for more\n# control, add individual board + shield combinations to\n# the `include` property, e.g:\n#\n# board: [ \"nice_nano_v2\" ]\n# shield: [ \"corne_left\", \"corne_right\" ]\n# include:\n#   - board: bdn9_rev2\n#   - board: nice_nano_v2\n#     shield: reviung41\n#\n---\n\n```\n\n----------------------------------------\n\nTITLE: Enabling require-prior-idle-ms with quick-tap-ms - DTS\nDESCRIPTION: This enables `require-prior-idle-ms` with a 125ms term and `quick-tap-ms` with a 200ms term for a hold-tap behavior. If a hold-tap is pressed within 125ms of another non-modifier key, it resolves to a tap immediately.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/hold-tap.mdx#_snippet_13\n\nLANGUAGE: DTS\nCODE:\n```\nrpi: require_prior_idle {\n    compatible = \"zmk,behavior-hold-tap\";\n    #binding-cells = <2>;\n    flavor = \"tap-preferred\";\n    tapping-term-ms = <200>;\n    quick-tap-ms = <200>;\n    require-prior-idle-ms = <125>;\n    bindings = <&kp>, <&kp>;\n};\n```\n\n----------------------------------------\n\nTITLE: Running BLE Peripheral Input Test Program\nDESCRIPTION: This command executes the 'tests_ble_split_peripheral-input_peripheral.exe' program, simulating a BLE peripheral device that provides input data. The '-d=3' flag likely sets the debug level to 3.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/peripheral-input/siblings.txt#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n./tests_ble_split_peripheral-input_peripheral.exe -d=3\n```\n\n----------------------------------------\n\nTITLE: Running Prettier for Documentation Formatting\nDESCRIPTION: This snippet shows how to run Prettier to format documentation files within the ZMK project.  It uses the `npm run prettier:format` command, assuming `npm` is configured and the `prettier:format` script is defined in the `package.json` file of the project. The purpose is to ensure consistent formatting of documentation files.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/CONTRIBUTING.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run prettier:format\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Central Test Executable\nDESCRIPTION: This command executes the `ble_test_central.exe` executable. The `-d=2` parameter sets the debug level to 2, presumably controlling the verbosity of the output during the test execution.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/run-peripheral-behavior/siblings.txt#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n./ble_test_central.exe -d=2\n```\n\n----------------------------------------\n\nTITLE: Matrix Transform - Charlieplex - Devicetree\nDESCRIPTION: This devicetree snippet demonstrates how to use a matrix transform with a charlieplex matrix.  A matrix transform is used to map charlieplex pairs to the layout of the keys, accounting for the un-addressable positions inherent in charlieplex matrices. It defines `kscan0` with `compatible = \"zmk,kscan-gpio-charlieplex\"` and the corresponding `default_transform` node.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/config/layout.md#_snippet_3\n\nLANGUAGE: devicetree\nCODE:\n```\n/ {\n    chosen {\n        zmk,kscan = &kscan0;\n        zmk,matrix-transform = &default_transform;\n    };\n\n    kscan0: kscan {\n        compatible = \"zmk,kscan-gpio-charlieplex\";\n        wakeup-source;\n\n        interrupt-gpios = <&pro_micro 21 (GPIO_ACTIVE_HIGH | GPIO_PULL_DOWN) >;\n        gpios\n          = <&pro_micro 16 GPIO_ACTIVE_HIGH>\n          , <&pro_micro 17 GPIO_ACTIVE_HIGH>\n          , <&pro_micro 18 GPIO_ACTIVE_HIGH>\n          , <&pro_micro 19 GPIO_ACTIVE_HIGH>\n          , <&pro_micro 20 GPIO_ACTIVE_HIGH>\n          ; // addressable space is 5x5, (minus paired values)\n    };\n\n    default_transform: matrix_transform {\n        compatible = \"zmk,matrix-transform\";\n        rows = <3>;\n        columns = <5>;\n        //  Q  W  E  R\n        //   A  S  D  F\n        //    Z  X  C  V\n        map = <\n            RC(0,1) RC(0,2) RC(0,3) RC(0,4)\n              RC(1,0) RC(1,2) RC(1,3) RC(1,4)\n                RC(2,0) RC(2,1) RC(2,3) RC(2,4)\n        >;\n    };\n};\n\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Peripheral Test 2\nDESCRIPTION: This command executes another BLE peripheral test executable, related to the multiple-peripherals split keyboard setup.  The `-d=4` argument specifies a device ID or debug level. This test is crucial for validating ZMK's split keyboard functionality with multiple BLE connections.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/multiple-peripherals/siblings.txt#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n./tests_ble_split_multiple-peripherals_peripheral2.exe -d=4\n```\n\n----------------------------------------\n\nTITLE: Tap Dance Behavior Configuration in ZMK DTS\nDESCRIPTION: This code snippet shows how to configure a tap dance behavior in ZMK using the device tree source (DTS) format. The `tap_dance_0` behavior is defined with a tapping term of 200ms and three different key press bindings (`&kp N1`, `&kp N2`, `&kp N3`) that are triggered based on the number of taps.  The behavior is then assigned to a key in the default keymap layer.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2022-04-10-zmk-sotf-5.md#_snippet_1\n\nLANGUAGE: dts\nCODE:\n```\n/ {\n    behaviors {\n        td0: tap_dance_0 {\n            compatible = \"zmk,behavior-tap-dance\";\n            #binding-cells = <0>;\n            tapping-term-ms = <200>;\n            bindings = <&kp N1>, <&kp N2>, <&kp N3>;\n        };\n    };\n\n    keymap {\n        compatible = \"zmk,keymap\";\n\n        default_layer {\n            bindings = <\n                &td0\n            >;\n        };\n    };\n};\n```\n\n----------------------------------------\n\nTITLE: Enabling OLED Display in ZMK\nDESCRIPTION: This snippet enables the OLED display support in ZMK. Setting `CONFIG_ZMK_DISPLAY` to 'y' includes the necessary drivers and configurations to utilize the OLED screen. This is only needed if the Nibble keyboard includes an OLED display. This configuration needs to be added to the local nibble configuration file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nibble/README.md#_snippet_2\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_ZMK_DISPLAY=y\n```\n\n----------------------------------------\n\nTITLE: Expanded ZMK Macro Definition (Generated from C Macro)\nDESCRIPTION: This code snippet shows the expanded macro definition that would be generated from the `ZMK_MACRO` C macro usage. The macro includes the `compatible` property, binding cells, `wait-ms`, `tap-ms`, and `bindings` properties.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/keymaps/behaviors/macros.md#_snippet_14\n\nLANGUAGE: dts\nCODE:\n```\nmy_zero_param_macro: my_zero_param_macro {\n        compatible = \"zmk,behavior-macro\";\n        #binding-cells = <0>;\n        wait-ms = <30>;\n        tap-ms = <40>;\n        bindings = <&kp Z &kp M &kp K>;\n    };\n\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Test Application\nDESCRIPTION: This command executes the `ble_test_no_auto_sec_central.exe` application with several command-line arguments.  It disables automatic security establishment, skips service discovery, and enables HID report reading immediately after connection. The `-d=2` argument likely sets the debug level to 2.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/security/read-hid-after-connect-without-auto-sec/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_no_auto_sec_central.exe -d=2 -skip_set_security_on_connect -read_hid_report_on_connect -skip_discovery_on_connect\n```\n\n----------------------------------------\n\nTITLE: Executing BLE Central Test\nDESCRIPTION: This command executes the `ble_test_central.exe` program with specific arguments. The `-d=2` argument likely sets the debug level, and `-disconnect_and_reconnect` instructs the program to perform a disconnection and reconnection test.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/profiles/reconnect-then-output-to-selection/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -disconnect_and_reconnect\n```\n\n----------------------------------------\n\nTITLE: Adafruit nRF52 Bootloader Linker Map\nDESCRIPTION: This snippet shows the memory allocation of the Adafruit nRF52 bootloader.  It defines the regions for FLASH, BOOTLOADER_CONFIG, MBR_PARAMS_PAGE, and BOOTLOADER_SETTINGS. This helps to identify potential conflicts with other memory regions, specifically the NVS settings area used by ZMK firmware.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2020-10-03-bootloader-fix.md#_snippet_0\n\nLANGUAGE: linker-script\nCODE:\n```\nFLASH (rx) : ORIGIN = 0xF4000, LENGTH = 0xFE000-0xF4000-2048 /* 38 KB */\n\nBOOTLOADER_CONFIG (r): ORIGIN = 0xFE000 - 2048, LENGTH = 2048\n\n/** Location of mbr params page in flash. */\nMBR_PARAMS_PAGE (rw) : ORIGIN = 0xFE000, LENGTH = 0x1000\n\n/** Location of bootloader setting in flash. */\nBOOTLOADER_SETTINGS (rw) : ORIGIN = 0xFF000, LENGTH = 0x1000\n```\n\n----------------------------------------\n\nTITLE: Disabling RGB Underglow LEDs in ZMK\nDESCRIPTION: This snippet disables the RGB underglow LEDs in the ZMK firmware configuration. It sets both `CONFIG_ZMK_RGB_UNDERGLOW` and `CONFIG_WS2812_STRIP` to 'n', effectively removing support for underglow LEDs from the build. This is applicable if the Nibble keyboard was built without LEDs and uses a nice!nano board. This configuration needs to be added to the local nibble configuration file.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/boards/shields/nibble/README.md#_snippet_0\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_ZMK_RGB_UNDERGLOW=n\nCONFIG_WS2812_STRIP=n\n```\n\n----------------------------------------\n\nTITLE: Implementing Grave Escape Behavior in ZMK Keymap\nDESCRIPTION: This code snippet demonstrates how to add Grave Escape behavior to a ZMK keymap. Grave Escape sends ESC when the key is pressed alone and sends ` when the key is pressed with the GUI or Shift modifier held.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/blog/2021-01-27-zmk-sotf-4.md#_snippet_3\n\nLANGUAGE: dts\nCODE:\n```\n&gresc\n```\n\n----------------------------------------\n\nTITLE: Running BLE Central Test Program\nDESCRIPTION: This command executes the 'ble_test_central.exe' program, which simulates a BLE central device. The '-d=2' flag likely sets the debug level to 2, and '-subscribe_to_pointer_report' enables subscription to pointer report notifications.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/app/tests/ble/split/peripheral-input/siblings.txt#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n./ble_test_central.exe -d=2 -subscribe_to_pointer_report\n```\n\n----------------------------------------\n\nTITLE: Setting internal oscillator for nRF52840 - Kconfig\nDESCRIPTION: This code snippet shows how to configure the nRF52840 microcontroller to use its internal oscillator instead of an external one. This is a potential solution for devices with a faulty oscillator that are experiencing wireless connectivity issues. Using the internal oscillator results in increased power consumption.\nSOURCE: https://github.com/zmkfirmware/zmk/blob/main/docs/docs/troubleshooting/connection-issues.mdx#_snippet_1\n\nLANGUAGE: Kconfig\nCODE:\n```\nCONFIG_CLOCK_CONTROL_NRF_K32SRC_RC=y\n```"
  }
]