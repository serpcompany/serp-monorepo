[
  {
    "owner": "reagento",
    "repo": "dishka",
    "content": "TITLE: Managing REQUEST Scope with Context Manager\nDESCRIPTION: Code showing how to enter and exit the REQUEST scope using a context manager. This pattern allows for proper resource management across different requests.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# For each request, event, etc.\nfor i in range(3):\n    with container.enter_scope(Scope.REQUEST):\n        # Simulate request processing\n        service = container.get(Service)\n        result = service.get_user_with_details(user_id=42)\n        print(f\"Request {i}: {result}\")\n        # When exiting the context, REQUEST-scoped dependencies will be released\n        # and their release functions will be called\n```\n\n----------------------------------------\n\nTITLE: Integrating Dishka with FastAPI\nDESCRIPTION: This snippet demonstrates how to integrate Dishka with FastAPI. It shows the setup process, including importing necessary components, decorating a route handler, creating a container, and setting up Dishka with the FastAPI app.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.fastapi import FromDishka, inject, setup_dishka, FastapiProvider\n\n@router.get(\"/\")\n@inject\nasync def index(interactor: FromDishka[Interactor]) -> str:\n    result = interactor()\n    return result\n\napp = FastAPI()\ncontainer = make_async_container(your_provider, FastapiProvider())\nsetup_dishka(container, app)\n```\n\n----------------------------------------\n\nTITLE: Using Containers in Python with Dishka\nDESCRIPTION: Shows how to create and use containers in different scopes (APP and REQUEST) using the Dishka framework. Demonstrates getting dependencies from containers and using context managers for nested scopes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/concepts.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\napp_container = make_container(provider1, provider2)  # enter APP scope\n\nconfig = app_container.get(Config)  # APP-scoped object\n\nwith container() as request_container:  # enter REQUEST scope\n    connection = request_container.get(Connection)  # REQUEST-scoped object\n    config = request_container.get(Config)  # APP-scoped object\n```\n\n----------------------------------------\n\nTITLE: Creating a Synchronous Container in Python\nDESCRIPTION: Creates a synchronous container by calling make_container and passing a provider. The container is attached to the APP scope by default.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container\ncontainer = make_container(provider)\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Type Hints for Dependency Injection\nDESCRIPTION: Example showing how to define Service and DAO classes with proper type hints for dependency injection. The code demonstrates a simple structure with data access and business logic layers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass DAO:\n    def __init__(self, connection: Connection) -> None:\n        self.connection = connection\n\n    def get_user(self, user_id: int) -> dict:\n        return {\"id\": user_id, \"name\": \"John\"}\n\n\nclass Service:\n    def __init__(self, dao: DAO, external_api: ExternalAPI) -> None:\n        self.dao = dao\n        self.external_api = external_api\n\n    def get_user_with_details(self, user_id: int) -> dict:\n        user = self.dao.get_user(user_id)\n        details = self.external_api.get_user_details(user_id)\n        return {**user, **details}\n```\n\n----------------------------------------\n\nTITLE: Creating Provider and Configuring Dependencies\nDESCRIPTION: Example of creating a Provider instance and setting up dependency resolution with different scopes (APP and REQUEST). Shows how to register classes and provide implementations for interfaces.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import Provider, Scope\n\n\nservice_provider = Provider(scope=Scope.REQUEST)\nservice_provider.provide(Service)\nservice_provider.provide(DAOImpl, provides=DAO)\nservice_provider.provide(SomeClient, scope=Scope.APP)  # override provider scope\n```\n\n----------------------------------------\n\nTITLE: Defining FastAPI Endpoint with Dishka Injection\nDESCRIPTION: Create a FastAPI endpoint that uses Dishka's FromDishka annotation for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\nasync def endpoint(\n    request: str, gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Connection Provider with Resource Management\nDESCRIPTION: Example of a custom Provider implementation that manages database connections with proper lifecycle management using generator functions and the yield pattern for resource cleanup.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import Provider, provide, Scope\n\n\nclass ConnectionProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def new_connection(self) -> Iterable[Connection]:\n        conn = sqlite3.connect(\":memory:\")\n        yield conn\n        conn.close()\n```\n\n----------------------------------------\n\nTITLE: Integrating Dishka with FastAPI Framework\nDESCRIPTION: Example of integrating Dishka with FastAPI using the provided integration module, showing dependency injection in route handlers with the @inject decorator and FromDishka type.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.fastapi import (\n    FromDishka, inject, setup_dishka,\n)\n\n\n@router.get(\"/\")\n@inject\nasync def index(service: FromDishka[Service]) -> str:\n    ...\n\n\n...\nsetup_dishka(container, app)\n```\n\n----------------------------------------\n\nTITLE: Providing Releasable Connection with Custom Factory\nDESCRIPTION: Example of providing a database connection with custom factory and release functions. This shows how to handle resources that need explicit cleanup.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef create_connection() -> Connection:\n    print(\"Creating connection\")\n    return Connection()\n\n\ndef release_connection(connection: Connection) -> None:\n    print(\"Releasing connection\")\n    connection.close()\n\n\nprovider.provide_factory(Connection, create_connection, release_connection, scope=Scope.REQUEST)\n```\n\n----------------------------------------\n\nTITLE: Basic Provider Method with @provide Decorator in Python\nDESCRIPTION: Demonstrates how to create a basic provider by defining a method in a Provider class and decorating it with @provide to specify the dependency scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def get_a(self) -> A:\n        return A()\n```\n\n----------------------------------------\n\nTITLE: Framework Integration with FastAPI\nDESCRIPTION: Example of integrating Dishka with FastAPI using decorators and middleware. This shows how to inject dependencies into route handlers automatically.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.fastapi import (\n    FromDishka, inject, setup_dishka,\n)\n\n\n@router.get(\"/\")\n@inject\nasync def index(service: FromDishka[Service]) -> str:\n    ...\n\n\n...\nsetup_dishka(container, app)\n```\n\n----------------------------------------\n\nTITLE: Using Provider with Generic Classes in Python\nDESCRIPTION: Shows how to create factories for generic classes by utilizing type parameters in the provider method signature.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    @provide\n    def make_a(self, type_: type[T]) -> A[T]:\n        ...\n```\n\n----------------------------------------\n\nTITLE: Using Components in Python with Dishka\nDESCRIPTION: Illustrates the use of components in Dishka to create isolated groups of providers. Shows how to define providers in different components and retrieve dependencies across components.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/concepts.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MainProvider(Provider):\n\n    @provide(scope=Scope.APP)\n    def foo(self, a: Annotated[int, FromComponent(\"X\")]) -> float:\n        return a/10\n\n    @provide(scope=Scope.APP)\n    def bar(self, a: int) -> complex:\n        return a + 0j\n\n\nclass AdditionalProvider(Provider):\n    component = \"X\"\n\n    @provide(scope=Scope.APP)\n    def foo(self) -> int:\n        return 1\n\n\ncontainer = make_container(MainProvider(), AdditionalProvider())\ncontainer.get(float)  # returns 0.1\ncontainer.get(complex)  # raises NoFactoryError\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Test Example Using Dishka, FastAPI, and Pytest in Python\nDESCRIPTION: This final snippet brings together all the concepts discussed, showing a complete example of how to test a FastAPI application using Dishka for dependency injection and pytest for testing. It includes setup, mocking, and actual test cases.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# test_example.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider in Python with Dishka\nDESCRIPTION: Demonstrates how to create a custom provider by inheriting from the Provider class and using it to create a container in the Dishka framework.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/concepts.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    pass\n\ncontainer = make_container(MyProvider())\n```\n\n----------------------------------------\n\nTITLE: Factory Override Mechanism in Python\nDESCRIPTION: Demonstrates how to override an existing factory implementation by specifying the override parameter, and how this is validated when creating a container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope, make_container\n\nclass MyProvider(Provider):\n    scope=Scope.APP\n\n    @provide\n    def get_int(self) -> int:\n        return 1\n\n    @provide(override=True)\n    def get_int2(self) -> int:\n        return 2\n\ncontainer = make_container(MyProvider())\na = container.get(int)  # 2\n```\n\n----------------------------------------\n\nTITLE: Thread-Safe Synchronous Container in Python\nDESCRIPTION: Creates thread-safe containers by providing a threading.Lock factory. This prevents race conditions when accessing dependencies concurrently across multiple scopes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport threading\n\ncontainer = make_container(provider, lock_factory=threading.Lock):\nwith container(lock_factory=threading.Lock) as nested_container:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Task-Safe Asynchronous Container in Python\nDESCRIPTION: Creates task-safe async containers by providing an asyncio.Lock factory. This prevents race conditions when accessing dependencies concurrently across multiple scopes in async code.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\ncontainer = make_async_container(provider, lock_factory=asyncio.Lock)\nasync with container(lock_factory=asyncio.Lock) as nested_container:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Data with Dishka Provider\nDESCRIPTION: Demonstrates how to declare and use context data within a Dishka Provider, including handling both REQUEST and APP scoped dependencies. Shows context value injection during container creation and request handling.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/context.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom framework import Request\nfrom dishka import Provider, make_container, Scope, from_context, provide\n\n\nclass MyProvider(Provider):\n    scope = Scope.REQUEST\n\n    # declare source\n    request = from_context(provides=Request, scope=Scope.REQUEST)\n    event_broker = from_context(provides=Broker, scope=Scope.APP)\n\n    # use objects as usual\n    @provide\n    def a(self, request: Request, broker: Broker) -> A:\n        return A(data=request.contents)\n\n# provide APP-scoped context variable\ncontainer = make_container(MyProvider(), context={Broker: broker})\n\nwhile True:\n    request = broker.recv()\n    # provide REQUEST-scoped context variable\n    with container(context={Request: request}) as request_container:\n        a = request_container.get(A)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Container for Dependency Management in Python\nDESCRIPTION: This snippet shows a basic container implementation that manages dependency creation. The container provides factory methods for dependencies, allowing lazy initialization and reuse. It's passed to request handlers via middleware, maintaining testability.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass Container:\n    def get_client(self) -> Client:\n        return Client(os.getenv(\"TOKEN\"))\n\n    def get_service(self) -> Service:\n        return Service(self.get_client())\n\ncontainer = Container()\ndef container_middleware(request):\n    request.state.container = container\n\napp.setup_middleware(container_middleware)\n\n@app.get(\"/\")\ndef index(request):\n    service = request.state.container.get_service()\n    service.action()\n```\n\n----------------------------------------\n\nTITLE: Automatic Recursive Dependency Registration in Python\nDESCRIPTION: Shows how to automatically register dependencies and their dependencies recursively without manual configuration using the recursive parameter.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass A: ...\n\nclass B:\n    def __init__(self, a: A): ...\n\nclass C:\n    def __init__(self, b: B): ...\n\nclass MyProvider(Provider):\n    c = provide(C, scope=Scope.APP, recursive=True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Synchronous Dependencies in Python\nDESCRIPTION: Demonstrates how to retrieve dependencies from a synchronous container using the get() method. The same instance is returned for multiple calls within the same scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(provider)\na = container.get(A)\na = container.get(A)  # same instance\n```\n\n----------------------------------------\n\nTITLE: Integrating FastStream with Litestar and Dishka\nDESCRIPTION: Complete example demonstrating the integration of FastStream with Litestar and Dishka for both HTTP and AMQP handling.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport uvicorn\nfrom dishka import Provider, Scope, provide\nfrom dishka import make_async_container\nfrom dishka.integrations import faststream as faststream_integration\nfrom dishka.integrations import litestar as litestar_integration\nfrom dishka.integrations.base import FromDishka as Depends\nfrom dishka.integrations.faststream import inject as faststream_inject\nfrom dishka.integrations.litestar import inject as litestar_inject\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRouter, RabbitRoute\nfrom litestar import Litestar, route, HttpMethod\n\n\nclass SomeDependency:\n    async def do_something(self) -> int:\n        print(\"Hello world\")\n        return 42\n\n\nclass SomeProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def some_dependency(self) -> SomeDependency:\n        return SomeDependency()\n\n\n@route(http_method=HttpMethod.GET, path=\"/\", status_code=200)\n@litestar_inject\nasync def http_handler(some_dependency: Depends[SomeDependency]) -> None:\n    await some_dependency.do_something()\n\n\n@faststream_inject\nasync def amqp_handler(data: str, some_dependency: Depends[SomeDependency]) -> None:\n    print(f\"{data=}\")\n    await some_dependency.do_something()\n\n\ndef create_app():\n    container = make_async_container(SomeProvider())\n\n    broker = RabbitBroker(\n        url=\"amqp://guest:guest@localhost:5672/\",\n    )\n    amqp_routes = RabbitRouter(\n        handlers=(\n            RabbitRoute(amqp_handler, \"test-queue\"),\n        )\n    )\n    broker.include_router(amqp_routes)\n    faststream_integration.setup_dishka(container, FastStream(broker))\n\n    http = Litestar(\n        route_handlers=[http_handler],\n        on_startup=[broker.start],\n        on_shutdown=[broker.close],\n    )\n    litestar_integration.setup_dishka(container, http)\n    return http\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(create_app(), host=\"0.0.0.0\", port=8000)\n```\n\n----------------------------------------\n\nTITLE: Dependency Finalization Using Generator Function in Python\nDESCRIPTION: Shows how to implement finalization logic for a dependency by turning the provider method into a generator function, allowing cleanup code to run when exiting the scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def get_a(self) -> Iterable[A]:\n        a = A()\n        yield a\n        a.close()\n```\n\n----------------------------------------\n\nTITLE: Providing Class Dependency Without Custom Logic in Python\nDESCRIPTION: Shows how to provide a class dependency directly using provide as a function without needing to define a method, leveraging the class's __init__ for dependency resolution.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n    a = provide(A, scope=Scope.REQUEST)\n```\n\n----------------------------------------\n\nTITLE: Entering Nested Scope with Asynchronous Container in Python\nDESCRIPTION: Creates a nested async container by calling the container as a function and using it as an async context manager. This enters the next scope in the container hierarchy.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync with container() as nested_container:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Using from_context with Dishka Provider and Scope\nDESCRIPTION: Demonstrates how to use from_context to inject dependencies from context into a Provider. It shows how to define context-dependent dependencies and use them in provider methods, as well as how to set context when entering scopes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/from_context.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import from_context, Provider, provide, Scope\n\nclass MyProvider(Provider):\n    scope = Scope.REQUEST\n\n    app = from_context(provides=App, scope=Scope.APP)\n    request = from_context(provides=RequestClass)\n\n    @provide\n    def get_a(self, request: RequestClass, app: App) -> A:\n        ...\n\ncontainer = make_container(MyProvider(), context={App: app})\nwith container(context={RequestClass: request_instance}) as request_container:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider for FastAPI\nDESCRIPTION: Define a custom provider class that can access FastAPI's Request object in the REQUEST scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Integrating FastStream with FastAPI and Dishka\nDESCRIPTION: Complete example showing how to integrate FastStream with FastAPI and Dishka for both HTTP and AMQP handling.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport uvicorn\nfrom dishka import Provider, Scope, provide\nfrom dishka import make_async_container\nfrom dishka.integrations import fastapi as fastapi_integration\nfrom dishka.integrations import faststream as faststream_integration\nfrom dishka.integrations.base import FromDishka as Depends\nfrom dishka.integrations.fastapi import DishkaRoute\nfrom dishka.integrations.faststream import inject as faststream_inject\nfrom fastapi import FastAPI, APIRouter\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker, RabbitRouter, RabbitRoute\n\n\nclass SomeDependency:\n    async def do_something(self) -> int:\n        print(\"Hello world\")\n        return 42\n\n\nclass SomeProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def some_dependency(self) -> SomeDependency:\n        return SomeDependency()\n\n\nrouter = APIRouter(\n    route_class=DishkaRoute,\n)\n\n\n@router.get(\"/\")\nasync def http_handler(some_dependency: Depends[SomeDependency]) -> None:\n    await some_dependency.do_something()\n\n\n@faststream_inject\nasync def amqp_handler(data: str, some_dependency: Depends[SomeDependency]) -> None:\n    print(f\"{data=}\")\n    await some_dependency.do_something()\n\n\ndef create_app():\n    container = make_async_container(SomeProvider())\n\n    broker = RabbitBroker(\n        url=\"amqp://guest:guest@localhost:5672/\",\n    )\n    amqp_routes = RabbitRouter(\n        handlers=(\n            RabbitRoute(amqp_handler, \"test-queue\"),\n        )\n    )\n    broker.include_router(amqp_routes)\n    faststream_integration.setup_dishka(container, FastStream(broker))\n\n    http = FastAPI(\n        on_startup=[broker.start],\n        on_shutdown=[broker.close],\n    )\n    http.include_router(router)\n    fastapi_integration.setup_dishka(container, http)\n    return http\n\n\nif __name__ == \"__main__\":\n    uvicorn.run(create_app(), host=\"0.0.0.0\", port=8000)\n```\n\n----------------------------------------\n\nTITLE: Basic Alias Usage with Provider Class\nDESCRIPTION: Demonstrates how to create an alias for a class A to be retrieved as AProtocol using a provider class. Shows basic alias configuration within a provider class using the @provide decorator.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/alias.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import alias, provide, Provider, Scope\n\nclass MyProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def get_a(self) -> A:\n        return A()\n\n    a_proto = alias(source=A, provides=AProtocol)\n```\n\n----------------------------------------\n\nTITLE: Accessing APP-Scoped Dependencies\nDESCRIPTION: Example of accessing APP-scoped dependencies using the container's get method. This demonstrates how to retrieve singleton instances.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Access APP-scoped dependency\nexternal_api = container.get(ExternalAPI)\n```\n\n----------------------------------------\n\nTITLE: Creating FastAPI Application Factory with Dishka in Python\nDESCRIPTION: This code shows how to create a FastAPI application factory that uses a Dishka container. It separates the application creation from the container setup, allowing for more flexible testing configurations.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# app_factory.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Defining FastAPI Service Structure in Python\nDESCRIPTION: This snippet shows the structure of a FastAPI service with dependency injection. It includes the definition of a Repository class, a Service class that depends on the Repository, and a FastAPI app with a route that uses the Service.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# app_before.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Configuring Provider with Custom Initialization\nDESCRIPTION: Demonstrates how to create a Provider subclass with custom initialization to handle configuration parameters.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    def __init__(self, uri: str, scope: Scope):\n        super().__init__(scope=scope)  # do not forget `super`\n        self.uri = uri\n\n    @provide\n    def get_connection(self) -> Iterable[Connection]:\n        conn = connect(self.uri)  # use passed configuration\n        yield conn\n        conn.close()\n\n    gateway = provide(Gateway)\n\nprovider = MyProvider(uri=os.getenv(\"DB_URI\"), scope=Scope.APP)\ncontainer = make_container(provider)\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Provider Methods in Python\nDESCRIPTION: This example illustrates how various provider methods like 'provide', 'alias', 'decorate', 'from_context', and 'provide_all' can be combined in a Dishka Provider class. It shows two equivalent ways of configuring providers: individually and using a combined approach.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide_all.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import alias, decorate, provide, provide_all, Provider, Scope\n\nclass OneByOne(Provider):\n    scope = Scope.APP\n\n    data = from_context(Data)\n    a = provide(A, provides=AProtocol)\n    b = provide(B, providesAProtocol)\n    b_alias = alias(source=C, provides=B)\n    c_decorate = decorate(CDecorator, provides=C)\n\nclass AllAtOnce(Provider):\n    scope = Scope.APP\n\n    provides = (\n        provide(A, provides=AProtocol)\n        + provide(B, provides=AProtocol)\n        + alias(source=C, provides=B)\n        + decorate(CDecorator, provides=C)\n        + from_context(Data)\n    )\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Container for Dependency Resolution\nDESCRIPTION: Example of creating a main Container by combining providers and accessing APP-scoped dependencies directly from the container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container\n\n\ncontainer = make_container(service_provider, ConnectionProvider())\n\nclient = container.get(SomeClient)  # `SomeClient` has Scope.APP, so it is accessible here\nclient = container.get(SomeClient)  # same instance of `SomeClient`\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into ARQ Task Handler in Python\nDESCRIPTION: This code demonstrates how to use the @inject decorator and FromDishka[] type hint to inject dependencies into an ARQ task handler function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/arq.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def get_content(\n    context: dict[Any, Any],\n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Integrating Dishka with FastAPI Application\nDESCRIPTION: Set up the Dishka integration with the FastAPI application using the setup_dishka function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app)\n```\n\n----------------------------------------\n\nTITLE: Configuring Provider Using Direct Method Calls\nDESCRIPTION: Demonstrates how to configure a Provider instance directly using method calls to register dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container, Provider, Scope\n\ndef get_connection() -> Iterable[Connection]:\n    conn = connect(uri)\n    yield conn\n    conn.close()\n\nprovider = Provider(scope=Scope.APP)\nprovider.provide(get_connection)\nprovider.provide(Gateway)\n\ncontainer = make_container(provider)\n```\n\n----------------------------------------\n\nTITLE: Supporting Multiple Interfaces with AnyOf in Python\nDESCRIPTION: Shows how to create a provider that can satisfy requests for multiple interfaces with the same implementation using the AnyOf type hint.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import AnyOf, provide, Provider, Scope\n\nclass MyProvider(Provider):\n    scope=Scope.APP\n\n    @provide\n    def p(self) -> AnyOf[A, AProtocol]:\n        return A()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Asynchronous Dependencies in Python\nDESCRIPTION: Demonstrates how to retrieve dependencies from an asynchronous container using the get() method with await. The same instance is returned for multiple calls within the same scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(provider)\na = await container.get(A)\na = await container.get(A)  # same instance\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration with FastStream\nDESCRIPTION: Configure the Dishka integration with FastStream, enabling automatic injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, broker=broker, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Defining a Dependency in Python\nDESCRIPTION: Demonstrates how to define a dependency relationship between two classes in Python. The Service class depends on the Client class.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/concepts.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Service:\n    def __init__(self, client: Client):\n        self.client = client\n```\n\n----------------------------------------\n\nTITLE: Alias Override Configuration\nDESCRIPTION: Shows how to configure alias overriding and different type mappings. Demonstrates using alias with override functionality and multiple type mappings within a provider class.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/alias.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope, alias, make_container\n\nclass MyProvider(Provider):\n    scope=Scope.APP\n    get_int = provide(int)\n    get_float = provide(float)\n\n    a_alias = alias(int, provides=complex)\n    a_alias_override = alias(float, provides=complex, override=True)\n\ncontainer = make_container(MyProvider())\na = container.get(complex)  # 0.0\n```\n\n----------------------------------------\n\nTITLE: Creating Providers with Scope Specification\nDESCRIPTION: Code that defines providers for dependency injection. It shows how to specify different scopes (APP vs REQUEST) for dependencies based on their lifecycle requirements.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import Provider, Scope\n\nprovider = Provider()\nprovider.provide(ExternalAPI, scope=Scope.APP)  # Created once for app lifecycle\nprovider.provide(Service, scope=Scope.REQUEST)  # Created for each request\nprovider.provide(DAO, scope=Scope.REQUEST)\n```\n\n----------------------------------------\n\nTITLE: Rendering Dependency Graphs with Dishka\nDESCRIPTION: Two methods for visualizing dependency graphs: render_d2() generates d2 lang format output, while render_mermaid() produces HTML with embedded mermaid.js graph. Both functions take a container parameter and return formatted string output.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/plotter.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndishka.plotter.render_d2(container)\n```\n\nLANGUAGE: python\nCODE:\n```\ndishka.plotter.render_mermaid(container)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dishka Container for FastAPI Application in Python\nDESCRIPTION: This snippet demonstrates how to set up a Dishka container for a FastAPI application. It would typically include provider definitions for the Repository and Service classes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# container_before.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Creating and Entering Container APP Scope\nDESCRIPTION: Code that creates the main Container instance and enters the APP scope. This initializes application-level dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import Container\n\ncontainer = Container([provider])\ncontainer.enter_scope(Scope.APP)\n```\n\n----------------------------------------\n\nTITLE: Using @decorate with Additional Parameters in Dishka\nDESCRIPTION: An example showing how a decorator function can also accept additional parameters beyond the object being decorated. The function can use these extra dependencies when creating the decorated object.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/decorate.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import decorate, Provider\n\nclass MyProvider(Provider):\n    @decorate\n    def decorate_a(self, a: A, b: B) -> A:\n        return ADecorator(a)\n```\n\n----------------------------------------\n\nTITLE: Implementing Constructor Injection in Python\nDESCRIPTION: This snippet demonstrates the primary DI approach - constructor injection. Dependencies are passed when creating the service instance, making them available to all methods and improving testability. The token is loaded from environment variables outside the business logic.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Service:\n    def __init__(self, client: Client):\n        self.client = client\n\n    def action(self):\n        self.client.get_data()\n\ntoken = os.getenv(\"TOKEN\")\nclient = Client(token)\nservice = Service(client)\nservice.action()\n```\n\n----------------------------------------\n\nTITLE: Creating New Types for Provider Isolation in Python\nDESCRIPTION: This snippet demonstrates how to distinguish between objects of the same type but with different meanings by using Python's NewType functionality to create semantically different types that will be recognized by Dishka.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/components.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NewType\n\nMainDbConnection = NewType(\"MainDbConnection\", Connection)\n```\n\n----------------------------------------\n\nTITLE: Managing Request Scope in WebSocket Handlers\nDESCRIPTION: Demonstrates how to handle WebSocket connections with both SESSION and REQUEST scoped dependencies by manually entering nested scope contexts.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def get_with_request(\n    websocket: WebSocket,\n    a: FromDishka[A],  # object with Scope.SESSION\n    container: FromDishka[AsyncContainer],  # container for Scope.SESSION\n) -> None:\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        # enter the nested scope, which is Scope.REQUEST\n        async with container() as request_container:\n            b = await request_container.get(B)  # object with Scope.REQUEST\n```\n\n----------------------------------------\n\nTITLE: Configuring Provider Using Class Inheritance\nDESCRIPTION: Shows how to configure a Provider by creating a subclass and using decorators to register dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container, Provider, provide, Scope\n\nclass MyProvider(Provider):\n    @provide\n    def get_connection(self) -> Iterable[Connection]:\n        conn = connect(uri)\n        yield conn\n        conn.close()\n\n    gateway = provide(Gateway)\n\ncontainer = make_container(MyProvider(scope=Scope.APP))\n```\n\n----------------------------------------\n\nTITLE: Overriding Providers with from_context in Dishka\nDESCRIPTION: Shows how to use from_context to override an existing provider factory. It demonstrates setting the override parameter and how the overridden value is used when retrieving dependencies from the container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/from_context.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, from_context, Provider, Scope, make_container\nclass MyProvider(Provider):\n    scope=Scope.APP\n\n    @provide\n    def get_int(self) -> int:\n        return 1\n\n    a_override = from_context(provides=int, override=True)\n\ncontainer = make_container(MyProvider(), context={int: 2})\na = container.get(int)  # 2\n```\n\n----------------------------------------\n\nTITLE: Providing Child Class for Parent Class Request in Python\nDESCRIPTION: Demonstrates how to configure a provider to return a child class instance when a parent class is requested, using source and provides parameters.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n    a = provide(source=AChild, scope=Scope.REQUEST, provides=A)\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies in Web Request Handlers in Python\nDESCRIPTION: This snippet shows the basic approach to dependency creation in web request handlers. Dependencies are created for each request, which ensures isolation but results in code duplication across handlers and potential inefficiency due to repeated instantiation.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@app.get(\"/\")\ndef index(request):\n    client = Client(os.getenv(\"TOKEN\"))\n    service = Service(client)\n    service.action()\n\n@app.get(\"/foo\")\ndef get_foo(request):\n    client = Client(os.getenv(\"TOKEN\"))\n    service = Service(client)\n    service.action()\n```\n\n----------------------------------------\n\nTITLE: Handling WebSocket Connections with Dishka in FastAPI\nDESCRIPTION: Implement a WebSocket handler using Dishka for dependency injection, managing both SESSION and REQUEST scopes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def get_with_request(\n    websocket: WebSocket,\n    a: FromDishka[A],  # object with Scope.SESSION\n    container: FromDishka[AsyncContainer],  # container for Scope.SESSION\n) -> None:\n    await websocket.accept()\n    while True:\n        data = await websocket.receive_text()\n        # enter the nested scope, which is Scope.REQUEST\n        async with container() as request_container:\n            b = await request_container.get(B)  # object with Scope.REQUEST\n```\n\n----------------------------------------\n\nTITLE: Explicit Runtime Scope Container Creation\nDESCRIPTION: Shows how to create a container with explicit RUNTIME scope and enter APP scope afterwards.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/scopes.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(provider, start_scope=Scope.RUNTIME)\nwith container() as app_container:\n    # RUNTIME -> APP\n```\n\n----------------------------------------\n\nTITLE: Defining Classes with Type Hints for Dependency Injection\nDESCRIPTION: Example of defining protocol and implementation classes with proper type hints to be used with Dishka dependency injection. Shows a service depending on a DAO interface.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass DAO(Protocol):\n    ...\n\n\nclass Service:\n    def __init__(self, dao: DAO):\n        ...\n\n\nclass DAOImpl(DAO):\n    def __init__(self, connection: Connection):\n        ...\n\n\nclass SomeClient:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Decorating Generic Objects with @decorate in Python\nDESCRIPTION: Shows how to create and apply Generic decorators to any type in Dishka, demonstrating generic type decoration patterns.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/generics.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n./generics_examples/decorate.py\n```\n\n----------------------------------------\n\nTITLE: Setting Default Scope for Multiple Dependencies in Python\nDESCRIPTION: Demonstrates how to set a default scope at the Provider class level to avoid specifying scope for each dependency individually, while still allowing override for specific cases.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n   scope=Scope.APP\n\n   @provide  # uses provider scope\n   async def get_a(self) -> A:\n      return A()\n\n   @provide(scope=Scope.REQUEST)  # has own scope\n   async def get_b(self) -> B:\n      return B()\n```\n\n----------------------------------------\n\nTITLE: Closing Container and Releasing Resources\nDESCRIPTION: Example of properly closing the container to clean up resources when the application shuts down.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncontainer.close()\n```\n\n----------------------------------------\n\nTITLE: Setting up Dishka Integration with Starlette Application\nDESCRIPTION: Configures the Dishka integration with a Starlette application to enable dependency injection throughout the application.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app)\n```\n\n----------------------------------------\n\nTITLE: Closing an Asynchronous Container in Python\nDESCRIPTION: Shows how to properly close an APP-level async container using await. This should be called on application termination to clean up resources.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nawait container.close()\n```\n\n----------------------------------------\n\nTITLE: Session and Request Scope Management\nDESCRIPTION: Illustrates different ways to manage session and request scopes, including automatic scope skipping and explicit scope entry.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/scopes.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(provider)\nwith container() as request_container:\n    # APP -> Session -> REQUEST\n    pass\n\nwith container(scope=Scope.SESSION) as session_container:\n    # APP -> Session\n    with session_container() as request_container:\n        # Session -> REQUEST\n        pass\n```\n\n----------------------------------------\n\nTITLE: Setting Up FastAPI Lifespan for Container Management\nDESCRIPTION: Configure FastAPI lifespan to properly close the Dishka container on application termination.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    yield\n    await app.state.dishka_container.close()\n\napp = FastAPI(lifespan=lifespan)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration with Flask\nDESCRIPTION: Configure the Dishka integration with Flask using setup_dishka. This should be called after registering all views and blueprints. Set auto_inject=True for automatic injection without @inject decorator.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Configuring Dishka with Synchronous Container for FastAPI\nDESCRIPTION: Set up Dishka integration using a synchronous container in a FastAPI application, including necessary imports and endpoint definition.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.fastapi import (\n    FromDishka,\n    FastapiProvider,\n    inject_sync,\n    setup_dishka,\n)\nfrom dishka import make_container, Provider, provide, Scope\n\n\nrouter = APIRouter()\n\n\n@router.get('/')\n@inject_sync\ndef endpoint(\n    gateway: FromDishka[Gateway],\n) -> ResponseModel:\n    ...\n\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    yield\n    app.state.dishka_container.close()\n\napp = FastAPI(lifespan=lifespan)\napp.include_router(router)\ncontainer = make_container(YourProvider(), FastapiProvider())\nsetup_dishka(container=container, app=app)\n```\n\n----------------------------------------\n\nTITLE: Creating Async Container with AiogramProvider\nDESCRIPTION: Create an async container with AiogramProvider to use TelegramObject and AiogramMiddlewareData in providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), AiogramProvider())\n```\n\n----------------------------------------\n\nTITLE: Setting up dishka integration with aiohttp\nDESCRIPTION: Demonstrates how to set up the dishka integration with an aiohttp application. The auto_inject parameter enables automatic dependency injection without explicit decorators.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider with Flask Request Access\nDESCRIPTION: Define a custom provider class that can access the Flask Request object within the REQUEST scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Dishka Integration Setup\nDESCRIPTION: Final setup of Dishka integration with Litestar application.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app)\n```\n\n----------------------------------------\n\nTITLE: Async Provider Method Implementation in Python\nDESCRIPTION: Shows how to create an asynchronous provider method for dependencies that require async initialization, and how to retrieve them from an async container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, Provider, Scope\n\nclass MyProvider(Provider):\n   @provide(scope=Scope.APP)\n   async def get_a(self) -> A:\n      return A()\n\ncontainer = make_async_container(MyProvider())\na = await container.get(A)\n```\n\n----------------------------------------\n\nTITLE: Setting Up gRPC Server with Dishka Interceptor\nDESCRIPTION: Shows how to configure a gRPC server with DishkaInterceptor for handling dependency injection in service calls.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/grpcio.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nserver = make_server(\n    ThreadPoolExecutor(max_workers=10),\n    interceptors=[\n        DishkaInterceptor(container),\n    ],\n)\n```\n\n----------------------------------------\n\nTITLE: Setting Provider Scope at Instance Level\nDESCRIPTION: Demonstrates setting scope when instantiating a Provider.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nprovider = Provider(scope=Scope.APP)\n```\n\n----------------------------------------\n\nTITLE: Creating a Container with FlaskProvider\nDESCRIPTION: Create a Dishka container using make_container, including FlaskProvider if Flask Request access is needed in providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(YourProvider(), FlaskProvider())\n```\n\n----------------------------------------\n\nTITLE: Implementing Parameter Injection in Python\nDESCRIPTION: This example shows parameter injection where dependencies are passed directly to methods. While this approach improves testability, it can become cumbersome when there are many methods that call each other or when maintaining interface compatibility is required.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Service:\n    def action(self, client: Client):\n        client.get_data()\n\nservice = Service()\nclient = Client(token=\"1234567890\")\nservice.action(client)\n```\n\n----------------------------------------\n\nTITLE: Configuring Components in Dishka Providers\nDESCRIPTION: This code shows various ways to specify which component a provider belongs to: using the default component, setting the component in a class definition, during instance creation, or creating a copy of a provider for a different component.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/components.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container, Provider\n\n# default component is used when not specified\nprovider0 = Provider()\n\nclass MyProvider(Provider):\n    # component can be set in class\n    component = \"component_name\"\n\nprovider1 = MyProvider()\n\n# component can be set on instance creation\nprovider2 = MyProvider(component=\"other\")\n\n# same provider instance is casted to use with different component\nprovider3 = provider2.to_component(\"additional\")\n\ncontainer = make_container(provider0, provider1, provider2, provider3)\n```\n\n----------------------------------------\n\nTITLE: Setting Provider Scope at Class Level\nDESCRIPTION: Shows how to set scope at the Provider class level.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    scope=Scope.APP\n```\n\n----------------------------------------\n\nTITLE: Using Dishka Inject Decorator for Manual Injection\nDESCRIPTION: Apply the @inject decorator to enable manual dependency injection in FastAPI endpoints or WebSocket handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\n@inject\nasync def endpoint(\n    gateway: FromDishka[Gateway],\n) -> ResponseModel:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Defining Basic Dependencies in Python\nDESCRIPTION: Shows basic class definitions for a Connection and Gateway class demonstrating a simple dependency relationship.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Connection:\n    pass\n\nclass Gateway:\n    def __init__(self, conn: Connection):\n        pass\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Component Isolation in Dishka\nDESCRIPTION: This example illustrates how components are isolated from each other. A provider in the default component cannot access an object from another component (\"X\") without explicit permission, leading to a dependency resolution error.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/components.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_container, Provider, provide, Scope\n\nclass MainProvider(Provider):\n    # default component is used here\n\n    @provide(scope=Scope.APP)\n    def foo(self, a: int) -> float:\n        return a/10\n\n\nclass AdditionalProvider(Provider):\n    component = \"X\"\n\n    @provide(scope=Scope.APP)\n    def foo(self) -> int:\n        return 1\n\n# we will get error immediately during container creation, skip validation for demo needs\ncontainer = make_container(MainProvider(), AdditionalProvider(), skip_validation=True)\n# retrieve from component \"X\"\ncontainer.get(int, component=\"X\")  # value 1 would be returned\n# retrieve from default component\ncontainer.get(float)  # raises NoFactoryError because int is in another component\n```\n\n----------------------------------------\n\nTITLE: Cross-Component Dependencies Using FromComponent Annotation\nDESCRIPTION: This snippet shows how to explicitly request a dependency from a different component using the Annotated type with FromComponent. This enables MainProvider to access an integer from component \"X\".\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/components.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\nfrom dishka import FromComponent, make_container, Provider, provide, Scope\n\nclass MainProvider(Provider):\n\n    @provide(scope=Scope.APP)\n    def foo(self, a: Annotated[int, FromComponent(\"X\")]) -> float:\n        return a/10\n\n\nclass AdditionalProvider(Provider):\n    component = \"X\"\n\n    @provide(scope=Scope.APP)\n    def foo(self) -> int:\n        return 1\n\ncontainer = make_container(MainProvider(), AdditionalProvider())\ncontainer.get(float)  # returns 0.1\n```\n\n----------------------------------------\n\nTITLE: Creating Container with GrpcioProvider\nDESCRIPTION: Demonstrates how to create a container with GrpcioProvider for handling ServicerContext and protobuf Message objects.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/grpcio.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(YourProvider(), GrpcioProvider())\n```\n\n----------------------------------------\n\nTITLE: Creating a provider with request access\nDESCRIPTION: Demonstrates how to create a custom provider that can access the aiohttp Request object. This provider can be used for both HTTP and Websocket requests in REQUEST and SESSION scopes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Using FromDishka in route handlers\nDESCRIPTION: Shows how to mark parameters in aiohttp route handlers for dependency injection using the FromDishka type annotation. This allows automatic injection of dependencies into the handler function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\nasync def endpoint(\n    request: str, gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Attribute Injection in Python\nDESCRIPTION: This example shows attribute injection where dependencies are set directly on object attributes after construction. This approach is typically used to break cyclic dependencies or modify existing objects, often in combination with constructor injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass Service:\n    client: Client\n\n    def action(self):\n        self.client.get_data()\n\nservice = Service()\nservice.client = Client(token)\nservice.action()\n```\n\n----------------------------------------\n\nTITLE: Using explicit inject decorator with aiohttp handlers\nDESCRIPTION: Shows how to use the @inject decorator explicitly with an aiohttp route handler. This is optional if auto_inject is enabled in the setup.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\n@inject\nasync def endpoint(\n    request: str, gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Handling Websockets with REQUEST scope\nDESCRIPTION: Demonstrates how to handle websockets with different scopes in aiohttp. Since websocket handlers are called once per connection, manual scope management is needed for REQUEST-scoped dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def get_with_request(\n    request: Request,\n    a: FromDishka[A],  # some object with Scope.SESSION\n    container: FromDishka[AsyncContainer],  # container for Scope.SESSION\n) -> web.WebsocketResponse:\n    websocket = web.WebsocketResponse()\n    await websocket.prepare(request)\n\n    async for message in websocket:\n        # enter the nested scope, which is Scope.REQUEST\n        async with container() as request_container:\n            b = await request_container.get(B)  # object with Scope.REQUEST\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Container with APP Scope\nDESCRIPTION: Demonstrates creating a container that implicitly enters the APP scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/scopes.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_container(provider)  # APP\n```\n\n----------------------------------------\n\nTITLE: Creating a container with AiohttpProvider\nDESCRIPTION: Shows how to create a dishka container with AiohttpProvider, which is needed when using aiohttp.web.Request in providers. This enables request-based dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), AiohttpProvider())\n```\n\n----------------------------------------\n\nTITLE: Creating an Asynchronous Container in Python\nDESCRIPTION: Creates an asynchronous container by calling make_async_container and passing a provider. Async containers can use both sync and async dependency sources.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import make_async_container\n\ncontainer = make_async_container(provider)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration with Celery\nDESCRIPTION: Shows how to configure the Dishka integration with a Celery application by providing the container and application instances to the setup_dishka function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=celery_app)\n```\n\n----------------------------------------\n\nTITLE: Importing dishka-aiohttp components\nDESCRIPTION: Shows how to import the necessary modules and classes from the dishka-aiohttp integration package to enable dependency injection in an aiohttp application.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.aiohttp import (\n    DISHKA_CONTAINER_KEY,\n    FromDishka,\n    inject,\n    setup_dishka,\n    AiohttpProvider,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Closing the container on application shutdown\nDESCRIPTION: Shows how to properly close the dishka container when the aiohttp application shuts down, which is important for resource cleanup and proper application termination.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiohttp.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def on_shutdown(app: Application):\n    await app[DISHKA_CONTAINER_KEY].close()\n\napp.on_shutdown.append(on_shutdown)\n```\n\n----------------------------------------\n\nTITLE: Comparing Individual Provides with Provide All in Python\nDESCRIPTION: This snippet demonstrates the equivalence between using multiple 'provide' calls and using a single 'provide_all' call in a Dishka Provider class. Both approaches result in the same configuration for the container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide_all.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import provide, provide_all, Provider, Scope\n\nclass OneByOne(Provider):\n    scope = Scope.APP\n\n    a = provide(ClassA)\n    b = provide(ClassB)\n\nclass AllAtOnce(Provider):\n    scope = Scope.APP\n\n    ab = provide_all(ClassA, ClassB)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Container Cleanup on Worker Shutdown\nDESCRIPTION: Demonstrates how to connect a handler to the worker_process_shutdown signal to properly close the Dishka container when a Celery worker process shuts down.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom celery import current_app\nfrom celery.signals import worker_process_shutdown\nfrom dishka import Container\n\n@worker_process_shutdown.connect()\ndef close_dishka(*args, **kwargs):\n    container: Container = current_app.conf[\"dishka_container\"]\n    container.close()\n```\n\n----------------------------------------\n\nTITLE: Container Creation with LitestarProvider\nDESCRIPTION: Creating an async container with custom provider and LitestarProvider for Request object support.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), LitestarProvider())\n```\n\n----------------------------------------\n\nTITLE: Closing Container Resources\nDESCRIPTION: Command to close the container when the application is shutting down. This ensures proper cleanup of all managed resources.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncontainer.close()\n```\n\n----------------------------------------\n\nTITLE: Resolving Dependencies by Parent Classes with WithParents in Python\nDESCRIPTION: Demonstrates how to configure a provider to allow resolution by parent classes or interfaces using the WithParents type hint wrapper.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import WithParents, provide, Provider, Scope\n\nclass A(Protocol): ...\nclass AImpl(A): ...\n\nclass MyProvider(Provider):\n    scope=Scope.APP\n\n    @provide\n    def a(self) -> WithParents[AImpl]:\n        return A()\n\ncontainer = make_async_container(MyProvider())\na = await container.get(A)\na = await container.get(AImpl)\na is a # True\n```\n\n----------------------------------------\n\nTITLE: Writing Tests with Mocked Dependencies Using Dishka and Pytest in Python\nDESCRIPTION: This code shows how to write tests using mocked dependencies configured with Dishka and pytest. It demonstrates how to use the fixtures and mocked objects in actual test cases.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# sometest.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Setting Up FastAPI Router with Dishka Integration\nDESCRIPTION: Configure a FastAPI router to use DishkaRoute for automatic dependency injection in HTTP endpoints.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nrouter = APIRouter(route_class=DishkaRoute)\n```\n\n----------------------------------------\n\nTITLE: Defining Endpoint with Dependency Injection\nDESCRIPTION: Example of using @inject decorator and FromDishka type annotation to inject dependencies into route handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\n@inject\nasync def endpoint(\n    request: str, gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider for FastStream\nDESCRIPTION: Define a custom provider class that can access StreamMessage in the REQUEST scope for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, event: StreamMessage) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Objects with @provide in Python\nDESCRIPTION: Demonstrates creating generic factory methods using TypeVar and Generic classes in Dishka. Shows how to use type[T] to access resolved TypeVar values with bounds and constraints.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/generics.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n./generics_examples/provide.py\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Starlette Endpoint Handlers\nDESCRIPTION: Shows how to use the @inject decorator with FromDishka type annotation to inject dependencies into Starlette endpoint handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def endpoint(\n    request: Request,\n    *,\n    gateway: FromDishka[Gateway],\n) -> ResponseModel:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Container Lifecycle Management\nDESCRIPTION: Setting up lifespan context manager to properly close the container on application termination.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@asynccontextmanager\nasync def lifespan(app: Litestar):\n    yield\n    await app.state.dishka_container.close()\n\napp = Litestar([endpoint], lifespan=[lifespan])\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka FastAPI Integration Components\nDESCRIPTION: Import necessary components from dishka and its FastAPI integration to set up dependency injection in a FastAPI application.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.fastapi import (\n    DishkaRoute,\n    FromDishka,\n    FastapiProvider,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider with Request Access\nDESCRIPTION: Defines a provider class that can access the Starlette Request object within the REQUEST scope. This demonstrates how to create dependencies that rely on the request context.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Using wrap_injection for Automatic Scope Management in Python\nDESCRIPTION: This snippet demonstrates how to use the 'wrap_injection' function with 'manage_scope=True' to automate entering and exiting the request scope without relying on middleware. This approach ensures that the container passed to 'wrap_injection' enters and exits the next scope automatically.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/adding_new.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwrap_injection(manage_scope=True)\n```\n\n----------------------------------------\n\nTITLE: Decorating gRPC Service Handler with Dependency Injection\nDESCRIPTION: Shows how to use the @inject decorator and FromDishka type annotation to inject dependencies into gRPC service handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/grpcio.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass ExampleService(ExampleServiceServicer):\n    @inject\n    def MyMethod(\n        self,\n        request: MyRequest,\n        context: ServicerContext,\n        service: FromDishka[UUIDService],\n    ) -> ResponseMessage:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Setting Dishka Task Class for Individual Celery Task\nDESCRIPTION: Shows how to set the DishkaTask base class for an individual Celery task, enabling automatic dependency injection just for that specific task handler.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@celery_app.task(base=DishkaTask)\ndef start( \n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Importing FastStream-Dishka Integration Components\nDESCRIPTION: Import necessary components from dishka and its FastStream integration for setting up dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.faststream import (\n    FromDishka,\n    inject,\n    setup_dishka,\n    FastStreamProvider,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Implementing Provider with Request Scope\nDESCRIPTION: Example of creating a provider class that uses the REQUEST scope and accesses the protobuf Message for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/grpcio.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, message: Message) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into TaskIQ Task Handlers in Python\nDESCRIPTION: Shows how to use the @inject decorator along with the FromDishka type annotation to inject dependencies into TaskIQ task handler functions. The patch_module parameter affects how task_name is generated.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/taskiq.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@broker.task\n@inject(patch_module=True)\nasync def start(\n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Setting Dishka Task Class for Celery App\nDESCRIPTION: Demonstrates how to configure a Celery app to use DishkaTask as the default task class, enabling automatic dependency injection for all task handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncelery_app = Celery(task_cls=DishkaTask)\n```\n\n----------------------------------------\n\nTITLE: Setting Provider Scope at Factory Level\nDESCRIPTION: Shows how to set dependency scope when registering individual factories.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    gateway = provide(Gateway, scope=Scope.APP)\n```\n\n----------------------------------------\n\nTITLE: Exception Handling in Provider Generator Functions in Python\nDESCRIPTION: Demonstrates how to handle exceptions that occur during dependency usage by capturing the exception in the generator function after yielding the dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def get_a(self) -> Iterable[A]:\n        a = A()\n        exc = yield a\n        # exc will be None if an exception has not occurred\n        if exc:\n            print(\"Some exception while process handling: \", exc)\n        a.close()\n```\n\n----------------------------------------\n\nTITLE: Defining Endpoint with Dependency Injection\nDESCRIPTION: Shows how to mark handler parameters for dependency injection using FromDishka type annotation in a Sanic endpoint.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@app.get('/')\nasync def endpoint(\n    request: str, gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Explicit Injection Decorator\nDESCRIPTION: Example of using the @inject decorator for explicit dependency injection in a Sanic endpoint when auto-injection is not enabled.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@app.get('/')\n@inject\nasync def endpoint(\n    gateway: FromDishka[Gateway],\n) -> ResponseModel:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Aliases with Components in Dishka\nDESCRIPTION: This brief example demonstrates how to use Dishka's alias functionality to reference types from different components without changing the original type definition.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/components.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\na = alias(int, component=\"X\")\n```\n\n----------------------------------------\n\nTITLE: Using @inject Decorator with Celery Tasks\nDESCRIPTION: Shows how to use the @inject decorator with Celery tasks when not using DishkaTask, enabling dependency injection through the FromDishka type annotation.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@celery_app.task\n@inject\ndef start( \n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Decorating Handlers with @inject for Manual Injection\nDESCRIPTION: Optionally use the @inject decorator if not using auto-injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@dp.message()\n@inject\nasync def start(\n    message: Message,\n    gateway: FromDishka[Gateway],\n):\n```\n\n----------------------------------------\n\nTITLE: Decorating Handlers with @inject for Explicit Injection\nDESCRIPTION: Optionally use the @inject decorator to explicitly mark handlers for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\n@inject\nasync def endpoint(\n    gateway: FromDishka[Gateway],\n) -> Response:\n    ...\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of @decorate in Dishka Provider\nDESCRIPTION: A basic example of using the @decorate decorator to wrap an existing object configured in another Provider. The decorated method receives the object and returns a decorated version of it.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/decorate.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import decorate, Provider\n\nclass MyProvider(Provider):\n    @decorate\n    def decorate_a(self, a: A) -> A:\n        return ADecorator(a)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Provider with Request Scope\nDESCRIPTION: Example of creating a custom provider that uses Litestar Request object in REQUEST scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Closing Container on Dispatcher Shutdown\nDESCRIPTION: Optionally register the container's close method to be called on dispatcher shutdown.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndispatcher.shutdown.register(container.close)\n```\n\n----------------------------------------\n\nTITLE: Class-based WebSocket Handler\nDESCRIPTION: Example of class-based WebSocket handler with dependency injection using inject_websocket decorator.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Handler(WebsocketListener):\n    path = \"/\"\n\n    @inject_websocket\n    async def on_receive(\n        a: FromDishka[A],  # object with Scope.SESSION\n        container: FromDishka[AsyncContainer],  # container for Scope.SESSION\n        data: dict[str, str]\n    ) -> dict[str, str]:\n        async with container() as request_container:\n            b = await request_container.get(B)  # object with Scope.REQUEST\n        return {\"key\": \"value\"}\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Provider with Request Scope\nDESCRIPTION: Demonstrates how to create a custom provider class that uses REQUEST scope and accepts Sanic Request object as a parameter.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, request: Request) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Using inject decorator with aiogram-dialog getter in Python\nDESCRIPTION: This example demonstrates how to use the @inject decorator with an aiogram-dialog getter function. It shows how to mark parameters for injection using FromDishka[].\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram_dialog.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def getter(\n    a: FromDishka[RequestDep],\n    mock: FromDishka[Mock],\n    **kwargs,\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Provide All as a Method in Python\nDESCRIPTION: This snippet shows how to use 'provide_all' as a method on a Provider instance. This approach allows for dynamic configuration of providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/provide_all.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nprovider = Provider(scope=Scope.APP)\nprovider.provide_all(ClassA, ClassB)\n```\n\n----------------------------------------\n\nTITLE: Custom Scope Implementation\nDESCRIPTION: Demonstrates how to create custom scopes by inheriting from BaseScope and defining new scope hierarchies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/scopes.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka import BaseScope, Provider, make_container, new_scope\n\nclass MyScope(BaseScope):\n    APPLICATION = new_scope(\"APPLICATION\")\n    SESSION = new_scope(\"SESSION\", skip=True)\n    EVENT = new_scope(\"EVENT\")\n\nprovider = Provider(scope=MyScope.EVENT)\nmake_container(provider, scopes=MyScope)\n```\n\n----------------------------------------\n\nTITLE: Creating Container with TaskiqProvider in Python\nDESCRIPTION: Demonstrates how to create a Dishka container that includes the TaskiqProvider, which is required when using TaskiqMessage in providers for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/taskiq.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), TaskiqProvider())\n```\n\n----------------------------------------\n\nTITLE: Injecting Dependencies into Telebot Handler Functions in Python\nDESCRIPTION: This snippet illustrates how to use the @inject decorator and FromDishka type hint to inject dependencies into a Telebot message handler function. It shows the syntax for marking parameters to be injected from the dishka container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/telebot.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@bot.message()\n@inject\ndef start(\n    message: Message,\n    gateway: FromDishka[Gateway],\n):\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka TaskIQ Integration in Python\nDESCRIPTION: Shows how to initialize the Dishka-TaskIQ integration by linking the container with the TaskIQ broker using the setup_dishka function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/taskiq.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, broker=broker)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration\nDESCRIPTION: Demonstrates how to set up the Dishka integration with Sanic application, including auto-injection configuration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, app=app, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Setting Up dishka Integration with Telebot in Python\nDESCRIPTION: This snippet demonstrates how to set up the dishka integration with a Telebot instance. It uses the setup_dishka function, passing the container and bot objects to configure the integration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/telebot.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, bot=bot)\n```\n\n----------------------------------------\n\nTITLE: Using Middleware for Dependency Injection in Python Web Apps\nDESCRIPTION: This example demonstrates using middleware to create dependencies for each request. The middleware creates services and attaches them to the request object, keeping handlers clean but potentially creating unnecessary dependencies for each request.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef service_creator(request):\n    client = Client(os.getenv(\"TOKEN\"))\n    service = Service(client)\n    request.state.service = Service(client)\n\napp.setup_middleware(service_creator)\n\n@app.get(\"/\")\ndef index(request):\n    service = request.state.service\n    service.action()\n```\n\n----------------------------------------\n\nTITLE: Entering Nested Scope with Synchronous Container in Python\nDESCRIPTION: Creates a nested container by calling the container as a function and using it as a context manager. This enters the next scope in the container hierarchy.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwith container() as nested_container:\n    pass\n```\n\n----------------------------------------\n\nTITLE: Testing FastStream with Dishka\nDESCRIPTION: Example of how to set up and run tests for a FastStream application using Dishka for dependency injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom collections.abc import AsyncIterator\n\nimport pytest\nfrom dishka import AsyncContainer, make_async_container\nfrom dishka import Provider, Scope, provide\nfrom dishka.integrations import faststream as faststream_integration\nfrom dishka.integrations.base import FromDishka as Depends\nfrom faststream import FastStream, TestApp\nfrom faststream.rabbit import RabbitBroker, TestRabbitBroker, RabbitRouter\n\nrouter = RabbitRouter()\n\n\n@router.subscriber(\"test-queue\")\nasync def handler(msg: str, some_dependency: Depends[int]) -> int:\n    print(f\"{msg=}\")\n    return some_dependency\n\n\n@pytest.fixture\nasync def broker() -> RabbitBroker:\n    broker = RabbitBroker()\n    broker.include_router(router)\n    return broker\n\n\n@pytest.fixture\ndef mock_provider() -> Provider:\n    class MockProvider(Provider):\n        @provide(scope=Scope.REQUEST)\n        async def get_some_dependency(self) -> int:\n            return 42\n\n    return MockProvider()\n\n\n@pytest.fixture\ndef container(mock_provider: Provider) -> AsyncContainer:\n    return make_async_container(mock_provider)\n\n\n@pytest.fixture\nasync def app(broker: RabbitBroker, container: AsyncContainer) -> FastStream:\n    app = FastStream(broker)\n    faststream_integration.setup_dishka(container, app, auto_inject=True)\n    return FastStream(broker)\n\n\n@pytest.fixture\nasync def client(app: FastStream) -> AsyncIterator[RabbitBroker]:\n    async with TestRabbitBroker(app.broker) as br, TestApp(app):\n        yield br\n\n\n@pytest.mark.asyncio\nasync def test_handler(client: RabbitBroker) -> None:\n    result = await client.request(\"hello\", \"test-queue\")\n    assert await result.decode() == 42\n```\n\n----------------------------------------\n\nTITLE: Importing dishka-pyTelegramBotAPI Components in Python\nDESCRIPTION: This snippet shows how to import the necessary components from dishka and its pyTelegramBotAPI integration. It includes imports for dependency injection, container creation, and Telebot-specific utilities.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/telebot.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.telebot import (\n    FromDishka,\n    inject,\n    setup_dishka,\n    TelebotProvider,\n    TelebotEvent,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Marking Handler Parameters for Dependency Injection\nDESCRIPTION: Use FromDishka[] to mark handler parameters that should be injected by Dishka.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@router.get('/')\nasync def endpoint(\n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Hierarchy of Scopes for Websocket Connections in Dishka\nDESCRIPTION: Diagram showing the hierarchical relationship between scopes in a websocket connection. For websockets, the SESSION scope sits between APP and REQUEST scopes, allowing for management of persistent connections.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/_websockets.rst#2025-04-22_snippet_0\n\nLANGUAGE: reST\nCODE:\n```\n``APP`` |rarr| ``SESSION`` |rarr| ``REQUEST``\n```\n\n----------------------------------------\n\nTITLE: Importing gRPC Integration Components\nDESCRIPTION: Imports the necessary components from dishka-grpcio integration package including inject decorator, DishkaInterceptor, and GrpcioProvider.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/grpcio.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.grpcio import (\n    inject, DishkaInterceptor, GrpcioProvider,\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Business Logic Without Dependency Injection in Python\nDESCRIPTION: This snippet demonstrates the problematic approach of creating dependencies inside methods. The Service class creates its own Client instance internally, which leads to issues with testing, configuration management, and code reuse.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/di_intro.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Service:\n    def action(self):\n        client = Client(token)\n        client.get_data()\n\nservice = Service()\nservice.action()\n```\n\n----------------------------------------\n\nTITLE: Managing REQUEST Scope with Context Managers\nDESCRIPTION: Example of entering and exiting REQUEST scope using context managers to create temporary subcontainers for handling request-scoped dependencies with proper lifecycle management.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# subcontainer to access shorter-living objects\nwith container() as request_container:\n    service = request_container.get(Service)\n    service = request_container.get(Service)  # same service instance\n# since we exited the context manager, the connection is now closed\n\n# new subcontainer to have a new lifespan for request processing\nwith container() as request_container:\n    service = request_container.get(Service)  # new service instance\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka Litestar Components\nDESCRIPTION: Import required components from dishka-litestar integration including core decorators and providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.litestar import (\n    FromDishka,\n    LitestarProvider,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka TaskIQ Integration Components in Python\nDESCRIPTION: Imports the necessary components from the dishka-taskiq integration, including FromDishka for type annotation, inject decorator, setup function, and the TaskiqProvider. Also imports core Dishka components.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/taskiq.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.taskiq import (\n    FromDishka,\n    inject,\n    setup_dishka,\n    TaskiqProvider,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Importing inject decorator for aiogram-dialog integration in Python\nDESCRIPTION: This snippet shows how to import the inject decorator from the dishka-aiogram_dialog integration. This decorator is used to mark parameters for injection in aiogram-dialog handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram_dialog.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.aiogram_dialog import inject\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-Starlette Integration Components\nDESCRIPTION: Imports necessary components from dishka-starlette integration and core dishka package to enable dependency injection with Starlette.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.starlette import (\n    DishkaRoute,\n    FromDishka,\n    StarletteProvider,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Creating Container with FastStreamProvider\nDESCRIPTION: Create a container with FastStreamProvider to enable using StreamMessage and ContextRepo in providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), FastStreamProvider())\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-Celery Integration Components\nDESCRIPTION: Shows how to import the necessary classes and functions from the dishka-celery integration module, including DishkaTask, FromDishka, inject, and setup_dishka.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.celery import (\n    DishkaTask,\n    FromDishka,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: WebSocket Handler with Session Scope\nDESCRIPTION: Example of WebSocket handler using inject_websocket decorator with session-scoped dependencies and manual request scope handling.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/litestar.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@websocket_listener(\"/\")\n@inject_websocket\nasync def get_with_request(\n    a: FromDishka[A],  # object with Scope.SESSION\n    container: FromDishka[AsyncContainer],  # container for Scope.SESSION\n    data: dict[str, str]\n) -> dict[str, str]:\n    # enter the nested scope, which is Scope.REQUEST\n    async with container() as request_container:\n        b = await request_container.get(B)  # object with Scope.REQUEST\n    return {\"key\": \"value\"}\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-ARQ Integration Components in Python\nDESCRIPTION: This snippet shows how to import the necessary components from the dishka.integrations.arq module for integrating Dishka with ARQ.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/arq.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.arq import (\n    FromDishka,\n    inject,\n    setup_dishka,\n)\n```\n\n----------------------------------------\n\nTITLE: Invalid Provider Attribute Override Example\nDESCRIPTION: Shows an example of incorrectly overriding reserved Provider attributes.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/provider/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass MyProvider(Provider):\n    scope = ...\n\n    factories = provide(SomeClass)  # ERROR\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-Sanic Integration Components\nDESCRIPTION: Shows how to import necessary components from dishka-sanic integration, including core functionality for dependency injection and Sanic integration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.sanic import (\n    FromDishka,\n    SanicProvider,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Installing Dishka via pip\nDESCRIPTION: Command to install the Dishka dependency injection library using pip package manager.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/quickstart.rst#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install dishka\n```\n\n----------------------------------------\n\nTITLE: Application Architecture Diagram (ASCII)\nDESCRIPTION: ASCII diagram showing the relationships between different components of the application including warehouse client, database connections, gateways, and interactors.\nSOURCE: https://github.com/reagento/dishka/blob/develop/examples/real_world/README.md#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n   ┌────────────────┐\n   │Warehouse client├────────────────────►─────┐\n   └────────────────┘                          │\n                       ┌────────────┐          │\n                 ┌─────►Unit of work├────►─────┤\n                 │     └────────────┘          │\n                 │                            ┌▼─────────┐\n   ┌─────────────┴──┐  ┌─────────────┐        │Interactor│\n   │DB Connection   ├──►Users gateway├───────►└▲─────────┘\n   └─────────────┬──┘  └─────────────┘         │\n                 │                             │\n                 │     ┌─────────────────┐     │\n                 └─────►Products gateway ├─►───┘\n                       └─────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Installing Dishka Package via pip\nDESCRIPTION: Command to install the Dishka dependency injection framework using pip package manager.\nSOURCE: https://github.com/reagento/dishka/blob/develop/README.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install dishka\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider with TelebotEvent in Python\nDESCRIPTION: This code demonstrates how to create a custom provider class that uses the TelebotEvent as a factory parameter for REQUEST-scoped dependencies. It shows the structure of a provider method that can access event data.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/telebot.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, event: TelebotEvent) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies with Specific Versions\nDESCRIPTION: A requirements.txt file that lists three Python packages with their exact versions. The dependencies include FastAPI 0.115.6 for building APIs, Aiogram 3.16.0 for Telegram bot development, and Uvicorn 0.34.0 as an ASGI server.\nSOURCE: https://github.com/reagento/dishka/blob/develop/examples/real_world/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nfastapi==0.115.6\naiogram==3.16.0\nuvicorn==0.34.0\n```\n\n----------------------------------------\n\nTITLE: Setting up Python Virtual Environment\nDESCRIPTION: Commands to create and activate a Python virtual environment for development\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv .venv\nsource .venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration with Aiogram\nDESCRIPTION: Configure the Dishka integration with Aiogram, enabling auto-injection for handlers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, router=dp, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Installing Development Dependencies\nDESCRIPTION: Commands to install development requirements and the project in editable mode\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements_dev.txt\nuv pip install -e .\n```\n\n----------------------------------------\n\nTITLE: Running Ruff Code Linter\nDESCRIPTION: Command to run the Ruff linter for code quality checks\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nruff check\n```\n\n----------------------------------------\n\nTITLE: Creating Async Container with FastAPI Provider\nDESCRIPTION: Initialize an async container with custom providers and FastapiProvider for FastAPI integration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/fastapi.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), FastapiProvider())\n```\n\n----------------------------------------\n\nTITLE: Running Integration Tests for Specific Library\nDESCRIPTION: Command to run integration tests for a specific library version\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nnox -t aiohttp\n```\n\n----------------------------------------\n\nTITLE: Building Documentation with Make\nDESCRIPTION: Command to compile the Sphinx documentation\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmake html\n```\n\n----------------------------------------\n\nTITLE: Applying inject decorator to aiogram-dialog event handler in Python\nDESCRIPTION: This snippet illustrates the use of the @inject decorator with an aiogram-dialog event handler (on_click). It shows how to mark multiple parameters for injection using FromDishka[].\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram_dialog.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@inject\nasync def on_click(\n    event,\n    widget,\n    manager,\n    a: FromDishka[RequestDep],\n    mock: FromDishka[Mock],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies in Requirements File\nDESCRIPTION: Lists required Python packages and references test.txt file using -r flag for including additional requirements.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/taskiq-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\ntaskiq\n```\n\n----------------------------------------\n\nTITLE: Specifying Dishka Project Dependencies in Python\nDESCRIPTION: This snippet lists the project dependencies for Dishka. It includes a reference to an external test.txt file for additional requirements and specifies Celery version 5.4.0 as a direct dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/celery-540.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\ncelery==5.4.0\n```\n\n----------------------------------------\n\nTITLE: Creating Container with SanicProvider\nDESCRIPTION: Shows how to create a container with SanicProvider for handling Sanic Request objects in providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/sanic.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), SanicProvider())\n```\n\n----------------------------------------\n\nTITLE: Defining gRPC Python Dependencies\nDESCRIPTION: Lists required gRPC dependencies including core library, tools for code generation, and testing utilities. Uses pip requirements file format to specify exact packages needed.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/grpcio-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n-r test.txt\ngrpcio\ngrpcio-tools\ngrpcio-testing\n```\n\n----------------------------------------\n\nTITLE: Python Dependencies List\nDESCRIPTION: Lists project dependencies including a reference to test.txt requirements file and the celery package for distributed task processing.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/celery-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\ncelery\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Nox\nDESCRIPTION: Commands for running various test suites using Nox test automation\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnox\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Integration with ARQ WorkerSettings in Python\nDESCRIPTION: This snippet shows how to set up the Dishka integration with ARQ WorkerSettings using the setup_dishka function.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/arq.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsetup_dishka(container=container, worker_settings=WorkerSettings)\n```\n\n----------------------------------------\n\nTITLE: Specifying FastAPI Dependency with Version Pinning in Requirements File\nDESCRIPTION: This requirements file includes another requirements file named 'asgi.txt' and pins the FastAPI framework to version 0.109.0. It uses pip's requirements syntax for dependency management in Python projects.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/fastapi-0109.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r asgi.txt\nfastapi==0.109.0\n```\n\n----------------------------------------\n\nTITLE: Setting Up Dishka Container with Click Context\nDESCRIPTION: Demonstrates how to create and configure a Dishka container within a Click group handler. The setup includes connecting the container to Click's context with optional automatic injection.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/click.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@click.group()\n@click.pass_context\ndef main(context: click.Context):\n    container = make_container(MyProvider())\n    setup_dishka(container=container, context=context, auto_inject=True)\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies with FastStream NATS\nDESCRIPTION: Requirements file specifying dependencies including FastStream with NATS integration and test requirements from test.txt\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/faststream-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\n\nfaststream[nats]\n```\n\n----------------------------------------\n\nTITLE: Configuring Mock Objects with Pytest Fixtures for Dishka in Python\nDESCRIPTION: This snippet illustrates how to set up pytest fixtures to configure mock objects for use with Dishka. It demonstrates creating providers with mock objects that can be used in tests.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/advanced/testing/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# fixtures.py content would go here, but it's not provided in the input\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies for Dishka Project\nDESCRIPTION: This snippet defines the required Python packages for the Dishka project. It includes a reference to an ASGI-specific requirements file and specifies the Litestar framework version.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/litestar-230.txt#2025-04-22_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\n-r asgi.txt\nlitestar==2.3.0\n```\n\n----------------------------------------\n\nTITLE: Creating a TaskIQ-aware Provider in Python\nDESCRIPTION: Demonstrates how to create a Provider class that can access the TaskiqMessage as a factory parameter within the REQUEST scope. This allows providers to access task-specific data.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/taskiq.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, event: TaskiqMessage) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies from Requirements File\nDESCRIPTION: Requirements file that specifies project dependencies, including a reference to asgi.txt and the starlette package. Uses pip's -r flag to include another requirements file.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/starlette-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r asgi.txt\nstarlette\n```\n\n----------------------------------------\n\nTITLE: Creating an Async Container with StarletteProvider\nDESCRIPTION: Creates an async container with StarletteProvider to enable the injection of Starlette Request or WebSocket objects into providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/starlette.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), StarletteProvider())\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Requirements file that includes test dependencies from test.txt and the aiogram package for building Telegram bots\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiogram-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\naiogram\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Provider for Aiogram Integration\nDESCRIPTION: Define a custom provider class that can access TelegramObject and AiogramMiddlewareData in the REQUEST scope.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass YourProvider(Provider):\n    @provide(scope=Scope.REQUEST)\n    def create_x(self, event: TelegramObject, middleware_data: AiogramMiddlewareData) -> X:\n         ...\n```\n\n----------------------------------------\n\nTITLE: Including Python Project Dependencies\nDESCRIPTION: This code specifies dependencies for a Python project by referencing a requirements file (test.txt) and explicitly listing the aiogram_dialog package.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiogram-dialog-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\naiogram_dialog\n```\n\n----------------------------------------\n\nTITLE: Creating a Container with TelebotProvider in Python\nDESCRIPTION: This code shows how to create an asynchronous container using make_async_container, including both a custom provider and the TelebotProvider. This setup is necessary when using TelebotEvent in providers.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/telebot.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncontainer = make_async_container(YourProvider(), TelebotProvider())\n```\n\n----------------------------------------\n\nTITLE: Listing Dependencies in Requirements Format\nDESCRIPTION: A requirements file entry specifying the test.txt file with -r flag and click package\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/click-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\nclick\n```\n\n----------------------------------------\n\nTITLE: Closing a Synchronous Container in Python\nDESCRIPTION: Shows how to properly close an APP-level container which is not a context manager. This should be called on application termination to clean up resources.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/container/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncontainer.close()\n```\n\n----------------------------------------\n\nTITLE: Command Handler with Explicit Injection Decorator\nDESCRIPTION: Demonstrates using the @inject decorator explicitly with FromDishka type annotation in a Click command handler.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/click.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@main.command(name=\"hello\")\n@inject\ndef hello(interactor: FromDishka[Interactor]):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Using Explicit Injection Decorator in FastStream Handler\nDESCRIPTION: Apply the @inject decorator for explicit dependency injection in a FastStream message handler.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@broker.subscriber(\"test\")\n@inject\nasync def start(\n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Running MyPy Type Checker\nDESCRIPTION: Command to run MyPy for static type checking\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nmypy\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Project Dependencies\nDESCRIPTION: This snippet defines the dependencies for a Python project. It includes a reference to an external test.txt file for additional requirements and explicitly lists Flask as a dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/flask-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\n-r test.txt\nFlask\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-Flask Integration Components\nDESCRIPTION: Import necessary classes and functions from dishka-flask integration and dishka core for setting up the integration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/flask.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.flask import (\n    FlaskProvider,\n    FromDishka,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Specifying Flask Dependency in Requirements File\nDESCRIPTION: This snippet defines the project dependencies. It includes a reference to another requirements file (test.txt) and specifies Flask version 3.0.2 as a required package.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/flask-302.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\nFlask==3.0.2\n```\n\n----------------------------------------\n\nTITLE: Using FromDishka Type Annotation for Dependency Injection\nDESCRIPTION: Demonstrates how to mark task parameters for dependency injection using the FromDishka type annotation, which tells Dishka to resolve the dependency from the container.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/celery.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@celery_app.task\ndef start( \n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Requirements file that includes another requirements file via -r flag and specifies arq package version 0.25.0.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/arq-0250.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\narq==0.25.0\n```\n\n----------------------------------------\n\nTITLE: Marking Handler Parameters for Dependency Injection\nDESCRIPTION: Use FromDishka[] to mark handler parameters that should be injected by Dishka.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@dp.message()\nasync def start(\n    message: Message,\n    gateway: FromDishka[Gateway],\n):\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: Requirements file that references an external test.txt file and pins the taskiq package to version 0.11.0.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/taskiq-0110.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\ntaskiq==0.11.0\n```\n\n----------------------------------------\n\nTITLE: Basic Command Handler with Dependency Injection\nDESCRIPTION: Shows how to define a Click command handler with dependency injection using FromDishka type annotation.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/click.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@main.command(name=\"hello\")\ndef hello(interactor: FromDishka[Interactor]):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies in Requirements File\nDESCRIPTION: This snippet lists the required Python packages and their versions for the Dishka project. It includes FastStream with NATS support (version 0.5.0rc2), typing extensions (version 4.11.0), and anyio (version 4.6.2). The file also references another requirements file named 'test.txt'.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/faststream-050.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\n\nfaststream[nats]==0.5.0rc2\ntyping-extensions==4.11.0\nanyio==4.6.2\n```\n\n----------------------------------------\n\nTITLE: Marking Parameters for Injection in FastStream Handler\nDESCRIPTION: Use FromDishka to mark parameters that should be injected in a FastStream message handler.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@broker.subscriber(\"test\")\nasync def start(\n    gateway: FromDishka[Gateway],\n):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Development Dependencies\nDESCRIPTION: This snippet defines the required versions for development tools used in the project. It includes Ruff for linting, Nox for automation, uv for package management, and mypy for static type checking.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements_dev.txt#2025-04-22_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\nruff==0.10.*\nnox==2024.10.*\nuv==0.5.*\nmypy==1.15.*\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: This snippet lists Python package dependencies. It includes a reference to another requirements file (test.txt) and specifies version 3.9.3 of the aiohttp package.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiohttp-393.txt#2025-04-22_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r test.txt\naiohttp==3.9.3\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka-Aiogram Integration Modules\nDESCRIPTION: Import necessary classes and functions from dishka and its aiogram integration to set up the integration.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/aiogram.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.aiogram import (\n    AiogramProvider,\n    FromDishka,\n    inject,\n    setup_dishka,\n)\nfrom dishka import make_async_container, Provider, provide, Scope\n```\n\n----------------------------------------\n\nTITLE: Installing Sphinx Documentation Dependencies\nDESCRIPTION: Lists required Python packages for Sphinx documentation generation including the core Sphinx package, copy button extension, autodoc generator, and Furo theme. All dependencies use version pinning to ensure compatibility.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements_doc.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nsphinx==8.1.*\nsphinx_copybutton==0.5.*\nsphinx-autodocgen==1.3\nfuro==2024.8.*\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Dependencies\nDESCRIPTION: This snippet defines the project dependencies. It includes a reference to another requirements file and specifies the PyTelegramBotAPI library as a direct dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/telebot-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: Plain Text\nCODE:\n```\n-r test.txt\npytelegrambotapi\n```\n\n----------------------------------------\n\nTITLE: Importing Dishka Click Integration\nDESCRIPTION: Shows how to import the necessary components from dishka-click integration module.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/click.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom dishka.integrations.click import setup_dishka, inject\n```\n\n----------------------------------------\n\nTITLE: Defining Python Test Dependencies with Version Constraints\nDESCRIPTION: Specifies the required testing packages including pytest and its plugins with version constraints. Uses the wildcard syntax to allow minor version updates while maintaining compatibility.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/test.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\npytest==8.*\npytest-asyncio==0.24.*\npytest-repeat==0.9.*\npytest-cov==5.0.*\n```\n\n----------------------------------------\n\nTITLE: Python Package Requirements\nDESCRIPTION: Requirements file that specifies the pytelegrambotapi package version 4.15.4 and references another requirements file test.txt.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/telebot-415.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\npytelegrambotapi==4.15.4\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies\nDESCRIPTION: A requirements file that lists Python package dependencies with their version constraints. References another requirements file (test.txt) and specifies exact version ranges for httpx and asgi_lifespan packages.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/asgi.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\n\nhttpx==0.27.*\nasgi_lifespan==2.1.*\n```\n\n----------------------------------------\n\nTITLE: Defining Python Package Dependencies\nDESCRIPTION: Requirements file (-r) referencing asgi.txt and specifying litestar as a dependency. Uses pip requirements file format.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/litestar-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r asgi.txt\nlitestar\n```\n\n----------------------------------------\n\nTITLE: Specifying gRPC Dependencies for Python Project\nDESCRIPTION: This snippet lists the required gRPC-related packages and their versions for the Dishka project. It includes the core gRPC library, tools for working with gRPC, and testing utilities.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/grpcio-1641.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\ngrpcio==1.64.1\ngrpcio-tools==1.64.1\ngrpcio-testing==1.64.1\n```\n\n----------------------------------------\n\nTITLE: Installing gRPC Dependencies via Requirements File\nDESCRIPTION: Specifies required gRPC Python packages and their versions. Includes core gRPC library, tools for code generation, and testing utilities all pinned to version 1.68.0. References another requirements file test.txt.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/grpcio-1680.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n-r test.txt\ngrpcio==1.68.0\ngrpcio-tools==1.68.0\ngrpcio-testing==1.68.0\n```\n\n----------------------------------------\n\nTITLE: Specifying FastAPI Dependency in Requirements File\nDESCRIPTION: This snippet defines the required version of FastAPI for the project. It also includes a reference to another requirements file named 'asgi.txt'.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/fastapi-0096.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r asgi.txt\nfastapi==0.96.0\n```\n\n----------------------------------------\n\nTITLE: Defining Dependencies for ASGI-based FastAPI Project\nDESCRIPTION: Requirements file that includes references to ASGI requirements and explicitly declares FastAPI as a dependency. Uses the -r flag to include external requirements file.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/fastapi-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r asgi.txt\nfastapi\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Dishka Project\nDESCRIPTION: This snippet defines the dependencies for the Dishka project. It includes a reference to another requirements file (test.txt) and specifies the aiohttp library as a direct dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiohttp-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\naiohttp\n```\n\n----------------------------------------\n\nTITLE: Defining Python Project Dependencies with pip Requirements File\nDESCRIPTION: A pip requirements file that includes another requirements file (test.txt) and specifies the Click package with version 8.1.7. The '-r' flag indicates that test.txt should be read and its contents included as dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/click-817.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\nclick==8.1.7\n```\n\n----------------------------------------\n\nTITLE: Specifying Starlette Dependency in Plaintext\nDESCRIPTION: This snippet defines a dependency on Starlette version 0.27.0 for the Dishka project. It uses a requirements file format, typically used with pip for Python package management.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/starlette-0270.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r asgi.txt\nstarlette==0.27.0\n```\n\n----------------------------------------\n\nTITLE: Installing Python Dependencies from Requirements File\nDESCRIPTION: Requirements file that references another requirements file (test.txt) and specifies aiogram version 3.14.0 as a dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiogram-3140.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\naiogram==3.14.0\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Dishka Project in Plain Text\nDESCRIPTION: This snippet lists the required dependencies for the Dishka project. It includes a reference to another file 'test.txt' and specifies the aiogram_dialog library version 2.1.0.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiogram-dialog-210.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\naiogram_dialog==2.1.0\n```\n\n----------------------------------------\n\nTITLE: Specifying Development Dependencies for Dishka Project using pip\nDESCRIPTION: This pip requirements file lists the development dependencies for the Dishka project. It includes pytest and its plugins for testing, httpx for HTTP requests, and asgi_lifespan for ASGI application management. The file uses version specifiers to ensure compatibility.\nSOURCE: https://github.com/reagento/dishka/blob/develop/examples/real_world/requirements_test.txt#2025-04-22_snippet_0\n\nLANGUAGE: pip\nCODE:\n```\n-r requirements.txt\n\npytest==7.*\npytest-asyncio==0.23.*\npytest-repeat==0.9.*\npytest-cov==4.1.0\n\nhttpx==0.26.*\nasgi_lifespan==2.1.*\n```\n\n----------------------------------------\n\nTITLE: Specifying Dependencies for Dishka Project\nDESCRIPTION: This snippet defines the project dependencies. It includes a reference to another requirements file (test.txt) and specifies the 'arq' package as a dependency.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/arq-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r test.txt\narq\n```\n\n----------------------------------------\n\nTITLE: Python Requirements Specification\nDESCRIPTION: Lists required Python packages and their versions, including a reference to test.txt and the aiogram library version 3.3.0\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/aiogram-330.txt#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n-r test.txt\naiogram==3.3.0\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Sanic Project\nDESCRIPTION: This snippet lists the required Python packages for a Sanic-based project. It includes Sanic for the web framework, sanic-testing for testing utilities, and a specific version of setuptools for build dependencies.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/sanic-latest.txt#2025-04-22_snippet_0\n\nLANGUAGE: Text\nCODE:\n```\n-r asgi.txt\nsanic\nsanic-testing\nsetuptools>=69.5.1\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Sanic Project\nDESCRIPTION: This snippet lists the required Python packages and their versions for a Sanic-based project. It includes Sanic 23.12.1 for the web framework, Sanic-testing 23.12.0 for testing utilities, and setuptools 69.5.1 for package management.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/sanic-23121.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n-r asgi.txt\nsanic==23.12.1\nsanic-testing==23.12.0\nsetuptools==69.5.1\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies with Version Requirements\nDESCRIPTION: This requirements file includes another requirements file (test.txt) and lists three specific Python packages with exact version numbers. It includes FastStream with NATS integration version 0.4.7, typing-extensions version 4.11.0, and anyio version 4.6.2.\nSOURCE: https://github.com/reagento/dishka/blob/develop/requirements/faststream-047.txt#2025-04-22_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n-r test.txt\n\nfaststream[nats]==0.4.7\ntyping-extensions==4.11.0\nanyio==4.6.2\n```\n\n----------------------------------------\n\nTITLE: Running RabbitMQ Container for FastStream\nDESCRIPTION: Docker command to run a RabbitMQ container for use with FastStream examples.\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/integrations/faststream.rst#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\ndocker run -d --name rabbitmq \\\n  -p 5672:5672 -p 15672:15672 \\\n  -e RABBITMQ_DEFAULT_USER=guest \\\n  -e RABBITMQ_DEFAULT_PASS=guest \\\n  rabbitmq:management\n```\n\n----------------------------------------\n\nTITLE: Installing Documentation Dependencies\nDESCRIPTION: Command to install requirements for building documentation\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements_doc.txt\n```\n\n----------------------------------------\n\nTITLE: Running Latest Version Integration Tests\nDESCRIPTION: Command to run integration tests with the latest version of a library\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnox -s aiohttp_latest\n```\n\n----------------------------------------\n\nTITLE: Cloning Dishka Repository\nDESCRIPTION: Instructions for cloning the Dishka project repository from GitHub\nSOURCE: https://github.com/reagento/dishka/blob/develop/docs/contributing.rst#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:reagento/dishka.git\ncd dishka\n```"
  }
]