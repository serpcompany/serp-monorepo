[
  {
    "owner": "redhawksdr",
    "repo": "core-framework",
    "content": "TITLE: Implementing ServiceFunction for Transforming Component in REDHAWK SDR (C++)\nDESCRIPTION: This code demonstrates the service function implementation for a component that transforms input data streams to output data streams. It shows how to read from input ports, handle stream creation, process data with an algorithm, and write to output ports, while properly managing SRI changes and EOS conditions.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-examples.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nint FmDemod_i::serviceFunction()\n{\n    // InFloatPort::getCurrentStream() returns the first input stream that has data available to be read,\n    // blocking if none are currently ready.\n    bulkio::InFloatStream input = dataFloat_in->getCurrentStream();\n    if (!input) {\n        // No streams are available (typically due to a stop).\n        return NOOP;\n    }\n\n    // If an output stream has already been created, OutFloatPort::getStream() finds it by streamID.\n    bulkio::OutFloatStream output = dataFloat_out->getStream(input.s\n treamID());\n    if (!output) {\n        // Otherwise, create a new stream.\n        output = dataFloat_out->createStream(input.streamID());\n        // configureStream() is a user-defined method to apply any transformations from the input SRI to the\n        // output SRI\n        configureStream(output, input.sri());\n    }\n\n    // Blocking read from the input stream. The default behavior returns exactly one packet worth of data,\n    // but a sample count and consume length (for overlap) can be provided as well.\n    bulkio::FloatDataBlock block = input.read();\n    if (!block) {\n        // There are two reasons why InFloatStream::read() might return a \"null\" block:\n        if (input.eos()) {\n            // 1. End-of-stream; close the output stream.\n            LOG_DEBUG(FmDemod_i, \"Stream \" << input.streamID() << \" got an EOS\");\n            output.close();\n            return NORMAL;\n        } else {\n            // 2. The component was stopped.\n            return NOOP;\n        }\n    }\n\n    // Handle an input queue flush. Depending on your algorithm, this may require resetting state, etc.\n    if (block.inputQueueFlushed()) {\n        LOG_WARN(FmDemod_i, \"Input queue flushed\");\n    }\n\n    // Handle SRI changes. The configureStream() method is also used on output stream creation; the SRI change flag\n    // is not set for a new stream.\n    // Optionally, FloatDataBlock::sriChangeFlags() returns a set of bit flags to check which parts of the SRI changed,\n    // if only certain fields are relevant.\n    if (block.sriChanged()) {\n        LOG_INFO(FmDemod_i, \"SRI changed\");\n        configureStream(output, block.sri());\n    }\n\n    // Update any internal variables or properties. This a user-defined method, and the behavior is up to the\n    // implementer. In this case, the algorithm depends on the sample rate of the input SRI.\n    updateParameters(block.sri());\n\n    // Run the algorithm here (FM demodulation, in this case), taking into account whether the input is complex or\n    // real. In this example, the output is always real regardless of the input, but this can differ on a per-component\n    // basis. The actual work is done in a private templatized member function, doFmDemod().\n    redhawk::buffer<float> buffer;\n    if (block.complex()) {\n        buffer = doFmDemod(block.cxbuffer());\n    } else {\n        buffer = doFmDemod(block.buffer());\n    }\n\n    // Write the processed data to the output stream. After calling OutFloatStream::write(), the buffer is now shared\n    // with an unknown number of consumers. No more modifications should be made.\n    // Regarding the BULKIO::PrecisionUTCTime, a block can contain multiple timestamps, if you explicitly request\n    // a read size; here, we are just taking the data in the block sizes it comes in, so we can just use the starting\n    // timestamp for the entire block. Algorithms that affect the time basis should compute a new block time.\n    output.write(buffer, block.getStartTime());\n    return NORMAL;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing ServiceFunction for Generative Component in REDHAWK SDR (C++)\nDESCRIPTION: This code demonstrates a service function implementation for a component that generates output data without requiring input. It shows how to create output streams, generate waveform data, and handle stream configuration and timestamp management for continuous output generation.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-examples.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint Waveform_i::serviceFunction()\n{\n    // Update any internal variables or properties. This a user-defined method, and the behavior is up to the\n    // implementer. In this case, the waveform parameters could be copied from properties to shadow variables\n    // while holding the properties lock (propertySetAccess).\n    updateParameters();\n\n    // For this example, the output stream is a member variable on the Waveform_i class. If it's not already\n    // created, do it here. Another option would be to create it inthe constructor() method.\n    if (!_outputStream) {\n        _outputStream = dataFloat_out->createStream(_streamID);\n        _sriChanged = true;\n    }\n\n    // If the SRI needs to be updated, based on the properties (or some other reason), one option is to set an\n    // internal flag; another possibility might be to update the SRI in updateParameters()--if the stream is only\n    // used from within serviceFunction(), there are no threading concerns.\n    // configureStream() is a user-defined method to apply any changes to the output stream SRI.\n    if (_sriChanged) {\n        configureStream(_outputStream);\n    }\n\n    // Create a buffer of the desired size. The redhawk::buffer class is the mutable version, and it gracefullly\n    // \"degrades\" to the immutable redhawk::shared_buffer class.\n    redhawk::buffer<float> data(1024);\n\n    // The implementation of the generator function is left as an exercise to the reader.\n    doWaveform(data.begin(), data.end());\n\n    // This example keeps a running BULKIO::PrecisionUTCTime for the first sample of each block. There are overloaded\n    // arithmetic operators to make it easier to modify.\n    _currentTimestamp += _outputStream.xdelta() * data.size();\n\n    // After calling OutFloatStream::write(), the buffer is now shared with an unknown number of consumers. No more\n    // modifications should be made.\n    _outputStream.write(data, _currentTimestamp);\n\n    return NORMAL;\n}\n```\n\n----------------------------------------\n\nTITLE: Reading from BulkIO Input Stream in C++\nDESCRIPTION: Illustrates how to read data from a BulkIO input stream using shared buffers in REDHAWK. It demonstrates handling both scalar and complex data types efficiently.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_2\n\nLANGUAGE: C++\nCODE:\n```\nbulkio::InFloatStream stream = dataFloat_in->getCurrentStream();\n    if (!stream) {\n        return NOOP;\n    }\n\n    bulkio::FloatDataBlock block = stream.read();\n    if (!block) {\n        return NOOP;\n    }\n\n    if (block.complex()) {\n        redhawk::shared_buffer<std::complex<float> > buffer = block.cxbuffer();\n        std::complex<float> sum = std::accumulate(buffer.begin(), buffer.end(), std::complex<float>(0.0, 0.0));\n    } else {\n        redhawk::shared_buffer<float> buffer = block.buffer();\n        float sum = std::accumulate(buffer.begin(), buffer.end(), 0.0);\n    }\n\n    return NORMAL;\n```\n\n----------------------------------------\n\nTITLE: Creating and Writing to a Shared Buffer in C++\nDESCRIPTION: Demonstrates how to create a writeable shared buffer, populate it with data, and write it to a BulkIO output stream. This approach allows for efficient memory sharing in REDHAWK components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\nredhawk::buffer<float> buffer(1024);\n    for (size_t ii = 0; ii < buffer.size(); ++ii) {\n        buffer[ii] = (float) ii;\n    }\nstream.write(buffer, bulkio::time::utils::now());\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom BulkIO Transport for FPGA Components in C++\nDESCRIPTION: This code snippet demonstrates how to create a custom transport for BulkIO in REDHAWK. It includes the implementation of transport factory, manager, and negotiation process for both input and output ports. The example uses a priority system to ensure the custom transport is selected over default options.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n// Custom Transport Factory\nclass CustomTransportFactory : public virtual POA_ExtendedCF::TransportFactory,\n                              public virtual PortableServer::RefCountServantBase\n{\npublic:\n    CustomTransportFactory() {}\n    ~CustomTransportFactory() {}\n\n    char* getName() throw (CORBA::SystemException) {\n        return CORBA::string_dup(\"custom\");\n    }\n\n    CORBA::Long getPriority() throw (CORBA::SystemException) {\n        return 0;\n    }\n\n    ExtendedCF::TransportManager_ptr getTransportManager(const char* transportType)\n        throw (CORBA::SystemException)\n    {\n        return new CustomTransportManager();\n    }\n};\n\n// Custom Transport Manager\nclass CustomTransportManager : public virtual POA_ExtendedCF::TransportManager,\n                               public virtual PortableServer::RefCountServantBase\n{\npublic:\n    CustomTransportManager() {}\n    ~CustomTransportManager() {}\n\n    ExtendedCF::TransportInfo* createInputTransport(const ExtendedCF::TransportInfo& transportInfo,\n                                                    const ExtendedCF::TransportInfoSequence& transportSpecs)\n        throw (CORBA::SystemException)\n    {\n        LOG_DEBUG(CustomTransportManager, \"createInputTransport\");\n        ExtendedCF::TransportInfo_var info = new ExtendedCF::TransportInfo();\n        info->transport_type = CORBA::string_dup(\"custom\");\n        info->transport_info.length(1);\n        info->transport_info[0].id = CORBA::string_dup(\"custom_prop\");\n        info->transport_info[0].value <<= \"custom_value\";\n        return info._retn();\n    }\n\n    ExtendedCF::TransportInfo* createOutputTransport(const ExtendedCF::TransportInfoSequence& transportSpecs)\n        throw (CORBA::SystemException)\n    {\n        LOG_DEBUG(CustomTransportManager, \"createOutputTransport\");\n        ExtendedCF::TransportInfo_var info = new ExtendedCF::TransportInfo();\n        info->transport_type = CORBA::string_dup(\"custom\");\n        info->transport_info.length(1);\n        info->transport_info[0].id = CORBA::string_dup(\"custom_prop\");\n        info->transport_info[0].value <<= \"custom_value\";\n        return info._retn();\n    }\n};\n\n// In the component constructor\nCustomTransportFactory* factory = new CustomTransportFactory();\nExtendedCF::TransportFactory_var factoryVar = factory->_this();\nRH_NL_TRACE(\"CustomTransport\", \"Registering custom transport factory\");\nredhawk::TransportRegistry::registerFactory(factoryVar);\n\n// In the dataFloat_out port implementation\nvoid dataFloat_out_i::getNegotiationProperties(ExtendedCF::TransportInfoSequence& transportSpecs)\n{\n    LOG_DEBUG(dataFloat_out_i, \"getNegotiationProperties\");\n    transportSpecs.length(1);\n    transportSpecs[0].transport_type = CORBA::string_dup(\"custom\");\n    transportSpecs[0].transport_info.length(1);\n    transportSpecs[0].transport_info[0].id = CORBA::string_dup(\"custom_prop\");\n    transportSpecs[0].transport_info[0].value <<= \"custom_value\";\n}\n\nvoid dataFloat_out_i::setNegotiationResult(const ExtendedCF::TransportInfo& transportInfo)\n{\n    LOG_DEBUG(dataFloat_out_i, \"setNegotiationResult\");\n    // Handle negotiation result\n}\n\n// In the dataFloat_in port implementation\nvoid dataFloat_in_i::getNegotiationProperties(ExtendedCF::TransportInfoSequence& transportSpecs)\n{\n    LOG_DEBUG(dataFloat_in_i, \"getNegotiationProperties\");\n    transportSpecs.length(1);\n    transportSpecs[0].transport_type = CORBA::string_dup(\"custom\");\n    transportSpecs[0].transport_info.length(1);\n    transportSpecs[0].transport_info[0].id = CORBA::string_dup(\"custom_prop\");\n    transportSpecs[0].transport_info[0].value <<= \"custom_value\";\n}\n```\n\n----------------------------------------\n\nTITLE: Using redhawk::buffer Template Class for Shared Memory in REDHAWK\nDESCRIPTION: Shows the template class that acquires memory from a process-shared heap to enable efficient shared memory transfers between processes. This class automatically handles the details of shared memory allocation, allowing components to focus on their core functionality.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/shared-memory-ipc.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\nredhawk::buffer<T>\n```\n\n----------------------------------------\n\nTITLE: Implementing FM Demodulation Algorithm for REDHAWK SDR Component (C++)\nDESCRIPTION: This code shows a templated implementation of an FM demodulation algorithm for use in the FmDemod component. It processes both real and complex input data and returns a buffer of demodulated float data using the dsp::process method for signal processing.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-examples.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\ntemplate <class T>\nredhawk::shared_buffer<float> FmDemod_i::doFmDemod(const redhawk::shared_buffer<T>& input)\n{\n    redhawk::buffer<float> output(input.size());\n    dsp::process(input.begin(), input.end(), output.begin(), demod);\n    return output;\n}\n```\n\n----------------------------------------\n\nTITLE: Keeping History of Shared Buffer in C++\nDESCRIPTION: Shows how to create a read-only copy of a shared buffer for maintaining history in REDHAWK components. This is useful when algorithms require access to previous data.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\nredhawk::shared_buffer<float> history = buffer;\n```\n\n----------------------------------------\n\nTITLE: Resource Implementation Start Function in C++\nDESCRIPTION: Core library function that handles component initialization and execution, called from the main() function in traditional components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-model.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nResource_impl::start_component()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Transport Class Declarations in Component Headers\nDESCRIPTION: Class declarations for custom transport implementation including InputTransport, OutputTransport, InputManager, OutputManager, and TransportFactory classes that handle BULKIO data transport for a component.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n     #include <ossie/debug.h>\n     #include <ossie/ProvidesPort.h>\n     #include <ossie/UsesPort.h>\n     #include <BulkioTransport.h>\n\n\n    // class implementing the custom input transport\n    class CustomInputTransport : public bulkio::InputTransport<BULKIO::dataFloat>\n    {\n    public:\n\n        CustomInputTransport(bulkio::InPort<BULKIO::dataFloat>* port,\n                             const std::string& transportId,\n                             const redhawk::PropertyMap &usesTransportProps )\n          : bulkio::InputTransport<BULKIO::dataFloat>(port, transportId) {\n\n          // save off source end point description\n          _usesTransportProps = usesTransportProps;\n        };\n\n        virtual ~CustomInputTransport() {\n           RH_NL_INFO(\"custom.transport\", \"CustomInputTransport::~CustomInputTransport\" );\n        }\n\n        std::string transportType() const {\n             return \"custom\";\n        };\n\n        redhawk::PropertyMap    getNegotiationProperties();\n\n        /**\n          Control interface used by port when a connectPort occurs to start the transport after the negotiation has completed.\n         */\n        void startTransport() {\n           RH_NL_INFO(\"custom.transport\", \"CustomInputTransport::startTransport\");\n        };\n\n        /**\n          Control interface used by port when a disconnectPort occurs to stop the transport.\n         */\n        void stopTransport() {\n           RH_NL_INFO(\"custom.transport\", \"CustomInputTransport::stopTransport\");\n        };\n\n        protected:\n          //  provides transport layer statistics to port\n          redhawk::PropertyMap  _getExtendedStatistics() {\n              return redhawk::PropertyMap();\n          }\n\n        private:\n           redhawk::PropertyMap     _usesTransportProps;\n    };\n\n    // class implementing the custom output transport\n    class CustomOutputTransport : public bulkio::OutputTransport<BULKIO::dataFloat>\n    {\n    public:\n\n        CustomOutputTransport(bulkio::OutPort<BULKIO::dataFloat>* parent,\n                              BULKIO::dataFloat_ptr port,\n                              const std::string& connectionId,\n                              const redhawk::PropertyMap &props )\n          : bulkio::OutputTransport<BULKIO::dataFloat>(parent, port) {\n            _connectionId = connectionId;\n            _inProps = props;\n        };\n\n        virtual ~CustomOutputTransport() {\n           RH_NL_INFO(\"custom.transport\", \"CustomOutputTransport::~CustomOutputTransport\" );\n        };\n\n        std::string transportType() const {\n            return \"custom\";\n        };\n\n        virtual CF::Properties transportInfo() const {\n            redhawk::PropertyMap props;\n            props[\"transport_side_information\"] = \"outbound\";\n            props[\"another_number\"] = static_cast<short>(100);\n            return props;\n        };\n\n        void _pushSRI(const BULKIO::StreamSRI& sri) {};\n        void _pushPacket(const BufferType& data, const BULKIO::PrecisionUTCTime& T, bool EOS, const std::string& streamID) {};\n\n        void disconnect() {\n            RH_NL_INFO(\"custom.transport\", \"CustomOutputTransport::disconnect\" );\n            // perform disconnection\n        };\n\n        redhawk::PropertyMap  getNegotiationProperties();\n\n    protected:\n        std::string _connectionId;\n        redhawk::PropertyMap  _inProps;\n    };\n\n    // manager class that creates input transport layer for a negotiable port\n    class CustomInputManager : public bulkio::InputManager<BULKIO::dataFloat>\n    {\n    public:\n\n        CustomInputManager(bulkio::InPort<BULKIO::dataFloat>* port)\n          : bulkio::InputManager<BULKIO::dataFloat>(port) {\n        };\n\n        virtual ~CustomInputManager() {\n        };\n\n        CustomInputTransport* createInputTransport(const std::string& transportId, const redhawk::PropertyMap& properties) {\n            RH_NL_INFO(\"custom.transport\", \"CustomInputManager::createInputTransport\" );\n            for ( redhawk::PropertyMap::const_iterator it = properties.begin(); it != properties.end(); it++) {\n                 RH_NL_INFO(\"custom.transport\", \"CustomInputManager, key (from uses): \"<<it->id );\n            }\n            return new CustomInputTransport(this->_port, transportId, properties);\n        };\n\n        std::string transportType(){\n            return \"custom\";\n        };\n\n        redhawk::PropertyMap getNegotiationProperties(redhawk::ProvidesTransport* providesTransport);\n\n    };\n\n    // manager class that creates output transport layer for a negotiable port\n    class CustomOutputManager : public bulkio::OutputManager<BULKIO::dataFloat>\n    {\n    public:\n\n        CustomOutputManager(bulkio::OutPort<BULKIO::dataFloat>* port)\n          : bulkio::OutputManager<BULKIO::dataFloat>(port) {};\n\n        virtual ~CustomOutputManager() {};\n\n        std::string transportType() {\n                return \"custom\";\n        }\n\n        virtual CF::Properties transportProperties();\n        virtual CustomOutputTransport* createOutputTransport(PtrType object, const std::string& connectionId, const redhawk::PropertyMap& properties);\n        virtual redhawk::PropertyMap getNegotiationProperties(redhawk::UsesTransport* transport);\n        virtual void setNegotiationResult(redhawk::UsesTransport* transport, const redhawk::PropertyMap& properties);\n    };\n\n    // factory class that registers input/ouptut managers with a negotiation port\n    class CustomTransportFactory : public bulkio::BulkioTransportFactory<BULKIO::dataFloat>\n    {\n    public:\n\n        std::string transportType() {\n            return \"custom\";\n        };\n\n        int defaultPriority() {\n            return 0;\n        };\n\n        virtual ~CustomTransportFactory() {};\n\n        CustomOutputManager* createOutputManager(OutPortType* port);\n        CustomInputManager* createInputManager(InPortType* port);\n    };}\n```\n\n----------------------------------------\n\nTITLE: Slicing Shared Buffer in C++\nDESCRIPTION: Illustrates how to create a subset of a shared buffer without copying data in REDHAWK components, useful for working with portions of larger data sets efficiently.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_5\n\nLANGUAGE: C++\nCODE:\n```\n// NB: The arguments are the start and end indices.\nredhawk::shared_buffer<float> part = buffer.slice(8, 24);\n// part.size() == 16\n```\n\n----------------------------------------\n\nTITLE: Component Implementation Class in C++\nDESCRIPTION: Example of a component-specific implementation class that contains the core functionality of a REDHAWK component.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-model.md#2025-04-22_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\nTuneFilterDecimate_i\n```\n\n----------------------------------------\n\nTITLE: Initializing Component Factory Function in C++\nDESCRIPTION: Component factory function make_component() that creates specific component instances, replacing the traditional main() function responsibilities for shared address space components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/component-model.md#2025-04-22_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\nmake_component()\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Transport Method Definitions in Component CPP Files\nDESCRIPTION: Function implementations for custom transport classes including input and output transport negotiation properties, manager functions, and transport creation methods.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\n\n    redhawk::PropertyMap CustomInputTransport::getNegotiationProperties() {\n        RH_NL_INFO(\"custom.transport\", \"CustomInputTransport::getNegotiationProperties\");\n        redhawk::PropertyMap props;\n        props[\"data::requestSize\"] = static_cast<CORBA::Long>(1000);\n        props[\"data::address\"] = \"0.0.0.0\";\n        props[\"data::port\"] =  static_cast<CORBA::Long>(0);\n        props[\"data::protocol\"] = \"udp\";\n        return props;\n    }\n\n    redhawk::PropertyMap CustomInputManager::getNegotiationProperties(redhawk::ProvidesTransport* providesTransport)\n    {\n        CustomInputTransport* _transport = dynamic_cast<CustomInputTransport*>(providesTransport);\n        if (!_transport) {\n            throw redhawk::FatalTransportError(\"Invalid provides transport instance\");\n        }\n\n        // return data end point connection information\n        redhawk::PropertyMap properties;\n        properties =  _transport->getNegotiationProperties();\n        return properties;\n    }\n\n    CustomInputManager* CustomTransportFactory::createInputManager(bulkio::InPort<BULKIO::dataFloat>* port) {\n        return new CustomInputManager(port);\n    }\n\n\n    redhawk::PropertyMap CustomOutputTransport::getNegotiationProperties() {\n        RH_NL_INFO(\"custom.transport\", \"CustomOutputTransport::getNegotiationProperties\");\n        redhawk::PropertyMap props;\n        props[\"data_protocol\"] = \"hello\";\n        return props;\n    }\n\n    CF::Properties CustomOutputManager::transportProperties() {\n        RH_NL_INFO(\"custom.transport\", \"CustomOutputManager::transportProperties\");\n        redhawk::PropertyMap props;\n        return props;\n    }\n\n    CustomOutputTransport* CustomOutputManager::createOutputTransport(PtrType object,\n                                                                      const std::string& connectionId,\n                                                                      const redhawk::PropertyMap& inputTransportProps)\n    {\n        return new CustomOutputTransport(this->_port, object, connectionId, inputTransportProps );\n    }\n\n    redhawk::PropertyMap CustomOutputManager::getNegotiationProperties(redhawk::UsesTransport* transport) {\n        CustomOutputTransport* _transport = dynamic_cast<CustomOutputTransport*>(transport);\n        if (!_transport) {\n            throw redhawk::FatalTransportError(\"Invalid transport object provided.\");\n        }\n\n        redhawk::PropertyMap properties;\n        properties =  _transport->getNegotiationProperties();\n        return properties;\n    }\n\n    void CustomOutputManager::setNegotiationResult(redhawk::UsesTransport* transport, const redhawk::PropertyMap& properties) {\n\n         if (!transport) {\n             throw redhawk::FatalTransportError(\"Invalid transport object provided.\");\n         }\n\n        RH_NL_INFO(\"custom.transport\", \"CustomOutputManager::setNegotiationResult\");\n        for ( redhawk::PropertyMap::const_iterator it = properties.begin(); it != properties.end(); it++) {\n              RH_NL_INFO(\"custom.transport\",  \"CustomOutputManager, key (from provides): \"<<it->id );\n        }\n    }\n\n    CustomOutputManager* CustomTransportFactory::createOutputManager(OutPortType* port)\n    {\n        return new CustomOutputManager(port);\n    };\n```\n\n----------------------------------------\n\nTITLE: Wrapping Existing Memory in Shared Buffer in C++\nDESCRIPTION: Demonstrates how to wrap existing memory in a shared buffer, allowing REDHAWK components to take ownership of externally allocated memory for efficient use.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_3\n\nLANGUAGE: C++\nCODE:\n```\nfloat* data = new float[1024];\nredhawk::shared_buffer<float> buffer(data, 1024);\n```\n\n----------------------------------------\n\nTITLE: Recasting Shared Buffer in C++\nDESCRIPTION: Demonstrates how to reinterpret a shared buffer as another type in REDHAWK, allowing for flexible data handling while maintaining memory efficiency.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_6\n\nLANGUAGE: C++\nCODE:\n```\nredhawk::buffer<std::complex<short> > source(20); // 80 bytes\nredhawk::shared_buffer<short> shorty = redhawk::shared_buffer<short>::recast(source);                                                        |\n// shorty.size() == 40\n```\n\n----------------------------------------\n\nTITLE: Using Custom Deleter with Shared Buffer in C++\nDESCRIPTION: Shows how to use a custom deleter with a shared buffer in REDHAWK, allowing for specialized memory management when the buffer is no longer in use.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-address/shared-address-components-howto.md#2025-04-22_snippet_4\n\nLANGUAGE: C++\nCODE:\n```\nfloat* data = (float*) malloc(sizeof(float) * 1024));\nredhawk::shared_buffer<float> buffer(data, 1024, &std::free);\n```\n\n----------------------------------------\n\nTITLE: Registering Custom Transport with REDHAWK Framework\nDESCRIPTION: Initialization code that creates and registers the custom transport factory with the REDHAWK transport registry system to make the custom transport available to components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\n    static int initializeModule() {\n        static CustomTransportFactory factory;\n        redhawk::TransportRegistry::RegisterTransport(&factory);\n        return 0;\n    }\n\n    static int initialized = initializeModule();\n```\n\n----------------------------------------\n\nTITLE: Custom Output Port Class Definition in C++\nDESCRIPTION: C++ header code defining a custom output port class that inherits from BulkIO OutFloatPort to override local transport behavior.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nclass CustomOutPort : public bulkio::OutFloatPort {\npublic:\n        virtual ~CustomOutPort() {};\n        CustomOutPort(std::string port_name)\n          : bulkio::OutFloatPort(port_name) {};\n\n        virtual redhawk::UsesTransport* _createLocalTransport(PortBase* port, CORBA::Object_ptr object, const std::string& connectionId);\n};\n```\n\n----------------------------------------\n\nTITLE: Custom Transport Implementation in C++\nDESCRIPTION: C++ implementation of the custom local transport creation method that disables local transport and forces negotiation.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nredhawk::UsesTransport* CustomOutPort::_createLocalTransport(PortBase* port, CORBA::Object_ptr object, const std::string& connectionId) {\n    // disable the local transport and force a negotiation\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Shared Memory Cleanup for Orphaned POSIX RT Shared Memory Files\nDESCRIPTION: Shows the file naming pattern for orphaned shared memory heap files that may need cleanup after component crashes. These files are created in the /dev/shm filesystem with a predictable naming pattern.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/shared-memory-ipc.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\nheap-<pid>\n```\n\n----------------------------------------\n\nTITLE: FIFO Naming Pattern for Interprocess Communication in REDHAWK\nDESCRIPTION: Displays the naming pattern for FIFO files used for interprocess communication in the REDHAWK framework. These files are normally cleaned up automatically but might need manual removal in error cases.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/shared-memory-ipc.md#2025-04-22_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n/tmp/fifo-<pid>-<hex number>\n```\n\n----------------------------------------\n\nTITLE: Setting CPU-based Allocator Policy in REDHAWK\nDESCRIPTION: Sets the REDHAWK shared memory allocator policy to CPU-based instead of the default thread-based policy. This environment variable configuration affects how memory pools are assigned to allocations.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/tuning.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nexport RH_SHMALLOC_POLICY=cpu\n```\n\n----------------------------------------\n\nTITLE: Configuring Single Pool for Thread-Based Allocation\nDESCRIPTION: Sets the number of thread-based pools to 1, which limits total memory usage by ensuring all threads use the same pool. This is especially useful for legacy components running as a single processing thread in a standalone process.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/tuning.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nexport RH_SHMALLOC_THREAD_NUM_POOLS=1\n```\n\n----------------------------------------\n\nTITLE: Configuring CPUs-per-Pool Ratio for CPU-Based Allocation\nDESCRIPTION: Assigns multiple CPUs to each memory pool in the CPU-based allocation policy. This example configures 4 CPUs per pool, which would create 4 pools on a 16-CPU system.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/tuning.md#2025-04-22_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nexport RH_SHMALLOC_CPUS_PER_POOL=4\n```\n\n----------------------------------------\n\nTITLE: Enabling REDHAWK Shared Memory Metrics via Environment Variable\nDESCRIPTION: Sets the RH_SHMALLOC_METRICS environment variable to enable shared memory metrics collection for all REDHAWK processes launched from the current shell.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/metrics.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nexport RH_SHMALLOC_METRICS=1\n```\n\n----------------------------------------\n\nTITLE: Example REDHAWK Shared Memory Metrics Output\nDESCRIPTION: Sample console output showing shared memory metrics from a single-process component, including file statistics, pool usage, superblock allocation, and memory block lifecycle information.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/shared-memory/metrics.md#2025-04-22_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nSHM metrics (24003):\n  Executable: /var/redhawk/sdr/dom/components/rh/SigGen/cpp/SigGen\n  Files created: 1\n  Files opened: 0\n  Files closed: 0\n  Files total bytes: 2101248\n  Heaps created: 1\n  Pools created: 8\n  Pools used: 1\n  Pool allocations hot: 8090\n  Pool allocations cold: 1\n  Pool allocations failed: 0\n  Superblocks created: 1\n  Superblocks mapped: 0\n  Superblocks reused: 0\n  Superblocks unmapped: 0\n  Heap clients created: 0\n  Heap clients destroyed: 0\n  Blocks created: 8091\n  Blocks attached: 0\n  Blocks released: 8091\n  Blocks destroyed: 695\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Transport Components Connection in Python\nDESCRIPTION: Python code demonstrating how to launch, connect and verify the state of custom transport components. Shows component interaction when running in different process spaces.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from ossie.utils import sb\n>>> src=sb.launch('transport_out', shared=False)\n>>> snk=sb.launch('transport_in')\n>>> src.connect(snk)\nCustomOutputTransport::getNegotiationProperties\nCustomInputManager::createInputTransport\nCustomInputManager, key (from uses): data_protocol\nCustomInputTransport::startTransport\nCustomInputTransport::getNegotiationProperties\nCustomOutputManager::setNegotiationResult\nCustomOutputManager, key (from provides): data::requestSize\nCustomOutputManager, key (from provides): data::address\nCustomOutputManager, key (from provides): data::port\nCustomOutputManager, key (from provides): data::protocol\n>>> src.ports[0]._get_connectionStatus()\n[ossie.cf.ExtendedCF.ConnectionStatus(connectionId='DCE_66bd31e4-3cab-452b-8c21-6c3a2bc165eb', port=<bulkio.bulkioInterfaces.BULKIO.internal._objref_dataFloatExt object at 0x7f55d294f990>, alive=True, transportType='custom', transportInfo=[ossie.cf.CF.DataType(id='transport_side_information', value=CORBA.Any(CORBA.TC_string, 'outbound')), ossie.cf.CF.DataType(id='another_number', value=CORBA.Any(CORBA.TC_short, 100))])]\n>>> src.disconnect(snk)\nCustomOutputTransport::disconnect\nCustomInputTransport::~CustomInputTransport\nCustomOutputTransport::~CustomOutputTransport\n```\n\n----------------------------------------\n\nTITLE: Testing Custom Port in Shared Address Space\nDESCRIPTION: Python code demonstrating the testing of components with custom transport in shared address space configuration.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> from ossie.utils import sb\n>>> src=sb.launch('transport_out')\n>>> snk=sb.launch('transport_in')\n>>> src.connect(snk)\nCustomOutputTransport::getNegotiationProperties\nCustomInputManager::createInputTransport\nCustomInputManager, key (from uses): data_protocol\nCustomInputTransport::startTransport\nCustomInputTransport::getNegotiationProperties\nCustomOutputManager::setNegotiationResult\nCustomOutputManager, key (from provides): data::requestSize\nCustomOutputManager, key (from provides): data::address\nCustomOutputManager, key (from provides): data::port\nCustomOutputManager, key (from provides): data::protocol\n>>> src.ports[0]._get_connectionStatus()\n[ossie.cf.ExtendedCF.ConnectionStatus(connectionId='DCE_66bd31e4-3cab-452b-8c21-6c3a2bc165eb', port=<bulkio.bulkioInterfaces.BULKIO.internal._objref_dataFloatExt object at 0x7f55d294f990>, alive=True, transportType='custom', transportInfo=[ossie.cf.CF.DataType(id='transport_side_information', value=CORBA.Any(CORBA.TC_string, 'outbound')), ossie.cf.CF.DataType(id='another_number', value=CORBA.Any(CORBA.TC_short, 100))])]\n>>> src.disconnect(snk)\nCustomOutputTransport::disconnect\nCustomInputTransport::~CustomInputTransport\nCustomOutputTransport::~CustomOutputTransport\n```\n\n----------------------------------------\n\nTITLE: Port Instance Creation Updates in C++\nDESCRIPTION: Code modifications showing the change from standard BulkIO port instantiation to custom port instantiation.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/custom-transport/add_transport.md#2025-04-22_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\ndataFloat_out = new CustomOutPort(\"dataFloat_out\");\n```\n\n----------------------------------------\n\nTITLE: Starting Default Domain Manager in Bash\nDESCRIPTION: Command to start the REDHAWK Domain Manager. This is a critical service for REDHAWK SDR framework operation.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnodeBooter -D\n```\n\n----------------------------------------\n\nTITLE: Starting REDHAWK Device Manager in Bash\nDESCRIPTION: Command to start a Device Manager for REDHAWK SDR. This connects devices to the domain for use by components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nnodeBooter -d /var/redhawk/sdr/dev/nodes/MyNode/DeviceManager.dcd.xml\n```\n\n----------------------------------------\n\nTITLE: Checking Node Status in Python\nDESCRIPTION: Python snippet to get the list of nodes and examine their status. This is useful for troubleshooting connectivity issues in a REDHAWK domain.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndomMgr = sb.domainless.getDomainObject()\nnodes = domMgr.deviceManagers\nfor node in nodes:\n    print(\"Node: %s\" % node.label)\n```\n\n----------------------------------------\n\nTITLE: Generating Component from REDHAWK Template in Bash\nDESCRIPTION: Command to create a new REDHAWK SDR component from a template. This is useful for starting component development with proper structure.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nredhawk-codegen -C MyComponent\n```\n\n----------------------------------------\n\nTITLE: Checking REDHAWK SDR Package Installation Status with RPM\nDESCRIPTION: Command to verify the installed status of a REDHAWK SDR package using RPM. This helps diagnose installation problems.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrpm -qa | grep redhawk\n```\n\n----------------------------------------\n\nTITLE: Setting Environment Variables for REDHAWK SDR in Bash\nDESCRIPTION: Command to source the REDHAWK SDR environment setup script. This sets the necessary environment variables for working with REDHAWK.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nsource /etc/profile.d/redhawk.sh\n```\n\n----------------------------------------\n\nTITLE: Checking OSSIE Environment Variables in Bash\nDESCRIPTION: Command to verify if OSSIE_HOME environment variable is set correctly. This is essential for REDHAWK SDR framework to locate its core libraries and components.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\necho $OSSIE_HOME\n```\n\n----------------------------------------\n\nTITLE: Verifying Component Property Definition in XML\nDESCRIPTION: XML snippet showing proper property definition in a REDHAWK component. This is crucial for component configuration and functionality.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_8\n\nLANGUAGE: xml\nCODE:\n```\n<simple id=\"frequency\" type=\"double\">\n    <value>100.0</value>\n    <units>MHz</units>\n    <kind kindtype=\"property\"/>\n</simple>\n```\n\n----------------------------------------\n\nTITLE: Debugging REDHAWK Component XML Dependency\nDESCRIPTION: XML snippet showing a dependency declaration in a component SPD file. This demonstrates how to properly reference external libraries.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/first_file.txt#2025-04-22_snippet_6\n\nLANGUAGE: xml\nCODE:\n```\n<dependency type=\"runtime\">\n    <softpkgref>\n        <localfile name=\"/deps/library.spd.xml\"/>\n    </softpkgref>\n</dependency>\n```\n\n----------------------------------------\n\nTITLE: Installing JacORB Files\nDESCRIPTION: Commands to extract JacORB archive and install it to a system-wide accessible location.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd /usr/share/java\nunzip /tmp/jacorb-3.9.zip\n```\n\n----------------------------------------\n\nTITLE: Linking JacORB Libraries\nDESCRIPTION: Commands to create symbolic links for JacORB JAR files in OSSIE library directory for automatic classpath inclusion.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nln -s /usr/share/java/jacorb-3.9/lib/jacorb-*.jar $OSSIEHOME/lib/\nln -s /usr/share/java/jacorb-3.9/lib/slf4j-*.jar $OSSIEHOME/lib/\n```\n\n----------------------------------------\n\nTITLE: Java ORB Properties Configuration\nDESCRIPTION: Configuration settings for Java's ORB implementation to use JacORB as the default CORBA provider.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_2\n\nLANGUAGE: properties\nCODE:\n```\norg.omg.CORBA.ORBClass=org.jacorb.orb.ORB\norg.omg.CORBA.ORBSingletonClass=org.jacorb.orb.ORBSingleton\njacorb.config.dir=/usr/local/redhawk/core/etc\n```\n\n----------------------------------------\n\nTITLE: Setting ORB Properties Permissions\nDESCRIPTION: Command to ensure the ORB properties file is readable by all users.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nchmod a+r $JAVA_HOME/jre/lib/orb.properties\n```\n\n----------------------------------------\n\nTITLE: Creating JacORB Configuration Directory\nDESCRIPTION: Command to create the REDHAWK-specific JacORB configuration directory.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nmkdir -p $OSSIEHOME/etc/\n```\n\n----------------------------------------\n\nTITLE: Copying JacORB Properties Template\nDESCRIPTION: Command to copy the default JacORB properties template to the REDHAWK configuration directory.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\ncp /usr/share/java/jacorb-3.9/etc/jacorb_properties.template $OSSIEHOME/etc/jacorb.properties\n```\n\n----------------------------------------\n\nTITLE: JacORB Logging Configuration\nDESCRIPTION: Properties configuration to adjust JacORB's logging verbosity level.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/docs/jacorb/using-jacorb.md#2025-04-22_snippet_6\n\nLANGUAGE: properties\nCODE:\n```\njacorb.log.default.verbosity=2\n```\n\n----------------------------------------\n\nTITLE: Configuring Log4j with Console Output for Core Framework\nDESCRIPTION: Sets up Log4j with a root logger at INFO level that outputs to stdout. Configures a ConsoleAppender with a simple pattern format that only displays the log message followed by a newline.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/burstioInterfaces/testing/tests/java/log4j_config.txt#2025-04-22_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\nlog4j.rootLogger=INFO,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%m%n\n```\n\n----------------------------------------\n\nTITLE: Configuring Log4j with Console Appender for Java Application\nDESCRIPTION: This configuration sets up Log4j with a root logger at WARN level and a console appender. The console output is configured to only show the log message followed by a newline without timestamps or log levels.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/frontendInterfaces/libsrc/testing/tests/java/log4j_config.txt#2025-04-22_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\nlog4j.rootLogger=WARN,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%m%n\n```\n\n----------------------------------------\n\nTITLE: Configuring Log4j with Console Output in Properties Format\nDESCRIPTION: Sets up Log4j with WARN level logging directed to the console (stdout). Configures a ConsoleAppender with a simple pattern that outputs just the log message followed by a newline character.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/bulkioInterfaces/libsrc/testing/tests/java/log4j_config.txt#2025-04-22_snippet_0\n\nLANGUAGE: properties\nCODE:\n```\nlog4j.rootLogger=WARN,stdout\n\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%m%n\n```\n\n----------------------------------------\n\nTITLE: Configuring Domain Manager Shared Memory in XML\nDESCRIPTION: This XML snippet demonstrates how to configure shared memory for the Domain Manager in the REDHAWK SDR framework. It defines memory thresholds and limits for the shared memory segments used by the Domain Manager.\nSOURCE: https://github.com/redhawksdr/core-framework/blob/develop-2.2/redhawk/src/testing/sdr/dev/data/subdir_test/subdir_two/second_file.txt#2025-04-22_snippet_0\n\nLANGUAGE: XML\nCODE:\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE properties PUBLIC \"-//Red Hat, Inc.//DTD DomainManager Shared Memory Configuration 1.0//EN\" \"DomainManagerSharedMemoryConfiguration.dtd\">\n<properties>\n    <!-- Number of kilobytes to pre-allocate for heap memory -->\n    <!-- Default value is \"33554432\" (32GB) -->\n    <simple id=\"DCE:8dcef419-b440-43b1-8e85-9f1841a2c83a\" name=\"heapSize\" type=\"unsigned long\" value=\"33554432\"/>\n\n    <!-- Maximum size, in kilobytes, that the heap is allowed to grow to -->\n    <!-- Default value is \"33554432\" (32GB) -->\n    <simple id=\"DCE:79e8a1cc-9498-44d2-8677-ddf695326296\" name=\"maxHeapSize\" type=\"unsigned long\" value=\"33554432\"/>\n\n    <!-- After the heap memory exceeds this size, in kilobytes, start the alarm service -->\n    <!-- Default value is \"33554432\" (32GB) -->\n    <simple id=\"DCE:89484401-6a0f-4677-ac37-376673ddb58a\" name=\"threshold\" type=\"unsigned long\" value=\"33554432\"/>\n\n    <!-- Critical threshold level, in kilobytes, that triggers an alarm to be issued if the heap memory exceeds -->\n    <!-- Default value is \"33554432\" (32GB) -->\n    <simple id=\"DCE:f4bac2b6-c2f9-45fb-ad52-f41360d62c16\" name=\"criticalThreshold\" type=\"unsigned long\" value=\"33554432\"/>\n</properties>\n```"
  }
]