[
  {
    "owner": "rustwasm",
    "repo": "wasm-bindgen",
    "content": "TITLE: Demonstrating String Usage in Rust for WebAssembly\nDESCRIPTION: This Rust code snippet showcases various operations with String type in the context of WebAssembly bindings. It includes string creation, manipulation, and passing strings between Rust and JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/string.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/string.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Fetch API in Rust for WebAssembly\nDESCRIPTION: This Rust code demonstrates how to use the Fetch API in a WebAssembly context. It includes functions for making HTTP requests to the GitHub API, handling responses, and parsing JSON data. The code showcases error handling, async/await syntax, and integration with JavaScript promises.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/fetch.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/fetch/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Passing Rust Closures to JavaScript with wasm-bindgen and web-sys\nDESCRIPTION: Complete example of using Rust closures with JavaScript web APIs via wasm-bindgen. Demonstrates event listeners, setTimeout, console.log, and Promise handling patterns with proper lifetime management.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/closures.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse js_sys::Promise;\nuse wasm_bindgen::prelude::*;\nuse wasm_bindgen::JsCast;\nuse wasm_bindgen_futures::JsFuture;\nuse web_sys::{Document, Element, HtmlElement, Window};\n\n/// Get the first element with the given ID from the document.\n#[wasm_bindgen(start)]\npub fn run() -> Result<(), JsValue> {\n    // Use `web_sys`'s global `window` function to get a handle on the global window object.\n    let window = web_sys::window().expect(\"no global `window` exists\");\n    let document = window.document().expect(\"should have a document on window\");\n    let body = document.body().expect(\"document should have a body\");\n\n    // Manufacture the element we're gonna append\n    let val = document.create_element(\"p\")?;\n    val.set_inner_html(\"Hello from Rust!\");\n\n    let mut clicks = 0;\n    let a = Closure::wrap(Box::new(move || {\n        clicks += 1;\n        web_sys::console::log_1(&\"Clicked!\".into());\n        if clicks > 5 {\n            val.set_inner_html(\"More than 5 clicks!\");\n        }\n    }) as Box<dyn FnMut()>);\n\n    // Register the onclick callback\n    val.set_onclick(Some(a.as_ref().unchecked_ref()));\n    a.forget();\n\n    let performance = window\n        .performance()\n        .expect(\"performance should be available\");\n\n    // setup a callback when the 'load' event fires on the window\n    let loadcb = Closure::once_into_js(move || {\n        // This will be invoked after the body's `load` event fires\n        web_sys::console::log_1(&\"loaded!\".into());\n\n        // Calculate how much time has passed since we've loaded\n        let start = performance.now();\n        let cb = Closure::once_into_js(move || {\n            let elapsed = performance.now() - start;\n            web_sys::console::log_1(&format!(\"{}ms elapsed\", elapsed).into());\n        });\n        // Schedule the timeout for 1000ms from now\n        window\n            .set_timeout_with_callback(cb.as_ref().unchecked_ref())\n            .expect(\"should register `setTimeout` OK\");\n    });\n    window.set_onload(Some(loadcb.unchecked_ref()));\n\n    // Set up our onClick callback for a button that will be created\n    let cb = Closure::wrap(Box::new(move || {\n        create_button_after_fetch(&window, &document);\n    }) as Box<dyn FnMut()>);\n\n    let button = document.create_element(\"button\")?;\n    button.set_inner_html(\"Click me to fetch HTML!\");\n    button.set_onclick(Some(cb.as_ref().unchecked_ref()));\n    // A Closure that is passed to `onclick` doesn't need to be forgotten because the browser\n    // will drop it after the element is destroyed, which makes sense.\n    // We could call cb.forget() here to leak our closure, but we can also use the\n    // regular drop semantics of Rust!\n\n    body.append_child(&val)?;\n    body.append_child(&button)?;\n\n    Ok(())\n}\n\nfn create_button_after_fetch(window: &Window, document: &Document) {\n    // Use fetch to get some remote data\n    let promise = window\n        .fetch_with_str(\"https://raw.githubusercontent.com/rustwasm/wasm-bindgen/master/examples/add/src/lib.rs\");\n\n    // Convert the promise into a future and use the `wasm-bindgen-futures` crate\n    // to wait for it asynchronously\n    let future = async move {\n        // Convert to a rust future\n        let resp_value = JsFuture::from(promise).await?;\n        // `resp_value` is a `Response` object\n        // https://developer.mozilla.org/en-US/docs/Web/API/Response\n        let resp: web_sys::Response = resp_value.dyn_into()?;\n        // Convert this other promise into a future as well\n        let text = JsFuture::from(resp.text()?).await?;\n        // Convert to a rust type\n        let html = text.as_string().unwrap();\n\n        // Now get a handle to the document\n        let window = web_sys::window().unwrap();\n        let document = window.document().unwrap();\n\n        // Create new elements\n        let pre = document.create_element(\"pre\")?;\n        let code = document.create_element(\"code\")?;\n        code.set_inner_html(&html);\n        pre.append_child(&code)?;\n        document.body().unwrap().append_child(&pre)?;\n\n        Ok::<(), JsValue>(())\n    };\n\n    wasm_bindgen_futures::spawn_local(future);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Rust Structure Export Example with WASM-Bindgen\nDESCRIPTION: Demonstrates how to export a Rust struct type for use in JavaScript using wasm-bindgen annotations. Shows parameter handling and type conversions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/exported-rust-types.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/exported_types.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Rust functions for WebAssembly export\nDESCRIPTION: Rust code that exports a greet() function to JavaScript using wasm-bindgen and demonstrates calling the browser's alert() function from Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/hello-world.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/hello_world/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebAssembly Module Instantiation in Rust\nDESCRIPTION: This code demonstrates how to use js-sys to compile, instantiate, and run a WebAssembly module from within Rust code compiled to WebAssembly. It includes functions for creating a module, instantiating it, and executing its exported functions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-wasm.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse js_sys::*;\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn run() -> Result<JsValue, JsValue> {\n    // Create our `WebAssembly.Module`\n    let module = include_bytes!(\"add.wasm\");\n    let module = WebAssembly::Module::new(&Uint8Array::from(module.as_ref()))?;\n\n    // Create the import object for the module\n    let import_object = Object::new();\n\n    // Instantiate the module\n    let instance = WebAssembly::Instance::new(&module, &import_object)?;\n\n    // Extract the `add` function from the module\n    let add = Reflect::get(&instance.exports(), &\"add\".into())?;\n    let add = add.dyn_ref::<Function>().unwrap();\n\n    // Invoke the `add` function\n    let result = add.call2(&JsValue::undefined(), &1.into(), &2.into())?;\n\n    // Return the result\n    Ok(result)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Exporting Rust Async Function as JavaScript Promise in WebAssembly\nDESCRIPTION: This example shows how to export a Rust async function that will be exposed as a JavaScript Promise. It uses the #[wasm_bindgen] attribute to make the function available to JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-promises-and-rust-futures.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub async fn foo() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing DOM Manipulation with web-sys in Rust\nDESCRIPTION: This code shows a Rust implementation for interacting with the DOM using web-sys. It demonstrates how to create DOM elements, customize them, and append them to the page when compiled to WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/dom.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/dom/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Drawing Smiley Face with Rust and WebAssembly Canvas API\nDESCRIPTION: Rust implementation that demonstrates canvas manipulation using web-sys. The code retrieves a canvas element, creates a 2D rendering context, and draws a smiley face using various canvas drawing methods.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/2d-canvas.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/canvas/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for Fetch API in Rust WebAssembly\nDESCRIPTION: This snippet shows the Cargo.toml configuration for a Rust WebAssembly project using the Fetch API. It enables features related to the Fetch API and associated types like Headers and Request.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/fetch.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/fetch/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Rust Numeric Type Examples\nDESCRIPTION: Demonstrates using various numeric types in Rust functions that will be exposed to JavaScript through wasm-bindgen. Shows parameter passing and return value handling for different numeric types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/numbers.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/numbers.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing console.log functionality in Rust for WebAssembly\nDESCRIPTION: This Rust code demonstrates multiple ways to use console.log when writing WebAssembly code with wasm-bindgen. It shows several implementations from basic to advanced, including direct JS imports, web_sys usage, and custom macros that mimic Rust's println! functionality.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/console-log.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// First up, let's take a look at the `console.log` function. This is the one that\n// prints a message to the developer console in your web browser, and we're going\n// to import it here.\n//\n// Note that the `#[wasm_bindgen]` attribute looks a bit different here. It's\n// modifying a whole module, not a function!\n#[wasm_bindgen]\nextern \"C\" {\n    // Use `js_namespace` here to bind `console.log(..)` instead of just\n    // `log(..)`\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n\n    // The `console.log` is quite polymorphic, so we can bind it with multiple\n    // signatures. Note that we need to use `js_name` to ensure we always call\n    // `log` in JS.\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_u32(a: u32);\n\n    // Multiple arguments too!\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn log_many(a: &str, b: &str);\n}\n\n// Next let's define some macros to make it a bit easier to use these functions.\n// First, a macro for `console.log`ing a single string, just to cut down on the\n// verbosity a bit.\n\nmacro_rules! log {\n    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))\n}\n\n// And another for logging multiple values, paired with their names. Like the\n// `dbg!` macro but prints to the console.\n\nmacro_rules! console_log {\n    // Note that this is using the `log` function imported above during\n    // `bare_bones`.\n    ($($ t:tt)*) => (log(&format_args!($($t)*).to_string()));\n}\n\n// And finally, we'll import the web_sys crate to demonstrate yet another method\n// of logging!\n//\n// You can import a number of console functions from web_sys, and construct them\n// manually via the `web_sys::console` module. Let's alternate between the two of\n// them.\n\n#[wasm_bindgen(start)]\npub fn run() {\n    // First up, let's log a string. This is going to be using our imported\n    // `log` function above.\n    log(\"Hello, world!\");\n\n    // There's various other functions on `console` we can call as well, for\n    // example the timing functions.\n    console_log!(\"Starting timer...\");\n    let start = web_sys::window()\n        .expect(\"should have a Window\")\n        .performance()\n        .expect(\"should have a Performance\")\n        .now();\n\n    // We can also explicitly use various print-like functions on the `console\n    // module.\n    web_sys::console::log_1(&\"Hello via web-sys\".into());\n\n    // We can even print formatted strings using our custom macros!\n    console_log!(\"Formatted {}: {}\", \"message\", 42);\n\n    // And we can even print out more complex objects like arrays or debuggable\n    // objects\n    console_log!(\"{:?}\", [1, 2, 3]);\n\n    // Let's check how long this all took\n    let end = web_sys::window()\n        .expect(\"should have a Window\")\n        .performance()\n        .expect(\"should have a Performance\")\n        .now();\n    console_log!(\"Time elapsed: {} ms\", end - start);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust Struct for JS Export with wasm-bindgen\nDESCRIPTION: Example showing how to define a Rust struct with methods that will be exported to JavaScript as a class. The struct has a constructor and methods for getting and setting an internal value.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust-struct.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct Foo {\n    internal: i32,\n}\n\n#[wasm_bindgen]\nimpl Foo {\n    #[wasm_bindgen(constructor)]\n    pub fn new(val: i32) -> Foo {\n        Foo { internal: val }\n    }\n\n    pub fn get(&self) -> i32 {\n        self.internal\n    }\n\n    pub fn set(&mut self, val: i32) {\n        self.internal = val;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up package.json for Rust WebAssembly project\nDESCRIPTION: The package.json configuration for the JavaScript side of the WebAssembly project. It includes dependencies for Webpack and the wasm-pack-plugin needed to build the Rust code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/hello-world.md#2025-04-16_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{{#include ../../../examples/hello_world/package.json}}\n```\n\n----------------------------------------\n\nTITLE: Implementing requestAnimationFrame Loop in Rust with web-sys\nDESCRIPTION: This Rust code demonstrates how to set up a requestAnimationFrame loop using web-sys. It creates a closure that updates a counter on the webpage, requests the next animation frame, and breaks the loop after 300 iterations.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/request-animation-frame.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/request-animation-frame/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for WebRTC DataChannel in Rust\nDESCRIPTION: This snippet shows the Cargo.toml configuration for enabling WebRTC DataChannel features in a Rust project. It includes necessary dependencies and feature flags for WebAssembly compilation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/webrtc_datachannel.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/webrtc_datachannel/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Using gloo-utils for JSON Serialization in Rust\nDESCRIPTION: This code demonstrates how to use gloo-utils to serialize and deserialize data between Rust and JavaScript using a JSON-based approach.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\nuse gloo_utils::format::JsValueSerdeExt;\n\n#[wasm_bindgen]\npub fn send_example_to_js() -> JsValue {\n    let mut field1 = HashMap::new();\n    field1.insert(0, String::from(\"ex\"));\n    let example = Example {\n        field1,\n        field2: vec![vec![1., 2.], vec![3., 4.]],\n        field3: [1., 2., 3., 4.]\n    };\n\n    JsValue::from_serde(&example).unwrap()\n}\n\n#[wasm_bindgen]\npub fn receive_example_from_js(val: JsValue) {\n    let example: Example = val.into_serde().unwrap();\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript functions and exporting Rust functions with wasm-bindgen\nDESCRIPTION: This Rust code example shows how to import a JavaScript function (alert) and export a Rust function (greet) using wasm-bindgen attributes.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/README.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n// Import the `window.alert` function from the Web.\n#[wasm_bindgen]\nextern \"C\" {\n    fn alert(s: &str);\n}\n\n// Export a `greet` function from Rust to JavaScript, that alerts a\n// hello message.\n#[wasm_bindgen]\npub fn greet(name: &str) {\n    alert(&format!(\"Hello, {}!\", name));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FM Oscillator in Rust\nDESCRIPTION: This Rust code implements the FM oscillator using web-sys. It creates and configures the necessary AudioNodes, sets up the audio graph, and provides methods to start and stop the oscillator.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/web-audio.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/webaudio/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing an Interval Struct with Heap-Allocated Closures in Rust\nDESCRIPTION: This snippet defines an Interval struct that uses heap-allocated closures to create a JavaScript interval. It includes methods for creating a new interval and automatically clearing it when dropped.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct Interval {\n    closure: Closure<dyn FnMut()>,\n    token: f64,\n}\n\nimpl Interval {\n    pub fn new<F: 'static>(millis: u32, f: F) -> Interval\n    where\n        F: FnMut()\n    {\n        // Construct a new closure.\n        let closure = Closure::new(f);\n\n        // Pass the closure to JS, to run every n milliseconds.\n        let token = setInterval(&closure, millis);\n\n        Interval { closure, token }\n    }\n}\n\n// When the Interval is destroyed, clear its `setInterval` timer.\nimpl Drop for Interval {\n    fn drop(&mut self) {\n        clearInterval(self.token);\n    }\n}\n\n// Keep logging \"hello\" every second until the resulting `Interval` is dropped.\n#[wasm_bindgen]\npub fn hello() -> Interval {\n    Interval::new(1_000, || log(\"hello\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebGL Triangle Drawing in Rust for WebAssembly\nDESCRIPTION: This Rust code demonstrates how to obtain a WebGL rendering context, compile shaders, create vertex buffers, and draw a triangle. It includes error handling and uses web-sys for WebGL bindings.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/webgl.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/webgl/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Measuring Function Performance with web-sys in Rust WebAssembly\nDESCRIPTION: Example of importing and using the Performance API from the web-sys crate to measure execution time of a Rust function when compiled to WebAssembly. The code demonstrates how to access window.performance, get timestamps using now(), and calculate elapsed time.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/performance.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\nuse web_sys::Performance;\n\n#[wasm_bindgen(start)]\npub fn run() {\n    // Here we want to utilize `window.performance.now()` to get the time before/after\n    // we execute a long-running task to get an idea of how much time it took.\n    //\n    // First up we need to get a handle to `window.performance` which is what is going\n    // to give us timing information.\n    let performance = web_sys::window()\n        .expect(\"should have a Window\")\n        .performance()\n        .expect(\"should have a Performance\");\n\n    // Next up we measure how long it takes to sort a large-ish array. Note that this\n    // timing isn't super precise, but should give a general idea of how long this\n    // function takes in the grand scheme of things.\n    let start = performance.now();\n    let mut arr = Vec::new();\n    for i in 0..1_000_000 {\n        arr.push(i);\n    }\n    arr.sort();\n    let elapsed = performance.now() - start;\n\n    // And now that we've measured our timing let's add it to the document so we can\n    // see what happened\n    log!(\n        \"it took {} milliseconds to sort {} numbers\",\n        elapsed,\n        arr.len()\n    );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo Dependencies for WebAssembly Canvas Project\nDESCRIPTION: Cargo.toml configuration file that enables features for DOM manipulation and 2D canvas operations using web-sys and wasm-bindgen.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/2d-canvas.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/canvas/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for web-sys in Cargo.toml\nDESCRIPTION: This snippet shows the Cargo.toml configuration for the project, including dependencies on wasm-bindgen and web-sys with specific feature flags enabled for DOM manipulation and animation frame requests.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/request-animation-frame.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/request-animation-frame/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Collecting Numbers from Any JavaScript Iterable using Rust and wasm-bindgen\nDESCRIPTION: This function demonstrates how to iterate over any JavaScript object that implements the iterator protocol using wasm-bindgen. It collects numbers from the iterable and returns them as a JavaScript Array. The function uses js_sys::try_iter to convert the JavaScript iterable to a Rust iterator.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/iterating-over-js-values.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn collect_numbers(some_iterable: &JsValue) -> Result<js_sys::Array, JsValue> {\n    let nums = js_sys::Array::new();\n\n    let iterator = js_sys::try_iter(some_iterable)?.ok_or_else(|| {\n        \"need to pass iterable JS values!\"\n    })?;\n\n    for x in iterator {\n        // If the iterator's `next` method throws an error, propagate it\n        // up to the caller.\n        let x = x?;\n\n        // If `x` is a number, add it to our array of numbers!\n        if x.as_f64().is_some() {\n            nums.push(&x);\n        }\n    }\n\n    Ok(nums)\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Async Functions with Error Handling in Rust WebAssembly\nDESCRIPTION: This snippet demonstrates importing JavaScript async functions with error handling using the catch attribute. It shows how to handle functions that may return errors as Result types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-promises-and-rust-futures.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(catch)]\n    async fn async_func_3() -> Result<JsValue, JsValue>;\n    #[wasm_bindgen(catch)]\n    async fn async_func_4() -> Result<(), JsValue>;\n}\n```\n\n----------------------------------------\n\nTITLE: Converting JavaScript Promise to Rust Future in WebAssembly\nDESCRIPTION: This snippet demonstrates how to convert a JavaScript Promise to a Rust Future using js_sys::Promise and wasm_bindgen_futures::JsFuture in an async Rust function. It resolves a Promise with a value of 42 and returns the result.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-promises-and-rust-futures.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nasync fn get_from_js() -> Result<JsValue, JsValue> {\n    let promise = js_sys::Promise::resolve(&42.into());\n    let result = wasm_bindgen_futures::JsFuture::from(promise).await?;\n    Ok(result)\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for WebAssembly with wasm-bindgen\nDESCRIPTION: The Cargo.toml configuration for a Rust WebAssembly project. It specifies wasm-bindgen as a dependency and sets the crate-type to cdylib which is required for WebAssembly compilation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/hello-world.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/hello_world/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Implementing WebRTC DataChannel in Rust for WebAssembly\nDESCRIPTION: This Rust code implements WebRTC data channel functionality. It sets up peer connections, creates data channels, and handles the sending and receiving of messages between peers. The code is designed to be compiled to WebAssembly for browser execution.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/webrtc_datachannel.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/webrtc_datachannel/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Webpack for Rust WebAssembly\nDESCRIPTION: Webpack configuration for building a Rust WebAssembly project. It sets up the wasm-pack-plugin to compile Rust to WebAssembly during the build process.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/hello-world.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/hello_world/webpack.config.js}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Dynamic Property Access with JavaScript Proxy\nDESCRIPTION: This snippet demonstrates how to create a Proxy object in JavaScript that intercepts get, set, and delete operations on properties. It shows dynamic property access behavior that returns the property length if not found, allows setting properties, and supports property deletion.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/indexing-getter-setter-deleter.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst foo = new Proxy({}, {\n    get(obj, prop) {\n        return prop in obj ? obj[prop] : prop.length;\n    },\n    set(obj, prop, value) {\n        obj[prop] = value;\n    },\n    deleteProperty(obj, prop) {\n        delete obj[prop];\n    },\n});\n\nfoo.ten;\n// 3\n\nfoo.ten = 10;\nfoo.ten;\n// 10\n\ndelete foo.ten;\nfoo.ten;\n// 3\n```\n\n----------------------------------------\n\nTITLE: Writing WebAssembly Tests in Rust\nDESCRIPTION: This code demonstrates how to write tests using wasm-bindgen-test. It includes examples of passing and failing tests, as well as a test that can run on multiple targets.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen_test::*;\n\n#[wasm_bindgen_test]\nfn pass() {\n    assert_eq!(1, 1);\n}\n\n#[wasm_bindgen_test]\nfn fail() {\n    assert_eq!(1, 2);\n}\n\n// On a target other then `wasm32-unknown-unknown`, the `#[test]` attribute\n// will be used instead, allowing this test to run on any target.\n#[wasm_bindgen_test(unsupported = test)]\nfn all_targets() {\n    assert_eq!(1, 2);\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Functions in Rust with wasm-bindgen\nDESCRIPTION: Rust code using wasm-bindgen to import JavaScript functions and classes. Shows how to declare external JavaScript functions and use them in Rust with proper type bindings.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/import-js.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen(module = \"/defined-in-js.js\")]\nextern \"C\" {\n    fn foo(a: i32) -> i32;\n\n    type Bar;\n\n    #[wasm_bindgen(constructor)]\n    fn new() -> Bar;\n\n    #[wasm_bindgen(method)]\n    fn add(this: &Bar, a: i32) -> i32;\n\n    type Content;\n\n    #[wasm_bindgen(constructor)]\n    fn new() -> Content;\n\n    #[wasm_bindgen(method, getter)]\n    fn name(this: &Content) -> String;\n\n    fn get_content() -> Content;\n}\n\n#[wasm_bindgen]\npub fn test() {\n    let x = foo(1);\n    console_log!(\"{}\", x);\n\n    let bar = Bar::new();\n    let y = bar.add(2);\n    console_log!(\"{}\", y);\n\n    let content = get_content();\n    console_log!(\"{}\", content.name());\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating JsValue Usage in Rust for WebAssembly\nDESCRIPTION: This Rust code snippet shows how to use the JsValue type to interact with JavaScript values in a WebAssembly context. It includes examples of creating, manipulating, and returning JsValue objects.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/jsvalue.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/js_value.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing JavaScript Exception Handling in Rust WASM\nDESCRIPTION: Demonstrates how to use the catch attribute to handle JavaScript exceptions in both standalone functions and methods. The caught exceptions are converted to Result types where Err contains the JsValue of the exception. This pattern works for any imported function or method that needs exception handling.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/catch.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    // `catch` on a standalone function.\n    #[wasm_bindgen(catch)]\n    fn foo() -> Result<(), JsValue>;\n\n    // `catch` on a method.\n    type Zoidberg;\n    #[wasm_bindgen(catch, method)]\n    fn woop_woop_woop(this: &Zoidberg) -> Result<u32, JsValue>;\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting Rust WebAssembly to JavaScript UI\nDESCRIPTION: This JavaScript code creates the user interface, initializes the Rust WebAssembly module, and handles user interactions. It translates UI events into calls to the Wasm code to control the FM oscillator.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/web-audio.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/webaudio/index.js}}\n```\n\n----------------------------------------\n\nTITLE: Defining Duck-Typed Interface in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates how to define a duck-typed interface in Rust using wasm-bindgen's structural attribute to work with JavaScript objects that share similar methods but not inheritance\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/working-with-duck-typed-interfaces.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/duck-typed-interfaces/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Weather Report Web Application in Rust for WebAssembly\nDESCRIPTION: This code snippet demonstrates a complete Rust implementation for a weather report web application. It includes functions for making HTTP requests to the OpenWeather API, parsing JSON responses, and rendering the UI. The code utilizes wasm-bindgen for WebAssembly integration and features async operations with spawn_local.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/weather_report.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::Deserialize;\nuse wasm_bindgen::prelude::*;\nuse wasm_bindgen::JsCast;\nuse wasm_bindgen_futures::spawn_local;\nuse web_sys::{Document, Element, HtmlElement, Window};\n\n#[wasm_bindgen(start)]\npub fn main() -> Result<(), JsValue> {\n    let window = web_sys::window().expect(\"no global `window` exists\");\n    let document = window.document().expect(\"should have a document on window\");\n    let body = document.body().expect(\"document should have a body\");\n\n    // Manufacture the element we're gonna append\n    let val = document.create_element(\"p\")?;\n    val.set_inner_html(\"Hello from Rust!\");\n\n    body.append_child(&val)?;\n\n    spawn_local(get_response());\n\n    Ok(())\n}\n\nasync fn get_response() {\n    let api_key = \"YOUR_API_KEY\";\n    let city = \"London\";\n    let url = format!(\n        \"https://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric\"\n    );\n\n    let resp = reqwest::get(&url).await.unwrap().json::<Response>().await.unwrap();\n\n    let window = web_sys::window().expect(\"no global `window` exists\");\n    let document = window.document().expect(\"should have a document on window\");\n    let body = document.body().expect(\"document should have a body\");\n\n    render_weather(&document, &body, &resp);\n}\n\nfn render_weather(document: &Document, parent: &Element, resp: &Response) {\n    let div = document\n        .create_element(\"div\")\n        .expect(\"failed to create div element\");\n    div.set_class_name(\"weather-report\");\n\n    let city = document\n        .create_element(\"h2\")\n        .expect(\"failed to create h2 element\");\n    city.set_inner_html(&resp.name);\n    div.append_child(&city).expect(\"failed to append city\");\n\n    let temp = document\n        .create_element(\"p\")\n        .expect(\"failed to create p element\");\n    temp.set_inner_html(&format!(\"Temperature: {}°C\", resp.main.temp));\n    div.append_child(&temp).expect(\"failed to append temp\");\n\n    let desc = document\n        .create_element(\"p\")\n        .expect(\"failed to create p element\");\n    desc.set_inner_html(&resp.weather[0].description);\n    div.append_child(&desc).expect(\"failed to append desc\");\n\n    parent.append_child(&div).expect(\"failed to append weather report\");\n}\n\n#[derive(Debug, Deserialize)]\nstruct Response {\n    name: String,\n    main: Main,\n    weather: Vec<Weather>,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Main {\n    temp: f64,\n}\n\n#[derive(Debug, Deserialize)]\nstruct Weather {\n    description: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Using Result<T, E> in Rust-WebAssembly Functions\nDESCRIPTION: The Result type can be returned from Rust functions exported to JavaScript. The Ok variant must be convertible to JS, while the Err variant must implement Into<JsValue>. Ok values are converted to JS, while Err values throw JavaScript exceptions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/result.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nResult<T, E>\n```\n\n----------------------------------------\n\nTITLE: Implementing Rust Character Counter for WebAssembly\nDESCRIPTION: Rust implementation of a Counter struct that works with character types through wasm-bindgen. Demonstrates conversion of Rust char to JavaScript string for WebAssembly interop.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/char.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\nstruct Counter {\n    key: char,\n    count: i32,\n}\n\n#[wasm_bindgen]\nimpl Counter {\n    #[wasm_bindgen(constructor)]\n    pub fn new(key: char) -> Counter {\n        Counter {\n            key,\n            count: 0,\n        }\n    }\n\n    pub fn key(&self) -> char {\n        self.key\n    }\n\n    pub fn count(&self) -> i32 {\n        self.count\n    }\n\n    pub fn increment(&mut self) {\n        self.count += 1;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using exported Rust functions in JavaScript with ECMAScript modules\nDESCRIPTION: This JavaScript snippet demonstrates how to import and use a Rust function (greet) that has been exported using wasm-bindgen.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/README.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { greet } from \"./hello_world\";\n\ngreet(\"World!\");\n```\n\n----------------------------------------\n\nTITLE: Using Number Slices in JavaScript with WebAssembly\nDESCRIPTION: This JavaScript code demonstrates how to interact with Rust-generated WebAssembly functions that work with number slices. It shows creation of typed arrays, passing them to WebAssembly functions, and handling the returned results.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/number-slices.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from \"./guide_supported_types_examples\";\n\n// Create a Float32Array and pass it to Rust\nconst f32Array = new Float32Array([1.0, 2.0, 3.0, 4.0, 5.0]);\nconst f32Sum = wasm.sum_f32_slice(f32Array);\nconsole.log(\"Sum of f32 array:\", f32Sum);\n\n// Create a Float64Array and pass it to Rust\nconst f64Array = new Float64Array([1.0, 2.0, 3.0, 4.0, 5.0]);\nconst f64Sum = wasm.sum_f64_slice(f64Array);\nconsole.log(\"Sum of f64 array:\", f64Sum);\n\n// Create an Int32Array and pass it to Rust\nconst i32Array = new Int32Array([1, 2, 3, 4, 5]);\nconst i32Sum = wasm.sum_i32_slice(i32Array);\nconsole.log(\"Sum of i32 array:\", i32Sum);\n\n// Create a BigInt64Array and pass it to Rust\nconst i64Array = new BigInt64Array([1n, 2n, 3n, 4n, 5n]);\nconst i64Sum = wasm.sum_i64_slice(i64Array);\nconsole.log(\"Sum of i64 array:\", i64Sum);\n\n// Create a Uint32Array and pass it to Rust\nconst u32Array = new Uint32Array([1, 2, 3, 4, 5]);\nconst u32Sum = wasm.sum_u32_slice(u32Array);\nconsole.log(\"Sum of u32 array:\", u32Sum);\n\n// Create a BigUint64Array and pass it to Rust\nconst u64Array = new BigUint64Array([1n, 2n, 3n, 4n, 5n]);\nconst u64Sum = wasm.sum_u64_slice(u64Array);\nconsole.log(\"Sum of u64 array:\", u64Sum);\n\n// Modify an Int32Array in-place\nconst modifyArray = new Int32Array([1, 2, 3, 4, 5]);\nconsole.log(\"Before modification:\", modifyArray);\nwasm.modify_i32_slice(modifyArray);\nconsole.log(\"After modification:\", modifyArray);\n\n// Get an Int32Array from Rust\nconst returnedArray = wasm.get_i32_slice();\nconsole.log(\"Returned i32 array:\", returnedArray);\n```\n\n----------------------------------------\n\nTITLE: Using Stack-Lifetime Closures with Imported JavaScript Functions in Rust\nDESCRIPTION: This snippet shows how to use stack-lifetime closures with imported JavaScript functions. It includes examples of passing both immutable and mutable closures to the imported functions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\ntakes_immutable_closure(&|| {\n    // ...\n});\n\nlet mut times_called = 0;\ntakes_mutable_closure(&mut || {\n    times_called += 1;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Communication in Rust\nDESCRIPTION: Rust implementation that demonstrates opening a WebSocket connection, setting up event listeners for message handling, error handling, and connection events. The code establishes a connection to an echo server, sends a ping message, and processes the response.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/websockets.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/websockets/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Synchronous WebAssembly Instantiation in JavaScript\nDESCRIPTION: This JavaScript code, running in a Web Worker, demonstrates synchronous WebAssembly instantiation. It fetches the Wasm file, compiles and instantiates it synchronously, and then calls the 'add' function from the Rust code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/synchronous-instantiation.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimportScripts(\"./pkg/synchronous_instantiation.js\");\n\nself.onmessage = async (e) => {\n  // We need to make sure that `wasm_bindgen` is ready to be used.\n  await wasm_bindgen();\n\n  // Since `wasm_bindgen(...)` function does not actually instantiate\n  // the Wasm module, but rather prepares it to be instantiated,\n  // we can use `wasm_bindgen.wasm` to get the underlying `WebAssembly.Module`.\n  console.log(wasm_bindgen.wasm);\n\n  // `WebAssembly.Module` can be instantiated synchronously.\n  const { instance } = new WebAssembly.Instance(wasm_bindgen.wasm, wasm_bindgen.imports);\n\n  // Instance exports is what `wasm_bindgen(...)` usually returns,\n  // so let's use it to initialize our exports.\n  wasm_bindgen.init(instance.exports);\n\n  // Now we can use our exports!\n  const result = wasm_bindgen.add(1, 2);\n  self.postMessage(result);\n};\n```\n\n----------------------------------------\n\nTITLE: Using wasm_bindgen attribute on async functions in Rust\nDESCRIPTION: The #[wasm_bindgen] attribute can now be used on async functions in Rust. This will automatically return a Promise on the JavaScript side.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_9\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\nasync fn my_async_function() {\n  // Async function body\n}\n```\n\n----------------------------------------\n\nTITLE: Counting Strings in a JavaScript Set using Rust and wasm-bindgen\nDESCRIPTION: This function demonstrates how to iterate over a JavaScript Set using wasm-bindgen. It counts the number of string elements in the set by converting the JavaScript iterator to a Rust iterator and checking each element's type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/iterating-over-js-values.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn count_strings_in_set(set: &js_sys::Set) -> u32 {\n    let mut count = 0;\n\n    // Call `keys` to get an iterator over the set's elements. Because this is\n    // in a `for ... in ...` loop, Rust will automatically call its\n    // `IntoIterator` trait implementation to convert it into a Rust iterator.\n    for x in set.keys() {\n        // We know the built-in iterator for set elements won't throw\n        // exceptions, so just unwrap the element. If this was an untrusted\n        // iterator, we might want to explicitly handle the case where it throws\n        // an exception instead of returning a `{ value, done }` object.\n        let x = x.unwrap();\n\n        // If `x` is a string, increment our count of strings in the set!\n        if x.is_string() {\n            count += 1;\n        }\n    }\n\n    count\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Async Functions in Rust WebAssembly\nDESCRIPTION: This example shows how to import JavaScript async functions into Rust using the extern \"C\" block with wasm_bindgen. It demonstrates importing functions with and without return values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-promises-and-rust-futures.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    async fn async_func_1_ret_number() -> JsValue;\n    async fn async_func_2();\n}\n\nasync fn get_from_js() -> f64 {\n    async_func_1_ret_number().await.as_f64().unwrap_or(0.0)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Rust Function for WebAssembly\nDESCRIPTION: This Rust code defines a simple function 'add' that takes two 32-bit integers and returns their sum. It's annotated with '#[wasm_bindgen]' to make it available to JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/synchronous-instantiation.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Bindings with Custom Types\nDESCRIPTION: Shows the resulting JavaScript code generated by wasm-bindgen when using unchecked type annotations. Includes JSDoc comments with the specified type information.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/unchecked_type.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * @param {Bar} arg1\n * @returns {Foo}\n */\nexport function foo(arg1) {\n    // ...\n}\n\nexport class Foo {\n    /**\n     * @param {Bar} arg1\n     * @returns {Baz}\n     */\n    foo(arg1) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Usage of WASM-Bindgen Exported Types\nDESCRIPTION: Shows how to consume and interact with Rust types exported via wasm-bindgen from JavaScript code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/exported-rust-types.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/exported_types.js}}\n```\n\n----------------------------------------\n\nTITLE: Using #[wasm_bindgen] Attribute for Rust Exports to JavaScript\nDESCRIPTION: The #[wasm_bindgen] attribute is used to customize how Rust functions and structs are exported to JavaScript when working with WebAssembly. This attribute allows developers to fine-tune the bindings between Rust and JavaScript code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/index.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\n```\n\n----------------------------------------\n\nTITLE: Applying getter_with_clone Attribute in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates two ways to use the `getter_with_clone` attribute: on a specific field and on an entire struct. This allows for more flexible getter generation when exposing Rust structs to JavaScript through wasm-bindgen.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/getter_with_clone.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct Foo {\n    #[wasm_bindgen(getter_with_clone)]\n    pub bar: String,\n}\n\n#[wasm_bindgen(getter_with_clone)]\npub struct Foo {\n    pub bar: String,\n    pub baz: String,\n}\n```\n\n----------------------------------------\n\nTITLE: Importing WebAssembly Module in Deno\nDESCRIPTION: Demonstrates how to import a WebAssembly module in Deno using TypeScript type annotations and ES module imports. This snippet shows the correct syntax for importing functions from a compiled WebAssembly module in a Deno environment.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/deployment.md#2025-04-16_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @deno-types=\"./out/crate_name.d.ts\"\nimport { yourFunction } from \"./out/crate_name.js\";\n```\n\n----------------------------------------\n\nTITLE: Implementing JavaScript Closure Support in Rust/WebAssembly Vector\nDESCRIPTION: Creates a wrapper around Vec<u32> that exposes an 'each' method to JavaScript, allowing iteration through vector elements using JavaScript callbacks. Uses js-sys::Function for JavaScript function handling and wasm-bindgen for WebAssembly interface generation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/receiving-js-closures-in-rust.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub struct VecU32 {\n    xs: Vec<u32>,\n}\n\n#[wasm_bindgen]\nimpl VecU32 {\n    pub fn each(&self, f: &js_sys::Function) {\n        let this = JsValue::null();\n        for &x in &self.xs {\n            let x = JsValue::from(x);\n            let _ = f.call1(&this, &x);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring web-sys Dependencies in Cargo.toml\nDESCRIPTION: Configuration for adding web-sys dependency with required DOM API features for browser interaction\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/without-a-bundler.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3.4\"\nfeatures = [\n  'Document',\n  'Element',\n  'HtmlElement',\n  'Node',\n  'Window',\n]\n```\n\n----------------------------------------\n\nTITLE: Implementing a Paint Application with Rust and WebAssembly\nDESCRIPTION: This Rust implementation creates a canvas element, applies CSS styling, adds it to the document, obtains a 2D rendering context, and sets up mouse event listeners to enable painting functionality in the browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/paint.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/paint/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for web-sys in Cargo.toml\nDESCRIPTION: This snippet shows how to set up dependencies in Cargo.toml for a Rust WebAssembly project that interacts with the DOM. It demonstrates how to depend on web-sys and activate the necessary features to enable DOM-related APIs.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/dom.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/dom/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation of Julia Set Fractal with WebAssembly Canvas Rendering\nDESCRIPTION: A Rust module that implements the Julia Set fractal algorithm and renders it to an HTML canvas using wasm-bindgen. It includes complex number operations, fractal calculation logic, and canvas manipulation code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/julia.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse std::ops::Add;\nuse std::ops::Mul;\nuse wasm_bindgen::prelude::*;\nuse wasm_bindgen::Clamped;\nuse web_sys::{CanvasRenderingContext2d, ImageData};\n\n// A macro to provide `println!(..)`-style syntax for `console.log` logging.\nmacro_rules! log {\n    ( $( $t:tt )* ) => {\n        web_sys::console::log_1(&format!( $( $t )* ).into());\n    }\n}\n\n#[wasm_bindgen(start)]\npub fn start() {\n    let document = web_sys::window().unwrap().document().unwrap();\n    let canvas = document.get_element_by_id(\"canvas\").unwrap();\n    let canvas: web_sys::HtmlCanvasElement = canvas\n        .dyn_into::<web_sys::HtmlCanvasElement>()\n        .map_err(|_| ())\n        .unwrap();\n\n    let context = canvas\n        .get_context(\"2d\")\n        .unwrap()\n        .unwrap()\n        .dyn_into::<web_sys::CanvasRenderingContext2d>()\n        .unwrap();\n\n    render(&context, 600, 600, -1.0, -1.0, 2.0, 2.0);\n}\n\n#[derive(Clone, Copy, Default)]\nstruct Complex {\n    a: f64,\n    b: f64,\n}\n\nimpl Complex {\n    fn new(a: f64, b: f64) -> Self {\n        let c = Self { a, b };\n        c\n    }\n\n    fn abs(&self) -> f64 {\n        (self.a * self.a + self.b * self.b).sqrt()\n    }\n\n    fn abs2(&self) -> f64 {\n        self.a * self.a + self.b * self.b\n    }\n}\n\nimpl Add for Complex {\n    type Output = Self;\n\n    fn add(self, other: Self) -> Self {\n        Self {\n            a: self.a + other.a,\n            b: self.b + other.b,\n        }\n    }\n}\n\nimpl Mul for Complex {\n    type Output = Self;\n\n    fn mul(self, other: Self) -> Self {\n        Self {\n            a: self.a * other.a - self.b * other.b,\n            b: self.a * other.b + self.b * other.a,\n        }\n    }\n}\n\nfn render(\n    context: &CanvasRenderingContext2d,\n    canvas_w: u32,\n    canvas_h: u32,\n    x_min: f64,\n    y_min: f64,\n    x_max: f64,\n    y_max: f64,\n) {\n    // The real meat of this example. We draw the Julia set for a given constant\n    // C.\n    let c = Complex::new(-0.15, 0.65);\n\n    let width = (x_max - x_min) as f64;\n    let height = (y_max - y_min) as f64;\n\n    let mut data = Vec::with_capacity((canvas_w * canvas_h * 4) as usize);\n\n    for y in 0..canvas_h {\n        let cy = y_min + (y_max - y_min) * (y as f64) / (canvas_h as f64);\n\n        for x in 0..canvas_w {\n            let cx = x_min + (x_max - x_min) * (x as f64) / (canvas_w as f64);\n            let mut z = Complex::new(cx, cy);\n\n            let mut i = 0;\n            while i < 255 && z.abs2() <= 4.0 {\n                z = z * z + c;\n                i += 1;\n            }\n\n            data.push(i);\n            data.push(i);\n            data.push(i);\n            data.push(255);\n        }\n    }\n\n    let data = ImageData::new_with_u8_clamped_array_and_sh(\n        Clamped(&mut data),\n        canvas_w,\n        canvas_h,\n    )\n    .unwrap();\n    context.put_image_data(&data, 0.0, 0.0).unwrap();\n}\n```\n\n----------------------------------------\n\nTITLE: Using Closure with Arguments and Return Value in Rust with wasm-bindgen\nDESCRIPTION: This snippet shows how to use a closure that takes an integer argument and returns a string with an imported JavaScript function. It demonstrates passing a closure that formats a string based on the input.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\ntakes_closure_that_takes_int_and_returns_string(&|x: u32| -> String {\n    format!(\"x is {}\", x)\n});\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Bindings for JavaScript Interop\nDESCRIPTION: The Rust code generated by wasm-bindgen to handle the JavaScript-to-Rust interface. It shows how pointers are managed, how reference cells are used for memory safety, and the implementation of the FFI layer.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust-struct.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// original input to `#[wasm_bindgen]` omitted ...\n\n#[export_name = \"foo_new\"]\npub extern \"C\" fn __wasm_bindgen_generated_Foo_new(arg0: i32) -> u32 {\n    let ret = Foo::new(arg0);\n    Box::into_raw(Box::new(WasmRefCell::new(ret))) as u32\n}\n\n#[export_name = \"foo_get\"]\npub extern \"C\" fn __wasm_bindgen_generated_Foo_get(me: u32) -> i32 {\n    let me = me as *mut WasmRefCell<Foo>;\n    wasm_bindgen::__rt::assert_not_null(me);\n    let me = unsafe { &*me };\n    return me.borrow().get();\n}\n\n#[export_name = \"foo_set\"]\npub extern \"C\" fn __wasm_bindgen_generated_Foo_set(me: u32, arg1: i32) {\n    let me = me as *mut WasmRefCell<Foo>;\n    wasm_bindgen::__rt::assert_not_null(me);\n    let me = unsafe { &*me };\n    me.borrow_mut().set(arg1);\n}\n\n#[no_mangle]\npub unsafe extern \"C\" fn __wbindgen_foo_free(me: u32) {\n    let me = me as *mut WasmRefCell<Foo>;\n    wasm_bindgen::__rt::assert_not_null(me);\n    (*me).borrow_mut(); // ensure no active borrows\n    drop(Box::from_raw(me));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Type Bindings in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates how to use unchecked_return_type and unchecked_param_type attributes to specify custom type annotations for JavaScript bindings. Shows implementation for both standalone functions and struct methods.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/unchecked_type.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(unchecked_return_type = \"Foo\")]\npub fn foo(\n    #[wasm_bindgen(unchecked_param_type = \"Bar\")]\n    arg1: JsValue,\n) -> JsValue {\n    // function body\n}\n\n#[wasm_bindgen]\npub struct Foo {\n    // properties\n}\n\n#[wasm_bindgen]\nimpl Foo {\n    #[wasm_bindgen(unchecked_return_type = \"Baz\")]\n    pub fn foo(\n        &self,\n        #[wasm_bindgen(unchecked_param_type = \"Bar\")]\n        arg1: JsValue,\n    ) -> JsValue {\n        // function body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation of Boxed Slice Handling\nDESCRIPTION: Rust code demonstrating how to work with boxed slices and vectors when interfacing with JavaScript through wasm-bindgen. Shows parameter passing and return value handling.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/boxed-slices.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/boxed_js_value_slice.rs}}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Usage of Rust Constructor\nDESCRIPTION: Shows how to use the Rust-defined constructor in JavaScript code by importing and instantiating the Foo class with the 'new' keyword.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/constructor.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Foo } from './my_module';\n\nconst f = new Foo();\nconsole.log(f.get_contents());\n```\n\n----------------------------------------\n\nTITLE: JavaScript Implementation Comparison for Structural vs Non-Structural Methods\nDESCRIPTION: Shows the difference between structural and non-structural method access in the generated JavaScript code. Demonstrates how structural access performs dynamic prototype chain walking versus static prototype access.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/structural.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Without `structural`, get the method directly off the prototype at load time:\nconst Duck_prototype_quack = Duck.prototype.quack;\nfunction quack(duck) {\n  Duck_prototype_quack.call(duck);\n}\n\n// With `structural`, walk the prototype chain on every access:\nfunction quack(duck) {\n  duck.quack();\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Rust Struct for JavaScript Export with js_name\nDESCRIPTION: Illustrates how to use js_name to rename a Rust struct for JavaScript export. The struct JsFoo is exported as Foo.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(js_name = Foo)]\npub struct JsFoo {\n    // ..\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Interface in Rust with wasm-bindgen\nDESCRIPTION: Shows how to define a TypeScript interface in Rust using custom sections and create corresponding Rust structs with wasm-bindgen bindings. Includes type definitions and constructor implementation for TextStyle struct that accepts TypeScript interface.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/typescript_type.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(typescript_custom_section)]\nconst ITEXT_STYLE: &'static str = r#\"\ninterface ITextStyle {\n    bold: boolean;\n    italic: boolean;\n    size: number;\n}\n\"#;\n\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(typescript_type = \"ITextStyle\")]\n    pub type ITextStyle;\n}\n\n#[wasm_bindgen]\n#[derive(Default)]\npub struct TextStyle {\n    pub bold: bool,\n    pub italic: bool,\n    pub size: i32,\n}\n\n#[wasm_bindgen]\nimpl TextStyle {\n    #[wasm_bindgen(constructor)]\n    pub fn new(i: ITextStyle) -> TextStyle {\n        let _js_value: JsValue = i.into();\n        // parse JsValue\n        TextStyle::default()\n    }\n\n    pub fn optional_new(_i: Option<ITextStyle>) -> TextStyle {\n        // parse JsValue\n        TextStyle::default()\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Dependencies in Cargo.toml\nDESCRIPTION: Cargo configuration file that enables necessary features for WebSocket functionality and event handling in wasm-bindgen.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/websockets.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/websockets/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Importing from Named Module in Rust WebAssembly\nDESCRIPTION: Demonstrates how to import items from a specific JavaScript module using the module attribute. This example shows importing a type from a custom module path.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/module.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"wu/tang/clan\")]\nextern \"C\" {\n    type ThirtySixChambers;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nimport { ThirtySixChambers } from \"wu/tang/clan\";\n```\n\n----------------------------------------\n\nTITLE: Using Rust-generated String Functions in JavaScript\nDESCRIPTION: This JavaScript code snippet shows how to use the Rust functions that handle strings after they've been compiled to WebAssembly. It demonstrates calling the functions and handling the returned values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/str.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/str.js}}\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Functions for Rust Import\nDESCRIPTION: JavaScript module defining functions that will be imported into Rust. Contains basic arithmetic, string manipulation, and class-based functionality.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/import-js.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// defined-in-js.js\nexport function foo(a) {\n    return a + 1;\n}\n\nexport class Bar {\n    constructor() {\n        this.internal = 3;\n    }\n\n    add(a) {\n        return a + this.internal;\n    }\n}\n\nexport class Content {\n    constructor() {\n        this.name = \"test\";\n    }\n}\n\nexport function get_content() {\n    return new Content();\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting Rust Function with Variadic Parameter to JavaScript\nDESCRIPTION: This snippet demonstrates how to export a Rust function with a variadic parameter to JavaScript. It uses the 'wasm_bindgen' attribute with 'variadic' and assumes the last argument will be the variadic array.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/variadic.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(variadic)]\npub  fn  variadic_function(arr: &JsValue) -> JsValue {\n\tarr.into()\n}\n```\n\n----------------------------------------\n\nTITLE: Fully Optimized JavaScript with Component Model\nDESCRIPTION: This JavaScript code represents the final optimized version after implementing both the reference types and component model proposals. It eliminates the need for a function shim entirely.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nexport const __wbg_bar_a81456386e6b526f = Foo.prototype.bar;\n```\n\n----------------------------------------\n\nTITLE: Basic JavaScript Namespace Binding in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates binding JavaScript console.log and a namespaced constructor using js_namespace attribute. Shows how to access functions and types through specific JavaScript namespaces.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_namespace.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n    \n    type Foo;\n    #[wasm_bindgen(constructor, js_namespace = Bar)]\n    fn new() -> Foo;\n}\n\nlog(\"hello, console!\");\nFoo::new();\n```\n\n----------------------------------------\n\nTITLE: Declaring JavaScript Constructor Binding in Rust\nDESCRIPTION: Demonstrates how to define an external JavaScript type and bind its constructor using wasm-bindgen. The constructor attribute indicates that the function should translate to the 'new' operator in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/constructor.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Shoes;\n\n    #[wasm_bindgen(constructor)]\n    fn new() -> Shoes;\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Number Slices in Rust for WebAssembly\nDESCRIPTION: This Rust code demonstrates how to work with various numeric slice types in a WebAssembly context. It includes functions for creating, modifying, and returning different number slices, showcasing the interoperability between Rust and JavaScript for these types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/number-slices.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn sum_f32_slice(slice: &[f32]) -> f32 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn sum_f64_slice(slice: &[f64]) -> f64 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn sum_i32_slice(slice: &[i32]) -> i32 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn sum_i64_slice(slice: &[i64]) -> i64 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn sum_u32_slice(slice: &[u32]) -> u32 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn sum_u64_slice(slice: &[u64]) -> u64 {\n    slice.iter().sum()\n}\n\n#[wasm_bindgen]\npub fn modify_i32_slice(slice: &mut [i32]) {\n    for item in slice.iter_mut() {\n        *item += 1;\n    }\n}\n\n#[wasm_bindgen]\npub fn get_i32_slice() -> Box<[i32]> {\n    vec![1, 2, 3, 4, 5].into_boxed_slice()\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Binding Code\nDESCRIPTION: Generated JavaScript shim that handles string conversion between JavaScript and WebAssembly, including memory management and UTF-8 encoding/decoding.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from './foo_bg';\\n\\nfunction passStringToWasm(arg) {\\n  const buf = new TextEncoder('utf-8').encode(arg);\\n  const len = buf.length;\\n  const ptr = wasm.__wbindgen_malloc(len, 1);\\n  let array = new Uint8Array(wasm.memory.buffer);\\n  array.set(buf, ptr);\\n  return [ptr, len];\\n}\\n\\nfunction getStringFromWasm(ptr, len) {\\n  const mem = new Uint8Array(wasm.memory.buffer);\\n  const slice = mem.slice(ptr, ptr + len);\\n  const ret = new TextDecoder('utf-8').decode(slice);\\n  return ret;\\n}\\n\\nexport function greet(arg0) {\\n  const [ptr0, len0] = passStringToWasm(arg0);\\n  try {\\n    const ret = wasm.greet(ptr0, len0);\\n    const ptr = wasm.__wbindgen_boxed_str_ptr(ret);\\n    const len = wasm.__wbindgen_boxed_str_len(ret);\\n    const realRet = getStringFromWasm(ptr, len);\\n    wasm.__wbindgen_boxed_str_free(ret);\\n    return realRet;\\n  } finally {\\n    wasm.__wbindgen_free(ptr0, len0, 1);\\n  }\\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Rust Function for JavaScript Export with js_name\nDESCRIPTION: Demonstrates how to use the js_name attribute to rename a Rust function to a camel-cased identifier in JavaScript. The function do_the_thing is exported as doTheThing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(js_name = doTheThing)]\npub fn do_the_thing() -> u32 {\n    42\n}\n```\n\n----------------------------------------\n\nTITLE: Using Exported Rust Async Function in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to import and use a Rust async function that has been exported as a JavaScript Promise. It shows the usage of the await keyword to handle the asynchronous operation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-promises-and-rust-futures.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { foo } from \"my-module\";\n\nasync function shim() {\n    const result = await foo();\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Async Main Function with wasm_bindgen in Rust\nDESCRIPTION: Shows how to use the wasm_bindgen main attribute with an async main function, enabling the use of await syntax in Cargo binaries.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/main.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(main)]\nasync fn main() {\n    // ...\n    future.await;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Class from Rust Struct\nDESCRIPTION: The JavaScript code generated by wasm-bindgen for the Rust struct. It shows how methods are exported, memory management with free(), and how static and instance methods are handled.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust-struct.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from './js_hello_world_bg';\n\nexport class Foo {\n    static __construct(ptr) {\n        return new Foo(ptr);\n    }\n\n    constructor(ptr) {\n        this.ptr = ptr;\n    }\n\n    free() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n        wasm.__wbg_foo_free(ptr);\n    }\n\n    static new(arg0) {\n        const ret = wasm.foo_new(arg0);\n        return Foo.__construct(ret)\n    }\n\n    get() {\n        const ret = wasm.foo_get(this.ptr);\n        return ret;\n    }\n\n    set(arg0) {\n        const ret = wasm.foo_set(this.ptr, arg0);\n        return ret;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Getter and Setter in Rust for WASM\nDESCRIPTION: Demonstrates basic implementation of a struct with getter and setter methods that will be exposed as JavaScript properties. Uses wasm_bindgen attributes to create a constructor and property accessors.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/getter-and-setter.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct Baz {\n    field: i32,\n}\n\n#[wasm_bindgen]\nimpl Baz {\n    #[wasm_bindgen(constructor)]\n    pub fn new(field: i32) -> Baz {\n        Baz { field }\n    }\n\n    #[wasm_bindgen(getter)]\n    pub fn field(&self) -> i32 {\n        self.field\n    }\n\n    #[wasm_bindgen(setter)]\n    pub fn set_field(&mut self, field: i32) {\n        self.field = field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Structure and Implementation with js_class Attribute\nDESCRIPTION: This snippet shows how to define a Rust structure and its implementation using the js_class attribute. It demonstrates creating a JsFoo struct with a constructor and a method, which will be attached to a JavaScript class named 'Foo'.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_class.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(js_name = Foo)]\npub struct JsFoo { /* ... */ }\n\n#[wasm_bindgen(js_class = Foo)]\nimpl JsFoo {\n    #[wasm_bindgen(constructor)]\n    pub fn new() -> JsFoo { /* ... */ }\n\n    pub fn foo(&self) { /* ... */ }\n}\n```\n\n----------------------------------------\n\nTITLE: Binding JavaScript Variadic Function in Rust for WebAssembly\nDESCRIPTION: This snippet shows how to bind a JavaScript variadic function in Rust for WebAssembly. It uses a slice as the last argument and annotates the function as variadic using the 'wasm_bindgen' attribute.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/variadic.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(variadic)]\n    fn sum(args: &[i32]) -> i32;\n}\n```\n\n----------------------------------------\n\nTITLE: Static String Binding in Rust\nDESCRIPTION: Example of importing JavaScript string literals directly as JsString to avoid TextDecoder/Encoder overhead.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(thread_local_v2, static_string)]\n    static STRING: JsString = \"a string literal\";\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Functions with Closure Parameters in Rust\nDESCRIPTION: This snippet demonstrates how to import JavaScript functions that accept closures as parameters using the #[wasm_bindgen] attribute. It shows declarations for functions taking both immutable and mutable closures.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    fn takes_immutable_closure(f: &dyn Fn());\n\n    fn takes_mutable_closure(f: &mut dyn FnMut());\n}\n```\n\n----------------------------------------\n\nTITLE: Using Constructor-Bound Function in Rust\nDESCRIPTION: Shows how to use the constructor-bound function in Rust code. This code will be translated to 'new Shoes()' in the generated JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/constructor.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n// Become a cobbler; construct `new Shoes()`\nlet shoes = Shoes::new();\n```\n\n----------------------------------------\n\nTITLE: Deserializing JsValue to Rust Data\nDESCRIPTION: This function shows how to receive a JsValue from JavaScript and deserialize it into a Rust Example struct using serde_wasm_bindgen::from_value.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn receive_example_from_js(val: JsValue) {\n    let example: Example = serde_wasm_bindgen::from_value(val).unwrap();\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing External JavaScript Module in Rust using wasm-bindgen\nDESCRIPTION: Demonstrates how to import functions from an external JavaScript file using the wasm_bindgen module attribute. The path specified must be relative to the crate root.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-snippets.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"/js/foo.js\")]\nextern \"C\" {\n    fn add(a: u32, b: u32) -> u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring WebAudio Dependencies in Cargo.toml\nDESCRIPTION: This snippet shows the Cargo.toml configuration for the WebAudio example. It enables the necessary features from the web-sys crate to use the WebAudio API.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/web-audio.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/webaudio/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Accessing Parent Classes Using Deref in Rust web-sys\nDESCRIPTION: Demonstrates how to use Deref to implicitly access methods from parent classes in the web-sys crate. This allows for ergonomic transitioning up the inheritance hierarchy.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/inheritance.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet element: &Element = ...;\n\nelement.append_child(..); // call a method on `Node`\n\nmethod_expecting_a_node(&element); // coerce to `&Node` implicitly\n\nlet node: &Node = &element; // explicitly coerce to `&Node`\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Timer Functions for Heap-Allocated Closures in Rust\nDESCRIPTION: This snippet demonstrates importing JavaScript timer functions (setInterval and clearInterval) and a logging function. These imports are used to work with heap-allocated closures in Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    fn setInterval(closure: &Closure<dyn FnMut()>, millis: u32) -> f64;\n    fn clearInterval(token: f64);\n\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Custom TypeScript Definitions Using Static String\nDESCRIPTION: Demonstrates how to add custom TypeScript type definitions to the generated .d.ts file using a static string constant. The content will be appended when using wasm-bindgen-cli with the --typescript flag.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/typescript_custom_section.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(typescript_custom_section)]\nconst TS_APPEND_CONTENT: &'static str = r#\"\n\nexport type Coords = { \"latitude\": number, \"longitude\": number, }; \n\n\"#;\n```\n\n----------------------------------------\n\nTITLE: Implementing IntoIterator for JavaScript Iterators\nDESCRIPTION: The IntoIterator trait implementation for JavaScript Iterator types allows iterating over JavaScript collections using Rust's for-loop syntax.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_16\n\nLANGUAGE: rust\nCODE:\n```\n// Using a JavaScript iterator in Rust\nlet js_array = js_sys::Array::new();\n// ...\nfor item in js_array.iter() {\n    // process each item\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Function with Closure Parameter and Return Value in Rust\nDESCRIPTION: This snippet demonstrates importing a JavaScript function that takes a closure with an integer argument and returns a string. It shows how to declare such a function using #[wasm_bindgen].\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/passing-rust-closures-to-js.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    fn takes_closure_that_takes_int_and_returns_string(x: &dyn Fn(u32) -> String);\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Character Type Implementation Example\nDESCRIPTION: Demonstrates the implementation of char type handling in Rust for WebAssembly bindings. Shows how characters are processed and returned between Rust and JavaScript environments.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/char.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/char.rs}}\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Class with Getter and Setter in JavaScript\nDESCRIPTION: Example of a JavaScript class 'TheDude' with a getter and setter for the 'white_russians' property.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/getter-and-setter.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nclass TheDude {\n  get white_russians() {\n    ...\n  }\n  set white_russians(val) {\n    ...\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing Rust Data to JsValue\nDESCRIPTION: This function demonstrates how to create an Example struct and serialize it to a JsValue using serde_wasm_bindgen::to_value for passing to JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn send_example_to_js() -> JsValue {\n    let mut field1 = HashMap::new();\n    field1.insert(0, String::from(\"ex\"));\n    let example = Example {\n        field1,\n        field2: vec![vec![1., 2.], vec![3., 4.]],\n        field3: [1., 2., 3., 4.]\n    };\n\n    serde_wasm_bindgen::to_value(&example).unwrap()\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Documented Rust Function with wasm-bindgen Attributes\nDESCRIPTION: This snippet demonstrates how to use `#[wasm_bindgen]` attributes to add return and parameter descriptions to a Rust function. The `add` function takes two u32 parameters and returns their sum, with each parameter and the return value documented.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/description.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n/// Adds `arg1` and `arg2`.\n#[wasm_bindgen(return_description = \"the result of the addition of `arg1` and `arg2`\")]\npub fn add(\n    #[wasm_bindgen(param_description = \"the first number\")]\n    arg1: u32,\n    #[wasm_bindgen(param_description = \"the second number\")]\n    arg2: u32,\n) -> u32 {\n    arg1 + arg2\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo.toml for WebGL in Rust and WebAssembly\nDESCRIPTION: This snippet shows the Cargo.toml configuration required to enable WebGL features for a Rust and WebAssembly project. It includes necessary dependencies and feature flags.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/webgl.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/webgl/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Error Handling with wasm_bindgen Main Attribute in Rust\nDESCRIPTION: Demonstrates how to use the wasm_bindgen main attribute to properly throw JavaScript errors from the Rust main function. The function returns a Result that can be converted into a JsValue error.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/main.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(main)]\nfn main() -> Result<(), JsValue> {\n    Err(JsValue::from(\"this error message will be thrown\"))\n}\n```\n\n----------------------------------------\n\nTITLE: Using web-sys Window API in Rust\nDESCRIPTION: Rust code example showing how to use the web-sys Window API to resize the browser window. Demonstrates proper error handling and WebAssembly function exports.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/using-web-sys.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\nuse web_sys::Window;\n\n#[wasm_bindgen]\npub fn make_the_window_small() {\n    // Resize the window to 500px by 500px.\n    let window = web_sys::window().unwrap();\n    window.resize_to(500, 500)\n        .expect(\"could not resize the window\");\n}\n```\n\n----------------------------------------\n\nTITLE: Rust External Type Import Example\nDESCRIPTION: Demonstrates importing and using JavaScript types in Rust code through WebAssembly bindings. Shows the supported parameter types and return value patterns.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/imported-js-types.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/imported_types.rs}}\n```\n\n----------------------------------------\n\nTITLE: Nested JavaScript Namespace Binding in Rust\nDESCRIPTION: Shows how to bind JavaScript functions that exist in nested namespaces using an array of strings in js_namespace attribute. Example demonstrates binding window.document.write.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_namespace.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = [\"window\", \"document\"])]\n    fn write(s: &str);\n}\n\nwrite(\"hello, document!\");\n```\n\n----------------------------------------\n\nTITLE: Demonstrating String Usage in Rust for WebAssembly\nDESCRIPTION: This Rust code snippet demonstrates how to handle strings in a Rust function that can be called from JavaScript via WebAssembly. It shows string parameter handling and return value creation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/str.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/str.rs}}\n```\n\n----------------------------------------\n\nTITLE: Checking JavaScript Property Existence with Reflect::has in Rust/WASM\nDESCRIPTION: Illustrates how to check if a property exists on a JavaScript object using js_sys::Reflect::has. This is equivalent to using the 'in' operator in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/accessing-properties-of-untyped-js-values.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nif js_sys::Reflect::has(&target, &property_key)? {\n    // ...\n} else {\n    // ...\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nif (property_key in target) {\n    // ...\n} else {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Declaring JavaScript Object Methods with wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates how to use the `method` attribute to declare a method of an imported JavaScript object. It shows the declaration of a `has` method for a `Set` type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/method.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Set;\n\n    #[wasm_bindgen(method)]\n    fn has(this: &Set, element: &JsValue) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Constructor Implementation in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates how to create a basic Rust struct with a constructor that can be called using 'new' syntax in JavaScript. The example shows a Foo struct with a contents field and methods for construction and access.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/constructor.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct Foo {\n    contents: u32,\n}\n\n#[wasm_bindgen]\nimpl Foo {\n    #[wasm_bindgen(constructor)]\n    pub fn new() -> Foo {\n        Foo { contents: 0 }\n    }\n\n    pub fn get_contents(&self) -> u32 {\n        self.contents\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Variadic Function in JavaScript\nDESCRIPTION: This snippet demonstrates how to create a variadic function in JavaScript that sums an arbitrary number of arguments. It shows both the old way using the 'arguments' object and the new way using rest parameters.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/variadic.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction sum(...rest) {\n    let i;\n    // the old way\n    let old_way = 0;\n    for (i=0; i<arguments.length; i++) {\n        old_way += arguments[i];\n    }\n    // the new way\n    let new_way = 0;\n    for (i=0; i<rest.length; i++) {\n        new_way += rest[i];\n    }\n    // both give the same answer\n    assert(old_way === new_way);\n    return new_way;\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing JavaScript Object in Rust\nDESCRIPTION: Rust code demonstrating how to access a JavaScript object using wasm-bindgen's thread_local_v2 attribute and JsValue.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(thread_local_v2)]\n    static COLORS: JsValue;\n}\n\nfn get_colors() -> JsValue {\n    COLORS.with(JsValue::clone)\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Implementation of Boxed Number Slice Handling\nDESCRIPTION: Demonstrates how to work with boxed number slices in Rust when interfacing with WebAssembly. The code shows handling of different numeric types through the wasm-bindgen interface.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/boxed-number-slices.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/boxed_number_slices.rs}}\n```\n\n----------------------------------------\n\nTITLE: Using Renamed Rust Function in JavaScript\nDESCRIPTION: Shows how to import and use the renamed Rust function in JavaScript. The function is imported as doTheThing and called accordingly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { doTheThing } from './my_module';\n\nconst x = doTheThing();\nconsole.log(x);\n```\n\n----------------------------------------\n\nTITLE: Loading and calling WebAssembly functions from JavaScript\nDESCRIPTION: JavaScript entry point that imports and initializes the WebAssembly module, then calls the exported greet() function from the Rust code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/hello-world.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/hello_world/index.js}}\n```\n\n----------------------------------------\n\nTITLE: Using TypeScript Types with WebAssembly Module\nDESCRIPTION: Demonstrates how to use the generated TypeScript types and construct TextStyle instances from TypeScript code. Shows both required and optional parameter usage.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/typescript_type.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ITextStyle, TextStyle } from \"./my_awesome_module\";\n\nconst style: TextStyle = new TextStyle({\n  bold: true,\n  italic: true,\n  size: 42,\n});\n\nconst optional_style: TextStyle = TextStyle.optional_new();\n```\n\n----------------------------------------\n\nTITLE: Using Result to Raise JavaScript Exceptions in Rust Functions\nDESCRIPTION: With wasm-bindgen, exported Rust functions can return a Result where the Err payload is raised as an exception in JavaScript, providing a natural error handling mechanism across language boundaries.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_12\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nfn function_that_might_fail() -> Result<(), JsValue> {\n    // If this returns Err, it will be raised as an exception in JavaScript\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Child Class Implementation\nDESCRIPTION: Shows how to properly extend a Rust-defined class in JavaScript, including the workaround needed for versions 0.2.48-0.2.87 of wasm-bindgen to handle prototype inheritance correctly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/constructor.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Parent } from './my_module';\n\nclass Child extends Parent {\n    constructor() {\n        super();\n        Object.setPrototypeOf(this, Child.prototype);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple Addition Function in Rust for WebAssembly\nDESCRIPTION: This Rust code defines a simple function 'add' that takes two i32 parameters and returns their sum. It uses the wasm_bindgen attribute to make it compatible with WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/add.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn add(a: i32, b: i32) -> i32 {\n    a + b\n}\n```\n\n----------------------------------------\n\nTITLE: Optional Static Binding in Rust\nDESCRIPTION: Example of using Option<T> to handle potentially undefined JavaScript values in static bindings.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" {\n    type Crypto;\n    #[wasm_bindgen(thread_local_v2, js_name = crypto)]\n    static CRYPTO: Option<Crypto>;\n}\n```\n\n----------------------------------------\n\nTITLE: Interacting with Rust-generated JsValue in JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates how to interact with JsValue objects created by Rust code compiled to WebAssembly. It shows calling Rust functions that accept and return JsValue types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/jsvalue.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/js_value.js}}\n```\n\n----------------------------------------\n\nTITLE: Implementing skip_typescript Attribute in Rust WASM\nDESCRIPTION: Shows how to use the skip_typescript attribute to exclude specific elements from TypeScript definition generation. Demonstrates usage on an enum, struct field, and method.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip_typescript.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(skip_typescript)]\npub enum MyHiddenEnum {\n    One,\n    Two,\n    Three\n}\n\n#[wasm_bindgen]\npub struct MyPoint {\n    pub x: u32,\n\n    #[wasm_bindgen(skip_typescript)]\n    pub y: u32,\n}\n\n#[wasm_bindgen]\nimpl MyPoint {\n\n    #[wasm_bindgen(skip_typescript)]\n    pub fn stringify(&self) -> String {\n        format!(\"({}, {})\", self.x, self.y)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing and Renaming JavaScript String Class in Rust with wasm-bindgen\nDESCRIPTION: This code snippet demonstrates how to import the JavaScript String class, rename it to JsString in Rust, and bind its charAt method. It uses the js_class attribute to specify the original JavaScript class name and the js_name attribute for renaming.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_class.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    // We don't want to import JS strings as `String`, since Rust already has a\n    // `String` type in its prelude, so rename it as `JsString`.\n    #[wasm_bindgen(js_name = String)]\n    type JsString;\n\n    // This is a method on the JavaScript \"String\" class, so specify that with\n    // the `js_class` attribute.\n    #[wasm_bindgen(method, js_class = \"String\", js_name = charAt)]\n    fn char_at(this: &JsString, index: u32) -> JsString;\n}\n```\n\n----------------------------------------\n\nTITLE: Custom Naming for Getter and Setter Methods in Rust with wasm-bindgen\nDESCRIPTION: Example of using custom method names for getter and setter while explicitly specifying the JavaScript property name.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/getter-and-setter.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type TheDude;\n\n    #[wasm_bindgen(method, getter = white_russians)]\n    fn my_custom_getter_name(this: &TheDude) -> u32;\n\n    #[wasm_bindgen(method, setter = white_russians)]\n    fn my_custom_setter_name(this: &TheDude, val: u32);\n}\n```\n\n----------------------------------------\n\nTITLE: Using wasm_bindgen Attribute Macro in Rust\nDESCRIPTION: Demonstrates the basic syntax of the #[wasm_bindgen] attribute macro used for WebAssembly bindings in Rust. This macro is essential for defining how Rust code interfaces with JavaScript through WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/index.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\n```\n\n----------------------------------------\n\nTITLE: Installing WebAssembly Target for Rust\nDESCRIPTION: Command to add the WebAssembly compilation target to Rust using rustup. This is required for compiling Rust code to WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/index.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nrustup target add wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Accessing Rust-defined JavaScript Class in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to import and use the Rust-defined 'Foo' class in JavaScript. It shows creating an instance of the class and calling its method.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_class.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Foo } from './my_module';\n\nconst x = new Foo();\nx.foo();\n```\n\n----------------------------------------\n\nTITLE: Block-level JavaScript Namespace Declaration\nDESCRIPTION: Demonstrates how to apply a namespace to an entire extern block when all items share the same namespace, reducing code duplication.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_namespace.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(js_namespace = Math)]\nextern \"C\" {\n    #[wasm_bindgen]\n    fn random() -> f64;\n    #[wasm_bindgen]\n    fn log(a: f64) -> f64;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating NonNull<T> Usage in Rust\nDESCRIPTION: This Rust code snippet showcases the usage of NonNull<T> type in a WebAssembly context. It includes functions for creating, manipulating, and converting NonNull<T> values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/non-null.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/non_null.rs}}\n```\n\n----------------------------------------\n\nTITLE: Interacting with Rust-generated Strings in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to interact with String values exposed by the Rust WebAssembly module. It shows calling Rust functions that return or accept strings, and manipulating these strings in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/string.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/string.js}}\n```\n\n----------------------------------------\n\nTITLE: Using Inspectable Struct in JavaScript\nDESCRIPTION: JavaScript example showing how to use the inspectable struct's generated toJSON and toString methods for debugging and serialization.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/inspectable.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = new Baz(3);\nassert.deepStrictEqual(obj.toJSON(), { field: 3 });\nobj.field = 4;\nassert.strictEqual(obj.toString(), '{\"field\":4}');\n```\n\n----------------------------------------\n\nTITLE: Defining FromWasmAbi Trait for JavaScript to Rust Conversion\nDESCRIPTION: This trait is used to convert JavaScript values to Rust. It defines an associated Abi type and a method to create Self from this Abi type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub trait FromWasmAbi: WasmDescribe {\n    type Abi: WasmAbi;\n    unsafe fn from_abi(js: Self::Abi) -> Self;\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Numeric Type Examples\nDESCRIPTION: Shows how to interact with Rust numeric types from JavaScript, including passing numbers and BigInts to Rust functions and handling returned numeric values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/numbers.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/numbers.js}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Worker Communication in Rust using wasm-bindgen\nDESCRIPTION: The Rust implementation defines a NumberEval struct for state management in the worker and a startup function for the main thread. It includes helper functions for setting up input callbacks and handling worker messages.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-web-worker.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../examples/wasm-in-web-worker/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Using js_sys::Function for Callback Type in web-sys\nDESCRIPTION: Example shows how callback types from WebIDL are represented as js_sys::Function in web-sys. You can either work directly with js_sys::Function or create a Closure<dyn FnMut> and convert it using JsCast::unchecked_ref.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/type-translations.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\njs_sys::Function\nClosure<dyn FnMut(...)>\nJsValue::as_ref()\nJsCast::unchecked_ref\n```\n\n----------------------------------------\n\nTITLE: Accessing Skipped Fields in JavaScript\nDESCRIPTION: Demonstrates the behavior of accessing struct fields in JavaScript where skipped fields are undefined. Shows that while you can shadow a skipped field with a new value, it won't affect the actual value in Rust memory.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport('./pkg/').then(rust => {\n    let foo = rust.Foo.new();\n    \n    // bar is accessible by getter\n    console.log(foo.bar);\n    // field marked with `skip` is undefined\n    console.log(foo.baz);      \n\n    // you can shadow it\n    foo.baz = 45;       \n    // so accessing by getter will return `45`\n    // but it won't affect real value in rust memory\n    console.log(foo.baz);\n});\n```\n\n----------------------------------------\n\nTITLE: Main Thread JavaScript for Loading Wasm and Starting Application\nDESCRIPTION: JavaScript code for the main thread that asynchronously loads the WebAssembly file and calls the startup entry point which creates a worker.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-web-worker.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/wasm-in-web-worker/index.js}}\n```\n\n----------------------------------------\n\nTITLE: Implementing Readonly Fields in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates how to create a struct with both readable/writable and readonly fields using wasm-bindgen. The example shows a Foo struct with a writable 'first' field and a readonly 'second' field.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/readonly.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn make_foo() -> Foo {\n    Foo {\n        first: 10,\n        second: 20,\n    }\n}\n\n#[wasm_bindgen]\npub struct Foo {\n    pub first: u32,\n\n    #[wasm_bindgen(readonly)]\n    pub second: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Polymorphic JavaScript Functions\nDESCRIPTION: Demonstrates using js_name to create multiple Rust functions that bind to the same JavaScript function with different signatures.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn console_log_str(s: &str);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn console_log_u32(n: u32);\n\n    #[wasm_bindgen(js_namespace = console, js_name = log)]\n    fn console_log_many(a: u32, b: &JsValue);\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Rust to Camel Case JavaScript Function\nDESCRIPTION: Demonstrates using js_name to bind a snake_case Rust function name to a camelCase JavaScript function name.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_name = jsOftenUsesCamelCase)]\n    fn js_often_uses_camel_case() -> u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Serialized Data in JavaScript\nDESCRIPTION: This JavaScript snippet demonstrates how to use the serialized data received from Rust, modify it, and send it back to Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { send_example_to_js, receive_example_from_js } from \"example\";\n\n// Get the example object from wasm.\nlet example = send_example_to_js();\n\n// Add another \"Vec\" element to the end of the \"Vec<Vec<f32>>\"\nexample.field2.push([5, 6]);\n\n// Send the example object back to wasm.\nreceive_example_from_js(example);\n```\n\n----------------------------------------\n\nTITLE: Custom-Named Getter and Setter Implementation in Rust\nDESCRIPTION: Shows how to customize the exported JavaScript property name for getters and setters using the wasm_bindgen attribute parameters.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/getter-and-setter.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nimpl Baz {\n    #[wasm_bindgen(getter = anotherName)]\n    pub fn field(&self) -> i32 {\n        self.field\n    }\n\n    #[wasm_bindgen(setter = anotherName)]\n    pub fn set_field(&mut self, field: i32) {\n        self.field = field;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Bindings for Imported Class\nDESCRIPTION: This JavaScript code shows the generated bindings for the imported 'Bar' class. It includes shims for the constructor, static method, instance methods, and property accessors.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js-struct.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from './foo_bg';\n\nimport { Bar } from './bar';\n\n// other support functions omitted...\n\nexport function __wbg_s_Bar_new() {\n  return addHeapObject(new Bar());\n}\n\nconst another_function_shim = Bar.another_function;\nexport function __wbg_s_Bar_another_function() {\n  return another_function_shim();\n}\n\nconst get_shim = Bar.prototype.get;\nexport function __wbg_s_Bar_get(ptr) {\n  return shim.call(getObject(ptr));\n}\n\nconst set_shim = Bar.prototype.set;\nexport function __wbg_s_Bar_set(ptr, arg0) {\n  set_shim.call(getObject(ptr), arg0)\n}\n\nconst property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').get;\nexport function __wbg_s_Bar_property(ptr) {\n  return property_shim.call(getObject(ptr));\n}\n\nconst set_property_shim = Object.getOwnPropertyDescriptor(Bar.prototype, 'property').set;\nexport function __wbg_s_Bar_set_property(ptr, arg0) {\n  set_property_shim.call(getObject(ptr), arg0)\n}\n```\n\n----------------------------------------\n\nTITLE: Renaming Function Parameters with js_name\nDESCRIPTION: Demonstrates how to rename function parameters using js_name. The parameter arg1 is renamed to firstArg in the JavaScript binding.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn foo(\n    #[wasm_bindgen(js_name = \"firstArg\")]\n    arg1: String,\n) {\n    // function body\n}\n\n#[wasm_bindgen]\npub struct Foo {\n    // properties\n}\n\n#[wasm_bindgen]\nimpl Foo {\n    pub fn foo(\n        &self,\n        #[wasm_bindgen(js_name = \"firstArg\")]\n        arg1: u32,\n    ) {\n        // function body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JsValue Struct Implementation in Rust\nDESCRIPTION: The implementation of JsValue in Rust, showing it as a simple wrapper around a u32 index with a Drop implementation that calls back to JavaScript to free the object reference when it goes out of scope.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\npub struct JsValue {\n    idx: u32,\n}\n\n// \"private\" constructors\n\nimpl Drop for JsValue {\n    fn drop(&mut self) {\n        unsafe {\n            __wbindgen_object_drop_ref(self.idx);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Readonly Fields from JavaScript\nDESCRIPTION: Shows how to interact with the Rust struct from JavaScript, demonstrating the difference between accessing regular and readonly fields. The readonly field can only be read, while regular fields can be both read and written.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/readonly.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { make_foo } from \"./my_module\";\n\nconst foo = make_foo();\n\n// Can both get and set `first`.\nfoo.first = 99;\nconsole.log(foo.first);\n\n// Can only get `second`.\nconsole.log(foo.second);\n```\n\n----------------------------------------\n\nTITLE: Conditional WebAssembly Function Definition\nDESCRIPTION: Demonstrates how to conditionally compile functions only for the WebAssembly target using cfg attributes.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/rust-targets.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(target_arch = \"wasm32\")]\n#[wasm_bindgen]\npub fn only_on_the_wasm_target() {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Dynamic Property Access in Rust with wasm-bindgen\nDESCRIPTION: This Rust code snippet shows how to use wasm-bindgen attributes (indexing_getter, indexing_setter, indexing_deleter) to bind JavaScript Proxy-like behavior. It defines methods for getting, setting, and deleting properties on a Foo type, which corresponds to the JavaScript Proxy example.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/indexing-getter-setter-deleter.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n    #[wasm_bindgen(thread_local_v2)]\n    static FOO: Foo;\n\n    #[wasm_bindgen(method, structural, indexing_getter)]\n    fn get(this: &Foo, prop: &str) -> u32;\n\n    #[wasm_bindgen(method, structural, indexing_setter)]\n    fn set(this: &Foo, prop: &str, val: u32);\n\n    #[wasm_bindgen(method, structural, indexing_deleter)]\n    fn delete(this: &Foo, prop: &str);\n}\n\nFOO.with(|foo| {\n    assert_eq!(foo.get(\"ten\"), 3);\n\n    foo.set(\"ten\", 10);\n    assert_eq!(foo.get(\"ten\"), 10);\n\n    foo.delete(\"ten\");\n    assert_eq!(foo.get(\"ten\"), 3);\n});\n```\n\n----------------------------------------\n\nTITLE: JavaScript Glue Code With Reference Types\nDESCRIPTION: Simplified JavaScript code generated when reference types support is enabled, demonstrating direct JS value passing to WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/reference-types.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nexport function takes_js_value(a) {\n    wasm.takes_js_value(a);\n}\n```\n\n----------------------------------------\n\nTITLE: Conditional wasm-bindgen Dependency Configuration\nDESCRIPTION: Shows how to configure wasm-bindgen as a target-specific dependency in Cargo.toml for better compile times.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/rust-targets.md#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[target.'cfg(target_arch = \"wasm32\")'.dependencies]\nwasm-bindgen = \"0.2\"\n```\n\n----------------------------------------\n\nTITLE: Using new JsValue methods in Rust\nDESCRIPTION: New is_truthy and is_falsy methods have been added to JsValue for checking truthiness/falsiness of JavaScript values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_11\n\nLANGUAGE: Rust\nCODE:\n```\nlet js_value: JsValue = /* ... */;\nif js_value.is_truthy() {\n  // Value is truthy\n}\nif js_value.is_falsy() {\n  // Value is falsy\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Getter and Setter in Rust with wasm-bindgen\nDESCRIPTION: Rust code using wasm-bindgen to import the 'TheDude' type and define getter and setter methods for the 'white_russians' property.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/getter-and-setter.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type TheDude;\n\n    #[wasm_bindgen(method, getter)]\n    fn white_russians(this: &TheDude) -> u32;\n\n    #[wasm_bindgen(method, setter)]\n    fn set_white_russians(this: &TheDude, val: u32);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Struct Field Skipping in Rust with wasm-bindgen\nDESCRIPTION: Defines a Rust struct with two public fields where one is marked to be skipped in JavaScript bindings. The `bar` field will be exposed to JS while the `baz` field marked with `skip` will not be accessible.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub struct Foo {\n    pub bar: u32,\n\n    #[wasm_bindgen(skip)]\n    pub baz: u32,\n}\n\n#[wasm_bindgen]\nimpl Foo {\n    pub fn new() -> Self {\n        Foo {\n            bar: 1,\n            baz: 2\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Namespace and Class\nDESCRIPTION: Example of JavaScript code exporting a namespace object and a class that will be accessed from Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nlet namespace = {\n    // Members of namespace...\n};\n\nclass SomeType {\n    // Definition of SomeType...\n};\n\nexport { SomeType, namespace };\n```\n\n----------------------------------------\n\nTITLE: JavaScript Usage of Rust Boxed Slices\nDESCRIPTION: JavaScript code showing how to interact with Rust functions that accept or return boxed slices and vectors. Demonstrates the JavaScript Array representation of Rust collections.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/boxed-slices.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/boxed_js_value_slice.js}}\n```\n\n----------------------------------------\n\nTITLE: Using the extends Attribute for JavaScript Inheritance\nDESCRIPTION: The #[wasm_bindgen(extends = ...)] attribute describes inheritance relationships between JavaScript types, enabling proper type casting and method access.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_14\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(extends = EventTarget)]\nextern \"C\" {\n    type Node;\n    \n    #[wasm_bindgen(extends = Node)]\n    type Element;\n    \n    #[wasm_bindgen(extends = Element)]\n    type HtmlElement;\n}\n```\n\n----------------------------------------\n\nTITLE: Deriving Serialize and Deserialize Traits in Rust\nDESCRIPTION: This code demonstrates how to derive Serialize and Deserialize traits for a struct in Rust, enabling it to be serialized and deserialized with Serde.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize)]\npub struct Example {\n    pub field1: HashMap<u32, String>,\n    pub field2: Vec<Vec<f32>>,\n    pub field3: [f32; 4],\n}\n```\n\n----------------------------------------\n\nTITLE: Using Rust-Generated Getters and Setters in JavaScript\nDESCRIPTION: Shows how to use the Rust-implemented getter and setter methods from JavaScript code. Creates an object instance and demonstrates property access and modification.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/getter-and-setter.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst obj = new Baz(3);\nassert.equal(obj.field, 3);\nobj.field = 4;\nassert.equal(obj.field, 4);\n```\n\n----------------------------------------\n\nTITLE: Using String Values with wasm_bindgen Enums\nDESCRIPTION: Demonstrates how to use string values with enums annotated with #[wasm_bindgen].\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_7\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\nenum MyEnum {\n    #[wasm_bindgen(js_name = \"optionA\")]\n    OptionA,\n    #[wasm_bindgen(js_name = \"optionB\")]\n    OptionB,\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Rust Function for WebAssembly Export\nDESCRIPTION: Defines a simple Rust function that takes a string parameter and returns a formatted string. This function will be exported to JavaScript using wasm-bindgen.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\\npub fn greet(a: &str) -> String {\\n    format!(\"Hello, {}!\", a)\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Type Hierarchy with extends Attribute in Rust for wasm-bindgen\nDESCRIPTION: This snippet demonstrates how to use the 'extends' attribute to define a simple type hierarchy between Foo and Bar. It shows how to declare the types and how the resulting conversions can be used.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/extends.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n\n    #[wasm_bindgen(extends = Foo)]\n    type Bar;\n}\n\nlet x: &Bar = ...;\nlet y: &Foo = x.as_ref(); // zero cost cast\n```\n\n----------------------------------------\n\nTITLE: Individual JavaScript Namespace Declarations\nDESCRIPTION: Example showing how to bind multiple JavaScript Math functions with individual namespace declarations.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_namespace.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = Math)]\n    fn random() -> f64;\n    #[wasm_bindgen(js_namespace = Math)]\n    fn log(a: f64) -> f64;\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Trait Implementations for Type Hierarchy in Rust\nDESCRIPTION: This snippet shows the trait implementations that are automatically generated by wasm-bindgen when using the 'extends' attribute. It includes From, AsRef, and AsMut implementations for the defined type hierarchy.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/extends.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl From<Bar> for Foo { ... }\nimpl AsRef<Foo> for Bar { ... }\nimpl AsMut<Foo> for Bar { ... }\n```\n\n----------------------------------------\n\nTITLE: Rust Boolean Type Example\nDESCRIPTION: Demonstrates boolean type usage in Rust with WebAssembly bindings. Shows parameter passing and return value handling for boolean types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/bool.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/bool.rs}}\n```\n\n----------------------------------------\n\nTITLE: Attaching Methods to Renamed Struct using js_class\nDESCRIPTION: Shows how to attach methods to a renamed struct using the js_class attribute. Methods for JsFoo are attached to the JavaScript class Foo.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(js_name = Foo)]\npub struct JsFoo { /* ... */ }\n\n#[wasm_bindgen(js_class = Foo)]\nimpl JsFoo {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Binding JavaScript Namespace and Class in Rust\nDESCRIPTION: Rust code showing how to bind to exported JavaScript namespace and class using wasm-bindgen module imports.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"/js/some-rollup.js\")]\nextern \"C\" {\n    // Likewise with the namespace--this refers to the object directly.\n    #[wasm_bindgen(thread_local_v2, js_name = namespace)]\n    static NAMESPACE: JsValue;\n\n    // Refer to SomeType's class\n    #[wasm_bindgen(thread_local_v2, js_name = SomeType)]\n    static SOME_TYPE: JsValue;\n\n    // Other bindings for SomeType\n    type SomeType;\n    #[wasm_bindgen(constructor)]\n    fn new() -> SomeType;\n}\n```\n\n----------------------------------------\n\nTITLE: Global Scope Import in Rust WebAssembly\nDESCRIPTION: Shows how to import from the global JavaScript scope when no module attribute is specified. The function is imported directly from the global this context.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/module.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    fn illmatic() -> u32;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\nlet illmatic = this.illmatic;\n```\n\n----------------------------------------\n\nTITLE: JavaScript Glue Code for Julia Set WebAssembly Example\nDESCRIPTION: A JavaScript file that loads and initializes the WebAssembly module for rendering the Julia Set fractal. It handles the module instantiation and calls the render function from the Rust code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/julia.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport('./pkg')\n  .catch(console.error);\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Function Using raw_module Attribute in Rust\nDESCRIPTION: This snippet demonstrates how to use the raw_module attribute in wasm-bindgen to import a JavaScript function from a specific file. The attribute specifies the exact path to the JavaScript file without any interpretation of the path.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/raw_module.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(raw_module = \"./some/js/file.js\")]\nextern \"C\" {\n    fn the_function();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Structural Method Access in Rust with wasm-bindgen\nDESCRIPTION: Demonstrates how to define structural methods and properties for a JavaScript type using wasm-bindgen. Shows the declaration of a Duck type with structural methods for quacking and checking swimming status.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/structural.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Duck;\n\n    #[wasm_bindgen(method, structural)]\n    fn quack(this: &Duck);\n\n    #[wasm_bindgen(method, getter, structural)]\n    fn is_swimming(this: &Duck) -> bool;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the bound Date.now() static method in Rust\nDESCRIPTION: This snippet shows how to use the bound `Date.now()` static method in Rust code. It demonstrates that the `now()` function becomes a static method of the imported `Date` type in Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/static_method_of.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet instant = Date::now();\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation for web-sys Cargo Features\nDESCRIPTION: Explains the feature requirements for using web-sys types and methods, using WebGlRenderingContext.compile_shader as an example. Shows that accessing a method requires enabling features for both the self type and argument types.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/cargo-features.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Cargo Features in `web-sys`\n\nTo keep `web-sys` building as fast as possible, there is a cargo feature for\nevery type defined in `web-sys`. To access that type, you must enable its\nfeature. To access a method, you must enable the feature for its `self` type and\nthe features for each of its argument types. In the [API documentation][], every\nmethod lists the features that are required to enable it.\n\nFor example, [the `WebGlRenderingContext::compile_shader` function][compile_shader] requires these features:\n\n* `WebGlRenderingContext`, because that is the method's `self` type\n* `WebGlShader`, because it takes an argument of that type\n\n[API documentation]: https://rustwasm.github.io/wasm-bindgen/api/web_sys\n[compile_shader]: https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.WebGlRenderingContext.html#method.compile_shader\n```\n\n----------------------------------------\n\nTITLE: Importing a JavaScript Function into Rust with wasm-bindgen\nDESCRIPTION: Declaration of an external JavaScript function in Rust using the wasm_bindgen attribute. The module attribute specifies which JavaScript module to import from, and the extern block declares the function signature.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"./greet\")]\nextern \"C\" {\n    fn greet(a: &str) -> String;\n}\n\nfn other_code() {\n    let greeting = greet(\"foo\");\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Class in Rust with wasm-bindgen\nDESCRIPTION: This Rust code demonstrates how to import a JavaScript class 'Bar' using wasm-bindgen. It shows the syntax for declaring the class type, constructor, static method, instance methods, and property getters/setters.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js-struct.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"./bar\")]\nextern \"C\" {\n    type Bar;\n\n    #[wasm_bindgen(constructor)]\n    fn new(arg: i32) -> Bar;\n\n    #[wasm_bindgen(js_namespace = Bar)]\n    fn another_function() -> i32;\n\n    #[wasm_bindgen(method)]\n    fn get(this: &Bar) -> i32;\n\n    #[wasm_bindgen(method)]\n    fn set(this: &Bar, val: i32);\n\n    #[wasm_bindgen(method, getter)]\n    fn property(this: &Bar) -> i32;\n\n    #[wasm_bindgen(method, setter)]\n    fn set_property(this: &Bar, val: i32);\n}\n\nfn run() {\n    let bar = Bar::new(Bar::another_function());\n    let x = bar.get();\n    bar.set(x + 3);\n\n    bar.set_property(bar.property() + 6);\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Binding for Default Export\nDESCRIPTION: Demonstrates how to bind to a JavaScript module's default export using js_name and js_class attributes.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(module = \"bar\")]\nextern \"C\" {\n    #[wasm_bindgen(js_name = default)]\n    type Foo;\n    #[wasm_bindgen(constructor, js_class = default)]\n    pub fn new() -> Foo;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring web-sys Dependencies in Cargo.toml\nDESCRIPTION: Initial Cargo.toml configuration for adding web-sys and wasm-bindgen dependencies to a Rust project. Sets up the basic structure for enabling specific web-sys features.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/using-web-sys.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nwasm-bindgen = \"0.2\"\n\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n]\n```\n\n----------------------------------------\n\nTITLE: Binding JavaScript's Date.now() static method using wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates how to use the `static_method_of` attribute to bind JavaScript's `Date.now()` static method to Rust. It defines an external type `Date` and a static method `now()` that returns a float.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/static_method_of.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Date;\n\n    #[wasm_bindgen(static_method_of = Date)]\n    pub fn now() -> f64;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining AudioContext with Webkit Vendor Prefix in Rust WebAssembly\nDESCRIPTION: This code snippet demonstrates how to use the vendor_prefix attribute in wasm-bindgen to define the AudioContext type with a webkit fallback. It allows the code to work with both standard and webkit-prefixed versions of the API.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/vendor_prefix.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(vendor_prefix = webkit)]\n    type AudioContext;\n\n    // methods on `AudioContext` ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Exportable JavaScript Module Function\nDESCRIPTION: Shows how to write a JavaScript module that exports functions for use with wasm-bindgen. The code must use ES module syntax with export statements.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-snippets.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport function add(a, b) {\n    return a + b;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Shim for Imported Function\nDESCRIPTION: Rust code generated by wasm-bindgen that creates a wrapper around the imported JavaScript function. It handles converting Rust string parameters to raw pointers and lengths for WebAssembly, and reconstructs returned strings from pointers and lengths.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern \"C\" fn greet(a: &str) -> String {\n    extern \"C\" {\n        fn __wbg_f_greet(a_ptr: *const u8, a_len: usize, ret_len: *mut usize) -> *mut u8;\n    }\n    unsafe {\n        let a_ptr = a.as_ptr();\n        let a_len = a.len();\n        let mut __ret_strlen = 0;\n        let mut __ret_strlen_ptr = &mut __ret_strlen as *mut usize;\n        let _ret = __wbg_f_greet(a_ptr, a_len, __ret_strlen_ptr);\n        String::from_utf8_unchecked(\n            Vec::from_raw_parts(_ret, __ret_strlen, __ret_strlen)\n        )\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Character Handling Example\nDESCRIPTION: Shows how characters are handled on the JavaScript side when interacting with Rust WebAssembly code. Demonstrates the string representation of characters in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/char.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/char.js}}\n```\n\n----------------------------------------\n\nTITLE: Rust Function Using JsValue Reference\nDESCRIPTION: A Rust function decorated with wasm_bindgen that takes a reference to a JsValue parameter.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/reference-types.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn takes_js_value(a: &JsValue) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Importing JavaScript Functions with Result in Rust-WebAssembly\nDESCRIPTION: When importing a JavaScript function that returns a Result in Rust, the #[wasm_bindgen(catch)] annotation is required on the import. This enables proper exception handling and conversion to the Result type in Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/result.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(catch)]\n```\n\n----------------------------------------\n\nTITLE: Listing web-sys Fetch Function Overloads in Rust\nDESCRIPTION: This snippet lists the different function overloads provided by web-sys for the 'fetch' API. It shows how web-sys handles different argument combinations for the Window::fetch method.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/function-overloads.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nWindow::fetch_with_str\nWindow::fetch_with_request\nWindow::fetch_with_str_and_init\nWindow::fetch_with_request_and_init\n```\n\n----------------------------------------\n\nTITLE: Loading WebAssembly Using no-modules Approach\nDESCRIPTION: HTML template demonstrating how to load WebAssembly and JavaScript code using the older --target no-modules approach\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/without-a-bundler.md#2025-04-16_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n{{#include ../../../examples/without-a-bundler-no-modules/index.html}}\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Colors Object\nDESCRIPTION: Example of defining a static JavaScript object containing RGB color values that will be accessed from Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/static-js-objects.md#2025-04-16_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nlet COLORS = {\n    red: 'rgb(255, 0, 0)',\n    green: 'rgb(0, 255, 0)',\n    blue: 'rgb(0, 0, 255)',\n};\n```\n\n----------------------------------------\n\nTITLE: Building a WebXR example with wasm-bindgen in Bash\nDESCRIPTION: Command to build and serve a WebXR example using Rust and wasm-bindgen. It requires the unstable flag since WebXR is in development, and runs the npm serve script to launch a local development server on port 8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/webxr/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Note: Requires unstable flag whilst WebXR in development\n$ RUSTFLAGS=--cfg=web_sys_unstable_apis npm run serve\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Shim for Imported Function\nDESCRIPTION: JavaScript code generated by wasm-bindgen that imports the actual JavaScript function and creates a bridge function that handles parameter and return value conversion between JavaScript and WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from './foo_bg';\n\nimport { greet } from './greet';\n\n// ...\n\nexport function __wbg_f_greet(ptr0, len0, wasmretptr) {\n  const [retptr, retlen] = passStringToWasm(greet(getStringFromWasm(ptr0, len0)));\n  (new Uint32Array(wasm.memory.buffer))[wasmretptr / 4] = retlen;\n  return retptr;\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Boolean Interaction\nDESCRIPTION: Shows JavaScript code interacting with Rust-compiled WebAssembly functions using boolean values. Demonstrates proper boolean value passing and handling.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/bool.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/bool.js}}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Bindings with Renamed Parameters\nDESCRIPTION: Shows the resulting JavaScript bindings generated from the Rust code with renamed parameters. Both standalone function and method parameters are renamed.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * @param {string} firstArg\n */\nexport function foo(firstArg) {\n    // ...\n}\n\nexport class Foo {\n    /**\n     * @param {number} firstArg\n     */\n    foo(firstArg) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Reading JavaScript Properties with Reflect::get in Rust/WASM\nDESCRIPTION: Demonstrates how to read a property from a JavaScript object using js_sys::Reflect::get. This is equivalent to using bracket notation property access in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/accessing-properties-of-untyped-js-values.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet value = js_sys::Reflect::get(&target, &property_key)?;\n```\n\nLANGUAGE: javascript\nCODE:\n```\nlet value = target[property_key];\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust External Function with Final Attribute\nDESCRIPTION: This snippet demonstrates how to use the `final` attribute in a Rust external function definition with wasm-bindgen. It declares the same `Foo` type and `bar` method, but with the `final` attribute for optimization.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n    #[wasm_bindgen(method, final)] // note the change here\n    fn bar(this: &Foo, argument: &str) -> JsValue;\n}\n```\n\n----------------------------------------\n\nTITLE: Basic usage of wasm-bindgen CLI\nDESCRIPTION: This command demonstrates the basic usage of the wasm-bindgen CLI tool. It processes a WebAssembly file, typically output from compiling a Rust crate, with various options available to customize the output.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/cli.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nwasm-bindgen [options] ./target/wasm32-unknown-unknown/release/crate.wasm\n```\n\n----------------------------------------\n\nTITLE: Configuring Project Dependencies in Cargo.toml for a WebAssembly Paint Application\nDESCRIPTION: This Cargo.toml configuration enables features necessary for the paint application to work with the DOM, events, and 2D canvas through wasm-bindgen and its features.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/paint.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/paint/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Implementation for Imported Class\nDESCRIPTION: This Rust code shows the generated implementation for the imported 'Bar' class. It includes the struct definition, constructor, and method implementations that call the external JavaScript functions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/importing-js-struct.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\npub struct Bar {\n    obj: JsValue,\n}\n\nimpl Bar {\n    fn new() -> Bar {\n        extern \"C\" {\n            fn __wbg_s_Bar_new() -> u32;\n        }\n        unsafe {\n            let ret = __wbg_s_Bar_new();\n            Bar { obj: JsValue::__from_idx(ret) }\n        }\n    }\n\n    fn another_function() -> i32 {\n        extern \"C\" {\n            fn __wbg_s_Bar_another_function() -> i32;\n        }\n        unsafe {\n            __wbg_s_Bar_another_function()\n        }\n    }\n\n    fn get(&self) -> i32 {\n        extern \"C\" {\n            fn __wbg_s_Bar_get(ptr: u32) -> i32;\n        }\n        unsafe {\n            let ptr = self.obj.__get_idx();\n            let ret = __wbg_s_Bar_get(ptr);\n            return ret\n        }\n    }\n\n    fn set(&self, val: i32) {\n        extern \"C\" {\n            fn __wbg_s_Bar_set(ptr: u32, val: i32);\n        }\n        unsafe {\n            let ptr = self.obj.__get_idx();\n            __wbg_s_Bar_set(ptr, val);\n        }\n    }\n\n    fn property(&self) -> i32 {\n        extern \"C\" {\n            fn __wbg_s_Bar_property(ptr: u32) -> i32;\n        }\n        unsafe {\n            let ptr = self.obj.__get_idx();\n            let ret = __wbg_s_Bar_property(ptr);\n            return ret\n        }\n    }\n\n    fn set_property(&self, val: i32) {\n        extern \"C\" {\n            fn __wbg_s_Bar_set_property(ptr: u32, val: i32);\n        }\n        unsafe {\n            let ptr = self.obj.__get_idx();\n            __wbg_s_Bar_set_property(ptr, val);\n        }\n    }\n}\n\nimpl WasmBoundary for Bar {\n    // ...\n}\n\nimpl ToRefWasmBoundary for Bar {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Using Inline JavaScript with wasm-bindgen\nDESCRIPTION: Demonstrates how to include JavaScript code directly in Rust source using the inline_js attribute. This approach is primarily intended for macro authors rather than hand-written code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/js-snippets.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(inline_js = \"export function add(a, b) { return a + b; }\")]\nextern \"C\" {\n    fn add(a: u32, b: u32) -> u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining IntoWasmAbi Trait for Rust to JavaScript Conversion\nDESCRIPTION: This trait is used to convert Rust values to JavaScript. It defines an associated Abi type and a method to convert self into this Abi type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait IntoWasmAbi: WasmDescribe {\n    type Abi: WasmAbi;\n    fn into_abi(self) -> Self::Abi;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Automatic WebAssembly Module Initialization in Rust\nDESCRIPTION: Demonstrates how to define a function that automatically executes when a WebAssembly module is instantiated using the start attribute. The function must take no arguments and return either () or Result<(), JsValue>. Only one start function can exist across the entire module and its dependencies.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/start.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(start)]\nfn start() {\n    // executed automatically ...\n}\n```\n\n----------------------------------------\n\nTITLE: Timing JavaScript Function Execution in Rust using js-sys\nDESCRIPTION: Example demonstrating how to measure execution time of JavaScript Function callbacks using js_sys::Date::now(). The code creates a Rust function that accepts a JavaScript Function as input, executes it, and returns the elapsed time in milliseconds.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/js-sys/index.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub fn timed(callback: &js_sys::Function) -> f64 {\n    let then = js_sys::Date::now();\n    callback.apply(JsValue::null(), &js_sys::Array::new()).unwrap();\n    let now = js_sys::Date::now();\n    now - then\n}\n```\n\n----------------------------------------\n\nTITLE: Defining RefFromWasmAbi Trait for JavaScript to Rust Reference Conversion\nDESCRIPTION: This trait is used to create shared references from JavaScript values. It defines Abi and Anchor types, with a method to create an Anchor from the Abi type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\npub trait RefFromWasmAbi: WasmDescribe {\n    type Abi: WasmAbi;\n    type Anchor: Deref<Target=Self>;\n    unsafe fn ref_from_abi(js: Self::Abi) -> Self::Anchor;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Test Environment with Rust Macros\nDESCRIPTION: Using wasm_bindgen_test_configure macro to force tests to run in specific environments like browsers or workers.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/browsers.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen_test::wasm_bindgen_test_configure;\n\n// Run in a browser.\nwasm_bindgen_test_configure!(run_in_browser);\n// Or run in a dedicated worker.\nwasm_bindgen_test_configure!(run_in_dedicated_worker);\n// Or run in a shared worker.\nwasm_bindgen_test_configure!(run_in_shared_worker);\n// Or run in a service worker.\nwasm_bindgen_test_configure!(run_in_service_worker);\n// Or run in Node.js but as an ES module.\nwasm_bindgen_test_configure!(run_in_node_experimental);\n```\n\n----------------------------------------\n\nTITLE: Adding a Web API Interface to web-sys\nDESCRIPTION: Instructions for adding a new Web API interface to the web-sys crate, including finding WebIDL specifications, annotating functions, generating binding code, and documenting changes in the changelog.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/web-sys/README.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n1. Copy the WebIDL specification of the API and place it in a new file in the\n   `webidls/unstable` folder. You can often find the IDL by going to the MDN\n   docs page for the API, scrolling to the bottom, clicking the\n   \"Specifications\" link, and scrolling to the bottom of the specification\n   page. For example, the bottom of the [MDN\n   docs](https://developer.mozilla.org/en-US/docs/Web/API/MediaSession) on the\n   MediaSession API takes you to the\n   [spec](https://w3c.github.io/mediasession/#the-mediasession-interface). The\n   [very bottom](https://w3c.github.io/mediasession/#idl-index) of _that_ page\n   is the IDL.\n2. Annotate the functions that can throw with `[Throws]`\n3. `cd crates/web-sys`\n4. Run `cargo run --release --package wasm-bindgen-webidl -- webidls src/features ./Cargo.toml`\n5. Run `git add .` to add all the generated files into git.\n6. Add an entry in CHANGELOG.md like the following\n\n   ```md\n   ...\n\n   ## Unreleased\n\n   ### Added\n\n   ...\n\n   * Added <your addition>\n     [#1234](https://github.com/rustwasm/wasm-bindgen/pull/1234) # <- link to your PR\n   ```\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Binding for Borrowed JS References\nDESCRIPTION: The generated Rust code for handling borrowed JavaScript values, showing how the exported WebAssembly function takes a numeric index, converts it to a JsValue reference, and calls the original function.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n// what the user wrote\npub fn foo(a: &JsValue) {\n    // ...\n}\n\n#[export_name = \"foo\"]\npub extern \"C\" fn __wasm_bindgen_generated_foo(arg0: u32) {\n    let arg0 = unsafe {\n        ManuallyDrop::new(JsValue::__from_idx(arg0))\n    };\n    let arg0 = &*arg0;\n    foo(arg0);\n}\n```\n\n----------------------------------------\n\nTITLE: Cross-Platform Addition Function with wasm-bindgen\nDESCRIPTION: Demonstrates a simple addition function using wasm_bindgen that works on both WebAssembly and native platforms. Includes a main function that only runs on non-wasm targets.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/rust-targets.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn add(a: u32, b: u32) -> u32 {\n    a + b\n}\n\n#[cfg(not(target_arch = \"wasm32\"))]\nfn main() {\n    println!(\"1 + 2 = {}\", add(1, 2));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining WasmSlice Struct for FFI String Representation\nDESCRIPTION: WasmSlice is a struct used to represent strings in FFI. It contains a pointer and a length, both as u32 values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\npub struct WasmSlice {\n    pub ptr: u32,\n    pub len: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Rust Parent Class Definition\nDESCRIPTION: Example of defining a Parent struct in Rust with a constructor that can be inherited from in JavaScript. Demonstrates proper wasm-bindgen setup for inheritance.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/constructor.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n#[wasm_bindgen]\npub struct Parent {\n    msg: String,\n}\n\n#[wasm_bindgen]\nimpl Parent {\n    #[wasm_bindgen(constructor)]\n    fn new() -> Self {\n        Parent {\n            msg: String::from(\"Hello from Parent!\"),\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining an Inspectable Rust Struct\nDESCRIPTION: Example of creating a Rust struct with the inspectable attribute to expose fields to JavaScript. The struct has both public and private fields with a constructor implementation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/inspectable.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(inspectable)]\npub struct Baz {\n    pub field: i32,\n    private: i32,\n}\n\n#[wasm_bindgen]\nimpl Baz {\n    #[wasm_bindgen(constructor)]\n    pub fn new(field: i32) -> Baz {\n        Baz { field, private: 13 }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple Inheritance with extends Attribute in Rust for wasm-bindgen\nDESCRIPTION: This snippet demonstrates how to use the 'extends' attribute multiple times to define a more complex type hierarchy involving Foo, Bar, and Baz. It shows how to declare the types and how the resulting conversions can be used in a chain.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/extends.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n\n    #[wasm_bindgen(extends = Foo)]\n    type Bar;\n\n    #[wasm_bindgen(extends = Foo, extends = Bar)]\n    type Baz;\n}\n\nlet x: &Baz = ...;\nlet y1: &Bar = x.as_ref();\nlet y2: &Foo = y1.as_ref();\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Tests Manually with Cargo\nDESCRIPTION: These commands show how to run WebAssembly tests manually using Cargo, including an option for running doctests on the nightly Rust channel.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --target wasm32-unknown-unknown\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo +nightly test --target wasm32-unknown-unknown -Zdoctest-xcompile\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Binding Code\nDESCRIPTION: Generated Rust code showing the low-level implementation of string handling between WebAssembly and Rust, including memory management and safety considerations.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\npub extern \"C\" fn greet(a: &str) -> String {\\n    format!(\"Hello, {}!\", a)\\n}\\n\\n#[export_name = \"greet\"]\\npub extern \"C\" fn __wasm_bindgen_generated_greet(\\n    arg0_ptr: *const u8,\\n    arg0_len: usize,\\n) -> *mut String {\\n    let arg0 = unsafe {\\n        let slice = ::std::slice::from_raw_parts(arg0_ptr, arg0_len);\\n        ::std::str::from_utf8_unchecked(slice)\\n    };\\n    let _ret = greet(arg0);\\n    Box::into_raw(Box::new(_ret))\\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Console Log Binding Example\nDESCRIPTION: Shows how to bind to JavaScript's console.log function using wasm_bindgen. This code will panic when run on non-wasm targets.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/rust-targets.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_namespace = console)]\n    fn log(s: &str);\n}\n\nfn main() {\n    log(\"hello!\");\n}\n```\n\n----------------------------------------\n\nTITLE: Example of a Rust Function Exported with wasm-bindgen\nDESCRIPTION: A simple Rust function that takes a string reference parameter and is exported to JavaScript using the #[wasm_bindgen] attribute.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/describe.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nfn greet(a: &str) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: AsRef Implementations for Inheritance in Rust web-sys\nDESCRIPTION: Shows the AsRef trait implementations for the HtmlAnchorElement type in web-sys, demonstrating how to access all parent classes in the inheritance hierarchy.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/inheritance.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nimpl AsRef<HtmlElement> for HtmlAnchorElement\nimpl AsRef<Element> for HtmlAnchorElement\nimpl AsRef<Node> for HtmlAnchorElement\nimpl AsRef<EventTarget> for HtmlAnchorElement\nimpl AsRef<Object> for HtmlAnchorElement\nimpl AsRef<JsValue> for HtmlAnchorElement\n```\n\n----------------------------------------\n\nTITLE: Configuring Dependencies for Wasm in Web Worker in Rust\nDESCRIPTION: The Cargo.toml configuration enables features necessary for working with the DOM, logging to the JS console, creating a worker, and handling message events in a wasm-bindgen project.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-web-worker.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n{{#include ../../../examples/wasm-in-web-worker/Cargo.toml}}\n```\n\n----------------------------------------\n\nTITLE: Using Imported JavaScript Object Methods in Rust with wasm-bindgen\nDESCRIPTION: This snippet shows how to use the imported JavaScript object method in Rust code. It demonstrates calling the `has` method on a `Set` object.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/method.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nlet set: Set = ...;\nlet elem: JsValue = ...;\nif set.has(&elem) {\n    ...\n}\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly with wasm-pack for Web Target\nDESCRIPTION: Command to build the WebSockets example using wasm-pack with the web target configuration. This compiles Rust code to WebAssembly for browser usage.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/websockets/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ wasm-pack build --target web\n```\n\n----------------------------------------\n\nTITLE: Defining a Rust External Function with wasm-bindgen\nDESCRIPTION: This snippet shows how to define an external function in Rust using wasm-bindgen without the `final` attribute. It declares a `Foo` type with a `bar` method that takes a string argument and returns a JsValue.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n    #[wasm_bindgen(method)]\n    fn bar(this: &Foo, argument: &str) -> JsValue;\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Interface with JSDoc Comments\nDESCRIPTION: Shows the resulting JavaScript code after wasm-bindgen processes the Rust code. Demonstrates the difference between auto-generated and custom JSDoc comments.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip_jsdoc.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n* Autogenerated docs.\n*\n* @param {number} arg\n* @returns {number}\n*/\nexport function foo(arg) { /* ... */ }\n\n/**\n* Manually written docs.\n*\n* @param {number} arg - A descriptive description.\n* @returns {number} Something a bit bigger.\n*/\nexport function bar(arg) { /* ... */ }\n```\n\n----------------------------------------\n\nTITLE: Using js_name with Types and Methods\nDESCRIPTION: Shows how to use js_name with type imports and corresponding js_class attribute for methods.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_name = String)]\n    type JsString;\n    #[wasm_bindgen(method, getter, js_class = \"String\")]\n    pub fn length(this: &JsString) -> u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a WebAssembly Function with Borrowed JS Reference in Rust\nDESCRIPTION: Example of a Rust function that takes a reference to a JsValue, demonstrating the borrowed object pattern where the JavaScript object has a temporary lifetime within the function call.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n// foo.rs\n#[wasm_bindgen]\npub fn foo(a: &JsValue) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Custom toJSON and toString Implementations\nDESCRIPTION: Example of overriding the default toJSON and toString implementations with custom behavior for the Rust struct.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/inspectable.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nimpl Baz {\n    #[wasm_bindgen(js_name = toJSON)]\n    pub fn to_json(&self) -> i32 {\n        self.field\n    }\n\n    #[wasm_bindgen(js_name = toString)]\n    pub fn to_string(&self) -> String {\n        format!(\"Baz: {}\", self.field)\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Adding gloo-utils Dependency for JSON Serialization\nDESCRIPTION: This snippet shows how to add the gloo-utils dependency with the serde feature in the Cargo.toml file for JSON-based serialization.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\ngloo-utils = { version = \"0.1\", features = [\"serde\"] }\n```\n\n----------------------------------------\n\nTITLE: JavaScript Equivalent of Default Getter Access in wasm-bindgen\nDESCRIPTION: JavaScript code showing how wasm-bindgen accesses getters by default, caching the accessor function.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/getter-and-setter.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst white_russians = Object.getOwnPropertyDescriptor(\n  TheDude.prototype,\n  \"white_russians\"\n).get;\n```\n\n----------------------------------------\n\nTITLE: Using js_name Attribute to Rename Exported Rust Enums\nDESCRIPTION: Demonstrates renaming an exported Rust enum using the js_name attribute for JavaScript interop.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_4\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\n#[js_name = \"MyJSEnum\"]\nenum MyRustEnum {\n    // enum variants\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling web-sys Window Feature in Cargo.toml\nDESCRIPTION: Cargo.toml configuration demonstrating how to enable specific web-sys features, in this case the Window API feature for accessing window manipulation functions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/using-web-sys.md#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies.web-sys]\nversion = \"0.3\"\nfeatures = [\n  \"Window\"\n]\n```\n\n----------------------------------------\n\nTITLE: JavaScript Implementation for Owned JS Objects\nDESCRIPTION: Generated JavaScript code that manages passing JS objects to WebAssembly using a slab allocator approach for long-lived objects, with functions to add objects to the heap and handle their cleanup when dropped from Rust.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nimport * as wasm from './foo_bg'; // imports from Wasm file\n\nconst heap = new Array(32);\nheap.push(undefined, null, true, false);\nlet heap_next = 36;\n\nfunction addHeapObject(obj) {\n  if (heap_next === heap.length)\n    heap.push(heap.length + 1);\n  const idx = heap_next;\n  heap_next = heap[idx];\n  heap[idx] = obj;\n  return idx;\n}\n\nexport function foo(arg0) {\n  const idx0 = addHeapObject(arg0);\n  wasm.foo(idx0);\n}\n\nexport function __wbindgen_object_drop_ref(idx) {\n  heap[idx ] = heap_next;\n  heap_next = idx;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a WebAssembly Function with Owned JS Value in Rust\nDESCRIPTION: Example of a Rust function that takes ownership of a JsValue, demonstrating the pattern for JavaScript objects with dynamic lifetimes that may be stored on the Rust heap.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\n// foo.rs\n#[wasm_bindgen]\npub fn foo(a: JsValue) {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: BufferSource Type Translation in web-sys\nDESCRIPTION: Shows how BufferSource and ArrayBufferView WebIDL types are translated to js_sys::Object and &mut [u8] in web-sys for handling byte buffers and arrays.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/type-translations.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\njs_sys::Object\n&mut [u8]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating no_deref Usage in Rust WASM Bindings\nDESCRIPTION: Shows how to use the no_deref attribute to prevent automatic Deref implementation for a type that extends another type. The example demonstrates that methods from the parent type Foo are not accessible on Bar due to no_deref.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/no_deref.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    type Foo;\n\n    #[wasm_bindgen(method)]\n    fn baz(this: &Foo)\n\n    #[wasm_bindgen(extends = Foo, no_deref)]\n    type Bar;\n}\n\nfn do_stuff(bar: &Bar) {\n    bar.baz() // Does not compile\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript for Final Attribute\nDESCRIPTION: This JavaScript code is generated by wasm-bindgen for the Rust external function with the `final` attribute. It hoists the target function and uses `Function.call` for invocation, optimizing the method lookup.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nconst __wbg_bar_target = Foo.prototype.bar;\n\nexport function __wbg_bar_a81456386e6b526f(arg0, arg1, arg2) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    return addHeapObject(__wbg_bar_target.call(getObject(arg0), varg1));\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Functions with Custom JSDoc in Rust\nDESCRIPTION: Demonstrates how to use #[wasm_bindgen(skip_jsdoc)] to control JSDoc generation. Shows two functions: foo() with auto-generated docs and bar() with custom JSDoc comments.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip_jsdoc.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\n/// Autogenerated docs.\n#[wasm_bindgen]\npub fn foo(arg: u32) -> u32 { arg + 1 }\n\n/// Manually written docs.\n///\n/// @param {number} arg - A descriptive description.\n/// @returns {number} Something a bit bigger.\n#[wasm_bindgen(skip_jsdoc)]\npub fn bar(arg: u32) -> u32 { arg + 2 }\n```\n\n----------------------------------------\n\nTITLE: Adding wasm-bindgen-test Dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to add wasm-bindgen-test as a dev-dependency in the Cargo.toml file. It specifies the version and notes compatibility with Rust versions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dev-dependencies]\nwasm-bindgen-test = \"0.3.0\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Unstable APIs via RUSTFLAGS\nDESCRIPTION: Shows how to enable unstable web-sys APIs by setting the web_sys_unstable_apis configuration flag through environment variables at compile time.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/unstable-apis.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nRUSTFLAGS=--cfg=web_sys_unstable_apis cargo run\n```\n\n----------------------------------------\n\nTITLE: Generated Rust Binding for Owned JS Values\nDESCRIPTION: The generated Rust code for handling owned JavaScript values, showing how the exported WebAssembly function takes a numeric index, converts it to a JsValue, and passes ownership to the original function.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n// what the user wrote\npub fn foo(a: JsValue) {\n    // ...\n}\n\n#[export_name = \"foo\"]\npub extern \"C\" fn __wasm_bindgen_generated_foo(arg0: u32) {\n    let arg0 = unsafe {\n        JsValue::__from_idx(arg0)\n    };\n    foo(arg0);\n}\n```\n\n----------------------------------------\n\nTITLE: Using typescript_type Attribute for Custom TypeScript Types\nDESCRIPTION: Specifies a custom TypeScript type for an extern Rust type using the typescript_type attribute.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_6\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\n#[typescript_type = \"MyCustomType\"]\nextern {\n    type SomeExternType;\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Implementation for Borrowed JS Objects\nDESCRIPTION: Generated JavaScript code that manages passing JS objects to WebAssembly by using a stack-based approach for temporary object references, which pushes objects to a heap array and passes their indices to WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// foo.js\nimport * as wasm from './foo_bg';\n\nconst heap = new Array(32);\nheap.push(undefined, null, true, false);\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n  stack_pointer -= 1;\n  heap[stack_pointer] = obj;\n  return stack_pointer;\n}\n\nexport function foo(arg0) {\n  const idx0 = addBorrowedObject(arg0);\n  try {\n    wasm.foo(idx0);\n  } finally {\n    heap[stack_pointer++] = undefined;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Renamed Rust Struct in JavaScript\nDESCRIPTION: Demonstrates how to import the renamed Rust struct in JavaScript. The struct is imported as Foo.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/js_name.md#2025-04-16_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Foo } from './my_module';\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: JavaScript Usage of Boxed Number Slices\nDESCRIPTION: Shows how to interact with Rust's boxed number slices from JavaScript using TypedArrays. This code demonstrates the JavaScript side of the WebAssembly interface.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/boxed-number-slices.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/boxed_number_slices.js}}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Integration for WebAssembly Character Counter\nDESCRIPTION: JavaScript code that interacts with the Rust-implemented Counter struct. Handles UI rendering and character selection for the counter application.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/char.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Counter } from './pkg';\n\nconst chars = ['$', '£', '¥', '€', '¢', '₿'];\nconst counters = [];\n\nfunction getRandomChar() {\n    return chars[Math.floor(Math.random() * chars.length)];\n}\n\nfunction render() {\n    const html = counters.map((counter, i) => {\n        return `\n            <div>\n                <span>key: ${counter.key()}</span>\n                <span>count: ${counter.count()}</span>\n                <button onclick=\"increment(${i})\">+</button>\n            </div>\n        `;\n    });\n    document.getElementById('root').innerHTML = html.join('');\n}\n\nwindow.increment = function(idx) {\n    counters[idx].increment();\n    render();\n};\n\ndocument.getElementById('add').addEventListener('click', () => {\n    counters.push(new Counter(getRandomChar()));\n    render();\n});\n\ncounters.push(new Counter(getRandomChar()));\nrender();\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Closure Methods in Rust for wasm-bindgen\nDESCRIPTION: This snippet shows two methods available on the Closure type in Rust when using wasm-bindgen. These methods, into_js_value and forget, are mentioned as examples of operations that could potentially lead to memory leaks without weak reference support.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/weak-references.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nClosure::{into_js_value,forget}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Glue Code Without Reference Types\nDESCRIPTION: Generated JavaScript code without reference types support, showing the complex heap management required for JS-Wasm value passing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/reference-types.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet stack_pointer = 32;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nexport function takes_js_value(a) {\n    try {\n        wasm.takes_js_value(addBorrowedObject(a));\n    } finally {\n        heap[stack_pointer++] = undefined;\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Using the JsCast Trait for Type Conversions\nDESCRIPTION: The JsCast trait enables safe casting between JavaScript types in Rust, allowing for proper inheritance relationships between types as described in RFC #2.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_13\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::JsCast;\n\nlet element = document.get_element_by_id(\"my-element\")?;\n// Cast from Element to HtmlElement\nlet html_element = element.dyn_into::<web_sys::HtmlElement>()?;\n```\n\n----------------------------------------\n\nTITLE: HTML Structure for Wasm Web Worker Example\nDESCRIPTION: The HTML structure includes an input field for entering numbers and a result field for displaying the output from the worker. It loads both the compiled wasm JavaScript and the initialization script.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-web-worker.md#2025-04-16_snippet_2\n\nLANGUAGE: html\nCODE:\n```\n{{#include ../../../examples/wasm-in-web-worker/index.html}}\n```\n\n----------------------------------------\n\nTITLE: Defining the WasmDescribe Trait in Rust for Type Descriptions\nDESCRIPTION: The WasmDescribe trait defines a simple interface for types to describe themselves programmatically. It contains a describe method that generates type information for the wasm-bindgen CLI tool.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/describe.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub trait WasmDescribe {\n    fn describe();\n}\n```\n\n----------------------------------------\n\nTITLE: Exporting a Rust Function to JavaScript with wasm-bindgen\nDESCRIPTION: A demonstration of how to export a Rust function to JavaScript using the #[wasm_bindgen] attribute. This shows the minimal intervention required to make Rust functions available in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/index.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub fn greet(name: &str) -> String {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Rust to Invalid JavaScript Identifier\nDESCRIPTION: Shows how to bind a Rust function to a JavaScript identifier that wouldn't be valid in Rust using a string literal.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nextern \"C\" {\n    #[wasm_bindgen(js_name = \"$$$\")]\n    fn cash_money() -> u32;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining JavaScript Imports with wasm-bindgen in Rust\nDESCRIPTION: This snippet demonstrates the syntax for importing JavaScript functions and classes into Rust using the `#[wasm_bindgen]` attribute within an `extern \"C\" { ... }` block. The code is not complete but illustrates the structure of such imports.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/index.md#2025-04-16_snippet_0\n\nLANGUAGE: Rust\nCODE:\n```\nextern \"C\" { ... }\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly with Standard Library Threading Support\nDESCRIPTION: Cargo command to build WebAssembly target with custom standard library compilation including threading support using the build-std feature.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/raytrace.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncargo build --target wasm32-unknown-unknown -Z build-std=panic_abort,std\n```\n\n----------------------------------------\n\nTITLE: Implementing Documented Rust Struct Method with wasm-bindgen Attributes\nDESCRIPTION: This snippet shows how to add documentation to a method of a Rust struct using `#[wasm_bindgen]` attributes. The `number` method of `FooList` struct is documented with a return description and a parameter description.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/description.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\npub struct FooList {\n    // properties\n}\n\n#[wasm_bindgen]\nimpl FooList {\n    /// Returns the number at the given index.\n    #[wasm_bindgen(return_description = \"the number at the given index\")]\n    pub fn number(\n        &self,\n        #[wasm_bindgen(param_description = \"the index of the number to be returned\")]\n        index: u32,\n    ) -> u32 {\n        // function body\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Function Export in Regular Rust\nDESCRIPTION: An example of a standard Rust function that returns a String, before any wasm-bindgen annotations are applied. This shows the starting point before WebAssembly integration.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/index.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\npub fn greet(name: &str) -> String {\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generated Type Description Function for an Exported Rust Function\nDESCRIPTION: The #[wasm_bindgen] macro generates this description function automatically. This function calls the describe() method for the function's type signature to provide type information to the wasm-bindgen CLI tool.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/describe.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[no_mangle]\npub extern \"C\" fn __wbindgen_describe_greet() {\n    <dyn Fn(&str)>::describe();\n}\n```\n\n----------------------------------------\n\nTITLE: Browser Capabilities Configuration\nDESCRIPTION: JSON configuration for Firefox and Chrome WebDriver capabilities, including media stream settings and browser arguments.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/browsers.md#2025-04-16_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"moz:firefoxOptions\": {\n    \"prefs\": {\n      \"media.navigator.streams.fake\": true,\n      \"media.navigator.permission.disabled\": true\n    },\n    \"args\": []\n  },\n  \"goog:chromeOptions\": {\n    \"args\": [\n      \"--use-fake-device-for-media-stream\",\n      \"--use-fake-ui-for-media-stream\"\n    ]\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Custom Derive Macro for TypeScript Exports\nDESCRIPTION: Shows how to use a derive macro to automatically generate TypeScript definitions from Rust structs. The macro can internally generate typescript_custom_section attributes.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/typescript_custom_section.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n#[derive(MyTypescriptExport)]\nstruct Coords {\n    latitude: u32,\n    longitude: u32,\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Rust Flags for WebAssembly Threading Support\nDESCRIPTION: Command to set required Rust compiler flags for enabling WebAssembly threading features including atomics, bulk memory, and mutable globals.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/raytrace.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nexport RUSTFLAGS='-C target-feature=+atomics,+bulk-memory,+mutable-globals'\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript for Non-Final Attribute\nDESCRIPTION: This JavaScript code is generated by wasm-bindgen for the Rust external function without the `final` attribute. It includes a function shim that performs runtime lookup of the `bar` method.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nexport function __wbg_bar_a81456386e6b526f(arg0, arg1, arg2) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    return addHeapObject(getObject(arg0).bar(varg1));\n}\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript Bindings with Documentation\nDESCRIPTION: This snippet shows the JavaScript bindings generated from the Rust code using wasm-bindgen. It includes JSDoc comments for both the `add` function and the `FooList.number` method, reflecting the documentation provided in the Rust code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/description.md#2025-04-16_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/**\n * Adds `arg1` and `arg2`.\n *\n * @param {number} arg1 - the first number\n * @param {number} arg2 - the second number\n * @returns {number} the result of the addition of `arg1` and `arg2`\n */\nexport function add(arg1, arg2) {\n    // ...\n}\n\nexport class FooList {\n    /**\n     * Returns the number at the given index.\n     *\n     * @param {number} index - the index of the number to be returned\n     * @returns {number} the number at the given index\n     */\n    number(index) {\n        // ...\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: JavaScript Equivalent of Structural Getter Access in wasm-bindgen\nDESCRIPTION: JavaScript code demonstrating how the 'structural' attribute changes getter access to walk the prototype chain on every access.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/getter-and-setter.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst white_russians = function(the_dude) {\n  return the_dude.white_russians;\n};\n```\n\n----------------------------------------\n\nTITLE: Creating HTML Structure for WebAssembly Integration\nDESCRIPTION: This HTML file sets up the basic structure for the web page. It includes a script tag that creates a Web Worker, which will handle the WebAssembly instantiation.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/synchronous-instantiation.md#2025-04-16_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<!DOCTYPE html>\n<html>\n  <head>\n    <meta charset=\"UTF-8\">\n    <title>Synchronous instantiation example</title>\n  </head>\n  <body>\n    <script>\n      const worker = new Worker(\"worker.js\");\n      worker.postMessage({});\n      worker.onmessage = (e) => {\n        console.log(\"Result:\", e.data);\n      };\n    </script>\n  </body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Regenerating web-sys bindings\nDESCRIPTION: Commands to regenerate the Rust bindings for web-sys after adding or modifying WebIDL files, using the wasm-bindgen-webidl tool.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/supporting-more-web-apis.md#2025-04-16_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\ncd crates/web-sys\ncargo run --release --package wasm-bindgen-webidl -- webidls src/features ./Cargo.toml\n```\n\n----------------------------------------\n\nTITLE: TypeScript Definition for WebAssembly Function Export\nDESCRIPTION: TypeScript declaration showing how a Rust function taking a JsValue appears in the JavaScript interface, accepting any value as its parameter.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/js-objects-in-rust.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// foo.d.ts\nexport function foo(a: any);\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Interface for Variadic Rust Function\nDESCRIPTION: This snippet shows the TypeScript interface generated for the Rust function with a variadic parameter. It represents the function signature that will be available in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/variadic.md#2025-04-16_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport  function  variadic_function(...arr:  any):  any;\n```\n\n----------------------------------------\n\nTITLE: Configuring Travis CI for wasm-bindgen-test\nDESCRIPTION: Travis CI configuration for running wasm-bindgen tests in headless Firefox and Chrome browsers. Includes setup for installing wasm-pack and configuring the necessary browser addons.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/continuous-integration.md#2025-04-16_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nlanguage: rust\nrust    : nightly\n\naddons:\n  firefox: latest\n  chrome : stable\n\ninstall:\n  - curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n\nscript:\n  # this will test the non Wasm targets if your crate has those, otherwise remove this line.\n  #\n  - cargo test\n\n  - wasm-pack test --firefox --headless\n  - wasm-pack test --chrome  --headless\n```\n\n----------------------------------------\n\nTITLE: JavaScript Default Export Example\nDESCRIPTION: Example of importing a default export from a JavaScript module.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/js_name.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport Foo from \"bar\";\n\nlet f = new Foo();\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-bindgen-cli using cargo-binstall\nDESCRIPTION: This snippet demonstrates how to install pre-built artifacts of wasm-bindgen-cli using the cargo-binstall tool.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ncargo binstall wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Referencing js-sys API Documentation in Markdown\nDESCRIPTION: This code snippet provides a link to the API documentation for the js-sys crate, which contains detailed information about the available JavaScript global API bindings.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/js-sys/README.md#2025-04-16_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n[API documentation](https://rustwasm.github.io/wasm-bindgen/api/js_sys/)\n```\n\n----------------------------------------\n\nTITLE: Configuring Unstable Web APIs in web_sys\nDESCRIPTION: Shows how to enable unstable browser APIs in the web_sys crate using a compile-time flag.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_5\n\nLANGUAGE: Shell\nCODE:\n```\nRUSTFLAGS=\"--cfg web_sys_unstable_apis\" cargo build\n```\n\n----------------------------------------\n\nTITLE: Web Worker JavaScript for Background Processing with Wasm\nDESCRIPTION: Worker script that loads the Wasm file, creates an object for background calculations, and binds the object's method to the onmessage callback for handling incoming messages from the main thread.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/wasm-in-web-worker.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/wasm-in-web-worker/worker.js}}\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub Actions for wasm-bindgen-test\nDESCRIPTION: GitHub Actions workflow configuration for running wasm-bindgen tests in headless Chrome and Firefox browsers on Ubuntu. Sets up the environment and runs tests for both browsers.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/continuous-integration.md#2025-04-16_snippet_2\n\nLANGUAGE: yaml\nCODE:\n```\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Install\n        run: curl https://rustwasm.github.io/wasm-pack/installer/init.sh -sSf | sh\n\n      - run: cargo test\n      - run: wasm-pack test --headless --chrome\n      - run: wasm-pack test --headless --firefox\n```\n\n----------------------------------------\n\nTITLE: Optimized JavaScript with Reference Types Proposal\nDESCRIPTION: This JavaScript snippet shows how the generated code would look after implementing the reference types proposal. It eliminates some function calls, further optimizing the binding.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst __wbg_bar_target = Foo.prototype.bar;\n\nexport function __wbg_bar_a81456386e6b526f(arg0, arg1, arg2) {\n    let varg1 = getStringFromWasm(arg1, arg2);\n    return __wbg_bar_target.call(arg0, varg1);\n}\n```\n\n----------------------------------------\n\nTITLE: Cargo Config for Enabling Unstable APIs\nDESCRIPTION: Demonstrates how to persistently enable unstable web-sys APIs using Cargo's configuration file, setting rustflags in .cargo/config.toml.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/unstable-apis.md#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[build]\nrustflags = [\"--cfg=web_sys_unstable_apis\"]\n```\n\n----------------------------------------\n\nTITLE: Enabling WebIDL Build Logging in web-sys\nDESCRIPTION: Shell command to enable verbose logging output during web-sys crate build using RUST_LOG environment variable. Sets logging level for wasm_bindgen_webidl and enables detailed cargo build output.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/logging.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd crates/web-sys\nRUST_LOG=wasm_bindgen_webidl cargo build -vv\n```\n\n----------------------------------------\n\nTITLE: Defining RefMutFromWasmAbi Trait for JavaScript to Rust Mutable Reference Conversion\nDESCRIPTION: This trait is used to create mutable references from JavaScript values. It's similar to RefFromWasmAbi but uses DerefMut instead of Deref.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\npub trait RefMutFromWasmAbi: WasmDescribe {\n    type Abi: WasmAbi;\n    type Anchor: DerefMut<Target=Self>;\n    unsafe fn ref_mut_from_abi(js: Self::Abi) -> Self::Anchor;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Clamped<T> for Uint8ClampedArray\nDESCRIPTION: The Clamped<T> type generates JavaScript Uint8ClampedArray bindings, useful for image data processing and canvas operations.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_18\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::Clamped;\n\n#[wasm_bindgen]\nfn process_image_data(data: Clamped<Vec<u8>>) {\n    // process image data that will be treated as a Uint8ClampedArray in JS\n}\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly Package with no-modules Target in wasm-pack\nDESCRIPTION: Command to build a WebAssembly package using wasm-pack with the no-modules target. This approach enables loading the WebAssembly module using traditional script tags rather than ES modules.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/without-a-bundler-no-modules/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasm-pack build --target no-modules\n```\n\n----------------------------------------\n\nTITLE: Cargo Configuration for WebAssembly Threading\nDESCRIPTION: Cargo configuration file content specifying build settings for WebAssembly with threading support, including target specification and compiler flags.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/raytrace.md#2025-04-16_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[unstable]\nbuild-std = ['std', 'panic_abort']\n\n[build]\ntarget = \"wasm32-unknown-unknown\"\nrustflags = '-Ctarget-feature=+atomics,+bulk-memory,+mutable-globals'\n```\n\n----------------------------------------\n\nTITLE: Generated TypeScript Definitions\nDESCRIPTION: The resulting TypeScript definition file after applying skip_typescript attributes, showing only the exposed elements.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-rust-exports/skip_typescript.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/* tslint:disable */\n/* eslint-disable */\nexport class MyPoint {\n  free(): void;\n  x: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Skipping TypeScript Generation with skip_typescript Attribute\nDESCRIPTION: Shows how to skip generating TypeScript bindings for a specific function or type.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_8\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen]\n#[skip_typescript]\nfn my_internal_function() {\n    // implementation\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting JsValue from a Closure\nDESCRIPTION: Extracting the underlying JsValue from a Closure<T> type, allowing for manual handling of JavaScript closures created from Rust functions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_19\n\nLANGUAGE: rust\nCODE:\n```\nuse wasm_bindgen::prelude::*;\n\nlet closure = Closure::wrap(Box::new(|x: i32| x + 1) as Box<dyn FnMut(i32) -> i32>);\n\n// Extract the underlying JsValue\nlet js_value = closure.as_ref().clone();\n\n// Pass the JavaScript function to an API\nsome_js_api(&js_value);\n\n// Don't forget to release the closure's memory when done\nclosure.forget();\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly with wasm-pack for Web Target\nDESCRIPTION: Command to build the Rust code into a WebAssembly module targeting web browsers. The --target web flag generates code suitable for direct inclusion in web pages.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/synchronous-instantiation/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ wasm-pack build --target web\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-bindgen-cli for Manual Testing\nDESCRIPTION: This command installs the wasm-bindgen-cli tool, which includes the test runner. It's used when not using wasm-pack for testing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ncargo install wasm-bindgen-cli --vers \"X.Y.Z\"\n```\n\n----------------------------------------\n\nTITLE: Conditional API Definition with web_sys_unstable_apis Flag\nDESCRIPTION: Demonstrates how web-sys hides unstable APIs using conditional compilation attributes. This pattern prevents breaking changes from affecting stable API users.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/web-sys/unstable-apis.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[cfg(web_sys_unstable_apis)]\npub struct Foo;\n```\n\n----------------------------------------\n\nTITLE: Including Generated Bindings in Rust\nDESCRIPTION: Demonstrates how the src/lib.rs file includes the bindings generated at compile time by the build.rs script. This is the entire content of the lib.rs file.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/overview.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../crates/web-sys/src/lib.rs}}\n```\n\n----------------------------------------\n\nTITLE: Testing Rust WebAssembly Project with Deno\nDESCRIPTION: Command to run tests using Deno with the --allow-read flag for reading the Wasm file during runtime. This flag is required due to a current limitation in Deno.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/explicit-resource-management/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ deno run --allow-read test.ts\n```\n\n----------------------------------------\n\nTITLE: Adding inspectable attribute for exported objects in Rust\nDESCRIPTION: A new #[wasm_bindgen(inspectable)] attribute has been added for exported objects to generate toJSON and toString implementations.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_10\n\nLANGUAGE: Rust\nCODE:\n```\n#[wasm_bindgen(inspectable)]\nstruct MyExportedObject {\n  // Object fields\n}\n```\n\n----------------------------------------\n\nTITLE: Running Local WebGL Example Server with NPM\nDESCRIPTION: Command to build and serve the WebGL example locally using npm. After running this command, the example will be accessible at http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/webgl/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Building and Serving web-sys Closure Example with npm\nDESCRIPTION: Command to build and serve the web-sys closure example locally using npm. After running this command, the example can be accessed at http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/closures/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running js-sys Tests with Cargo for WebAssembly Target\nDESCRIPTION: This command demonstrates how to navigate to the js-sys directory within the wasm-bindgen project and run tests using cargo with the wasm32-unknown-unknown target. This is essential for testing WebAssembly compatibility of the js-sys crate.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/js-sys/testing.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd wasm-bindgen/crates/js-sys\ncargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: TypeScript Declaration for Exported Function\nDESCRIPTION: TypeScript type declaration showing how the exported Rust function will appear in JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/exporting-rust.md#2025-04-16_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// foo.d.ts\\nexport function greet(a: string): string;\n```\n\n----------------------------------------\n\nTITLE: Building WASM Package for Web Target in wasm-bindgen\nDESCRIPTION: Uses wasm-pack to build the project with the 'web' target, which generates JS and WASM files that can be directly used in a browser without a bundler.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/without-a-bundler/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ wasm-pack build --target web\n```\n\n----------------------------------------\n\nTITLE: WebIDL Record Implementation\nDESCRIPTION: Example of WebIDL record support for APIs like ClipboardItem and GPUDeviceDescriptor\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nClipboardItem()\nGPUDeviceDescriptor.requiredLimits\nHeader()\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Paint Example with npm\nDESCRIPTION: This command uses npm to build and serve the paint example locally. After running this command, the example can be accessed through a web browser at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/paint/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running the Julia Set Example with NPM Serve\nDESCRIPTION: Command to locally build and serve the Julia Set WebAssembly example. After running this command, the example can be accessed at http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/julia_set/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly Benchmarks with Cargo\nDESCRIPTION: Commands for building and preparing the WebAssembly benchmarks. This includes compiling to wasm32 target and using wasm-bindgen-cli to generate web-compatible output.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/benchmarks/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ cd benchmarks\n$ cargo build --release --target wasm32-unknown-unknown\n$ cargo run --package wasm-bindgen-cli -- --out-dir pkg --target web ../target/wasm32-unknown-unknown/release/wasm_bindgen_benchmark.wasm\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly in WebAssembly Example with npm\nDESCRIPTION: This command starts a local server to run the WebAssembly in WebAssembly example. After running this command, the example can be accessed by visiting http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/wasm-in-wasm-imports/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Generating WebAssembly Test Coverage with LLVM Tools\nDESCRIPTION: Shell script demonstrating the complete workflow for generating WebAssembly test coverage data. Includes running tests with coverage instrumentation, compiling LLVM IR to object files, merging profiling data, and generating HTML coverage reports using llvm-cov.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/coverage.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n# Run the tests:\n# `--tests` to not run documentation tests, which is currently not supported.\nRUSTFLAGS=\"-Cinstrument-coverage -Zno-profiler-runtime --emit=llvm-ir --cfg=wasm_bindgen_unstable_test_coverage\" \\\nCARGO_TARGET_WASM32_UNKNOWN_UNKNOWN_RUNNER=wasm-bindgen-test-runner \\\ncargo +nightly test --tests\n# Compile to object files:\n# - Extract a list of compiled artifacts from Cargo and filter them with `jq`.\n# - Figure out the path to the LLVM IR file corresponding to an artifact.\n# - Compile to object file with Clang and store for later usage with `llvm-cov`.\ncrate_name=name_of_the_tested_crate_in_snake_case\nobjects=()\nIFS=$'\\n'\nfor file in $(\n    RUSTFLAGS=\"-Cinstrument-coverage -Zno-profiler-runtime --emit=llvm-ir --cfg=wasm_bindgen_unstable_test_coverage\" \\\n    cargo +nightly test --tests --no-run --message-format=json | \\\n    jq -r \"select(.reason == \\\"compiler-artifact\\\") | (select(.target.kind == [\\\"test\\\"]) // select(.target.name == \\\"$crate_name\\\")) | .filenames[0]\"\n)\ndo\n    if [[ ${file##*.} == \"rlib\" ]]; then\n        base=$(basename $file .rlib)\n        file=$(dirname $file)/${base#\"lib\"}.ll\n    else\n        file=$(dirname $file)/$(basename $file .wasm).ll\n    fi\n\n    output = $(basename $file .ll).o\n    clang-19 $file -Wno-override-module -c -o $output\n    objects+=(-object $output)\ndone\n# Merge all generated raw profiling data.\nllvm-profdata-19 merge -sparse *.profraw -o coverage.profdata\n# Produce test coverage data in the HTML format and pass the object files we generated earlier.\nllvm-cov-19 show -show-instantiations=false -Xdemangler=rustfilt -output-dir coverage -format=html -instr-profile=coverage.profdata ${objects[@]} -sources src\n```\n\n----------------------------------------\n\nTITLE: Implementing WasmAbi for WasmSlice\nDESCRIPTION: This implementation shows how WasmSlice can be split into multiple WebAssembly parameters, specifically two u32 values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/design/rust-type-conversions.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nimpl WasmAbi for WasmSlice {\n    fn split(self) -> (u32, u32, (), ()) {\n        (self.ptr, self.len, (), ())\n    }\n\n    // some other details to specify return type of `split`, go in the other direction\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Serving Rust WebAssembly Fetch API Example\nDESCRIPTION: This command builds the example project and serves it locally. After running this, the example can be accessed by visiting http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/fetch/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Custom TypeScript Section\nDESCRIPTION: Support for arbitrary expressions in wasm_bindgen typescript custom sections\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(typescript_custom_section)]\n```\n\n----------------------------------------\n\nTITLE: Building and Serving WebRTC DataChannel Example with npm\nDESCRIPTION: This command builds and serves the WebRTC DataChannel example locally using npm. After running this command, the example can be accessed by visiting http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/webrtc_datachannel/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running the Duck-Typed Interfaces Example with npm\nDESCRIPTION: This command builds and serves the example project. After running this command, the example can be viewed in a web browser at http://localhost:8080/.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/duck-typed-interfaces/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running Local Development Server - NPM\nDESCRIPTION: Command to start a local development server for viewing the requestAnimationFrame example in a browser at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/request-animation-frame/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Building Rust WebAssembly Project\nDESCRIPTION: Command to build the Rust WebAssembly project using a shell script.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/explicit-resource-management/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ ./build.sh\n```\n\n----------------------------------------\n\nTITLE: Running WebAssembly Tests with wasm-pack\nDESCRIPTION: This shell command demonstrates how to run WebAssembly tests using wasm-pack. It targets Node.js by default and shows the output of a test run.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ wasm-pack test --node\n    Finished dev [unoptimized + debuginfo] target(s) in 0.11s\n     Running /home/.../target/wasm32-unknown-unknown/debug/deps/wasm-4a309ffe6ad80503.wasm\nrunning 2 tests\n\ntest wasm::pass ... ok\ntest wasm::fail ... FAILED\n\nfailures:\n\n---- wasm::fail output ----\n    error output:\n        panicked at 'assertion failed: `(left == right)`\n          left: `1`,\n         right: `2`', crates/test/tests/wasm.rs:14:5\n\n    JS exception that was thrown:\n        RuntimeError: unreachable\n            at __rust_start_panic (wasm-function[1362]:33)\n            at rust_panic (wasm-function[1357]:30)\n            at std::panicking::rust_panic_with_hook::h56e5e464b0e7fc22 (wasm-function[1352]:444)\n            at std::panicking::continue_panic_fmt::had70ba48785b9a8f (wasm-function[1350]:122)\n            at std::panicking::begin_panic_fmt::h991e7d1ca9bf9c0c (wasm-function[1351]:95)\n            at wasm::fail::ha4c23c69dfa0eea9 (wasm-function[88]:477)\n            at core::ops::function::FnOnce::call_once::h633718dad359559a (wasm-function[21]:22)\n            at wasm_bindgen_test::__rt::Context::execute::h2f669104986475eb (wasm-function[13]:291)\n            at __wbg_test_fail_1 (wasm-function[87]:57)\n            at module.exports.__wbg_apply_2ba774592c5223a7 (/home/alex/code/wasm-bindgen/target/wasm32-unknown-unknown/wbg-tmp/wasm-4a309ffe6ad80503.js:61:66)\n\n\nfailures:\n\n    wasm::fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored\n\nerror: test failed, to rerun pass '--test wasm'\n```\n\n----------------------------------------\n\nTITLE: Serving WASM Project Locally Using Various Web Servers\nDESCRIPTION: Shows different methods to serve the project directory using either the 'http' crate from crates.io or Python's built-in HTTP servers, allowing the browser to access the compiled WebAssembly example.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/without-a-bundler/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# static server from https://crates.io/crates/https\nhttp\n\n# or use python\npython2 -m SimpleHTTPServer\npython3 -m http.server\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-bindgen-cli using Cargo\nDESCRIPTION: This snippet shows how to install the wasm-bindgen-cli tool using Cargo, Rust's package manager.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo install wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Installing npm Dependencies for Rust WebAssembly Project\nDESCRIPTION: This command installs the necessary npm packages for the project. It must be run before using any npm packages.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/fetch/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm install\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Running Weather Report Web Application\nDESCRIPTION: This snippet shows the commands to install dependencies, build the project, and start the local server for the weather report web application. It uses npm for package management and build processes.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/weather_report/README.md#2025-04-16_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\n$ npm install\n$ npm run build\n$ npm start\n```\n\n----------------------------------------\n\nTITLE: Serving WebAssembly Files Using HTTP Servers\nDESCRIPTION: Commands for serving the compiled WebAssembly files locally using different HTTP server options. Includes options for the 'http' crate or Python's built-in HTTP servers.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/synchronous-instantiation/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# static server from https://crates.io/crates/https\nhttp\n\n# or use python\npython2 -m SimpleHTTPServer\npython3 -m http.server\n```\n\n----------------------------------------\n\nTITLE: Generated JavaScript for Structural Attribute with Future Proposals\nDESCRIPTION: This JavaScript snippet shows how the default `structural` attribute would generate code after implementing future WebAssembly proposals. It still includes a function shim for runtime prototype chain lookups.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/attributes/on-js-imports/final.md#2025-04-16_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nexport function __wbg_bar_a81456386e6b526f(varg1) {\n    return this.bar(varg1);\n}\n```\n\n----------------------------------------\n\nTITLE: Running the wasm-audio-worklet Example Locally\nDESCRIPTION: Command to build and run the wasm-audio-worklet example locally using Python. After running this command, the example can be accessed by visiting http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/wasm-audio-worklet/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ python3 run.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Cargo for WebAssembly Testing\nDESCRIPTION: This TOML configuration sets up Cargo to use the wasm-bindgen-test-runner for the wasm32-unknown-unknown target.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/usage.md#2025-04-16_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[target.wasm32-unknown-unknown]\nrunner = 'wasm-bindgen-test-runner'\n```\n\n----------------------------------------\n\nTITLE: Installing wasm-bindgen CLI using Cargo\nDESCRIPTION: This command installs the wasm-bindgen command line interface tool using Cargo, Rust's package manager. The -f flag forces a reinstall if the tool is already present.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/cli.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo install -f wasm-bindgen-cli\n```\n\n----------------------------------------\n\nTITLE: Configuring Rust Release Profile for Smaller WebAssembly Binaries\nDESCRIPTION: This TOML configuration enables Link Time Optimization (LTO) in the release profile, which helps generate smaller WebAssembly binaries for larger applications.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/add.md#2025-04-16_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[profile.release]\nlto = true\n```\n\n----------------------------------------\n\nTITLE: Running Web-sys DOM Example with NPM\nDESCRIPTION: Command to serve the web-sys DOM example locally using npm. This will start a local server that hosts the WebAssembly example.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/dom/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: WebIDL Warning Log Format\nDESCRIPTION: Example of a warning log message format when wasm_bindgen_webidl encounters unsupported WebIDL interface definitions during processing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/logging.md#2025-04-16_snippet_1\n\nLANGUAGE: text\nCODE:\n```\nWARN 2018-07-06T18:21:49Z: wasm_bindgen_webidl: Unsupported WebIDL interface: ...\n```\n\n----------------------------------------\n\nTITLE: Running UI Tests with Cargo on Unix/Linux\nDESCRIPTION: Command to execute UI tests for the wasm-bindgen-macro package. This runs the tests to verify that error messages match the expected output.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/macro/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo test -p wasm-bindgen-macro --test ui\n```\n\n----------------------------------------\n\nTITLE: Running Headless Browser Tests with wasm-pack\nDESCRIPTION: Command to run tests in multiple headless browsers using wasm-pack test command.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/browsers.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nwasm-pack test --headless --chrome --firefox --safari\n```\n\n----------------------------------------\n\nTITLE: Building and Serving the Rust WebAssembly Addition Example\nDESCRIPTION: Command to build and serve the Rust WebAssembly addition example locally. After running this command, the example can be accessed at http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/add/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Rust Raw Pointer Example\nDESCRIPTION: Example showing usage of raw pointer types (*const T and *mut T) in Rust code meant for WebAssembly compilation. The code appears to be included from an external file.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/pointers.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/src/pointers.rs}}\n```\n\n----------------------------------------\n\nTITLE: Running Local Server for Rust WebAssembly Example\nDESCRIPTION: This command starts a local server to run the Rust WebAssembly example that demonstrates importing non-browser JavaScript.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/import_js/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Building the WebAudio Example with npm\nDESCRIPTION: Command to build and serve the WebAudio example locally using npm. After running this command, the example can be accessed by visiting http://localhost:8080 in a browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/webaudio/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Compiling Publishing Script\nDESCRIPTION: Compiles the publish.rs script that handles the release process.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/publishing.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nrustc publish.rs\n```\n\n----------------------------------------\n\nTITLE: Running Local Development Server for Raytracing Demo\nDESCRIPTION: Command to start a local Python server to run the raytracing example. After running this command, the demo can be accessed at http://localhost:8000.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/raytrace-parallel/README.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n$ python3 run.py\n```\n\n----------------------------------------\n\nTITLE: Running Tests in Browser Environment via Environment Variable\nDESCRIPTION: Command to run WebAssembly tests targeting browsers using the WASM_BINDGEN_USE_BROWSER environment variable.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/browsers.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nWASM_BINDGEN_USE_BROWSER=1 cargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Serving WebAssembly Hello World Project\nDESCRIPTION: Command to serve the WebAssembly project locally using npm. Once running, the example can be accessed at http://localhost:8080 in a web browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/hello_world/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: JavaScript Raw Pointer Interaction\nDESCRIPTION: Example demonstrating how JavaScript code interacts with Rust raw pointers exposed through WebAssembly bindings. The code appears to be included from an external file.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/pointers.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/pointers.js}}\n```\n\n----------------------------------------\n\nTITLE: Setting Up Local Development Server\nDESCRIPTION: Shell commands for building WebAssembly code and starting a local development server using Python or miniserve\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/examples/without-a-bundler.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nwasm-pack build --target web\npython3 -m http.server 8080\n```\n\nLANGUAGE: shell\nCODE:\n```\ncargo install miniserve\nminiserve . --index \"index.html\" -p 8080\n```\n\n----------------------------------------\n\nTITLE: Demonstrating cargo test command for WebAssembly in Markdown\nDESCRIPTION: Shows the command line usage pattern for running Rust tests compiled to WebAssembly using the wasm-bindgen-test-runner crate.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/test-macro/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Testing WebAssembly with Deno\nDESCRIPTION: Command to test the WebAssembly module using Deno with file read permissions. The --allow-read flag is required for runtime Wasm file access until Deno issue #2552 is resolved.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/deno/README.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ deno run --allow-read test.ts\n```\n\n----------------------------------------\n\nTITLE: Running Local Development Server for WebAssembly Example\nDESCRIPTION: Command to start a local development server to run the WebAssembly char type example. The server will be accessible at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/char/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Inline Wasm-Bindgen Reference\nDESCRIPTION: Simple inline code reference showing the package name wasm-bindgen in a markdown context. This is not an actual code snippet but rather documentation formatting.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/introduction.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`wasm-bindgen`\n```\n\n----------------------------------------\n\nTITLE: Adding serde-wasm-bindgen Dependencies in Rust\nDESCRIPTION: This snippet shows how to add serde and serde-wasm-bindgen as dependencies in the Cargo.toml file for a Rust WebAssembly project.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/arbitrary-data-with-serde.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde-wasm-bindgen = \"0.4\"\n```\n\n----------------------------------------\n\nTITLE: Serving Static Files for WebAssembly Application\nDESCRIPTION: Commands to serve the static files locally using different HTTP servers. Includes options for using the http crate or Python's built-in HTTP servers.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/websockets/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# static server from https://crates.io/crates/https\nhttp\n\n# or use python\npython2 -m SimpleHTTPServer\npython3 -m http.server\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Link\nDESCRIPTION: Simple markdown documentation with a link to the wasm-bindgen online documentation\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/README.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Examples\n\nThis directory contains a number of Cargo projects that are all examples of how\nto use `wasm-bindgen` in various contexts. More documentation can be [found\nonline][dox]\n\n[dox]: https://rustwasm.github.io/docs/wasm-bindgen/examples/index.html\n```\n\n----------------------------------------\n\nTITLE: Building and Serving the 2D Canvas Example with npm\nDESCRIPTION: Command to build and serve the 2D Canvas example locally using npm, which will start a local development server at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/canvas/README.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Searching for WebIDL files in web-sys\nDESCRIPTION: Command to search for a specific Web API within the WebIDL files of the web-sys crate to determine if it already exists.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/supporting-more-web-apis.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngrep -rn MyWebApi crates/web-sys/webidls\n```\n\n----------------------------------------\n\nTITLE: Publishing to Cargo\nDESCRIPTION: Executes the publish script to release the updated crates to cargo registry.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/publishing.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure you are in the root of the wasm-bindgen repo!\n./publish publish\n```\n\n----------------------------------------\n\nTITLE: Bumping Version Numbers\nDESCRIPTION: Executes the publish script to bump minor versions of all crates in the wasm-bindgen repository.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/publishing.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Make sure you are in the root of the wasm-bindgen repo!\n./publish bump\n```\n\n----------------------------------------\n\nTITLE: Interacting with NonNull<T> in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to interact with Rust functions that use NonNull<T>. It shows how NonNull<T> is represented as a JavaScript number and how to use it in function calls.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/non-null.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/non_null.js}}\n```\n\n----------------------------------------\n\nTITLE: Building wasm-bindgen Console Log Example\nDESCRIPTION: Command to serve the WebAssembly console logging example locally using npm. Running this command starts a local server at http://localhost:8080 where the example can be viewed in a browser.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/console_log/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Moving WebIDL files to the enabled directory\nDESCRIPTION: Command to move a WebIDL file from an unavailable directory to the enabled directory to make the API available in web-sys.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/supporting-more-web-apis.md#2025-04-16_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd crates/web-sys\ngit mv webidls/unavailable_enum_ident/MyWebApi.webidl webidls/enabled/MyWebApi.webidl\n```\n\n----------------------------------------\n\nTITLE: Using js_sys::try_iter for JavaScript Iteration Protocol\nDESCRIPTION: The js_sys::try_iter function checks if JavaScript values implement the iteration protocol and provides a Rust iterator over their yielded values.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_17\n\nLANGUAGE: rust\nCODE:\n```\nuse js_sys::try_iter;\n\nfn process_iterable(js_value: &JsValue) {\n    // Check if the value is iterable and convert to Rust iterator\n    if let Ok(Some(iter)) = try_iter(js_value) {\n        for item in iter {\n            if let Ok(item) = item {\n                // process each item\n            }\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running NPM Server for WebAssembly Example\nDESCRIPTION: Command to serve the WebAssembly example locally using NPM. After running this command, the example can be accessed at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/wasm-in-wasm/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running Macro UI Tests\nDESCRIPTION: Command to run tests that verify error messages and source span accuracy for the #[wasm_bindgen] proc-macro.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/testing.md#2025-04-16_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ncargo test -p wasm-bindgen-macro\n```\n\n----------------------------------------\n\nTITLE: Running Local TodoMVC Server with NPM\nDESCRIPTION: Command to serve the TodoMVC example locally on port 8080 using npm\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/todomvc/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Running Wasm Tests for Node and Headless Browsers\nDESCRIPTION: Command to run the main wasm-bindgen test suite that compiles tests to WebAssembly and executes them in Node.js or headless browsers. Uses the split linked modules feature.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/testing.md#2025-04-16_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nWASM_BINDGEN_SPLIT_LINKED_MODULES=1 cargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Styling Team Member Images with CSS\nDESCRIPTION: CSS styling to control the size of team member profile images, ensuring they display consistently in the team members table.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/team.md#2025-04-16_snippet_0\n\nLANGUAGE: css\nCODE:\n```\nimg {\n    max-width: 117px;\n    max-height: 117px;\n}\n```\n\n----------------------------------------\n\nTITLE: Running Native Host Target Tests\nDESCRIPTION: Command to run the sanity test suite that verifies exported wasm-bindgen methods work on the native host target.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/testing.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncargo test\n```\n\n----------------------------------------\n\nTITLE: Running Web IDL Frontend Tests\nDESCRIPTION: Command to execute the test suite for the Web IDL frontend implementation targeting WebAssembly.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/testing.md#2025-04-16_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo test -p webidl-tests --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Running Local Web Server for web-sys Performance Demo\nDESCRIPTION: Command to start a local development server that hosts the web-sys performance.now() example at http://localhost:8080.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/performance/README.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm run serve\n```\n\n----------------------------------------\n\nTITLE: Static String Import in Rust\nDESCRIPTION: Example of importing strings as JsString through wasm_bindgen thread local static declarations\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen(thread_local, static_string)] static STRING: JsString = \"a string literal\";\n```\n\n----------------------------------------\n\nTITLE: Configuring AppVeyor for wasm-bindgen-test\nDESCRIPTION: AppVeyor configuration for Windows-based testing of wasm-bindgen in Chrome and Firefox. Sets up Rust nightly toolchain and configures WebDriver paths for browser testing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/continuous-integration.md#2025-04-16_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\ninstall:\n  - ps: Install-Product node 10\n  - appveyor-retry appveyor DownloadFile https://win.rustup.rs/ -FileName rustup-init.exe\n  - rustup-init.exe -y --default-host x86_64-pc-windows-msvc --default-toolchain nightly\n  - set PATH=%PATH%;C:\\Users\\appveyor\\.cargo\\bin\n  - rustc -V\n  - cargo -V\n  - rustup target add wasm32-unknown-unknown\n  - cargo install wasm-bindgen-cli\n\nbuild: false\n\ntest_script:\n  # Test in Chrome. chromedriver is installed by default in appveyor.\n  - set CHROMEDRIVER=C:\\Tools\\WebDriver\\chromedriver.exe\n  - cargo test --target wasm32-unknown-unknown\n  - set CHROMEDRIVER=\n  # Test in Firefox. geckodriver is also installed by default.\n  - set GECKODRIVER=C:\\Tools\\WebDriver\\geckodriver.exe\n  - cargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Running Wasm Tests with Cargo\nDESCRIPTION: Command to execute WebAssembly tests using cargo test with the wasm32-unknown-unknown target. This allows running tests compiled to WebAssembly instead of native code.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/wasm-bindgen-test/index.md#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncargo test --target wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Writing JavaScript Properties with Reflect::set in Rust/WASM\nDESCRIPTION: Shows how to write a property to a JavaScript object using js_sys::Reflect::set. Returns a boolean indicating if the update was successful.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/accessing-properties-of-untyped-js-values.md#2025-04-16_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\njs_sys::Reflect::set(&target, &property_key, &value)?;\n```\n\nLANGUAGE: javascript\nCODE:\n```\ntarget[property_key] = value;\n```\n\n----------------------------------------\n\nTITLE: Describing Example Tests for Rust WASM Bindgen in Markdown\nDESCRIPTION: This Markdown snippet explains the purpose and current limitations of the example tests for the wasm-bindgen project. It highlights that the tests open examples in a browser and check for console errors, with current support limited to Firefox.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/example-tests/README.md#2025-04-16_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n# example-tests\n\nTests that none of our examples are broken, by opening them in a browser\nand checking that no errors get logged to the console.\n\nThis currently only supports Firefox.\n```\n\n----------------------------------------\n\nTITLE: Updating wasm-bindgen Dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to update the wasm-bindgen dependency in a Rust project's Cargo.toml file to the latest version. The $TODO_VERSION placeholder should be replaced with the actual version number upon release.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/releases/release-announcement-template.md#2025-04-16_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nwasm-bindgen = \"$TODO_VERSION\"\n```\n\n----------------------------------------\n\nTITLE: Setting TRYBUILD Environment Variable in PowerShell\nDESCRIPTION: PowerShell command to set the TRYBUILD environment variable to 'overwrite', which is used on Windows to update reference files instead of using the update-all-references script.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/macro/README.md#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$env:TRYBUILD=\"overwrite\"\n```\n\n----------------------------------------\n\nTITLE: Configuring WASM_BINDGEN_TEST_TIMEOUT Environment Variable\nDESCRIPTION: Sets the timeout value for the wasm-bindgen-test-runner via an environment variable.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_3\n\nLANGUAGE: Shell\nCODE:\n```\nWASM_BINDGEN_TEST_TIMEOUT=300000\n```\n\n----------------------------------------\n\nTITLE: Renaming Exported Functions with js_name Attribute\nDESCRIPTION: The #[wasm_bindgen(js_name = \"name\")] attribute allows renaming exported functions and methods for JavaScript, enabling idiomatic naming conventions in both languages.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/CHANGELOG.md#2025-04-16_snippet_15\n\nLANGUAGE: rust\nCODE:\n```\n#[wasm_bindgen]\nimpl MyStruct {\n    // JavaScript will call this as myStruct.doSomething()\n    // Rust calls it as my_struct.do_something()\n    #[wasm_bindgen(js_name = doSomething)]\n    pub fn do_something(&self) {\n        // implementation\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Running web-sys tests with cargo for WebAssembly target\nDESCRIPTION: Commands to navigate to the web-sys directory within the wasm-bindgen repository and run tests using cargo test with the wasm32-unknown-unknown target. All features are enabled during testing.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/testing.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ncd wasm-bindgen/crates/web-sys\ncargo test --target wasm32-unknown-unknown --all-features\n```\n\n----------------------------------------\n\nTITLE: Referencing wasm-bindgen Types in Markdown\nDESCRIPTION: Code reference showing the inline usage of wasm-bindgen in documentation, demonstrating how to reference the tool name in markdown format.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/index.md#2025-04-16_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n`wasm-bindgen`\n```\n\n----------------------------------------\n\nTITLE: Starting HTTP Server for Benchmarks\nDESCRIPTION: Command to start a local HTTP server using the 'https' crate to serve the benchmark files.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/benchmarks/README.md#2025-04-16_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n$ http\n```\n\n----------------------------------------\n\nTITLE: Building WebAssembly Project\nDESCRIPTION: Command to build the WebAssembly example project using a shell script.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/examples/deno/README.md#2025-04-16_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ ./build.sh\n```\n\n----------------------------------------\n\nTITLE: Updating Test References on Unix/Linux\nDESCRIPTION: Shell command to update all reference files for UI tests. This should be run from within the ui-tests folder to generate or update the .stderr files when tests fail.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/crates/macro/README.md#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n./update-all-references.sh\n```\n\n----------------------------------------\n\nTITLE: Displaying web-sys Directory Structure\nDESCRIPTION: Shows the file and directory layout of the web-sys crate, including the build script, source files, and WebIDL definitions.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/contributing/web-sys/overview.md#2025-04-16_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n.\n├── build.rs\n├── Cargo.toml\n├── README.md\n├── src\n│   └── lib.rs\n└── webidls\n    └── enabled\n        └── ...\n```\n\n----------------------------------------\n\nTITLE: JavaScript External Type Implementation\nDESCRIPTION: Shows the JavaScript side implementation of types that are imported into Rust code through WebAssembly bindings.\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/types/imported-js-types.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../../examples/guide-supported-types-examples/imported_types.js}}\n```\n\n----------------------------------------\n\nTITLE: Using Duck-Typed Interfaces in JavaScript\nDESCRIPTION: Shows JavaScript implementation and usage of objects that conform to the duck-typed interface defined in Rust\nSOURCE: https://github.com/rustwasm/wasm-bindgen/blob/main/guide/src/reference/working-with-duck-typed-interfaces.md#2025-04-16_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n{{#include ../../../examples/duck-typed-interfaces/duck-typed-interfaces.js}}\n```"
  }
]