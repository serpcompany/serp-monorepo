[
  {
    "owner": "lucia-auth",
    "repo": "lucia",
    "content": "TITLE: Complete Session Management Implementation\nDESCRIPTION: The full TypeScript implementation of the session management system, combining all the functions for token generation, session creation, validation, and invalidation with the necessary type definitions.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait db.execute(\n\t\t\"INSERT INTO user_session (id, user_id, expires_at) VALUES (?, ?, ?)\",\n\t\tsession.id,\n\t\tsession.userId,\n\t\tsession.expiresAt\n\t);\n\treturn session;\n}\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst row = await db.queryOne(\n\t\t\"SELECT user_session.id, user_session.user_id, user_session.expires_at, app_user.id FROM user_session INNER JOIN user ON app_user.id = user_session.user_id WHERE id = ?\",\n\t\tsessionId\n\t);\n\tif (row === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst session: Session = {\n\t\tid: row[0],\n\t\tuserId: row[1],\n\t\texpiresAt: row[2]\n\t};\n\tconst user: User = {\n\t\tid: row[3]\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", session.id);\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait db.execute(\n\t\t\t\"UPDATE user_session SET expires_at = ? WHERE id = ?\",\n\t\t\tsession.expiresAt,\n\t\t\tsession.id\n\t\t);\n\t}\n\treturn { session, user };\n}\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE user_id = ?\", userId);\n}\n\nexport type SessionValidationResult =\n\t| { session: Session; user: User }\n\t| { session: null; user: null };\n\nexport interface Session {\n\tid: string;\n\tuserId: number;\n\texpiresAt: Date;\n}\n\nexport interface User {\n\tid: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Session Tokens and Extending Expiration if Active in TypeScript\nDESCRIPTION: This function validates a session token by hashing it to find the session in the database and checking expiration. If the session exists and is valid, it extends the expiration if less than 15 days remain. It also deletes expired sessions. It returns an object containing the session and associated user or null if invalid.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst result = await db\n\t\t.select({ user: userTable, session: sessionTable })\n\t\t.from(sessionTable)\n\t\t.innerJoin(userTable, eq(sessionTable.userId, userTable.id))\n\t\t.where(eq(sessionTable.id, sessionId));\n\tif (result.length < 1) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst { user, session } = result[0];\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait db.delete(sessionTable).where(eq(sessionTable.id, session.id));\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait db\n\t\t\t.update(sessionTable)\n\t\t\t.set({\n\t\t\t\texpiresAt: session.expiresAt\n\t\t\t})\n\t\t\t.where(eq(sessionTable.id, session.id));\n\t}\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Validation and Auto-Renewal\nDESCRIPTION: Function to validate session tokens by checking existence and expiration. Includes auto-renewal logic when sessions are within 15 days of expiration to maintain active sessions while allowing inactive ones to expire.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst row = await db.queryOne(\n\t\t\"SELECT user_session.id, user_session.user_id, user_session.expires_at, app_user.id FROM user_session INNER JOIN user ON app_user.id = user_session.user_id WHERE id = ?\",\n\t\tsessionId\n\t);\n\tif (row === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst session: Session = {\n\t\tid: row[0],\n\t\tuserId: row[1],\n\t\texpiresAt: row[2]\n\t};\n\tconst user: User = {\n\t\tid: row[3]\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", session.id);\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait db.execute(\n\t\t\t\"UPDATE user_session SET expires_at = ? WHERE id = ?\",\n\t\t\tsession.expiresAt,\n\t\t\tsession.id\n\t\t);\n\t}\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication Hook Implementation in SvelteKit\nDESCRIPTION: Implementation of a SvelteKit handle hook for centralized session validation. This hook intercepts all requests, validates the session token, updates the session cookie as needed, and makes user and session data available to all routes via event.locals.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// src/hooks.server.ts\nimport {\n\tvalidateSessionToken,\n\tsetSessionTokenCookie,\n\tdeleteSessionTokenCookie\n} from \"./lib/server/session\";\n\nimport type { Handle } from \"@sveltejs/kit\";\n\nexport const handle: Handle = async ({ event, resolve }) => {\n\tconst token = event.cookies.get(\"session\") ?? null;\n\tif (token === null) {\n\t\tevent.locals.user = null;\n\t\tevent.locals.session = null;\n\t\treturn resolve(event);\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session !== null) {\n\t\tsetSessionTokenCookie(event, token, session.expiresAt);\n\t} else {\n\t\tdeleteSessionTokenCookie(event);\n\t}\n\n\tevent.locals.session = session;\n\tevent.locals.user = user;\n\treturn resolve(event);\n};\n```\n\n----------------------------------------\n\nTITLE: Validating and Extending a Session Token - TypeScript\nDESCRIPTION: Validates a session token by hashing it, loading the session from Redis, checking for expiration, and extending the session if it's within 15 days of expiration. If expired, deletes session data. Handles Redis interaction and JSON session structure. Dependencies: @oslojs/encoding, @oslojs/crypto/sha2, redis client. Input: token string. Output: Session object or null if invalid. Ensures active sessions persist, optimizing for user experience and security.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { redis } from \"./redis.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function validateSessionToken(token: string): Promise<Session | null> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst item = await redis.get(`session:${sessionId}`);\n\tif (item === null) {\n\t\treturn null;\n\t}\n\n\tconst result = JSON.parse(item);\n\tconst session: Session = {\n\t\tid: result.id,\n\t\tuserId: result.user_id,\n\t\texpiresAt: new Date(result.expires_at * 1000)\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait redis.delete(`session:${sessionId}`);\n\t\tawait redis.srem(`user_sessions:${userId}`, sessionId);\n\t\treturn null;\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait redis.set(\n\t\t\t`session:${session.id}`,\n\t\t\tJSON.stringify({\n\t\t\t\tid: session.id,\n\t\t\t\tuser_id: session.userId,\n\t\t\t\texpires_at: Math.floor(session.expiresAt / 1000)\n\t\t\t}),\n\t\t\t{\n\t\t\t\tEXAT: Math.floor(session.expiresAt / 1000)\n\t\t\t}\n\t\t);\n\t}\n\treturn session;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Validating a session token and extending expiration in TypeScript\nDESCRIPTION: Implements `validateSessionToken()` which hashes the provided token, queries the database for the session with that ID, verifies if it exists and is not expired, deletes expired sessions, and extends the expiration date by 30 days if less than 15 days remain. Returns session and user data if valid, null otherwise. Relies on Oslo's encoding and crypto for hashing and encoding, and handles expiration logic for active sessions.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/mysql.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst row = await db.queryOne(\n\t\t\"SELECT user_session.id, user_session.user_id, user_session.expires_at, user.id FROM user_session INNER JOIN user ON user.id = user_session.user_id WHERE id = ?\",\n\t\tsessionId\n\t);\n\tif (row === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst session: Session = {\n\t\tid: row[0],\n\t\tuserId: row[1],\n\t\texpiresAt: row[2]\n\t};\n\tconst user: User = {\n\t\tid: row[3]\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", session.id);\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait db.execute(\n\t\t\t\"UPDATE user_session SET expires_at = ? WHERE id = ?\",\n\t\t\t\tsession.expiresAt,\n\t\t\t\tsession.id\n\t\t);\n\t}\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Session with Hashed ID and Expiration using TypeScript\nDESCRIPTION: This function takes a session token and user ID to create a session record. The session ID is generated by hashing the token with SHA-256 and encoding it in hexadecimal. The session expires after 30 days, and the session data is inserted into the database. It handles dependencies like database access, hashing, and encoding.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait db.insert(sessionTable).values(session);\n\treturn session;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating sessions in MySQL with TypeScript\nDESCRIPTION: Contains `invalidateSession()` and `invalidateAllSessions()` functions that delete a session by its ID or all sessions for a specific user from the `user_session` table, respectively. Uses Oslo's database abstraction for executing delete queries. Facilitates user logout or session invalidation for security.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/mysql.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE user_id = ?\", userId);\n}\n```\n\n----------------------------------------\n\nTITLE: Session Validation in SvelteKit Page Loader\nDESCRIPTION: Implementation of session validation in a SvelteKit page loader. This code retrieves the session cookie, validates the token, and handles invalid sessions by deleting the cookie. On successful validation, it refreshes the session cookie's expiration time.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// +page.server.ts\nimport { fail, redirect } from \"@sveltejs/kit\";\nimport {\n\tvalidateSessionToken,\n\tsetSessionTokenCookie,\n\tdeleteSessionTokenCookie\n} from \"$lib/server/session\";\n\nimport type { Actions, PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async (event) => {\n\tconst token = event.cookies.get(\"session\") ?? null;\n\tif (token === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session === null) {\n\t\tdeleteSessionTokenCookie(event);\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\tsetSessionTokenCookie(event, token, session.expiresAt);\n\n\t// ...\n};\n```\n\n----------------------------------------\n\nTITLE: Invalidating Single and All User Sessions in Redis - TypeScript\nDESCRIPTION: Provides two functions: one to invalidate a single session (deletes session and removes it from the user's session set), and one to invalidate all sessions for a user using Redis pipelining for efficiency. Input: sessionId, userId (for single session) and userId (for all sessions). Requires an instantiated redis client. Ensures clean removal of session(s) and their user-to-session relations.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { redis } from \"./redis.js\";\n\n// ...\n\nexport async function invalidateSession(sessionId: string, userId: number): Promise<void> {\n\tawait redis.delete(`session:${sessionId}`);\n\tawait redis.srem(`user_sessions:${userId}`, sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tconst sessionIds = await redis.smembers(`user_sessions:${userId}`);\n\tif (sessionIds.length < 1) {\n\t\treturn;\n\t}\n\n\tconst pipeline = redis.pipeline();\n\n\tfor (const sessionId of sessionIds) {\n\t\tpipeline.unlink(`session:${sessionId}`);\n\t}\n\tpipeline.unlink(`user_sessions:${userId}`);\n\n\tawait pipeline.exec();\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a session in MySQL with SHA-256 hashed session ID in TypeScript\nDESCRIPTION: Defines `createSession()` which hashes the generated token using SHA-256, encodes it in hex lowercase, and inserts a new session record into the `user_session` table with a 30-day expiration. Utilizes Oslo's crypto and encoding libraries for hashing and encoding. Ensures secure, unique identifiers for sessions linked to user IDs.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/mysql.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait db.execute(\n\t\t\"INSERT INTO user_session (id, user_id, expires_at) VALUES (?, ?, ?)\",\n\t\t\tsession.id,\n\t\t\tsession.userId,\n\t\t\texpiresAt: session.expiresAt\n\t);\n\treturn session;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Session\nDESCRIPTION: This asynchronous function creates a new session in the database.  It calculates a `sessionId` by hashing the provided `token` using `sha256` from `@oslojs/crypto/sha2`, and encoding the result using `encodeHexLowerCase` from `@oslojs/encoding`. It sets the `expiresAt` date to 30 days from the current time.  It utilizes Prisma's client to insert the new session into the database and returns the created session object.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prisma } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait prisma.session.create({\n\t\tdata: session\n\t});\n\treturn session;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating a Specific Session by ID in TypeScript\nDESCRIPTION: This function deletes a session record from the database by its session ID, effectively invalidating it and ending the session.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait db.delete(sessionTable).where(eq(sessionTable.id, sessionId));\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Session Management API Interface\nDESCRIPTION: TypeScript interface for the session management API. Includes function signatures for token generation, session creation, validation, and invalidation, along with necessary type definitions.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"./db.js\";\n\nexport function generateSessionToken(): string {\n\t// TODO\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\t// TODO\n}\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\t// TODO\n}\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\t// TODO\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\t// TODO\n}\n\nexport type SessionValidationResult =\n\t| { session: Session; user: User }\n\t| { session: null; user: null };\n\nexport interface Session {\n\tid: string;\n\tuserId: number;\n\texpiresAt: Date;\n}\n\nexport interface User {\n\tid: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating All Sessions for a User in TypeScript\nDESCRIPTION: This function deletes all sessions associated with a given user ID, effectively logging out the user from all devices.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait db.delete(sessionTable).where(eq(sessionTable.userId, userId));\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Session and Setting Cookie\nDESCRIPTION: This code provides an example of how to use the session API to create a session upon user sign-in.  It calls `generateSessionToken` to generate a token, creates a session with the user ID using the `createSession` function, and then sets a session token cookie on the user's client.  The dependency is the `setSessionTokenCookie` function (implementation not provided here).\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSessionToken, createSession } from \"./session.js\";\n\nconst token = generateSessionToken();\nconst session = createSession(token, userId);\nsetSessionTokenCookie(token);\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Invalidation Functions\nDESCRIPTION: Functions to invalidate individual sessions or all sessions for a user. These operations simply delete the relevant records from the database.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"./db.js\";\n\n// ...\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE id = ?\", sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE user_id = ?\", userId);\n}\n```\n\n----------------------------------------\n\nTITLE: Invalidating Sessions by Deletion in SQLite Using TypeScript\nDESCRIPTION: Provides functions to invalidate a single session by its ID and to invalidate all sessions associated with a specific user ID. These functions execute delete statements against the SQLite database to remove session entries, effectively logging out the session or all sessions for a user.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { db } from \"./db.js\";\n\n// ...\n\nexport function invalidateSession(sessionId: string): void {\n\tdb.execute(\"DELETE FROM session WHERE id = ?\", sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait db.execute(\"DELETE FROM user_session WHERE user_id = ?\", userId);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Session and Storing SHA-256 Hashed ID in SQLite Using TypeScript\nDESCRIPTION: Creates a session for a given token and user ID by computing the SHA-256 hash of the token, encoding it in lowercase hexadecimal, and setting an expiration date 30 days in the future. It inserts the session data into the SQLite database and returns the session object. Depends on Oslo encoding, Oslo crypto SHA-256 hashing, and a `db` module for database execution.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { db } from \"./db.js\";\nimport { encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport function createSession(token: string, userId: number): Session {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tdb.execute(\n\t\t\"INSERT INTO session (id, user_id, expires_at) VALUES (?, ?, ?)\",\n\t\tsession.id,\n\t\tsession.userId,\n\t\tMath.floor(session.expiresAt.getTime() / 1000)\n\t);\n\treturn session;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Authentication Context in SvelteKit Routes\nDESCRIPTION: Example of utilizing authentication context in SvelteKit page routes. This demonstrates how to access the user and session data in both page load functions and form actions to implement protected routes and authenticated operations.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// +page.server.ts\nimport { fail, redirect } from \"@sveltejs/kit\";\n\nimport type { Actions, PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async (event) => {\n\tif (event.locals.user === null) {\n\t\treturn redirect(\"/login\");\n\t}\n\t// ...\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tif (event.locals.user === null) {\n\t\t\tthrow fail(401);\n\t\t}\n\t\t// ...\n\t}\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Creation with SHA-256 Hashing\nDESCRIPTION: Function to create sessions linked to users. Uses SHA-256 to hash the token for secure storage, sets a 30-day expiration period, and stores the session data in PostgreSQL.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { db } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait db.execute(\n\t\t\"INSERT INTO user_session (id, user_id, expires_at) VALUES (?, ?, ?)\",\n\t\tsession.id,\n\t\tsession.userId,\n\t\tsession.expiresAt\n\t);\n\treturn session;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Secure Session Token Generation\nDESCRIPTION: Function to generate cryptographically secure session tokens using Web Crypto API. Creates a random byte array and encodes it using base32 for case-insensitive, compact representation.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { encodeBase32LowerCaseNoPadding } from \"@oslojs/encoding\";\n\n// ...\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating PostgreSQL Schema for User Sessions\nDESCRIPTION: SQL schema defining the tables required for user authentication and session management. Creates an app_user table for user data and a user_session table with necessary fields for session management including expiration timestamps.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_0\n\nLANGUAGE: sql\nCODE:\n```\nCREATE TABLE app_user (\n    id SERIAL PRIMARY KEY,\n    username TEXT NOT NULL UNIQUE\n);\n\nCREATE TABLE user_session (\n    id TEXT NOT NULL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES app_user(id),\n    expires_at TIMESTAMPTZ NOT NULL,\n);\n```\n\n----------------------------------------\n\nTITLE: Generating Secure Session Token with Web Crypto API in TypeScript\nDESCRIPTION: Generates a cryptographically secure random session token using the Web Crypto API to produce 20 random bytes. The bytes are then encoded in lowercase base32 without padding using the Oslo encoding package. This method ensures high entropy tokens safe for session identification, avoiding insecure RNGs like Math.random().\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { encodeBase32LowerCaseNoPadding } from \"@oslojs/encoding\";\n\n// ...\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User and Session Schemas for MySQL with Drizzle ORM in TypeScript\nDESCRIPTION: This snippet demonstrates how to define database schemas for 'user' and 'session' tables using Drizzle ORM specifically for MySQL. It utilizes `mysqlTable` to define columns, primary keys, foreign key relationships (`userId` referencing `userTable.id`), and data types like `int`, `varchar`, and `datetime`. It requires `mysql2/promise` for the connection and `drizzle-orm/mysql-core` for schema definition helpers. Inferred TypeScript types `User` and `Session` are also exported.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport mysql from \"mysql2/promise\";\nimport { mysqlTable, int, varchar, datetime } from \"drizzle-orm/mysql-core\";\nimport { drizzle } from \"drizzle-orm/mysql2\";\n\nimport type { InferSelectModel } from \"drizzle-orm\";\n\nconst connection = await mysql.createConnection();\nconst db = drizzle(connection);\n\nexport const userTable = mysqlTable(\"user\", {\n\tid: int(\"id\").primaryKey().autoincrement()\n});\n\nexport const sessionTable = mysqlTable(\"session\", {\n\tid: varchar(\"id\", {\n\t\tlength: 255\n\t}).primaryKey(),\n\tuserId: int(\"user_id\")\n\t\t.notNull()\n\t\t.references(() => userTable.id),\n\texpiresAt: datetime(\"expires_at\").notNull()\n});\n\nexport type User = InferSelectModel<typeof userTable>;\nexport type Session = InferSelectModel<typeof sessionTable>;\n```\n\n----------------------------------------\n\nTITLE: Handling GitHub OAuth Callback in SvelteKit\nDESCRIPTION: This SvelteKit server route handles the callback from GitHub. It validates the state parameter against the stored cookie, exchanges the authorization code for tokens using Arctic, fetches the user's profile from the GitHub API, checks if the user exists in the database (TODO), creates or retrieves the user, creates a session using Lucia Auth utilities, sets the session cookie, and redirects the user.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// routes/login/github/callback/+server.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"$lib/server/session\";\nimport { github } from \"$lib/server/oauth\";\n\nimport type { RequestEvent } from \"@sveltejs/kit\";\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(event: RequestEvent): Promise<Response> {\n\tconst code = event.url.searchParams.get(\"code\");\n\tconst state = event.url.searchParams.get(\"state\");\n\tconst storedState = event.cookies.get(\"github_oauth_state\") ?? null;\n\tif (code === null || state === null || storedState === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await github.validateAuthorizationCode(code);\n\t} catch (e) {\n\t\t// Invalid code or client credentials\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tconst githubUserResponse = await fetch(\"https://api.github.com/user\", {\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${tokens.accessToken()}`\n\t\t}\n\t});\n\tconst githubUser = await githubUserResponse.json();\n\tconst githubUserId = githubUser.id;\n\tconst githubUsername = githubUser.login;\n\n\t// TODO: Replace this with your own DB query.\n\tconst existingUser = await getUserFromGitHubId(githubUserId);\n\n\tif (existingUser) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, user.id);\n\t\tsetSessionTokenCookie(event, sessionToken, session.expiresAt);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: \"/\"\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO: Replace this with your own DB query.\n\tconst user = await createUser(githubUserId, githubUsername);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tsetSessionTokenCookie(event, sessionToken, session.expiresAt);\n\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: \"/\"\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Google Authorization URL in SvelteKit Route (TypeScript)\nDESCRIPTION: A SvelteKit API route (`routes/login/google/+server.ts`) handling GET requests. It generates a unique `state` and `codeVerifier` using Arctic, creates the Google authorization URL including `openid` and `profile` scopes, stores the `state` and `codeVerifier` in secure, HTTP-only cookies for later verification, and redirects the user to the generated Google authorization URL.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// routes/login/google/+server.ts\nimport { generateState, generateCodeVerifier } from \"arctic\";\nimport { google } from \"$lib/server/oauth\";\n\nimport type { RequestEvent } from \"@sveltejs/kit\";\n\nexport async function GET(event: RequestEvent): Promise<Response> {\n\tconst state = generateState();\n\tconst codeVerifier = generateCodeVerifier();\n\tconst url = google.createAuthorizationURL(state, codeVerifier, [\"openid\", \"profile\"]);\n\n\tevent.cookies.set(\"google_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\tevent.cookies.set(\"google_code_verifier\", codeVerifier, {\n\t\tpath: \"/\",\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: url.toString()\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic Session Management in TypeScript with Lucia v4\nDESCRIPTION: Example of creating and validating sessions in Lucia v4. The code demonstrates how to generate a random session ID using crypto API, encode it as a base32 string, and implement a validation function that returns both session and user data.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/migrate-lucia-v3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport function createSession(userId: number): Session {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst sessionId = encodeBase32LowerCaseNoPadding(bytes);\n\t// Insert session into database.\n\treturn session;\n}\n\nexport function validateSessionToken(sessionId: string): SessionValidationResult {\n\t// Get and validate session\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Prisma Session Model\nDESCRIPTION: This code defines the Prisma schema for the `User` and `Session` models. The `User` model contains an `id` field and a relationship to the `Session` model. The `Session` model includes fields for `id`, `userId`, and `expiresAt`, with a relation to the `User` model based on the `userId`.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_0\n\nLANGUAGE: prisma\nCODE:\n```\nmodel User {\n  id       Int       @id @default(autoincrement())\n  sessions Session[]\n}\n\nmodel Session {\n  id        String   @id\n  userId    Int\n  expiresAt DateTime\n\n  user      User     @relation(references: [id], fields: [userId], onDelete: Cascade)\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Current User in SvelteKit Load Function (TypeScript)\nDESCRIPTION: Example SvelteKit `load` function (`routes/+page.server.ts`) demonstrating how to access the authenticated user and session information, typically populated by Lucia middleware into `event.locals`. If no user is found (`event.locals.user` is null), it redirects the user to the login page.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// routes/+page.server.ts\nimport { redirect } from \"@sveltejs/kit\";\n\nimport type { PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async (event) => {\n\tif (!event.locals.user) {\n\t\treturn redirect(302, \"/login\");\n\t}\n\n\treturn {\n\t\tuser\n\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Validating Session Token\nDESCRIPTION: This asynchronous function validates a session token. It first calculates the session ID by hashing the token using SHA-256 and encoding it. It then queries the database for a session with the calculated ID, including the related user data. It checks if the session exists and whether it has expired. If the session has expired, it's deleted from the database. If the session is close to expiration (within 15 days), it's extended. The function returns the session and the user object if the session is valid, or `null` for both if invalid.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prisma } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst result = await prisma.session.findUnique({\n\t\twhere: {\n\t\t\tid: sessionId\n\t\t},\n\t\tinclude: {\n\t\t\tuser: true\n\t\t}\n\t});\n\tif (result === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst { user, ...session } = result;\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait prisma.session.delete({ where: { id: sessionId } });\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait prisma.session.update({\n\t\t\twhere: {\n\t\t\t\tid: session.id\n\t\t\t},\n\t\t\tdata: {\n\t\t\t\texpiresAt: session.expiresAt\n\t\t\t}\n\t\t});\n\t}\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Session from Cookie\nDESCRIPTION: This code snippet demonstrates how to use the `validateSessionToken` function to validate a session when a user revisits the application.  It retrieves the session token from a cookie, and then passes the token to `validateSessionToken`.  The return values are then processed to determine if a session exists.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { validateSessionToken } from \"./session.js\";\n\nconst token = cookies.get(\"session\");\nif (token !== null) {\n\tconst { session, user } = validateSessionToken(token);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign-out Functionality in Next.js\nDESCRIPTION: Next.js page component containing a form that triggers a server action (`logout`). The `logout` action retrieves the current session, invalidates it using Lucia Auth's `invalidateSession`, removes the session cookie using `deleteSessionTokenCookie`, and redirects the user to the login page. It includes basic error handling for unauthorized attempts.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getCurrentSession, invalidateSession, deleteSessionTokenCookie } from \"@/lib/session\";\nimport { redirect } from \"next/navigation\";\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n\treturn (\n\t\t<form action={logout}>\n\t\t\t<button>Sign out</button>\n\t\t</form>\n\t);\n}\n\nasync function logout(): Promise<ActionResult> {\n\t\"use server\";\n\tconst { session } = await getCurrentSession();\n\tif (!session) {\n\t\treturn {\n\t\t\terror: \"Unauthorized\"\n\t\t};\n\t}\n\n\tawait invalidateSession(session.id);\n\tawait deleteSessionTokenCookie();\n\treturn redirect(\"/login\");\n}\n\ninterface ActionResult {\n\terror: string | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User and Session Schemas for SQLite with Drizzle ORM in TypeScript\nDESCRIPTION: This snippet provides the schema definition for 'user' and 'session' tables using Drizzle ORM configured for SQLite. It uses `sqliteTable` to define columns with types `integer` and `text`, including setting the mode for the `expiresAt` timestamp to `timestamp`. Primary and foreign keys are established similarly to other database examples. It requires `better-sqlite3` for the database connection and `drizzle-orm/sqlite-core`. Inferred `User` and `Session` types are exported.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport sqlite from \"better-sqlite3\";\nimport { sqliteTable, integer, text } from \"drizzle-orm/sqlite-core\";\nimport { drizzle } from \"drizzle-orm/better-sqlite3\";\n\nimport type { InferSelectModel } from \"drizzle-orm\";\n\nconst sqliteDB = sqlite(\":memory:\");\nconst db = drizzle(sqliteDB);\n\nexport const userTable = sqliteTable(\"user\", {\n\tid: integer(\"id\").primaryKey()\n});\n\nexport const sessionTable = sqliteTable(\"session\", {\n\tid: text(\"id\").primaryKey(),\n\tuserId: integer(\"user_id\")\n\t\t.notNull()\n\t\t.references(() => userTable.id),\n\texpiresAt: integer(\"expires_at\", {\n\t\tmode: \"timestamp\"\n\t}).notNull()\n});\n\nexport type User = InferSelectModel<typeof userTable>;\nexport type Session = InferSelectModel<typeof sessionTable>;\n```\n\n----------------------------------------\n\nTITLE: Defining Session API Types\nDESCRIPTION: This code defines the types and structure of the session API, including the `User` and `Session` types imported from Prisma's client. It also defines a type `SessionValidationResult`, used to specify the return values of the `validateSessionToken` function.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { User, Session } from \"@prisma/client\";\n\nexport function generateSessionToken(): string {\n\t// TODO\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\t// TODO\n}\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\t// TODO\n}\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\t// TODO\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\t// TODO\n}\n\nexport type SessionValidationResult =\n\t| { session: Session; user: User }\n\t| { session: null; user: null };\n```\n\n----------------------------------------\n\nTITLE: Creating a Cached Session Validation Function for Next.js\nDESCRIPTION: A reusable function that implements session validation with React's cache() to optimize performance. This allows multiple calls to getCurrentSession() without incurring additional database queries, making it efficient for server components.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cookies } from \"next/headers\";\nimport { cache } from \"react\";\n\n// ...\n\nexport const getCurrentSession = cache(async (): Promise<SessionValidationResult> => {\n\tconst cookieStore = await cookies();\n\tconst token = cookieStore.get(\"session\")?.value ?? null;\n\tif (token === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst result = await validateSessionToken(token);\n\treturn result;\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Session Tokens in Next.js API Routes\nDESCRIPTION: Implementation of session token validation in a Next.js API route handler. The code extracts the session token from cookies, validates it, and returns appropriate responses based on the validation result.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { validateSessionToken } from \"$lib/server/session\";\n\nimport type { NextRequest } from \"next/server\";\n\nexport async function GET(request: NextRequest): Promise<Response> {\n\tconst token = request.cookies.get(\"session\")?.value ?? null;\n\tif (token === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Session Token\nDESCRIPTION: This function generates a random session token. It uses the `crypto.getRandomValues` function to generate 20 random bytes, which are then encoded using `encodeBase32LowerCaseNoPadding` from the `@oslojs/encoding` package.  It provides alternatives if the runtime does not support the `crypto` API. This is a core component of session security.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { encodeBase32LowerCaseNoPadding } from \"@oslojs/encoding\";\n\n// ...\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating User Sessions from Cookies\nDESCRIPTION: Example demonstrating how to validate a session token stored in cookies. Retrieves the token from cookies and uses the validateSessionToken function to check its validity.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { validateSessionToken } from \"./session.js\";\n\nconst token = cookies.get(\"session\");\nif (token !== null) {\n\tconst { session, user } = validateSessionToken(token);\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Session API\nDESCRIPTION: This is the full code of the session API that includes all the previously defined functions and types, combining all the functionality.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prisma } from \"./db.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\nimport type { User, Session } from \"@prisma/client\";\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait prisma.session.create({\n\t\tdata: session\n\t});\n\treturn session;\n}\n\nexport async function validateSessionToken(token: string): Promise<SessionValidationResult> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst result = await prisma.session.findUnique({\n\t\twhere: {\n\t\t\tid: sessionId\n\t\t},\n\t\tinclude: {\n\t\t\tuser: true\n\t\t}\n\t});\n\tif (result === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst { user, ...session } = result;\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait prisma.session.delete({ where: { id: sessionId } });\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait prisma.session.update({\n\t\t\twhere: {\n\t\t\t\tid: session.id\n\t\t\t},\n\t\t\tdata: {\n\t\t\t\texpiresAt: session.expiresAt\n\t\t\t}\n\t\t});\n\t}\n\treturn { session, user };\n}\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait prisma.session.delete({ where: { id: sessionId } });\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait prisma.session.deleteMany({\n\t\twhere: {\n\t\t\tuserId: userId\n\t\t}\n\t});\n}\n\nexport type SessionValidationResult =\n\t| { session: Session; user: User }\n\t| { session: null; user: null };\n```\n\n----------------------------------------\n\nTITLE: Example Usage of Session API for Creating and Validating Sessions in TypeScript\nDESCRIPTION: Demonstrates how to generate a new session token, create a session for a user, store the token in a client cookie, and later validate the session token from cookies to retrieve session and user info. Highlights integration points for session management in an application.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { generateSessionToken, createSession } from \"./session.js\";\n\nconst token = generateSessionToken();\nconst session = createSession(token, userId);\nsetSessionTokenCookie(token);\n```\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { validateSessionToken } from \"./session.js\";\n\nconst token = cookies.get(\"session\");\nif (token !== null) {\n\tconst { session, user } = validateSessionToken(token);\n}\n```\n\n----------------------------------------\n\nTITLE: Generating Secure Session Tokens with crypto and base32 Encoding in TypeScript\nDESCRIPTION: This function creates a secure, random session token by generating 20 random bytes using crypto.getRandomValues, then encoding the bytes with base32 for compactness and case insensitivity. It ensures strong randomness suitable for session tokens, avoiding insecure methods.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Required Dependencies\nDESCRIPTION: NPM command to install Oslo packages needed for encoding and cryptographic operations. Oslo provides typed, lightweight utilities that support various runtimes.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @oslojs/encoding @oslojs/crypto\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis-Based Token Bucket Rate Limiting in TypeScript\nDESCRIPTION: TypeScript class that implements the token bucket algorithm using Redis for distributed storage. It uses the pre-loaded Lua script for atomic operations and provides a clean API similar to the in-memory version.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TokenBucketRateLimit {\n\tprivate storageKey: string;\n\n\tpublic max: number;\n\tpublic refillIntervalSeconds: number;\n\n\tconstructor(storageKey: string, max: number, refillIntervalSeconds: number) {\n\t\tthis.storageKey = storageKey;\n\t\tthis.max = max;\n\t\tthis.refillIntervalSeconds = refillIntervalSeconds;\n\t}\n\n\tpublic async consume(key: string, cost: number): Promise<boolean> {\n\t\tconst result = await client.EVALSHA(SCRIPT_SHA, {\n\t\t\tkeys: [`${this.storageKey}:${key}`],\n\t\t\targuments: [\n\t\t\t\tthis.max.toString(),\n\t\t\t\tthis.refillIntervalSeconds.toString(),\n\t\t\t\tcost.toString(),\n\t\t\t\tMath.floor(Date.now() / 1000).toString()\n\t\t\t]\n\t\t});\n\t\treturn Boolean(result[0]);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Sign-In Page with GitHub OAuth Link in Next.js (TypeScript React)\nDESCRIPTION: Defines a server component in app/login/page.tsx that renders a sign-in UI with a link to initiate GitHub OAuth. The page is async, enabling future expansion. Clicking the link navigates users to the OAuth authorization flow. No explicit dependencies beyond standard Next.js App Router and React.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_5\n\nLANGUAGE: typescriptreact\nCODE:\n```\n// app/login/page.tsx\nexport default async function Page() {\n\treturn (\n\t\t<>\n\t\t\t<h1>Sign in</h1>\n\t\t\t<a href=\"/login/github\">Sign in with GitHub</a>\n\t\t</>\n\t);\n}\n```\n\n----------------------------------------\n\nTITLE: Loading the Redis Lua Script\nDESCRIPTION: Code snippet showing how to load the Lua script into Redis and retrieve the script hash for future reference, which is more efficient than sending the full script with each request.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst SCRIPT_SHA = await client.scriptLoad(script);\n```\n\n----------------------------------------\n\nTITLE: Invalidating a Session\nDESCRIPTION: This asynchronous function invalidates a session by deleting it from the database.  It takes the session ID as input and uses Prisma's `delete` operation to remove the corresponding session record.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { prisma } from \"./db.js\";\n\n// ...\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\tawait prisma.session.delete({ where: { id: sessionId } });\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tawait prisma.session.deleteMany({\n\t\twhere: {\n\t\t\tuserId: userId\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Generating OAuth Authorization URL and Setting State Cookie in Next.js Route Handler (TypeScript)\nDESCRIPTION: Implements a GET handler in app/login/github/route.ts. It generates a random OAuth state, builds GitHub's OAuth authorization URL, and stores the state value in a secure, HTTP-only cookie with a 10-minute expiry. Users are redirected to the authorization URL. Depends on Arctic's generateState and GitHub provider, and Next.js headers/cookies. Environment variable NODE_ENV controls cookie security. Required for initiating secure OAuth sign-in flow.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// app/login/github/route.ts\nimport { generateState } from \"arctic\";\nimport { github } from \"@/lib/oauth\";\nimport { cookies } from \"next/headers\";\n\nexport async function GET(): Promise<Response> {\n\tconst state = generateState();\n\tconst url = github.createAuthorizationURL(state, []);\n\n\tconst cookieStore = await cookies();\n\tcookieStore.set(\"github_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10,\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: url.toString()\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Optional Oslo Dependencies for Encoding and Crypto\nDESCRIPTION: This command installs optional dependencies `@oslojs/encoding` and `@oslojs/crypto` using npm. These packages provide lightweight, fully-typed helper functions for tasks like hashing session tokens, supporting various JavaScript runtimes with minimal external dependencies, as mentioned in the Lucia documentation context.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @oslojs/encoding @oslojs/crypto\n```\n\n----------------------------------------\n\nTITLE: Setting and Deleting Session Cookies in Astro API - TypeScript\nDESCRIPTION: These functions set and remove the session token cookie in an Astro API context. setSessionTokenCookie securely sets a 'session' cookie with recommended flags (HttpOnly, SameSite=Lax, Secure, Path, and expiry), depending on the deployment environment, while deleteSessionTokenCookie removes the cookie by setting its value to empty and Max-Age to 0. Requires a valid APIContext and expects a token string and expiry date for setting; no direct output except modifying the response cookies.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport type { APIContext } from \"astro\";\n\n// ...\n\nexport function setSessionTokenCookie(context: APIContext, token: string, expiresAt: Date): void {\n\tcontext.cookies.set(\"session\", token, {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\tsecure: import.meta.env.PROD,\n\t\texpires: expiresAt,\n\t\tpath: \"/\"\n\t});\n}\n\nexport function deleteSessionTokenCookie(context: APIContext): void {\n\tcontext.cookies.set(\"session\", \"\", {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\tsecure: import.meta.env.PROD,\n\t\tmaxAge: 0,\n\t\tpath: \"/\"\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Arctic Google Provider TypeScrpt\nDESCRIPTION: Demonstrates the TypeScript code required to import and initialize the Arctic Google OAuth provider, configuring it with the client ID, secret obtained from the `.env` file, and the designated redirect URI.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { Google } from \"arctic\";\n\nexport const google = new Google(\n\timport.meta.env.GOOGLE_CLIENT_ID,\n\timport.meta.env.GOOGLE_CLIENT_SECRET,\n\t\"http://localhost:4321/login/google/callback\"\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Google OAuth Environment Variables\nDESCRIPTION: Defines the necessary environment variables for Google OAuth within a `.env` file. The `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` are obtained from the Google Cloud Console after creating an OAuth client.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# .env\nGOOGLE_CLIENT_ID=\"\"\nGOOGLE_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Oslo Encoding and Crypto Dependencies with npm (Shell)\nDESCRIPTION: Installs the Oslo packages `@oslojs/encoding` and `@oslojs/crypto` via npm to support encoding operations and cryptographic hashing for sessions. These packages provide cross-runtime compatibility and lightweight, fully-typed implementations.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i @oslojs/encoding @oslojs/crypto\n```\n\n----------------------------------------\n\nTITLE: Accessing Authenticated User TypeScrpt\nDESCRIPTION: Provides an example of checking for and accessing the authenticated user object from `Astro.locals`, assuming a middleware is set up to load the user based on the session cookie.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nif (Astro.locals.user === null) {\n\treturn Astro.redirect(\"/login\");\n}\n\nconst user = Astro.locals.user;\n```\n\n----------------------------------------\n\nTITLE: Validating Session Token from Cookie - TypeScript\nDESCRIPTION: Shows client-provided token validation: retrieves session token from cookies, checks non-nullity, and calls validateSessionToken to load/verify the session. Input: none (uses cookies.get). Output: session object or null. Requires implementation of validateSessionToken in the imported module.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { validateSessionToken } from \"./session.js\";\n\nconst token = cookies.get(\"session\");\nif (token !== null) {\n\tconst session = validateSessionToken(token);\n}\n\n```\n\n----------------------------------------\n\nTITLE: Validating User Session on Page Load in Next.js\nDESCRIPTION: Example Next.js page component that uses `getCurrentSession` (presumably a custom function wrapping Lucia Auth logic) to check for an active user session. If no user is found (i.e., not authenticated), it redirects to the login page; otherwise, it displays a greeting.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { redirect } from \"next/navigation\";\nimport { getCurrentSession } from \"@/lib/session\";\n\nexport default async function Page() {\n\tconst { user } = await getCurrentSession();\n\tif (user === null) {\n\t\treturn redirect(\"/login\");\n\t}\n\treturn <h1>Hi, {user.name}!</h1>;\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current User from Session in Astro\nDESCRIPTION: Provides example code to access the current authenticated user from Astro's local context, assuming middleware for session handling is implemented, and redirects to login if no user is found.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nif (Astro.locals.user === null) {\n\treturn Astro.redirect(\"/login\");\n}\n\nconst user = Astro.locals.user;\n```\n\n----------------------------------------\n\nTITLE: Managing Session Cookies TypeScript\nDESCRIPTION: This snippet provides two functions for managing session cookies: setting and deleting. The `setSessionTokenCookie` function adds a `Set-Cookie` header with attributes like `HttpOnly`, `SameSite=Lax`, `Path=/`, and handles `Secure` and expiration (`Expires`) based on the environment (`PROD` or development). The `deleteSessionTokenCookie` function invalidates the cookie by setting `Max-Age=0`. Both functions adjust the `Secure` attribute based on whether the application is running in a production (HTTPS) environment or development (HTTP), and they assume a generic `HTTPResponse` interface and an `env` variable.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/index.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// `HTTPResponse` is a generic interface.\n// Adjust this code to fit your framework's API.\n\nexport function setSessionTokenCookie(response: HTTPResponse, token: string, expiresAt: Date): void {\n\tif (env === Env.PROD) {\n\t\t// When deployed over HTTPS\n\t\tresponse.headers.add(\n\t\t\t\"Set-Cookie\",\n\t\t\t`session=${token}; HttpOnly; SameSite=Lax; Expires=${expiresAt.toUTCString()}; Path=/; Secure;`\n\t\t);\n\t} else {\n\t\t// When deployed over HTTP (localhost)\n\t\tresponse.headers.add(\n\t\t\t\"Set-Cookie\",\n\t\t\t\"session=${token}; HttpOnly; SameSite=Lax; Expires=${expiresAt.toUTCString()}; Path=/\"\n\t\t);\n\t}\n}\n\nexport function deleteSessionTokenCookie(response: HTTPResponse): void {\n\tif (env === Env.PROD) {\n\t\t// When deployed over HTTPS\n\t\tresponse.headers.add(\n\t\t\t\"Set-Cookie\",\n\t\t\t\"session=; HttpOnly; SameSite=Lax; Max-Age=0; Path=/; Secure;\"\n\t\t);\n\t} else {\n\t\t// When deployed over HTTP (localhost)\n\t\tresponse.headers.add(\"Set-Cookie\", \"session=; HttpOnly; SameSite=Lax; Max-Age=0; Path=/\");\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Google OAuth Credentials\nDESCRIPTION: Defines environment variables within a `.env` file to store the Google Client ID and Client Secret required for the OAuth application.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# .env\nGOOGLE_CLIENT_ID=\"\"\nGOOGLE_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Signing Out by Invalidating Session and Removing Cookie in Next.js (TypeScript React)\nDESCRIPTION: Contains a page component and logout action that invalidates the session and removes the session cookie on sign-out. The form/button calls the logout function, which checks for an active session, invalidates it, deletes the session token cookie, and redirects to the login page. Relies on session utility functions and Next.js APIs. Input and output types are specified for session data and result objects.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_9\n\nLANGUAGE: typescriptreact\nCODE:\n```\nimport { getCurrentSession, invalidateSession, deleteSessionTokenCookie } from \"@/lib/session\";\nimport { redirect } from \"next/navigation\";\nimport { cookies } from \"next/headers\";\n\nexport default async function Page() {\n\treturn (\n\t\t<form action={logout}>\n\t\t\t<button>Sign out</button>\n\t\t</form>\n\t);\n}\n\nasync function logout(): Promise<ActionResult> {\n\t\"use server\";\n\tconst { session } = await getCurrentSession();\n\tif (!session) {\n\t\treturn {\n\t\t\terror: \"Unauthorized\"\n\t\t};\n\t}\n\n\tawait invalidateSession(session.id);\n\tawait deleteSessionTokenCookie();\n\treturn redirect(\"/login\");\n}\n\ninterface ActionResult {\n\terror: string | null;\n}\n```\n\n----------------------------------------\n\nTITLE: Generating GitHub OAuth Authorization URL in SvelteKit\nDESCRIPTION: This SvelteKit server route (`+server.ts`) generates a unique state string, creates the GitHub OAuth authorization URL using the Arctic client, sets the state in an HTTP-only cookie, and redirects the user's browser to the generated URL.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// routes/login/github/+server.ts\nimport { generateState } from \"arctic\";\nimport { github } from \"$lib/server/oauth\";\n\nimport type { RequestEvent } from \"@sveltejs/kit\";\n\nexport async function GET(event: RequestEvent): Promise<Response> {\n\tconst state = generateState();\n\tconst url = github.createAuthorizationURL(state, []);\n\n\tevent.cookies.set(\"github_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10,\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: url.toString()\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing CSRF Protection TypeScript\nDESCRIPTION: This snippet demonstrates a basic CSRF protection mechanism by checking the 'Origin' header for incoming requests that are not GET requests. It compares the 'Origin' header against an expected value (`https://example.com`). If the origin is missing or doesn't match, it sets a 403 Forbidden status code on the response. This method relies on the browser sending the 'Origin' header and the application avoiding state-changing GET requests. It assumes generic `HTTPRequest` and `HTTPResponse` interfaces.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/index.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// `HTTPRequest` and `HTTPResponse` are generic interfaces.\n// Adjust this code to fit your framework's API.\n\nfunction handleRequest(request: HTTPRequest, response: HTTPResponse): void {\n\tif (request.method !== \"GET\") {\n\t\tconst origin = request.headers.get(\"Origin\");\n\t\t// You can also compare it against the Host or X-Forwarded-Host header.\n\t\tif (origin === null || origin !== \"https://example.com\") {\n\t\t\tresponse.setStatusCode(403);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Deleting Session Cookies in Next.js\nDESCRIPTION: Functions for managing session cookies with proper security attributes. The implementation uses Next.js's cookies API to set and delete cookies with HttpOnly, SameSite, Secure, and appropriate expiration settings.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cookies } from \"next/headers\";\n\n// ...\n\nexport async function setSessionTokenCookie(token: string, expiresAt: Date): Promise<void> {\n\tconst cookieStore = await cookies();\n\tcookieStore.set(\"session\", token, {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\texpires: expiresAt,\n\t\tpath: \"/\"\n\t});\n}\n\nexport async function deleteSessionTokenCookie(): Promise<void> {\n\tconst cookieStore = await cookies();\n\tcookieStore.set(\"session\", \"\", {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\tmaxAge: 0,\n\t\tpath: \"/\"\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Session API for Sign-In and Token Handling - TypeScript\nDESCRIPTION: Demonstrates usage of the session management API: generating a session token, creating a session for a user, and setting the token as a cookie. Requires prior implementation of generateSessionToken and createSession. Shows typical call sequence at user sign-in. Input: userId (number). Output: sets cookie and creates session.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { generateSessionToken, createSession } from \"./session.js\";\n\nconst token = generateSessionToken();\nconst session = createSession(token, userId);\nsetSessionTokenCookie(token);\n\n```\n\n----------------------------------------\n\nTITLE: Validating Current Session in Next.js Page Using getCurrentSession (TypeScript React)\nDESCRIPTION: Implements a page component that calls getCurrentSession to retrieve the user. If the user is absent, it redirects to the login page; otherwise, it renders a welcome message. Intended for authenticated routes in Next.js App Router. Relies on custom session utility import and Next.js's redirect function.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_8\n\nLANGUAGE: typescriptreact\nCODE:\n```\nimport { redirect } from \"next/navigation\";\nimport { getCurrentSession } from \"@/lib/session\";\n\nexport default async function Page() {\n\tconst { user } = await getCurrentSession();\n\tif (user === null) {\n\t\treturn redirect(\"/login\");\n\t}\n\treturn <h1>Hi, {user.username}!</h1>;\n}\n```\n\n----------------------------------------\n\nTITLE: Comprehensive Session Management Implementation with Redis - TypeScript\nDESCRIPTION: Presents the full session lifecycle management implementation in one file: generating and hashing tokens, creating and persisting session objects, validating and conditionally extending sessions, and procedures for invalidation. All functions are present and interact with Redis for storage and retrieval. Dependencies: @oslojs/encoding, @oslojs/crypto/sha2, redis client instance, Web Crypto API. Session interface included for strong typing.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { redis } from \"./redis.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait redis.set(\n\t\t`session:${session.id}`,\n\t\tJSON.stringify({\n\t\t\tid: session.id,\n\t\t\tuser_id: session.userId,\n\t\t\texpires_at: Math.floor(session.expiresAt / 1000)\n\t\t}),\n\t\t{\n\t\t\tEXAT: Math.floor(session.expiresAt / 1000)\n\t\t}\n\t);\n\tawait redis.sadd(`user_sessions:${userId}`, sessionId);\n\n\treturn session;\n}\n\nexport async function validateSessionToken(token: string): Promise<Session | null> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst item = await redis.get(`session:${sessionId}`);\n\tif (item === null) {\n\t\treturn null;\n\t}\n\n\tconst result = JSON.parse(item);\n\tconst session: Session = {\n\t\tid: result.id,\n\t\tuserId: result.user_id,\n\t\texpiresAt: new Date(result.expires_at * 1000)\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tawait redis.delete(`session:${sessionId}`);\n\t\tawait redis.srem(`user_sessions:${userId}`, sessionId);\n\t\treturn null;\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tawait redis.set(\n\t\t\t`session:${session.id}`,\n\t\t\tJSON.stringify({\n\t\t\t\tid: session.id,\n\t\t\t\tuser_id: session.userId,\n\t\t\t\texpires_at: Math.floor(session.expiresAt / 1000)\n\t\t\t}),\n\t\t\t{\n\t\t\t\tEXAT: Math.floor(session.expiresAt / 1000)\n\t\t\t}\n\t\t);\n\t}\n\treturn session;\n}\n\nexport async function invalidateSession(sessionId: string, userId: number): Promise<void> {\n\tawait redis.delete(`session:${sessionId}`);\n\tawait redis.srem(`user_sessions:${userId}`, sessionId);\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\tconst sessionIds = await redis.smembers(`user_sessions:${userId}`);\n\tif (sessionIds.length < 1) {\n\t\treturn;\n\t}\n\n\tconst pipeline = redis.pipeline();\n\n\tfor (const sessionId of sessionIds) {\n\t\tpipeline.unlink(`session:${sessionId}`);\n\t}\n\tpipeline.unlink(`user_sessions:${userId}`);\n\n\tawait pipeline.exec();\n}\n\nexport interface Session {\n\tid: string;\n\tuserId: number;\n\texpiresAt: Date;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using Session Validation in Next.js Server Components and Actions\nDESCRIPTION: Example of how to use the getCurrentSession() function in both server components and server actions. This pattern demonstrates authentication checks and redirects for unauthenticated users in both contexts.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// app/api/page.tsx\nimport { redirect } from \"next/navigation\";\n\nasync function Page() {\n\tconst { user } = await getCurrentSession();\n\tif (user === null) {\n\t\treturn redirect(\"/login\");\n\t}\n\n\tasync function action() {\n\t\t\"use server\";\n\t\tconst { user } = await getCurrentSession();\n\t\tif (user === null) {\n\t\t\treturn redirect(\"/login\");\n\t\t}\n\t\t// ...\n\t}\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Session Tokens in Astro Endpoints - TypeScript\nDESCRIPTION: This async function demonstrates validation of a session token from cookies in an Astro API GET handler. It extracts the session token, validates it, deletes the cookie if invalid, and refreshes it if valid, using imported utility functions. Depends on validateSessionToken, setSessionTokenCookie, and deleteSessionTokenCookie from project-specific modules, as well as the APIContext type. The main input is the request context; the output is a Response object with status 401 if unauthenticated.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n\tvalidateSessionToken,\n\tsetSessionTokenCookie,\n\tdeleteSessionTokenCookie\n} from \"$lib/server/session\";\n\nimport type { APIContext } from \"astro\";\n\nexport async function GET(context: APIContext): Promise<Response> {\n\tconst token = context.cookies.get(\"session\")?.value ?? null;\n\tif (token === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session === null) {\n\t\tdeleteSessionTokenCookie(context);\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\tsetSessionTokenCookie(context, token, session.expiresAt);\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting GitHub OAuth Credentials in Environment Variables (Bash)\nDESCRIPTION: This snippet represents the required entries for the .env file of a Next.js project to store GitHub OAuth client credentials. The variables are populated by values obtained from GitHub's developer settings page. The environment variables must be loaded at runtime for correct operation.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nGITHUB_CLIENT_ID=\"\"\nGITHUB_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Generating Google Authorization URL TypeScrpt\nDESCRIPTION: An Astro API route (`pages/login/google/index.ts`) demonstrating how to generate a Google OAuth authorization URL. It creates and stores the required state and code verifier in cookies and redirects the user to Google's sign-in page.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\n// pages/login/google/index.ts\nimport { generateState } from \"arctic\";\nimport { google } from \"@lib/oauth\";\n\nimport type { APIContext } from \"astro\";\n\nexport async function GET(context: APIContext): Promise<Response> {\n\tconst state = generateState();\n\tconst codeVerifier = generateCodeVerifier();\n\tconst url = google.createAuthorizationURL(state, codeVerifier, [\"openid\", \"profile\"]);\n\n\tcontext.cookies.set(\"google_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\tsecure: import.meta.env.PROD,\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\tcontext.cookies.set(\"google_code_verifier\", codeVerifier, {\n\t\tpath: \"/\",\n\t\tsecure: import.meta.env.PROD,\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn context.redirect(url.toString());\n}\n```\n\n----------------------------------------\n\nTITLE: Generating a cryptographically secure 20-byte session token in TypeScript\nDESCRIPTION: Creates a function `generateSessionToken()` that generates a 20-byte random token using secure browser or Node.js APIs, then encodes it in base32 case-insensitive format. This token serves as a user session identifier ensuring high entropy and security. Depends on Oslo's encoding library `@oslojs/encoding` and the Web Crypto API.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/mysql.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Sign-in Page with OAuth Link in Astro HTML\nDESCRIPTION: Defines a simple sign-in page with a link button directing users to initiate GitHub OAuth login via `/login/github`. The page provides a basic user interface for authentication initiation.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_3\n\nLANGUAGE: html\nCODE:\n```\n<!-- pages/login/index.astro -->\n<html lang=\"en\">\n\t<body>\n\t\t<h1>Sign in</h1>\n\t\t<a href=\"/login/github\">Sign in with GitHub</a>\n\t</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Handling GitHub OAuth Callback, Validating State, and Managing Sessions (TypeScript)\nDESCRIPTION: Implements a GET route handler for app/login/github/callback/route.ts. It validates OAuth state, exchanges authorization code for tokens, fetches user profile from GitHub, and checks/extracts user data. If the user exists, creates a session and sets a session cookie; if not, creates a new user. Depends on Arctic, custom session functions, and various Next.js APIs. Requires REAL implementations for getUserFromGitHubId, createUser, and session handling. Expects Request input and sends a redirect response.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// app/login/github/callback/route.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"@/lib/session\";\nimport { github } from \"@/lib/oauth\";\nimport { cookies } from \"next/headers\";\n\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(request: Request): Promise<Response> {\n\tconst url = new URL(request.url);\n\tconst code = url.searchParams.get(\"code\");\n\tconst state = url.searchParams.get(\"state\");\n\tconst cookieStore = await cookies();\n\tconst storedState = cookieStore.get(\"github_oauth_state\")?.value ?? null;\n\tif (code === null || state === null || storedState === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await github.validateAuthorizationCode(code);\n\t} catch (e) {\n\t\t// Invalid code or client credentials\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tconst githubUserResponse = await fetch(\"https://api.github.com/user\", {\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${tokens.accessToken()}`\n\t\t}\n\t});\n\tconst githubUser = await githubUserResponse.json();\n\tconst githubUserId = githubUser.id;\n\tconst githubUsername = githubUser.login;\n\n\t// TODO: Replace this with your own DB query.\n\tconst existingUser = await getUserFromGitHubId(githubUserId);\n\n\tif (existingUser !== null) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, existingUser.id);\n\t\tawait setSessionTokenCookie(sessionToken, session.expiresAt);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: \"/\"\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO: Replace this with your own DB query.\n\tconst user = await createUser(githubUserId, githubUsername);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tawait setSessionTokenCookie(sessionToken, session.expiresAt);\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: \"/\"\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Session Cookie Expiration in Next.js Middleware\nDESCRIPTION: A middleware implementation that extends session cookie expiration only for GET requests to avoid conflicts with newly set cookies in server actions or route handlers. It also includes CSRF protection for non-GET requests.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// middleware.ts\nimport { NextResponse } from \"next/server\";\n\nimport type { NextRequest } from \"next/server\";\n\nexport async function middleware(request: NextRequest): Promise<NextResponse> {\n\tif (request.method === \"GET\") {\n\t\tconst response = NextResponse.next();\n\t\tconst token = request.cookies.get(\"session\")?.value ?? null;\n\t\tif (token !== null) {\n\t\t\t// Only extend cookie expiration on GET requests since we can be sure\n\t\t\t// a new session wasn't set when handling the request.\n\t\t\tresponse.cookies.set(\"session\", token, {\n\t\t\t\tpath: \"/\",\n\t\t\t\tmaxAge: 60 * 60 * 24 * 30,\n\t\t\t\tsameSite: \"lax\",\n\t\t\t\thttpOnly: true,\n\t\t\t\tsecure: process.env.NODE_ENV === \"production\"\n\t\t\t});\n\t\t}\n\t\treturn response;\n\t}\n\n\t// CSRF protection\n\n\treturn NextResponse.next();\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Redis-Based Throttler Class in TypeScript Using Lua Script\nDESCRIPTION: Defines a TypeScript `Throttler` class that interacts with Redis to enforce login throttling via a preloaded Lua script. It uses the EVALSHA command with keys and current UNIX timestamp arguments to atomically manage user lockout status. The `consume` method returns a boolean indicating if the attempt is allowed, and `reset` deletes the Redis key to clear throttle state. Requires initialized Redis client and script SHA hash. Inputs are string keys representing users and timestamps; output is boolean or void.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Throttler {\n\tprivate storageKey: string;\n\n\tconstructor(storageKey: string) {\n\t\tthis.storageKey = storageKey;\n\t}\n\n\tpublic async consume(key: string): Promise<boolean> {\n\t\tconst result = await client.EVALSHA(SCRIPT_SHA, {\n\t\t\tkeys: [`${this.storageKey}:${key}`],\n\t\t\targuments: [Math.floor(Date.now() / 1000).toString()]\n\t\t});\n\t\treturn Boolean(result[0]);\n\t}\n\n\tpublic async reset(key: string): Promise<void> {\n\t\tawait client.DEL(key);\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Using Redis-Based Throttler Class for User Login Attempts in TypeScript\nDESCRIPTION: Example usage of the Redis-backed `Throttler` class showing instantiation, consuming throttling state per user ID to prevent excessive requests, password verification, and resetting throttle on successful login. Assumes the Lua script is loaded and linked to the class. Inputs are user IDs and passwords with outputs as exceptions on rate limiting or invalid credentials.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst throttler = new Throttler<number>(\"login_throttler\");\n\nif (!throttler.consume(userId)) {\n\tthrow new Error(\"Too many requests\");\n}\nconst validPassword = verifyPassword(password);\nif (!validPassword) {\n\tthrow new Error(\"Invalid password\");\n}\nthrottler.reset(user.id);\n```\n\n----------------------------------------\n\nTITLE: Implementing In-Memory Token Bucket Rate Limiting in TypeScript\nDESCRIPTION: A TypeScript class implementation of the token bucket algorithm using in-memory storage. It maintains a bucket of tokens for each user that gets refilled at configured intervals, allowing for burst handling while preventing abuse.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport class TokenBucketRateLimit<_Key> {\n\tpublic max: number;\n\tpublic refillIntervalSeconds: number;\n\n\tconstructor(max: number, refillIntervalSeconds: number) {\n\t\tthis.max = max;\n\t\tthis.refillIntervalSeconds = refillIntervalSeconds;\n\t}\n\n\tprivate storage = new Map<_Key, Bucket>();\n\n\tpublic consume(key: _Key, cost: number): boolean {\n\t\tlet bucket = this.storage.get(key) ?? null;\n\t\tconst now = Date.now();\n\t\tif (bucket === null) {\n\t\t\tbucket = {\n\t\t\t\tcount: this.max - cost,\n\t\t\t\trefilledAt: now\n\t\t\t};\n\t\t\tthis.storage.set(key, bucket);\n\t\t\treturn true;\n\t\t}\n\t\tconst refill = Math.floor((now - bucket.refilledAt) / (this.refillIntervalSeconds * 1000));\n\t\tbucket.count = Math.min(bucket.count + refill, this.max);\n\t\tbucket.refilledAt = bucket.refilledAt + refill * this.refillIntervalSeconds * 1000;\n\t\tif (bucket.count < cost) {\n\t\t\treturn false;\n\t\t}\n\t\tbucket.count -= cost;\n\t\tthis.storage.set(key, bucket);\n\t\treturn true;\n\t}\n}\n\ninterface Bucket {\n\tcount: number;\n\trefilledAt: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Atomic Redis Throttling Logic Using Lua Script\nDESCRIPTION: A Lua script designed for redis that atomically manages login throttling data, storing the number of failed attempts and last update timestamp in a hash per user key. It compares current time with lockout durations defined in a local table, returns 1 if the user can proceed, or 0 if still locked out. The script increases the lockout index after each failed attempt, enforcing progressively longer delays. Inputs include the redis key and the current timestamp in seconds; output is a numeric array with 1 or 0 indicating allowance.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_2\n\nLANGUAGE: Lua\nCODE:\n```\n-- Returns 1 if allowed, 0 if not\nlocal key                   = KEYS[1]\nlocal now                   = tonumber(ARGV[1])\n\nlocal timeoutSeconds = {1, 2, 4, 8, 16, 30, 60, 180, 300}\n\nlocal fields = redis.call(\"HGETALL\", key)\nif #fields == 0 then\n    redis.call(\"HSET\", key, \"index\", 1, \"updated_at\", now)\n    return {1}\nend\nlocal index = 0\nlocal updatedAt = 0\nfor i = 1, #fields, 2 do\n\tif fields[i] == \"index\" then\n        index = tonumber(fields[i+1])\n    elseif fields[i] == \"updated_at\" then\n        updatedAt = tonumber(fields[i+1])\n    end\nend\nlocal allowed = now - updatedAt >= timeoutSeconds[index]\nif not allowed then\n    return {0}\nend\nindex = math.min(index + 1, #timeoutSeconds)\nredis.call(\"HSET\", key, \"index\", index, \"updated_at\", now)\nreturn {1}\n```\n\n----------------------------------------\n\nTITLE: Generating a Secure Base32 Session Token - TypeScript\nDESCRIPTION: Implements a session token generator using 20 bytes of cryptographically-secure random data, encoded in base32 (lowercase, no padding) using @oslojs/encoding. Relies on the Web Crypto API's getRandomValues. Ensures tokens are suitable for authentication by avoiding insecure RNGs. Prerequisites: @oslojs/encoding package and a Web Crypto-compatible runtime.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { encodeBase32LowerCaseNoPadding } from \"@oslojs/encoding\";\n\n// ...\n\nexport function generateSessionToken(): string {\n\tconst bytes = new Uint8Array(20);\n\tcrypto.getRandomValues(bytes);\n\tconst token = encodeBase32LowerCaseNoPadding(bytes);\n\treturn token;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using the In-Memory Token Bucket Rate Limiter\nDESCRIPTION: Example of initializing and using the in-memory token bucket rate limiter to protect against excessive requests. The example creates a bucket with 10 maximum tokens that refills at 2 tokens per second.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// Bucket that has 10 tokens max and refills at a rate of 2 tokens/sec\nconst ratelimit = new TokenBucketRateLimit<string>(10, 2);\n\nif (!ratelimit.consume(ip, 1)) {\n\tthrow new Error(\"Too many requests\");\n}\n```\n\n----------------------------------------\n\nTITLE: Generating OAuth Authorization URL and State in TypeScript\nDESCRIPTION: Handles GET requests to initiate OAuth login by generating secure state, creating authorization URL, setting the state in secure cookies, and redirecting the user to GitHub authorization page.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/login/github/index.ts\nimport { generateState } from \"arctic\";\nimport { github } from \"@lib/oauth\";\n\nimport type { APIContext } from \"astro\";\n\nexport async function GET(context: APIContext): Promise<Response> {\n\tconst state = generateState();\n\tconst url = github.createAuthorizationURL(state, []);\n\n\tcontext.cookies.set(\"github_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\tsecure: import.meta.env.PROD,\n\t\thttpOnly: true,\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn context.redirect(url.toString());\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Google OAuth Callback in SvelteKit Route (TypeScript)\nDESCRIPTION: SvelteKit API route (`routes/login/google/callback/+server.ts`) handling the GET request from Google after user authentication. It retrieves the `code` and `state` from the URL, validates the `state` against the stored cookie value, uses Arctic to validate the authorization `code` with the stored `codeVerifier`, decodes the ID token to get user claims (ID and username), checks if the user exists in the database (placeholder logic), creates a new user if necessary (placeholder logic), creates a Lucia session, sets the session cookie using Lucia helpers, and redirects the authenticated user to the application's root.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// routes/login/google/callback/+server.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"$lib/server/session\";\nimport { google } from \"$lib/server/oauth\";\nimport { decodeIdToken } from \"arctic\";\n\nimport type { RequestEvent } from \"@sveltejs/kit\";\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(event: RequestEvent): Promise<Response> {\n\tconst code = event.url.searchParams.get(\"code\");\n\tconst state = event.url.searchParams.get(\"state\");\n\tconst storedState = event.cookies.get(\"google_oauth_state\") ?? null;\n\tconst codeVerifier = event.cookies.get(\"google_code_verifier\") ?? null;\n\tif (code === null || state === null || storedState === null || codeVerifier === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await google.validateAuthorizationCode(code, codeVerifier);\n\t} catch (e) {\n\t\t// Invalid code or client credentials\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tconst claims = decodeIdToken(tokens.idToken());\n\tconst googleUserId = claims.sub;\n\tconst username = claims.name;\n\n\t// TODO: Replace this with your own DB query.\n\tconst existingUser = await getUserFromGoogleId(googleUserId);\n\n\tif (existingUser !== null) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, existingUser.id);\n\t\tsetSessionTokenCookie(event, sessionToken, session.expiresAt);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: \"/\"\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO: Replace this with your own DB query.\n\tconst user = await createUser(googleUserId, username);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tsetSessionTokenCookie(event, sessionToken, session.expiresAt);\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: \"/\"\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Redis-Based Token Bucket Rate Limiter\nDESCRIPTION: Example of initializing and using the Redis-based token bucket rate limiter in an asynchronous context. It creates a bucket with 10 maximum tokens that refills at 2 tokens per second.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// Bucket that has 10 tokens max and refills at a rate of 2 tokens/sec.\n// Ensure that the storage key is unique.\nconst ratelimit = new TokenBucketRateLimit(\"global_ip\", 10, 2);\n\nconst valid = await ratelimit.consume(ip, 1);\nif (!valid) {\n\tthrow new Error(\"Too many requests\");\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Arctic GitHub OAuth Provider in TypeScript\nDESCRIPTION: Imports the Arctic library and creates a new GitHub provider instance using environment variables for client ID and secret, enabling OAuth operations like authorization URL generation and token validation.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GitHub } from \"arctic\";\n\nexport const github = new GitHub(\n\timport.meta.env.GITHUB_CLIENT_ID,\n\timport.meta.env.GITHUB_CLIENT_SECRET,\n\tnull\n);\n```\n\n----------------------------------------\n\nTITLE: Checking User Session in SvelteKit Server Load\nDESCRIPTION: This TypeScript SvelteKit server load function checks if a user session exists in `event.locals`. If no session is found, it redirects the user to the login page using SvelteKit's `redirect` helper.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\n// routes/+page.server.ts\nimport { redirect } from \"@sveltejs/kit\";\n\nimport type { PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async (event) => {\n\tif (!event.locals.user) {\n\t\treturn redirect(302, \"/login\");\n\t}\n\n\treturn {\n\t\tuser\n\t};\n};\n```\n\n----------------------------------------\n\nTITLE: Loading Redis Lua Script via TypeScript client\nDESCRIPTION: Shows how to load the Lua throttling script into Redis using a TypeScript Redis client, returning the SHA1 hash of the loaded script for subsequent EVALSHA calls. This step is necessary for efficient and atomic script execution. Requires a Redis client instance supporting the scriptLoad method. Input is the script string, output is a SHA hash string.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst SCRIPT_SHA = await client.scriptLoad(script);\n```\n\n----------------------------------------\n\nTITLE: Defining the User Interface in TypeScript\nDESCRIPTION: TypeScript interface defining the structure for a User object. It includes a standard `id`, a `googleId` to store the unique identifier from Google, and the user's `name`.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgoogleId: string;\n\tname: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Sign-in Link in Svelte\nDESCRIPTION: A simple Svelte component (`routes/login/+page.svelte`) displaying a sign-in page title and a link. Clicking the link directs the user to the `/login/google` route to initiate the Google OAuth flow.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_5\n\nLANGUAGE: svelte\nCODE:\n```\n<!-- routes/login/+page.svelte -->\n<h1>Sign in</h1>\n<a href=\"/login/google\">Sign in with Google</a>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign-out Endpoint TypeScrpt\nDESCRIPTION: An Astro API route (`POST`) that handles user sign-out. It invalidates the current session using Lucia Auth and removes the session cookie from the user's browser.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { invalidateSession, deleteSessionTokenCookie } from \"@lib/server/session\";\n\nimport type { APIContext } from \"astro\";\n\nexport async function POST(context: APIContext): Promise<Response> {\n\tif (context.locals.session === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\tawait invalidateSession(context.locals.session.id);\n\tdeleteSessionTokenCookie(context);\n\treturn context.redirect(\"/login\");\n}\n```\n\n----------------------------------------\n\nTITLE: Using the In-Memory Throttler Class in TypeScript for User Login Attempts\nDESCRIPTION: Demonstrates practical usage of the in-memory `Throttler` class to manage failed login attempts by applying progressively longer lockout periods. It shows instantiation with a predefined timeout sequence, consuming the throttle state for a user ID, validating password, and resetting the throttler on successful login. Requires the `Throttler` class and a `verifyPassword` function. Inputs include numeric user IDs and passwords; outputs are error exceptions on throttling or invalid password.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst throttler = new Throttler<number>([1, 2, 4, 8, 16, 30, 60, 180, 300]);\n\nif (!throttler.consume(userId)) {\n\tthrow new Error(\"Too many requests\");\n}\nconst validPassword = verifyPassword(password);\nif (!validPassword) {\n\tthrow new Error(\"Invalid password\");\n}\nthrottler.reset(user.id);\n```\n\n----------------------------------------\n\nTITLE: Defining User Interface with GitHub Fields\nDESCRIPTION: This TypeScript interface defines the structure for a user object, including `id`, `githubId`, and `username` fields necessary to store information retrieved from GitHub during the OAuth process.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgithubId: number;\n\tusername: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Session and Storing in Redis - TypeScript\nDESCRIPTION: Creates a new session in Redis with a unique session ID (SHA-256 hash of the token), 30-day expiration, and user linkage. Stores the session as JSON and tracks all sessions for each user with a Redis set. Requires @oslojs/encoding and @oslojs/crypto/sha2 for encoding and hashing, and a running Redis instance. Input: session token (string), user ID (number). Output: Session object. The expiration is handled in seconds.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { redis } from \"./redis.js\";\nimport { encodeBase32LowerCaseNoPadding, encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst session: Session = {\n\t\tid: sessionId,\n\t\tuserId,\n\t\texpiresAt: new Date(Date.now() + 1000 * 60 * 60 * 24 * 30)\n\t};\n\tawait redis.set(\n\t\t`session:${session.id}`,\n\t\tJSON.stringify({\n\t\t\tid: session.id,\n\t\t\tuser_id: session.userId,\n\t\t\texpires_at: Math.floor(session.expiresAt / 1000)\n\t\t}),\n\t\t{\n\t\t\tEXAT: Math.floor(session.expiresAt / 1000)\n\t\t}\n\t);\n\tawait redis.sadd(`user_sessions:${userId}`, sessionId);\n\n\treturn session;\n}\n\n```\n\n----------------------------------------\n\nTITLE: TypeScript Type Definitions for Authentication Context\nDESCRIPTION: TypeScript type definitions that extend SvelteKit's App.Locals interface to include user and session information. This enables type-safe access to authentication context throughout the application.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// src/app.d.ts\n\nimport type { User } from \"$lib/server/user\";\nimport type { Session } from \"$lib/server/session\";\n\ndeclare global {\n\tnamespace App {\n\t\tinterface Locals {\n\t\t\tuser: User | null;\n\t\t\tsession: Session | null;\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n----------------------------------------\n\nTITLE: Declaring Session Management API Functions and Types - TypeScript\nDESCRIPTION: Defines a composed API surface for session management, including generating a session token, creating a session, validating a session token, invalidating single and all sessions, and the Session TypeScript interface. All functions are placeholders for implementation in the session management system using Redis as the backing store. Import of a Redis instance is expected via './redis.js'.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { redis } from \"./redis.js\";\n\nexport function generateSessionToken(): string {\n\t// TODO\n}\n\nexport async function createSession(token: string, userId: number): Promise<Session> {\n\t// TODO\n}\n\nexport async function validateSessionToken(token: string): Promise<Session | null> {\n\t// TODO\n}\n\nexport async function invalidateSession(sessionId: string): Promise<void> {\n\t// TODO\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\t// TODO\n}\n\nexport interface Session {\n\tid: string;\n\tuserId: number;\n\texpiresAt: Date;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Arctic GitHub Provider\nDESCRIPTION: This TypeScript code initializes the GitHub OAuth provider using the Arctic library. It imports the `GitHub` class and uses environment variables for the client ID and secret.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { GitHub } from \"arctic\";\nimport { GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET } from \"$env/static/private\";\n\nexport const github = new GitHub(GITHUB_CLIENT_ID, GITHUB_CLIENT_SECRET, null);\n```\n\n----------------------------------------\n\nTITLE: Installing Oslo Encoding and Crypto Packages with npm - Shell\nDESCRIPTION: Installs the @oslojs/encoding and @oslojs/crypto packages using npm. These packages provide TypeScript-friendly APIs for encoding (base32, hex) and cryptographic functions (SHA-2). Both are required as dependencies for the following TypeScript session management examples.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/redis.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm i @oslojs/encoding @oslojs/crypto\n\n```\n\n----------------------------------------\n\nTITLE: Configuring GitHub OAuth Environment Variables\nDESCRIPTION: These environment variables store the client ID and secret obtained when creating a GitHub OAuth application. They should be placed in a `.env` file for secure access within the application.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_1\n\nLANGUAGE: Bash\nCODE:\n```\n# .env\nGITHUB_CLIENT_ID=\"\"\nGITHUB_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Cloning Example Project Using Git in Bash\nDESCRIPTION: This command clones a GitHub repository containing a reference implementation of GitHub OAuth in Next.js. No dependencies are needed beyond git and network access. The input is the repository SSH URL; the output is a local copy of the repository. The command must be run from the terminal in the desired directory.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:lucia-auth/example-nextjs-github-oauth.git\n```\n\n----------------------------------------\n\nTITLE: Handling Requests with Session Validation TypeScript\nDESCRIPTION: This snippet illustrates a complete request processing flow that includes initial CSRF protection using the 'Origin' header, followed by session validation. It parses the cookie header to find the session token, validates it using an imported `validateSessionToken` function, and handles validation outcomes: if the session is invalid or missing, it deletes the cookie (if present) and returns 401; otherwise, it renews the session cookie using `setSessionTokenCookie`. This ensures the session remains active as long as the user is interacting with the application and assumes generic `HTTPRequest` and `HTTPResponse` interfaces and imports from `./session.js`.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/index.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport {\n\tvalidateSessionToken,\n\tdeleteSessionTokenCookie,\n\tsetSessionTokenCookie\n} from \"./session.js\";\n\n// `HTTPRequest` and `HTTPResponse` are generic interfaces.\n// Adjust this code to fit your framework's API.\n\nfunction handleRequest(request: HTTPRequest, response: HTTPResponse): void {\n\t// csrf protection\n\tif (request.method !== \"GET\") {\n\t\tconst origin = request.headers.get(\"Origin\");\n\t\t// You can also compare it against the Host or X-Forwarded-Host header.\n\t\tif (origin === null || origin !== \"https://example.com\") {\n\t\t\tresponse.setStatusCode(403);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// session validation\n\tconst cookies = parseCookieHeader(request.headers.get(\"Cookie\") ?? \"\");\n\tconst token = cookies.get(\"session\");\n\tif (token === null) {\n\t\tresponse.setStatusCode(401);\n\t\treturn;\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session === null) {\n\t\tdeleteSessionTokenCookie(response);\n\t\tresponse.setStatusCode(401);\n\t\treturn;\n\t}\n\tsetSessionTokenCookie(response, token, session, expiresAt);\n\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing In-Memory Login Throttling in TypeScript\nDESCRIPTION: Defines a generic TypeScript class `Throttler` that uses an internal Map to track failed login attempts per key, incrementally increasing lockout durations based on a configurable array of timeout seconds. The class supports consuming (checking and updating) throttle state for a given key and resetting the counter. It requires TypeScript environment and depends on standard timing functions. Inputs include keys representing users and array of timeout durations; outputs are booleans indicating whether an attempt is allowed.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/throttling.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport class Throttler<_Key> {\n\tpublic timeoutSeconds: number[];\n\n\tprivate storage = new Map<_Key, ThrottlingCounter>();\n\n\tconstructor(timeoutSeconds: number[]) {\n\t\tthis.timeoutSeconds = timeoutSeconds;\n\t}\n\n\tpublic consume(key: _Key): boolean {\n\t\tlet counter = this.storage.get(key) ?? null;\n\t\tconst now = Date.now();\n\t\tif (counter === null) {\n\t\t\tcounter = {\n\t\t\t\tindex: 0,\n\t\t\t\tupdatedAt: now\n\t\t\t};\n\t\t\tthis.storage.set(key, counter);\n\t\t\treturn true;\n\t\t}\n\t\tconst allowed = now - counter.updatedAt >= this.timeoutSeconds[counter.index] * 1000;\n\t\tif (!allowed) {\n\t\t\treturn false;\n\t\t}\n\t\tcounter.updatedAt = now;\n\t\tcounter.index = Math.min(counter.index + 1, this.timeoutSeconds.length - 1);\n\t\tthis.storage.set(key, counter);\n\t\treturn true;\n\t}\n\n\tpublic reset(key: _Key): void {\n\t\tthis.storage.delete(key);\n\t}\n}\n\ninterface ThrottlingCounter {\n\tindex: number;\n\tupdatedAt: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Session Tokens with Expiration and Automatic Renewal in TypeScript\nDESCRIPTION: Validates a session token by hashing it to find the corresponding session and user in the database. It verifies the session existence and expiration, deletes expired sessions, and extends sessions close to expiration by updating the expiry to 30 days from now if less than 15 days remain. Returns both session and user objects or nulls if invalid. Relies on Oslo encoding, SHA-256 hashing, and the `db` querying interface.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { db } from \"./db.js\";\nimport { encodeHexLowerCase } from \"@oslojs/encoding\";\nimport { sha256 } from \"@oslojs/crypto/sha2\";\n\n// ...\n\nexport function validateSessionToken(token: string): SessionValidationResult {\n\tconst sessionId = encodeHexLowerCase(sha256(new TextEncoder().encode(token)));\n\tconst row = db.queryOne(\n\t\t\"SELECT session.id, session.user_id, session.expires_at, user.id FROM session INNER JOIN user ON user.id = session.user_id WHERE id = ?\",\n\t\tsessionId\n\t);\n\tif (row === null) {\n\t\treturn { session: null, user: null };\n\t}\n\tconst session: Session = {\n\t\tid: row[0],\n\t\tuserId: row[1],\n\t\texpiresAt: new Date(row[2] * 1000)\n\t};\n\tconst user: User = {\n\t\tid: row[3]\n\t};\n\tif (Date.now() >= session.expiresAt.getTime()) {\n\t\tdb.execute(\"DELETE FROM session WHERE id = ?\", session.id);\n\t\treturn { session: null, user: null };\n\t}\n\tif (Date.now() >= session.expiresAt.getTime() - 1000 * 60 * 60 * 24 * 15) {\n\t\tsession.expiresAt = new Date(Date.now() + 1000 * 60 * 60 * 24 * 30);\n\t\tdb.execute(\n\t\t\t\"UPDATE session SET expires_at = ? WHERE id = ?\",\n\t\t\tMath.floor(session.expiresAt.getTime() / 1000),\n\t\t\tsession.id\n\t\t);\n\t}\n\treturn { session, user };\n}\n```\n\n----------------------------------------\n\nTITLE: Redirecting Unauthenticated Users in Astro Pages - TypeScript\nDESCRIPTION: This snippet conditionally redirects users to the login page if no authenticated user exists in Astro.locals. It is intended to be used at the top of a page component or endpoint logic, and relies on authentication context having been previously established (typically by middleware). Input is the current request context; output is a redirect or normal page execution.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\n---\nif (Astro.locals.user === null) {\n    return Astro.redirect(\"/login\")\n}\n---\n```\n\n----------------------------------------\n\nTITLE: Defining TypeScript Session API Interface and Types\nDESCRIPTION: Declares the TypeScript API skeleton for managing sessions including functions to generate session tokens, create sessions, validate tokens, and invalidate sessions. It includes types for `SessionValidationResult`, `Session`, and `User` interfaces used throughout the implementation. All functions are marked TODO placeholder implementations.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { db } from \"./db.js\";\n\nexport function generateSessionToken(): string {\n\t// TODO\n}\n\nexport function createSession(token: string, userId: number): Session {\n\t// TODO\n}\n\nexport function validateSessionToken(token: string): SessionValidationResult {\n\t// TODO\n}\n\nexport function invalidateSession(sessionId: string): void {\n\t// TODO\n}\n\nexport async function invalidateAllSessions(userId: number): Promise<void> {\n\t// TODO\n}\n\nexport type SessionValidationResult =\n\t| { session: Session; user: User }\n\t| { session: null; user: null };\n\nexport interface Session {\n\tid: string;\n\tuserId: number;\n\texpiresAt: Date;\n}\n\nexport interface User {\n\tid: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Session Validation Middleware in Astro - TypeScript\nDESCRIPTION: This middleware function validates session cookies on every request in an Astro app. It retrieves the session token, checks validity, refreshes or removes cookies as needed, and attaches session and user details to context.locals. Relies on the 'validateSession', 'setSessionTokenCookie', and 'deleteSessionTokenCookie' utility functions, and uses Astro's defineMiddleware API. Inputs are the incoming context and continuation callback; session and user data are propagated app-wide.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/middleware.ts\nimport {\n\tvalidateSession,\n\tsetSessionTokenCookie,\n\tdeleteSessionTokenCookie\n} from \"./lib/server/session\";\nimport { defineMiddleware } from \"astro:middleware\";\n\nexport const onRequest = defineMiddleware(async (context, next) => {\n\tconst token = context.cookies.get(\"session\")?.value ?? null;\n\tif (token === null) {\n\t\tcontext.locals.user = null;\n\t\tcontext.locals.session = null;\n\t\treturn next();\n\t}\n\n\tconst { session, user } = await validateSessionToken(token);\n\tif (session !== null) {\n\t\tsetSessionTokenCookie(context, token, session.expiresAt);\n\t} else {\n\t\tdeleteSessionTokenCookie(context);\n\t}\n\n\tcontext.locals.session = session;\n\tcontext.locals.user = user;\n\treturn next();\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring SQLite Session and User Tables with SQL\nDESCRIPTION: Defines the SQLite schema for user and session tables. The user table uses an integer primary key 'id', while the session table uses a text 'id' (the SHA-256 hash of the session token), references the user ID, and stores the expiration timestamp as an integer UNIX timestamp (seconds).\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/sqlite.md#_snippet_0\n\nLANGUAGE: SQL\nCODE:\n```\nCREATE TABLE user (\n    id INTEGER NOT NULL PRIMARY KEY\n);\n\n\nCREATE TABLE session (\n    id TEXT NOT NULL PRIMARY KEY,\n    user_id INTEGER NOT NULL REFERENCES user(id),\n    expires_at INTEGER NOT NULL\n);\n```\n\n----------------------------------------\n\nTITLE: Restricting API Access Based on User Authentication in Astro - TypeScript\nDESCRIPTION: This endpoint handler returns a 401 Unauthorized response if the user property on the APIContexts locals is null, enforcing authenticated access to the endpoint. Assumes session validation middleware has set context.locals.user. Input is the request context; output is a Response object with 401 status on failure.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nexport function GET(context: APIContext): Promise<Response> {\n\tif (context.locals.user === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting and Deleting Session Cookies in SvelteKit\nDESCRIPTION: Functions for managing session cookies in SvelteKit with proper security attributes. The implementation includes setting secure, HttpOnly cookies with appropriate SameSite policy and expiration handling for both creating and deleting session tokens.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { RequestEvent } from \"@sveltejs/kit\";\n\n// ...\n\nexport function setSessionTokenCookie(event: RequestEvent, token: string, expiresAt: Date): void {\n\tevent.cookies.set(\"session\", token, {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\texpires: expiresAt,\n\t\tpath: \"/\"\n\t});\n}\n\nexport function deleteSessionTokenCookie(event: RequestEvent): void {\n\tevent.cookies.set(\"session\", \"\", {\n\t\thttpOnly: true,\n\t\tsameSite: \"lax\",\n\t\tmaxAge: 0,\n\t\tpath: \"/\"\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Authentication in SvelteKit API Endpoints\nDESCRIPTION: Implementation of authentication checks in SvelteKit API endpoints. This code shows how to protect API routes by verifying the user's authentication status before processing requests.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/sveltekit.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// +server.ts\nimport { lucia } from \"$lib/server/session\";\n\nexport function GET(event: RequestEvent): Promise<Response> {\n\tif (event.locals.user === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 401\n\t\t});\n\t}\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User and Session Schemas for PostgreSQL with Drizzle ORM in TypeScript\nDESCRIPTION: This snippet shows the definition of 'user' and 'session' table schemas using Drizzle ORM tailored for PostgreSQL. It employs `pgTable` to configure columns with types like `serial`, `text`, `integer`, and `timestamp` (with timezone). It establishes primary keys and a foreign key constraint between `sessionTable.userId` and `userTable.id`. Dependencies include `pg` for the database connection pool and `drizzle-orm/pg-core`. The inferred `User` and `Session` types are exported for use in TypeScript.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/drizzle-orm.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport pg from \"pg\";\nimport { pgTable, serial, text, integer, timestamp } from \"drizzle-orm/pg-core\";\nimport { drizzle } from \"drizzle-orm/node-postgres\";\n\nimport type { InferSelectModel } from \"drizzle-orm\";\n\nconst pool = new pg.Pool();\nconst db = drizzle(pool);\n\nexport const userTable = pgTable(\"user\", {\n\tid: serial(\"id\").primaryKey()\n});\n\nexport const sessionTable = pgTable(\"session\", {\n\tid: text(\"id\").primaryKey(),\n\tuserId: integer(\"user_id\")\n\t\t.notNull()\n\t\t.references(() => userTable.id),\n\texpiresAt: timestamp(\"expires_at\", {\n\t\twithTimezone: true,\n\t\tmode: \"date\"\n\t}).notNull()\n});\n\nexport type User = InferSelectModel<typeof userTable>;\nexport type Session = InferSelectModel<typeof sessionTable>;\n```\n\n----------------------------------------\n\nTITLE: Handling OAuth Callback and User Session Creation in TypeScript\nDESCRIPTION: Processes OAuth callback by validating URL parameters and state cookie, exchanging authorization code for tokens, fetching the GitHub user profile, and managing user sessions including creation or retrieval of user records, and setting session cookies.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/login/github/callback.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"@lib/session\";\nimport { github } from \"@lib/oauth\";\n\nimport type { APIContext } from \"astro\";\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(context: APIContext): Promise<Response> {\n\tconst code = context.url.searchParams.get(\"code\");\n\tconst state = context.url.searchParams.get(\"state\");\n\tconst storedState = context.cookies.get(\"github_oauth_state\")?.value ?? null;\n\tif (code === null || state === null || storedState === null) {\n\t\treturn new Response(null, { status: 400 });\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, { status: 400 });\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await github.validateAuthorizationCode(code);\n\t} catch (e) {\n\t\treturn new Response(null, { status: 400 });\n\t}\n\tconst githubUserResponse = await fetch(\"https://api.github.com/user\", {\n\t\theaders: {\n\t\t\tAuthorization: `Bearer ${tokens.accessToken()}`\n\t\t}\n\t});\n\tconst githubUser = await githubUserResponse.json();\n\tconst githubUserId = githubUser.id;\n\tconst githubUsername = githubUser.login;\n\n\t// Replace with DB query to find existing user.\n\tconst existingUser = await getUserFromGitHubId(githubUserId);\n\n\tif (existingUser !== null) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, existingUser.id);\n\t\tsetSessionTokenCookie(context, sessionToken, session.expiresAt);\n\t\treturn context.redirect(\"/\");\n\t}\n\n\t// Replace with DB query to create new user.\n\tconst user = await createUser(githubUserId, githubUsername);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tsetSessionTokenCookie(context, sessionToken, session.expiresAt);\n\treturn context.redirect(\"/\");\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Google OAuth Callback TypeScrpt\nDESCRIPTION: The Astro API route (`pages/login/google/callback.ts`) responsible for processing the redirect from Google. It validates the state, exchanges the authorization code for tokens using the code verifier, decodes the ID token to get user info, handles user creation or lookup, creates a new session, sets the session cookie, and redirects the user.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// pages/login/google/callback.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"@lib/server/session\";\nimport { google } from \"@lib/oauth\";\nimport { decodeIdToken } from \"arctic\";\n\nimport type { APIContext } from \"astro\";\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(context: APIContext): Promise<Response> {\n\tconst code = context.url.searchParams.get(\"code\");\n\tconst state = context.url.searchParams.get(\"state\");\n\tconst storedState = context.cookies.get(\"google_oauth_state\")?.value ?? null;\n\tconst codeVerifier = context.cookies.get(\"google_code_verifier\")?.value ?? null;\n\tif (code === null || state === null || storedState === null || codeVerifier === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await google.validateAuthorizationCode(code, codeVerifier);\n\t} catch (e) {\n\t\t// Invalid code or client credentials\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tconst claims = decodeIdToken(tokens.idToken());\n\tconst googleUserId = claims.sub;\n\tconst username = claims.name;\n\n\t// TODO: Replace this with your own DB query.\n\tconst existingUser = await getUserFromGoogleId(googleUserId);\n\n\tif (existingUser !== null) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, existingUser.id);\n\t\tsetSessionTokenCookie(context, sessionToken, session.expiresAt);\n\t\treturn context.redirect(\"/\");\n\t}\n\n\t// TODO: Replace this with your own DB query.\n\tconst user = await createUser(googleUserId, username);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tsetSessionTokenCookie(context, sessionToken, session.expiresAt);\n\treturn context.redirect(\"/\");\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Sign Out Form in Svelte\nDESCRIPTION: A Svelte component (`routes/+page.svelte`) containing a form that triggers the sign-out action. It uses the POST method and includes a submit button. The `use:enhance` action from `$app/forms` is applied for progressive enhancement, allowing the form submission to happen without a full page reload if JavaScript is enabled.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_10\n\nLANGUAGE: svelte\nCODE:\n```\n<!-- routes/+page.svelte -->\n<script lang=\"ts\">\n\timport { enhance } from \"$app/forms\";\n</script>\n\n<form method=\"post\" use:enhance>\n    <button>Sign out</button>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Implementing Sign Out Logic in SvelteKit Actions (TypeScript)\nDESCRIPTION: SvelteKit server-side `actions` object (`routes/+page.server.ts`) defining a default action for handling user sign-out. It checks if a session exists in `event.locals`, invalidates the session using a Lucia helper function (`invalidateSession`), deletes the session cookie using another helper (`deleteSessionTokenCookie`), and redirects the user to the login page.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// routes/+page.server.ts\nimport { fail, redirect } from \"@sveltejs/kit\";\nimport { invalidateSession, deleteSessionTokenCookie } from \"$lib/server/session\";\n\nimport type { Actions, PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async ({ locals }) => {\n\t// ...\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tif (event.locals.session === null) {\n\t\t\treturn fail(401);\n\t\t}\n\t\tawait invalidateSession(event.locals.session.id);\n\t\tdeleteSessionTokenCookie(event);\n\t\treturn redirect(302, \"/login\");\n\t}\n};\n```\n\n----------------------------------------\n\nTITLE: Initializing the Arctic Google Provider in TypeScript\nDESCRIPTION: Initializes the Google OAuth provider using the `arctic` library. It requires the Google Client ID, Client Secret (imported from private environment variables), and the configured redirect URI where Google will send the user back after authentication.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Google } from \"arctic\";\nimport { GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET } from \"$env/static/private\";\n\nexport const google = new Google(\n\tGOOGLE_CLIENT_ID,\n\tGOOGLE_CLIENT_SECRET,\n\t\"http://localhost:5173/login/google/callback\"\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring Google Credentials Env\nDESCRIPTION: Illustrates how to define environment variables in a `.env` file to store sensitive Google OAuth client credentials (ID and secret), ensuring they are not hardcoded in the application.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# .env\nGOOGLE_CLIENT_ID=\"\"\nGOOGLE_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Arctic Package Bash\nDESCRIPTION: Provides the npm command to install the Arctic library, which serves as the lightweight OAuth client used in the tutorial to handle the interaction with the Google OAuth provider.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install arctic\n```\n\n----------------------------------------\n\nTITLE: Generating Google Authorization URL in Next.js Route\nDESCRIPTION: Next.js API route (`app/login/google/route.ts`) that handles GET requests. It uses Arctic to generate a state, code verifier, and the Google authorization URL (requesting 'openid' and 'profile' scopes). It stores the state and code verifier in secure, HTTP-only cookies and redirects the user to the generated Google URL.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// app/login/google/route.ts\nimport { generateState, generateCodeVerifier } from \"arctic\";\nimport { google } from \"@/lib/auth\";\nimport { cookies } from \"next/headers\";\n\nexport async function GET(): Promise<Response> {\n\tconst state = generateState();\n\tconst codeVerifier = generateCodeVerifier();\n\tconst url = google.createAuthorizationURL(state, codeVerifier, [\"openid\", \"profile\"]);\n\n\tconst cookieStore = await cookies();\n\tcookieStore.set(\"google_oauth_state\", state, {\n\t\tpath: \"/\",\n\t\thttpOnly: true,\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\tcookieStore.set(\"google_code_verifier\", codeVerifier, {\n\t\tpath: \"/\",\n\t\thttpOnly: true,\n\t\tsecure: process.env.NODE_ENV === \"production\",\n\t\tmaxAge: 60 * 10, // 10 minutes\n\t\tsameSite: \"lax\"\n\t});\n\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: url.toString()\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Google OAuth Callback in Next.js Route\nDESCRIPTION: Next.js Route Handler (`app/login/google/callback/route.ts`) for the OAuth callback URL. It retrieves the authorization code and state from the URL, validates them against the stored state and code verifier from cookies, exchanges the code for tokens using Arctic, decodes the ID token to get user info, checks if the user exists in the database (or creates a new one), creates a user session using Lucia Auth functions, sets the session cookie, and redirects the user to the homepage.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// app/login/google/callback/route.ts\nimport { generateSessionToken, createSession, setSessionTokenCookie } from \"@/lib/session\";\nimport { google } from \"@/lib/oauth\";\nimport { cookies } from \"next/headers\";\nimport { decodeIdToken } from \"arctic\";\n\nimport type { OAuth2Tokens } from \"arctic\";\n\nexport async function GET(request: Request): Promise<Response> {\n\tconst url = new URL(request.url);\n\tconst code = url.searchParams.get(\"code\");\n\tconst state = url.searchParams.get(\"state\");\n\tconst cookieStore = await cookies();\n\tconst storedState = cookieStore.get(\"google_oauth_state\")?.value ?? null;\n\tconst codeVerifier = cookieStore.get(\"google_code_verifier\")?.value ?? null;\n\tif (code === null || state === null || storedState === null || codeVerifier === null) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tif (state !== storedState) {\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\n\tlet tokens: OAuth2Tokens;\n\ttry {\n\t\ttokens = await google.validateAuthorizationCode(code, codeVerifier);\n\t} catch (e) {\n\t\t// Invalid code or client credentials\n\t\treturn new Response(null, {\n\t\t\tstatus: 400\n\t\t});\n\t}\n\tconst claims = decodeIdToken(tokens.idToken());\n\tconst googleUserId = claims.sub;\n\tconst username = claims.name;\n\n\t// TODO: Replace this with your own DB query.\n\tconst existingUser = await getUserFromGoogleId(googleUserId);\n\n\tif (existingUser !== null) {\n\t\tconst sessionToken = generateSessionToken();\n\t\tconst session = await createSession(sessionToken, existingUser.id);\n\t\tawait setSessionTokenCookie(sessionToken, session.expiresAt);\n\t\treturn new Response(null, {\n\t\t\tstatus: 302,\n\t\t\theaders: {\n\t\t\t\tLocation: \"/\"\n\t\t\t}\n\t\t});\n\t}\n\n\t// TODO: Replace this with your own DB query.\n\tconst user = await createUser(googleUserId, username);\n\n\tconst sessionToken = generateSessionToken();\n\tconst session = await createSession(sessionToken, user.id);\n\tawait setSessionTokenCookie(sessionToken, session.expiresAt);\n\treturn new Response(null, {\n\t\tstatus: 302,\n\t\theaders: {\n\t\t\tLocation: \"/\"\n\t\t}\n\t});\n}\n```\n\n----------------------------------------\n\nTITLE: Signing Out Users by Invalidating Session and Clearing Cookie in TypeScript\nDESCRIPTION: Handles POST requests to log out users by invalidating their session in the database and deleting session cookies, then redirects to login page. Ensures session security and proper cleanup.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n// Sign out API route\nimport { invalidateSession, deleteSessionTokenCookie } from \"@lib/session\";\n\nimport type { APIContext } from \"astro\";\n\nexport async function POST(context: APIContext): Promise<Response> {\n\tif (context.locals.session === null) {\n\t\treturn new Response(null, { status: 401 });\n\t}\n\tawait invalidateSession(context.locals.session.id);\n\tdeleteSessionTokenCookie(context);\n\treturn context.redirect(\"/login\");\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing User Sign Out Action in SvelteKit\nDESCRIPTION: This TypeScript SvelteKit server action handles user sign out. It checks for an active session, invalidates the session using `invalidateSession` (from Lucia Auth utilities), removes the session cookie using `deleteSessionTokenCookie`, and redirects the user to the login page.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_9\n\nLANGUAGE: TypeScript\nCODE:\n```\n// routes/+page.server.ts\nimport { fail, redirect } from \"@sveltejs/kit\";\nimport { invalidateSession, deleteSessionTokenCookie } from \"$lib/server/session\";\n\nimport type { Actions, PageServerLoad } from \"./$types\";\n\nexport const load: PageServerLoad = async ({ locals }) => {\n\t// ...\n};\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\tif (event.locals.session === null) {\n\t\t\treturn fail(401);\n\t\t}\n\t\tawait invalidateSession(event.locals.session.id);\n\t\tdeleteSessionTokenCookie(event);\n\t\treturn redirect(302, \"/login\");\n\t}\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Svelte Sign Out Button\nDESCRIPTION: This Svelte component creates a form with a single button labeled \"Sign out\". Using the `use:enhance` action from SvelteKit, this form submission triggers the default server action defined in `+page.server.ts` for sign out.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_10\n\nLANGUAGE: Svelte\nCODE:\n```\n<!-- routes/+page.svelte -->\n<script lang=\"ts\">\n\timport { enhance } from \"$app/forms\";\n</script>\n\n<form method=\"post\" use:enhance>\n    <button>Sign out</button>\n</form>\n```\n\n----------------------------------------\n\nTITLE: Updating User Data Model with GitHub Information in TypeScript\nDESCRIPTION: Extends the user interface to include GitHub-specific fields such as GitHub ID and username, necessary for associating external OAuth data with internal user records.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgithubId: number;\n\tusername: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Lua Script for Redis-Based Token Bucket Implementation\nDESCRIPTION: A Lua script that implements the token bucket algorithm in Redis, ensuring atomic operations. The script handles token creation, refilling, consumption, and expiration in a distributed environment.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/rate-limit/token-bucket.md#_snippet_2\n\nLANGUAGE: lua\nCODE:\n```\n-- Returns 1 if allowed, 0 if not\nlocal key                   = KEYS[1]\nlocal max                   = tonumber(ARGV[1])\nlocal refillIntervalSeconds = tonumber(ARGV[2])\nlocal cost                  = tonumber(ARGV[3])\nlocal now                   = tonumber(ARGV[4]) -- Current unix time in seconds\n\nlocal fields = redis.call(\"HGETALL\", key)\n\nif #fields == 0 then\n\tlocal expiresInSeconds = cost * refillIntervalSeconds\n\tredis.call(\"HSET\", key, \"count\", max - cost, \"refilled_at\", now)\n\tredis.call(\"EXPIRE\", key, expiresInSeconds)\n\treturn {1}\nend\n\nlocal count = 0\nlocal refilledAt = 0\nfor i = 1, #fields, 2 do\n\tif fields[i] == \"count\" then\n\t\tcount = tonumber(fields[i+1])\n\telseif fields[i] == \"refilled_at\" then\n\t\trefilledAt = tonumber(fields[i+1])\n\tend\nend\n\nlocal refill = math.floor((now - refilledAt) / refillIntervalSeconds)\ncount = math.min(count + refill, max)\nrefilledAt = refilledAt + refill * refillIntervalSeconds\n\nif count < cost then\n\treturn {0}\nend\n\ncount = count - cost\nlocal expiresInSeconds = (max - count) * refillIntervalSeconds\nredis.call(\"HSET\", key, \"count\", count, \"refilled_at\", now)\nredis.call(\"EXPIRE\", key, expiresInSeconds)\nreturn {1}\n```\n\n----------------------------------------\n\nTITLE: Cloning Example SvelteKit GitHub OAuth Project\nDESCRIPTION: This Bash command clones the official example project repository for the SvelteKit GitHub OAuth tutorial from GitHub.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\ngit clone git@github.com:lucia-auth/example-sveltekit-github-oauth.git\n```\n\n----------------------------------------\n\nTITLE: Implementing CSRF Protection in Next.js Middleware\nDESCRIPTION: This code creates a middleware function that protects against Cross-Site Request Forgery (CSRF) attacks by validating the Origin header against the Host header for non-GET requests, returning a 403 status for invalid requests.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/nextjs.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// middleware.ts\nimport { NextResponse } from \"next/server\";\n\nimport type { NextRequest } from \"next/server\";\n\nexport async function middleware(request: NextRequest): Promise<NextResponse> {\n\tif (request.method === \"GET\") {\n\t\treturn NextResponse.next();\n\t}\n\tconst originHeader = request.headers.get(\"Origin\");\n\t// NOTE: You may need to use `X-Forwarded-Host` instead\n\tconst hostHeader = request.headers.get(\"Host\");\n\tif (originHeader === null || hostHeader === null) {\n\t\treturn new NextResponse(null, {\n\t\t\tstatus: 403\n\t\t});\n\t}\n\tlet origin: URL;\n\ttry {\n\t\torigin = new URL(originHeader);\n\t} catch {\n\t\treturn new NextResponse(null, {\n\t\t\tstatus: 403\n\t\t});\n\t}\n\tif (origin.host !== hostHeader) {\n\t\treturn new NextResponse(null, {\n\t\t\tstatus: 403\n\t\t});\n\t}\n\treturn NextResponse.next();\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Arctic OAuth Client Library\nDESCRIPTION: This npm command installs the Arctic library, a lightweight OAuth client recommended for handling various OAuth providers including GitHub.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_3\n\nLANGUAGE: Bash\nCODE:\n```\nnpm install arctic\n```\n\n----------------------------------------\n\nTITLE: Extending Astro App Locals with Session and User Types - TypeScript\nDESCRIPTION: This TypeScript declaration file extends Astro's Locals interface with session and user properties for application-wide access. It ensures type safety by declaring these properties as nullable and referencing types from the session module. Intended for use in src/env.d.ts, it provides contextual type information throughout the Astro app, with no direct runtime behavior.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\n// src/env.d.ts\n\n/// <reference types=\"astro/client\" />\ndeclare namespace App {\n\t// Note: 'import {} from \"\"' syntax does not work in .d.ts files.\n\tinterface Locals {\n\t\tsession: import(\"./lib/server/session\").Session | null;\n\t\tuser: import(\"./lib/server/session\").User | null;\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CSRF Protection in Astro Server - TypeScript\nDESCRIPTION: This snippet shows how to enable CSRF protection using the Origin header in Astro by updating the astro.config.mjs file. It sets the output to server and enables origin checking in the security section. Requires Astro v4 or higher; for v5 and up, this is already enabled by default. No external dependencies required, but the security configuration is applicable only to Astro server output.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/cookies/astro.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\n// astro.config.mjs\nexport default defineConfig({\n\toutput: \"server\",\n\tsecurity: {\n\t\tcheckOrigin: true\n\t}\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing GitHub OAuth Provider with Arctic in TypeScript\nDESCRIPTION: Imports the GitHub class from Arctic and creates a provider instance using client credentials from environment variables. The instance will be used for generating authorization URLs and validating authorization codes. Ensure the .env variables are populated as per earlier code. No redirect URI is specified (null), which may be default behavior.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { GitHub } from \"arctic\";\n\nexport const github = new GitHub(\n\tprocess.env.GITHUB_CLIENT_ID,\n\tprocess.env.GITHUB_CLIENT_SECRET,\n\tnull\n);\n```\n\n----------------------------------------\n\nTITLE: Updating User Model for GitHub OAuth (TypeScript)\nDESCRIPTION: Defines a TypeScript interface for a User object. The model includes fields for local user ID, GitHub user ID (as number), and GitHub username. Intended for updating application database schema and for use in code where user data is required. Modify database migrations accordingly to reflect the new structure.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgithubId: number;\n\tusername: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Arctic OAuth Library via npm\nDESCRIPTION: Installs the Arctic npm package, a lightweight OAuth client supporting 50+ providers. This enables OAuth flows, including GitHub authentication, in a Next.js project. Requires npm and package.json; run from the project root.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/nextjs.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install arctic\n```\n\n----------------------------------------\n\nTITLE: Creating Sign-in Page HTML\nDESCRIPTION: Provides the basic HTML structure for a sign-in page in Astro, including a link that initiates the Google OAuth flow by directing the user to the `/login/google` API route.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_5\n\nLANGUAGE: HTML\nCODE:\n```\n<!-- pages/login/index.astro -->\n<html lang=\"en\">\n\t<body>\n\t\t<h1>Sign in</h1>\n\t\t<a href=\"/login/google\">Sign in with Google</a>\n\t</body>\n</html>\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies with npm\nDESCRIPTION: This command installs the required dependencies for the project. Specifically, it installs the `@oslojs/encoding` and `@oslojs/crypto` packages. These packages are used for encoding and cryptographic operations, respectively.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/prisma.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm i @oslojs/encoding @oslojs/crypto\n```\n\n----------------------------------------\n\nTITLE: Defining User Interface TypeScrpt\nDESCRIPTION: Shows a TypeScript interface snippet for a user object, updated to include fields specifically for storing the Google user ID and name, required for associating Google accounts with users in the database.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgoogleId: string;\n\tname: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Session API for Sign-In\nDESCRIPTION: Example showing how to use the session API during user sign-in. Generates a session token, creates a session, and stores the token in a cookie.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/sessions/basic-api/postgresql.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { generateSessionToken, createSession } from \"./session.js\";\n\nconst token = generateSessionToken();\nconst session = createSession(token, userId);\nsetSessionTokenCookie(token);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Sign-in Page in Next.js\nDESCRIPTION: A simple Next.js page component (`app/login/page.tsx`) displaying a sign-in heading and a link that directs the user to the Google OAuth initiation route (`/login/google`).\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\n// app/login/page.tsx\nexport default async function Page() {\n\treturn (\n\t\t<>\n\t\t\t<h1>Sign in</h1>\n\t\t\t<a href=\"/login/google\">Sign in with Google</a>\n\t\t</>\n\t);\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Google OAuth Provider with Arctic\nDESCRIPTION: Initializes the Arctic Google OAuth provider using the Google Client ID, Client Secret (from environment variables), and the specified redirect URI for the OAuth callback.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Google } from \"arctic\";\n\nexport const google = new Google(\n\tprocess.env.GOOGLE_CLIENT_ID,\n\tprocess.env.GOOGLE_CLIENT_SECRET,\n\t\"http://localhost:3000/login/google/callback\"\n);\n```\n\n----------------------------------------\n\nTITLE: Cloning Example Repository Bash\nDESCRIPTION: Provides the command line instruction to clone the official example project repository from GitHub, offering a practical starting point based on the tutorial.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/astro.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:lucia-auth/example-astro-google-oauth.git\n```\n\n----------------------------------------\n\nTITLE: Creating Svelte Login Page Link\nDESCRIPTION: This Svelte component creates a simple login page with an HTML link that directs the user to the SvelteKit route `/login/github` to initiate the OAuth flow.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/sveltekit.md#_snippet_5\n\nLANGUAGE: Svelte\nCODE:\n```\n<!-- routes/login/+page.svelte -->\n<h1>Sign in</h1>\n<a href=\"/login/github\">Sign in with GitHub</a>\n```\n\n----------------------------------------\n\nTITLE: Installing the Arctic OAuth Library\nDESCRIPTION: Installs the `arctic` library using npm, which is required for handling the OAuth 2.0 flow with various providers, including Google.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install arctic\n```\n\n----------------------------------------\n\nTITLE: Cloning the Example Project Repository using Git\nDESCRIPTION: This command clones the example SvelteKit project demonstrating Google OAuth integration with Lucia from GitHub using SSH.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/sveltekit.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:lucia-auth/example-sveltekit-google-oauth.git\n```\n\n----------------------------------------\n\nTITLE: Defining User Interface in TypeScript\nDESCRIPTION: TypeScript interface defining the structure for a user object within the application, including fields for the unique user ID, Google-specific ID, and username.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface User {\n\tid: number;\n\tgoogleId: string;\n\tname: string;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Environment Variables for GitHub OAuth\nDESCRIPTION: Defines the environment variables to store GitHub OAuth client ID and secret, necessary for OAuth authentication flow.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/github-oauth/astro.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# .env\nGITHUB_CLIENT_ID=\"\"\nGITHUB_CLIENT_SECRET=\"\"\n```\n\n----------------------------------------\n\nTITLE: Cloning Example Project Repository\nDESCRIPTION: Command to clone the example Next.js project repository which demonstrates the Google OAuth integration described in the tutorial.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:lucia-auth/example-nextjs-google-oauth.git\n```\n\n----------------------------------------\n\nTITLE: Installing Arctic Dependency\nDESCRIPTION: NPM command to install the Arctic library, which simplifies the implementation of OAuth 2.0 flows.\nSOURCE: https://github.com/lucia-auth/lucia/blob/main/pages/tutorials/google-oauth/nextjs.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpm install arctic\n```"
  }
]