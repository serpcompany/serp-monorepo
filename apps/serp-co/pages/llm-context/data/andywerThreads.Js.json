[
  {
    "owner": "andywer",
    "repo": "threads.js",
    "content": "TITLE: Using a function worker - JavaScript\nDESCRIPTION: This snippet illustrates how to create and use a function worker to fetch a GitHub profile. It imports `spawn`, `Thread`, and `Worker` from the threads.js library and defines an asynchronous function to call the worker. It then uses the returned data to print information about the user.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst fetchGithubProfile = await spawn(new Worker(\"./workers/fetch-github-profile\"))\nconst andywer = await fetchGithubProfile(\"andywer\")\n\nconsole.log(`User \"andywer\" has signed up on ${new Date(andywer.created_at).toLocaleString()}`)\n\nawait Thread.terminate(fetchGithubProfile)\n```\n\n----------------------------------------\n\nTITLE: Subscribe to Thread Events\nDESCRIPTION: This code snippet shows how to subscribe to events emitted by a spawned thread. It uses `Thread.events()` to get an Observable of all thread events and then subscribes to it, logging each event to the console. This is useful for debugging thread behavior. It also shows how to subscribe specifically to error events using `Thread.errors()`.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst myThread = await spawn(new Worker(\"./mythread\"))\n\nThread.events(myThread).subscribe(event => console.log(\"Thread event:\", event))\n```\n\n----------------------------------------\n\nTITLE: Custom Serializer Implementation (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to define a custom serializer for passing instances of classes between threads. It defines a `SerializerImplementation` for a class called `MyClass`, including `serialize` and `deserialize` methods. The serialize method transforms the object to a plain Javascript object with type information while the deserialize method converts it back to an instance of `MyClass`. This snippet defines the serializer's structure and logic, including the crucial `__type` property.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { SerializerImplementation } from \"threads\"\n\ninterface SerializedMyClass {\n  __type: \"$$MyClass\"\n  state: string\n}\n\nclass MyClass {\n  state: string\n\n  constructor(initialState: string) {\n    this.state = initialState\n  }\n\n  doStuff() {\n    // Do fancy things\n  }\n\n  serialize(): SerializedMyClass {\n    return {\n      __type: \"$$MyClass\",\n      state: this.state\n    }\n  }\n\n  static deserialize(message: SerializedMyClass) {\n    return new MyClass(message.state)\n  }\n}\n\nconst MySerializer: SerializerImplementation = {\n  deserialize(message, defaultHandler) {\n    if (message && message.__type === \"$$MyClass\") {\n      return MyClass.deserialize(message as any)\n    } else {\n      return defaultHandler(message)\n    }\n  },\n  serialize(thing, defaultHandler) {\n    if (thing instanceof MyClass) {\n      return thing.serialize()\n    } else {\n      return defaultHandler(thing)\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using Blob Workers - JavaScript\nDESCRIPTION: This snippet demonstrates how to use Blob workers to inline worker code directly into the main bundle, useful for single-file deployments. It uses `BlobWorker.fromText()` to create a worker from a string containing the worker's code.  It conditionally imports worker code depending on whether the environment is a browser or node.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nimport { spawn, BlobWorker } from \"threads\"\nimport MyWorkerNode from \"raw-loader!../dist/worker.node/worker.js\"\nimport MyWorkerWeb from \"raw-loader!../dist/worker.web/worker.js\"\n\nconst MyWorker = process.browser ? MyWorkerWeb : MyWorkerNode\n\nconst worker = await spawn(BlobWorker.fromText(MyWorker))\n// Now use this worker as always\n```\n\n----------------------------------------\n\nTITLE: Exposing Functions from a Worker (workers/auth.js)\nDESCRIPTION: This JavaScript code defines a worker module that exposes a function `hashPassword` using threads.js.  It imports the `expose` function from the \"threads/worker\" library and the `sha256` function from the \"js-sha256\" library. The `expose` function is used to make the `hashPassword` function available for calls from the main thread. The `hashPassword` function takes a password and salt as input, concatenates them, and returns the SHA256 hash of the concatenated string. The worker module can be used in both web worker and Node.js worker thread contexts.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/index.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/auth.js\nimport sha256 from \"js-sha256\"\nimport { expose } from \"threads/worker\"\n\nexpose({\n  hashPassword(password, salt) {\n    return sha256(password + salt)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Error Handling in worker - JavaScript\nDESCRIPTION: This snippet showcases error handling when using threads.js.  The `try...catch` block demonstrates how errors thrown in the worker thread are propagated to the main thread, allowing for centralized error management. The code attempts to increment and decrement a counter in a separate thread, catching any errors that occur during the process and logging them to the console.  The worker is terminated in a `finally` block.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst counter = await spawn(new Worker(\"./workers/counter\"))\n\ntry {\n  await counter.increment()\n  await counter.increment()\n  await counter.decrement()\n\n  console.log(`Counter is now at ${await counter.getCount()}`)\n} catch (error) {\n  console.error(\"Counter thread errored:\", error)\n} finally {\n  await Thread.terminate(counter)\n}\n```\n\n----------------------------------------\n\nTITLE: Spawning a Worker and Hashing a Password (master.js)\nDESCRIPTION: This JavaScript code demonstrates how to spawn a worker using threads.js and call a function within that worker. It imports the necessary modules from the \"threads\" library, spawns a worker from the \"./workers/auth\" file, calls the `hashPassword` function within the worker, logs the hashed password, and then terminates the worker. It showcases the asynchronous nature of worker threads and the ease of communicating with them.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst auth = await spawn(new Worker(\"./workers/auth\"))\nconst hashed = await auth.hashPassword(\"Super secret password\", \"1234\")\n\nconsole.log(\"Hashed password:\", hashed)\n\nawait Thread.terminate(auth)\n```\n\n----------------------------------------\n\nTITLE: Exposing module with type export - TypeScript\nDESCRIPTION: This snippet defines a module worker with an exported type definition, enabling type-safe inter-thread communication. It defines a `counter` object with methods like `getCount`, `increment`, and `decrement`. The type of the `counter` object is exported as `Counter` which can then be used in the main thread when spawning this worker. The `expose` function makes the defined object callable in the main thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\n// counter.ts\nimport { expose } from \"threads/worker\"\n\nlet currentCount = 0\n\nconst counter = {\n  getCount() {\n    return currentCount\n  },\n  increment() {\n    return ++currentCount\n  },\n  decrement() {\n    return --currentCount\n  }\n}\n\nexport type Counter = typeof counter\n\nexpose(counter)\n```\n\n----------------------------------------\n\nTITLE: Transfer ArrayBuffer with Observable\nDESCRIPTION: This code demonstrates using `Transfer()` with Observables to stream ArrayBuffers from a worker thread. It creates an Observable that emits ArrayBuffers received from a data source, transferring ownership to the subscriber, avoiding copying. This optimizes the streaming of large binary data between threads. The `DataSource` is assumed to emit `data` events with `ArrayBuffer` payload.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { expose, Observable, Transfer } from \"threads/worker\"\nimport { DataSource } from \"./my-data-source\"\n\nexpose(function streamBuffers() {\n  return new Observable(observer => {\n    const datasource = new DataSource()\n    datasource.on(\"data\", arrayBuffer => observer.next(Transfer(arrayBuffer)))\n    return () => datasource.close()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Worker Thread: Streaming Min/Max Values with Observable Subject\nDESCRIPTION: This worker thread uses an Observable Subject to stream minimum and maximum values as they are updated.  The `minmax` object exposes methods to add values, finish the stream, and retrieve the observable.  It imports `Observable` and `Subject` from `threads/observable`.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-observables.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// minmax.js\nimport { Observable, Subject } from \"threads/observable\"\nimport { expose } from \"threads/worker\"\n\nlet max = -Infinity\nlet min = Infinity\n\nlet subject = new Subject()\n\nconst minmax = {\n  finish() {\n    subject.complete()\n    subject = new Subject()\n  },\n  add(value) {\n    max = Math.max(max, value)\n    min = Math.min(min, value)\n    subject.next({ max, min })\n  },\n  values() {\n    return Observable.from(subject)\n  }\n}\n\nexpose(minmax)\n```\n\n----------------------------------------\n\nTITLE: Spawning and Terminating Workers in threads.js (JavaScript)\nDESCRIPTION: This code demonstrates how to spawn a worker thread using threads.js and how to call a function exposed by the worker. It also shows how to terminate the worker thread when it is no longer needed. The example uses the `spawn`, `Thread`, and `Worker` classes from the threads.js library. It depends on a worker file located at `./workers/auth`.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nasync function main() {\n  const auth = await spawn(new Worker(\"./workers/auth\"))\n  const hashed = await auth.hashPassword(\"Super secret password\", \"1234\")\n\n  console.log(\"Hashed password:\", hashed)\n\n  await Thread.terminate(auth)\n}\n\nmain().catch(console.error)\n```\n\n----------------------------------------\n\nTITLE: Exposing an object in module worker - JavaScript\nDESCRIPTION: This snippet shows how to expose an object from a worker thread, allowing the main thread to access multiple functions defined within that object. It defines a `counter` object with `getCount`, `increment`, and `decrement` methods, then uses `expose` to make this object available to the main thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/counter.js\nimport { expose } from \"threads/worker\"\n\nlet currentCount = 0\n\nconst counter = {\n  getCount() {\n    return currentCount\n  },\n  increment() {\n    return ++currentCount\n  },\n  decrement() {\n    return --currentCount\n  }\n}\n\nexpose(counter)\n```\n\n----------------------------------------\n\nTITLE: Transfer ArrayBuffer from Worker\nDESCRIPTION: This code snippet shows how to transfer an ArrayBuffer from a worker thread back to the main thread using `Transfer()`.  It defines a function that performs an XOR operation on the buffer and then transfers ownership back to the caller, ensuring thread safety and avoiding unnecessary copying. It uses the `expose` function to make the worker function accessible.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/arraybuffer-xor.js\nimport { expose, Transfer } from \"threads/worker\"\n\nexpose(function xorBuffer(buffer, value) {\n  const view = new Uint8Array(buffer)\n  view.forEach((byte, offset) => view.set([byte ^ value], offset))\n  return Transfer(buffer)\n})\n```\n\n----------------------------------------\n\nTITLE: Exposing Worker Functionality in threads.js (JavaScript)\nDESCRIPTION: This code shows how to expose functionality from a worker thread using threads.js. The `expose` function from the `threads/worker` module is used to define a function (`hashPassword`) that can be called from the main thread. The worker thread calculates a SHA256 hash of the provided password and salt and returns the result.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/auth.js - will be run in worker thread\nimport sha256 from \"js-sha256\"\nimport { expose } from \"threads/worker\"\n\nexpose({\n  hashPassword(password, salt) {\n    return sha256(password + salt)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Exposing a function for function worker - JavaScript\nDESCRIPTION: This code defines a function worker that fetches a GitHub profile using `isomorphic-fetch`. It imports `fetch` and `expose` from `threads/worker` and defines an asynchronous function called `fetchGithubProfile`. This function is exposed using `expose` for use in the main thread.  It returns a promise that resolves to the JSON response from the GitHub API.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/fetch-github-profile.js\nimport fetch from \"isomorphic-fetch\"\nimport { expose } from \"threads/worker\"\n\nexpose(async function fetchGithubProfile(username) {\n  const response = await fetch(`https://api.github.com/users/${username}`)\n  return response.json()\n})\n```\n\n----------------------------------------\n\nTITLE: Register Custom Serializer (TypeScript)\nDESCRIPTION: This TypeScript code snippet shows how to register a custom serializer in both the main thread and the worker thread using `registerSerializer()`.  It emphasizes the importance of registering the serializer before spawning threads or exposing worker functions, ensuring that the serializer is available for message passing. It also highlights the availability of `registerSerializer` in both the main and worker modules.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerSerializer } from \"threads\"\n// also exported from the worker sub-module:\n// import { registerSerializer from \"threads/worker\"\n\nregisterSerializer(MySerializer)\n```\n\n----------------------------------------\n\nTITLE: Spawning a simple worker - JavaScript\nDESCRIPTION: This snippet demonstrates the basic usage of `spawn()` to create a worker thread, call a function within it, and terminate the thread. It imports `spawn`, `Thread`, and `Worker` from the threads.js library and defines an asynchronous `main` function to handle worker interaction. The worker executes a simple addition function.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nasync function main() {\n  const add = await spawn(new Worker(\"./workers/add\"))\n  const sum = await add(2, 3)\n\n  console.log(`2 + 3 = ${sum}`)\n\n  await Thread.terminate(add)\n}\n\nmain().catch(console.error)\n```\n\n----------------------------------------\n\nTITLE: Using a module worker - JavaScript\nDESCRIPTION: This snippet demonstrates using a module worker that exposes an object containing multiple functions. It imports `spawn`, `Thread`, and `Worker` from the threads.js library and spawns a worker that exposes a counter object.  It then calls the `increment`, `decrement`, and `getCount` functions on the worker and prints the current count.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst counter = await spawn(new Worker(\"./workers/counter\"))\nawait counter.increment()\nawait counter.increment()\nawait counter.decrement()\n\nconsole.log(`Counter is now at ${await counter.getCount()}`)\n\nawait Thread.terminate(counter)\n```\n\n----------------------------------------\n\nTITLE: Register Multiple Custom Serializers (TypeScript)\nDESCRIPTION: This TypeScript code shows how to register multiple custom serializers. Serializers are chained in reverse registration order: the last registered serializer is tried first, falling back to previously registered serializers if it cannot handle the data. This allows for a flexible and extensible serialization mechanism.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { registerSerializer } from \"threads\"\n\nregisterSerializer(SomeSerializer)\nregisterSerializer(AnotherSerializer)\n\n// threads.js will first try to use AnotherSerializer, will fall back to SomeSerializer,\n// eventually falls back to passing the data as is if no serializer can handle it\n```\n\n----------------------------------------\n\nTITLE: Type-safe workers with module export - TypeScript\nDESCRIPTION: This snippet demonstrates how to export a type from the worker module and use it when spawning the worker in the main thread, ensuring type safety across threads.  It imports the `Counter` type from the worker module and uses it as a type parameter for the `spawn` function.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\n// master.ts\nimport { spawn, Thread, Worker } from \"threads\"\nimport { Counter } from \"./workers/counter\"\n\nconst counter = await spawn<Counter>(new Worker(\"./workers/counter\"))\nconsole.log(`Initial counter: ${await counter.getCount()}`)\n\nawait counter.increment()\nconsole.log(`Updated counter: ${await counter.getCount()}`)\n\nawait Thread.terminate(counter)\n```\n\n----------------------------------------\n\nTITLE: Transfer ArrayBuffer to Worker (Master)\nDESCRIPTION: This code snippet demonstrates how to transfer an ArrayBuffer to a worker thread using the `Transfer()` function. This avoids copying the buffer, improving performance when working with large binary data. It imports necessary modules, spawns a worker, and calls a function in the worker, transferring the data.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Transfer, Worker } from \"threads\"\n\nconst xorBuffer = await spawn(new Worker(\"./workers/arraybuffer-xor\"))\nconst resultBuffer = await xorBuffer(Transfer(testData), 127)\n```\n\n----------------------------------------\n\nTITLE: Adding threads-plugin to Webpack Config (Diff)\nDESCRIPTION: This diff shows how to add the `threads-plugin` to your webpack configuration. The plugin automatically detects and bundles worker code, replacing `new Worker(...)` expressions with the bundle path.  First install the plugin, then add it to the plugins array in your webpack config.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_3\n\nLANGUAGE: diff\nCODE:\n```\n+ const ThreadsPlugin = require('threads-plugin')\n\n  module.exports = {\n    // ...\n    plugins: [\n+     new ThreadsPlugin()\n    ]\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Scheduling Tasks with pool.queue() in TypeScript\nDESCRIPTION: This snippet shows the function signature for scheduling tasks using `pool.queue()`. The `TaskFunction` type defines the function that will be executed by a worker, and the `pool.queue()` method returns a promise that resolves when the task is completed or rejects if the task fails.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nlet pool: Pool<ThreadType>\ntype TaskFunction<ThreadType, T> = (thread: ThreadType) => Promise<T> | T\n\npool.queue<T>(task: TaskFunction<ThreadType, T>): Promise<T>\n```\n\n----------------------------------------\n\nTITLE: Master Thread: Streaming Results from Worker\nDESCRIPTION: This master thread code spawns a worker, subscribes to the `values` observable, and calls the `add` method on the worker with several values. Finally, it calls the `finish` method and terminates the worker.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-observables.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst minmax = await spawn(new Worker(\"./workers/minmax\"))\n\nminmax.values().subscribe(({ min, max }) => {\n  console.log(`Min: ${min} | Max: ${max}`)\n})\n\nawait minmax.add(2)\nawait minmax.add(3)\nawait minmax.add(4)\nawait minmax.add(1)\nawait minmax.add(5)\nawait minmax.finish()\n\nawait Thread.terminate(minmax)\n```\n\n----------------------------------------\n\nTITLE: Exposing a function in a worker - JavaScript\nDESCRIPTION: This snippet shows how to use `expose()` to make a function available from the worker thread to the main thread. It imports `expose` from `threads/worker` and defines an `add` function that takes two arguments and returns their sum. This function is then exposed for use by the main thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/add.js\nimport { expose } from \"threads/worker\"\n\nexpose(function add(a, b) {\n  return a + b\n})\n```\n\n----------------------------------------\n\nTITLE: Observable Subject Usage Example\nDESCRIPTION: This snippet highlights how to create and use an Observable Subject to externally trigger updates. It demonstrates both direct subscription to the Subject and creating a read-only Observable from the Subject.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-observables.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst observable = new Observable(observer => {\n  // We can call `.next()`, `.error()`, `.complete()` only here\n  // as they are only exposed on the `observer`\n  observer.complete()\n})\n\nconst subject = new Subject()\nsubject.complete()\n// We are free to call `.next()`, `.error()`, `.complete()` from anywhere now\n// Beware: With great power comes great responsibility! Don't write spaghetti code.\n\nconst subscriptionOne = observable.subscribe(/* ... */)\nsubscriptionOne.unsubscribe()\n\nconst subscriptionTwo = subject.subscribe(/* ... */)\nsubscriptionTwo.unsubscribe()\n\n// The returned observable will be read-only\nreturn Observable.from(subject)\n```\n\n----------------------------------------\n\nTITLE: ASAR Unpack Configuration for Electron (Diff)\nDESCRIPTION: This diff shows how to configure the `asarUnpack` option in the `package.json` file for Electron applications. This ensures that the specified worker files are unpacked from the ASAR archive when the application launches, allowing them to be spawned as workers.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_8\n\nLANGUAGE: diff\nCODE:\n```\n+ \"asarUnpack\": {\n+   \"dist/main/0.bundle.worker.js\",\n+   \"dist/main/0.bundle.worker.js.map\"\n+ }\n```\n\n----------------------------------------\n\nTITLE: Type-safe workers - TypeScript\nDESCRIPTION: This snippet demonstrates how to use TypeScript to define the type of a spawned worker function, improving type safety. It defines a `HashFunction` type and uses it when spawning the worker. The `spawn` function is parameterized with the type of the worker's exposed function.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n// master.ts\nimport { spawn, Thread, Worker } from \"threads\"\n\ntype HashFunction = (input: string) => Promise<string>\n\nconst sha512 = await spawn<HashFunction>(new Worker(\"./workers/sha512\"))\nconst hashed = await sha512(\"abcdef\")\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Thread Pool in JavaScript\nDESCRIPTION: This snippet demonstrates creating a thread pool, queuing a task to be executed by a worker, and then terminating the pool. It showcases the basic usage of the `Pool` class and the `queue` method for scheduling asynchronous tasks.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { spawn, Pool, Worker } from \"threads\"\n\nconst pool = Pool(() => spawn(new Worker(\"./workers/multiplier\")), 8 /* optional size */)\n\npool.queue(async multiplier => {\n  const multiplied = await multiplier(2, 3)\n  console.log(`2 * 3 = ${multiplied}`)\n})\n\nawait pool.completed()\nawait pool.terminate()\n```\n\n----------------------------------------\n\nTITLE: Importing threads/register for Parcel Bundler (Diff)\nDESCRIPTION: This diff shows how to import `threads/register` at the beginning of the application code when using the Parcel bundler.  This registers the library's `Worker` implementation as the global `Worker`. It is needed since you cannot import { Worker } from \"threads\".\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n  import { spawn } from \"threads\"\n+ import \"threads/register\"\n\n  // ...\n\n  const work = await spawn(new Worker(\"./worker\"))\n```\n\n----------------------------------------\n\nTITLE: Pool Factory Function Overloads in TypeScript\nDESCRIPTION: These function overloads define the different ways to create a `Pool` instance. The first argument is always a factory function that spawns a worker. The second argument can be either the pool size as a number or a `PoolOptions` object for more detailed configuration.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nfunction Pool(threadFactory: () => Thread, size?: number): Pool\nfunction Pool(threadFactory: () => Thread, options?: PoolOptions): Pool\n```\n\n----------------------------------------\n\nTITLE: Worker Thread: Returning an Observable\nDESCRIPTION: This code demonstrates how to create and return an Observable from a worker thread using `observable-fns` and `threads/worker`. The `expose` function makes the `startCounting` function available to the main thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-observables.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// workers/counter.js\nimport { Observable } from \"observable-fns\"\nimport { expose } from \"threads/worker\"\n\nfunction startCounting() {\n  return new Observable(observer => {\n    for (let currentCount = 1; currentCount <= 10; currentCount++) {\n      observer.next(currentCount)\n    }\n    observer.complete()\n  })\n}\n\nexpose(startCounting)\n```\n\n----------------------------------------\n\nTITLE: Handling Task Results in JavaScript\nDESCRIPTION: This example shows how to handle task results using `pool.queue()` and `.then()`. By attaching a `.then()` callback, you can process the result of the task without blocking the queuing of other tasks.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { spawn, Pool, Worker } from \"threads\"\n\nconst pool = Pool(() => spawn(new Worker(\"./workers/crytpo\")))\nconst task = pool.queue(crypto => crypto.encrypt(\"some-password\"))\n\ntask.then(result => {\n  // do something with the result \n})\n\nawait pool.completed()\nawait pool.terminate()\n```\n\n----------------------------------------\n\nTITLE: TypeScript Compiler Options for Webpack (Diff)\nDESCRIPTION: This diff shows how to configure the TypeScript compiler options in Webpack to preserve `import` and `export` statements. This ensures that Webpack can resolve these statements and that the `threads-plugin` can function correctly.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_5\n\nLANGUAGE: diff\nCODE:\n```\n  module.exports = {\n    // ...\n    module: {\n      rules: [\n        {\n          test: /\\.ts$/,\n          loader: \"ts-loader\",\n+         options: {\n+           compilerOptions: {\n+             module: \"esnext\"\n+           }\n+         }\n        }\n      ]\n    },\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Webpack Externals Config for Node.js bundles (Diff)\nDESCRIPTION: This diff shows how to configure Webpack to exclude `tiny-worker` when creating a bundle for Node.js (target: \"node\").  This prevents the package from being bundled. Ensure `tiny-worker` is listed in the `package.json` dependencies.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_4\n\nLANGUAGE: diff\nCODE:\n```\n  module.exports = {\n    // ...\n+   externals: {\n+     \"tiny-worker\": \"tiny-worker\"\n+   }\n    // ...\n```\n\n----------------------------------------\n\nTITLE: Bundle Install and Jekyll Serve\nDESCRIPTION: Installs the required gems using Bundler and then starts the Jekyll server to serve the documentation locally.  The `--path vendor/bundle` option installs gems into the vendor/bundle directory. The `--baseurl ''` option tells Jekyll to serve the site from the root directory.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/README.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbundle install --path vendor/bundle\nbundle exec jekyll serve --baseurl ''\n```\n\n----------------------------------------\n\nTITLE: Waiting for Tasks to Complete in TypeScript\nDESCRIPTION: This example demonstrates how to wait for a subset of tasks to complete using `Promise.all()` and a list of `QueuedTask` objects.  Other pool tasks might still be running.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\n// (Created a pool and queued other pool tasks before…)\n\nconst myTasks: QueuedTask[] = []\n\nfor (let input = 0; input < 5; input++) {\n  const task = pool.queue(worker => worker.work(input))\n  myTasks.push(task)\n}\n\nawait Promise.all(myTasks)\nconsole.log(\"All worker.work() tasks have completed. Other pool tasks might still be running.\")\n```\n\n----------------------------------------\n\nTITLE: Installing threads.js and tiny-worker (Shell)\nDESCRIPTION: This command installs the `threads` and `tiny-worker` npm packages. The `tiny-worker` package is an optional dependency required for supporting Node.js versions less than 12, serving as a fallback when `worker_threads` are not available.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install threads tiny-worker\n```\n\n----------------------------------------\n\nTITLE: TypeScript Compiler Options for threads-plugin\nDESCRIPTION: This configuration ensures that the TypeScript compiler keeps the `import` / `export` statements intact, so webpack resolves them and threads-plugin can do its job.  Requires TypeScript version 4+.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n    // ...\n    module: {\n      rules: [\n        {\n          test: /\\.ts$/,\n          loader: \"ts-loader\",\n+         options: {\n+           compilerOptions: {\n+             module: \"esnext\"\n+           }\n+         }\n        }\n      ]\n    },\n    // ...\n  }\n```\n\n----------------------------------------\n\nTITLE: Electron Webpack Whitelist Modules (Diff)\nDESCRIPTION: This diff demonstrates how to add `threads` to the `whiteListedModules` array in the `webpackElectron` field of the `package.json` file when using `electron-webpack`. This ensures that `threads` is correctly included in the Electron application bundle.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/getting-started.md#_snippet_6\n\nLANGUAGE: diff\nCODE:\n```\n  \"electronWebpack\": {\n    \"whiteListedModules\": [\n+     \"threads\"\n    ]\n  }\n```\n\n----------------------------------------\n\nTITLE: Pool Options Interface in TypeScript\nDESCRIPTION: This TypeScript interface defines the available options when creating a thread pool. It allows customization of concurrency, maximum queued jobs, pool name, and pool size, providing control over the pool's behavior and resource usage.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\ninterface PoolOptions {\n  concurrency?: number\n  maxQueuedJobs?: number\n  name?: string\n  size?: number\n}\n```\n\n----------------------------------------\n\nTITLE: Master Thread: Subscribing to Observable from Worker\nDESCRIPTION: This code snippet demonstrates how to spawn a worker, obtain an observable from it, and subscribe to the observable to receive updates. It imports necessary modules from the `threads` library.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-observables.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst counter = await spawn(new Worker(\"./workers/counter\"))\n\ncounter().subscribe(newCount => console.log(`Counter incremented to:`, newCount))\n```\n\n----------------------------------------\n\nTITLE: Subscribe to Thread Errors\nDESCRIPTION: This code snippet shows how to subscribe to only error events emitted by a thread, it's similar to the previous example, but focuses solely on error events.  It's a specialized case for easier debugging.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-advanced.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nThread.errors(myThread).subscribe(error => console.log(\"Thread error:\", error))\n```\n\n----------------------------------------\n\nTITLE: Adding ThreadsPlugin to webpack.config.js\nDESCRIPTION: This code snippet shows how to add the ThreadsPlugin to your webpack configuration. The plugin automatically detects and bundles worker code, replacing the original path with the worker bundle path.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n+ const ThreadsPlugin = require('threads-plugin');\n\n  module.exports = {\n    // ...\n    plugins: [\n+     new ThreadsPlugin()\n    ]\n    // ...\n  }\n```\n\n----------------------------------------\n\nTITLE: Cancelling a Queued Task in JavaScript\nDESCRIPTION: This snippet demonstrates how to cancel a queued task using the `cancel()` method. Note that tasks can only be cancelled if they have not yet started executing.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst task = pool.queue(multiplierWorker => multiplierWorker(2, 3))\ntask.cancel()\n```\n\n----------------------------------------\n\nTITLE: Webpack config externals for tiny-worker\nDESCRIPTION: This configuration ensures that the `tiny-worker` package is not bundled when creating a bundle for node.js. This is necessary for node versions less than 12.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nmodule.exports = {\n    // ...\n+   externals: {\n+     \"tiny-worker\": \"tiny-worker\"\n+   }\n    // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Installing threads.js via npm\nDESCRIPTION: This command installs the threads.js library using npm. It's a prerequisite for using threads.js in a Node.js project or a web project with a build system like Webpack.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpm install threads\n```\n\n----------------------------------------\n\nTITLE: Importing threads/register for Parcel\nDESCRIPTION: This code snippet imports `threads/register` to register the library's Worker implementation as the global `Worker` in Parcel projects. It must be placed at the beginning of application code in the master thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { spawn } from \"threads\"\n+ import \"threads/register\"\n\n  // ...\n\n  const work = await spawn(new Worker(\"./worker\"))\n```\n\n----------------------------------------\n\nTITLE: Terminating a Thread Pool in JavaScript\nDESCRIPTION: This example shows how to terminate a thread pool using the `terminate()` method. You can either terminate gracefully, waiting for all tasks to complete, or force-terminate immediately.\nSOURCE: https://github.com/andywer/threads.js/blob/master/docs/usage-pool.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// Terminate gracefully\npool.terminate()\n\n// Force-terminate pool workers\npool.terminate(true)\n```\n\n----------------------------------------\n\nTITLE: Basic threads.js usage - Master\nDESCRIPTION: This JavaScript code demonstrates the basic usage of threads.js in the master thread. It spawns a worker, calls a function on the worker, and then terminates the worker thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\n// master.js\nimport { spawn, Thread, Worker } from \"threads\"\n\nconst auth = await spawn(new Worker(\"./workers/auth\"))\nconst hashed = await auth.hashPassword(\"Super secret password\", \"1234\")\n\nconsole.log(\"Hashed password:\", hashed)\n\nawait Thread.terminate(auth)\n```\n\n----------------------------------------\n\nTITLE: Basic threads.js usage - Worker\nDESCRIPTION: This JavaScript code demonstrates the basic usage of threads.js in the worker thread. It exposes a function that can be called from the master thread.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\n// workers/auth.js\nimport sha256 from \"js-sha256\"\nimport { expose } from \"threads/worker\"\n\nexpose({\n  hashPassword(password, salt) {\n    return sha256(password + salt)\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Debug logging with threads.js\nDESCRIPTION: This command shows how to enable debug logging for threads.js. Setting the `DEBUG` environment variable to `threads:*` enables all debug logging.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\nDEBUG=threads:* npm test\n```\n\n----------------------------------------\n\nTITLE: Installing threads.js\nDESCRIPTION: This command installs the threads package and tiny-worker as a dependency. The `tiny-worker` package is only required for node.js versions less than 12.\nSOURCE: https://github.com/andywer/threads.js/blob/master/README.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install threads tiny-worker\n```"
  }
]