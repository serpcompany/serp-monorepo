[
  {
    "owner": "cogciprocate",
    "repo": "ocl",
    "content": "TITLE: OpenCL Vector Addition Example in Rust\nDESCRIPTION: Complete example demonstrating how to use OCL to perform vector addition on a GPU/accelerator. Shows kernel creation, buffer management, and execution.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/README.md#2025-04-22_snippet_2\n\nLANGUAGE: opencl\nCODE:\n```\n__kernel void add(__global float* buffer, float scalar) {\n    buffer[get_global_id(0)] += scalar;\n}\n```\n\nLANGUAGE: rust\nCODE:\n```\nextern crate ocl;\nuse ocl::ProQue;\n\nfn trivial() -> ocl::Result<()> {\n    let src = r#\"\n        __kernel void add(__global float* buffer, float scalar) {\n            buffer[get_global_id(0)] += scalar;\n        }\n    \"#;\n\n    let pro_que = ProQue::builder()\n        .src(src)\n        .dims(1 << 20)\n        .build()?;\n\n    let buffer = pro_que.create_buffer::<f32>()?;\n\n    let kernel = pro_que.kernel_builder(\"add\")\n        .arg(&buffer)\n        .arg(10.0f32)\n        .build()?;\n\n    unsafe { kernel.enq()?; }\n\n    let mut vec = vec![0.0f32; buffer.len()];\n    buffer.read(&mut vec).enq()?;\n\n    println!(\"The value at index [{}] is now '{}'!\", 200007, vec[200007]);\n    Ok(())\n}\n```\n\n----------------------------------------\n\nTITLE: Basic OpenCL Kernel Example in Rust\nDESCRIPTION: A complete example showing how to use OCL to create and run an OpenCL kernel that adds a scalar value to each element in a buffer. Demonstrates creating a program queue, buffer, kernel, and data transfer.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl/README.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nextern crate ocl;\nuse ocl::ProQue;\n\nfn trivial() -> ocl::Result<()> {\n    let src = r#\"\n        __kernel void add(__global float* buffer, float scalar) {\n            buffer[get_global_id(0)] += scalar;\n        }\n    \"#;\n\n    let pro_que = ProQue::builder()\n        .src(src)\n        .dims(1 << 20)\n        .build()?;\n\n    let buffer = pro_que.create_buffer::<f32>()?;\n\n    let kernel = pro_que.kernel_builder(\"add\")\n        .arg(&buffer)\n        .arg(10.0f32)\n        .build()?;\n\n    unsafe { kernel.enq()?; }\n\n    let mut vec = vec![0.0f32; buffer.len()];\n    buffer.read(&mut vec).enq()?;\n\n    println!(\"The value at index [{}] is now '{}'!\", 200007, vec[200007]);\n    Ok()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Using OpenCL-OpenGL Interop Context in Rust\nDESCRIPTION: This code snippet illustrates the process of creating an OpenCL context with OpenGL interoperability, creating an OpenCL buffer from an OpenGL buffer, and managing the shared resource. It demonstrates acquiring and releasing the buffer for OpenCL use.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl-interop/README.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\n// First, create an OpenGL context and make sure it is active...\n\n// Next, Create an OpenCL context with the interop enabled: (NOTE:\n// `::get_context` will return the first available GPU device on your that\n// supports OpenGL interop on your system -- you may need to choose a device\n// and create the context manually instead if this does not work):\nlet context = ocl_interop::get_context()?;\n\n// Later, after creating an OpenGL buffer...\n\n// Create an OpenCL buffer from an OpenGL buffer:\nlet cl_buffer = ocl::Buffer::<f32>::from_gl_buffer(&queue, None, gl_buffer)?;\n\n// Acquire the buffer, making it usable:\ncl_buffer.cmd().gl_acquire().enq()?;\n\n// Use the buffer...\n\n// Release the acquisition:\ncl_buffer.cmd().gl_release().enq()?\n```\n\n----------------------------------------\n\nTITLE: Using BufferBuilder to create a new Buffer\nDESCRIPTION: The recommended new approach to creating a Buffer using the builder pattern, which allows for better configurability and a more stable API.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_2\n\nLANGUAGE: rust\nCODE:\n```\nBuffer::builder()\n  .queue(queue)\n  .flags(flags)\n  .dims(dims)\n  .host_data(&data)\n  .build()\n```\n\n----------------------------------------\n\nTITLE: OpenCL Kernel for Adding a Scalar Value\nDESCRIPTION: An OpenCL kernel function that adds a scalar value to each element in a global float buffer. Takes the buffer and scalar as parameters and uses the global ID to identify the current element.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl/README.md#2025-04-22_snippet_3\n\nLANGUAGE: opencl\nCODE:\n```\n__kernel void add(__global float* buffer, float scalar) {\n    buffer[get_global_id(0)] += scalar;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the new Kernel::new API with queue method\nDESCRIPTION: The updated way to create a Kernel and set its queue using the builder-style pattern which separates queue assignment from kernel creation.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_4\n\nLANGUAGE: rust\nCODE:\n```\nKernel::new(\"kernel_name\", &program)?.queue(queue)\n```\n\n----------------------------------------\n\nTITLE: Setting Kernel Arguments Example in Rust\nDESCRIPTION: Example showing how to set kernel arguments using the core API with the new ArgVal type\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nlet kernel = core::create_kernel(&program, \"multiply\")?\ncore::set_kernel_arg(&kernel, 0, ArgVal::scalar(&10.0f32))?\ncore::set_kernel_arg(&kernel, 1, ArgVal::mem(&buffer))?\n```\n\n----------------------------------------\n\nTITLE: Using the new BufferBuilder pattern instead of Buffer::new\nDESCRIPTION: Example showing migration from the old Buffer::new constructor to the new builder pattern which offers more flexibility and stability.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nBuffer::new(queue, Some(flags), dims, Some(&data))\n```\n\n----------------------------------------\n\nTITLE: Adding ocl-interop Dependency in Cargo.toml\nDESCRIPTION: This snippet shows how to add the ocl-interop crate as a dependency in the Cargo.toml file. This is required to use OpenCL-OpenGL interoperability features in a Rust project.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl-interop/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\nocl-interop = \"0.1\"\n```\n\n----------------------------------------\n\nTITLE: Adding OCL Dependency to Cargo.toml\nDESCRIPTION: Cargo dependency configuration to include the OCL library in a Rust project.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nocl = \"0.19\"\n```\n\n----------------------------------------\n\nTITLE: Adding OCL Dependency in Cargo.toml\nDESCRIPTION: Configuration for adding the OCL library dependency to a Rust project's Cargo.toml file. Sets the dependency version to 0.19.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl/README.md#2025-04-22_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nocl = \"0.19\"\n```\n\n----------------------------------------\n\nTITLE: Command Queue Properties Example - OpenCL\nDESCRIPTION: Valid property options that can be passed when creating command queues including out-of-order execution and profiling enable flags\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_9\n\nLANGUAGE: rust\nCODE:\n```\nQUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\nQUEUE_PROFILING_ENABLE\n```\n\n----------------------------------------\n\nTITLE: Migrating from old Kernel::new to new API without default queue\nDESCRIPTION: Example of how to migrate from the old Kernel::new constructor that accepted a queue to the new version that requires setting the queue separately.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_3\n\nLANGUAGE: rust\nCODE:\n```\nKernel::new(\"kernel_name\", &program, queue)?\n```\n\n----------------------------------------\n\nTITLE: Importing OCL Crate in Rust\nDESCRIPTION: Code to import the OCL crate into a Rust project's root file (lib.rs or main.rs).\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate ocl;\n```\n\n----------------------------------------\n\nTITLE: Importing OCL Library in Rust\nDESCRIPTION: Code to import the OCL library into a Rust project's crate root file (lib.rs or main.rs).\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate ocl;\n```\n\n----------------------------------------\n\nTITLE: Updated kernel named argument with explicit buffer type specification\nDESCRIPTION: New way to specify a Buffer type argument with None value by providing explicit type information about the Buffer.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_6\n\nLANGUAGE: rust\nCODE:\n```\n.arg_buf_named(\"buf\", None::<Buffer<f32>>)\n```\n\n----------------------------------------\n\nTITLE: Importing ocl-interop Crate in Rust\nDESCRIPTION: This snippet demonstrates how to import the ocl-interop crate in the main Rust file (lib.rs or main.rs). This import is necessary to access the interoperability functions provided by the crate.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/ocl-interop/README.md#2025-04-22_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nextern crate ocl_interop;\n```\n\n----------------------------------------\n\nTITLE: Alternative syntax for kernel named argument with explicit types\nDESCRIPTION: Another approach to specify both data type and buffer type using type parameters when setting a kernel argument to None.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_7\n\nLANGUAGE: rust\nCODE:\n```\n.arg_buf_named::<f32, Buffer<f32>>(\"buf\", None)\n```\n\n----------------------------------------\n\nTITLE: Event Passing Annotation Example - Rust\nDESCRIPTION: Example showing how to annotate None values for event parameters after the trait object to generic conversion\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_8\n\nLANGUAGE: rust\nCODE:\n```\nNone::<Event> // Will suffice for either event wait list or new event reference\n```\n\n----------------------------------------\n\nTITLE: Legacy kernel named argument with buffer type via type parameter\nDESCRIPTION: Old style of specifying a Buffer type argument with None value using a single type parameter.\nSOURCE: https://github.com/cogciprocate/ocl/blob/master/RELEASES.md#2025-04-22_snippet_5\n\nLANGUAGE: rust\nCODE:\n```\n.arg_buf_named::<f32>(\"buf\", None)\n```"
  }
]