[
  {
    "owner": "opentensor",
    "repo": "developer-docs",
    "content": "TITLE: Creating a Subnet Proposal in Bittensor's Governance System\nDESCRIPTION: This code snippet demonstrates how a Triumvirate member creates a proposal to add a new subnet to the Bittensor network. It uses the SubtensorModule to create a SudoAddNetwork call with network ID, tempo, and modality parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/governance.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nSubtensorModule.SudoAddNetwork(netuid, tempo, modality)\n```\n\n----------------------------------------\n\nTITLE: Committing Weights to Bittensor Blockchain in Python\nDESCRIPTION: This function commits a hash of the neuron's weights to the Bittensor blockchain using the provided wallet. It handles error checking and user interaction, returning a boolean success flag and a descriptive message.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/commit_weights/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef commit_weights_extrinsic(subtensor, wallet, netuid, commit_hash, wait_for_inclusion = False, wait_for_finalization = False):\n   \"\"\"Commits a hash of the neuron's weights to the Bittensor blockchain using the provided wallet.\n   This function is a wrapper around the `do_commit_weights` method.\n\n   :param subtensor: The subtensor instance used for blockchain interaction.\n   :type subtensor: bittensor.core.subtensor.Subtensor\n   :param wallet: The wallet associated with the neuron committing the weights.\n   :type wallet: bittensor_wallet.Wallet\n   :param netuid: The unique identifier of the subnet.\n   :type netuid: int\n   :param commit_hash: The hash of the neuron's weights to be committed.\n   :type commit_hash: str\n   :param wait_for_inclusion: Waits for the transaction to be included in a block.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: Waits for the transaction to be finalized on the blockchain.\n   :type wait_for_finalization: bool\n\n   :returns: ``True`` if the weight commitment is successful, False otherwise. And `msg`, a string\n             value describing the success or potential error.\n   :rtype: tuple[bool, str]\n\n   This function provides a user-friendly interface for committing weights to the Bittensor blockchain, ensuring proper\n       error handling and user interaction when required.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Account Management Functions in Python\nDESCRIPTION: Functions for managing account stakes, validating hotkeys and coldkeys, and retrieving account information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nget_total_stake_for_hotkey( self, ss58_address: str, block: Optional[int] = None ) -> Optional['bittensor.Balance']\n\nget_total_stake_for_coldkey( self, ss58_address: str, block: Optional[int] = None ) -> Optional['bittensor.Balance']\n\nget_stake_for_coldkey_and_hotkey( self, hotkey_ss58: str, coldkey_ss58: str, block: Optional[int] = None ) -> Optional['bittensor.Balance']\n\nget_stake( self, hotkey_ss58: str, block: Optional[int] = None ) -> List[Tuple[str,'bittensor.Balance']]\n\ndoes_hotkey_exist( self, hotkey_ss58: str, block: Optional[int] = None ) -> bool\n\nget_hotkey_owner( self, hotkey_ss58: str, block: Optional[int] = None ) -> Optional[str]\n\nget_axon_info( self, hotkey_ss58: str, block: Optional[int] = None ) -> Optional[axon_info]\n\nget_prometheus_info( self, hotkey_ss58: str, block: Optional[int] = None ) -> Optional[axon_info]\n```\n\n----------------------------------------\n\nTITLE: Accessing Subnet State in Bittensor with Python\nDESCRIPTION: Demonstrates how to use bt.metagraph to access and sync subnet state information. It shows getting the current state and syncing with a specific block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph( netuid = 1 )             # Get the current state.\nassert subnet.netuid == 1\nsubnet.sync( block = 101010 )                   # Sync the state with a particular block.\nassert subnet.block == 101010\n```\n\n----------------------------------------\n\nTITLE: Calculating Bittensor Subnet Rewards with AsyncSubtensor\nDESCRIPTION: Asynchronous script that connects to Bittensor network, fetches subnet information, and calculates daily rewards for a given hotkey. Handles multiple subnets, performs tempo calculations, and includes slippage consideration for Alpha to Tao conversions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n# Speicfy which subnets you wish to inspect, by UID\nNETUIDS = range(0,64)\nBLOCKTIME = 12\n\nsubtensor_address = \"finney\"  # or \"test\" or locally with \"ws://127.0.0.1:9944\"\n\nasync def main():\n    async with AsyncSubtensor(f\"{subtensor_address}\") as subtensor:\n        all_sn_dynamic_info_list = await subtensor.all_subnets()\n\n        all_sn_dynamic_info = {info.netuid: info for info in all_sn_dynamic_info_list}\n        daily_blocks = (60 * 60 * 24) / BLOCKTIME  # Number of blocks per day\n        \n\n        print(f\"Hotkey: {HOTKEY}\")\n\n        subnets = await asyncio.gather(*[subtensor.subnet_exists(netuid) for netuid in range(1, 8)])\n        metagraphs = await asyncio.gather(*[ subtensor.metagraph(netuid=id) for id in NETUIDS])\n        for id in NETUIDS:\n            print(f\"UID: {id}\")\n            \n            metagraph = metagraphs[id]\n            tempo_multiplier = daily_blocks / metagraph.tempo\n            \n            subnet_info = all_sn_dynamic_info.get(id)\n\n            uid = metagraph.hotkeys.index(HOTKEY) if HOTKEY in metagraph.hotkeys else None\n\n            if uid is None:\n                print(f\"Hotkey {HOTKEY} not found in the metagraph\")\n            else:\n                daily_rewards_alpha = float(metagraph.emission[uid] * tempo_multiplier)\n                daily_rewards_tao = float(daily_rewards_alpha * subnet_info.price.tao)\n                alpha_to_tao_with_slippage, slippage = subnet_info.alpha_to_tao_with_slippage(\n                    alpha=daily_rewards_alpha\n                )\n\n                print(f\"Daily Rewards Alpha: {daily_rewards_alpha}\")\n                print(f\"Daily Rewards Tao: {daily_rewards_tao}\")\n                print(f\"Alpha to Tao with Slippage: {alpha_to_tao_with_slippage}\")\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor SDK using Bash script\nDESCRIPTION: Bash command to download and execute the Bittensor installation script, which handles the installation process including prerequisites.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/opentensor/bittensor/master/scripts/install.sh)\"\n```\n\n----------------------------------------\n\nTITLE: Transferring TAO using Balance object in Python\nDESCRIPTION: Demonstrates how to transfer TAO using the new Balance object in Bittensor v9.0. The example shows both the previous method and the new method using the tao() and rao() helper functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/migration_guide.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\nsubtensor = Subtensor()\nsubtensor.transfer(wallet, destination, 1.0)\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\nfrom bittensor.utils.balance import tao, rao\n\nsubtensor = Subtensor()\nsubtensor.transfer(wallet, destination, tao(1.0))\n# or\nsubtensor.transfer(wallet, destination, rao(1000000000))\n```\n\n----------------------------------------\n\nTITLE: Creating a New Subnet with BTCLI\nDESCRIPTION: Create a new subnet using a coldkey with sufficient TAO balance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/subnet-creators-btcli-guide.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Lock Cost on Bittensor Mainchain\nDESCRIPTION: This command retrieves the current cost to create a subnet on the Bittensor mainchain. The cost fluctuates based on demand and requires at least 100 TAO by default.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet lock_cost\n```\n\n----------------------------------------\n\nTITLE: Complete Example of Configuring Consensus-based Weights in Python\nDESCRIPTION: Demonstrates a full example of enabling the consensus-based weights feature and setting alpha values for a specific subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\nwallet = bt.wallet(name=\"test-coldkey\")\nsubtensor = bt.subtensor(network=\"127.0.0.1:9946\")\n\n# Enable consensus-based weights (liquid alpha) feature\nenabled_result = subtensor.set_hyperparameter(\nwallet=wallet,\nnetuid=1,\nparameter=\"liquid_alpha_enabled\",\nvalue=True,\nwait_for_inclusion=True,\nwait_for_finalization=True,\n)\nprint(enabled_result)\n\n# Set alpha low and high values\nalpha_low_high_result = subtensor.set_hyperparameter(\nwallet=wallet,\nnetuid=1,\nparameter=\"alpha_values\",\nvalue=[6554, 52428], # decimal 0.1 for alpha_low and 0.8 for alpha_high\nwait_for_inclusion=True,\nwait_for_finalization=True,\n)\nprint(alpha_low_high_result)\n```\n\n----------------------------------------\n\nTITLE: Listing Subnets in Bittensor using CLI\nDESCRIPTION: Shows how to list all currently running subnets on Bittensor using the command-line interface.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets list\n```\n\n----------------------------------------\n\nTITLE: Multi-threaded Subnet Existence Checks in Python\nDESCRIPTION: This code uses Python's ThreadPoolExecutor to perform concurrent subnet existence checks. It creates a separate Subtensor object for each thread, which is faster but can potentially overuse web sockets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nfrom bittensor.core.subtensor import Subtensor\n\ndef subnet_exists(netuid: int):\n    subtensor = Subtensor(\"test\")\n    result = subtensor.subnet_exists(netuid=netuid)\n    subtensor.close()\n    print(\"subnet \" + str(netuid) + \" exists: \" + str(result) )\n\nwith ThreadPoolExecutor() as executor:\n    subnets = executor.map(subnet_exists, range(1, 8))\n```\n\n----------------------------------------\n\nTITLE: Subnet Management in Bittensor CLI\nDESCRIPTION: Commands for interacting with subnets, including listing, creating, registering, and viewing subnet information such as hyperparameters and metagraph data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets hyperparameters\nbtcli subnets list\nbtcli subnets burn-cost\nbtcli subnets create\nbtcli subnets pow-register\nbtcli subnets register\nbtcli subnets metagraph\nbtcli subnets show\nbtcli subnets price\n```\n\n----------------------------------------\n\nTITLE: Retrieving Weight Distribution in Bittensor Subnet (Python)\nDESCRIPTION: Method that retrieves the weight distribution set by neurons within a specific subnet of the Bittensor network. Takes parameters for subnet ID and optional block number. Returns a list of tuples mapping each neuron's UID to its assigned weights.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_72\n\nLANGUAGE: python\nCODE:\n```\ndef weights(netuid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Incrementally Unstaking Alpha Tokens from Bittensor Subnets (Python)\nDESCRIPTION: This script demonstrates how to incrementally unstake alpha tokens from multiple subnets to yield TAO. It reverses the effects of the staking script, calculating slippage and updating stake information for each subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(name=\"ExampleWalletName\")\nwallet.unlock_coldkey()\n\nto_sell = [119, 277, 18, 5] # list of netuids to unstake from\nincrement = 0.01 # amount of alpha to unstake\ntotal_sell = 0 # total amount of alpha unstaked\nstake = {} # dictionary to store the stake for each netuid\n\nwhile total_sell < 3:\n    for netuid in to_sell:\n        subnet = sub.subnet(netuid)\n        print(f\"slippage for subnet {netuid}\", subnet.alpha_slippage(increment))\n\n        sub.remove_stake( \n            wallet = wallet, \n            netuid = netuid, \n            hotkey = subnet.owner_hotkey, \n            amount = increment, \n        )\n        current_stake = sub.get_stake(\n            coldkey_ss58 = wallet.coldkeypub.ss58_address,\n            hotkey_ss58 = subnet.owner_hotkey,\n            netuid = netuid,\n        )\n        stake[netuid] = current_stake\n        total_sell += increment\n        print (f'netuid {netuid} price {subnet.price} stake {current_stake}')\n    sub.wait_for_block()\n```\n\n----------------------------------------\n\nTITLE: Moving Stake Between Validators in Python\nDESCRIPTION: This script demonstrates how to move stake from one validator to another in the Bittensor network. It uses AsyncSubtensor to asynchronously transfer a specified amount of TAO from a source hotkey and subnet to a destination hotkey and subnet. The script includes wallet management and transaction monitoring functionality.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\nimport bittensor as bt\nfrom bittensor.core.subtensor import Subtensor\nfrom bittensor.core.async_subtensor import AsyncSubtensor\n\nasync def main():\n    async with AsyncSubtensor(\"test\") as subtensor:\n        wallet = bt.wallet(\n            name=\"PracticeKey!\"\n        )\n        wallet.unlock_coldkey()\n        result = await subtensor.move_stake(wallet = wallet,\n            origin_hotkey = \"5DyHnV9Wz6cnefGfczeBkQCzHZ5fJcVgy7x1eKVh8otMEd31\",\n            origin_netuid = 5,\n            destination_hotkey = \"5HidY9Danh9NhNPHL2pfrf97Zboew3v7yz4abuibZszcKEMv\",\n            destination_netuid = 18,\n            amount = bt.Balance.from_tao(1.0),\n            wait_for_inclusion = True,\n            wait_for_finalization = False,\n        )\n        if result:\n            print(\"Stake was successfully moved!\")\n        else:\n            print(\"Failed to move stake.\")\n# Because move_stake is asynchronous, we run it in an event loop:\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Neuron Weight Setting Method Python Definition\nDESCRIPTION: Method to set inter-neuronal weights for specified neurons, influencing the network's collective intelligence and trust relationships.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_62\n\nLANGUAGE: python\nCODE:\n```\ndef set_weights(wallet, netuid, uids, weights, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False, max_retries = 5)\n```\n\n----------------------------------------\n\nTITLE: Initializing Subtensor Class in Python\nDESCRIPTION: Class definition for Subtensor that inherits from SubtensorMixin. It provides core functionality for interacting with the Substrate Interface with configuration options for network connection and logging.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Subtensor(network = None, config = None, _mock = False, log_verbose = False):\n    \"\"\"Thin layer for interacting with Substrate Interface. Mostly a collection of frequently-used calls.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing BTCLI from PyPI using pip\nDESCRIPTION: Command to install the latest version of btcli using pip. After installation, the version can be verified using the --version flag.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-btcli.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install bittensor-cli\n```\n\nLANGUAGE: shell\nCODE:\n```\nbtcli --version\n```\n\n----------------------------------------\n\nTITLE: Setting Inter-Neuronal Weights in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method sets weights between neurons in the Bittensor network, defining how much influence or trust one neuron places on others. It requires wallet credentials, network UID, target UIDs, and weight values. The function shapes the network's collective intelligence through weight relationships.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nset_weights(wallet, netuid, uids, weights, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False, max_retries = 5)\n```\n\n----------------------------------------\n\nTITLE: Viewing a Hotkey's Emissions on Bittensor Subnets (Python)\nDESCRIPTION: This script displays the last day's emissions for a specified hotkey on all subnets on which the hotkey is registered. It can be useful for miners to see how much they've been extracting from different subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.async_subtensor import AsyncSubtensor\nimport sys\nimport asyncio\n\n# This is the validator HK for Opentensor Foundation, substitute with the hotkey of the miner/validator you wish to inspect\nHOTKEY = \"5F4tQyWrhfGVcNhoqeiNsR6KjD4wMZ2kfhLj4oHYuyHbZAc3\"\n```\n\n----------------------------------------\n\nTITLE: Registering as a Validator in Bittensor\nDESCRIPTION: Command to register a validator with a subnet using btcli. Requires specifying the desired netuid, wallet name, and hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet register --netuid <desired netuid> --wallet.name  <wallet name> --hotkey <your hotkey>\n```\n\n----------------------------------------\n\nTITLE: Multiple Staking Method in Python\nDESCRIPTION: Method for adding stakes to multiple neurons simultaneously using their hotkey SS58 addresses. Enables efficient bulk staking operations from a single wallet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef add_stake_multiple(wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False):\n    \"\"\"Adds stakes to multiple neurons identified by their hotkey SS58 addresses.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Signing and Sending Blockchain Extrinsics in Bittensor (Python)\nDESCRIPTION: This helper method signs and submits an extrinsic call to the blockchain using a specified wallet. It allows configuring whether to wait for inclusion or finalization of the transaction and which keypair (coldkey, hotkey, or coldkeypub) should be used for signing.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nsign_and_send_extrinsic(call, wallet, wait_for_inclusion = True, wait_for_finalization = False, sign_with = 'coldkey')\n```\n\n----------------------------------------\n\nTITLE: Verifying BTCLI Installation\nDESCRIPTION: Command to verify the installation of btcli by checking its version.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-btcli.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli --version\n```\n\n----------------------------------------\n\nTITLE: Initializing and Synchronizing a Metagraph in Bittensor\nDESCRIPTION: Shows how to initialize a metagraph to represent the current state of the Bittensor network and synchronize it to reflect the latest state. Also demonstrates accessing metagraph properties and maintaining local copies of network data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\nmetagraph = Metagraph(netuid=config.netuid, network=subtensor.network, sync=False)\n\nmetagraph.sync(subtensor=subtensor)\n\ntotal_stake = metagraph.S\nneuron_ranks = metagraph.R\nneuron_incentives = metagraph.I\naxons = metagraph.axons\nneurons = metagraph.neurons\n\nhotkeys = deepcopy(metagraph.hotkeys)\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering Hotkey with BTCLI\nDESCRIPTION: Commands for creating a new hotkey, regenerating a hotkey, and registering a hotkey on a subnet using BTCLI. These operations should be performed on a secure coldkey workstation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/validators-btcli-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new-hotkey\nbtcli wallet regen-hotkey\nbtcli subnets register\nbtcli subnets pow-register\n```\n\n----------------------------------------\n\nTITLE: Incrementally Staking TAO Tokens on Bittensor Subnets (Python)\nDESCRIPTION: This script demonstrates how to incrementally stake 3 TAO into several subnets over multiple blocks. It uses the Bittensor library to interact with the network, calculates slippage, and updates stake information for each subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(name=\"ExampleWalletName\")\nwallet.unlock_coldkey()\n\nto_buy = [119, 277, 18, 5] # list of netuids to stake into\nincrement = 0.01 # amount of TAO to stake\ntotal_spend = 0 # total amount of TAO spent\nstake = {} # dictionary to store the stake for each netuid\n\nwhile total_spend < 3:\n    for netuid in to_buy:\n        subnet = sub.subnet(netuid)\n        print(f\"slippage for subnet {netuid}\", subnet.slippage(increment))\n        sub.add_stake( \n            wallet = wallet, \n            netuid = netuid, \n            hotkey = subnet.owner_hotkey, \n            tao_amount = increment, \n        )\n\n        current_stake = sub.get_stake(\n            coldkey_ss58 = wallet.coldkeypub.ss58_address,\n            hotkey_ss58 = subnet.owner_hotkey,\n            netuid = netuid,\n        )\n        stake[netuid] = current_stake\n        total_spend += increment\n        print (f'netuid {netuid} price {subnet.price} stake {current_stake}')\n    sub.wait_for_block()\n```\n\n----------------------------------------\n\nTITLE: Async Method Declarations for Bittensor Network Interaction\nDESCRIPTION: A collection of asynchronous method declarations for interacting with the Bittensor blockchain. Methods include retrieving voting data, checking immunity periods, verifying delegate status, and querying neuron registration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nasync def get_vote_data(proposal_hash, block = None, block_hash = None, reuse_block = False)\n\nasync def immunity_period(netuid, block = None, block_hash = None, reuse_block = False)\n\nasync def initialize()\n\nasync def is_hotkey_delegate(hotkey_ss58, block = None, block_hash = None, reuse_block = False)\n\nasync def is_hotkey_registered(hotkey_ss58, netuid = None, block = None, block_hash = None, reuse_block = False)\n\nasync def is_hotkey_registered_any(hotkey_ss58, block = None, block_hash = None, reuse_block = False)\n\nasync def is_hotkey_registered_on_subnet(hotkey_ss58, netuid, block = None, block_hash = None, reuse_block = False)\n\nasync def last_drand_round()\n\nasync def max_weight_limit(netuid, block = None, block_hash = None, reuse_block = False)\n\nasync def metagraph(netuid, lite = True, block = None)\n\nasync def min_allowed_weights(netuid, block = None, block_hash = None, reuse_block = False)\n\nasync def neuron_for_uid(uid, netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Metagraph Methods in Python for Bittensor\nDESCRIPTION: This snippet contains various methods available in the Metagraph class. These methods provide access to different attributes and functionalities of the Metagraph object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndef S(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef R(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef I(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef E(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef C(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef T(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef Tv(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef D(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef B(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef W(self) -> torch.FloatTensor\n```\n\nLANGUAGE: python\nCODE:\n```\ndef hotkeys(self) -> List[str]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef coldkeys(self) -> List[str]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef addresses(self) -> List[str]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef __str__(self)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef __repr__(self)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef metadata(self) -> dict\n```\n\nLANGUAGE: python\nCODE:\n```\ndef __init__(self, netuid: int, network: str = 'finney', lite: bool = True, sync: bool = True) -> 'metagraph'\n```\n\nLANGUAGE: python\nCODE:\n```\ndef sync (self, block: Optional[int] = None, lite: bool = True) -> 'metagraph'\n```\n\nLANGUAGE: python\nCODE:\n```\ndef save(self) -> 'metagraph'\n```\n\nLANGUAGE: python\nCODE:\n```\ndef load(self) -> 'metagraph'\n```\n\nLANGUAGE: python\nCODE:\n```\ndef load_from_path(self, dir_path:str) -> 'metagraph'\n```\n\n----------------------------------------\n\nTITLE: Registering Wallet via Proof-of-Work in Bittensor\nDESCRIPTION: Function that registers a wallet to the Bittensor network using Proof-of-Work. It includes options for CUDA acceleration, multiple processes, and various parameters to control the registration process and blockchain transaction handling.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/registration/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nregister_extrinsic(subtensor, wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True, max_allowed_attempts = 3, output_in_place = True, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False)\n```\n\n----------------------------------------\n\nTITLE: Verifying Bittensor SDK version\nDESCRIPTION: Command to check the installed version of Bittensor SDK using the bittensor module.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m bittensor\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Unstaking from Low-Emission Validators in Python\nDESCRIPTION: This script unstakes TAO from validators with the lowest emissions. It first retrieves all stakes associated with a coldkey, filters them based on a minimum threshold, sorts by emission rate, and then concurrently executes unstaking operations. The script takes environment variables for wallet name, total TAO to unstake, and maximum number of validators to unstake from.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport os, sys, asyncio, time\nimport bittensor as bt\nimport bittensor_wallet\nfrom bittensor import tao\n\nasync def perform_unstake(subtensor, stake, amount):\n    try:\n        print(f\"⏳ Attempting to unstake {amount} from {stake.hotkey_ss58} on subnet {stake.netuid}\")\n        start = time.time()\n        result = await subtensor.unstake(\n            wallet, hotkey_ss58=stake.hotkey_ss58, netuid=stake.netuid, amount=amount\n        )\n        elapsed = time.time() - start\n        if result:\n            print(f\"✅ Successfully unstaked {amount} from {stake.hotkey_ss58} on subnet {stake.netuid} in {elapsed:.2f}s\")\n            return True\n        else:\n            print(f\"❌ Failed to unstake from {stake.hotkey_ss58} on subnet {stake.netuid}\")\n            return False\n    except Exception as e:\n        print(f\"❌ Error during unstake from {stake.hotkey_ss58} on subnet {stake.netuid}: {e}\")\n        return False\n\n\nasync def main():\n    async with bt.async_subtensor(network='test') as subtensor:\n        try:\n            # Retrieve all active active stakes asscociated with the coldkey\n            stakes = await subtensor.get_stake_for_coldkey(wallet_ck)\n        except Exception as e:\n            sys.exit(f\"❌ Failed to get stake info: {e}\")\n\n        # Filter and sort\n        # Remove small stakes that are under the minimum threshold\n        stakes = list(filter(lambda s: float(s.stake.tao) > unstake_minimum, stakes))\n        # Sort by emission rate (lowest emission first)\n        stakes = sorted(stakes, key=lambda s: s.emission.tao)\n        # Limit to the N lowest emission validators\n        stakes = stakes[:max_stakes_to_unstake]\n\n        if not stakes:\n            sys.exit(\"❌ No eligible stakes found to unstake.\")\n\n        print(f\"\\n📊 Preparing to unstake from {len(stakes)} validators:\\n\")\n        for s in stakes:\n            print(f\"Validator: {s.hotkey_ss58}\\n  NetUID: {s.netuid}\\n  Stake: {s.stake.tao}\\n  Emission: {s.emission}\\n-----------\")\n\n        # Determine how much TAO to unstake per validator\n        amount_per_stake = total_to_unstake / len(stakes)\n        \n        # Prepare concurrent unstake tasks, then execute as a batch\n        tasks = [\n            perform_unstake(subtensor, stake, min(amount_per_stake, stake.stake))\n            for stake in stakes\n        ]\n        results = await asyncio.gather(*tasks)\n\n        # Count successes and print final report\n        success_count = sum(results)\n        print(f\"\\n🎯 Unstake complete. Success: {success_count}/{len(stakes)}\")\n        \nwallet_name = os.environ.get('WALLET')\ntotal_to_unstake = os.environ.get('TOTAL_TAO_TO_UNSTAKE')\nmax_stakes_to_unstake = os.environ.get('MAX_STAKES_TO_UNSTAKE')\n\nif wallet_name is None:\n    sys.exit(\"wallet name not specified. Usage: `TOTAL_TAO_TO_UNSTAKE=1 MAX_STAKES_TO_UNSTAKE=10 WALLET=my-wallet-name ./unstakerscript.py`\")\n\nif total_to_unstake is None:\n    print(\"Unstaking total not specified, defaulting to 1 TAO.\")\n    total_to_unstake = 1\nelse:\n    try:\n        total_to_unstake = float(total_to_unstake)\n    except:\n        sys.exit(\"invalid TAO amount!\")\n\nif max_stakes_to_unstake is None:\n    max_stakes_to_unstake = 10\nelse:\n    try:\n        max_stakes_to_unstake = int(max_stakes_to_unstake)\n    except:\n        sys.exit(\"invalid number for MAX_STAKES_TO_UNSTAKE\")\n\nprint(f\"🔍 Using wallet: {wallet_name}\")\nprint(f\"🧮 Unstaking a total of {total_to_unstake} TAO across up to {max_stakes_to_unstake} lowest-emission validators\")\n\ntotal_to_unstake = bt.Balance.from_tao(total_to_unstake)\nwallet = bt.wallet(wallet_name)\nwallet_ck = wallet.coldkeypub.ss58_address\n\nunstake_minimum = 0.0005  # TAO\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Retrieving Stake Information for Coldkey and Hotkey\nDESCRIPTION: This method retrieves the stake information associated with a specified coldkey and hotkey, providing insights into the financial commitments related to these keys.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_stake_for_coldkey_and_hotkey(hotkey_ss58, coldkey_ss58, block = None)\n\n      Retrieves stake information associated with a specific coldkey and hotkey.\n\n      :param hotkey_ss58: the hotkey SS58 address to query\n      :type hotkey_ss58: str\n      :param coldkey_ss58: the coldkey SS58 address to query\n      :type coldkey_ss58: str\n      :param block: the block number to query\n      :type block: Optional[int]\n\n      :returns: Stake Balance for the given coldkey and hotkey\n```\n\n----------------------------------------\n\nTITLE: Fetching Subnet UIDs for Hotkey in Python\nDESCRIPTION: This asynchronous method retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. It identifies the specific subnets within the Bittensor network where the neuron associated with the hotkey is active.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nasync def get_netuids_for_hotkey(hotkey_ss58, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Querying Total Stake at Dynamic Registration with Python\nDESCRIPTION: This example shows how to query the total stake in the system at the moment of subnet registration under dynamic pricing for a specific network ID. It connects to the Finney test network and retrieves the historical stake value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'TotalStakeAtDynamic', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Listing Subnets using BTCLI in Bash\nDESCRIPTION: Command to list available subnets in Bittensor network. This is a permissionless read operation that doesn't require a coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets list\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to Multiple Hotkeys in Bittensor\nDESCRIPTION: Function to add stake from a wallet's coldkey to multiple hotkeys simultaneously. It takes lists of hotkey addresses and corresponding amounts, with options to wait for blockchain inclusion or finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/staking/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef add_stake_multiple_extrinsic(subtensor, wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False):\n\n   Adds stake to each ``hotkey_ss58`` in the list, using each amount, from a common coldkey.\n\n   :param subtensor: The initialized SubtensorInterface object.\n   :param wallet: Bittensor wallet object for the coldkey.\n   :param hotkey_ss58s: List of hotkeys to stake to.\n   :param amounts: List of amounts to stake. If `None`, stake all to the first hotkey.\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns `False`\n                              if the extrinsic fails to enter the block within the timeout.\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning `True`, or\n                                 returns `False` if the extrinsic fails to be finalized within the timeout.\n\n   :returns:\n\n             `True` if extrinsic was finalized or included in the block. `True` if any wallet was staked. If we did\n                 not wait for finalization/inclusion, the response is `True`.\n   :rtype: success\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to a Single Hotkey in Bittensor\nDESCRIPTION: Function to add stake from a wallet's coldkey to a specified hotkey. The function allows staking a specific amount or all available balance and can optionally wait for blockchain inclusion or finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/staking/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef add_stake_extrinsic(subtensor, wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False):\n\n   Adds the specified amount of stake to passed hotkey `uid`.\n\n   :param subtensor: the Subtensor object to use\n   :param wallet: Bittensor wallet object.\n   :param hotkey_ss58: The `ss58` address of the hotkey account to stake to defaults to the wallet's hotkey.\n   :param amount: Amount to stake as Bittensor balance, `None` if staking all.\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                              `False` if the extrinsic fails to enter the block within the timeout.\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning `True`,\n                                 or returns `False` if the extrinsic fails to be finalized within the timeout.\n\n   :returns:\n\n             Flag is `True` if extrinsic was finalized or included in the block. If we did not wait for\n                           finalization/inclusion, the response is `True`.\n   :rtype: success\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to a Single Hotkey in Bittensor (Python)\nDESCRIPTION: This asynchronous function adds a specified amount of stake to a given hotkey in the Bittensor network. It handles the extrinsic call to the Subtensor and supports waiting for inclusion or finalization of the transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/staking/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def add_stake_extrinsic(subtensor, wallet, old_balance = None, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False):\n    \"\"\"\n    Adds the specified amount of stake to passed hotkey `uid`.\n\n    :param subtensor: the initialized SubtensorInterface object to use\n    :param wallet: Bittensor wallet object.\n    :param old_balance: the balance prior to the staking\n    :param hotkey_ss58: The `ss58` address of the hotkey account to stake to defaults to the wallet's hotkey.\n    :param amount: Amount to stake as Bittensor balance, `None` if staking all.\n    :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                              `False` if the extrinsic fails to enter the block within the timeout.\n    :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning `True`,\n                                 or returns `False` if the extrinsic fails to be finalized within the timeout.\n\n    :returns:\n             Flag is `True` if extrinsic was finalized or included in the block. If we did not wait for\n                           finalization/inclusion, the response is `True`.\n    :rtype: success\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registering a Hotkey on a Bittensor Subnet (Python)\nDESCRIPTION: This script demonstrates how to register a hotkey on a specific subnet using the burned_register method. It includes the method signature, parameters, return value, and a sample usage script.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nburned_register(\n    wallet, \n    netuid: int, \n) -> bool\n\n# Sample script:\nimport bittensor as bt\nlogging = bt.logging\nlogging.set_info()\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(\n    name=\"ExampleWalletName\",\n    hotkey=\"ExampleHotkey\",\n)\nwallet.unlock_coldkey()\nreg = sub.burned_register(wallet=wallet, netuid=3)\n```\n\n----------------------------------------\n\nTITLE: Setting Weights in Bittensor Network\nDESCRIPTION: Method to set weights for a given network UID (netuid) in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nset_weights(self, wallet: 'bittensor.wallet', netuid: int, uids: Union[torch.LongTensor, list], weights: Union[torch.FloatTensor, list], version_key: int = bittensor.__version_as_int__, wait_for_inclusion:bool = False, wait_for_finalization:bool = False, prompt:bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Transfer Funds Using Bittensor Extrinsic\nDESCRIPTION: Function to transfer funds from one wallet to another on the Bittensor network. Supports full or partial balance transfers with options for transaction confirmation waiting and account preservation. Takes parameters for source wallet, destination address, amount, and various transfer options.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/transfer/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef transfer_extrinsic(subtensor, wallet, dest, amount, transfer_all = False, wait_for_inclusion = True, wait_for_finalization = False, keep_alive = True):\n   \"\"\"Transfers funds from this wallet to the destination public key address.\n\n   :param subtensor: the Subtensor object used for transfer\n   :type subtensor: bittensor.core.subtensor.Subtensor\n   :param wallet: Bittensor wallet object to make transfer from.\n   :type wallet: bittensor_wallet.Wallet\n   :param dest: Destination public key address (ss58_address or ed25519) of recipient.\n   :type dest: str\n   :param amount: Amount to stake as Bittensor balance.\n   :type amount: bittensor.utils.balance.Balance\n   :param transfer_all: Whether to transfer all funds from this wallet to the destination address.\n   :type transfer_all: bool\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                              `False` if the extrinsic fails to enter the block within the timeout.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 `True`, or returns `False` if the extrinsic fails to be finalized within the timeout.\n   :type wait_for_finalization: bool\n   :param keep_alive: If set, keeps the account alive by keeping the balance above the existential deposit.\n   :type keep_alive: bool\n\n   :returns:\n\n             Flag is `True` if extrinsic was finalized or included in the block. If we did not wait for\n                 finalization / inclusion, the response is `True`, regardless of its inclusion.\n   :rtype: success (bool)\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Accessing Metagraph Properties in Bittensor Network in Python\nDESCRIPTION: Retrieves various properties from the metagraph for use in network interactions and decisions. This includes stake information, neuron rankings, incentives, and communication endpoints.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntotal_stake = metagraph.S\nneuron_ranks = metagraph.R\nneuron_incentives = metagraph.I\naxons = metagraph.axons\nneurons = metagraph.neurons\n```\n\n----------------------------------------\n\nTITLE: Checking Hotkey Registration Status in Bittensor (Python)\nDESCRIPTION: Determines if a hotkey is registered in the Bittensor network, either globally or on a specific subnet. This function is critical for validating a neuron's participation eligibility in network processes like consensus and validation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\ndef is_hotkey_registered(hotkey_ss58, netuid = None, block = None):\n    \"\"\"\n    Determines whether a given hotkey (public key) is registered in the Bittensor network, either globally across\n        any subnet or specifically on a specified subnet. This function checks the registration status of a neuron\n        identified by its hotkey, which is crucial for validating its participation and activities within the\n        network.\n\n    :param hotkey_ss58: The SS58 address of the neuron's hotkey.\n    :param netuid: The unique identifier of the subnet to check the registration. If `None`, the\n                   registration is checked across all subnets.\n    :param block: The blockchain block number at which to perform the query.\n\n    :returns:\n\n              `True` if the hotkey is registered in the specified context (either any subnet or a specific subnet),\n                  `False` otherwise.\n    :rtype: bool\n\n    This function is important for verifying the active status of neurons in the Bittensor network. It aids in\n        understanding whether a neuron is eligible to participate in network processes such as consensus,\n        validation, and incentive distribution based on its registration status.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Minimum TAO for Validator Permit in Bittensor\nDESCRIPTION: Python script to calculate the minimum TAO required for a validator permit based on the top 64 stake holders in a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph(1)\ntop_64_stake = sorted(subnet.S)[-64:]\nprint (f'Current requirement for validator permits based on the top 64 stake stands at {min(top_64_stake)} tao')\n```\n\n----------------------------------------\n\nTITLE: Querying Neuron Information in Python using Bittensor API\nDESCRIPTION: This snippet contains multiple methods for retrieving neuron information from the Bittensor network. It includes functions to get neuron data for specific public keys, wallets, and user IDs across different subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nget_neuron_for_pubkey_and_subnet( self, hotkey_ss58: str, netuid: int, block: Optional[int] = None ) -> Optional[NeuronInfo]\n```\n\nLANGUAGE: python\nCODE:\n```\nget_all_neurons_for_pubkey( self, hotkey_ss58: str, block: Optional[int] = None ) -> List[NeuronInfo]\n```\n\nLANGUAGE: python\nCODE:\n```\nneuron_has_validator_permit( self, uid: int, netuid: int, block: Optional[int] = None ) -> Optional[bool]\n```\n\nLANGUAGE: python\nCODE:\n```\nneuron_for_wallet( self, wallet: 'bittensor.Wallet', netuid = int, block: Optional[int] = None ) -> Optional[NeuronInfo]\n```\n\nLANGUAGE: python\nCODE:\n```\nneuron_for_uid( self, uid: int, netuid: int, block: Optional[int] = None ) -> Optional[NeuronInfo]\n```\n\nLANGUAGE: python\nCODE:\n```\nneurons(self, netuid: int, block: Optional[int] = None ) -> List[NeuronInfo]\n```\n\nLANGUAGE: python\nCODE:\n```\nneuron_for_uid_lite( self, uid: int, netuid: int, block: Optional[int] = None ) -> Optional[NeuronInfoLite]\n```\n\nLANGUAGE: python\nCODE:\n```\nneurons_lite(self, netuid: int, block: Optional[int] = None ) -> List[NeuronInfoLite]\n```\n\nLANGUAGE: python\nCODE:\n```\nmetagraph( self, netuid: int, lite: bool = True ) -> 'bittensor.Metagraph'\n```\n\n----------------------------------------\n\nTITLE: Asynchronously Staking to Top Subnets/Validators with Bittensor Python SDK\nDESCRIPTION: This script demonstrates how to asynchronously stake a user-defined amount of TAO across a specified number of top subnets and validators using the Bittensor Python SDK. It utilizes the AsyncSubtensor module for concurrent blockchain interactions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport os, sys, asyncio\nimport bittensor as bt\nimport time\nfrom bittensor import tao\n\n# Load environmental variables\nwallet_name=os.environ.get('WALLET')\ntotal_to_stake=os.environ.get('TOTAL_TAO_TO_STAKE')\nnum_subnets= os.environ.get('NUM_SUBNETS_TO_STAKE_IN')\nvalidators_per_subnet = os.environ.get('NUM_VALIDATORS_PER_SUBNET')\n\n# Validate inputs\nif wallet_name is None:\n    sys.exit(\"❌ WALLET not specified. Usage: `WALLET=my-wallet TOTAL_TAO_TO_STAKE=1 NUM_SUBNETS_TO_STAKE_IN=3 NUM_VALIDATORS_PER_SUBNET=3 python script.py`\")\n\nif total_to_stake is None:\n    print(\"⚠️ TOTAL_TAO_TO_STAKE not specified. Defaulting to 1 TAO.\")\n    total_to_stake = 1.0\nelse:\n    try:\n        total_to_stake = float(total_to_stake)\n    except:\n        sys.exit(\"❌ Invalid TOTAL_TAO_TO_STAKE amount.\")\n\nif num_subnets is None:\n    num_subnets = 3\nelse:\n    try:\n        num_subnets = int(num_subnets)\n    except:\n        sys.exit(\"❌ Invalid NUM_SUBNETS_TO_STAKE_IN.\")\n\nif validators_per_subnet is None:\n    validators_per_subnet = 3\nelse:\n    try:\n        validators_per_subnet = int(validators_per_subnet)\n    except:\n        sys.exit(\"❌ Invalid NUM_VALIDATORS_PER_SUBNET.\")\n\nprint(f\"\\n🔓 Using wallet: {wallet_name}\")\nprint(f\"📊 Dividing {total_to_stake} TAO across top {validators_per_subnet} validators in each of top {num_subnets} subnets.\")\n\nwallet = bt.wallet(wallet_name)\n```\n\n----------------------------------------\n\nTITLE: Getting Total Stake for Coldkey\nDESCRIPTION: This method returns the total stake held on a specific coldkey by taking its SS58 address as a parameter. It provides insights into the financial position of the coldkey in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_total_stake_for_coldkey(ss58_address, block = None)\n\n      Returns the total stake held on a coldkey.\n\n      :param ss58_address: The SS58 address of the coldkey\n      :type ss58_address: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance of the stake held on the coldkey.\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Existence in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method verifies if a subnet with the specified unique identifier exists within the Bittensor network. It can query this information at a specific blockchain block (by number or hash) and returns a boolean result indicating existence.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nsubnet_exists(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Displaying Subnet Information with Dynamic TAO in Bittensor CLI\nDESCRIPTION: This snippet demonstrates how to use the 'btcli subnet list' command to view information about subnets and their currency reserves in the Dynamic TAO system. It shows subnet details including price, market cap, emission, and stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/index.md#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n                                                                Subnets\n                                                               Network: rao\n\n\n        ┃               ┃ Price       ┃ Market Cap  ┃              ┃                         ┃               ┃              ┃\n Netuid ┃ Name          ┃ (τ_in/α_in) ┃ (α * Price) ┃ Emission (τ) ┃ P (τ_in, α_in)          ┃ Stake (α_out) ┃ Supply (α)   ┃ Tempo (k/n)\n━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━\n   0    │ τ root        │ 1.00 τ/Τ    │ τ 5.93m     │ τ 0.0000     │ -, -                    │ Τ 5.93m       │ 5.93m Τ /21M │ -/-\n   3    │ γ templar     │ 0.02 τ/γ    │ τ 57.32     │ τ 0.0197     │ τ 31.44, 1.43k γ        │ 1.18k γ       │ 2.61k γ /21M │ 67/99\n   9    │ ι pretrain    │ 0.02 τ/ι    │ τ 55.38     │ τ 0.0194     │ τ 30.91, 1.46k ι        │ 1.16k ι       │ 2.61k ι /21M │ 73/99\n   1    │ α apex        │ 0.02 τ/α    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k α        │ 1.14k α       │ 2.61k α /21M │ 65/99\n   2    │ β omron       │ 0.02 τ/β    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k β        │ 1.14k β       │ 2.61k β /21M │ 66/99\n   4    │ δ targon      │ 0.02 τ/δ    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k δ        │ 1.14k δ       │ 2.61k δ /21M │ 68/99\n   ...\n```\n\n----------------------------------------\n\nTITLE: Checking Miner Registration Status with SS58 Hotkey\nDESCRIPTION: Python script to check the registration status of a miner using its SS58 hotkey. It uses the Bittensor library to interact with the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/index.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n# Replace below with your SS58 hotkey \nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nsub = bt.subtensor(network)\nprint(f\"Registration status for hotkey {hotkey} is: {sub.is_hotkey_registered(hotkey)}\")\n```\n\n----------------------------------------\n\nTITLE: Managing Stake Operations in Python\nDESCRIPTION: Async methods for querying and managing stake information for both coldkeys and hotkeys in the Bittensor network. Includes functionality to get total stakes and detailed stake information for multiple keys.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nasync def get_stake_info_for_coldkey(coldkey_ss58, block = None, block_hash = None, reuse_block = False)\nasync def get_total_stake_for_coldkey(ss58_address, block = None, block_hash = None, reuse_block = False)\nasync def get_total_stake_for_coldkeys(*ss58_addresses, block = None, block_hash = None, reuse_block = False)\nasync def get_total_stake_for_hotkey(ss58_address, block = None, block_hash = None, reuse_block = False)\nasync def get_total_stake_for_hotkeys(*ss58_addresses, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Wallet Management Commands in Bittensor CLI\nDESCRIPTION: List of btcli commands for managing wallets, including creating new keys, regenerating keys, transferring funds, and managing wallet identities.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallets regen-coldkeypub\nbtcli wallets regen-hotkey\nbtcli wallets new-hotkey\nbtcli wallets new-coldkey\nbtcli wallets create\nbtcli wallets balance\nbtcli wallets history\nbtcli wallets overview\nbtcli wallets transfer\nbtcli wallets inspect\nbtcli wallets faucet\nbtcli wallets set-identity\nbtcli wallets get-identity\nbtcli wallets sign\nbtcli wallets swap_hotkey\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Commit-Reveal Extrinsic in Bittensor Python\nDESCRIPTION: This asynchronous function handles the commit-reveal process for a Bittensor validator. It takes a subtensor instance, wallet, network ID, UIDs, weights, and optional parameters for version key and transaction confirmation behavior. The function returns a tuple containing a success boolean and a result message.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/commit_reveal/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def commit_reveal_v3_extrinsic(subtensor, wallet, netuid, uids, weights, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Initializing Bittensor Metagraph Example\nDESCRIPTION: Example showing how to initialize and use the Metagraph class to represent the current state of the Bittensor network, including synchronization and accessing network properties.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\nmetagraph = Metagraph(netuid=config.netuid, network=subtensor.network, sync=False)\n\nmetagraph.sync(subtensor=subtensor)\n\ntotal_stake = metagraph.S\nneuron_ranks = metagraph.R\nneuron_incentives = metagraph.I\naxons = metagraph.axons\nneurons = metagraph.neurons\n\nhotkeys = deepcopy(metagraph.hotkeys)\n```\n\n----------------------------------------\n\nTITLE: Revealing Weights on Bittensor Blockchain (Python)\nDESCRIPTION: Allows neurons to reveal their previously committed weight distribution for a specific subnet, ensuring transparency and accountability within the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\ndef reveal_weights(wallet, netuid, uids, weights, salt, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False, max_retries = 5):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Transferring Tokens in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method transfers tokens from a source wallet to a destination address. It supports options for transferring all tokens, waiting for inclusion or finalization, and keeping the account alive. Returns a boolean indicating success.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\ntransfer(wallet, dest, amount, transfer_all = False, wait_for_inclusion = True, wait_for_finalization = False, keep_alive = True)\n```\n\n----------------------------------------\n\nTITLE: Rotating Bittensor Hotkey using CLI\nDESCRIPTION: Command to swap a potentially compromised hotkey with a new one using the Bittensor CLI. This operation moves the registration and delegated stake to a new hotkey owned by the same coldkey, incurring a 1 τ recycling fee.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/coldkey-hotkey-security.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet swap-hotkey\n```\n\n----------------------------------------\n\nTITLE: Listing axon information for neurons\nDESCRIPTION: Python code to import bittensor, create a metagraph object, and list axon information for the first 10 neurons.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nmetagraph = bt.metagraph(1)\nmetagraph.axons[:10]\n```\n\n----------------------------------------\n\nTITLE: Calculating Alpha to TAO Exchange with Slippage\nDESCRIPTION: Python method for estimating the amount of TAO received when unstaking Alpha tokens, considering slippage based on the current pool state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nalpha_to_tao_with_slippage(alpha: Union[Balance, float, int], percentage: bool = False) -> Union[tuple[Balance, Balance], float]:\n```\n\n----------------------------------------\n\nTITLE: Querying Trust Values in Bittensor Network with Python\nDESCRIPTION: This example shows how to query the trust values of UIDs in a specific Bittensor subnet. It connects to the Finney test network and retrieves a vector of trust values for all UIDs in the specified network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'Trust', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Metagraph Object with Specific Parameters\nDESCRIPTION: Demonstrates how to initialize a metagraph object for the Bittensor network with specific parameters including network UID, network name, lite mode, and synchronization options.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\n\nmetagraph = Metagraph(netuid=123, network=\"finney\", lite=True, sync=True)\n```\n\n----------------------------------------\n\nTITLE: Creating a Default Wallet using Bittensor Wallet SDK\nDESCRIPTION: Python code demonstrating how to create a default wallet using the Bittensor Wallet SDK.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor_wallet import Wallet\n\n# creates wallet with name `default`\nwallet = Wallet()\nwallet.create()\n```\n\n----------------------------------------\n\nTITLE: Transferring Funds in Bittensor Network\nDESCRIPTION: Method to transfer funds from a wallet to a destination public key address in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntransfer(self, wallet: 'bittensor.wallet', dest: str, amount: Union[Balance, float], wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Registering a Wallet to Root Network in Bittensor\nDESCRIPTION: Function that registers a wallet to the Bittensor root network. It accepts a subtensor object, wallet, and boolean flags to control waiting for inclusion or finalization of the transaction on the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/root/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nroot_register_extrinsic(subtensor, wallet, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Querying WeightsVersionKey in Bittensor Network with Python\nDESCRIPTION: This snippet shows how to query the WeightsVersionKey parameter for a specific netuid in the Bittensor network using the Substrate interface. The WeightsVersionKey represents the version key for weights in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'WeightsVersionKey', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Checking Registration Status with SS58 Hotkey and Netuid in Bittensor\nDESCRIPTION: Python script to check the registration status of a hotkey in a specific subnet of Bittensor using the SS58 address and netuid.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nnetuid = 1 # subnet uid\nsub = bt.subtensor(network)\nmg = sub.metagraph(netuid)\nif hotkey not in mg.hotkeys:\n  print(f\"Hotkey {hotkey} deregistered\")\nelse:\n  print(f\"Hotkey {hotkey} is registered\")\n```\n\n----------------------------------------\n\nTITLE: Listing All Wallets with Bittensor CLI\nDESCRIPTION: This command displays all wallets and their corresponding hotkeys in the specified wallet path. It presents the output in a hierarchical tree format showing the SS58 addresses for each coldkey and hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_43\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet list --path ~/.bittensor\n```\n\n----------------------------------------\n\nTITLE: Multiple Unstaking Extrinsic Function in Python\nDESCRIPTION: Removes stake from multiple hotkeys simultaneously to a common coldkey. Supports batch unstaking operations with configurable amounts for each hotkey and options for transaction confirmation waiting.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/unstaking/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef unstake_multiple_extrinsic(subtensor, wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Creating a New Coldkey with Bittensor CLI\nDESCRIPTION: This command creates a new coldkey required for holding TAO balances and performing high-value transactions. It allows specifying the mnemonic word count and supports password protection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_44\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new_coldkey --n_words 15\n```\n\n----------------------------------------\n\nTITLE: Subscribing Endpoint to Bittensor Network in Python\nDESCRIPTION: Asynchronous function that subscribes a Bittensor endpoint to the subtensor chain. It configures network connectivity with IP, port, and protocol settings, with options for TLS and transaction confirmation parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/serving/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def serve_extrinsic(subtensor, wallet, ip, port, protocol, netuid, placeholder1 = 0, placeholder2 = 0, wait_for_inclusion = False, wait_for_finalization=True, certificate = None):\n    \"\"\"\n    Subscribes a Bittensor endpoint to the subtensor chain.\n\n    :param subtensor: Subtensor instance object.\n    :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n    :param wallet: Bittensor wallet object.\n    :type wallet: bittensor_wallet.Wallet\n    :param ip: Endpoint host port i.e., ``192.122.31.4``.\n    :type ip: str\n    :param port: Endpoint port number i.e., ``9221``.\n    :type port: int\n    :param protocol: An ``int`` representation of the protocol.\n    :type protocol: int\n    :param netuid: The network uid to serve on.\n    :type netuid: int\n    :param placeholder1: A placeholder for future use.\n    :type placeholder1: int\n    :param placeholder2: A placeholder for future use.\n    :type placeholder2: int\n    :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning ``True``, or\n                              returns ``False`` if the extrinsic fails to enter the block within the timeout.\n    :type wait_for_inclusion: bool\n    :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 ``True``, or returns ``False`` if the extrinsic fails to be finalized within the timeout.\n    :type wait_for_finalization: bool\n    :param certificate: Certificate to use for TLS. If ``None``, no TLS will be used.\n                       Defaults to ``None``.\n    :type certificate: bittensor.utils.Certificate\n\n    :returns:\n\n             Flag is ``True`` if extrinsic was finalized or included in the block. If we did not wait for\n                 finalization / inclusion, the response is ``True``.\n    :rtype: success (bool)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying Weights Between UIDs in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to query the weight values set by a specific UID to other UIDs in a Bittensor subnet. It connects to the Finney test network and retrieves the vector of weight assignments from one neuron to others.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nuid = 123\nresult = substrate.query('SubtensorModule', 'Weights', [netuid, uid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Unstaking Extrinsic in Bittensor (Python)\nDESCRIPTION: Asynchronous function to remove stake from a specified hotkey back to the wallet's coldkey. Allows configuring wait behavior for transaction inclusion and finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/unstaking/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def unstake_extrinsic(subtensor, wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False):\n   \"\"\"\n   Removes stake into the wallet coldkey from the specified hotkey ``uid``.\n\n   :param subtensor: AsyncSubtensor instance.\n   :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n   :param wallet: Bittensor wallet object.\n   :type wallet: bittensor_wallet.Wallet\n   :param hotkey_ss58: The ``ss58`` address of the hotkey to unstake from. By default, the wallet hotkey\n                       is used.\n   :type hotkey_ss58: Optional[str]\n   :param amount: Amount to stake as Bittensor balance, or ``float`` interpreted as Tao.\n   :type amount: Union[Balance, float]\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning ``True``, or\n                              returns ``False`` if the extrinsic fails to enter the block within the timeout.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 ``True``, or returns ``False`` if the extrinsic fails to be finalized within the timeout.\n   :type wait_for_finalization: bool\n\n   :returns:\n\n             Flag is ``True`` if extrinsic was finalized or included in the block. If we did not wait for\n                 finalization / inclusion, the response is ``True``.\n   :rtype: success (bool)\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Revealing Weights on Bittensor Blockchain\nDESCRIPTION: Async function for revealing the weights for a specific subnet on the Bittensor blockchain. It handles the submission of UIDs, weights, salt values, and version key with options to wait for transaction inclusion or finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/weights/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def reveal_weights_extrinsic(subtensor, wallet, netuid, uids, weights, salt, version_key, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Unstaking Tokens in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method removes a specified amount of stake from a hotkey account. It requires the wallet credentials and optionally the hotkey address and amount to unstake. If no amount is specified, it unstakes all tokens. Returns a boolean indicating success.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_60\n\nLANGUAGE: python\nCODE:\n```\nunstake(wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Wallet using Bittensor Wallet SDK\nDESCRIPTION: Python code showing how to create a custom wallet by specifying name, path, and hotkey using the Bittensor Wallet SDK.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor_wallet import Wallet\n\nmy_name = \"my_wallet_name\"\nmy_path = \"path_to_my_wallet\"\nmy_hotkey = \"name_of_my_hotkey\"\n\nmy_wallet = Wallet(name=my_name, path=my_path, hotkey=my_hotkey)\nmy_wallet.create()\n```\n\n----------------------------------------\n\nTITLE: Finding Top Three Validators in a Subnet in Python\nDESCRIPTION: This function retrieves the metagraph for a given subnet, extracts the top three validators based on their stake, and returns relevant information. It uses asynchronous operations to fetch the metagraph data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def find_top_three_valis(subtensor,subnet):\n    netuid = subnet.netuid\n    print(f\"\\n🔍 Subnet {netuid} had {subnet.tao_in_emission} emissions!\")\n    print(f\"\\n🔍 Fetching metagraph for subnet {netuid}...\")\n    \n    start_time = time.time()\n    metagraph = await subtensor.metagraph(netuid)\n\n    print(f\"✅ Retrieved metagraph for subnet {netuid} in {time.time() - start_time:.2f} seconds.\")\n    # Extract validators and their stake amounts\n    hk_stake_pairs = [(metagraph.hotkeys[index], metagraph.stake[index]) for index in range(len(metagraph.stake))]\n    \n    # Sort validators by stake in descending order\n    top_validators = sorted(hk_stake_pairs, key=lambda x: x[1], reverse=True)[0:3]\n\n    # Print the top 3 validators for this subnet\n    print(f\"\\n🏆 Top 3 Validators for Subnet {netuid}:\")\n    for rank, (index, stake) in enumerate(top_validators, start=1):\n        print(f\"  {rank}. Validator index {index} - Stake: {stake}\")\n    \n    return {\n        \"netuid\": netuid,\n        \"metagraph\": metagraph,\n        \"validators\": top_validators\n    }\n```\n\n----------------------------------------\n\nTITLE: Extracting UID Information from Bittensor Subnet\nDESCRIPTION: Demonstrates how to extract information about a specific UID in a Bittensor subnet, including the associated hotkey and coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph( netuid = 1 )\nuid = 123\nprint ('uid', uid, ' owned by hotkey:', subnet.hotkeys[ uid ], 'associated with coldkey': subnet.coldkey[ uid ] )\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Subnets Information in Bittensor Network\nDESCRIPTION: Fetches comprehensive information about all subnets in the Bittensor network, providing details on each subnet's characteristics and operational parameters at a specific block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef get_all_subnets_info(block = None):\n      Retrieves detailed information about all subnets within the Bittensor network. This function provides\n          comprehensive data on each subnet, including its characteristics and operational parameters.\n\n      :param block: The blockchain block number for the query.\n\n      :returns: A list of SubnetInfo objects, each containing detailed information about a subnet.\n      :rtype: list[SubnetInfo]\n\n      Gaining insights into the subnets' details assists in understanding the network's composition, the roles of\n          different subnets, and their unique features.\n```\n\n----------------------------------------\n\nTITLE: Viewing Bittensor Subnet Parameters\nDESCRIPTION: Shows how to access and print the stake and weights of validators in a Bittensor subnet using Python. It uses the bt.metagraph function with lite=False for full data access.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph( netuid = 1, lite = False)\nprint ('subnet 1 validator stake', subnet.S )\nprint ('subnet 1 validator weights', subnet.W )\n```\n\n----------------------------------------\n\nTITLE: Root Weight Setting Method Python Definition\nDESCRIPTION: Method to set weights for the root network, allowing specification of subnet UIDs and corresponding weights with version control.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_60\n\nLANGUAGE: python\nCODE:\n```\ndef root_set_weights(wallet, netuids, weights, version_key = 0, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Information by Hotkey in Bittensor\nDESCRIPTION: Fetches comprehensive information about a delegate neuron based on its hotkey address, including stakes, nominators, and reward distribution parameters at a specified block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef get_delegate_by_hotkey(hotkey_ss58, block = None):\n      Retrieves detailed information about a delegate neuron based on its hotkey. This function provides a\n          comprehensive view of the delegate's status, including its stakes, nominators, and reward distribution.\n\n      :param hotkey_ss58: The ``SS58`` address of the delegate's hotkey.\n      :type hotkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Detailed information about the delegate neuron, ``None`` if not found.\n      :rtype: Optional[DelegateInfo]\n\n      This function is essential for understanding the roles and influence of delegate neurons within the Bittensor\n          network's consensus and governance structures.\n```\n\n----------------------------------------\n\nTITLE: Staking TAO Tokens to Top Validators in Python\nDESCRIPTION: This function stakes a specified amount of TAO tokens to a list of top validators on a given subnet. It uses asynchronous operations to perform multiple staking transactions concurrently.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def stake_batch(subtensor, netuid, top_validators, amount_to_stake):\n    for hk in top_validators:\n        print(f\"💰 Staking {amount_to_stake} to {hk} on subnet {netuid}...\")\n    try:\n        results = await asyncio.gather(*[ subtensor.add_stake(wallet=wallet, netuid=netuid, hotkey_ss58=hk, amount=amount_to_stake) for hk in top_validators ] )\n        print(results)\n    except Exception as e:\n        print(f\"❌ Failed to stake to {hk} on subnet {netuid}: {e}\")\n```\n\n----------------------------------------\n\nTITLE: Viewing Current Difficulty using CLI in Opentensor Network\nDESCRIPTION: This command uses the Opentensor CLI to list subnets and display current difficulty levels for POW and Recycle registrations. It shows network IDs, neuron counts, maximum neurons, difficulties, tempo, connection requirements, emission percentages, and burn costs.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_difficulty.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets list\nNETUID  NEURONS  MAX_N   DIFFICULTY  TEMPO  CON_REQ  EMISSION  BURN(τ)\n1       691    1.02 K   198.08 T    99     None     28.44%   τ4.75710\n3      4096    4.10 K   320.81 T    99     None     71.56%   τ1.00000\n    DIFFICULTY: Current proof of work difficulty\n    BURN: Current cost to register a key via recycle registration.\n```\n\n----------------------------------------\n\nTITLE: Creating a New Subnet with btcli subnet create\nDESCRIPTION: This command registers a new subnet. It requires wallet information and network details.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets create\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Setting Child Stakes with btcli stake child set\nDESCRIPTION: This command sets child hotkeys on specified subnets with given proportions. It allows users to delegate authority to different hotkeys, securing their position and influence on the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child set -c 5FCL3gmjtQV4xxxxuEPEFQVhyyyyqYgNwX7drFLw7MSdBnxP -c 5Hp5dxxxxtGg7pu8dN2btyyyyVA1vELmM9dy8KQv3LxV8PA7 --hotkey default --netuid 1 -p 0.3 -p 0.7\n```\n\n----------------------------------------\n\nTITLE: Streaming Data from Axons Example\nDESCRIPTION: Example demonstrating how to stream data chunks from Axons using the Dendrite forward method with streaming enabled.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/dendrite/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndendrite = bittensor.Dendrite(wallet = wallet)\nasync for chunk in dendrite.forward(axons, synapse, timeout, deserialize, run_async, streaming):\n    # Process each chunk here\n    print(chunk)\n```\n\n----------------------------------------\n\nTITLE: Revealing Weights on Bittensor Blockchain in Python\nDESCRIPTION: This function reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet. It handles error checking and user interaction, returning a boolean success flag and a descriptive message.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/commit_weights/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef reveal_weights_extrinsic(subtensor, wallet, netuid, uids, weights, salt, version_key, wait_for_inclusion = False, wait_for_finalization = False):\n   \"\"\"Reveals the weights for a specific subnet on the Bittensor blockchain using the provided wallet.\n   This function is a wrapper around the `_do_reveal_weights` method.\n\n   :param subtensor: The subtensor instance used for blockchain interaction.\n   :type subtensor: bittensor.core.subtensor.Subtensor\n   :param wallet: The wallet associated with the neuron revealing the weights.\n   :type wallet: bittensor_wallet.Wallet\n   :param netuid: The unique identifier of the subnet.\n   :type netuid: int\n   :param uids: List of neuron UIDs for which weights are being revealed.\n   :type uids: list[int]\n   :param weights: List of weight values corresponding to each UID.\n   :type weights: list[int]\n   :param salt: List of salt values corresponding to the hash function.\n   :type salt: list[int]\n   :param version_key: Version key for compatibility with the network.\n   :type version_key: int\n   :param wait_for_inclusion: Waits for the transaction to be included in a block.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: Waits for the transaction to be finalized on the blockchain.\n   :type wait_for_finalization: bool\n\n   :returns:\n\n             ``True`` if the weight revelation is successful, False otherwise. And `msg`, a string value\n                 describing the success or potential error.\n   :rtype: tuple[bool, str]\n\n   This function provides a user-friendly interface for revealing weights on the Bittensor blockchain, ensuring proper\n       error handling and user interaction when required.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Adding Stake Method in Python\nDESCRIPTION: Method for adding stake to a neuron identified by hotkey SS58 address. Handles the staking process which enables neurons to participate and earn incentives in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef add_stake(wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False):\n    \"\"\"Adds the specified amount of stake to a neuron identified by the hotkey SS58 address.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Updating Legacy Bittensor Wallets to NaCl Format\nDESCRIPTION: This command updates any legacy Bittensor wallets to the new NaCl format for enhanced security. The example shows both the command and expected terminal output during the update process.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet update\n```\n\nLANGUAGE: bash\nCODE:\n```\n>> Do you want to update all legacy wallets? [y/n]: y\n>> =====  wallet(test-coldkey, default, ~/.bittensor/wallets/)  =====\n>> ✅ Keyfile is updated. \n>> 🔑 Keyfile (NaCl encrypted, /Users/docwriter/.bittensor/wallets/test-coldkey/coldkey)>\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Lock Cost on Bittensor Testchain\nDESCRIPTION: This command retrieves the current cost to create a subnet on the Bittensor testchain. The cost fluctuates based on demand.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet lock_cost --subtensor.network test\n```\n\n----------------------------------------\n\nTITLE: Querying Runtime API in Python\nDESCRIPTION: Async method for interacting with the blockchain's runtime API. Handles Scale Bytes encoded data and provides low-level access to runtime methods.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nasync def query_runtime_api(runtime_api, method, params = None, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Getting Neuron Info by Public Key and Subnet\nDESCRIPTION: This function retrieves detailed information about a neuron using its public key and subnet UID. It provides essential attributes related to the neuron's status and stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_neuron_for_pubkey_and_subnet(hotkey_ss58, netuid, block = None)\n\n      Retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID\n          (netuid). This function provides detailed neuron information for a particular subnet within the Bittensor\n          network.\n\n      :param hotkey_ss58: The ``SS58`` address of the neuron's hotkey.\n      :type hotkey_ss58: str\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns:\n\n                Detailed information about the neuron if found,\n                    ``None`` otherwise.\n      :rtype: Optional[bittensor.core.chain_data.neuron_info.NeuronInfo]\n\n      This function is crucial for accessing specific neuron data and understanding its status, stake, and other\n          attributes within a particular subnet of the Bittensor ecosystem.\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to Multiple Hotkeys in Bittensor\nDESCRIPTION: Method to add stake to multiple hotkeys from a common coldkey in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nadd_stake_multiple(self, wallet: 'bittensor.wallet', hotkey_ss58s: List[str], amounts: List[Union[Balance, float]] = None, wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Querying Multiple Axons with Dendrite Example\nDESCRIPTION: Example code showing how to initialize a Dendrite instance and query multiple Axons in the Bittensor network using the forward method.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/dendrite/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor\nwallet = bittensor.Wallet()                     # Initialize a wallet\nsynapse = bittensor.Synapse(...)                # Create a synapse object that contains query data\ndendrite = bittensor.Dendrite(wallet = wallet)  # Initialize a dendrite instance\nnetuid = ...                                    # Provide subnet ID\nmetagraph = bittensor.Metagraph(netuid)         # Initialize a metagraph instance\naxons = metagraph.axons                         # Create a list of axons to query\nresponses = await dendrite(axons, synapse)      # Send the query to all axons and await the responses\n```\n\n----------------------------------------\n\nTITLE: Setting Neuron Weights on Bittensor Blockchain in Python\nDESCRIPTION: Sets validator-defined weights for specified neurons on the Bittensor blockchain. Takes parameters for subtensor connection, wallet, subnet ID, neuron UIDs, weight values, version key, and transaction confirmation options. Returns a success boolean indicating if the operation was completed successfully.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/set_weights/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nset_weights_extrinsic(subtensor, wallet, netuid, uids, weights, version_key = 0, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Initializing a Metagraph for Bittensor Network in Python\nDESCRIPTION: Creates a new instance of the Metagraph class with specified network parameters. This example shows how to initialize a metagraph to represent the current state of the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\nmetagraph = Metagraph(netuid=config.netuid, network=subtensor.network, sync=False)\n```\n\n----------------------------------------\n\nTITLE: Displaying Subnet Information with Dynamic TAO-enabled btcli\nDESCRIPTION: This code snippet shows the output of the 'btcli subnet list' command, which displays information about subnets and their currency reserves on the Bittensor testnet. It includes details such as subnet name, price, market cap, emission, stake, and supply for various subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/understanding-subnets.md#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n        ┃               ┃ Price       ┃ Market Cap  ┃              ┃                         ┃               ┃              ┃\n Netuid ┃ Name          ┃ (τ_in/α_in) ┃ (α * Price) ┃ Emission (τ) ┃ P (τ_in, α_in)          ┃ Stake (α_out) ┃ Supply (α)   ┃ Tempo (k/n)\n━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━\n   0    │ τ root        │ 1.00 τ/Τ    │ τ 5.93m     │ τ 0.0000     │ -, -                    │ Τ 5.93m       │ 5.93m Τ /21M │ -/-\n   3    │ γ templar     │ 0.02 τ/γ    │ τ 57.32     │ τ 0.0197     │ τ 31.44, 1.43k γ        │ 1.18k γ       │ 2.61k γ /21M │ 67/99\n   9    │ ι pretrain    │ 0.02 τ/ι    │ τ 55.38     │ τ 0.0194     │ τ 30.91, 1.46k ι        │ 1.16k ι       │ 2.61k ι /21M │ 73/99\n   1    │ α apex        │ 0.02 τ/α    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k α        │ 1.14k α       │ 2.61k α /21M │ 65/99\n   2    │ β omron       │ 0.02 τ/β    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k β        │ 1.14k β       │ 2.61k β /21M │ 66/99\n   4    │ δ targon      │ 0.02 τ/δ    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k δ        │ 1.14k δ       │ 2.61k δ /21M │ 68/99\n   ...\n```\n\n----------------------------------------\n\nTITLE: Creating a Wallet using Python\nDESCRIPTION: Python code snippet to create a new Bittensor wallet with both coldkey and hotkey using the bittensor library.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nwallet = bt.wallet(name = 'my_coldkey', hotkey = 'my_hotkey' )\nwallet.create_if_non_existent()\n```\n\n----------------------------------------\n\nTITLE: Fetching Existential Deposit Amount in Python\nDESCRIPTION: This asynchronous method retrieves the existential deposit amount for the Bittensor blockchain. The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nasync def get_existential_deposit(block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Hyperparameters with btcli\nDESCRIPTION: This command demonstrates how to view the hyperparameters of a specific subnet using the Bittensor CLI. It displays various configuration settings for the subnet with the specified netuid.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/subnet-hyperparameters.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet hyperparameters --netuid 19\n```\n\n----------------------------------------\n\nTITLE: Efficient Neuron Retrieval Using AsyncSubtensor in Python\nDESCRIPTION: This code demonstrates an efficient way to retrieve all neurons from the testnet using AsyncSubtensor. It utilizes asyncio.gather for concurrent execution of multiple subnet queries.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.async_subtensor import AsyncSubtensor\n\nasync def async_main():\n    async with AsyncSubtensor(\"test\") as subtensor:\n        start = time.time()\n        block_hash = await subtensor.get_block_hash()\n        total_subnets = await subtensor.get_total_subnets(block_hash=block_hash)\n        neurons = await asyncio.gather(*[subtensor.neurons(x, block_hash) for x in range(0, total_subnets+1)])\n        print(time.time() - start)\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Starting and Stopping Axon Server in Python\nDESCRIPTION: Illustrates how to start and stop an Axon server. Starting the server allows it to accept incoming requests, while stopping it gracefully terminates connections and takes the server offline.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmy_axon = bittensor.Axon(...)\n... # setup axon, attach functions, etc.\nmy_axon.start()  # Starts the axon server\n\n...\n\nmy_axon.stop()  # Stops the axon server\n```\n\n----------------------------------------\n\nTITLE: Creating a Wallet with BTCLI in Shell\nDESCRIPTION: This command creates a new wallet using the Bittensor CLI (btcli). It's a prerequisite for managing stake in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet create\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateInfo Class in Bittensor Chain Data Module (Python)\nDESCRIPTION: Dataclass implementation for storing and managing delegate information in the Bittensor network. This class provides data structures for delegate attributes including stake, nominators, registrations, and return metrics.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/delegate_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass DelegateInfo:\n\n   Dataclass for delegate information. For a lighter version of this class, see ``DelegateInfoLite``.\n\n   :param hotkey_ss58: Hotkey of the delegate for which the information is being fetched.\n   :type hotkey_ss58: str\n   :param total_stake: Total stake of the delegate.\n   :type total_stake: int\n   :param nominators: List of nominators of the delegate and their stake.\n   :type nominators: list[tuple[str, int]]\n   :param take: Take of the delegate as a percentage.\n   :type take: float\n   :param owner_ss58: Coldkey of the owner.\n   :type owner_ss58: str\n   :param registrations: List of subnets that the delegate is registered on.\n   :type registrations: list[int]\n   :param validator_permits: List of subnets that the delegate is allowed to validate on.\n   :type validator_permits: list[int]\n   :param return_per_1000: Return per 1000 TAO, for the delegate over a day.\n   :type return_per_1000: int\n   :param total_daily_return: Total daily return of the delegate.\n   :type total_daily_return: int\n```\n\n----------------------------------------\n\nTITLE: Viewing Registered Subnets for a Hotkey (Python)\nDESCRIPTION: This script shows how to retrieve the netuids in which a hotkey is registered using the get_netuids_for_hotkey method. It includes the method signature, parameters, and an example usage script.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nget_netuids_for_hotkey(\n    hotkey: str, \n) -> list[int]\n\n# Example usage:\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(\n    name=\"ExampleWalletName\",\n    hotkey=\"ExampleHotkey\",\n)\nwallet.unlock_coldkey()\nnetuids = sub.get_netuids_for_hotkey(wallet.hotkey.ss58_address)\nprint(netuids)\n```\n\n----------------------------------------\n\nTITLE: Async Add Stake Method\nDESCRIPTION: Asynchronous method to add stake to a neuron identified by hotkey SS58 address. Handles the staking process in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def add_stake(wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False):\n```\n\n----------------------------------------\n\nTITLE: Registering Wallet in Bittensor Network\nDESCRIPTION: Method to register a wallet to the Bittensor chain, with options for CUDA acceleration and multiple processes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nregister(self, wallet: 'bittensor.Wallet', netuid: int, wait_for_inclusion: bool = False, wait_for_finalization: bool = True, prompt: bool = False, max_allowed_attempts: int = 3, output_in_place: bool = True, cuda: bool = False, dev_id: Union[List[int], int] = 0, TPB: int = 256, num_processes: Optional[int] = None, update_interval: Optional[int] = None, log_verbose: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Subnets Information in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method gathers comprehensive information about all subnets within the Bittensor network. Returns a list of SubnetInfo objects containing details about each subnet's characteristics and operational parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nget_all_subnets_info(block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Importing Test Wallets and Listing Keys\nDESCRIPTION: Demonstrates how to regenerate two test coldkeys using mnemonics and list their public keys. Creates wallets named 'playground-test1' and 'playground-test2' in the .bittensor/wallets directory.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet regen-coldkey \\\n--mnemonic \"add aerobic there stool organ switch about diagram arctic vague replace seminar\" \\\n--wallet.name 'playground-test1' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli wallet regen-coldkey \\\n--mnemonic \"nominee sort fringe gauge tank sure core memory abandon lamp alter flash\" \\\n--wallet.name 'playground-test2' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli wallet list --wallet.path ~/.bittensor/wallets\n```\n\n----------------------------------------\n\nTITLE: Unstaking TAO from a Single Hotkey in Bittensor Network (Python)\nDESCRIPTION: Method that removes a specified amount of stake from a single hotkey account. Takes parameters for wallet, hotkey address, amount to unstake, and options for waiting for transaction inclusion or finalization. Returns a boolean indicating success.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_70\n\nLANGUAGE: python\nCODE:\n```\ndef unstake(wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Upgrading Bittensor SDK with pip\nDESCRIPTION: Command to upgrade an existing Bittensor SDK installation to the latest version using pip.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m pip install --upgrade bittensor\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet-specific Hotkey Registration in Bittensor (Python)\nDESCRIPTION: Checks if a hotkey is registered on a specific subnet identified by netuid. This helps verify subnet-specific participation of a neuron.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\ndef is_hotkey_registered_on_subnet(hotkey_ss58, netuid, block = None):\n    \"\"\"\n    Checks if the hotkey is registered on a given netuid.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Initializing and Configuring Axon Server in Python\nDESCRIPTION: This code snippet demonstrates how to initialize an Axon server with custom configuration, attach custom request handling functions, and start the server. It includes examples of defining custom synapse classes and handling functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport bittensor\n\n# Define your custom synapse class\nclass MySynapse( bittensor.Synapse ):\n    input: int = 1\n    output: int = None\n\n# Define a custom request forwarding function using your synapse class\ndef forward( synapse: MySynapse ) -> MySynapse:\n    # Apply custom logic to synapse and return it\n    synapse.output = 2\n    return synapse\n\n# Define a custom request verification function\ndef verify_my_synapse( synapse: MySynapse ):\n    # Apply custom verification logic to synapse\n    # Optionally raise Exception\n    assert synapse.input == 1\n    ...\n\n# Define a custom request blacklist function\ndef blacklist_my_synapse( synapse: MySynapse ) -> bool:\n    # Apply custom blacklist\n    return False ( if non blacklisted ) or True ( if blacklisted )\n\n# Define a custom request priority function\ndef prioritize_my_synapse( synapse: MySynapse ) -> float:\n    # Apply custom priority\n    return 1.0\n\n# Initialize Axon object with a custom configuration\nmy_axon = bittensor.Axon(\n    config=my_config,\n    wallet=my_wallet,\n    port=9090,\n    ip=\"192.0.2.0\",\n    external_ip=\"203.0.113.0\",\n    external_port=7070\n)\n\n# Attach the endpoint with the specified verification and forward functions.\nmy_axon.attach(\n    forward_fn = forward_my_synapse,\n    verify_fn = verify_my_synapse,\n    blacklist_fn = blacklist_my_synapse,\n    priority_fn = prioritize_my_synapse\n)\n\n# Serve and start your axon.\nmy_axon.serve(\n    netuid = ...\n    subtensor = ...\n).start()\n\n# If you have multiple forwarding functions, you can chain attach them.\nmy_axon.attach(\n    forward_fn = forward_my_synapse,\n    verify_fn = verify_my_synapse,\n    blacklist_fn = blacklist_my_synapse,\n    priority_fn = prioritize_my_synapse\n).attach(\n    forward_fn = forward_my_synapse_2,\n    verify_fn = verify_my_synapse_2,\n    blacklist_fn = blacklist_my_synapse_2,\n    priority_fn = prioritize_my_synapse_2\n).serve(\n    netuid = ...\n    subtensor = ...\n).start()\n```\n\n----------------------------------------\n\nTITLE: Serving Axon to the Bittensor Network in Python\nDESCRIPTION: Asynchronous function that serves an axon to the network, enabling a neuron to accept requests. It configures the axon with networking parameters and submits the transaction to the Bittensor blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/serving/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def serve_axon_extrinsic(subtensor, netuid, axon, wait_for_inclusion = False, wait_for_finalization = True, certificate = None):\n    \"\"\"\n    Serves the axon to the network.\n\n    :param subtensor: Subtensor instance object.\n    :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n    :param netuid: The ``netuid`` being served on.\n    :type netuid: int\n    :param axon: Axon to serve.\n    :type axon: bittensor.core.axon.Axon\n    :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning ``True``, or\n                              returns ``False`` if the extrinsic fails to enter the block within the timeout.\n    :type wait_for_inclusion: bool\n    :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 ``True``, or returns ``False`` if the extrinsic fails to be finalized within the timeout.\n    :type wait_for_finalization: bool\n    :param certificate: Certificate to use for TLS. If ``None``, no TLS will be used.\n                       Defaults to ``None``.\n    :type certificate: bittensor.utils.Certificate\n\n    :returns:\n\n             Flag is ``True`` if extrinsic was finalized or included in the block. If we did not wait for\n                 finalization / inclusion, the response is ``True``.\n    :rtype: success (bool)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Neurons in a Subnet (Python)\nDESCRIPTION: Retrieves a list of all neurons within a specified subnet with detailed information about each neuron's attributes and network interactions. This provides a comprehensive view of the subnet's neuron population.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\ndef neurons(netuid, block = None):\n    \"\"\"\n    Retrieves a list of all neurons within a specified subnet of the Bittensor network.\n    This function provides a snapshot of the subnet's neuron population, including each neuron's attributes and\n        network interactions.\n\n    :param netuid: The unique identifier of the subnet.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: A list of NeuronInfo objects detailing each neuron's characteristics in the subnet.\n\n    Understanding the distribution and status of neurons within a subnet is key to comprehending the network's\n        decentralized structure and the dynamics of its consensus and governance processes.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying Neuron Identity in Bittensor (Python)\nDESCRIPTION: Queries the identity of a neuron on the Bittensor blockchain using a given key. This retrieves detailed identity information that is crucial for understanding the neuron's role in the network's decentralized identity system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\ndef query_identity(key, block = None):\n    \"\"\"\n    Queries the identity of a neuron on the Bittensor blockchain using the given key. This function retrieves\n        detailed identity information about a specific neuron, which is a crucial aspect of the network's\n        decentralized identity and governance system.\n\n    :param key: The key used to query the neuron's identity, typically the neuron's SS58 address.\n    :type key: str\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: An object containing the identity information of the neuron if found, ``None`` otherwise.\n\n    The identity information can include various attributes such as the neuron's stake, rank, and other\n        network-specific details, providing insights into the neuron's role and status within the Bittensor network.\n\n    .. note::\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Syncing Metagraph with Latest Block in Python\nDESCRIPTION: Synchronizes the metagraph with the latest block from the subtensor using the lite version for efficiency. This keeps the metagraph updated with current network state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\nsubtensor = Subtensor()\nmetagraph.sync(subtensor=subtensor)\n```\n\n----------------------------------------\n\nTITLE: Viewing Stakes List\nDESCRIPTION: Command to display currently held stakes across different validators and subnets, showing stake amounts, values, and computed swap rates.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_5\n\nLANGUAGE: console\nCODE:\n```\n                       Hotkey: 5GEXJdUXxLVmrkaHBfkFmoodXrCSUMFSgPXULbnrRicEt1kK\n                                            Network: test\n\n                             See below for an explanation of the columns\n\n        ┃           ┃     Value ┃           ┃    Price    ┃                  ┃            ┃  Emission\n Netuid ┃ Name      ┃ (α x τ/α) ┃ Stake (α) ┃ (τ_in/α_in) ┃    Swap (α -> τ) ┃ Registered ┃ (α/block)\n━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━━\n 250    │ ኤ unknown │   τ 18.38 │ 602.14 ኤ  │ 0.0305 τ/ኤ  │ τ 17.96 (2.287%) │        YES │  0.0000 ኤ\n 119    │ Ⲃ vidac   │   τ 13.72 │  98.73 Ⲃ  │ 0.1390 τ/Ⲃ  │ τ 13.61 (0.815%) │        YES │  0.0000 Ⲃ\n────────┼───────────┼───────────┼───────────┼─────────────┼──────────────────┼────────────┼───────────\n 2      │           │   τ 32.10 │           │             │          τ 31.57 │            │\n```\n\n----------------------------------------\n\nTITLE: Main Staking Execution in Python\nDESCRIPTION: This is the main function that orchestrates the entire staking process. It fetches subnet information, finds top validators, and initiates staking operations across multiple subnets concurrently using asynchronous programming.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    async with bt.async_subtensor(network='test') as subtensor: \n\n        print(\"Fetching information on top subnets by TAO emissions\")\n        \n        # get subnets and sort by tao emissions\n        sorted_subnets = sorted(list(await subtensor.all_subnets()), key=lambda subnet: subnet.tao_in_emission, reverse=True)\n        top_subnets = sorted_subnets[0:3]\n        amount_to_stake = bt.Balance.from_tao(total_to_stake/9)\n        \n        # find the top 3 validators in each subnet        \n        top_vali_dicts = await asyncio.gather(*[find_top_three_valis(subtensor, subnet) for subnet in top_subnets])\n        top_validators_per_subnet = {}\n        for d in top_vali_dicts:\n            netuid = d['netuid']\n            for v in d['validators']:\n                hk = v[0]\n                if netuid in top_validators_per_subnet:\n                    top_validators_per_subnet[netuid].append(hk)\n                else:\n                    top_validators_per_subnet[netuid] = [hk]\n\n        # Stake to each top 3 validators in each top 3 subnets\n        start_time = time.time()\n        await asyncio.gather(*[stake_batch(subtensor, netuid,top_validators, amount_to_stake) for netuid, top_validators in top_validators_per_subnet.items()])\n        print(f\"Staking completed in {time.time() - start_time:.2f}s\")\n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Information by Hotkey in Bittensor (Python)\nDESCRIPTION: This asynchronous method fetches detailed information about a delegate neuron using its hotkey address. Returns a DelegateInfo object containing the delegate's stakes, nominators, and reward distribution data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nget_delegate_by_hotkey(hotkey_ss58, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Listing Stake Accounts with btcli stake list\nDESCRIPTION: This command lists all stake accounts for a wallet. It supports options for specifying the network, wallet name, hotkey, and wallet path.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake list [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Displaying Subnet Exchange Rates\nDESCRIPTION: Python script demonstrating how to display exchange rates for a subnet's alpha token, with and without slippage considerations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\nsub = bt.Subtensor(network=\"test\")\nsubnet = sub.subnet(netuid=1)\n\nprint(\"alpha_to_tao_with_slippage\", subnet.alpha_to_tao_with_slippage(100))\nprint(\"alpha_to_tao_with_slippage percentage\", subnet.alpha_to_tao_with_slippage(100, percentage=True))\n\nprint(\"tao_to_alpha_with_slippage\", subnet.tao_to_alpha_with_slippage(100))\nprint(\"tao_to_alpha_with_slippage percentage\", subnet.tao_to_alpha_with_slippage(100, percentage=True))\n\nprint(\"tao_to_alpha\", subnet.tao_to_alpha(100))\nprint(\"alpha_to_tao\", subnet.alpha_to_tao(100))\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Nodes with BTCLI in Shell\nDESCRIPTION: This command shows detailed information about nodes in a specific subnet. It requires the subnet ID (netuid) as an argument and displays data such as stake, alpha, TAO, dividends, and other node-specific information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbtcli subnet show --netuid 119\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to Multiple Hotkeys in Bittensor (Python)\nDESCRIPTION: This asynchronous function adds stake to multiple hotkeys in the Bittensor network from a common coldkey. It supports staking different amounts to each hotkey and can wait for inclusion or finalization of the transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/staking/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def add_stake_multiple_extrinsic(subtensor, wallet, hotkey_ss58s, old_balance = None, amounts = None, wait_for_inclusion = True, wait_for_finalization = False):\n    \"\"\"\n    Adds stake to each ``hotkey_ss58`` in the list, using each amount, from a common coldkey.\n\n    :param subtensor: The initialized SubtensorInterface object.\n    :param wallet: Bittensor wallet object for the coldkey.\n    :param old_balance: The balance of the wallet prior to staking.\n    :param hotkey_ss58s: List of hotkeys to stake to.\n    :param amounts: List of amounts to stake. If `None`, stake all to the first hotkey.\n    :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns `False`\n                              if the extrinsic fails to enter the block within the timeout.\n    :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning `True`, or\n                                 returns `False` if the extrinsic fails to be finalized within the timeout.\n\n    :returns:\n             `True` if extrinsic was finalized or included in the block. `True` if any wallet was staked. If we did\n                 not wait for finalization/inclusion, the response is `True`.\n    :rtype: success\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Block Number from Bittensor Blockchain (Python)\nDESCRIPTION: This asynchronous method returns the current block number on the Bittensor blockchain. This represents the latest state of the blockchain and is essential for time-sensitive operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nget_current_block()\n```\n\n----------------------------------------\n\nTITLE: Viewing Bittensor Dashboard in CLI\nDESCRIPTION: This command displays the Bittensor dashboard, showing balances, stakes, and other blockchain information without requiring a private key.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/coldkey-hotkey-security.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbtcli view dashboard\n```\n\n----------------------------------------\n\nTITLE: Batch Unstaking from Multiple Hotkeys in Bittensor Network (Python)\nDESCRIPTION: An asynchronous method that performs batch unstaking from multiple hotkey accounts in the Bittensor network. It allows neurons to reduce their staked amounts across multiple accounts efficiently, supporting dynamic stake management.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_61\n\nLANGUAGE: python\nCODE:\n```\nasync def unstake_multiple(wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Scoring Mechanism for Miner Responses\nDESCRIPTION: Implementation of reward functions that calculate scores for miner responses based on text accuracy, position (bounding box overlap), font similarity, and response time. These functions determine how miners are rewarded.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Calculate the edit distance between two strings.\ndef get_text_reward(text1: str, text2: str = None):\n  ...\n# Calculate the intersection over union (IoU) of two bounding boxes.\ndef get_position_reward(boxA: List[float], boxB: List[float] = None):\n  ...\n# Calculate the distance between two fonts, based on the font size and font family.\ndef get_font_reward(font1: dict, font2: dict = None, alpha_size=1.0, alpha_family=1.0):\n  ...\n# Score a section of the image based on the section's correctness.\n# Correctness is defined as:\n# - the intersection over union of the bounding boxes,\n# - the delta between the predicted font and the ground truth font,\n# - and the edit distance between the predicted text and the ground truth text.\ndef section_reward(label: dict, pred: dict, alpha_p=1.0, alpha_f=1.0, alpha_t=1.0, verbose=False):\n  ...\n  reward = {\n        'text': get_text_reward(label['text'], pred.get('text')),\n        'position': get_position_reward(label['position'], pred.get('position')),\n        'font': get_font_reward(label['font'], pred.get('font')),\n    }\n\n    reward['total'] = (alpha_t * reward['text'] + alpha_p * reward['position'] + alpha_f * reward['font']) / (alpha_p + alpha_f + alpha_t)\n...\n# Reward the miner response.\ndef reward(image_data: List[dict], predictions: List[dict], time_elapsed: float) -> float:\n    time_reward = max(1 - time_elapsed / max_time, 0)\n    total_reward = (alpha_prediction * prediction_reward + alpha_time * time_reward) / (alpha_prediction + alpha_time)\n...\n```\n\n----------------------------------------\n\nTITLE: Viewing Wallet Transaction History in Bittensor CLI\nDESCRIPTION: This command displays the transaction history of a wallet on the Bittensor network, showing details like sender, receiver, amount, extrinsic ID, and block number for each transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_42\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet history\n```\n\n----------------------------------------\n\nTITLE: Checking Registration Status with SS58 Hotkey in Bittensor\nDESCRIPTION: Python script to check the registration status of a hotkey in Bittensor using the SS58 address.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nsub = bt.subtensor(network)\nprint(f\"Registration status for hotkey {hotkey} is: {sub.is_hotkey_registered(hotkey)}\")\n```\n\n----------------------------------------\n\nTITLE: Asynchronous PoW Registration Function in Python\nDESCRIPTION: Asynchronous function to register a wallet to the Bittensor chain using Proof-of-Work. Supports both CPU and CUDA-based mining with configurable parameters for performance optimization and progress monitoring.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/registration/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def register_extrinsic(subtensor, wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True, max_allowed_attempts = 3, output_in_place = True, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False)\n```\n\n----------------------------------------\n\nTITLE: Checking TAO Balance with Bittensor Python SDK\nDESCRIPTION: This snippet demonstrates how to check the TAO balance of a wallet using the Bittensor Python SDK. It connects to the test network, initializes a wallet, and retrieves the balance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(\n    name=\"PracticeKey!\",\n    hotkey=\"stakinkey1\",\n)\nwallet.unlock_coldkey()\nbalance = sub.get_balance(wallet.coldkey.ss58_address)\nprint(balance)\n```\n\n----------------------------------------\n\nTITLE: Setting Destination Address for TAO Transfer in JavaScript\nDESCRIPTION: This snippet demonstrates how to set the destination Ethereum address for a TAO token transfer. It requires the user to paste a valid Ethereum address.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/transfer-between-two-h160-accounts.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Enter your destination address here:\nconst destinationEthereumAddress = '0x2B5AD5c4795c026514f8317c7a215E218DcCD6cF';\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Burned Registration Function in Python\nDESCRIPTION: Asynchronous function to register a wallet to the Bittensor chain by recycling TAO tokens. Takes a subtensor instance, wallet, netuid and wait parameters to control transaction finalization behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/registration/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def burned_register_extrinsic(subtensor, wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Netuids for Hotkey in Bittensor\nDESCRIPTION: This method retrieves the subnet UIDs associated with a given hotkey's SS58 address. It returns a list of netuids for which the hotkey is a member, allowing identification of active subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_netuids_for_hotkey(hotkey_ss58, block = None)\n\n      Retrieves a list of subnet UIDs (netuids) for which a given hotkey is a member. This function identifies the\n          specific subnets within the Bittensor network where the neuron associated with the hotkey is active.\n\n      :param hotkey_ss58: The ``SS58`` address of the neuron's hotkey.\n      :type hotkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: A list of netuids where the neuron is a member.\n```\n\n----------------------------------------\n\nTITLE: Axon Server Registration Method Python Definition\nDESCRIPTION: Method to register an Axon serving endpoint on the Bittensor network for handling incoming queries and data processing tasks.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_61\n\nLANGUAGE: python\nCODE:\n```\ndef serve_axon(netuid, axon, wait_for_inclusion = False, wait_for_finalization = True, certificate = None)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Balance for a Coldkey Address in Bittensor (Python)\nDESCRIPTION: This asynchronous method fetches the balance for a given coldkey address on the Bittensor blockchain. Returns a Balance object containing the account's funds information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nget_balance(address, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Calculating Emission Distribution for Stakers in Bittensor\nDESCRIPTION: This LaTeX formula shows how to calculate the emission distribution for a specific staker based on their proportion of the total delegated stake to a validator.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/delegation.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\text{emission for staker x from validator V} = \n  \\frac\n  { stake_x }\n  { \\sum_{i \\in \\text{V's stakers}} \\bigl(stake_i) }\n```\n\n----------------------------------------\n\nTITLE: Enabling Consensus-based Weights Feature using btcli\nDESCRIPTION: Shows how to enable the consensus-based weights feature for a subnet using the btcli command-line interface.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set hyperparameters --netuid 1 --param liquid_alpha_enabled --value True\n```\n\n----------------------------------------\n\nTITLE: Implementing CUDA-based PoW Solver in Bittensor\nDESCRIPTION: A GPU-accelerated process that solves the registration Proof-of-Work challenge. It extends the base solver functionality with CUDA-specific implementations for better performance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nclass CUDASolver(proc_num, num_proc, update_interval, finished_queue, solution_queue, stopEvent, curr_block, curr_block_num, curr_diff, check_block, limit, dev_id, tpb):\n   \"\"\"A process that solves the registration PoW problem.\n\n   :param proc_num: The number of the process being created.\n   :type proc_num: int\n   :param num_proc: The total number of processes running.\n   :type num_proc: int\n   :param update_interval: The number of nonces to try to solve before checking for a new block.\n   :type update_interval: int\n   :param finished_queue: The queue to put the process number when a process finishes each\n                          update_interval. Used for calculating the average time per update_interval across all processes.\n   :type finished_queue: multiprocessing.Queue\n   :param solution_queue: The queue to put the solution the process has found during the pow solve.\n   :type solution_queue: multiprocessing.Queue\n   :param stopEvent: The event to set by the main process when all the solver processes should\n                     stop. The solver process will check for the event after each update_interval. The solver process will stop\n                     when the event is set. Used to stop the solver processes when a solution is found.\n   :type stopEvent: multiprocessing.Event\n   :param curr_block: The array containing this process's current block hash. The main process\n                      will set the array to the new block hash when a new block is finalized in the network. The solver process\n                      will get the new block hash from this array when newBlockEvent is set.\n   :type curr_block: multiprocessing.Array\n   :param curr_block_num: The value containing this process's current block number. The main\n                          process will set the value to the new block number when a new block is finalized in the network. The\n                          solver process will get the new block number from this value when newBlockEvent is set.\n   :type curr_block_num: multiprocessing.Value\n   :param curr_diff: The array containing this process's current difficulty. The main process will\n                     set the array to the new difficulty when a new block is finalized in the network. The solver process will\n                     get the new difficulty from this array when newBlockEvent is set.\n   :type curr_diff: multiprocessing.Array\n   :param check_block: The lock to prevent this process from getting the new block data while the\n                       main process is updating the data.\n   :type check_block: multiprocessing.Lock\n   :param limit: The limit of the pow solve for a valid solution.\n   :type limit: int\n   \"\"\"\n\n   dev_id: int\n   tpb: int\n\n   def run(self):\n      \"\"\"Method to be run in sub-process; can be overridden in sub-class\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Dendrite Session for HTTP Requests in Bittensor\nDESCRIPTION: An example of how to use the aiohttp.ClientSession from a Dendrite instance to make HTTP POST requests. This shows the proper async pattern for network communication within the Bittensor framework.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/dendrite/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor                                # Import bittensor\nwallet = bittensor.Wallet( ... )                # Initialize a wallet\ndendrite = bittensor.Dendrite(wallet=wallet)   # Initialize a dendrite instance with the wallet\n\nasync with (await dendrite.session).post(       # Use the session to make an HTTP POST request\n    url,                                        # URL to send the request to\n    headers={...},                              # Headers dict to be sent with the request\n    json={...},                                 # JSON body data to be sent with the request\n    timeout=10,                                 # Timeout duration in seconds\n) as response:\n    json_response = await response.json()       # Extract the JSON response from the server\n```\n\n----------------------------------------\n\nTITLE: Creating a Local Subnet in Bittensor\nDESCRIPTION: This command creates a new subnet on a local Bittensor chain. It requires the wallet name and the local chain endpoint. The cost is τ100.000000000 for the first subnet created.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create --wallet.name owner --subtensor.chain_endpoint ws://127.0.0.1:9946\n```\n\n----------------------------------------\n\nTITLE: Consensus-based Weights Formula\nDESCRIPTION: Mathematical formula showing how the exponential moving average bond value is computed for subnet validators, where alpha is now a variable determined by subnet consensus\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/chain-rel-notes.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\nB_{ij}^{(t)} = \\alpha\\cdot\\Delta B_{ij}^{(t)} + (1-\\alpha)\\cdot B_{ij}^{(t-1)}\n```\n\n----------------------------------------\n\nTITLE: Example of Setting Alpha Values in Bittensor Subnet\nDESCRIPTION: An example showing how to set alpha_low to 0.1 (integer 6554) and alpha_high to 0.8 (integer 52428) for subnet 1. The command uses the btcli sudo set hyperparameters command with specific parameter values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set hyperparameters --netuid 1 --param alpha_values --value 6554,52429\n```\n\n----------------------------------------\n\nTITLE: Verifying Bittensor Wallet SDK Installation\nDESCRIPTION: Python code to import the bittensor_wallet module and print its version to verify successful installation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor_wallet\nprint(bittensor_wallet.__version__)\n```\n\n----------------------------------------\n\nTITLE: Implementing Threaded FastAPI Server for Bittensor Axon (Python)\nDESCRIPTION: The FastAPIThreadedServer class extends uvicorn.Server to run a FastAPI application in a separate thread. It manages the server lifecycle, handles signals, and provides methods for starting and stopping the server.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass FastAPIThreadedServer(config):\n    Bases: uvicorn.Server\n\n    should_exit: bool = False\n    is_running: bool = False\n\n    def install_signal_handlers(self):\n        # Method implementation\n\n    def run_in_thread(self):\n        # Method implementation\n\n    def start(self):\n        # Method implementation\n\n    def stop(self):\n        # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Retrieving Lite Version of Neurons in a Subnet (Python)\nDESCRIPTION: Retrieves a streamlined list of neurons from a specific subnet, focusing on key attributes like stake and network participation. This provides an efficient overview of the subnet's neuron population.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\ndef neurons_lite(netuid, block = None):\n    \"\"\"\n    Retrieves a list of neurons in a 'lite' format from a specific subnet of the Bittensor network.\n    This function provides a streamlined view of the neurons, focusing on key attributes such as stake and network\n        participation.\n\n    :param netuid: The unique identifier of the subnet.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: A list of simplified neuron information for the subnet.\n\n    This function offers a quick overview of the neuron population within a subnet, facilitating efficient analysis\n        of the network's decentralized structure and neuron dynamics.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Alpha Token to TAO Exchange Rate\nDESCRIPTION: Python method for estimating the amount of TAO yielded by unstaking a given amount of Alpha tokens, ignoring slippage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nalpha_to_tao(self, alpha: Union[Balance, float, int]) -> Balance:\n```\n\n----------------------------------------\n\nTITLE: Transferring TAO Between Wallets\nDESCRIPTION: Demonstrates how to transfer 0.1 TAO from playground-test1 to playground-test2 using the destination address on the test network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet regen-coldkey \\\n--mnemonic \"add aerobic there stool organ switch about diagram arctic vague replace seminar\" \\\n--wallet.name 'playground-test1' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli wallet transfer \\\n--amount 0.1 \\\n--wallet.name 'playground-test1' \\\n--network test \\\n--destination \"5ESAWH9HDB9PZvs1q5j3aWF3x1wo88kwaqNcJEabGKsHMvX6\" \\\n--no-prompt \\\n--wallet.path ~/.bittensor/wallets\n```\n\n----------------------------------------\n\nTITLE: Creating Proof-of-Work for Registration in Bittensor\nDESCRIPTION: Function that creates a proof of work for a given subtensor and wallet. It supports both CPU and CUDA-based solving with configurable parameters for optimization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef create_pow(subtensor, wallet, netuid, output_in_place = True, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False):\n   \"\"\"Creates a proof of work for the given subtensor and wallet.\n\n   :param subtensor: The subtensor to create a proof of work for.\n   :type subtensor: bittensor.core.subtensor.Subtensor\n   :param wallet: The wallet to create a proof of work for.\n   :type wallet: bittensor_wallet.Wallet\n   :param netuid: The netuid for the subnet to create a proof of work for.\n   :type netuid: int\n   :param output_in_place: If true, prints the progress of the proof of work to the console in-place. Meaning the\n                           progress is printed on the same lines. Default is ``True``.\n   :type output_in_place: bool\n   :param cuda: If true, uses CUDA to solve the proof of work. Default is ``False``.\n   :type cuda: bool\n   :param dev_id: The CUDA device id(s) to use. If cuda is true and dev_id is a list, then\n                  multiple CUDA devices will be used to solve the proof of work. Default is ``0``.\n   :type dev_id: Union[List[int], int]\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor SDK with torch\nDESCRIPTION: Pip commands to install Bittensor SDK with PyTorch support, including an alternative command for environments where quotes are needed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\npip install bittensor[torch]\n```\n\nLANGUAGE: bash\nCODE:\n```\npip install \"bittensor[torch]\"\n```\n\n----------------------------------------\n\nTITLE: Querying AlphaDividendsPerSubnet in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the AlphaDividendsPerSubnet storage item for a specific network ID (netuid) and hotkey. It represents the last total alpha dividend for a hotkey on a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'AlphaDividendsPerSubnet', [netuid, hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Using Context Manager for Synchronous Subtensor Connection in Python\nDESCRIPTION: This example shows how to use a context manager (with statement) to automatically handle the closing of a synchronous Subtensor connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/sdk/managing-subtensor-connections.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nwith bt.subtensor(\"finney\") as sub:\n    # all calls to subtensor instance inside this block\n\n\n# instance and connection are terminated at the end of the context scope\n```\n\n----------------------------------------\n\nTITLE: Retrieving Metadata from Bittensor Blockchain in Python\nDESCRIPTION: Asynchronous function for fetching metadata from the blockchain for a specific hotkey and network UID. It allows specifying a specific block or block hash for historical queries.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/serving/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def get_metadata(subtensor, netuid, hotkey, block = None, block_hash = None, reuse_block = False):\n    \"\"\"\n    Fetches metadata from the blockchain for a given hotkey and netuid.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hotkey Owner in Bittensor\nDESCRIPTION: Fetches the coldkey owner (SS58 address) of a given hotkey at a specific blockchain block, establishing the ownership relationship between keys in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef get_hotkey_owner(hotkey_ss58, block = None):\n      Retrieves the owner of the given hotkey at a specific block hash.\n      This function queries the blockchain for the owner of the provided hotkey. If the hotkey does not exist at the\n          specified block hash, it returns None.\n\n      :param hotkey_ss58: The SS58 address of the hotkey.\n      :type hotkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The SS58 address of the owner if the hotkey exists, or None if it doesn't.\n      :rtype: Optional[str]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Take Percentage in Bittensor\nDESCRIPTION: Fetches the percentage of rewards that a delegate claims from its nominators' stakes, which is a critical parameter in the network's reward distribution mechanism.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef get_delegate_take(hotkey_ss58, block = None):\n      Retrieves the delegate 'take' percentage for a neuron identified by its hotkey. The 'take' represents the\n          percentage of rewards that the delegate claims from its nominators' stakes.\n\n      :param hotkey_ss58: The ``SS58`` address of the neuron's hotkey.\n      :type hotkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The delegate take percentage, None if not available.\n      :rtype: Optional[float]\n\n      The delegate take is a critical parameter in the network's incentive structure, influencing the distribution of\n          rewards among neurons and their nominators.\n```\n\n----------------------------------------\n\nTITLE: Setting Child Hotkeys in Bittensor CLI\nDESCRIPTION: Command to assign a proportion of the parent hotkey's stake weight to child hotkeys. Specifies the subnet ID, child hotkey addresses, proportions, parent hotkey, and wallet name.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake set_children --netuid <netuid> --children <a list of SS58 child hotkeys>  --proportions <a list of decimal numbers> --hotkey <parent hotkey> --wallet.name <coldkey>\n```\n\n----------------------------------------\n\nTITLE: Calculating Slippage in Bittensor Subnet Staking using LaTeX\nDESCRIPTION: This LaTeX formula calculates the slippage in a Bittensor subnet staking operation. It compares the expected yield without slippage to the actual yield with slippage to determine the magnitude of the slippage effect.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/staking-unstaking-dtao.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n16.667 = 50 - 33.333\n```\n\n----------------------------------------\n\nTITLE: Getting Total Stake for Hotkey\nDESCRIPTION: This method returns the total stake held on a hotkey using its SS58 address as input. It allows users to evaluate their financial activity associated with the hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_total_stake_for_hotkey(ss58_address, block = None)\n\n      Returns the total stake held on a hotkey.\n\n      :param ss58_address: The SS58 address of the hotkey\n      :type ss58_address: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance of the stake held on the hotkey.\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Neurons in Python\nDESCRIPTION: Async method to retrieve a complete list of neurons within a specified subnet, including their attributes and network interactions. Takes subnet ID and optional block parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nasync def neurons(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Wallet Status in Bittensor\nDESCRIPTION: Command to view the status of a wallet in Bittensor, including UID, stake, rank, trust, and other mining-related information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/index.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview --netuid\n```\n\n----------------------------------------\n\nTITLE: Configuring BTCLI Environment in Bash\nDESCRIPTION: Commands for configuring the BTCLI environment. These are permissionless operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli config set\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli config get\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Delegates on the Chain in Python\nDESCRIPTION: This asynchronous method fetches all delegates on the Bittensor chain. It returns a list of DelegateInfo objects, or an empty list if there are no delegates.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nasync def get_delegates(block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Calculating Transfer Fee\nDESCRIPTION: This method calculates the transaction fee for transferring tokens, using the wallet, destination address, and value of tokens. It estimates costs based on current network conditions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_transfer_fee(wallet, dest, value)\n\n      Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This\n          function simulates the transfer to estimate the associated cost, taking into account the current network\n          conditions and transaction complexity.\n\n      :param wallet: The wallet from which the transfer is initiated.\n      :type wallet: bittensor_wallet.Wallet\n      :param dest: The ``SS58`` address of the destination account.\n      :type dest: str\n      :param value: The amount of tokens to be transferred,\n                    specified as a Balance object, or in Tao (float) or Rao (int) units.\n      :type value: Union[bittensor.utils.balance.Balance, float, int]\n\n      :returns:\n\n                The estimated transaction fee for the transfer, represented as a Balance\n                    object.\n      :rtype: bittensor.utils.balance.Balance\n\n      Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet\n          has sufficient funds to cover both the transfer amount and the associated costs. This function provides a\n          crucial tool for managing financial operations within the Bittensor network.\n```\n\n----------------------------------------\n\nTITLE: Configuring Subnet Hyperparameters with BTCLI\nDESCRIPTION: Set subnet hyperparameters using the coldkey that created the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/subnet-creators-btcli-guide.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Delegates in Bittensor Network\nDESCRIPTION: Fetches information about all delegate neurons on the Bittensor blockchain at a specific block, returning a list of DelegateInfo objects containing comprehensive delegate data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef get_delegates(block = None):\n      Fetches all delegates on the chain\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: List of DelegateInfo objects, or an empty list if there are no delegates.\n```\n\n----------------------------------------\n\nTITLE: Initializing Axon Server in Bittensor Subnet Miner\nDESCRIPTION: This snippet shows how to create an Axon server instance for a subnet miner using the Bittensor API. The Axon server receives incoming Synapse objects from subnet validators.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/learn/bittensor-building-blocks.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\naxon = bt.axon(wallet=self.wallet, config=self.config)\n```\n\n----------------------------------------\n\nTITLE: Setting Root Weights on Bittensor Network\nDESCRIPTION: Function for setting weights on the Bittensor root network. It allows a wallet to assign weights to different subnets identified by their netuids. Includes parameters for version control and transaction confirmation behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/root/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nset_root_weights_extrinsic(subtensor, wallet, netuids, weights, version_key = 0, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Initializing Metagraph in Python\nDESCRIPTION: Example showing how to initialize a metagraph object with specific network parameters. The example demonstrates creating a metagraph instance with a network UID, network name, and configuration flags.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nmetagraph = Metagraph(netuid=123, network=\"finney\", lite=True, sync=True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving On-Chain Commitment for a Neuron in Bittensor (Python)\nDESCRIPTION: This asynchronous method fetches the on-chain commitment data for a specific neuron identified by its subnet UID and neuron UID. Returns the commitment as a string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nget_commitment(netuid, uid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Setting Multiple Child Hotkeys in Bittensor\nDESCRIPTION: Example command to set multiple child hotkeys, specifying the subnet ID, child hotkey addresses, proportions, parent hotkey, and wallet name.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake set_children \\\n  --netuid 4 \\\n  --children 5Gx1CZ9jviC6V2KynBAcTpES4yK76riCagv5o5SFFZFYXj4s,5HEXVAHY9gyavj5xnbov9Qoba4hPJYkkwwnq1MQFepLK7Gei \\\n  --proportions 0.3,0.7 \\\n  --hotkey 5DqJdDLU23m7yf6rZSmbLTshU7Bfn9eCTBkduhF4r9i73B9Y \\\n  --wallet.name Alice\n```\n\n----------------------------------------\n\nTITLE: Managing Child Stake using BTCLI in Bash\nDESCRIPTION: Commands for managing child stake, including getting, setting, revoking, and taking. These operations require a coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child ...\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake children ...\n```\n\n----------------------------------------\n\nTITLE: Simplified Alpha Reserve Injection Formula in Bittensor Network\nDESCRIPTION: This simplified formula for alpha injection cancels out the price variable, resulting in a calculation based on total TAO emission and the sum of all subnet token prices.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\Delta\\alpha_i = \n  \\frac\n    {\\Delta\\bar{\\tau}}\n    {\\sum_{j \\in \\mathbb{S}}\n  \\bigl(p_j)}\n$$\n```\n\n----------------------------------------\n\nTITLE: Moving Staked TAO between Subnets with btcli stake move\nDESCRIPTION: This command moves staked TAO from one subnet to another. It converts the origin subnet's dTao to Tao, then to the destination subnet's dTao. Required options include origin and destination netuids.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake move\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake move [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Metagraph in Python using Bittensor\nDESCRIPTION: This snippet shows various ways to create, sync, save, and load a Metagraph object. It includes examples for different network configurations and synchronization options.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\n# Creating metagraph and sync state from a netuid parameter, defaults to connecting to network `finney`\nmetagraph = bt.metagraph( netuid = 1 )\n\n# Create metagraph and sync with lite = False to sync weights and bonds matrices.\nmetagraph = bt.metagraph( netuid = 1, lite = False)\n\n# Create metagraph and sync state from local entrypoint, assuming a subtensor chain is currently running.\nmetagraph = bt.metagraph( netuid = 1, network = 'local' )\n\n# Create an empty metagraph object with no state syncing.\nmetagraph = bt.metagraph( netuid = 1, sync = False )\n\n# Sync the metagraph at a particular block\nmetagraph.sync( block = 100000 )\n\n# Save the metagraph to ~/.bittensor/metagraphs/network-$NETWORK_NAME/netuid-#NETUID/block-$BLOCK.pt\nmetagraph.save()\n\n# Load the latest metagraph by block.\nmetagraph.load()\n```\n\n----------------------------------------\n\nTITLE: Creating AxonInfo object from JSON string\nDESCRIPTION: A class method that creates an AxonInfo object from its JSON string representation, with error handling for JSON decoding, type, and value errors.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_string(json_string):\n    \"\"\"\n    Creates an `AxonInfo` object from its string representation using JSON.\n\n    :param json_string: The JSON string representation of the AxonInfo object.\n    :type json_string: str\n\n    :returns:\n              An instance of AxonInfo created from the JSON string. If decoding fails, returns a default\n                  `AxonInfo` object with default values.\n    :rtype: AxonInfo\n\n    :raises json.JSONDecodeError: If there is an error in decoding the JSON string.\n    :raises TypeError: If there is a type error when creating the AxonInfo object.\n    :raises ValueError: If there is a value error when creating the AxonInfo object.\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Processing Weights for Network UID in Python\nDESCRIPTION: Processes weight tensors for a given subnet id using the provided weight and UID arrays, applying constraints and normalization based on the subtensor and metagraph data. Handles both NumPy arrays and PyTorch tensors.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndef process_weights_for_netuid(uids, weights, netuid, subtensor, metagraph = None, exclude_quantile = 0):\n    \"\"\"Processes weight tensors for a given subnet id using the provided weight and UID arrays, applying constraints\n    and normalization based on the subtensor and metagraph data. This function can handle both NumPy arrays and PyTorch\n    tensors.\n\n    :param uids: Array of unique identifiers of the neurons.\n    :type uids: Union[NDArray[np.int64], \"torch.Tensor\"]\n    :param weights: Array of weights associated with the user IDs.\n    :type weights: Union[NDArray[np.float32], \"torch.Tensor\"]\n    :param netuid: The network uid to process weights for.\n    :type netuid: int\n    :param subtensor: Subtensor instance to access blockchain data.\n    :type subtensor: Subtensor\n    :param metagraph: Metagraph instance for additional network data. If None, it is fetched from\n                      the subtensor using the netuid.\n    :type metagraph: Optional[Metagraph]\n    :param exclude_quantile: Quantile threshold for excluding lower weights. Defaults to ``0``.\n    :type exclude_quantile: int\n\n    :returns:\n\n              tuple\n                  containing the array of user IDs and the corresponding normalized weights. The data type of the return\n                  matches the type of the input weights (NumPy or PyTorch).\n    :rtype: Union[tuple[\"torch.Tensor\", \"torch.FloatTensor\"], tuple[NDArray[np.int64], NDArray[np.float32]]]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Parameters in Python\nDESCRIPTION: Collection of async methods for retrieving subnet-related information from the Bittensor network, including burn costs, hyperparameters, and reveal periods. Methods accept block number and hash parameters for historical queries.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nasync def get_subnet_burn_cost(block = None, block_hash = None, reuse_block = False)\nasync def get_subnet_hyperparameters(netuid, block = None, block_hash = None, reuse_block = False)\nasync def get_subnet_reveal_period_epochs(netuid, block = None, block_hash = None)\nasync def get_subnets(block = None, block_hash = None, reuse_block = False)\nasync def get_total_subnets(block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Current Block Number in Bittensor\nDESCRIPTION: Fetches the current block number on the Bittensor blockchain, providing a reference point for the latest state of the network and facilitating time-sensitive operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef get_current_block():\n      Returns the current block number on the Bittensor blockchain. This function provides the latest block number,\n          indicating the most recent state of the blockchain.\n\n      :returns: The current chain block number.\n      :rtype: int\n\n      Knowing the current block number is essential for querying real-time data and performing time-sensitive\n          operations on the blockchain. It serves as a reference point for network activities and data\n          synchronization.\n```\n\n----------------------------------------\n\nTITLE: Creating a New Hotkey with Bittensor CLI\nDESCRIPTION: This command generates a new hotkey for managing a neuron or participating in a subnet. It allows customizing the mnemonic word count and offers optional password protection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_45\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new-hotkey --n_words 24\n```\n\n----------------------------------------\n\nTITLE: Global State Functions in Python\nDESCRIPTION: Functions to query global blockchain state including blocks, issuance, stake, and rate limits.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef block (self) -> int:\n\ntotal_issuance (self, block: Optional[int] = None ) -> 'bittensor.Balance'\n\ntotal_stake (self,block: Optional[int] = None ) -> 'bittensor.Balance'\n\nserving_rate_limit (self, block: Optional[int] = None ) -> Optional[int]\n\ntx_rate_limit (self, block: Optional[int] = None ) -> Optional[int]\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Fund Transfer in Bittensor Network (Python)\nDESCRIPTION: This function transfers funds from one wallet to another in the Bittensor network. It allows for transfer of a specific amount or all funds, with options to wait for inclusion or finalization of the transaction, and to keep the sender's account alive. It requires an initialized AsyncSubtensor object and a Bittensor wallet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/transfer/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def transfer_extrinsic(subtensor, wallet, dest, amount, transfer_all = False, wait_for_inclusion = True, wait_for_finalization = False, keep_alive = True):\n    \"\"\"\n    Transfers funds from this wallet to the destination public key address.\n\n    :param subtensor: initialized AsyncSubtensor object used for transfer\n    :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n    :param wallet: Bittensor wallet object to make transfer from.\n    :type wallet: bittensor_wallet.Wallet\n    :param dest: Destination public key address (ss58_address or ed25519) of recipient.\n    :type dest: str\n    :param amount: Amount to stake as Bittensor balance.\n    :type amount: bittensor.utils.balance.Balance\n    :param transfer_all: Whether to transfer all funds from this wallet to the destination address.\n    :type transfer_all: bool\n    :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                               `False` if the extrinsic fails to enter the block within the timeout.\n    :type wait_for_inclusion: bool\n    :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                  `True`, or returns `False` if the extrinsic fails to be finalized within the timeout.\n    :type wait_for_finalization: bool\n    :param keep_alive: If set, keeps the account alive by keeping the balance above the existential deposit.\n    :type keep_alive: bool\n\n    :returns:\n              Flag is `True` if extrinsic was finalized or included in the block. If we did not wait for\n                  finalization / inclusion, the response is `True`, regardless of its inclusion.\n    :rtype: success (bool)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Viewing Coldkey Public Information\nDESCRIPTION: Bash commands to display the public information of a coldkey, including the public address and other non-sensitive data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncd ~/.bittensor/wallets/test-coldkey\ncat coldkeypub.txt | jq\n```\n\n----------------------------------------\n\nTITLE: Subnet Existence Check Method Python Definition\nDESCRIPTION: Method to verify the existence of a subnet with a specified unique identifier within the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_65\n\nLANGUAGE: python\nCODE:\n```\ndef subnet_exists(netuid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Managing Stake using BTCLI in Bash\nDESCRIPTION: Commands for managing stake, including adding, removing, and moving stake. These operations require a coldkey and must be performed in a secure environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake add\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake remove\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli st add\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli st remove\n```\n\n----------------------------------------\n\nTITLE: Unlocking Wallet Keys\nDESCRIPTION: Function to decrypt a wallet's coldkey or hotkey. It attempts to unlock the specified key type and returns an UnlockStatus object containing success status and an error message if unsuccessful.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef unlock_key(wallet, unlock_type='coldkey'):\n   \"\"\"Attempts to decrypt a wallet's coldkey or hotkey\n   :param wallet: a Wallet object\n   :param unlock_type: the key type, 'coldkey' or 'hotkey'\n\n   Returns: UnlockStatus for success status of unlock, with error message if unsuccessful\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using AsyncSubtensor class in Bittensor SDK\nDESCRIPTION: Example usage of the experimental AsyncSubtensor class introduced in Bittensor SDK 8.3.0. This class is not yet ready for production use.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Example code for AsyncSubtensor\n# Note: This is experimental and not ready for production use\nfrom bittensor import AsyncSubtensor\n\nasync def example():\n    async_subtensor = AsyncSubtensor()\n    # Use async methods here\n```\n\n----------------------------------------\n\nTITLE: Querying Blockchain Constants in Python\nDESCRIPTION: Async method to retrieve constant values from specified blockchain modules. Used for accessing fixed network parameters and configuration values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nasync def query_constant(module_name, constant_name, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Children Neurons in Bittensor Network\nDESCRIPTION: Fetches the child neurons associated with a specific hotkey and subnet, returning formatted data about the parent-child relationship structure within the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef get_children(hotkey, netuid, block = None):\n      This method retrieves the children of a given hotkey and netuid. It queries the SubtensorModule's ChildKeys\n          storage function to get the children and formats them before returning as a tuple.\n\n      :param hotkey: The hotkey value.\n      :type hotkey: str\n      :param netuid: The netuid value.\n      :type netuid: int\n      :param block: The block number for which the children are to be retrieved.\n      :type block: Optional[int]\n\n      :returns:\n\n                A tuple containing a boolean indicating success or failure, a list of formatted children, and an error\n                    message (if applicable)\n```\n\n----------------------------------------\n\nTITLE: Delegating Stake in Bittensor\nDESCRIPTION: Method to add a specific amount of stake to a delegate using a wallet in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndelegate(self, wallet: 'bittensor.wallet', delegate_ss58: Optional[str] = None, amount: Union[Balance, float] = None, wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Converting Weights and UIDs for Emit in Python\nDESCRIPTION: Converts weights into integer u32 representation that sum to MAX_INT_WEIGHT. Takes UIDs and weights as input and returns UIDs and weight values as lists of integers.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef convert_weights_and_uids_for_emit(uids, weights):\n    \"\"\"Converts weights into integer u32 representation that sum to MAX_INT_WEIGHT.\n\n    :param uids: Tensor of uids as destinations for passed weights.\n    :type uids: np.int64\n    :param weights: Tensor of weights.\n    :type weights: np.float32\n\n    :returns: Uids as a list.\n              weight_vals (list[int]): Weights as a list.\n    :rtype: weight_uids (list[int])\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registering on a Subnet with Bittensor Python SDK\nDESCRIPTION: This snippet demonstrates how to register a hotkey on a subnet using the Bittensor Python SDK. It uses the 'burned_register' method, which is necessary for staking, mining, or validating on a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nlogging = bt.logging\nlogging.set_info()\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(\n    name=\"ExampleWalletName\",\n    hotkey=\"ExampleHotkey\",\n)\nwallet.unlock_coldkey()\nreg = sub.burned_register(wallet=wallet, netuid=3)\n```\n\n----------------------------------------\n\nTITLE: Encoding Parameters for Blockchain Calls in Python\nDESCRIPTION: Method that converts call parameters into a hex-encoded string based on their types for blockchain transaction preparation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef encode_params(call_definition, params):\n      Returns a hex encoded string of the params using their types.\n```\n\n----------------------------------------\n\nTITLE: Calculating TAO to Alpha Exchange with Slippage\nDESCRIPTION: Python method for estimating the amount of Alpha tokens received when staking TAO, considering slippage based on the current pool state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ntao_to_alpha_with_slippage(tao: Union[Balance, float, int], percentage: bool = False) -> Union[tuple[Balance, Balance], float]:\n```\n\n----------------------------------------\n\nTITLE: Enabling Consensus-based Weights Feature in Python\nDESCRIPTION: Sets the 'liquid_alpha_enabled' hyperparameter to enable the consensus-based weights feature for a specific subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nenabled_result = subtensor.set_hyperparameter(\nwallet=wallet,\nnetuid=<your_preferred_netuid>,\nparameter=\"liquid_alpha_enabled\",\nvalue=value,\nwait_for_inclusion=True,\nwait_for_finalization=True,\n)\nprint(enabled_result)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegation Information by Coldkey in Bittensor\nDESCRIPTION: Fetches a list of delegates that a specific account has staked tokens on, returning details about each delegation relationship and the amount staked on each delegate.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef get_delegated(coldkey_ss58, block = None):\n      Retrieves a list of delegates and their associated stakes for a given coldkey. This function identifies the\n      delegates that a specific account has staked tokens on.\n\n      :param coldkey_ss58: The `SS58` address of the account's coldkey.\n      :type coldkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: A list of tuples, each containing a delegate's information and staked amount.\n\n      This function is important for account holders to understand their stake allocations and their involvement in\n          the network's delegation and consensus mechanisms.\n```\n\n----------------------------------------\n\nTITLE: Checking Wallet Balance for a Specific Wallet\nDESCRIPTION: Command for checking the balance of a specific wallet using the wallet name parameter.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_31\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w balance --wallet-name WALLET\n```\n\n----------------------------------------\n\nTITLE: Implementing Tensor Class with Pydantic in Python\nDESCRIPTION: This class represents a Tensor object using Pydantic's BaseModel. It includes attributes for buffer, dtype, and shape, along with methods for serialization, deserialization, and conversion to different formats.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/tensor/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Tensor(/, **data):\n    Bases: :py:obj:`pydantic.BaseModel`\n\n    Represents a Tensor object.\n\n    :param buffer: Tensor buffer data.\n    :type buffer: Optional[str]\n    :param dtype: Tensor data type.\n    :type dtype: str\n    :param shape: Tensor shape.\n    :type shape: list[int]\n\n    Create a new model by parsing and validating input data from keyword arguments.\n\n    Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n    validated to form a valid model.\n\n    `self` is explicitly positional-only to allow `self` as a field name.\n\n\n    .. py:attribute:: buffer\n       :type:  Optional[str]\n       :value: None\n\n\n\n    .. py:method:: deserialize()\n\n       Deserializes the Tensor object.\n\n       :returns: The deserialized tensor object.\n       :rtype: np.array or torch.Tensor\n\n       :raises Exception: If the deserialization process encounters an error.\n\n\n\n    .. py:attribute:: dtype\n       :type:  str\n       :value: None\n\n\n\n    .. py:attribute:: model_config\n\n       Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n\n\n    .. py:method:: numpy()\n\n\n    .. py:method:: serialize(tensor_)\n       :staticmethod:\n\n\n       Serializes the given tensor.\n\n       :param tensor_: The tensor to serialize.\n       :type tensor_: np.array or torch.Tensor\n\n       :returns: The serialized tensor.\n       :rtype: :func:`Tensor`\n\n       :raises Exception: If the serialization process encounters an error.\n\n\n\n    .. py:attribute:: shape\n       :type:  list[int]\n       :value: None\n\n\n\n    .. py:method:: tensor()\n\n\n    .. py:method:: tolist()\n```\n\n----------------------------------------\n\nTITLE: Running EVM-enabled Bittensor Localnet\nDESCRIPTION: Commands to clone the Subtensor repository and run the localnet script for setting up an EVM-enabled Bittensor local network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/evm-localnet-with-metamask-wallet.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/subtensor\n./scripts/localnet.sh\n```\n\n----------------------------------------\n\nTITLE: Signing Messages with Bittensor Wallet CLI\nDESCRIPTION: This command allows users to sign a message using their Bittensor wallet or wallet hotkey. It's used to prove ownership of a coldkey or hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_51\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet sign [OPTIONS]\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet sign --wallet-name default --message '{\"something\": \"here\", \"timestamp\": 1719908486}'\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet sign --wallet-name default --wallet-hotkey hotkey --message '{\"something\": \"here\", \"timestamp\": 1719908486}'\n```\n\n----------------------------------------\n\nTITLE: Validating Chain Endpoints\nDESCRIPTION: Function to validate if a provided endpoint URL is a valid WebSocket URL for connecting to a Substrate chain. This ensures that connection attempts are made only to properly formatted endpoints.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef validate_chain_endpoint(endpoint_url):\n   \"\"\"Validates if the provided endpoint URL is a valid WebSocket URL.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Initializing Metagraph with Specific Parameters in Python\nDESCRIPTION: Demonstrates initializing a metagraph with specific network parameters like network UID and configuration. This detailed example shows options for lite mode and immediate synchronization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\n\nmetagraph = Metagraph(netuid=123, network=\"finney\", lite=True, sync=True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Neuron Information by UID in Bittensor (Python)\nDESCRIPTION: Retrieves detailed information about a specific neuron identified by its UID within a subnet. This function provides comprehensive data about a neuron's stake, rank, and operational status.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\ndef neuron_for_uid(uid, netuid, block = None):\n    \"\"\"\n    Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a\n        specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a\n        neuron's attributes, including its stake, rank, and operational status.\n\n    :param uid: The unique identifier of the neuron.\n    :type uid: int\n    :param netuid: The unique identifier of the subnet.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: Detailed information about the neuron if found, a null neuron otherwise\n\n    This function is crucial for analyzing individual neurons' contributions and status within a specific subnet,\n        offering insights into their roles in the network's consensus and validation mechanisms.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Syncing Metagraph with Specific Block in Python\nDESCRIPTION: Synchronizes the metagraph with a specific historical block for detailed analysis. This example shows how to access past network states for analysis purposes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\nsubtensor = Subtensor()\nmetagraph.sync(block=12345, lite=False, subtensor=subtensor)\n```\n\n----------------------------------------\n\nTITLE: Creating StorageKey from Storage Function Details in Python\nDESCRIPTION: This class method creates a StorageKey instance using storage function details. It requires pallet name, storage function name, runtime configuration, and metadata. Optional parameters can be provided for mapped storage functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/storage/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@classmethod\ndef create_from_storage_function(pallet, storage_function, params, runtime_config, metadata):\n    \"\"\"\n    Create a StorageKey instance providing storage function details\n\n    :param pallet: name of pallet\n    :param storage_function: name of storage function\n    :param params: Optional list of parameters in case of a Mapped storage function\n    :param runtime_config: RuntimeConfigurationObject\n    :param metadata: GenericMetadataVersioned\n\n    :returns: StorageKey\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying Map Storage in Python\nDESCRIPTION: Async method to query map storage from any blockchain module. Retrieves key-value data structures for accessing complex blockchain state information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nasync def query_map(module, name, block = None, block_hash = None, reuse_block = False, params = None)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnet Hyperparameters\nDESCRIPTION: This function retrieves hyperparameters for a specified subnet, which govern the operational behavior of the subnet within the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_subnet_hyperparameters(netuid, block = None)\n\n      Retrieves the hyperparameters for a specific subnet within the Bittensor network. These hyperparameters define\n          the operational settings and rules governing the subnet's behavior.\n\n      :param netuid: The network UID of the subnet to query.\n      :type netuid: int\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The subnet's hyperparameters, or `None` if not available.\n\n      Understanding the hyperparameters is crucial for comprehending how subnets are configured and managed, and how\n          they interact with the network's consensus and incentive mechanisms.\n```\n\n----------------------------------------\n\nTITLE: Querying Bonds in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the Bonds storage item for a specific network ID (netuid) and UID. It retrieves the bond values of UIDs in a network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nuid = 123\nresult = substrate.query('SubtensorModule', 'Bonds', [netuid, uid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Regenerating Coldkey in Bittensor CLI\nDESCRIPTION: Command to regenerate a coldkey from an existing mnemonic. This is used for recovery or security purposes, allowing users to recreate their coldkey using a mnemonic phrase.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_47\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-coldkey --mnemonic \"word1 word2 ... word12\"\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-coldkey [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Getting Child Hotkey Take with btcli stake child take\nDESCRIPTION: This command is used to get the current take value for a child hotkey on a specified subnet. The take value represents the percentage of rewards the child hotkey receives.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child take --hotkey <child_hotkey> --netuid 1\n```\n\n----------------------------------------\n\nTITLE: Sample Unstaking Script Output in Console\nDESCRIPTION: This console output shows the execution results of the unstaking script. It displays the wallet used, the validators selected for unstaking with their respective attributes (NetUID, Stake, Emission), the progress of each unstaking operation, and a final summary of successful operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_9\n\nLANGUAGE: console\nCODE:\n```\nUnstaking total not specified, defaulting to 1 TAO.\n🔍 Using wallet: PracticeKey!\n🧮 Unstaking a total of 1 TAO across up to 10 lowest-emission validators\n\n📊 Preparing to unstake from 10 validators:\n\nValidator: 5GEXJdUXxLVmrkaHBfkFmoodXrCSUMFSgPXULbnrRicEt1kK\n  NetUID: 119\n  Stake: 229.212349960Ⲃ\n  Emission: 0.000000000Ⲃ\n-----------\nValidator: 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT\n  NetUID: 119\n  Stake: 19.766958098Ⲃ\n  Emission: 0.000000000Ⲃ\n-----------\nValidator: 5FRxKzKrBDX3cCGqXFjYb6zCNC7GMTEaam1FWtsE8Nbr1EQJ\n  NetUID: 119\n  Stake: 18.475227001Ⲃ\n  Emission: 0.000000000Ⲃ\n-----------\nValidator: 5Gwz1AQmkya4UkiiXc9HASKYLc5dsQ9qzrgqCfSvjtbrbQp6\n  NetUID: 3\n  Stake: 44.463571197γ\n  Emission: 0.005925040γ\n-----------\nValidator: 5EscZNs55FCTfbpgFFDTbiSE7GgwSwqmdivfPikdqTyDiegb\n  NetUID: 3\n  Stake: 786.209456613γ\n  Emission: 0.102145233γ\n-----------\nValidator: 5GNyf1SotvL34mEx86C2cvEGJ563hYiPZWazXUueJ5uu16EK\n  NetUID: 277\n  Stake: 5.058595339इ\n  Emission: 4.550549887इ\n-----------\nValidator: 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT\n  NetUID: 3\n  Stake: 11.654577962γ\n  Emission: 5.429011017γ\n-----------\nValidator: 5EFtEvPcgZHheW36jGXMPMrDETzbngziR3DPPVVp5L5Gt7Wo\n  NetUID: 277\n  Stake: 5.258687558इ\n  Emission: 11.038508585इ\n-----------\nValidator: 5CFZ9xDaFQVLA9ERsTs9S3i6jp1VDydvjQH5RDsyWCCJkTM4\n  NetUID: 119\n  Stake: 20.942357630Ⲃ\n  Emission: 16.662837489Ⲃ\n-----------\nValidator: 5FupG35rCCMghVEAzdYuxxb4SWHU7HtpKeveDmSoyCN8vHyb\n  NetUID: 3\n  Stake: 87.243220111γ\n  Emission: 22.063085545γ\n-----------\n⏳ Attempting to unstake τ0.100000000 from 5GEXJdUXxLVmrkaHBfkFmoodXrCSUMFSgPXULbnrRicEt1kK on subnet 119\nEnter your password:\nDecrypting...\n⏳ Attempting to unstake τ0.100000000 from 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT on subnet 119\n⏳ Attempting to unstake τ0.100000000 from 5FRxKzKrBDX3cCGqXFjYb6zCNC7GMTEaam1FWtsE8Nbr1EQJ on subnet 119\n⏳ Attempting to unstake τ0.100000000 from 5Gwz1AQmkya4UkiiXc9HASKYLc5dsQ9qzrgqCfSvjtbrbQp6 on subnet 3\n⏳ Attempting to unstake τ0.100000000 from 5EscZNs55FCTfbpgFFDTbiSE7GgwSwqmdivfPikdqTyDiegb on subnet 3\n⏳ Attempting to unstake τ0.100000000 from 5GNyf1SotvL34mEx86C2cvEGJ563hYiPZWazXUueJ5uu16EK on subnet 277\n⏳ Attempting to unstake τ0.100000000 from 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT on subnet 3\n⏳ Attempting to unstake τ0.100000000 from 5EFtEvPcgZHheW36jGXMPMrDETzbngziR3DPPVVp5L5Gt7Wo on subnet 277\n⏳ Attempting to unstake τ0.100000000 from 5CFZ9xDaFQVLA9ERsTs9S3i6jp1VDydvjQH5RDsyWCCJkTM4 on subnet 119\n⏳ Attempting to unstake τ0.100000000 from 5FupG35rCCMghVEAzdYuxxb4SWHU7HtpKeveDmSoyCN8vHyb on subnet 3\n✅ Successfully unstaked 0.100000000इ from 5Gwz1AQmkya4UkiiXc9HASKYLc5dsQ9qzrgqCfSvjtbrbQp6 on subnet 3 in 10.78s\n✅ Successfully unstaked 0.100000000इ from 5FRxKzKrBDX3cCGqXFjYb6zCNC7GMTEaam1FWtsE8Nbr1EQJ on subnet 119 in 10.78s\n✅ Successfully unstaked 0.100000000इ from 5GEXJdUXxLVmrkaHBfkFmoodXrCSUMFSgPXULbnrRicEt1kK on subnet 119 in 15.23s\n✅ Successfully unstaked 0.100000000इ from 5FupG35rCCMghVEAzdYuxxb4SWHU7HtpKeveDmSoyCN8vHyb on subnet 3 in 10.78s\n✅ Successfully unstaked 0.100000000इ from 5EFtEvPcgZHheW36jGXMPMrDETzbngziR3DPPVVp5L5Gt7Wo on subnet 277 in 10.79s\n✅ Successfully unstaked 0.100000000इ from 5EscZNs55FCTfbpgFFDTbiSE7GgwSwqmdivfPikdqTyDiegb on subnet 3 in 10.79s\n✅ Successfully unstaked 0.100000000इ from 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT on subnet 3 in 10.83s\n✅ Successfully unstaked 0.100000000इ from 5FCPTnjevGqAuTttetBy4a24Ej3pH9fiQ8fmvP1ZkrVsLUoT on subnet 119 in 10.83s\n✅ Successfully unstaked 0.100000000इ from 5GNyf1SotvL34mEx86C2cvEGJ563hYiPZWazXUueJ5uu16EK on subnet 277 in 10.84s\n✅ Successfully unstaked 0.100000000इ from 5CFZ9xDaFQVLA9ERsTs9S3i6jp1VDydvjQH5RDsyWCCJkTM4 on subnet 119 in 10.89s\n\n🎯 Unstake complete. Success: 10/10\n```\n\n----------------------------------------\n\nTITLE: Network Tempo Query Method Python Definition\nDESCRIPTION: Method to retrieve the Tempo hyperparameter for a specified subnet in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_67\n\nLANGUAGE: python\nCODE:\n```\ndef tempo(netuid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Checking Validator Permit Status in Bittensor\nDESCRIPTION: Python script to check the validator permit status for a specific wallet and hotkey in a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph(1)\nwallet = bt.wallet( name = 'my_coldkey', hotkey = 'my_validator_hotkey' )\nmy_uid = subnet.hotkeys.index( wallet.hotkey.ss58_address )\nprint(f'Validator permit: {subnet.validator_permit(my_uid)}')\n```\n\n----------------------------------------\n\nTITLE: Retrieving Stake Information for Coldkey and Hotkey in Python\nDESCRIPTION: This asynchronous method retrieves stake information associated with a specific coldkey and hotkey combination in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nasync def get_stake_for_coldkey_and_hotkey(hotkey_ss58, coldkey_ss58, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Checking Miner Registration Status with UID and SS58 Hotkey\nDESCRIPTION: Python script to check the registration status of a miner using its UID and SS58 hotkey. It uses the Bittensor library and metagraph to verify if the miner is registered at the specified UID.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/index.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n# Replace below with your SS58 hotkey \nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nnetuid = 1 # subnet uid\nsub = bt.subtensor(network)\nmg = sub.metagraph(netuid)\nuid = 2 # Your UID\nregistered = mg.hotkeys[uid] == hotkey\nif not registered:\n  print(f\"Miner at uid {uid} not registered\")\nelse:\n  print(f\"Miner at uid {uid} registered\")\n```\n\n----------------------------------------\n\nTITLE: Initializing Subtensor Connections in Python\nDESCRIPTION: Examples of creating Subtensor instances with different configurations, including default chain connection, parsing from command line, connecting to local entrypoint, and connecting to a specific endpoint.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Creating a default chain connection to remote finney instance.\nsub = bt.subtensor()\n\n# Parsing --subtensor.network and --subtensor.chain_endpoint from the command line\nsub = bt.subtensor( config = bt.subtensor.config() )\n\n# Connecting subtensor's default local entrypoint \"ws://127.0.0.1:9944\"\nsub = bt.subtensor( network = 'local' )\n\n# Connecting to a specific endpoint\nsub = bt.subtensor( chain_endpoint = \"ws://127.0.0.1:9944\" )\n```\n\n----------------------------------------\n\nTITLE: Checking Weight Set Rate Limit in Bittensor Network (Python)\nDESCRIPTION: Method that returns the WeightsSetRateLimit hyperparameter for a specified subnet. Takes parameters for subnet ID and optional block number. Returns the rate limit value or None if the subnet doesn't exist or the parameter isn't found.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_73\n\nLANGUAGE: python\nCODE:\n```\ndef weights_rate_limit(netuid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Creating a Hotkey with btcli\nDESCRIPTION: Command to generate a new hotkey associated with an existing coldkey using btcli. This is necessary for users who plan to validate or mine in a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new_hotkey --wallet.name <my_coldkey> --wallet.hotkey <my_hotkey>\n```\n\n----------------------------------------\n\nTITLE: Adding Stakes using btcli\nDESCRIPTION: Command for staking TAO to a validator on a subnet. Shows interactive process of selecting subnet, validator and amount to stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbtcli stake add\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnet Metagraph\nDESCRIPTION: Python function signature for fetching the metagraph for a specified subnet netuid, including detailed data on the neurons in the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nmetagraph(\n    netuid: int, \n    block: Optional[int] = None\n) -> bittensor.Metagraph\n```\n\n----------------------------------------\n\nTITLE: Viewing Wallet Balance with btcli\nDESCRIPTION: This command displays the balance of a Bittensor wallet. It can be run on a permissionless workstation as it only requires public key information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet balance\n```\n\n----------------------------------------\n\nTITLE: Viewing Registered Subnets with Bittensor Python SDK\nDESCRIPTION: This code snippet shows how to view the subnets on which a hotkey is registered using the Bittensor Python SDK. It retrieves and prints the network UIDs (netuids) associated with the hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\nwallet = bt.wallet(\n    name=\"ExampleWalletName\",\n    hotkey=\"ExampleHotkey\",\n)\nwallet.unlock_coldkey()\nnetuids = sub.get_netuids_for_hotkey(wallet.hotkey.ss58_address)\nprint(netuids)\n```\n\n----------------------------------------\n\nTITLE: Encrypting a Hotkey with btcli\nDESCRIPTION: Command to create a new encrypted hotkey using btcli, enhancing security by requiring a password for access.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new_hotkey --use-password\n```\n\n----------------------------------------\n\nTITLE: Recycling TAO in Subnet\nDESCRIPTION: Asynchronous method to retrieve the 'Burn' hyperparameter for a specified subnet, representing the amount of TAO recycled within the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nasync def recycle(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to a Subnet\nDESCRIPTION: Python function signature for staking an amount of TAO to a specific subnet under a provided hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nasync add_stake(\n    wallet, \n    hotkey: str, \n    netuid: int, \n    tao_amount: Union[float, bittensor.Balance, int]\n)\n```\n\n----------------------------------------\n\nTITLE: Defining NeuronInfoLite Class in Python\nDESCRIPTION: This class represents neuron metadata without weights and bonds. It includes various attributes such as hotkey, coldkey, uid, netuid, active status, stake, rank, emission, incentive, consensus, trust, and more. It also provides methods for creating null neurons and decoding byte data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_info_lite/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass NeuronInfoLite:\n    hotkey: str\n    coldkey: str\n    uid: int\n    netuid: int\n    active: int\n    stake: Balance\n    stake_dict: dict\n    total_stake: Balance\n    rank: float\n    emission: float\n    incentive: float\n    consensus: float\n    trust: float\n    validator_trust: float\n    dividends: float\n    last_update: int\n    validator_permit: bool\n    prometheus_info: Optional[PrometheusInfo]\n    axon_info: Optional[AxonInfo]\n    pruning_score: int\n    is_null: bool = False\n\n    @staticmethod\n    def get_null_neuron():\n        # Returns a null NeuronInfoLite instance\n\n    @classmethod\n    def list_from_vec_u8(cls, vec_u8: bytes) -> list[NeuronInfoLite]:\n        # Decodes a bytes object into a list of NeuronInfoLite instances\n```\n\n----------------------------------------\n\nTITLE: Blake2 128-bit Hash Function for Substrate Storage Keys\nDESCRIPTION: Helper function that calculates a 16-byte Blake2b hash for the provided data. This hash is used as a key for Substrate storage items in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef blake2_128(data)\n```\n\n----------------------------------------\n\nTITLE: Setting Weights on Bittensor Blockchain\nDESCRIPTION: Async function that sets weights and values on the blockchain for a wallet's hotkey account. It processes lists of UIDs and corresponding weights with options to control transaction finality behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/weights/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def set_weights_extrinsic(subtensor, wallet, netuid, uids, weights, version_key = 0, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Querying Burn in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the Burn storage item for a specific network ID (netuid). It retrieves the burn value for a given network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'Burn', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Getting Child Hotkey Take Rate with Bittensor CLI\nDESCRIPTION: This command displays the take percentage of a given child hotkey for a specific network UID. It requires specifying the network UID, child hotkey, and wallet name.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake get_childkey_take \\\n  --netuid <netuid> \\\n  --hotkey <child hotkey> \\\n  --wallet.name <coldkey>\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake get_childkey_take \\\n  --netuid 4 \\\n  --hotkey 5Gx1CZ9jviC6V2KynBAcTpES4yK76riCagv5o5SFFZFYXj4s \\\n  --wallet.name Bob\n```\n\n----------------------------------------\n\nTITLE: Checking Network-wide Hotkey Registration in Bittensor (Python)\nDESCRIPTION: Checks if a neuron's hotkey is registered on any subnet within the Bittensor network. This function is essential for determining the network-wide presence and participation of a neuron.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\ndef is_hotkey_registered_any(hotkey_ss58, block = None):\n    \"\"\"\n    Checks if a neuron's hotkey is registered on any subnet within the Bittensor network.\n\n    :param hotkey_ss58: The ``SS58`` address of the neuron's hotkey.\n    :type hotkey_ss58: str\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: ``True`` if the hotkey is registered on any subnet, False otherwise.\n    :rtype: bool\n\n    This function is essential for determining the network-wide presence and participation of a neuron.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying Validator Trust Values in Bittensor Network with Python\nDESCRIPTION: This example shows how to query the validator trust values of UIDs in a specific Bittensor subnet. It connects to the Finney test network and retrieves a vector of trust values specifically for validators in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ValidatorTrust', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Executing Senate and Proposal Commands with BTCLI\nDESCRIPTION: These commands are used by senators to interact with the governance system, including managing the senate, handling proposals, and casting votes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/governance/senators-btcli-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo senate\nbtcli sudo proposals\nbtcli sudo senate-vote\nbtcli sudo senate_vote\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnetwork N Hyperparameter in Bittensor (Python)\nDESCRIPTION: This asynchronous method returns the SubnetworkN hyperparameter for a specified subnet. It can query this information at a specific blockchain block (by number or hash) and returns the integer value or None if the subnetwork doesn't exist or the parameter is not found.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nsubnetwork_n(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Multiple Hotkey Unstaking Extrinsic in Bittensor (Python)\nDESCRIPTION: Asynchronous function to remove stake from multiple hotkeys simultaneously to a common coldkey. Supports batch unstaking operations with different amounts for each hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/unstaking/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def unstake_multiple_extrinsic(subtensor, wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False):\n   \"\"\"\n   Removes stake from each ``hotkey_ss58`` in the list, using each amount, to a common coldkey.\n\n   :param subtensor: Subtensor instance.\n   :type subtensor: bittensor.core.subtensor.Subtensor\n   :param wallet: The wallet with the coldkey to unstake to.\n   :type wallet: bittensor_wallet.Wallet\n   :param hotkey_ss58s: List of hotkeys to unstake from.\n   :type hotkey_ss58s: List[str]\n   :param amounts: List of amounts to unstake. If ``None``, unstake all.\n   :type amounts: List[Union[Balance, float]]\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning ``True``, or\n                              returns ``False`` if the extrinsic fails to enter the block within the timeout.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 ``True``, or returns ``False`` if the extrinsic fails to be finalized within the timeout.\n   :type wait_for_finalization: bool\n\n   :returns:\n\n             Flag is ``True`` if extrinsic was finalized or included in the block. Flag is ``True`` if any\n                 wallet was unstaked. If we did not wait for finalization / inclusion, the response is ``True``.\n   :rtype: success (bool)\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Attaching Custom Functions to Axon Server in Python\nDESCRIPTION: Demonstrates how to attach custom forward, blacklist, priority, and verify functions to an Axon instance. These functions define how the Axon processes and validates incoming requests.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef forward_custom(synapse: MyCustomSynapse) -> MyCustomSynapse:\n    # Custom logic for processing the request\n    return synapse\n\ndef blacklist_custom(synapse: MyCustomSynapse) -> tuple[bool, str]:\n    return True, \"Allowed!\"\n\ndef priority_custom(synapse: MyCustomSynapse) -> float:\n    return 1.0\n\ndef verify_custom(synapse: MyCustomSynapse):\n    # Custom logic for verifying the request\n    pass\n\nmy_axon = bittensor.Axon(...)\nmy_axon.attach(forward_fn=forward_custom, verify_fn=verify_custom)\n```\n\n----------------------------------------\n\nTITLE: Displaying Wallet Overview in Bittensor CLI\nDESCRIPTION: Commands to view wallet overview information with various filtering and sorting options. These are read-only commands that provide a comprehensive view of a user's network presence on the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_46\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview --all --sort-by stake --sort-order descending\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview -in hk1,hk2 --sort-by stake\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Registering Neuron on Bittensor Network\nDESCRIPTION: Asynchronous method to register a neuron on the Bittensor network using a provided wallet. Handles the registration process including proof of work and CUDA support.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_46\n\nLANGUAGE: python\nCODE:\n```\nasync def register(wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True, max_allowed_attempts = 3, output_in_place = False, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False)\n```\n\n----------------------------------------\n\nTITLE: Staking Precompile ABI in JSON\nDESCRIPTION: ABI (Application Binary Interface) for the staking precompile contract, defining the addStake and removeStake functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/staking-precompile.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"hotkey\",\n                \"type\": \"bytes32\"\n            }\n        ],\n        \"name\": \"addStake\",\n        \"outputs\": [],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    },\n    {\n        \"inputs\": [\n            {\n                \"internalType\": \"bytes32\",\n                \"name\": \"hotkey\",\n                \"type\": \"bytes32\"\n            },\n            {\n                \"internalType\": \"uint256\",\n                \"name\": \"amount\",\n                \"type\": \"uint256\"\n            }\n        ],\n        \"name\": \"removeStake\",\n        \"outputs\": [],\n        \"stateMutability\": \"payable\",\n        \"type\": \"function\"\n    }\n]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Account Balance in Bittensor\nDESCRIPTION: Fetches the TAO balance for a given coldkey address at a specific blockchain block, returning a Balance object that contains the account's financial information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef get_balance(address, block = None):\n      Retrieves the balance for given coldkey.\n\n      :param address: coldkey address.\n      :type address: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance object.\n```\n\n----------------------------------------\n\nTITLE: Revealing Weights on Bittensor Chain\nDESCRIPTION: Asynchronous method to reveal previously committed weight distributions for a specific subnet using the provided wallet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nasync def reveal_weights(wallet, netuid, uids, weights, salt, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False, max_retries = 5)\n```\n\n----------------------------------------\n\nTITLE: Viewing TAO Balance with BTCLI in Shell\nDESCRIPTION: This command displays the balance of TAO tokens in your wallet. It shows free balance, staked balance, and total balance for each wallet associated with your account.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet balance\n```\n\n----------------------------------------\n\nTITLE: Checking if a Hotkey is a Delegate in Bittensor (Python)\nDESCRIPTION: Determines whether a given hotkey is a delegate on the Bittensor network by checking if the associated neuron is part of the network's delegation system. Delegates have special status in consensus and governance processes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\ndef is_hotkey_delegate(hotkey_ss58, block = None):\n    \"\"\"\n    Determines whether a given hotkey (public key) is a delegate on the Bittensor network. This function checks if\n        the neuron associated with the hotkey is part of the network's delegation system.\n\n    :param hotkey_ss58: The SS58 address of the neuron's hotkey.\n    :type hotkey_ss58: str\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: `True` if the hotkey is a delegate, `False` otherwise.\n\n    Being a delegate is a significant status within the Bittensor network, indicating a neuron's involvement in\n        consensus and governance processes.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Balance Objects from Rao Units in Python\nDESCRIPTION: Static method that creates a Balance object from an integer amount in rao units. Rao is the smallest unit in the Bittensor network, while tao is derived by dividing rao by 10^9.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/balance/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef from_rao(amount):\n  :staticmethod:\n\n\n  Given rao, return Balance object with rao(``int``) and tao(``float``), where rao = int(tao*pow(10,9))\n\n  :param amount: The amount in rao.\n  :type amount: int\n\n  :returns: A Balance object representing the given amount.\n```\n\n----------------------------------------\n\nTITLE: Getting Total Stake for Multiple Hotkeys\nDESCRIPTION: This function aggregates and returns the total stake held on multiple hotkeys, identified by their SS58 addresses. It provides a collective financial overview for the hotkeys involved.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_total_stake_for_hotkeys(*ss58_addresses, block = None)\n\n      Returns the total stake held on hotkeys.\n\n      :param ss58_addresses: The SS58 address(es) of the hotkey(s)\n      :type ss58_addresses: tuple[str]\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance objects}.  \n      :rtype: Dict {address\n```\n\n----------------------------------------\n\nTITLE: Fetching Subnet Hyperparameter in Python\nDESCRIPTION: This asynchronous method retrieves a specified hyperparameter for a specific subnet. It returns the value of the specified hyperparameter if the subnet exists, or None.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nasync def get_hyperparameter(param_name, netuid, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Registering a Miner in Bittensor Subnet\nDESCRIPTION: Command to register a miner in a specific Bittensor subnet using btcli. It requires specifying the subnet ID (netuid), coldkey name, and hotkey name.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/index.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet register --netuid <your_preferred_netuid>  --wallet.name  <my_coldkey> --wallet.hotkey <my_hotkey>\n```\n\n----------------------------------------\n\nTITLE: Retrieving Existential Deposit in Bittensor\nDESCRIPTION: Fetches the minimum amount of TAO required for an account to exist on the blockchain (existential deposit), which prevents dust accounts and ensures efficient use of network resources.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef get_existential_deposit(block = None):\n      Retrieves the existential deposit amount for the Bittensor blockchain.\n      The existential deposit is the minimum amount of TAO required for an account to exist on the blockchain.\n      Accounts with balances below this threshold can be reaped to conserve network resources.\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The existential deposit amount.\n\n      The existential deposit is a fundamental economic parameter in the Bittensor network, ensuring efficient use of\n          storage and preventing the proliferation of dust accounts.\n```\n\n----------------------------------------\n\nTITLE: Neuron Information Functions in Python\nDESCRIPTION: Functions for querying neuron registration status and identifiers across subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nis_hotkey_registered_any( self, hotkey_ss58: str, block: Optional[int] = None) -> bool\n\nis_hotkey_registered_on_subnet( self, hotkey_ss58: str, netuid: int, block: Optional[int] = None) -> bool\n\nis_hotkey_registered( self, hotkey_ss58: str, netuid: int, block: Optional[int] = None) -> bool\n\nget_uid_for_hotkey_on_subnet( self, hotkey_ss58: str, netuid: int, block: Optional[int] = None) -> int\n\nget_all_uids_for_hotkey( self, hotkey_ss58: str, block: Optional[int] = None) -> List[int]\n\nget_netuids_for_hotkey( self, hotkey_ss58: str, block: Optional[int] = None) -> List[int]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnet Burn Cost\nDESCRIPTION: This method retrieves the burn cost for registering a new subnet, which reflects the economic model of the Bittensor network. It returns the amount of Tao required for the registration process.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_subnet_burn_cost(block = None)\n\n      Retrieves the burn cost for registering a new subnet within the Bittensor network. This cost represents the\n          amount of Tao that needs to be locked or burned to establish a new subnet.\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The burn cost for subnet registration.\n      :rtype: int\n\n      The subnet burn cost is an important economic parameter, reflecting the network's mechanisms for controlling\n          the proliferation of subnets and ensuring their commitment to the network's long-term viability.\n```\n\n----------------------------------------\n\nTITLE: Delegation Functions in Python\nDESCRIPTION: Functions for managing delegation including delegate validation, rewards, and nominator information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nis_hotkey_delegate( self, hotkey_ss58: str ) -> bool\n\nget_delegate_take( self, hotkey_ss58: str, block: Optional[int] = None ) -> Optional[float]\n\nget_nominators_for_hotkey( self, hotkey_ss58: str, block: Optional[int] = None ) -> List[Tuple[str, Balance]]\n\nget_delegate_by_hotkey( self, hotkey_ss58: str, block: Optional[int] = None ) -> Optional[DelegateInfo]\n\nget_delegates( self, block: Optional[int] = None ) -> List[DelegateInfo]\n\nget_delegated( self, coldkey_ss58: str, block: Optional[int] = None ) -> List[Tuple[DelegateInfo, Balance]]\n```\n\n----------------------------------------\n\nTITLE: Setting Alpha Values for Consensus-based Weights in Python\nDESCRIPTION: Sets the 'alpha_values' hyperparameter to define the lower and upper bounds for alpha in the consensus-based weights calculation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nalpha_low_high_result = subtensor.set_hyperparameter(\nwallet=wallet,\nnetuid=<your_preferred_netuid>,\nparameter=\"alpha_values\",\nvalue=[], # decimal 0.1 for alpha_low and 0.8 for alpha_high\nwait_for_inclusion=True,\nwait_for_finalization=True,\n)\nprint(alpha_low_high_result)\n```\n\n----------------------------------------\n\nTITLE: Unstaking from a Subnet\nDESCRIPTION: Python function signature for unstaking an amount of TAO from a specified hotkey on a given subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nunstake(\n    wallet, \n    hotkey: str, \n    netuid: int, \n    amount: Union[float, bittensor.Balance, int]\n)\n```\n\n----------------------------------------\n\nTITLE: Listing Wallet Stakes\nDESCRIPTION: Shows how to list all stakes associated with playground-test1 wallet on the test network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet regen-coldkey \\\n--mnemonic \"add aerobic there stool organ switch about diagram arctic vague replace seminar\" \\\n--wallet.name 'playground-test1' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli stake list --network test --wallet.name playground-test1 --wallet-path ~/.bittensor/wallets --no-prompt\n```\n\n----------------------------------------\n\nTITLE: Checking Balance for Specific SS58 Addresses\nDESCRIPTION: Command for checking balances of specific SS58 addresses using the --ss58 parameter.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_34\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w balance --ss58 <ss58_address> --ss58 <ss58_address>\n```\n\n----------------------------------------\n\nTITLE: Implementing CPU-based PoW Solver in Bittensor\nDESCRIPTION: A process-based solver that attempts to solve the registration Proof-of-Work problem using CPU. It handles communication between processes and updates based on new blockchain conditions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass Solver(proc_num, num_proc, update_interval, finished_queue, solution_queue, stopEvent, curr_block, curr_block_num, curr_diff, check_block, limit):\n   \"\"\"A process that solves the registration PoW problem.\n\n   :param proc_num: The number of the process being created.\n   :type proc_num: int\n   :param num_proc: The total number of processes running.\n   :type num_proc: int\n   :param update_interval: The number of nonces to try to solve before checking for a new block.\n   :type update_interval: int\n   :param finished_queue: The queue to put the process number when a process finishes each\n                          update_interval. Used for calculating the average time per update_interval across all processes.\n   :type finished_queue: multiprocessing.Queue\n   :param solution_queue: The queue to put the solution the process has found during the pow solve.\n   :type solution_queue: multiprocessing.Queue\n   :param stopEvent: The event to set by the main process when all the solver processes should\n                     stop. The solver process will check for the event after each update_interval. The solver process will stop\n                     when the event is set. Used to stop the solver processes when a solution is found.\n   :type stopEvent: multiprocessing.Event\n   :param curr_block: The array containing this process's current block hash. The main process\n                      will set the array to the new block hash when a new block is finalized in the network. The solver process\n                      will get the new block hash from this array when newBlockEvent is set.\n   :type curr_block: multiprocessing.Array\n   :param curr_block_num: The value containing this process's current block number. The main\n                          process will set the value to the new block number when a new block is finalized in the network. The\n                          solver process will get the new block number from this value when newBlockEvent is set.\n   :type curr_block_num: multiprocessing.Value\n   :param curr_diff: The array containing this process's current difficulty. The main process will\n                     set the array to the new difficulty when a new block is finalized in the network. The solver process will\n                     get the new difficulty from this array when newBlockEvent is set.\n   :type curr_diff: multiprocessing.Array\n   :param check_block: The lock to prevent this process from getting the new block data while the\n                       main process is updating the data.\n   :type check_block: multiprocessing.Lock\n   :param limit: The limit of the pow solve for a valid solution.\n   :type limit: int\n   \"\"\"\n\n   def run(self):\n      \"\"\"Method to be run in sub-process; can be overridden in sub-class\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Listing All Subnets with btcli subnet list\nDESCRIPTION: This command lists all subnets and their detailed information, including NETUID, number of neurons, emission percentage, tempo, and other parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_15\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets list\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet list [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Querying Neuron Identity in Python\nDESCRIPTION: Async method to retrieve detailed identity information for a specific neuron using their SS58 address. Returns network-specific details about the neuron's role and status.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nasync def query_identity(key, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Subnet Parameter Setting Command Syntax\nDESCRIPTION: Syntax for the sudo set command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_25\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Querying Weight Commits in Bittensor Network with Python\nDESCRIPTION: This example shows how to query the commit data for an account on a given network ID in the Bittensor network. It connects to the Finney test network and retrieves the commit-reveal weight setting data for a specific account.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nwho = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'WeightCommits', [netuid, who])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Transferring Stakes between Wallets\nDESCRIPTION: Command to transfer stake ownership from one wallet to another while maintaining the same hotkey. Shows the process of selecting stakes and executing the transfer.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nbtcli stake transfer\n```\n\n----------------------------------------\n\nTITLE: Setting Subnet Hyperparameters with btcli\nDESCRIPTION: This command shows how to set hyperparameters for a subnet using the Bittensor CLI. Only the coldkey that created the subnet has permission to modify these settings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/subnet-hyperparameters.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set\n```\n\n----------------------------------------\n\nTITLE: External IP Retrieval Function\nDESCRIPTION: Function that attempts to get the external IP address using multiple services. Returns the router's external facing IP as a string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/networking/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef get_external_ip():\n    \"\"\"Checks CURL/URLLIB/IPIFY/AWS for your external ip.\n    :returns: Your routers external facing ip as a string.\n    :rtype: external_ip  (:obj:`str` `required`)\n    :raises ExternalIPNotFound (Exception): Raised if all external ip attempts fail.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Getting Total Stake for Multiple Coldkeys\nDESCRIPTION: This function returns the total stake held on multiple coldkeys, provided as a tuple of their SS58 addresses. It aggregates the financial data associated with each coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_total_stake_for_coldkeys(*ss58_addresses, block = None)\n\n      Returns the total stake held on multiple coldkeys.\n\n      :param ss58_addresses: The SS58 address(es) of the coldkey(s)\n      :type ss58_addresses: tuple[str]\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance objects}.  \n      :rtype: Dict in view {address\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncMetagraph in Python\nDESCRIPTION: Creates an instance of AsyncMetagraph, which represents the Bittensor network state. It allows for asynchronous operations and syncing with the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass AsyncMetagraph(netuid, network = settings.DEFAULT_NETWORK, lite = True, sync = True, subtensor = None):\n    # ... implementation details ...\n```\n\n----------------------------------------\n\nTITLE: Listing All Local Bittensor Wallets\nDESCRIPTION: Command to list all local Bittensor wallets stored in the root directory, showing their names and public addresses.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet list\n```\n\n----------------------------------------\n\nTITLE: Viewing Exchange Rates for Subnet Alpha Token with Bittensor Python SDK\nDESCRIPTION: This code snippet shows how to view exchange rates for a subnet alpha token, both with and without slippage, using the Bittensor Python SDK. It connects to the test network and retrieves various exchange rate information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-sdk.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\nsub = bt.Subtensor(network=\"test\")\nsubnet = sub.subnet(netuid=1)\n\nprint(\"alpha_to_tao_with_slippage\", subnet.alpha_to_tao_with_slippage(100))\nprint(\"alpha_to_tao_with_slippage percentage\", subnet.alpha_to_tao_with_slippage(100, percentage=True))\n\nprint(\"tao_to_alpha_with_slippage\", subnet.tao_to_alpha_with_slippage(100))\nprint(\"tao_to_alpha_with_slippage percentage\", subnet.tao_to_alpha_with_slippage(100, percentage=True))\n\nprint(\"tao_to_alpha\", subnet.tao_to_alpha(100))\nprint(\"alpha_to_tao\", subnet.alpha_to_tao(100))\n```\n\n----------------------------------------\n\nTITLE: Querying ColdkeySwapScheduleDuration in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the ColdkeySwapScheduleDuration storage item. It retrieves the block duration for which a coldkey swap schedule must wait before execution.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'ColdkeySwapScheduleDuration')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Installing Basic Packages on Linux for Subtensor\nDESCRIPTION: Install essential packages on Linux to prepare for Subtensor node installation. This includes build tools, clang, curl, git, OpenSSL development files, LLVM, libudev, and protobuf compiler.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nsudo apt-get update \nsudo apt install -y build-essential clang curl git make libssl-dev llvm libudev-dev protobuf-compiler pkg-config\n```\n\n----------------------------------------\n\nTITLE: Verifying UIDs in Bittensor Subnet\nDESCRIPTION: Shows how to verify the UIDs in a Bittensor subnet using Python. It accesses the subnet's UIDs and checks if they match the expected list.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph( netuid = 1 )\nassert subnet.uids.tolist() == [ 0, 1, 2, ... 1022, 1023 ]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnets in Bittensor\nDESCRIPTION: This method retrieves the list of all subnet unique identifiers currently present in the Bittensor network, providing an overview of the network's structure.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_subnets(block = None)\n\n      Retrieves the list of all subnet unique identifiers (netuids) currently present in the Bittensor network.\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: A list of subnet netuids.\n\n      This function provides a comprehensive view of the subnets within the Bittensor network,\n      offering insights into its diversity and scale.\n```\n\n----------------------------------------\n\nTITLE: Querying Minimum Stake Required for Weights in Bittensor with Python\nDESCRIPTION: This example shows how to query the minimum stake required for weights in the Bittensor network. It connects to the Finney test network and retrieves the threshold value that determines the minimum stake needed to set weights in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_58\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'WeightsMinStake')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Checking Miner Registration Status with SS58 Hotkey and Netuid\nDESCRIPTION: Python script to check the registration status of a miner using its SS58 hotkey and subnet ID (netuid). It uses the Bittensor library and metagraph to verify registration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/index.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n# Replace below with your SS58 hotkey \nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nnetuid = 1 # subnet uid\nsub = bt.subtensor(network)\nmg = sub.metagraph(netuid)\nif hotkey not in mg.hotkeys:\n  print(f\"Hotkey {hotkey} deregistered\")\nelse:\n  print(f\"Hotkey {hotkey} is registered\")\n```\n\n----------------------------------------\n\nTITLE: Listing Subnets with BTCLI in Shell\nDESCRIPTION: This command lists all available subnets in the Bittensor network. It displays information such as subnet ID, name, token price, market cap, emission rate, and other relevant details.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/managing-stake-btcli.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbtcli subnet list\n```\n\n----------------------------------------\n\nTITLE: Retrieving Hotkey Owner in Python\nDESCRIPTION: This asynchronous method retrieves the owner of a given hotkey at a specific block hash. It returns the SS58 address of the owner if the hotkey exists, or None if it doesn't.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nasync def get_hotkey_owner(hotkey_ss58, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Casting Senate Votes in Bittensor CLI\nDESCRIPTION: This command enables Senators to vote on proposals. Users are prompted for the proposal hash and their vote (approval or disapproval). The vote is included in the next block once confirmed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/senate.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbtcli sudo senate-vote\n```\n\n----------------------------------------\n\nTITLE: Registering Wallet via Burning TAO in Bittensor\nDESCRIPTION: Function that registers a wallet to the Bittensor network by recycling/burning TAO tokens. It takes a subtensor instance, wallet, network ID, and parameters to control waiting for blockchain inclusion and finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/registration/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nburned_register_extrinsic(subtensor, wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Using Context Manager for Asynchronous Subtensor Connection in Python\nDESCRIPTION: These snippets demonstrate two ways to use context managers with asynchronous Subtensor connections, ensuring proper connection handling.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/sdk/managing-subtensor-connections.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nasync with bt.AsyncSubtensor() as sub:\n    # calls to subtensor\n\n# instance and connection are terminated at the end of the context scope\n```\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.AsyncSubtensor()\nasync with sub:\n    # calls to subtensor\n\n# instance and connection are terminated at the end of the context scope\n```\n\n----------------------------------------\n\nTITLE: Handling Key File Error in Bittensor CLI\nDESCRIPTION: This error occurs when using an unregistered key in a btcli command. The solution is to register the keys in the desired network before use.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nKeyFileError: Keyfile at: /path/to/.bittensor/wallets/some-coldkey/hotkeys/somehotkey does not exist\n```\n\n----------------------------------------\n\nTITLE: SubnetInfo Class Method for Converting Vector to List\nDESCRIPTION: A class method that converts a vector of u8 values to a list. This is likely used for deserializing subnet information from blockchain storage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/subnet_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nlist_from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Staked Balance\nDESCRIPTION: Python function signature for fetching the staked balance for a given hotkey and coldkey pair on a specific subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nget_stake(\n    hotkey_ss58: str, \n    coldkey_ss58: str, \n    netuid: int\n) -> bittensor.Balance\n```\n\n----------------------------------------\n\nTITLE: Retrieving Tempo Hyperparameter in Bittensor (Python)\nDESCRIPTION: This asynchronous method returns the Tempo hyperparameter for a specified subnet. It can query this information at a specific blockchain block (by number or hash) and returns the integer value or None if the subnetwork doesn't exist or the parameter is not found.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\ntempo(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: AsyncSubtensor Class Definition\nDESCRIPTION: Defines the AsyncSubtensor class for interacting with Substrate Interface. Includes initialization parameters for network connection and configuration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass AsyncSubtensor(network = None, config = None, _mock = False, log_verbose = False):\n    \"\"\"Thin layer for interacting with Substrate Interface. Mostly a collection of frequently-used calls.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Extrinsic Submission in Bittensor (Python)\nDESCRIPTION: Asynchronously submits an extrinsic to the Bittensor blockchain. It handles waiting for inclusion and finalization, and manages potential exceptions during submission. This function is useful for non-blocking extrinsic operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/utils/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nasync def async_submit_extrinsic(subtensor, extrinsic, wait_for_inclusion, wait_for_finalization):\n    # Function implementation not provided in the snippet\n```\n\n----------------------------------------\n\nTITLE: Querying Total Stake in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to query the total amount of tokens staked in the Bittensor network. It connects to the Finney test network and retrieves the aggregate value of all staked tokens across the system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TotalStake')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Rate Limit in Bittensor with Python\nDESCRIPTION: This example demonstrates how to query the general transaction rate limit in the Bittensor network. It connects to the Finney test network and retrieves the value that restricts overall transaction frequency in the system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TxRateLimit')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Stake Data Processor Function\nDESCRIPTION: Function to process stake data by decoding account IDs and converting stakes from rao to Balance objects. Takes a list of stake data tuples and returns a dictionary.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/utils/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef process_stake_data(stake_data):\n    \"\"\"Processes stake data to decode account IDs and convert stakes from rao to Balance objects.\"\"\"\n    return dict\n```\n\n----------------------------------------\n\nTITLE: Committing Weights for Bittensor Subnet\nDESCRIPTION: This command is used to commit weights for a specific subnet in the Bittensor network. Users must specify the netuid, UIDs of interest, and the corresponding weights.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_53\n\nLANGUAGE: bash\nCODE:\n```\nbtcli weights commit [OPTIONS]\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wt commit --netuid 1 --uids 1,2,3,4 --w 0.1,0.2,0.3\n```\n\n----------------------------------------\n\nTITLE: PoW Solution Class for Bittensor Registration\nDESCRIPTION: A class representing a solution to the registration Proof-of-Work problem. It includes methods to check if the solution is stale based on current blockchain state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass POWSolution:\n   \"\"\"A solution to the registration PoW problem.\"\"\"\n\n   block_number: int\n   nonce: int\n   difficulty: int\n   seal: bytes\n\n   def is_stale(self, subtensor):\n      \"\"\"Synchronous implementation. Returns True if the POW is stale.\n\n      This means the block the POW is solved for is within 3 blocks of the current block.\n      \"\"\"\n\n   async def is_stale_async(self, subtensor):\n      \"\"\"Asynchronous implementation. Returns True if the POW is stale.\n\n      This means the block the POW is solved for is within 3 blocks of the current block.\n      \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Regenerating Coldkey with Mnemonic in Bittensor\nDESCRIPTION: This command allows you to regenerate your coldkey wallet using your saved mnemonic phrase. This is necessary if you've lost access to your wallet but still have your mnemonic phrase backup.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen_coldkey --mnemonic **** *** **** **** ***** **** *** **** **** **** ***** *****\n```\n\n----------------------------------------\n\nTITLE: Making State Calls to Bittensor Blockchain (Python)\nDESCRIPTION: This asynchronous method makes direct state calls to the Bittensor blockchain for advanced queries. It allows specifying the method name, data payload, and target block (by number or hash). This provides flexibility for querying blockchain data beyond standard API methods.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nstate_call(method, data, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Logging Messages with BittensorConsole\nDESCRIPTION: Example showing how to use various logging methods from the BittensorConsole class. Demonstrates logging different message types (info, error, success, warning, critical) and shows that regular logging calls will not be displayed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/console/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor import logging\n\n# will be logged\nlogging.console.info(\"info message\")\nlogging.console.error(\"error message\")\nlogging.console.success(\"success message\")\nlogging.console.warning(\"warning message\")\nlogging.console.critical(\"critical message\")\n\n# will not be logged\nlogging.info(\"test info\")\n```\n\n----------------------------------------\n\nTITLE: Minting Faucet Tokens for Local Subnet Creation in Bittensor\nDESCRIPTION: This command mints faucet tokens (fake TAO) for a specified wallet on a local Bittensor blockchain. It requires the wallet name and the local chain endpoint.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet faucet --wallet.name <owner-wallet-name> --subtensor.chain_endpoint ws://127.0.0.1:9946\n```\n\n----------------------------------------\n\nTITLE: Accessing Historical Network Data with Archive Network in Python\nDESCRIPTION: Demonstrates accessing data beyond the previous 300 blocks using the archive network. This is necessary for historical analysis as light nodes only store recent blocks.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\nsubtensor = Subtensor(network='archive')\ncurrent_block = subtensor.get_current_block()\nhistory_block = current_block - 1200\n\nmetagraph.sync(block=history_block, lite=False, subtensor=subtensor)\n```\n\n----------------------------------------\n\nTITLE: Transferring TAO with btcli\nDESCRIPTION: This command transfers TAO from one coldkey to another. It requires access to the coldkey private key and must be run on a secure coldkey workstation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet transfer\n```\n\n----------------------------------------\n\nTITLE: Retrieving TAO Balance\nDESCRIPTION: Python function signature for fetching the current or historical coldkey TAO balance for a given address.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nget_balance(\n    address: str, \n    block: Optional[int] = None\n) -> bittensor.Balance\n```\n\n----------------------------------------\n\nTITLE: Managing Balances and Blocks in Python using Bittensor API\nDESCRIPTION: This snippet includes methods for retrieving token balances and current block information from the Bittensor network. It provides functionality to get individual and multiple address balances.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nget_balance(self, address: str, block: int = None) -> Balance\n```\n\nLANGUAGE: python\nCODE:\n```\nget_current_block(self) -> int\n```\n\nLANGUAGE: python\nCODE:\n```\nget_balances(self, block: int = None) -> Dict[str, Balance]\n```\n\n----------------------------------------\n\nTITLE: Implementing Get and Save Latest Version Function in Python\nDESCRIPTION: Defines a function to retrieve and save the latest version of Bittensor from PyPI. It returns the latest version as a string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/version/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef get_and_save_latest_version(timeout = 15):\n    \"\"\"Retrieves and saves the latest version of Bittensor.\n\n    :param timeout: The timeout for the request to PyPI in seconds. Default is ``15``.\n    :type timeout: int\n\n    :returns: The latest version of Bittensor.\n    :rtype: str\n    \"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Querying Total Coldkey Stake in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to query the total amount of stake under a specific coldkey on the Bittensor network. It connects to the Finney test network and retrieves the stake value associated with a coldkey generated from the '//Bob' seed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\ncoldkey = Keypair.create_from_uri('//Bob').ss58_address\nresult = substrate.query('SubtensorModule', 'TotalColdkeyStake', [coldkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating a Subnet on Bittensor Mainchain\nDESCRIPTION: This command creates a new subnet on the Bittensor mainchain. It requires real TAO in the owner wallet. The netuid of the created subnet is returned.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create\n```\n\n----------------------------------------\n\nTITLE: Fetching Neuron Information for Subnet in Python\nDESCRIPTION: This asynchronous method retrieves information about a neuron based on its public key (hotkey SS58 address) and the specific subnet UID (netuid). It provides detailed neuron information for a particular subnet within the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nasync def get_neuron_for_pubkey_and_subnet(hotkey_ss58, netuid, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Interactive btcli Command for Setting Hyperparameters\nDESCRIPTION: Demonstrates the interactive btcli command for setting hyperparameters, which can be used to configure consensus-based weights.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set\n\n>> Enter wallet name (default):    # <my_coldkey>\n>> Enter netuid [0/1/2/3] (0):     # <your_preferred_netuid>\n>> Enter hyperparameter:           # <liquid_alpha_enabled>\n>> Enter new value:                # <True> or <False>\n>> Enter password to unlock key:   # <password>\n```\n\n----------------------------------------\n\nTITLE: Querying WeightsSetRateLimit in Bittensor Network with Python\nDESCRIPTION: This snippet demonstrates how to query the WeightsSetRateLimit parameter for a specific netuid in the Bittensor network using the Substrate interface. The WeightsSetRateLimit represents the rate limit for setting weights in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'WeightsSetRateLimit', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Metagraph using BTCLI in Bash\nDESCRIPTION: Command to display the metagraph of a subnet. This is a permissionless read operation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets metagraph\n```\n\n----------------------------------------\n\nTITLE: POW Registration for Subnet Nodes\nDESCRIPTION: Command to register a neuron using Proof of Work, with support for multi-processing and CUDA acceleration. Requires computational resources and understanding of POW mechanics.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_18\n\nLANGUAGE: bash\nCODE:\n```\nbtcli pow_register --netuid 1 --num_processes 4 --cuda\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet pow-register [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Implementing BTStreamingResponse Class\nDESCRIPTION: Specialized StreamingResponse subclass for handling token streaming. Manages the response streaming process including headers and token streamer execution.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/stream/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass BTStreamingResponse(model, *, synapse = None, **kwargs):\n   Bases: :py:obj:`starlette.responses.StreamingResponse`\n\n   async def stream_response(send):\n       pass\n\n   synapse = None\n   token_streamer = None\n```\n\n----------------------------------------\n\nTITLE: Querying Validator Permits in Bittensor Network with Python\nDESCRIPTION: This example shows how to query the validator permit values of UIDs in a specific Bittensor subnet. It connects to the Finney test network and retrieves a vector of boolean values indicating which UIDs have validator permissions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ValidatorPermit', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Getting Stake Info for Coldkey\nDESCRIPTION: This function retrieves detailed stake information for a specified coldkey, including amounts staked and associated delegates. This data is crucial for assessing involvement in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_stake_info_for_coldkey(coldkey_ss58, block = None)\n\n      Retrieves stake information associated with a specific coldkey. This function provides details about the stakes\n          held by an account, including the staked amounts and associated delegates.\n\n      :param coldkey_ss58: The ``SS58`` address of the account's coldkey.\n      :type coldkey_ss58: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: A list of StakeInfo objects detailing the stake allocations for the account.\n\n      Stake information is vital for account holders to assess their investment and participation in the network's\n          delegation and consensus processes.\n```\n\n----------------------------------------\n\nTITLE: Generating Weight Hash in Python\nDESCRIPTION: Generates a valid commit hash from the provided weights. Takes address, netuid, uids, values, version_key, and salt as input and returns the generated commit hash as a string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef generate_weight_hash(address, netuid, uids, values, version_key, salt):\n    \"\"\"Generate a valid commit hash from the provided weights.\n\n    :param address: The account identifier. Wallet ss58_address.\n    :type address: str\n    :param netuid: The network unique identifier.\n    :type netuid: int\n    :param uids: The list of UIDs.\n    :type uids: list[int]\n    :param salt: The salt to add to hash.\n    :type salt: list[int]\n    :param values: The list of weight values.\n    :type values: list[int]\n    :param version_key: The version key.\n    :type version_key: int\n\n    :returns: The generated commit hash.\n    :rtype: str\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Undelegating Stake in Bittensor\nDESCRIPTION: Method to remove a specific amount of stake from a delegate using a wallet in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nundelegate(self, wallet: 'bittensor.wallet', delegate_ss58: Optional[str] = None, amount: Union[Balance, float] = None, wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Removing Staked TAO with btcli stake remove\nDESCRIPTION: This command unstakes TAO from one or more hotkeys and transfers them back to the user's coldkey. It allows flexible management of TAO stake across different neurons on the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake remove --amount 100 -in hk1,hk2\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake remove [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Updating Only Alpha High Value in Bittensor\nDESCRIPTION: Example of updating only the alpha_high value while keeping alpha_low unchanged. The command requires providing both values even when changing only one, by retrieving the current alpha_low value first and then setting both values together.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set hyperparameters --netuid 1 --param alpha_values --value 6554,55706\n```\n\n----------------------------------------\n\nTITLE: Serving Axon on Bittensor Subnet in Python\nDESCRIPTION: Shows how to serve an Axon instance on a specific subnet within the Bittensor network. This method registers the Axon with a subnet, allowing it to participate in the network's operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_axon = bittensor.Axon(...)\nsubtensor = bt.subtensor(network=\"local\") # Local by default\nmy_axon.serve(netuid=1, subtensor=subtensor)  # Serves the axon on subnet with netuid 1\n```\n\n----------------------------------------\n\nTITLE: Querying Network Parameters in Python\nDESCRIPTION: Collection of queries for various network parameters including difficulty, stake requirements, and registration settings using SubstrateInterface.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'Owner', [hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Checking if a Hotkey Exists in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method verifies if a hotkey is known by the Bittensor blockchain and has associated accounts. Returns a boolean value indicating whether the hotkey exists.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndoes_hotkey_exist(hotkey_ss58, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Synchronous Neuron Retrieval in Python\nDESCRIPTION: This snippet shows the synchronous version of retrieving all neurons from the testnet using the Subtensor class. It's provided for comparison with the asynchronous version to demonstrate the performance difference.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\ndef sync_main():\n    subtensor = Subtensor(\"test\")\n    start = time.time()\n    block = subtensor.block\n    total_subnets = subtensor.get_total_subnets(block)\n    neurons = [subtensor.neurons(x, block) for x in range(0, total_subnets+1)]\n    print(time.time() - start)\n```\n\n----------------------------------------\n\nTITLE: Computing Miner Emissions Share in Yuma Consensus\nDESCRIPTION: This LaTeX equation calculates a miner's share of the subnet's miner-emissions based on their proportion of the total aggregate miner ranking.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\nM_j = \\frac{\\,R_j\\,}{\\sum_{k \\in \\mathbb{M}} R_k}\n```\n\n----------------------------------------\n\nTITLE: Initializing Bittensor Objects for Consensus-based Weights in Python\nDESCRIPTION: Sets up the wallet and subtensor objects needed to interact with the Bittensor network for consensus-based weights functionality.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\nwallet = bt.wallet(name=<my_coldkey>)\nsubtensor = bt.subtensor(network=\"127.0.0.1:9946\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Subnet on Bittensor Testchain\nDESCRIPTION: This command creates a new subnet on the Bittensor testchain. It requires sufficient test TAO in the owner wallet. The netuid of the created subnet is returned.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/create-a-subnet.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create --subtensor.network test\n```\n\n----------------------------------------\n\nTITLE: Creating and Managing Hotkeys with BTCLI for Bittensor Mining\nDESCRIPTION: Commands for creating new hotkeys, regenerating existing hotkeys, and registering UIDs for mining operations. These operations should be performed on a secure coldkey workstation before transferring to the mining environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/miners/miners-btcli-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new-hotkey\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-hotkey\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets register\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets pow-register\n```\n\n----------------------------------------\n\nTITLE: Retrieving Lite Neuron Data in Python\nDESCRIPTION: Async method to get a simplified view of neurons in a subnet, focusing on key attributes like stake and participation. Provides streamlined network analysis capabilities.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nasync def neurons_lite(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Defining SynapseException Base Class\nDESCRIPTION: Base exception class for Synapse-related errors with message and synapse attributes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/errors/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass SynapseException(Exception):\n    message = 'Synapse Exception'\n    synapse = None\n\n    def __init__(self, message='Synapse Exception', synapse = None):\n        super().__init__(message)\n```\n\n----------------------------------------\n\nTITLE: Calculating Stake Yield in Bittensor Subnet using LaTeX\nDESCRIPTION: This LaTeX formula calculates the amount of alpha stake yielded when staking a certain amount of TAO in a Bittensor subnet. It takes into account the initial reserves of TAO and alpha, and the cost of staking.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/staking-unstaking-dtao.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\text{Stake} = \\alpha_{\\text{in}} - \\frac{\\tau_{\\text{in}} \\alpha_{\\text{in}}} {\\tau_{\\text{in}} + \\text{cost}}\n```\n\n----------------------------------------\n\nTITLE: Registering a Neuron on Bittensor Network (Python)\nDESCRIPTION: Facilitates the registration of a neuron on the Bittensor network, enabling it to stake, set weights, and receive incentives. This method supports the network's decentralized growth and scalability.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_57\n\nLANGUAGE: python\nCODE:\n```\ndef register(wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True, max_allowed_attempts = 3, output_in_place = True, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Retrieving Max Weight Limit Hyperparameter in Bittensor (Python)\nDESCRIPTION: Returns the MaxWeightsLimit hyperparameter for a specific subnet. This parameter defines limits on weight assignments within the network and is crucial for understanding network constraints.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\ndef max_weight_limit(netuid, block = None):\n    \"\"\"\n    Returns network MaxWeightsLimit hyperparameter.\n\n    :param netuid: The unique identifier of the subnetwork.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns:\n\n              The value of the MaxWeightsLimit hyperparameter, or ``None`` if the subnetwork does not\n                  exist or the parameter is not found.\n    :rtype: Optional[float]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Filtering Network UIDs by Registered Hotkeys in Bittensor\nDESCRIPTION: Filters a list of network UIDs based on specified UIDs and registered hotkey wallets. This is useful for selecting a subset of neurons meeting specific criteria at a given blockchain block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef filter_netuids_by_registered_hotkeys(all_netuids, filter_for_netuids, all_hotkeys, block):\n      Filters a given list of all netuids for certain specified netuids and hotkeys\n\n      :param all_netuids: A list of netuids to filter.\n      :type all_netuids: Iterable[int]\n      :param filter_for_netuids: A subset of all_netuids to filter from the main list.\n      :type filter_for_netuids: Iterable[int]\n      :param all_hotkeys: Hotkeys to filter from the main list.\n      :type all_hotkeys: Iterable[Wallet]\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The filtered list of netuids.\n```\n\n----------------------------------------\n\nTITLE: Querying API Nodes in Bittensor Subnet in Python\nDESCRIPTION: An asynchronous method that queries API nodes of a subnet using the given synapse and bespoke query function. It takes axons to query, a deserialize flag, a timeout value, and additional keyword arguments for the prepare_synapse function.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/subnets/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def query_api(axons, deserialize = False, timeout = 12, **kwargs):\n    \"\"\"\n    Queries the API nodes of a subnet using the given synapse and bespoke query function.\n\n    :param axons: The list of axon(s) to query.\n    :type axons: Union[bt.axon, list[bt.axon]]\n    :param deserialize: Whether to deserialize the responses. Defaults to False.\n    :type deserialize: Optional[bool]\n    :param timeout: The timeout in seconds for the query. Defaults to 12.\n    :type timeout: Optional[int]\n    :param \\*\\*kwargs: Keyword arguments for the prepare_synapse_fn.\n\n    :returns: The result of the process_responses_fn.\n    :rtype: Any\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Fetching Single Subnet Information\nDESCRIPTION: Python function signature for retrieving information about a single subnet identified by its netuid.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsubnet(\n    netuid: int, \n    block_number: Optional[int] = None\n) -> DynamicInfo\n```\n\n----------------------------------------\n\nTITLE: Setting Delegate Take Percentage\nDESCRIPTION: Command for changing a delegate's take percentage using btcli sudo set-take. Requires wallet name and hotkey specification.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_26\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set-take --wallet-name my_wallet --wallet-hotkey my_hotkey\n```\n\n----------------------------------------\n\nTITLE: Listing Bittensor Wallet Directory Structure\nDESCRIPTION: Bash command to display the directory structure of Bittensor wallets, showing the location of coldkeys and hotkeys.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ntree ~/.bittensor/\n```\n\n----------------------------------------\n\nTITLE: Checking Wallet Balance with Default Config\nDESCRIPTION: Command for checking wallet balance using default configuration values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_32\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w balance\n```\n\n----------------------------------------\n\nTITLE: Configuring Async Bittensor Subtensor for Test Network\nDESCRIPTION: Python code snippet demonstrating how to import and configure the Bittensor AsyncSubtensor for the test network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.AsyncSubtensor(network=\"test\")\n```\n\n----------------------------------------\n\nTITLE: Querying OwnedHotkeys in Python\nDESCRIPTION: Retrieves the vector of hotkeys controlled by a specific coldkey using SubstrateInterface.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\ncoldkey = Keypair.create_from_uri('//Bob').ss58_address\nresult = substrate.query('SubtensorModule', 'OwnedHotkeys', [coldkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Querying ActivityCutoff in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the ActivityCutoff storage item for a specific network ID (netuid). ActivityCutoff represents the activity cutoff for networks.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ActivityCutoff', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Multiple Account Balances in Bittensor\nDESCRIPTION: Fetches TAO balances for multiple coldkey addresses at once, returning a dictionary mapping addresses to their Balance objects at a specified blockchain block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef get_balances(*addresses, block = None):\n      Retrieves the balance for given coldkey(s)\n\n      :param addresses: coldkey addresses(s).\n      :type addresses: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance objects}.\n      :rtype: Dict of {address\n```\n\n----------------------------------------\n\nTITLE: Querying Subtensor Storage in Python\nDESCRIPTION: Asynchronous method to query named storage from the Subtensor module on the Bittensor blockchain. Used to retrieve specific data like stake, rank, or other neuron attributes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_44\n\nLANGUAGE: python\nCODE:\n```\nasync def query_subtensor(name, block = None, block_hash = None, reuse_block = False, params = None)\n```\n\n----------------------------------------\n\nTITLE: Creating New Hotkey with btcli\nDESCRIPTION: This command creates a new hotkey owned by the coldkey. It requires access to the coldkey private key and should be run on a secure coldkey workstation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new-hotkey\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Identities in Bittensor\nDESCRIPTION: Fetches delegate identity information from both the blockchain and GitHub, prioritizing chain data but supplementing with GitHub data when necessary, to provide complete delegate profile information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef get_delegate_identities(block = None):\n      Fetches delegates identities from the chain and GitHub. Preference is given to chain data, and missing info is\n          filled-in by the info from GitHub. At some point, we want to totally move away from fetching this info from\n          GitHub, but chain data is still limited in that regard.\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: DelegatesDetails, ...}\n      :rtype: Dict {ss58\n```\n\n----------------------------------------\n\nTITLE: Publishing Metadata to Bittensor Network\nDESCRIPTION: Publishes metadata on the Bittensor network using the specified wallet and network identifier. It supports various data formats including Sha256, Blake256, Keccak256, or Raw0-128 with a maximum string length of 128 bytes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/serving/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\npublish_metadata(subtensor, wallet, netuid, data_type, data, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Calculating Delegated Stake in Bittensor\nDESCRIPTION: This LaTeX snippet demonstrates how to calculate the total delegated stake and the validator's total stake, including both self-stake and delegated stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/delegation.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\text{delegated stake} = 100\\tau + 70\\tau + 30\\tau = 200\\tau\n\\text{total stake} = \\text{self-stake} + \\text{delegated stake} = 800\\tau + 200\\tau = 1000 \\tau\n```\n\n----------------------------------------\n\nTITLE: Performing Concurrent Stake Operations\nDESCRIPTION: Python code snippet demonstrating how to use asyncio.gather for concurrent stake operations across multiple subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nscatter_stake = await asyncio.gather(*[ sub.add_stake( hotkey, coldkey, netuid, amount ) for netuid in range(64) ] )\n```\n\n----------------------------------------\n\nTITLE: Querying Blockchain Constants in Bittensor (Python)\nDESCRIPTION: Retrieves a constant from a specified module on the Bittensor blockchain. This provides access to fixed parameters like inflation rates, consensus rules, or validation thresholds that define the network's operation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\ndef query_constant(module_name, constant_name, block = None):\n    \"\"\"\n    Retrieves a constant from the specified module on the Bittensor blockchain. This function is used to access\n        fixed parameters or values defined within the blockchain's modules, which are essential for understanding\n        the network's configuration and rules.\n\n    :param module_name: The name of the module containing the constant.\n    :param constant_name: The name of the constant to retrieve.\n    :param block: The blockchain block number at which to query the constant.\n\n    :returns: The value of the constant if found, `None` otherwise.\n    :rtype: Optional[scalecodec.ScaleType]\n\n    Constants queried through this function can include critical network parameters such as inflation rates,\n        consensus rules, or validation thresholds, providing a deeper understanding of the Bittensor network's\n        operational parameters.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Serving Axon on Bittensor Network\nDESCRIPTION: Internal method to submit a serve axon transaction to the Bittensor blockchain. It enables a neuron's Axon to serve requests on the network by creating and submitting the appropriate transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/serving/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndo_serve_axon(subtensor, wallet, call_params, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Querying Module Storage in Python\nDESCRIPTION: Generic async method for querying any module storage on the blockchain. Provides flexible data retrieval from various blockchain modules.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nasync def query_module(module, name, block = None, block_hash = None, reuse_block = False, params = None)\n```\n\n----------------------------------------\n\nTITLE: Closing Asynchronous Subtensor Connection in Python\nDESCRIPTION: This snippet demonstrates how to properly initialize and close an asynchronous Subtensor connection using the close() method.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/sdk/managing-subtensor-connections.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.AsyncSubtensor()\nawait sub.initialize()\n# calls to subtensor\nawait sub.close()\n# instance and connection are terminated.\n```\n\n----------------------------------------\n\nTITLE: Querying AlphaValues in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the AlphaValues storage item for a specific network ID (netuid). AlphaValues represent the alpha values for the network (lower and upper alpha).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'AlphaValues', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Checking SS58 Address Balance Using BTCLI\nDESCRIPTION: This bash command demonstrates how to check the balance of an SS58 address using the BTCLI tool. It requires BTCLI version 8.2.0 or later.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/transfer-from-metamask-to-ss58.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet balance --ss58 5HgU7B3xfSfisR1A7wDMt7FHX5Uizj6xtWWHwhwJMZSrdN7y\n```\n\n----------------------------------------\n\nTITLE: Single Unstaking Extrinsic Function in Python\nDESCRIPTION: Removes stake from a specified hotkey back to the wallet's coldkey. Handles single unstaking transactions with options for waiting for inclusion or finalization. Takes parameters for subtensor instance, wallet, hotkey address, and amount to unstake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/unstaking/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef unstake_extrinsic(subtensor, wallet, hotkey_ss58 = None, amount = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Transfer and UID Operations in Python\nDESCRIPTION: Async methods for calculating transfer fees and retrieving UIDs for hotkeys on specific subnets. These utilities help manage transaction costs and identify neurons within the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nasync def get_transfer_fee(wallet, dest, value)\nasync def get_uid_for_hotkey_on_subnet(hotkey_ss58, netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: AxonMiddleware Dispatch Method\nDESCRIPTION: Core request processing method that handles the complete lifecycle of HTTP requests including preprocessing, verification, priority assessment, and response generation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def dispatch(request, call_next):\n    # Method implementation not shown in snippet\n    # Processes HTTP requests and returns responses\n    pass\n```\n\n----------------------------------------\n\nTITLE: Retrieving Blockchain Data with AsyncSubtensor in Python\nDESCRIPTION: This code demonstrates how to use AsyncSubtensor to efficiently retrieve balances and other data from multiple coldkey addresses concurrently. It shows the syntax differences between synchronous and asynchronous approaches, illustrates how to make concurrent API calls with asyncio.gather, and explains changes in the return value format between Subtensor and AsyncSubtensor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\n\nfrom bittensor.core.subtensor import Subtensor  # sync\nfrom bittensor.core.async_subtensor import AsyncSubtensor  # async\n\nfrom bittensor.utils.balance import Balance\n\nCOLDKEY_PUB = \"5EhCvSxpFRgXRCaN5LH2wRCD5su1vKsnVfYfjzkqfmPoCy2G\"\nCOLDKEY_PUBS = [\n    COLDKEY_PUB,\n    \"5CZrQzo3W6LGEopMw2zVMugPcwFBmQDYne3TJc9XzZbTX2WR\",\n    \"5Dcmx3kNTKqExHoineVpBJ6HnD9JHApRs8y2GFBgPLCaYn8d\",\n    \"5DZaBZKKGZBGaevi42bYUK44tEuS3SYJ7GU3rQKYr7kjfa8v\"\n]\n\n\nasync def main():  # define a coroutine with `async def`\n    sync_sub = Subtensor(\"finney\")  # same as always\n    async with AsyncSubtensor(\"finney\") as async_subtensor:  # very important to initialise this with `async with`\n        sync_balance: Balance = sync_sub.get_balance(COLDKEY_PUB)\n        # returns τ0.000000000\n\n        async_balance: dict[str, Balance] = await async_subtensor.get_balance(COLDKEY_PUB)\n        # returns {'5EhCvSxpFRgXRCaN5LH2wRCD5su1vKsnVfYfjzkqfmPoCy2G': τ0.000000000}\n        # get_balance now takes multiple addresses, and returns them as a dict\n        # of {ss58: Balance}\n        # for example:\n        async_balances: dict[str, Balance] = await async_subtensor.get_balance(*COLDKEY_PUBS)\n        # returns: {\n        #   '5EhCvSxpFRgXRCaN5LH2wRCD5su1vKsnVfYfjzkqfmPoCy2G': τ0.000000000,\n        #   '5CZrQzo3W6LGEopMw2zVMugPcwFBmQDYne3TJc9XzZbTX2WR': τ0.000000000,\n        #   '5Dcmx3kNTKqExHoineVpBJ6HnD9JHApRs8y2GFBgPLCaYn8d': τ0.000000000,\n        #   '5DZaBZKKGZBGaevi42bYUK44tEuS3SYJ7GU3rQKYr7kjfa8v': τ0.000000000\n        #   }\n        # This works the same with .get_total_stake_for_coldkey, .get_total_stake_for_hotkey\n        # to do multiples with sync subtensor, we would do:\n        sync_balances: dict[str, Balance] = {}\n        for coldkey in COLDKEY_PUBS:\n            sync_balances[coldkey] = sync_sub.get_balance(coldkey)\n\n        # let's say we want to make multiple calls at the same time. We can do this with asyncio.gather\n        async_delegated, async_balance = await asyncio.gather(\n            async_subtensor.get_delegated(COLDKEY_PUB),\n            async_subtensor.get_balance(COLDKEY_PUB)\n        )\n        # This will make concurrent calls to retrieve the delegates and balance of this coldkey\n        # We can even chain these together quite dramatically, such as this example in btcli wallets:\n        \"\"\"\n        balances, all_neurons, all_delegates = await asyncio.gather(\n            subtensor.get_balance(\n                *[w.coldkeypub.ss58_address for w in wallets_with_ckp_file],\n                block_hash=block_hash,\n            ),\n            asyncio.gather(\n                *[\n                    subtensor.neurons_lite(netuid=netuid, block_hash=block_hash)\n                    for netuid in all_netuids\n                ]\n            ),\n            asyncio.gather(\n                *[\n                    subtensor.get_delegated(w.coldkeypub.ss58_address)\n                    for w in wallets_with_ckp_file\n                ]\n            ),\n        )\n        \"\"\"\n        # There are also certain changes for the decoding of SCALE objects from the chain.\n        # As a rule of thumb, anything using `.value` from sync Subtensor just returns the value itself\n        # See the example of `Subtensor._get_hyperparameter` vs `AsyncSubtensor.get_hyperparameter`:\n        # Subtensor\n        \"\"\"\n        result = self.query_subtensor(param_name, block, [netuid])\n        if result is None or not hasattr(result, \"value\"):\n            return None\n\n        return result.value\n        \"\"\"\n        # AsyncSubtensor\n        \"\"\"\n        result = await self.substrate.query(\n            module=\"SubtensorModule\",\n            storage_function=param_name,\n            params=[netuid],\n            block_hash=block_hash,\n            reuse_block_hash=reuse_block,\n        )\n\n        if result is None:\n            return None\n\n        return result\n        \"\"\"\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())  # coroutines need to have something to run them, usually `asyncio.run`\n```\n\n----------------------------------------\n\nTITLE: Transferring TAO to Multisig Wallet\nDESCRIPTION: Command to initiate a TAO transfer to the multisig wallet using BTCLI.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/keys/multisig.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet transfer\n```\n\n----------------------------------------\n\nTITLE: Async Multiple Stake Addition\nDESCRIPTION: Asynchronous method to add stakes to multiple neurons simultaneously. Enables bulk staking operations from a single wallet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nasync def add_stake_multiple(wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False):\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Subtensor Methods for Subnet Operations\nDESCRIPTION: Methods in the MockSubtensor class that simulate subnet-related operations such as creating subnets, setting weights, and managing axons without requiring an actual blockchain connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef create_subnet(netuid)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef do_set_weights(wallet, netuid, uids, vals, version_key, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef do_serve_axon(wallet, call_params, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef do_serve_prometheus(wallet, call_params, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Weight Distribution in Bittensor Subnet (Python)\nDESCRIPTION: An asynchronous method that retrieves the weight distribution set by neurons within a specific subnet. It maps each neuron's UID to weights assigned to other neurons, reflecting network trust mechanisms that influence consensus and reward allocation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_62\n\nLANGUAGE: python\nCODE:\n```\nasync def weights(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Weight Management in Bittensor CLI\nDESCRIPTION: Commands for revealing and committing weights in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nbtcli weights reveal\nbtcli weights commit\n```\n\n----------------------------------------\n\nTITLE: Running Subtensor Lite Node on Mainchain\nDESCRIPTION: Execute the Subtensor node in lite mode connected to the mainchain, using warp sync and specific network configurations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./target/production/node-subtensor --chain ./chainspecs/raw_spec_finney.json --base-path /tmp/blockchain --sync=warp --port 30333 --max-runtime-instances 32 --rpc-max-response-size 2048 --rpc-cors all --rpc-port 9944 --bootnodes /dns/bootnode.finney.chain.opentensor.ai/tcp/30333/ws/p2p/12D3KooWRwbMb85RWnT8DSXSYMWQtuDwh4LJzndoRrTDotTR5gDC --no-mdns --prometheus-external --rpc-external\n```\n\n----------------------------------------\n\nTITLE: Basic BTCLI Usage Command\nDESCRIPTION: Shows the basic command structure and global options for the Bittensor CLI tool\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli [OPTIONS] COMMAND [ARGS]...\n```\n\n----------------------------------------\n\nTITLE: Senate Voting with btcli sudo\nDESCRIPTION: Command for voting on senate proposals using the btcli sudo senate_vote command. Requires a proposal hash and allows specification of network, wallet details, and vote direction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_22\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo senate_vote --proposal <proposal_hash>\n```\n\n----------------------------------------\n\nTITLE: Querying BondsMovingAverage in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the BondsMovingAverage storage item for a specific network ID (netuid). It retrieves the moving average of bonds in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'BondsMovingAverage', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Converting Bond UIDs and Values to Tensor in Python\nDESCRIPTION: Converts bond and uids from chain representation into a numpy array. Takes the number of neurons, UIDs, and bonds as input and returns converted row bonds as a numpy float32 array.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef convert_bond_uids_and_vals_to_tensor(n, uids, bonds):\n    \"\"\"Converts bond and uids from chain representation into a np.array.\n\n    :param n: number of neurons on network.\n    :type n: int\n    :param uids: Tensor of uids as destinations for passed bonds.\n    :type uids: list[int]\n    :param bonds: Tensor of bonds.\n    :type bonds: list[int]\n\n    :returns: Converted row bonds.\n    :rtype: row_bonds (np.float32)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Subtensor Arguments in Python\nDESCRIPTION: Static method to add Subtensor-specific command line arguments to an ArgumentParser. Configures network settings, chain endpoints, and mock connections.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/types/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nparser = argparse.ArgumentParser()\nSubtensor.add_args(parser)\n```\n\n----------------------------------------\n\nTITLE: Using Dendrite Without Context Manager in Synchronous Context\nDESCRIPTION: Example showing how to use the Dendrite class without a context manager in a synchronous context. This approach requires manual session management.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/dendrite/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nd = dendrite(wallet = bittensor_wallet.Wallet() )\nprint(d)\nd( <axon> ) # ping axon\nd( [<axons>] ) # ping multiple\nd( bittensor.core.axon.Axon, bittensor.core.synapse.Synapse )\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Burn Cost using BTCLI in Bash\nDESCRIPTION: Commands to check the required burn cost for registering in a subnet. These are permissionless read operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets burn-cost\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets burn_cost\n```\n\n----------------------------------------\n\nTITLE: Loading Metagraph State Example\nDESCRIPTION: Example showing how to load a metagraph state from the default directory\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nmetagraph.load()\n```\n\n----------------------------------------\n\nTITLE: Querying Subtensor Storage in Bittensor (Python)\nDESCRIPTION: Retrieves specific data or parameters from the Subtensor module, such as stake, rank, or other neuron-specific attributes, providing valuable insights into the network's state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\ndef query_subtensor(name, block = None, params = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Running Weight Copy Simulation\nDESCRIPTION: Executes the weight copy simulation to model how different parameters affect the dividends of honest validators versus weight-copying validators. This is the core experiment that generates the data for analysis.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom weight_copy_simulation import WeightCopySimulation\nWeightCopySimulation(setup = setup).run_simulation()\n```\n\n----------------------------------------\n\nTITLE: Querying Module Storage in Bittensor Blockchain (Python)\nDESCRIPTION: Provides a generic query interface for flexible data retrieval from various blockchain modules, enhancing understanding of the network's state and dynamics.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\ndef query_module(module, name, block = None, params = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Querying BlockEmission in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the BlockEmission storage item. BlockEmission represents the total block emission value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'BlockEmission')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Running Subtensor Archive Node on Testchain\nDESCRIPTION: Execute the Subtensor node as an archive node connected to the testchain, using full sync, archive pruning, and testnet-specific bootnode configuration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n./target/production/node-subtensor --chain ./chainspecs/raw_spec_testfinney.json --base-path /tmp/blockchain --sync=full --pruning archive --port 30333 --max-runtime-instances 32 --rpc-max-response-size 2048 --rpc-cors all --rpc-port 9944 --bootnodes /dns/bootnode.test.finney.opentensor.ai/tcp/30333/ws/p2p/12D3KooWPM4mLcKJGtyVtkggqdG84zWrd7Rij6PGQDoijh1X86Vr --no-mdns --prometheus-external --rpc-external\n```\n\n----------------------------------------\n\nTITLE: Listing Subnets\nDESCRIPTION: Shows how to list all available subnets in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_4\n\nLANGUAGE: shell\nCODE:\n```\nbtcli subnet list\n```\n\n----------------------------------------\n\nTITLE: Calculating New Immunity Period for Commit Reveal in Python\nDESCRIPTION: This snippet shows how to calculate the new immunity period when updating the commit reveal interval. It ensures that the immunity period remains larger than the commit reveal interval to prevent premature miner deregistration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/commit-reveal.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnew_immunity_period = (new_commit_reveal_interval - old_commit_reveal_interval) + old_immunity_period\n```\n\n----------------------------------------\n\nTITLE: Creating Initialized AsyncSubtensor Instance for Bittensor (Python)\nDESCRIPTION: An asynchronous factory method that creates and initializes an AsyncSubtensor instance. This is useful when you don't want to manually call 'await subtensor.initialize()' after instantiation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_64\n\nLANGUAGE: python\nCODE:\n```\nasync def get_async_subtensor(network = None, config = None, _mock = False, log_verbose = False)\n```\n\n----------------------------------------\n\nTITLE: Registering Wallet by Burning TAO in Bittensor\nDESCRIPTION: Method to register a wallet to the Bittensor chain by recycling TAO tokens.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nburned_register(self, wallet: 'bittensor.Wallet', netuid: int, wait_for_inclusion: bool = False, wait_for_finalization: bool = True, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Key Last Block in Bittensor with Python\nDESCRIPTION: This example demonstrates how to retrieve the last block number of a transaction for a given hotkey, network ID, and name. It connects to the Finney test network and queries the blockchain for the most recent transaction block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nname = 1\nresult = substrate.query('SubtensorModule', 'TransactionKeyLastBlock', [hotkey, netuid, name])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Swapping Hotkeys in Bittensor Wallet\nDESCRIPTION: This command is used to swap the hotkey of a registered wallet for a new, unregistered hotkey on the Bittensor blockchain. It requires a fee of 1 TAO for recycling.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_52\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet swap-hotkey [OPTIONS] [DESTINATION_HOTKEY_NAME]\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet swap_hotkey destination_hotkey_name --wallet-name your_wallet_name --wallet-hotkey original_hotkey\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncSubstrateInterface in Python\nDESCRIPTION: This code snippet shows how to initialize AsyncSubstrateInterface, which is an asyncio rewrite of Polkadot's py-substrate-interface library. It demonstrates the use of an async context manager to handle the interface.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync with AsyncSubstrateInterface(chain_endpoint) as substrate:\n    block_hash = await substrate.get_chain_head()\n```\n\n----------------------------------------\n\nTITLE: Installing Rust for Subtensor Node\nDESCRIPTION: Install Rust programming language and update the environment, which is required for compiling Subtensor source code.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource ~/.cargo/env\n```\n\n----------------------------------------\n\nTITLE: Querying CommitRevealWeightsEnabled in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the CommitRevealWeightsEnabled storage item for a specific network ID (netuid). It checks whether the commit-reveal process for weights is enabled for a given network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'CommitRevealWeightsEnabled', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Revealing and Committing Weights with BTCLI\nDESCRIPTION: Commands for revealing and committing weights using BTCLI. These operations require an active validator permit on the subnet and are performed on the validator node (hotkey workstation).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/validators-btcli-guide.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli weights reveal\nbtcli weights commit\nbtcli wt reveal\nbtcli wt commit\nbtcli weight reveal\nbtcli weight commit\n```\n\n----------------------------------------\n\nTITLE: Setting a Single Child Hotkey in Bittensor\nDESCRIPTION: Example command to set a single child hotkey, specifying the subnet ID, child hotkey address, proportion, parent hotkey, and wallet name.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake set_children \\\n  --netuid 4 \\\n  --children 5HEXVAHY9gyavj5xnbov9Qoba4hPJYkkwwnq1MQFepLK7Gei \\\n  --proportions 0.5 \\\n  --hotkey 5DqJdDLU23m7yf6rZSmbLTshU7Bfn9eCTBkduhF4r9i73B9Y \\\n  --wallet.name Alice\n```\n\n----------------------------------------\n\nTITLE: Fetching All Subnets Information\nDESCRIPTION: Python function signature for retrieving information about all subnets at a certain block height or the current block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nall_subnets(\n    block_number: Optional[int] = None\n) -> List[DynamicInfo]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Balances for Multiple Coldkey Addresses in Bittensor (Python)\nDESCRIPTION: This asynchronous method fetches balances for multiple coldkey addresses simultaneously. Returns a dictionary mapping each address to its corresponding Balance object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nget_balances(*addresses, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Creating List of StakeInfo Objects from Byte Vector in Python\nDESCRIPTION: A class method that constructs multiple StakeInfo objects from a vector of bytes. Used for batch deserialization of stake information from the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/stake_info/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef list_from_vec_u8(vec_u8):\n    :classmethod:\n\n\n    Returns a list of StakeInfo objects from a ``vec_u8``.\n```\n\n----------------------------------------\n\nTITLE: Loading Metagraph State from a File Path\nDESCRIPTION: Shows how to load the state of a metagraph from a specified directory path. This allows for restoration of previously saved metagraph states.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\n\nnetuid = 1\nmetagraph = Metagraph(netuid=netuid)\n\nmetagraph.load_from_path(\"/path/to/dir\")\n```\n\n----------------------------------------\n\nTITLE: Mapping Hotkey to UID in Bittensor Network with Python\nDESCRIPTION: This example shows how to map a hotkey to its corresponding UID within a specific Bittensor subnet. It connects to the Finney test network and retrieves the UID associated with a hotkey generated from the '//Alice' seed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'Uids', [netuid, hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Account ID Decoder Function\nDESCRIPTION: Function to decode an AccountId from bytes to a Base64 string using SS58 encoding. Takes account_id_bytes as input and returns a decoded string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/utils/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef decode_account_id(account_id_bytes):\n    \"\"\"Decodes an AccountId from bytes to a Base64 string using SS58 encoding.\"\"\"\n    return str\n```\n\n----------------------------------------\n\nTITLE: Constructing a Synapse from HTTP Headers\nDESCRIPTION: Shows how to create a new Synapse instance from received HTTP headers, enabling reconstruction of a Synapse object after network transmission.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nreceived_headers = {\n    'bt_header_axon_address': '127.0.0.1',\n    'bt_header_dendrite_port': '8080',\n    # Other headers...\n}\nsynapse = Synapse.from_headers(received_headers)\n# synapse is a new Synapse instance reconstructed from the received headers\n```\n\n----------------------------------------\n\nTITLE: Analyzing Validator Performance\nDESCRIPTION: Calculates Mean Square Error between honest validator dividends with and without liquid alpha to evaluate parameter impact.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic_all_SN.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport torch.nn as nn\nloss = nn.MSELoss()\n\nbest_params['MSE'] = None\nfor idx, row in best_params.iterrows(): \n    original_div = div_rates[(div_rates.netuid == row.netuid) & (div_rates.cr_interval == row.cr_interval) & (div_rates.alpha_high == 0.9) & (div_rates.alpha_low == 0.9)]\n    original_div = torch.tensor(list(original_div.dividend.values))[0]\n    la_div = torch.tensor(list(row.dividend.values))\n    best_params.loc[idx, 'MSE'] = loss(original_div, la_div).item()\n\nbest_params\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Registrations using btcli (Shell)\nDESCRIPTION: This shell command demonstrates how to use the btcli wallet overview command to check subnet registrations. It displays the registrations to subnets by hotkeys controlled by the wallet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_25\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet overview\n```\n\n----------------------------------------\n\nTITLE: Querying Map Storage in Bittensor Blockchain (Python)\nDESCRIPTION: Retrieves map storage data from any module on the Bittensor blockchain. This method is useful for accessing complex and structured data within blockchain modules.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\ndef query_map(module, name, block = None, params = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Running Archive Node on Mainchain with Docker\nDESCRIPTION: This command starts a Subtensor archive node connected to the Bittensor mainchain using Docker. It uses the provided script with specific parameters for the network and node type.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/run/subtensor.sh -e docker --network mainnet --node-type archive\n```\n\n----------------------------------------\n\nTITLE: Querying Consensus Values in Python\nDESCRIPTION: Retrieves consensus values for UIDs in a network using the SubstrateInterface. Takes a netuid parameter and returns a vector of u16 values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'Consensus', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Difficulty Parameter for Subnet in Bittensor Network (Python)\nDESCRIPTION: This asynchronous method retrieves the 'Difficulty' hyperparameter for a specified subnet in the Bittensor network. The difficulty parameter affects the computational challenge required for neurons to participate in consensus and validation processes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndifficulty(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Async Burned Register Method\nDESCRIPTION: Method to register a neuron by recycling TAO tokens, allowing them to be re-mined through network work.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nasync def burned_register(wallet, netuid, wait_for_inclusion = False, wait_for_finalization = True):\n```\n\n----------------------------------------\n\nTITLE: Creating Local Copy of Hotkeys from Bittensor Metagraph in Python\nDESCRIPTION: Creates a local copy of hotkeys from the metagraph for querying and interacting with network entities. This helps maintain a reference to network participants.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nhotkeys = deepcopy(metagraph.hotkeys)\n```\n\n----------------------------------------\n\nTITLE: Verifying Bittensor SDK in Python interpreter\nDESCRIPTION: Python code to import bittensor and print its version number within the Python interpreter.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nprint( bt.__version__ )\n```\n\n----------------------------------------\n\nTITLE: Root Registration Method Python Definition\nDESCRIPTION: Method to register a neuron by recycling TAO tokens. Handles transaction inclusion and finalization on the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\ndef root_register(wallet, wait_for_inclusion = False, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Showing Subnet Details\nDESCRIPTION: Demonstrates how to display detailed information about a specific subnet (netuid 3).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_5\n\nLANGUAGE: shell\nCODE:\n```\nbtcli subnet show --netuid 3\n```\n\n----------------------------------------\n\nTITLE: Getting Current Block Number\nDESCRIPTION: Python function signature for retrieving the current chain block number.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nget_current_block() -> int\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to Hotkey in Bittensor\nDESCRIPTION: Method to add a specific amount of stake to a hotkey UID in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nadd_stake(self, wallet: 'bittensor.wallet', hotkey_ss58: Optional[str] = None, amount: Union[Balance, float] = None, wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Creating and Activating a Python Virtual Environment\nDESCRIPTION: Commands to create a Python virtual environment named btcli_venv and activate it. This is a prerequisite for installing btcli from source.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-btcli.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv btcli_venv\nsource btcli_venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Blockchain State Query Method Python Definition\nDESCRIPTION: Method for making direct state calls to the Bittensor blockchain for advanced queries with specific method calls and data inputs.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_64\n\nLANGUAGE: python\nCODE:\n```\ndef state_call(method, data, block = None)\n```\n\n----------------------------------------\n\nTITLE: Querying Used Work in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to query the global used work storage in the Bittensor network. It connects to the Finney test network and retrieves the work value associated with a specific binary key for proof of work validation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_51\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nkey = b\"some_key\"\nresult = substrate.query('SubtensorModule', 'UsedWork', [key])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Console Output for Unstaking Script (Console)\nDESCRIPTION: This console output shows the results of running the unstaking script, including slippage calculations, subnet prices, and current stake amounts for each subnet after unstaking.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_22\n\nLANGUAGE: console\nCODE:\n```\nEnter your password:\nDecrypting...\n\nslippage for subnet 119\n5.480567515602973\nnetuid 119 price τ0.027590441 stake Ⲃ2.899319570\nslippage for subnet 277\n22.534224516416796\nnetuid 277 price τ0.014730536 stake इ5.429337492\nslippage for subnet 18\n48.29992457746112\nnetuid 18 price τ0.001068362 stake σ65.558512653\nslippage for subnet 5\n36.680744412524845\nnetuid 5 price τ0.001785179 stake ε33.619312896\n\n...\n```\n\n----------------------------------------\n\nTITLE: Processing Simulation Results to Get Dividend Rates\nDESCRIPTION: Calls the get_relative_dividend_rate function with the experiment setup and sorts the results by the G value (relative dividend rate). Lower G values indicate more effective penalization of weight copiers.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndiv_rates = get_relative_dividend_rate(setup)\ndiv_rates.sort_values('G')\n```\n\n----------------------------------------\n\nTITLE: Querying Total Number of Networks in Bittensor with Python\nDESCRIPTION: This example shows how to query the total number of existing networks in the Bittensor ecosystem. It connects to the Finney test network and retrieves the count of all subnets in the system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TotalNetworks')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Serving Axon Extrinsic to Bittensor Network\nDESCRIPTION: Serves an axon to the Bittensor network with options for TLS certification and transaction confirmation. This registers the axon's availability for handling requests on the specified subnetwork.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/serving/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nserve_axon_extrinsic(subtensor, netuid, axon, wait_for_inclusion = False, wait_for_finalization = True, certificate = None)\n```\n\n----------------------------------------\n\nTITLE: Example BTCLI Configuration File\nDESCRIPTION: Sample YAML configuration file for btcli, typically located at ~/.bittensor/config.yml. It includes settings for chain, network, wallet keys, and metagraph columns.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-btcli.md#2025-04-22_snippet_4\n\nLANGUAGE: yaml\nCODE:\n```\nchain: ws://127.0.0.1:9945\nnetwork: local\nno_cache: False\nwallet_hotkey: hotkey-user1\nwallet_name: coldkey-user1\nwallet_path: ~/.bittensor/wallets\nmetagraph_cols:\n  ACTIVE: true\n  AXON: true\n  COLDKEY: true\n  CONSENSUS: true\n  DIVIDENDS: true\n  EMISSION: true\n  HOTKEY: true\n  INCENTIVE: true\n  RANK: true\n  STAKE: true\n  TRUST: true\n  UID: true\n  UPDATED: true\n  VAL: true\n  VTRUST: true\n```\n\n----------------------------------------\n\nTITLE: Retrieving Wallet Identity with Bittensor CLI\nDESCRIPTION: This command retrieves the identity information associated with a specific SS58 address on the Bittensor network. It requires providing a coldkey or hotkey SS58 address to query.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_40\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet get_identity --key <s58_address>\n```\n\n----------------------------------------\n\nTITLE: Subscribing Endpoint to Bittensor Chain\nDESCRIPTION: Subscribes a Bittensor endpoint to the subtensor chain, specifying network address, port, protocol, and network UID. This function registers the neuron's service endpoint on the blockchain for discovery by other participants.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/serving/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nserve_extrinsic(subtensor, wallet, ip, port, protocol, netuid, placeholder1 = 0, placeholder2 = 0, wait_for_inclusion = False, wait_for_finalization=True, certificate = None)\n```\n\n----------------------------------------\n\nTITLE: Querying Network Parameters in Python\nDESCRIPTION: Collection of queries for various network parameters including emission, registration counts, and scaling laws.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'PendingEmission', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Adding Stake to Validator Hotkey in Bittensor\nDESCRIPTION: Command to add stake to a validator's hotkey account within a subnet using btcli. Requires specifying the wallet name and hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake add --wallet.name <wallet name> --wallet.hotkey <your validating hotkey>\n```\n\n----------------------------------------\n\nTITLE: Creating a NeuronInfo instance from NeuronInfoLite and dictionaries in Python\nDESCRIPTION: Class method that creates a NeuronInfo object from a NeuronInfoLite instance and dictionaries containing weights and bonds. This allows constructing a full neuron representation from partial data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_info/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_weights_bonds_and_neuron_lite(neuron_lite, weights_as_dict, bonds_as_dict)\n```\n\n----------------------------------------\n\nTITLE: Serving Axon Endpoint\nDESCRIPTION: Asynchronous method to register an Axon serving endpoint on the network, enabling the neuron to handle incoming queries and process data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_50\n\nLANGUAGE: python\nCODE:\n```\nasync def serve_axon(netuid, axon, wait_for_inclusion = False, wait_for_finalization = True, certificate = None)\n```\n\n----------------------------------------\n\nTITLE: Accessing Validator Dividends in Bittensor Subnet\nDESCRIPTION: Demonstrates how to view the validator dividends in a Bittensor subnet using Python. It accesses the dividends data from the subnet's metagraph.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/working-with-subnets.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsubnet = bt.metagraph( netuid = 1 )\nprint ('subnet 1 validator dividends', subnet.D )\n```\n\n----------------------------------------\n\nTITLE: Regenerating Coldkey Public Key in Bittensor CLI\nDESCRIPTION: Command to regenerate the public part of a coldkey (coldkeypub.txt) using either a public key in hex format or an SS58 address. Useful when moving to a new machine for subnet mining.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_48\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen_coldkeypub --ss58_address 5DkQ4...\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-coldkeypub [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: xxHash 64-bit Hash Function for Substrate Storage\nDESCRIPTION: Function that calculates a 64-bit xxHash for the provided data, likely used as a component in other hashing operations for Substrate storage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef xxh64(data)\n```\n\n----------------------------------------\n\nTITLE: Fetching Delegated Stakes for a Coldkey in Python\nDESCRIPTION: This asynchronous method retrieves a list of delegates and their associated stakes for a given coldkey. It identifies the delegates that a specific account has staked tokens on.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nasync def get_delegated(coldkey_ss58, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Handling Low Priority Transaction Error in Bittensor CLI\nDESCRIPTION: This error occurs when submitting a duplicate transaction too quickly. The solution is to wait for a few minutes before running the command again.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1014, 'message': 'Priority is too low: (18446744073709551615 vs 18446744073709551615)', 'data': 'The transaction has too low priority to replace another transaction already in the pool.'}\n```\n\n----------------------------------------\n\nTITLE: Closing Synchronous Subtensor Connection in Python\nDESCRIPTION: This example shows how to properly close a synchronous Subtensor connection using the close() method after usage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/sdk/managing-subtensor-connections.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.subtensor(\"finney\")\n# subtensor calls\nsub.close()\n# instance and connection are terminated.\n```\n\n----------------------------------------\n\nTITLE: Setting Root Network Weights\nDESCRIPTION: Asynchronous method to set weights for the root network, allowing control of subnet influence.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_49\n\nLANGUAGE: python\nCODE:\n```\nasync def root_set_weights(wallet, netuids, weights, version_key = 0, wait_for_inclusion = True, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Querying AvgTempo in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the AvgTempo storage item. AvgTempo represents the global average tempo.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'AvgTempo')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Configuring and Using Logging in Python with Bittensor\nDESCRIPTION: This snippet demonstrates how to configure and use the logging functionality in Bittensor. It includes examples of turning on/off debug and trace logs, logging to files, and using different log levels.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\n\n# Turn on debug logs\nbt.debug()\n\n# Turn on trace logs\nbt.trace()\n\n# Turn off debug logs\nbt.set_debug(False)\n\n# Turn off trace logs\nbt.set_trace(False)\n\n# Turn on logging from class definition\nbt.logging( set_debug = True )\n\n# Instantiate logging from command line args\nbt.logging( bt.logging.config() )\n\n# Turn on logging to file\nbt.logging( record_log = True, logging_dir = '/path/to/logs/' )\n\n# Log\nbt.logging.info(message)\nbt.logging.debug(message)\nbt.logging.trace(message)\nbt.logging.success(message)\nbt.logging.critical(message)\nbt.logging.error(message)\n>>> 2023-05-29 09:27:25.426 |       INFO       | message\n\n# Log using prefix suffix design\nbt.logging.info(prefix, message)\nbt.logging.debug(prefix, message)\nbt.logging.trace(prefix, message)\nbt.logging.success(prefix, message)\nbt.logging.critical(prefix, message)\nbt.logging.error(prefix, message)\n>>> 2023-05-29 09:27:47.184 |       INFO       | cat                           dogs\n```\n\n----------------------------------------\n\nTITLE: TAO-based Subnet Registration\nDESCRIPTION: Commands for registering neurons by recycling TAO tokens. Verifies subnet existence and balance sufficiency before registration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_19\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets register --netuid 1\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet register [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Setting Root Weights in Python with New Function\nDESCRIPTION: The new function set_root_weights() must be used to set root weights, replacing the previous set_weights() function. This new function requires signing with the coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nset_root_weights()\n```\n\n----------------------------------------\n\nTITLE: Retrieving Vote Data\nDESCRIPTION: This method retrieves vote data associated with a given proposal hash. It is crucial for understanding the voting dynamics and outcomes within the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_vote_data(proposal_hash, block = None)\n\n\n```\n\n----------------------------------------\n\nTITLE: Calculating Emission Percentage for Individual Nominators in Bittensor\nDESCRIPTION: These LaTeX snippets demonstrate how to calculate the emission percentage for each nominator based on their stake contribution.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/delegation.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\text{emission for staker x from validator V} = \n  \\frac\n  { 100\\tau }\n  { 100\\tau + 70\\tau + 30\\tau } = 50\\%\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\text{emission for staker x from validator V} = \n  \\frac\n  { 70\\tau }\n  { 100\\tau + 70\\tau + 30\\tau } = 35\\%\n```\n\nLANGUAGE: latex\nCODE:\n```\n\\text{emission for staker x from validator V} = \n  \\frac\n  { 30\\tau }\n  { 100\\tau + 70\\tau + 30\\tau } = 15\\%\n```\n\n----------------------------------------\n\nTITLE: Retrieving Subnet Hyperparameter in Bittensor\nDESCRIPTION: Fetches a specific hyperparameter value for a subnet at a given blockchain block, which controls the behavior and rules of the subnet within the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef get_hyperparameter(param_name, netuid, block = None):\n      Retrieves a specified hyperparameter for a specific subnet.\n\n      :param param_name: The name of the hyperparameter to retrieve.\n      :type param_name: str\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: the block number at which to retrieve the hyperparameter.\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Alpha Out in Python\nDESCRIPTION: Shows how to query the amount of alpha in a subnet using the SubstrateInterface. Takes a netuid parameter and returns a u64 value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'SubnetAlphaOut', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Token Transfer Method Python Definition\nDESCRIPTION: Method to transfer tokens between wallets with options for complete transfer and connection management.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_68\n\nLANGUAGE: python\nCODE:\n```\ndef transfer(wallet, dest, amount, wait_for_inclusion = True, wait_for_finalization = False, transfer_all = False, keep_alive = True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Identities from Bittensor Network (Python)\nDESCRIPTION: This asynchronous method retrieves identity information for all delegates in the Bittensor network. The method allows specifying a block number or hash for historical queries.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nget_delegate_identities(block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Setting Validator Take with BTCLI\nDESCRIPTION: Command for setting the validator take using BTCLI. This operation requires sudo permissions and is performed on a coldkey workstation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/validators-btcli-guide.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set-take\n```\n\n----------------------------------------\n\nTITLE: Removing Stake from Multiple Hotkeys in Bittensor\nDESCRIPTION: Method to remove stake from multiple hotkeys to a common coldkey in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nunstake_multiple(self, wallet: 'bittensor.wallet', hotkey_ss58s: List[str], amounts: List[Union[Balance, float]] = None, wait_for_inclusion: bool = True, wait_for_finalization: bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Implementing StreamingSynapse Class\nDESCRIPTION: Abstract base class for handling streaming responses in Bittensor network. Provides methods for deserializing, processing streaming responses and extracting JSON data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/stream/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass StreamingSynapse(/, **data):\n   Bases: :py:obj:`bittensor.core.synapse.Synapse`, :py:obj:`abc.ABC`\n\n   @abstractmethod\n   async def process_streaming_response(response):\n       pass\n\n   @abstractmethod\n   def extract_response_json(response):\n       pass\n\n   def create_streaming_response(token_streamer):\n       pass\n```\n\n----------------------------------------\n\nTITLE: Using Custom Chain Endpoint in Bittensor CLI\nDESCRIPTION: This command demonstrates how to use a custom chain endpoint when swapping a hotkey using the Bittensor CLI. It shows the syntax for specifying a non-default network or chain endpoint.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-networks.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet swap_hotkey --subtensor.chain_endpoint wss://dev.chain.opentensor.ai:443\n```\n\n----------------------------------------\n\nTITLE: Retrieving Delegate Take Percentage in Python\nDESCRIPTION: This asynchronous method fetches the delegate 'take' percentage for a neuron identified by its hotkey. The 'take' represents the percentage of rewards that the delegate claims from its nominators' stakes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nasync def get_delegate_take(hotkey_ss58, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Limit in Python\nDESCRIPTION: Shows how to query the maximum number of networks allowed in the system. Returns a u16 value with default of 12.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'SubnetLimit')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Async Block Property\nDESCRIPTION: Property to asynchronously retrieve the current block from the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@property\nasync def block():\n```\n\n----------------------------------------\n\nTITLE: Querying Delegates in Python\nDESCRIPTION: Checks the delegation status of a hotkey account. Returns the delegation take value indicating if the key is open for delegation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'Delegates', [hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Setting Subnet Parameters with btcli sudo\nDESCRIPTION: Command for modifying subnet hyperparameters such as tempo using the btcli sudo set command. Requires netuid, parameter name, and new value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_24\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set --netuid 1 --param tempo --value 400\n```\n\n----------------------------------------\n\nTITLE: Revealing Weights for Bittensor Subnet\nDESCRIPTION: This command is used to reveal weights for a specific subnet in the Bittensor network. Users must specify the netuid, UIDs, weights, and corresponding salt values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_54\n\nLANGUAGE: bash\nCODE:\n```\nbtcli weights reveal [OPTIONS]\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wt reveal --netuid 1 --uids 1,2,3,4 --weights 0.1,0.2,0.3,0.4 --salt 163,241,217,11,161,142,147,189\n```\n\n----------------------------------------\n\nTITLE: Retrieving Neuron TLS Certificate in Python\nDESCRIPTION: This asynchronous method retrieves the TLS certificate for a specific neuron identified by its unique identifier (UID) within a specified subnet (netuid) of the Bittensor network. It's used for certificate discovery for setting up mutual TLS communication between neurons.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nasync def get_neuron_certificate(hotkey, netuid, block = None, block_hash = None, reuse_block = False):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Utilities Command Group Syntax\nDESCRIPTION: Base syntax for the btcli utils command group that contains utility functions like conversion.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_28\n\nLANGUAGE: bash\nCODE:\n```\nbtcli utils [OPTIONS] COMMAND [ARGS]...\n```\n\n----------------------------------------\n\nTITLE: Querying MinChildkeyTake in Python\nDESCRIPTION: Retrieves the minimum childkey take percentage for child-keys using the SubstrateInterface. Returns a u16 value representing percentage * 65535.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'MinChildkeyTake')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Alpha Emission in Python\nDESCRIPTION: Demonstrates how to query the amount of alpha entering a subnet per block using the SubstrateInterface. Takes a netuid parameter and returns a u64 value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'SubnetAlphaInEmission', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Async Bond Distribution Retrieval\nDESCRIPTION: Method to fetch the bond distribution between neurons in a specific subnet, showing investment and trust relationships.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def bonds(netuid, block = None, block_hash = None, reuse_block = False):\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Metagraph with btcli\nDESCRIPTION: Commands to display metagraph information for different subnets on mainnet (finney) or testnet. Includes options for network selection and data reuse.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_17\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet metagraph --netuid 0\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet metagraph --netuid 1 --network test\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet metagraph [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Displaying BadRequest Error in Bash\nDESCRIPTION: Illustrates the error message for unclassified errors in Subtensor transactions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_11\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 255'\n}\n```\n\n----------------------------------------\n\nTITLE: Wallet Balance Command Syntax\nDESCRIPTION: Syntax for the wallet balance command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_35\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet balance [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Converting Weight UIDs and Values to Tensor in Python\nDESCRIPTION: Converts weights and uids from chain representation into a numpy array or PyTorch FloatTensor. Takes the number of neurons, UIDs, and weights as input and returns converted row weights as a numpy float32 array or PyTorch FloatTensor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef convert_weight_uids_and_vals_to_tensor(n, uids, weights):\n    \"\"\"Converts weights and uids from chain representation into a np.array (inverse operation from\n    convert_weights_and_uids_for_emit).\n\n    :param n: number of neurons on network.\n    :type n: int\n    :param uids: Tensor of uids as destinations for passed weights.\n    :type uids: list[int]\n    :param weights: Tensor of weights.\n    :type weights: list[int]\n\n    :returns: Converted row weights.\n    :rtype: row_weights (np.float32 or torch.FloatTensor)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Converting AxonInfo to parameter dictionary\nDESCRIPTION: A method that converts the AxonInfo object to a torch tensor or dictionary depending on the USE_TORCH flag.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef to_parameter_dict():\n    \"\"\"Returns a torch tensor or dict of the subnet info, depending on the USE_TORCH flag set.\"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Minimum Required Stake in Bittensor\nDESCRIPTION: This method retrieves the minimum required stake for nominators within the Subtensor network, retrying calls if failures occur. It returns a Balance object representing the minimum required stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_minimum_required_stake()\n\n      Returns the minimum required stake for nominators in the Subtensor network.\n      This method retries the substrate call up to three times with exponential backoff in case of failures.\n\n      :returns: The minimum required stake as a Balance object.\n      :rtype: Balance\n\n      :raises Exception: If the substrate call fails after the maximum number of retries.\n```\n\n----------------------------------------\n\nTITLE: Utility Function Documentation for get_cpu_count()\nDESCRIPTION: A simple utility function that returns the number of CPUs available in the system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef get_cpu_count():\n    \"\"\"Returns the number of CPUs in the system.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Checking Registration Status with UID and SS58 Hotkey in Bittensor\nDESCRIPTION: Python script to check the registration status of a specific UID and hotkey combination in a Bittensor subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nhotkey = \"5HEo565WAy4Dbq3Sv271SAi7syBSofyfhhwRNjFNSM2gP9M2\"\nnetwork = \"finney\"\nnetuid = 1 # subnet uid\nsub = bt.subtensor(network)\nmg = sub.metagraph(netuid)\nuid = 2 # Your UID\nregistered = mg.hotkeys[uid] == hotkey\nif not registered:\n  print(f\"Miner at uid {uid} not registered\")\nelse:\n  print(f\"Miner at uid {uid} registered\")\n```\n\n----------------------------------------\n\nTITLE: Monitoring Subnet Status with BTCLI\nDESCRIPTION: Use these commands to view subnet information without any special permissions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/subnet-creators-btcli-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet show\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli view dashboard\n```\n\n----------------------------------------\n\nTITLE: Staking Operations in Bittensor CLI\nDESCRIPTION: Commands for managing stakes, including adding, removing, listing, moving, and transferring stakes. Also includes commands for managing child stakes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake add\nbtcli stake remove\nbtcli stake list\nbtcli stake move\nbtcli stake transfer\nbtcli stake swap\nbtcli stake child get\nbtcli stake child set\nbtcli stake child revoke\nbtcli stake child take\nbtcli stake children get\nbtcli stake children set\nbtcli stake children revoke\nbtcli stake children take\n```\n\n----------------------------------------\n\nTITLE: Querying Total Token Issuance in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to retrieve the total issuance of tokens on the Bittensor network. It connects to the Finney test network and queries the total number of tokens in circulation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TotalIssuance')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Hyperparameters with btcli subnet hyperparameters\nDESCRIPTION: This command shows a list of hyperparameters for the specified subnet. It requires the netuid of the subnet to be specified.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo get --netuid 1\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet hyperparameters [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Children for a Hotkey in a Subnet (Python)\nDESCRIPTION: This asynchronous method retrieves the children associated with a specific hotkey and network UID. It queries the SubtensorModule's ChildKeys storage and returns a tuple containing success status, formatted children list, and any error messages.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nget_children(hotkey, netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Minimum Required Stake in Python\nDESCRIPTION: This asynchronous method returns the minimum required stake for nominators in the Subtensor network. It retries the substrate call up to three times with exponential backoff in case of failures.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nasync def get_minimum_required_stake():\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: String Representation of Subtensor Instance in Python\nDESCRIPTION: These methods provide string representations of a Subtensor instance. They return information about the connection to the chain endpoint or network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nstr(obj)\n```\n\nLANGUAGE: python\nCODE:\n```\nrepr(obj)\n```\n\n----------------------------------------\n\nTITLE: Querying CRV3WeightCommits in Python\nDESCRIPTION: Retrieves v3 weight commits for an account based on netuid and epoch. Returns a vector deque containing account IDs, byte vectors and timestamps.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\ncommit_epoch = 100\nresult = substrate.query('SubtensorModule', 'CRV3WeightCommits', [netuid, commit_epoch])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Configuring Sync Bittensor Subtensor for Test Network\nDESCRIPTION: Python code snippet showing how to import and configure the Bittensor Subtensor for synchronous calls to the test network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.Subtensor(network=\"test\")\n```\n\n----------------------------------------\n\nTITLE: Decoding Hex-Encoded Strings in Dictionary\nDESCRIPTION: Function that traverses a dictionary, identifies hex-encoded strings, and decodes them into readable strings. It handles nested dictionaries and lists within the dictionary, converting hexadecimal representations to human-readable text.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef decode_hex_identity_dict(info_dictionary):\n   \"\"\"Decodes hex-encoded strings in a dictionary.\n\n   This function traverses the given dictionary, identifies hex-encoded strings, and decodes them into readable\n       strings. It handles nested dictionaries and lists within the dictionary.\n\n   :param info_dictionary: The dictionary containing hex-encoded strings to decode.\n   :type info_dictionary: dict\n\n   :returns: The dictionary with decoded strings.\n   :rtype: dict\n\n   .. admonition:: Examples\n\n      input_dict = {\n      ...     \"name\": {\"value\": \"0x6a6f686e\"},\n      ...     \"additional\": [\n      ...         [{\"data\": \"0x64617461\"}]\n      ...     ]\n      ... }\n      decode_hex_identity_dict(input_dict)\n      {'name': 'john', 'additional': [('data', 'data')]}\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating TAO to Alpha Token Exchange Rate\nDESCRIPTION: Python method for estimating the amount of Alpha tokens received for a given amount of TAO, ignoring slippage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntao_to_alpha(self, tao: Union[Balance, float, int]) -> Balance:\n```\n\n----------------------------------------\n\nTITLE: Displaying SubnetDoesntExist Error in Bash\nDESCRIPTION: Shows the error message when attempting to interact with a non-existent subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 3'\n}\n```\n\n----------------------------------------\n\nTITLE: Sending OCRSynapse Queries from Validator to Miners\nDESCRIPTION: Code showing how a validator creates an OCRSynapse object with image data and uses the dendrite client to query miners. The serialized image is sent to selected miners for processing.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Create synapse object to send to the miner and attach the image.\n# convert PIL image into a json serializable format\nsynapse = OCRSynapse(base64_image = serialize_image(image))\n# The dendrite client of the validator queries the miners in the subnet\nresponses = self.dendrite.query(\n    # Send the query to selected miner axons in the network.\n    axons=[self.metagraph.axons[uid] for uid in miner_uids],\n    # Pass the synapse to the miner.\n    synapse=synapse,\n...\n)\n```\n\n----------------------------------------\n\nTITLE: DelegatesDetails Class Definition for Bittensor Network in Python\nDESCRIPTION: A class designed to store and manage details about delegates in the Bittensor network. It contains attributes for storing display name, contact information (email, web, twitter, riot), legal information, PGP fingerprint, and additional custom data as tuples.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/delegates_details/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass DelegatesDetails:\n\n   additional = list[tuple[str, str]]\n   display = str\n   email = Optional[str] = None\n   image = Optional[str] = None\n   legal = Optional[str] = None\n   pgp_fingerprint = Optional[str] = None\n   riot = Optional[str] = None\n   twitter = Optional[str] = None\n   web = str\n\n   @classmethod\n   def from_chain_data(data)\n```\n\n----------------------------------------\n\nTITLE: Creating a NeuronInfo instance from a byte vector in Python\nDESCRIPTION: Class method that instantiates a NeuronInfo object from a serialized byte vector. This method converts the binary representation back into a structured NeuronInfo object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Synchronizing AsyncMetagraph with Network in Python\nDESCRIPTION: Asynchronously synchronizes the metagraph with the current state of the Bittensor network. It updates various attributes to reflect the latest network data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nasync def sync(block = None, lite = True, subtensor = None):\n    # ... implementation details ...\n```\n\n----------------------------------------\n\nTITLE: LoggingConfig Class Definition - Python\nDESCRIPTION: Named tuple class that holds logging configuration parameters including debug, info, logging directory, record log, and trace settings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/loggingmachine/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass LoggingConfig(NamedTuple):\n    debug: bool\n    info: bool\n    logging_dir: str\n    record_log: bool\n    trace: bool\n```\n\n----------------------------------------\n\nTITLE: Registering a Wallet to Bittensor Root Network in Python\nDESCRIPTION: Asynchronous function for registering a wallet to the Bittensor root network. Takes a subtensor object, wallet, and flags for transaction confirmation behavior. Returns True if the registration was successful or if confirmation flags are disabled.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/root/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def root_register_extrinsic(subtensor, wallet, wait_for_inclusion = True, wait_for_finalization = True):\n   \"\"\"\n   Registers the wallet to root network.\n\n   :param subtensor: The AsyncSubtensor object\n   :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n   :param wallet: Bittensor wallet object.\n   :type wallet: bittensor_wallet.Wallet\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                              `False` if the extrinsic fails to enter the block within the timeout.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning\n                                 `True`, or returns `False` if the extrinsic fails to be finalized within the timeout.\n   :type wait_for_finalization: bool\n\n   :returns:\n\n             `True` if extrinsic was finalized or included in the block. If we did not wait for finalization/inclusion,\n                 the response is `True`.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Error Responses in Bittensor Axon Server (Python)\nDESCRIPTION: This function creates an error response based on the provided synapse object. It returns a JSON response with a status code and content indicating the error message.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef create_error_response(synapse):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Base Miner Implementation Using Pytesseract\nDESCRIPTION: Implementation of the base OCR miner that uses pytesseract to extract text data from images. This code represents the baseline functionality that miners can improve upon.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pytesseract\n# Extracts text data from image using pytesseract. This is the baseline miner.\ndef miner(image, merge=True, sort=True)\n...\nresponse = miner(noisy_image, merge=True)\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Registration Price using BTCLI in Bash\nDESCRIPTION: Command to check the price required to register in a particular subnet. This is a permissionless read operation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets price\n```\n\n----------------------------------------\n\nTITLE: Asynchronous Subnet Existence Checks Using AsyncSubtensor in Python\nDESCRIPTION: This snippet demonstrates using Python's asyncio module with Bittensor's AsyncSubtensor class to perform concurrent subnet existence checks efficiently. It uses a single websocket connection for multiple requests.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.async_subtensor import AsyncSubtensor\nimport asyncio\n\nasync def main():\n    async with AsyncSubtensor(\"test\") as subtensor:\n        block_hash = await subtensor.get_block_hash()\n        subnets = await asyncio.gather(*[subtensor.subnet_exists(netuid, block_hash=block_hash) for netuid in range(1, 8)])\n        for i, subnet in enumerate(subnets):\n            print(\"subnet \" + str(1+i) + \" exists: \" + str(subnet))             \n\nasyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: IP Address Conversion Utilities\nDESCRIPTION: Collection of functions for converting between integer and string representations of IP addresses, determining IP versions, and formatting IP strings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/networking/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef int_to_ip(int_val):\n    \"\"\"Maps an integer to a unique ip-string\n    :param int_val: The integer representation of an ip. Must be in the range (0, 3.4028237e+38).\n    :type int_val: int\n    :returns: The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n    :rtype: str_val (str)\n    :raises netaddr.core.AddrFormatError (Exception): Raised when the passed int_vals is not a valid ip int value.\n    \"\"\"\n\ndef ip_to_int(str_val):\n    \"\"\"Maps an ip-string to a unique integer.\n    arg:\n        str_val (:tyep:`str`, `required):\n            The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n    :returns: The integer representation of an ip. Must be in the range (0, 3.4028237e+38).\n    :rtype: int_val  (:type:`int128`, `required`)\n    :raises netaddr.core.AddrFormatError (Exception): Raised when the passed str_val is not a valid ip string value.\n    \"\"\"\n\ndef ip_version(str_val):\n    \"\"\"Returns the ip version (IPV4 or IPV6).\n    arg:\n        str_val (:tyep:`str`, `required):\n            The string representation of an ip. Of form *.*.*.* for ipv4 or *::*:*:*:* for ipv6\n    :returns: The ip version (Either 4 or 6 for IPv4/IPv6)\n    :rtype: int_val  (:type:`int128`, `required`)\n    :raises netaddr.core.AddrFormatError (Exception): Raised when the passed str_val is not a valid ip string value.\n    \"\"\"\n\ndef ip__str__(ip_type, ip_str, port):\n    \"\"\"Return a formatted ip string\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing cast_dtype Function in Python\nDESCRIPTION: This function casts a raw value to a string representing the numpy or torch data type. It handles various input types and raises an exception for invalid inputs.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/tensor/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef cast_dtype(raw):\n    Casts the raw value to a string representing the `numpy data type <https://numpy.org/doc/stable/user/basics.types.html>`_, or the `torch data type <https://pytorch.org/docs/stable/tensor_attributes.html>`_ if using torch.\n\n    :param raw: The raw value to cast.\n    :type raw: Union[None, numpy.dtype, torch.dtype, str]\n\n    :returns: The string representing the numpy/torch data type.\n    :rtype: str\n\n    :raises Exception: If the raw value is of an invalid type.\n```\n\n----------------------------------------\n\nTITLE: Defining DynamicInfo Class Structure\nDESCRIPTION: Python dataclass definition for the DynamicInfo object, which encapsulates the state of a subnet with all new attributes for Dynamic TAO.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass DynamicInfo:\n    netuid: int\n    owner_hotkey: str\n    owner_coldkey: str\n    subnet_name: str\n    symbol: str\n    tempo: int\n    last_step: int\n    blocks_since_last_step: int\n    emission: Balance\n    alpha_in: Balance\n    alpha_out: Balance\n    tao_in: Balance\n    price: Balance\n    k: float\n    is_dynamic: bool\n    alpha_out_emission: Balance\n    alpha_in_emission: Balance\n    tao_in_emission: Balance\n    pending_alpha_emission: Balance\n    pending_root_emission: Balance\n    network_registered_at: int\n    subnet_identity: Optional[SubnetIdentity]\n```\n\n----------------------------------------\n\nTITLE: Setting Child Hotkey Take with btcli stake child take\nDESCRIPTION: This command sets a new take value for a child hotkey on a specified subnet. The take value must be between 0 and 18%.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child take --hotkey <child_hotkey> --take 0.12 --netuid 1\n```\n\n----------------------------------------\n\nTITLE: Serving Prometheus in Bittensor Network\nDESCRIPTION: Method to start serving a Prometheus server on a specific port for a given network UID in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nserve_prometheus(self, wallet: 'bittensor.wallet', port: int, netuid: int, wait_for_inclusion: bool = False, wait_for_finalization: bool = True) -> bool\n```\n\n----------------------------------------\n\nTITLE: Extrinsic Transaction Method Python Definition\nDESCRIPTION: Helper method to sign and submit extrinsic calls to the blockchain with various signing options and inclusion controls.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_63\n\nLANGUAGE: python\nCODE:\n```\ndef sign_and_send_extrinsic(call, wallet, wait_for_inclusion = True, wait_for_finalization = False, sign_with = 'coldkey')\n```\n\n----------------------------------------\n\nTITLE: Setting Network UID for Bittensor Analysis\nDESCRIPTION: Sets the network UID (netuid) variable to 17, which identifies the specific subnet being analyzed in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnetuid = 17\n```\n\n----------------------------------------\n\nTITLE: Capped Alpha Reserve Injection in Bittensor Network\nDESCRIPTION: This formula introduces a cap on alpha injection to prevent runaway inflation. It uses the minimum of the calculated injection and a predefined alpha emission rate.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\Delta\\alpha_i = \\min\\left\\{\n  \\frac\n    {\\Delta\\bar{\\tau}}\n    {\\sum_{j \\in \\mathbb{S}}\n  \\bigl(p_j)},\n  \\Delta\\bar{\\alpha_i} \\right\\}\n\n$$\n```\n\n----------------------------------------\n\nTITLE: Converting from parameter dictionary to AxonInfo object\nDESCRIPTION: A class method that creates an AxonInfo object from a torch parameter dictionary.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_parameter_dict(parameter_dict):\n    \"\"\"\n    Returns an axon_info object from a torch parameter_dict or a parameter dict.\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: DelegateInfo Class Attributes in Bittensor (Python)\nDESCRIPTION: Attribute definitions for the DelegateInfo class showing property types. These attributes store critical information about delegates including stake amounts, network permissions, and return calculations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/delegate_info/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n   hotkey_ss58: str\n   nominators: list[tuple[str, bittensor.utils.balance.Balance]]\n   owner_ss58: str\n   registrations: list[int]\n   return_per_1000: bittensor.utils.balance.Balance\n   take: float\n   total_daily_return: bittensor.utils.balance.Balance\n   total_stake: bittensor.utils.balance.Balance\n   validator_permits: list[int]\n```\n\n----------------------------------------\n\nTITLE: Retrieving Total Number of Subnets\nDESCRIPTION: This method retrieves the total number of subnets within the Bittensor network at a specific blockchain block, which is useful for understanding network growth.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_total_subnets(block = None)\n\n      Retrieves the total number of subnets within the Bittensor network as of a specific blockchain block.\n\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The total number of subnets in the network.\n      :rtype: Optional[str]\n\n      Understanding the total number of subnets is essential for assessing the network's growth and the extent of its\n          decentralized infrastructure.\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Subtensor Methods for Token Operations\nDESCRIPTION: Methods in the MockSubtensor class that simulate token-related operations such as transfers, fee calculations, and stake management without requiring an actual blockchain connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef get_transfer_fee(wallet, dest, value):\n\n      Calculates the transaction fee for transferring tokens from a wallet to a specified destination address. This\n          function simulates the transfer to estimate the associated cost, taking into account the current network\n          conditions and transaction complexity.\n\n      :param wallet: The wallet from which the transfer is initiated.\n      :type wallet: bittensor_wallet.Wallet\n      :param dest: The ``SS58`` address of the destination account.\n      :type dest: str\n      :param value: The amount of tokens to be transferred,\n                    specified as a Balance object, or in Tao (float) or Rao (int) units.\n      :type value: Union[bittensor.utils.balance.Balance, float, int]\n\n      :returns:\n\n                The estimated transaction fee for the transfer, represented as a Balance\n                    object.\n      :rtype: bittensor.utils.balance.Balance\n\n      Estimating the transfer fee is essential for planning and executing token transactions, ensuring that the wallet\n          has sufficient funds to cover both the transfer amount and the associated costs. This function provides a\n          crucial tool for managing financial operations within the Bittensor network.\n```\n\nLANGUAGE: python\nCODE:\n```\ndef do_transfer(wallet, dest, transfer_balance, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\nLANGUAGE: python\nCODE:\n```\ndef force_set_balance(ss58_address, balance = Balance(0)):\n\n      :returns: (success, err_msg)\n      :rtype: tuple[bool, Optional[str]]\n```\n\n----------------------------------------\n\nTITLE: Filtering Network UIDs by Registered Hotkeys in Bittensor (Python)\nDESCRIPTION: This asynchronous method filters a list of network UIDs based on specific criteria including registered hotkeys. It evaluates which UIDs should be included based on the provided filters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfilter_netuids_by_registered_hotkeys(all_netuids, filter_for_netuids, all_hotkeys, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Querying ChildkeyTake in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the ChildkeyTake storage item for a specific hotkey and network ID (netuid). It retrieves the childkey take for a given hotkey on a specific subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ChildkeyTake', [hotkey, netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating a Coldkey-Only Wallet with btcli\nDESCRIPTION: Command to create a new coldkey-only wallet using the btcli tool. This is suitable for users who don't need to mine, validate, or participate in governance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet new_coldkey --wallet.name <my_coldkey>\n```\n\n----------------------------------------\n\nTITLE: Custom Synapse Deserialization Example in Python\nDESCRIPTION: Demonstrates how to create a custom Synapse subclass with a specialized deserialize method. This example shows how to handle additional data fields and perform custom deserialization logic such as decoding base64-encoded content.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass CustomSynapse(Synapse):\n    additional_data: str\n\n    def deserialize(self) -> \"CustomSynapse\":\n        # Custom deserialization logic\n        # For example, decoding a base64 encoded string in 'additional_data'\n        if self.additional_data:\n            self.additional_data = base64.b64decode(self.additional_data).decode('utf-8')\n        return self\n\nserialized_data = '{\"additional_data\": \"SGVsbG8gV29ybGQ=\"}'  # Base64 for 'Hello World'\ncustom_synapse = CustomSynapse.model_validate_json(serialized_data)\ndeserialized_synapse = custom_synapse.deserialize()\n```\n\n----------------------------------------\n\nTITLE: Loading Metagraph From Custom Path Example\nDESCRIPTION: Example demonstrating how to load a metagraph state from a specific directory path\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndir_path = \"/path/to/saved/metagraph/states\"\nmetagraph.load_from_path(dir_path)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Burn Hyperparameter in Bittensor (Python)\nDESCRIPTION: Fetches the 'Burn' hyperparameter for a specified subnet, representing the amount of Tao recycled within the network. This is crucial for analyzing network registration usage and participation costs.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\ndef recycle(netuid, block = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Rendering Subnet Cards in JSX\nDESCRIPTION: This code snippet demonstrates how to render a grid of cards representing different subnets using JSX. It uses custom components like Cards and CardSmall to create a visually appealing layout. Each card contains an icon, title, link, and brief description of the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_subnet-pages/index.md#2025-04-22_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\n<Cards>\n    <CardSmall\n    icon={SiRootssage}\n    title='Subnet 0'\n    link='/subnet-pages/subnet-0'\n    body='root subnet' />\n</Cards>\n\n<Cards>\n    <CardSmall\n    icon={() => <span style={{ fontSize: '1.2rem', paddingBottom: '0.4rem', display: 'inline-block' }}>α</span>}\n    title='Subnet 1'\n    link='/subnet-pages/subnet-1'\n    body='text prompting' />\n    <CardSmall\n    icon={() => <span style={{ fontSize: '1.2rem', paddingBottom: '0.4rem', display: 'inline-block' }}>β</span>}\n    title='Subnet 2'\n    link='/subnet-pages/subnet-2'\n    body='Omron' />\n    <CardSmall\n    icon={() => <span style={{ fontSize: '1.2rem', paddingBottom: '0.4rem', display: 'inline-block' }}>γ</span>}\n    title='Subnet 3'\n    link='/subnet-pages/subnet-3'\n    body='data scraping' />\n    <CardSmall\n    icon={() => <span style={{ fontSize: '1.2rem', paddingBottom: '0.4rem', display: 'inline-block' }}>Δ</span>}\n    title='Subnet 4'\n    link='/subnet-pages/subnet-4'\n    body='Targon' />\n</Cards>\n```\n\n----------------------------------------\n\nTITLE: Querying ParentKeys in Python\nDESCRIPTION: Maps child keys to parent keys with proportions for a specific network ID.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nchild = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ParentKeys', [child, netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Querying AdjustmentAlpha in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the AdjustmentAlpha storage item for a specific network ID (netuid). AdjustmentAlpha represents the alpha adjustment value for the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'AdjustmentAlpha', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Running Subtensor Archive Node on Mainchain\nDESCRIPTION: Execute the Subtensor node as an archive node connected to the mainchain, using full sync and archive pruning for complete historical data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./target/production/node-subtensor --chain ./chainspecs/raw_spec_finney.json --base-path /tmp/blockchain --sync=full --pruning archive --port 30333 --max-runtime-instances 32 --rpc-max-response-size 2048 --rpc-cors all --rpc-port 9944 --bootnodes /dns/bootnode.finney.chain.opentensor.ai/tcp/30333/ws/p2p/12D3KooWRwbMb85RWnT8DSXSYMWQtuDwh4LJzndoRrTDotTR5gDC --no-mdns --prometheus-external --rpc-external\n```\n\n----------------------------------------\n\nTITLE: Creating ScheduledColdkeySwapInfo from Vector Data in Python\nDESCRIPTION: Classmethod that parses a vector of unsigned 8-bit integers and converts it into a ScheduledColdkeySwapInfo object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/scheduled_coldkey_swap_info/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Querying Axons in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the Axons storage item for a specific network ID (netuid) and hotkey. It retrieves axon information for a given hotkey within a network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'Axons', [netuid, hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Defining BTStreamingResponseModel Class\nDESCRIPTION: Pydantic model that encapsulates a token streamer callable. Used for validation and creating streaming responses. The token_streamer attribute takes a send function and returns an awaitable.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/stream/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass BTStreamingResponseModel(/, **data):\n   Bases: :py:obj:`pydantic.BaseModel`\n   token_streamer: Callable[[starlette.types.Send], Awaitable[None]]\n```\n\n----------------------------------------\n\nTITLE: Creating NeuronCertificate from Vector Data in Python\nDESCRIPTION: Static method to construct a NeuronCertificate object from a vector of unsigned 8-bit integers (vec_u8). This enables deserialization of certificate data from a binary format, likely used for blockchain data interchange.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_certificate/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Querying Runtime API in Bittensor Blockchain (Python)\nDESCRIPTION: Interacts with the blockchain's runtime API, allowing advanced users to retrieve data encoded in Scale Bytes format and access deeper layers of the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_54\n\nLANGUAGE: python\nCODE:\n```\ndef query_runtime_api(runtime_api, method, params = None, block = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Navigating to Subtensor Directory\nDESCRIPTION: This command changes the current directory to the cloned Subtensor repository. It's necessary to execute subsequent commands from within this directory.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd subtensor\n```\n\n----------------------------------------\n\nTITLE: Calculating Local Voting Power in Dynamic TAO\nDESCRIPTION: This LaTeX equation calculates a hotkey's local voting power in a subnet, which is the product of the subnet's total voting power (τ_in) and the hotkey's stake share (α / α_out).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_weights-dtao.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$ \n\\tau_{in}\\times\\text{hotkey's stake share} = \\tau_{in}\\times\\frac{\\alpha}{\\alpha_{out}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Viewing Hotkey Information\nDESCRIPTION: Bash command to display the information of a hotkey, including both public and private data (for unencrypted hotkeys).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/working-with-keys.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\ncat hotkeys/test-hotkey | jq\n```\n\n----------------------------------------\n\nTITLE: Setting Up Subtensor Network Configuration\nDESCRIPTION: Static method that determines and configures the appropriate network and chain endpoint based on provided parameters and configuration object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/types/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef setup_config(network, config):\n    \"\"\"Sets up and returns the configuration for the Subtensor network and endpoint.\n\n    This method determines the appropriate network and chain endpoint based on the provided network string or\n        configuration object. It evaluates the network and endpoint in the following order of precedence:\n        1. Provided network string.\n        2. Configured chain endpoint in the `config` object.\n        3. Configured network in the `config` object.\n        4. Default chain endpoint.\n        5. Default network.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying BlockAtRegistration in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the BlockAtRegistration storage item for a specific network ID (netuid) and UID. It retrieves the block number at registration for a given UID.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nuid = 123\nresult = substrate.query('SubtensorModule', 'BlockAtRegistration', [netuid, uid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Saving Metagraph State Example\nDESCRIPTION: Example showing how to save the current metagraph state and subsequently load it back\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nmetagraph.save()\n\n# Loading saved state using default path\nmetagraph.load()\n\n# Loading saved state using custom path\nmetagraph.load_from_path(dir_path)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Minimum Allowed Weights Hyperparameter in Bittensor (Python)\nDESCRIPTION: Returns the MinAllowedWeights hyperparameter for a specific subnet. This parameter sets the minimum threshold for weight assignments and is important for network participation requirements.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_45\n\nLANGUAGE: python\nCODE:\n```\ndef min_allowed_weights(netuid, block = None):\n    \"\"\"\n    Returns network MinAllowedWeights hyperparameter.\n\n    :param netuid: The unique identifier of the subnetwork.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns:\n\n              The value of the MinAllowedWeights hyperparameter, or ``None`` if the subnetwork does not\n                  exist or the parameter is not found.\n    :rtype: Optional[int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Downloading Metagraph Data\nDESCRIPTION: Downloads required metagraph data for the experiment using the configured setup parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic_all_SN.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom download_metagraphs import DownloadMetagraph\nDownloadMetagraph(setup = setup).run()\n```\n\n----------------------------------------\n\nTITLE: Importing Coldkey Public Key in Bittensor CLI\nDESCRIPTION: This command imports a coldkey public key into the Bittensor CLI, allowing for permissionless operations such as viewing balances and blockchain information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/coldkey-hotkey-security.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbtcli w regen-coldkeypub --ss58 <YOUR COLDKEY PUBLIC KEY>\n```\n\n----------------------------------------\n\nTITLE: Deserialization Methods for DelegateInfo in Bittensor (Python)\nDESCRIPTION: Class methods for deserializing delegate information from byte vectors. These methods include functionality to convert raw blockchain data into structured delegate objects.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/delegate_info/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n   @classmethod\n   def delegated_list_from_vec_u8(vec_u8)\n\n   @classmethod\n   def from_vec_u8(vec_u8)\n\n   @classmethod\n   def list_from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Computing Validator Emissions Share in Yuma Consensus\nDESCRIPTION: This LaTeX equation calculates a validator's share of validator emissions based on the sum of its bonds to miners, weighted by the miner's total emissions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_7\n\nLANGUAGE: latex\nCODE:\n```\nV_i = \\sum_{j \\in \\mathbb{M}} \\Bigl(\\,B_{ij} \\,\\times\\, M_j\\Bigr)\n```\n\n----------------------------------------\n\nTITLE: Advanced Wallet Identity Options in Bittensor CLI\nDESCRIPTION: Shows the full command syntax for getting wallet identity, including all available options. This command allows querying identity information with various configuration options including network selection and verbosity settings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_41\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet get-identity [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Internal Serving Function for Axon Transactions in Python\nDESCRIPTION: Asynchronous internal method that submits a serve axon transaction to the Bittensor blockchain. It enables a neuron's Axon to serve requests on the network with specified call parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/serving/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def do_serve_axon(subtensor, wallet, call_params, wait_for_inclusion = False, wait_for_finalization = True):\n    \"\"\"\n    Internal method to submit a serve axon transaction to the Bittensor blockchain. This method creates and submits a\n        transaction, enabling a neuron's ``Axon`` to serve requests on the network.\n\n    :param subtensor: Subtensor instance object.\n    :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n    :param wallet: The wallet associated with the neuron.\n    :type wallet: bittensor_wallet.Wallet\n    :param call_params: Parameters required for the serve axon call.\n    :type call_params: bittensor.core.types.AxonServeCallParams\n    :param wait_for_inclusion: Waits for the transaction to be included in a block.\n    :type wait_for_inclusion: bool\n    :param wait_for_finalization: Waits for the transaction to be finalized on the blockchain.\n    :type wait_for_finalization: bool\n\n    :returns: A tuple containing a success flag and an optional error message.\n    :rtype: tuple[bool, Optional[str]]\n\n    This function is crucial for initializing and announcing a neuron's ``Axon`` service on the network, enhancing the\n        decentralized computation capabilities of Bittensor.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Decoding Account ID List in Python\nDESCRIPTION: Classmethod that decodes a list of AccountIds from a vector of unsigned 8-bit integers (vec_u8).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/scheduled_coldkey_swap_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef decode_account_id_list(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Signing and Sending Transactions with Nonce in Python\nDESCRIPTION: This helper function signs and sends transactions with a nonce on the Bittensor blockchain. It's used internally by the commit_weights and reveal_weights functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/commit_weights/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef sign_and_send_with_nonce(subtensor, call, wallet, wait_for_inclusion, wait_for_finalization):\n```\n\n----------------------------------------\n\nTITLE: Querying MinAllowedWeights in Python\nDESCRIPTION: Queries the minimum allowed weights for a specific network using the SubstrateInterface. Requires netuid parameter and returns a u16 value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'MinAllowedWeights', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating WeightCommitInfo from Vector Data in Python\nDESCRIPTION: A class method that creates a WeightCommitInfo instance from tuple data containing account ID, commit data, and round number. This method decodes the raw blockchain data into a structured WeightCommitInfo object.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/weight_commit_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_vec_u8(data):\n    \"\"\"\n    Creates a WeightCommitInfo instance\n\n    :param data: Tuple containing ((AccountId,), (commit_data,), round_number)\n    :type data: tuple\n\n    :returns: A new instance with the decoded data\n    :rtype: WeightCommitInfo\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Synchronizing Metagraph with Bittensor Network in Python\nDESCRIPTION: Updates the metagraph to reflect the latest state of the Bittensor network. This ensures the metagraph contains current information about neurons and network status.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmetagraph.sync(subtensor=subtensor)\n```\n\n----------------------------------------\n\nTITLE: Calculating Proportional Emissions to Alpha Stakers in Bittensor Network\nDESCRIPTION: This formula calculates the percentage of emissions allocated to alpha stakers based on a validator's stake weight proportion of alpha.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\text{proportional emissions (\\%) to alpha stakers} \n= \\frac{\\alpha_{x}}\n     {\\alpha_{x} + \\tau_{x} \\, w_{\\tau}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Calculating Validator Stake Weight in Dynamic TAO\nDESCRIPTION: This LaTeX equation defines how a validator hotkey's stake weight is calculated for a subnet, combining normalized global and local weights with a global_split parameter.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_weights-dtao.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n$$ \n\\begin{split}\n& = \\text{(global\\_split}\\times\\text{normalized global weight)} + \\text{(1-global\\_split}\\times\\text{normalized local weight)}\\\\\\\\\n& = \\text{global\\_split}\\times\\frac{\\text{hotkey's global weight}}{\\text{sum of all global weights of all hotkeys in the subnets in question}}\\\\ \\\\\n& + \\text{ (1-global\\_split)}\\times\\frac{\\text{hotkey's local weight}}{\\text{sum of all local weights in the subnet}}\n\\end{split}\n$$\n```\n\n----------------------------------------\n\nTITLE: Defining Stake Vector S in LaTeX\nDESCRIPTION: This LaTeX equation defines a 4x1 stake vector S with elements s_{i} where i ranges from 0 to 3. The vector represents the stake distribution among nodes in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/concepts/_equations.md#2025-04-22_snippet_3\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nS = \\begin{bmatrix} s_{0} \\\\ s_{1} \\\\ s_{2} \\\\ s_{3} \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Network Parameter Functions in Python\nDESCRIPTION: Functions to retrieve network hyperparameters like MaxAllowedUids, BlocksSinceLastStep, and Tempo.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nmax_n (self, netuid: int, block: Optional[int] = None ) -> Optional[int]\n\nblocks_since_epoch (self, netuid: int, block: Optional[int] = None) -> int\n\ntempo (self, netuid: int, block: Optional[int] = None) -> int\n```\n\n----------------------------------------\n\nTITLE: Generating Synthetic Invoice PDF in Python\nDESCRIPTION: Functions to create a synthetic invoice PDF document using Faker and ReportLab libraries. Includes methods to generate sample data, create the invoice PDF, and corrupt the image with noise.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Generates a PDF invoice from the raw data passed in as \"invoice_data\" dictionary \n# and saves the PDF with \"filename\"\ndef create_invoice(invoice_data, filename):\n...\n\n# Using Faker, generate sample data for the invoice\ninvoice_info = {\n    \"company_name\": fake.company(),\n    \"company_address\": fake.address(),\n    \"company_city_zip\": f'{fake.city()}, {fake.zipcode()}',\n...\n}\n...\n\n# Pass the \"invoice_info\" containing the Faker-generated raw data \n# to create_invoice() method and generate the synthetic invoice PDF \npdf_filename = \"sample_invoice.pdf\"\ndata = create_invoice(invoice_info, pdf_filename)\n...\n\n# Loads PDF and converts it into usable PIL image using Pillow library\n# Used by the corrupt_image() method \ndef load_image(pdf_path, page=0, zoom_x=1.0, zoom_y=1.0):\n  ...\n\n# Accepts a PDF, uses load_image() method to convert to image \n# and adds noise, blur, spots, rotates the page, curls corners, darkens edges so \n# that the overall result is noisy. Saves back in PDF format. \n# This is our corrupted synthetic PDF document. \ndef corrupt_image(input_pdf_path, output_pdf_path, border=50, noise=0.1, spot=(100,100), scale=0.95, theta=0.2, blur=0.5):\n  ...\n```\n\n----------------------------------------\n\nTITLE: xxHash 128-bit Hash Function for Substrate Storage Keys\nDESCRIPTION: Helper function that calculates two concatenated xxh64 hashes for the provided data. This combined 128-bit hash is used as a key for several Substrate storage operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef xxh128(data)\n```\n\n----------------------------------------\n\nTITLE: Defining StorageKey Class for Substrate Storage in Python\nDESCRIPTION: This class represents a single state entry in Substrate's key-value store. It provides methods for creating storage keys, converting parameters, and decoding values. The class is part of the bittensor.utils.substrate_utils.storage module.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/storage/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass StorageKey(pallet, storage_function, params, data, value_scale_type, metadata, runtime_config):\n    \"\"\"A StorageKey instance is a representation of a single state entry.\n\n    Substrate uses a simple key-value data store implemented as a database-backed, modified Merkle tree.\n    All of Substrate's higher-level storage abstractions are built on top of this simple key-value store.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining SubnetHyperparameters Class in Python\nDESCRIPTION: This class represents the hyperparameters for a subnet in the Bittensor network. It includes various attributes such as rho, kappa, immunity_period, and methods for handling these parameters. The class also provides a class method for creating an instance from a vector of bytes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/subnet_hyperparameters/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nclass SubnetHyperparameters:\n    def __init__(self):\n        self.rho = 0\n        self.kappa = 0\n        self.immunity_period = 0\n        self.min_allowed_weights = 0\n        self.max_weight_limit = 0.0\n        self.tempo = 0\n        self.min_difficulty = 0\n        self.max_difficulty = 0\n        self.weights_version = 0\n        self.weights_rate_limit = 0\n        self.adjustment_interval = 0\n        self.activity_cutoff = 0\n        self.registration_allowed = False\n        self.target_regs_per_interval = 0\n        self.min_burn = 0\n        self.max_burn = 0\n        self.bonds_moving_avg = 0\n        self.max_regs_per_block = 0\n        self.serving_rate_limit = 0\n        self.max_validators = 0\n        self.adjustment_alpha = 0\n        self.difficulty = 0\n        self.commit_reveal_weights_interval = 0\n        self.commit_reveal_weights_enabled = False\n        self.alpha_high = 0\n        self.alpha_low = 0\n        self.liquid_alpha_enabled = False\n\n    @classmethod\n    def from_vec_u8(cls, vec_u8):\n        # Implementation details omitted\n        pass\n```\n\n----------------------------------------\n\nTITLE: Defining Weight Matrix W in LaTeX\nDESCRIPTION: This LaTeX equation defines a 4x4 weight matrix W with elements w_{i,j} where i and j range from 0 to 3. The matrix represents the weights in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/concepts/_equations.md#2025-04-22_snippet_0\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nW  = \\begin{bmatrix} w_{0,0} & w_{0,1} & w_{0,2} & w_{0,3}  \\\\ w_{1,0} & w_{1,1} & w_{1,2} & w_{1,3} \\\\ w_{2,0} & w_{2,1} & w_{2,2} & w_{2,3} \\\\ w_{3,0} & w_{3,1} & w_{3,2} & w_{3,3} \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Querying LastMechansimStepBlock in Python\nDESCRIPTION: Retrieves the last block when the mechanism step was performed for a given netuid. Uses SubstrateInterface to query mechanism timing information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'LastMechansimStepBlock', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Setting Identity in Bittensor CLI\nDESCRIPTION: Command to create or update on-chain identity for a coldkey or hotkey. This incurs a 1 TAO transaction fee and allows setting attributes like display name, legal name, web URL, and contact information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_50\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet set_identity\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet set-identity [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Regenerating Hotkey in Bittensor CLI\nDESCRIPTION: Command to regenerate a hotkey using a seed value. Similar to coldkey regeneration, this allows users to recreate their hotkey from a seed for security or recovery purposes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_49\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen_hotkey --seed 0x1234...\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-hotkey [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Getting IP string representation from AxonInfo\nDESCRIPTION: A method that returns the complete IP address as a string.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef ip_str():\n    \"\"\"Return the whole IP as string\"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Inspecting UIDs in Bittensor\nDESCRIPTION: Command to view the status of a registered wallet in Bittensor, including UID, stake, rank, and other parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/validators/index.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet overview --netuid\n```\n\n----------------------------------------\n\nTITLE: Querying ChildKeys in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the ChildKeys storage item for a specific parent key and network ID (netuid). It retrieves the mapping of parent keys to child keys with proportions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nparent = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ChildKeys', [parent, netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating Balance Objects from Tao Units in Python\nDESCRIPTION: Static method that creates a Balance object from a float amount in tao units. The method converts the tao amount to rao by multiplying by 10^9 and storing as an integer.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/balance/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef from_float(amount):\n  :staticmethod:\n\n\n  Given tao, return :func:`Balance` object with rao(``int``) and tao(``float``), where rao = int(tao*pow(10,9))\n  :param amount: The amount in tao.\n  :type amount: float\n\n  :returns: A Balance object representing the given amount.\n```\n\n----------------------------------------\n\nTITLE: Commit and Reveal Weights on Bittensor Network in Python\nDESCRIPTION: This function commits and reveals weights for a given subtensor and wallet with specified UIDs and weights. It allows configuration of the version key and waiting behavior for transaction inclusion and finalization, returning a success status and associated message.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/commit_reveal/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ncommit_reveal_v3_extrinsic(subtensor, wallet, netuid, uids, weights, version_key = version_as_int, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Querying Total Hotkey Stake in Bittensor Network with Python\nDESCRIPTION: This example shows how to query the total amount of stake under a specific hotkey on the Bittensor network. It connects to the Finney test network and retrieves the stake value associated with a hotkey generated from the '//Alice' seed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'TotalHotkeyStake', [hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Subnet Management Functions in Python\nDESCRIPTION: Functions for managing and querying subnet information including existence, modality, and connection requirements.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nsubnet_exists( self, netuid: int, block: Optional[int] = None ) -> bool\n\nget_all_subnet_netuids( self, block: Optional[int] = None ) -> List[int]\n\nget_total_subnets( self, block: Optional[int] = None ) -> int\n\nget_subnet_modality( self, netuid: int, block: Optional[int] = None ) -> Optional[int]\n\nget_subnet_connection_requirement( self, netuid_0: int, netuid_1: int, block: Optional[int] = None) -> Optional[int]\n\nget_emission_value_by_subnet( self, netuid: int, block: Optional[int] = None ) -> Optional[float]\n\nget_subnet_connection_requirements( self, netuid: int, block: Optional[int] = None) -> Dict[str, int]\n\nget_subnets( self, block: Optional[int] = None ) -> List[int]\n\nget_all_subnets_info( self, block: Optional[int] = None ) -> List[SubnetInfo]\n\nget_subnet_info( self, netuid: int, block: Optional[int] = None ) -> Optional[SubnetInfo]\n```\n\n----------------------------------------\n\nTITLE: Querying BurnRegistrationsThisInterval in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the BurnRegistrationsThisInterval storage item for a specific network ID (netuid). It retrieves the number of burn registrations in this interval.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'BurnRegistrationsThisInterval', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating StakeInfo Object from Byte Vector in Python\nDESCRIPTION: A class method that constructs a StakeInfo object from a vector of bytes (vec_u8). This is used for deserializing stake information received from the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/stake_info/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef from_vec_u8(vec_u8):\n    :classmethod:\n\n\n    Returns a StakeInfo object from a ``vec_u8``.\n```\n\n----------------------------------------\n\nTITLE: Bittensor Substrate API Reference (Python)\nDESCRIPTION: A reference to the substrate interface for interacting with the Bittensor blockchain. This attribute provides access to low-level blockchain operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_56\n\nLANGUAGE: python\nCODE:\n```\nsubstrate\n```\n\n----------------------------------------\n\nTITLE: Generating Storage Key in Python\nDESCRIPTION: This method generates a storage key based on the currently specified pallet, function, and parameters in the StorageKey instance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/storage/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef generate(self):\n    \"\"\"Generate a storage key for current specified pallet/function/params\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Verifying Request Authenticity in Bittensor Axon Server (Python)\nDESCRIPTION: This async method verifies the authenticity and integrity of incoming requests to the Axon server. It retrieves the specific verification function for the request's Synapse type and executes it, handling any exceptions that may arise.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nasync def verify(synapse):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Configuring Bitteson App Component in TypeScript\nDESCRIPTION: This code snippet shows the configuration of a Bitteson App component in TypeScript. It sets up the data provider and defines resources for blog posts, including list, show, create, and edit routes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst App = () => (\n  <Bitteson\n    dataProvider={dataProvider}\n    resources={[\n      {\n        name: \"blog_posts\",\n        list: \"/blog-posts\",\n        show: \"/blog-posts/show/:id\",\n        create: \"/blog-posts/create\",\n        edit: \"/blog-posts/edit/:id\",\n      },\n    ]}\n  >\n    /* ... */\n  </Bitteson>\n);\n```\n\n----------------------------------------\n\nTITLE: Calculating Expected TAO Tokens from Unstaking (LaTeX)\nDESCRIPTION: This snippet calculates the expected number of TAO tokens to be received when unstaking alpha tokens, without considering slippage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{split}\n\\text{} & = \\text{α unstaked}\\times{\\text{Expected α price}}\\\\\n& = 20\\times0.225 \\\\\n&= \\text{4.5 TAO tokens} \n\\end{split}\n```\n\n----------------------------------------\n\nTITLE: Using environment variables for Wallet SDK passwords\nDESCRIPTION: New feature in Wallet SDK 2.1.0 allowing the use of local environment variables to store encrypted hotkey and coldkey passwords.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Example of using environment variables for wallet passwords\nimport os\n\n# Set environment variables\nos.environ['HOTKEY_PASSWORD'] = 'encrypted_hotkey_password'\nos.environ['COLDKEY_PASSWORD'] = 'encrypted_coldkey_password'\n\n# Use these in your wallet operations\n```\n\n----------------------------------------\n\nTITLE: Retrieving Immunity Period for a Subnet in Bittensor (Python)\nDESCRIPTION: Retrieves the 'ImmunityPeriod' hyperparameter for a specific subnet, which defines the duration during which new neurons are protected from certain network penalties. This parameter is part of Bittensor's governance system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ndef immunity_period(netuid, block = None):\n    \"\"\"\n    Retrieves the 'ImmunityPeriod' hyperparameter for a specific subnet. This parameter defines the duration during\n        which new neurons are protected from certain network penalties or restrictions.\n\n    :param netuid: The unique identifier of the subnet.\n    :type netuid: int\n    :param block: The blockchain block number for the query.\n    :type block: Optional[int]\n\n    :returns: The value of the 'ImmunityPeriod' hyperparameter if the subnet exists, ``None`` otherwise.\n    :rtype: Optional[int]\n\n    The 'ImmunityPeriod' is a critical aspect of the network's governance system, ensuring that new participants\n        have a grace period to establish themselves and contribute to the network without facing immediate\n        punitive actions.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Checking Subnet Creation Cost with btcli subnet lock-cost\nDESCRIPTION: This command shows the required amount of TAO to be locked for creating a new subnet. The cost anneals over a period of two days.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_16\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets lock_cost\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet lock-cost [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Wallet with Custom Word Count\nDESCRIPTION: Command for creating a new wallet with a custom mnemonic word count.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_36\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet create --n_words 21\n```\n\n----------------------------------------\n\nTITLE: Committing Weight Hash to Bittensor Blockchain\nDESCRIPTION: Async function that commits a hash of the neuron's weights to the Bittensor blockchain. It handles the process of sending the transaction with proper validation and error handling, allowing options to wait for block inclusion or finalization.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/weights/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def commit_weights_extrinsic(subtensor, wallet, netuid, commit_hash, wait_for_inclusion = False, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Querying BondsPenalty in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the BondsPenalty storage item for a specific network ID (netuid). It retrieves the bonds penalty setting for a subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'BondsPenalty', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: ChainDataType Enum Definition\nDESCRIPTION: Defines an enumeration class for different types of chain data including AccountId, DelegateInfo, NeuronInfo, and other blockchain-related data types.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/utils/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ChainDataType(enum.Enum):\n    NeuronInfo = 1\n    SubnetInfo = 2\n    DelegateInfo = 3\n    NeuronInfoLite = 4\n    DelegatedInfo = 5\n    StakeInfo = 6\n    IPInfo = 7\n    SubnetHyperparameters = 8\n    ScheduledColdkeySwapInfo = 9\n    AccountId = 10\n    NeuronCertificate = 11\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Config for Bittensor Wallet SDK\nDESCRIPTION: Python code demonstrating how to create a custom configuration object for use with the Bittensor Wallet SDK.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor_wallet.config import Config\nconfig = Config()\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Logger Names in Bittensor\nDESCRIPTION: A function that iterates through the logging root manager's logger dictionary and yields the names of all active Logger instances while skipping placeholders.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/helpers/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef all_logger_names():\n\n   Generate the names of all active loggers.\n\n   This function iterates through the logging root manager's logger dictionary and yields the names of all active\n   `Logger` instances. It skips placeholders and other types that are not instances of `Logger`.\n\n   :Yields: *name (str)* -- The name of an active logger.\n```\n\n----------------------------------------\n\nTITLE: Async Blocks Since Update Check\nDESCRIPTION: Method to check the number of blocks that have passed since the last update for a specific UID in a subnetwork.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def blocks_since_last_update(netuid, uid):\n```\n\n----------------------------------------\n\nTITLE: Pushing Data to Redis List in Bash\nDESCRIPTION: This snippet demonstrates how to use the LPUSH command in Redis to add an item to a list. It adds 'bike:1' to the 'bikes:repairs' list.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nLPUSH bikes:repairs bike:1\n```\n\n----------------------------------------\n\nTITLE: Viewing Senate Proposals in Bittensor CLI\nDESCRIPTION: This command allows anyone to view current proposals before the Senate. It is an unpermissioned request that can be executed by any user.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/senate.md#2025-04-22_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nbtcli sudo proposals\n```\n\n----------------------------------------\n\nTITLE: Setting adjustment_alpha Parameter via CLI in Bittensor\nDESCRIPTION: This command uses the Bittensor CLI to set the adjustment_alpha parameter for a specific subnet. The value 17893341751498265066 corresponds to setting adjustment_alpha to 0.97, which affects the balance between registration burn and POW costs.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/_legacy_hyperparams.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set --param adjustment_alpha --value 17893341751498265066 --netuid <NETUID>\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Childkey Take Rate Limit in Bittensor with Python\nDESCRIPTION: This example demonstrates how to query the transaction childkey take rate limit in the Bittensor network. It connects to the Finney test network and retrieves the rate limit value that restricts how frequently childkeys can take actions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_47\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TxChildkeyTakeRateLimit')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Neuron Certificate in Bittensor\nDESCRIPTION: This method retrieves the TLS certificate for a specified neuron identified by its unique UID within a given subnet. It facilitates mutual TLS communication by providing the required certificate.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_neuron_certificate(hotkey, netuid, block = None)\n\n      Retrieves the TLS certificate for a specific neuron identified by its unique identifier (UID) within a\n          specified subnet (netuid) of the Bittensor network.\n\n      :param hotkey: The hotkey to query.\n      :param netuid: The unique identifier of the subnet.\n      :param block: The blockchain block number for the query.\n\n      :returns: the certificate of the neuron if found, `None` otherwise.\n\n      This function is used for certificate discovery for setting up mutual tls communication between neurons.\n```\n\n----------------------------------------\n\nTITLE: Implementing Version Check Function in Python\nDESCRIPTION: Defines a function to check if the current Bittensor version is up-to-date with the latest version on PyPI. It raises a VersionCheckError if the check fails.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/version/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef check_version(timeout = 15):\n    \"\"\"Check if the current version of Bittensor is up-to-date with the latest version on PyPi.\n    Raises a VersionCheckError if the version check fails.\n\n    :param timeout: The timeout for the request to PyPI in seconds. Default is ``15``.\n    :type timeout: int\n    \"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Implementing Configuration Method for PriorityThreadPoolExecutor\nDESCRIPTION: A class method that retrieves configuration from the argument parser and returns a bittensor.Config object, enabling standardized configuration of the executor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/threadpool/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef config():\n   \"\"\"\n   Get config from the argument parser.\n\n   Return: :func:`bittensor.Config` object.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Specifying Destination SS58 Address in JavaScript\nDESCRIPTION: This snippet shows how to set the destination SS58 address for the TAO transfer in the withdraw.js file. It demonstrates replacing the default address with a specific SS58 address.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/transfer-from-metamask-to-ss58.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// Destination address can be replaced with any ss58 address here:\nconst destinationAddress = account.address;\n```\n\nLANGUAGE: javascript\nCODE:\n```\nconst destinationAddress = \"5HgU7B3xfSfisR1A7wDMt7FHX5Uizj6xtWWHwhwJMZSrdN7y\";\n```\n\n----------------------------------------\n\nTITLE: Encoding Parameters for Bittensor Blockchain Calls (Python)\nDESCRIPTION: This asynchronous method encodes parameters using their specified types and returns them as a hex encoded string. Used for preparing parameters for blockchain calls.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nencode_params(call_definition, params)\n```\n\n----------------------------------------\n\nTITLE: Querying LastHotkeyColdkeyEmissionOnNetuid in Python\nDESCRIPTION: Retrieves the last emission block for a hotkey-coldkey pair on a given netuid. Uses SubstrateInterface to query the blockchain state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\ncoldkey = Keypair.create_from_uri('//Bob').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'LastHotkeyColdkeyEmissionOnNetuid', [hotkey, coldkey, netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Signing Message with Hotkey using btcli\nDESCRIPTION: This command signs a message using the hotkey. It requires access to the hotkey private key and is typically used on a hotkey workstation for mining or validation operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet sign\n```\n\n----------------------------------------\n\nTITLE: Importing Bittensor Core Module in Python\nDESCRIPTION: This code snippet demonstrates how to import the bittensor.core module in Python. It's a basic import statement that makes the core functionality of Bittensor available in the current namespace.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n.. py:module:: bittensor.core\n```\n\n----------------------------------------\n\nTITLE: Checking Balance for All Wallets\nDESCRIPTION: Command for displaying balances of all wallets using the --all flag.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_33\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w balance --all\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Subtensor Methods for Neuron Operations\nDESCRIPTION: Methods in the MockSubtensor class that simulate operations related to neurons such as retrieving neuron information and subnet details without requiring an actual blockchain connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef neurons(netuid, block = None):\n\n      Retrieves a list of all neurons within a specified subnet of the Bittensor network.\n      This function provides a snapshot of the subnet's neuron population, including each neuron's attributes and\n          network interactions.\n\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: A list of NeuronInfo objects detailing each neuron's characteristics in the subnet.\n\n      Understanding the distribution and status of neurons within a subnet is key to comprehending the network's\n          decentralized structure and the dynamics of its consensus and governance processes.\n```\n\nLANGUAGE: python\nCODE:\n```\ndef neuron_for_uid(uid, netuid, block = None):\n\n      Retrieves detailed information about a specific neuron identified by its unique identifier (UID) within a\n          specified subnet (netuid) of the Bittensor network. This function provides a comprehensive view of a\n          neuron's attributes, including its stake, rank, and operational status.\n\n      :param uid: The unique identifier of the neuron.\n      :type uid: int\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Detailed information about the neuron if found, a null neuron otherwise\n\n      This function is crucial for analyzing individual neurons' contributions and status within a specific subnet,\n          offering insights into their roles in the network's consensus and validation mechanisms.\n```\n\n----------------------------------------\n\nTITLE: Querying MinBurn in Python\nDESCRIPTION: Retrieves the minimum burn value for a given network using the SubstrateInterface. Takes netuid as parameter and returns a u64 value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'MinBurn', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Serial Execution of Subnet Existence Checks in Python\nDESCRIPTION: This snippet demonstrates a serial approach to checking subnet existence using Bittensor's Subtensor class. It iterates through a range of network IDs, making individual calls to the blockchain for each check.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.subtensor import Subtensor\n\nsubtensor = Subtensor(\"test\")\nfor netuid in range(1, 8):\n    print(\"subnet \" + str(netuid) + \" exists: \" + str(subtensor.subnet_exists(netuid=netuid)))\n```\n\n----------------------------------------\n\nTITLE: Creating and activating Python virtual environment\nDESCRIPTION: Commands to create a Python virtual environment named 'btsdk_venv' and activate it for Bittensor SDK installation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv btsdk_venv\nsource btsdk_venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Waiting for Specific Block\nDESCRIPTION: Python function signature for waiting until a specified block number is reached or the next block arrives.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nwait_for_block(\nblock: Optional[int] = None\n)\n```\n\n----------------------------------------\n\nTITLE: Checking Wallet Balance - Test1\nDESCRIPTION: Shows how to check the balance of the playground-test1 wallet on the test network after regenerating the coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet regen-coldkey \\\n--mnemonic \"add aerobic there stool organ switch about diagram arctic vague replace seminar\" \\\n--wallet.name 'playground-test1' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli wallet balance \\\n--wallet.name 'playground-test1' \\\n--wallet.path ~/.bittensor/wallets \\\n--network test\n```\n\n----------------------------------------\n\nTITLE: Revoking All Child Hotkeys with btcli stake child revoke\nDESCRIPTION: This command removes all child hotkeys on a specified subnet. It's used to revoke delegated authority from all child hotkeys, removing their position and influence on the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child revoke --hotkey <parent_hotkey> --netuid 1\n```\n\n----------------------------------------\n\nTITLE: Converting Synapse State to HTTP Headers\nDESCRIPTION: Illustrates how a Synapse instance converts its internal state into HTTP headers for network transmission, handling basic properties, complex objects, and size metrics for bandwidth management.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsynapse = Synapse(name=\"ExampleSynapse\", timeout=30)\nheaders = synapse.to_headers()\n# headers now contains a dictionary representing the Synapse instance\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Alpha Out Emission in Python\nDESCRIPTION: Demonstrates how to query the amount of alpha leaving a subnet per block. Takes a netuid parameter and returns a u64 value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'SubnetAlphaOutEmission', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Fixing SSL Issues in macOS Python Virtual Environment\nDESCRIPTION: This command forcefully reinstalls urllib3 to resolve SSL certificate verification errors when using a Python virtual environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npip install urllib3 --force-reinstall\n```\n\n----------------------------------------\n\nTITLE: Initializing AsyncSubtensor in Python\nDESCRIPTION: This snippet demonstrates how to initialize AsyncSubtensor, which is the asyncio version of the Subtensor class. It uses an async context manager and shows a basic usage example of retrieving neurons.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/asyncio.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.async_subtensor import AsyncSubtensor\n\nasync def main():\n    async with AsyncSubtensor(\"test\") as subtensor:\n        neurons = await subtensor.neurons_lite(1)\n```\n\n----------------------------------------\n\nTITLE: Querying Validator Prune Length in Bittensor Network with Python\nDESCRIPTION: This example demonstrates how to query the length of validator pruning for a specific Bittensor subnet. It connects to the Finney test network and retrieves the pruning parameter that determines how validators are removed from the active set.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_53\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'ValidatorPruneLen', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Querying LastHotkeyEmissionDrain in Python\nDESCRIPTION: Retrieves the last block when a hotkey's emission was drained. Uses SubstrateInterface to query blockchain state for emission drain information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nresult = substrate.query('SubtensorModule', 'LastHotkeyEmissionDrain', [hotkey])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Mock Subtensor Class in Python\nDESCRIPTION: A mock implementation of the Subtensor class that simulates blockchain interactions for testing purposes. It mimics chain queries and maintains a local state without requiring an actual connection to the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MockSubtensor(*args, **kwargs):\n   Bases: :py:obj:`bittensor.core.subtensor.Subtensor`\n\n\n   A Mock Subtensor class for running tests.\n   This should mock only methods that make queries to the chain.\n   e.g. We mock `Subtensor.query_subtensor` instead of all query methods.\n\n   This class will also store a local (mock) state of the chain.\n\n   Initializes an instance of the Subtensor class.\n\n   :param network: The network name or type to connect to.\n   :type network: str\n   :param config: Configuration object for the AsyncSubtensor instance.\n   :type config: Optional[Config]\n   :param _mock: Whether this is a mock instance. Mainly just for use in testing.\n   :param log_verbose: Enables or disables verbose logging.\n   :type log_verbose: bool\n\n   :raises Any exceptions raised during the setup, configuration, or connection process.:\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Chain State Classes for Bittensor Testing\nDESCRIPTION: Mock classes for representing the state of the Bittensor blockchain during testing. These classes include MockChainState, MockSystemState, and MockSubtensorState to simulate blockchain storage and behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MockChainState:\n\n   Bases: :py:obj:`TypedDict`\n\n\n   dict() -> new empty dictionary\n   dict(mapping) -> new dictionary initialized from a mapping object's\n       (key, value) pairs\n   dict(iterable) -> new dictionary initialized as if via:\n       d = {}\n       for k, v in iterable:\n           d[k] = v\n   dict(**kwargs) -> new dictionary initialized with the name=value pairs\n       in the keyword argument list.  For example:  dict(one=1, two=2)\n\n   Initialize self.  See help(type(self)) for accurate signature.\n\n\n   .. py:attribute:: SubtensorModule\n      :type:  MockSubtensorState\n\n\n   .. py:attribute:: System\n      :type:  MockSystemState\n```\n\n----------------------------------------\n\nTITLE: Defining OCRSynapse Protocol Class for Bittensor Communication\nDESCRIPTION: Implementation of the OCRSynapse class that inherits from bt.Synapse to enable communication between miners and validators. It defines the structure for sending images to be processed and receiving extracted data responses.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# OCRSynapse class, using bt.Synapse as its base.\n# This protocol enables communication between the miner and the validator.\n# Attributes:\n#    - image: A pdf image to be processed by the miner.\n#    - response: List[dict] containing data extracted from the image.\nclass OCRSynapse(bt.Synapse):\n   \"\"\"\n    A simple OCR synapse protocol representation which uses bt.Synapse as its base.\n    This protocol enables communication between the miner and the validator.\n\n    Attributes:\n    - image: A pdf image to be processed by the miner.\n    - response: List[dict] containing data extracted from the image.\n    \"\"\"\n\n    # Required request input, filled by sending dendrite caller. It is a base64 encoded string.\n    base64_image: str\n\n    # Optional request output, filled by receiving axon.\n    response: typing.Optional[typing.List[dict]] = None\n```\n\n----------------------------------------\n\nTITLE: Prometheus Info Dictionary Definition\nDESCRIPTION: InfoDict subclass defining the structure for Prometheus monitoring information, including block, IP, port, and version details.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass PrometheusInfoDict(InfoDict):\n    block: int\n    ip: int\n    ip_type: int\n    port: int\n    version: int\n```\n\n----------------------------------------\n\nTITLE: Retrieving Existential Deposit in Bittensor\nDESCRIPTION: Method to get the existential deposit for the Bittensor chain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nget_existential_deposit(self, block: Optional[int] = None) -> Optional[Balance]\n```\n\n----------------------------------------\n\nTITLE: Implementing Other Mock Classes for Bittensor Testing\nDESCRIPTION: Additional mock classes used in the Bittensor testing framework such as MockMapResult and utility functions like min_required_stake for simulating blockchain behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass MockMapResult(records = None):\n\n   .. py:attribute:: records\n      :type:  Optional[list[tuple[MockSubtensorValue, MockSubtensorValue]]]\n```\n\nLANGUAGE: python\nCODE:\n```\ndef min_required_stake():\n      :staticmethod:\n\n\n      As the minimum required stake may change, this method allows us to dynamically\n      update the amount in the mock without updating the tests\n```\n\n----------------------------------------\n\nTITLE: Configuring Ethereum Private Key in JavaScript\nDESCRIPTION: This snippet demonstrates how to set the Ethereum private key in a JavaScript configuration file. The private key is copied from the Metamask wallet and pasted into the config.js file to enable seamless interaction with the Bittensor EVM testnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/evm-testnet-with-metamask-wallet.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ethPrivateKey = \"02c1c4112233snipsnipsnipgh933aca491e090e0b7xxyy1b124b86d9382b01a8\";\n```\n\n----------------------------------------\n\nTITLE: Calculating Unstaked TAO Tokens (LaTeX)\nDESCRIPTION: This snippet calculates the actual amount of TAO tokens received after unstaking, taking into account slippage.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_3\n\nLANGUAGE: latex\nCODE:\n```\n\\text{Unstaked TAO tokens} = 15 − 11.54 = 3.46 \\text{ TAO}\n```\n\n----------------------------------------\n\nTITLE: Getting a null NeuronInfo instance in Python\nDESCRIPTION: Static method that returns a null/empty NeuronInfo instance. This can be used as a placeholder or default when a valid neuron information is not available.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_info/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@staticmethod\ndef get_null_neuron()\n```\n\n----------------------------------------\n\nTITLE: Calculating Relative Dividend Rates\nDESCRIPTION: Implements function to calculate relative dividend rates for weight copiers under different parameter configurations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic_all_SN.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef get_relative_dividend_rate(setup):\n    div_rates = []\n\n    for netuid in setup.netuids:\n        for cr_interval in setup.cr_intervals:\n            for alpha_low in setup.alpha_lows:\n                for alpha_high in setup.alpha_highs:\n                    if alpha_low > alpha_high:\n                        continue\n                    \n                    try: \n                        with open(f\"{setup.result_path}/yuma_result_netuid{netuid}_conceal{cr_interval}_al{alpha_low:.1f}_ah{alpha_high:.1f}.pkl\", 'rb') as handle:\n                            _yuma_results = pickle.load(handle)\n\n                        dividend = [\n                            (s[\"validator_reward_normalized\"] / s[\"stake\"]).tolist()\n                            for idx, s in _yuma_results.items()\n                        ]\n\n                        dividend_df = pd.DataFrame(\n                            dividend,\n                            columns=[f\"v{i}\" for i in range(len(dividend[0]) - 1 )] + [\"v_bad\"],\n                        )\n                        \n                        div_last = dividend_df.iloc[-1]\n                        if (div_last.isna()).any():\n                            div_rate = None\n                        else:\n                            div_rate = div_last[-1] / div_last[:-1].median() \n\n                        div_rates.append([netuid, cr_interval, alpha_low, alpha_high, div_rate, div_last])\n                    \n                    except:\n                        div_rates.append([netuid, cr_interval, alpha_low, alpha_high, None, None])\n\n\n    div_rates = pd.DataFrame(div_rates, dtype='float64', columns = ['netuid', 'cr_interval', 'alpha_low', 'alpha_high', 'G', 'dividend'])\n    div_rates.index = div_rates.index.map(lambda x : x)\n\n    return div_rates\n```\n\n----------------------------------------\n\nTITLE: Getting Child Hotkeys with Bittensor CLI\nDESCRIPTION: This command retrieves the child hotkeys for a given parent hotkey and network UID. It requires specifying the network UID, parent hotkey, and optionally the wallet name. The '--all' flag can be used to retrieve all child hotkeys.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake get_children --netuid <netuid> --hotkey <parent hotkey> --all\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake get_children \\\n  --netuid 4 \\\n  --hotkey 5DqJdDLU23m7yf6rZSmbLTshU7Bfn9eCTBkduhF4r9i73B9Y \\\n  --wallet.name Alice \\\n  --all\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake get_children\n```\n\n----------------------------------------\n\nTITLE: IPInfo Class Definition with Encoding Methods in Python\nDESCRIPTION: The IPInfo class represents IP information with properties including IP address, IP type, and protocol. It provides methods for encoding and decoding IP information, converting between parameter dictionaries and vec_u8 formats, and handling lists of IP information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/ip_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass IPInfo:\n\n   Dataclass representing IP information.\n\n   :ivar ip: The IP address as a string.\n   :vartype ip: str\n   :ivar ip_type: The type of the IP address (e.g., IPv4, IPv6).\n   :vartype ip_type: int\n   :ivar protocol: The protocol associated with the IP (e.g., TCP, UDP).\n\n   :vartype protocol: int\n\n\n   .. py:method:: encode()\n\n      Returns a dictionary of the IPInfo object that can be encoded.\n\n\n\n   .. py:method:: fix_decoded_values(decoded)\n      :classmethod:\n\n\n      Returns a SubnetInfo object from a decoded IPInfo dictionary.\n\n\n\n   .. py:method:: from_parameter_dict(parameter_dict)\n      :classmethod:\n\n\n      Creates a IPInfo instance from a parameter dictionary.\n\n\n\n   .. py:method:: from_vec_u8(vec_u8)\n      :classmethod:\n\n\n      Returns a IPInfo object from a ``vec_u8``.\n\n\n\n   .. py:attribute:: ip\n      :type:  str\n\n\n   .. py:attribute:: ip_type\n      :type:  int\n\n\n   .. py:method:: list_from_vec_u8(vec_u8)\n      :classmethod:\n\n\n      Returns a list of IPInfo objects from a ``vec_u8``.\n\n\n\n   .. py:attribute:: protocol\n      :type:  int\n\n\n   .. py:method:: to_parameter_dict()\n\n      Returns a torch tensor or dict of the subnet IP info.\n```\n\n----------------------------------------\n\nTITLE: Defining DelegateInfoLite Class in Python\nDESCRIPTION: This class represents a lightweight version of delegate information in the Bittensor network. It includes attributes such as delegate and owner SS58 addresses, take percentage, nominator count, registrations, validator permits, and return metrics.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/delegate_info_lite/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass DelegateInfoLite:\n\n   delegate_ss58: str\n   take: float\n   nominators: int\n   owner_ss58: str\n   registrations: list[int]\n   validator_permits: list[int]\n   return_per_1000: int\n   total_daily_return: int\n```\n\n----------------------------------------\n\nTITLE: Navigating to Examples Directory in Bash\nDESCRIPTION: Command to change directory to the 'examples' folder in the EVM-Bittensor repository.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/ed25519-verify-precompile.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncd examples\n```\n\n----------------------------------------\n\nTITLE: Validating Bittensor Addresses and Public Keys\nDESCRIPTION: Function to check if a given address is a valid Bittensor destination address. It accepts addresses in either string or bytes format and returns a boolean indicating validity.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef is_valid_bittensor_address_or_public_key(address):\n   \"\"\"Checks if the given address is a valid destination address.\n\n   :param address: The address to check.\n   :type address: Union[str, bytes]\n\n   :returns: True if the address is a valid destination address, False otherwise.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Normalizing Max Weight in Python\nDESCRIPTION: Normalizes the tensor x so that sum(x) = 1 and the max value is not greater than the limit. Takes a numpy float32 tensor and an optional limit as input and returns the normalized tensor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\ndef normalize_max_weight(x, limit = 0.1):\n    \"\"\"Normalizes the tensor x so that sum(x) = 1 and the max value is not greater than the limit.\n    :param x: Tensor to be max_value normalized.\n    :type x: :obj:`np.float32`\n    :param limit: float: Max value after normalization.\n\n    :returns: Normalized x tensor.\n    :rtype: y (:obj:`np.float32`)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying LastHotkeyEmissionOnNetuid in Python\nDESCRIPTION: Retrieves the last emission block for a hotkey on a specific netuid. Uses SubstrateInterface to query emission timing information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nhotkey = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'LastHotkeyEmissionOnNetuid', [hotkey, netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Implementing Info Dictionary Classes for Bittensor Mocking\nDESCRIPTION: Classes that represent information dictionaries used in Bittensor mock implementations. These include InfoDict and AxonInfoDict which provide structured data storage for axon information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass InfoDict:\n\n   Bases: :py:obj:`collections.abc.Mapping`\n\n\n   .. py:method:: default()\n      :classmethod:\n\n      :abstractmethod:\n```\n\nLANGUAGE: python\nCODE:\n```\nclass AxonInfoDict:\n\n   Bases: :py:obj:`InfoDict`\n\n\n   .. py:attribute:: block\n      :type:  int\n\n\n   .. py:method:: default()\n      :classmethod:\n\n\n\n   .. py:attribute:: ip\n      :type:  int\n\n\n   .. py:attribute:: ip_type\n      :type:  int\n\n\n   .. py:attribute:: placeholder1\n      :type:  int\n\n\n   .. py:attribute:: placeholder2\n      :type:  int\n\n\n   .. py:attribute:: port\n      :type:  int\n\n\n   .. py:attribute:: protocol\n      :type:  int\n\n\n   .. py:attribute:: version\n      :type:  int\n```\n\n----------------------------------------\n\nTITLE: Calculating Percentage Slippage (LaTeX)\nDESCRIPTION: This snippet calculates the percentage of slippage experienced during the unstaking operation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{split}\n\\text{Percentage slippage} & = \\frac{\\text{Slippage TAO tokens}}{\\text{Expected TAO tokens}}\\times 100\\% \\\\\n& = \\frac{1.04}{4.5}\\times 100\\% \\\\\n& = 23.1\\% \n\\end{split}\n```\n\n----------------------------------------\n\nTITLE: Retrieving All Logger Instances in Bittensor\nDESCRIPTION: A generator function that yields all active Logger instances from the logging root manager's dictionary, skipping placeholders and non-Logger types.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/helpers/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef all_loggers():\n\n   Generator that yields all logger instances in the application.\n\n   Iterates through the logging root manager's logger dictionary and yields all active `Logger` instances. It skips\n   placeholders and other types that are not instances of `Logger`.\n\n   :Yields: *logger (logging.Logger)* -- An active logger instance.\n```\n\n----------------------------------------\n\nTITLE: LoggingMachine Class Definition - Python\nDESCRIPTION: State machine implementation for handling logger states in Bittensor, inheriting from statemachine.StateMachine and logging.Logger. Manages transitions between different logging states and provides methods for logging at various levels.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/loggingmachine/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass LoggingMachine(statemachine.StateMachine, logging.Logger):\n    def __init__(self, config, name=BITTENSOR_LOGGER_NAME):\n        # Initialize logger with name and optional level\n        pass\n```\n\n----------------------------------------\n\nTITLE: Querying Subtensor Module Storage\nDESCRIPTION: Method for querying named storage from the Subtensor module to retrieve specific blockchain data like stake, rank, or neuron attributes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef query_subtensor(name, block = None, params = None):\n```\n\n----------------------------------------\n\nTITLE: Converting Root Weight UIDs and Values to Tensor in Python\nDESCRIPTION: Converts root weights and uids from chain representation into a numpy array or PyTorch FloatTensor. Takes the number of neurons, UIDs, weights, and subnets as input and returns converted row weights as a numpy float32 array.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/weight_utils/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef convert_root_weight_uids_and_vals_to_tensor(n, uids, weights, subnets):\n    \"\"\"Converts root weights and uids from chain representation into a np.array or torch FloatTensor\n    (inverse operation from convert_weights_and_uids_for_emit)\n\n    :param n: number of neurons on network.\n    :type n: int\n    :param uids: Tensor of uids as destinations for passed weights.\n    :type uids: list[int]\n    :param weights: Tensor of weights.\n    :type weights: list[int]\n    :param subnets: list of subnets on the network.\n    :type subnets: list[int]\n\n    :returns: Converted row weights.\n    :rtype: row_weights (np.float32)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Dividend Distribution Between Honest Validators and Weight Copiers\nDESCRIPTION: Creates a visualization comparing the dividend distribution for honest validators versus weight copiers under the selected parameters. This shows the relative positioning of weight copiers in terms of dividend earnings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndf = div_rates[(div_rates.cr_interval == cr_interval) & (div_rates.alpha_high == alpha_high) & (div_rates.alpha_low == alpha_low) ]\nla_dividend_df = pd.DataFrame(list(df.dividend.values)).T\n\nfigure(figsize=(10, 7.5), dpi=80)\n\nplt.plot(la_dividend_df.iloc[:-1, 0].sort_values().reset_index(drop = True), label = 'dividend for honest validators')\nplt.axhline(y = la_dividend_df.iloc[-1].values, color = 'r', linestyle = '--', label = 'dividend for weight copier') \nplt.axhline(y = la_dividend_df.iloc[:-1, 0].median(), color = 'green', linestyle = '--', label = 'median dividend for hoenst validators') \n\nplt.title(\"Dividend for honest validators and weight copier\")\nplt.ylabel(\"Dividend per stake\")\nplt.xlabel(\"Validator sorted by dividend\")\nplt.legend()\n```\n\n----------------------------------------\n\nTITLE: Calculating New TAO Reserves After Unstaking (LaTeX)\nDESCRIPTION: This snippet calculates the new TAO reserves after an unstaking operation, maintaining the constant product k.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{split}\n& 86.67 \\times\\text{new TAO reserves} = 1000\\\\\n\\implies & \\text{new TAO reserves} = 1000/86.67 = 11.54 \\text{ TAO}\n\\end{split}\n```\n\n----------------------------------------\n\nTITLE: Converting Storage Key to Hex String in Python\nDESCRIPTION: This method returns a hexadecimal string representation of the current StorageKey data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/storage/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef to_hex(self):\n    \"\"\"Returns a Hex-string representation of current StorageKey data\n\n    :returns: Hex string\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registration Statistics Tracking in Bittensor\nDESCRIPTION: A class for tracking and storing statistics related to the registration Proof-of-Work process, including block information, difficulty, hash rates, and time metrics.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nclass RegistrationStatistics:\n   \"\"\"Statistics for a registration.\"\"\"\n\n   block_hash: str\n   block_number: int\n   difficulty: int\n   hash_rate: float\n   hash_rate_perpetual: float\n   rounds_total: int\n   time_average: float\n   time_spent: float\n   time_spent_total: float\n```\n\n----------------------------------------\n\nTITLE: Querying AdjustmentInterval in Python using SubstrateInterface\nDESCRIPTION: This snippet demonstrates how to query the AdjustmentInterval storage item for a specific network ID (netuid). AdjustmentInterval represents the adjustment interval for networks.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'AdjustmentInterval', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating a list of NeuronInfo objects from a byte vector in Python\nDESCRIPTION: Class method that deserializes a byte vector into a list of NeuronInfo objects. This is useful for processing multiple neurons' data that has been serialized together.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/neuron_info/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef list_from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Navigating to Developer Docs Directory\nDESCRIPTION: Change the current working directory to the cloned developer-docs folder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd developer-docs\n```\n\n----------------------------------------\n\nTITLE: Sudo Commands for Network Management\nDESCRIPTION: Various administrative commands including hyperparameter viewing, delegate take management, and governance operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_21\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo get --netuid 1\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo get-take --wallet-name my_wallet --wallet-hotkey my_hotkey\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo proposals\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo senate\n```\n\n----------------------------------------\n\nTITLE: Publishing Metadata to Bittensor Network in Python\nDESCRIPTION: Asynchronous function for publishing metadata on the Bittensor network. It allows specifying a data type (hash algorithm) and supports waiting for inclusion or finalization of the transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/serving/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def publish_metadata(subtensor, wallet, netuid, data_type, data, wait_for_inclusion = False, wait_for_finalization = True):\n    \"\"\"\n    Publishes metadata on the Bittensor network using the specified wallet and network identifier.\n\n    :param subtensor: The subtensor instance representing the Bittensor blockchain connection.\n    :type subtensor: bittensor.subtensor\n    :param wallet: The wallet object used for authentication in the transaction.\n    :type wallet: bittensor.wallet\n    :param netuid: Network UID on which the metadata is to be published.\n    :type netuid: int\n    :param data_type: The data type of the information being submitted. It should be one of the following:\n                     ``'Sha256'``, ``'Blake256'``, ``'Keccak256'``, or ``'Raw0-128'``. This specifies the format or hashing\n                     algorithm used for the data.\n    :type data_type: str\n    :param data: The actual metadata content to be published. This should be formatted or hashed according to the\n                ``type`` specified. (Note: max ``str`` length is 128 bytes)\n    :type data: str\n    :param wait_for_inclusion: If ``True``, the function will wait for the extrinsic to be included in a\n                              block before returning. Defaults to ``False``.\n    :type wait_for_inclusion: bool, optional\n    :param wait_for_finalization: If ``True``, the function will wait for the extrinsic to be finalized\n                                 on the chain before returning. Defaults to ``True``.\n    :type wait_for_finalization: bool, optional\n\n    :returns: ``True`` if the metadata was successfully published (and finalized if specified). ``False`` otherwise.\n    :rtype: bool\n\n    :raises MetadataError: If there is an error in submitting the extrinsic or if the response from the blockchain indicates\n        failure.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Miner Benchmark Weight in Yuma Consensus\nDESCRIPTION: This LaTeX equation computes the benchmark weight for a miner in the Yuma Consensus algorithm. It finds the maximum weight level supported by at least a fraction κ of total stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n\\overline{W_j} = \\arg \\max_{w} \n\\Bigl(\\,\n   \\sum_{i \\in \\mathbb{V}} S_i \\,\\cdot\\, \\bigl\\{\\,W_{ij}\\,\\ge w \\bigr\\} \\ge \\kappa\n\\Bigr).\n```\n\n----------------------------------------\n\nTITLE: Querying Bittensor Subnet for Next Adjustment Block in JavaScript\nDESCRIPTION: This script, bt-next-adjust-block.js, is used to query a Bittensor subnet to determine the number of blocks remaining before the recycle register cost is recalculated. The script is located in the project's scripts directory and requires installation and specific usage instructions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/utilities.md#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n// bt-next-adjust-block.js\n// No code snippet provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Defining Metagraph State Dictionary Keys in Python\nDESCRIPTION: Defines a list of keys used in the metagraph state dictionary for NDArray serialization. Each key corresponds to a specific attribute or metric of the metagraph nodes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nMETAGRAPH_STATE_DICT_NDARRAY_KEYS = ['version', 'n', 'block', 'stake', 'total_stake', 'ranks', 'trust', 'consensus', 'validator_trust', 'incentive', 'emission', 'dividends', 'active', 'last_update', 'validator_permit', 'uids']\n```\n\n----------------------------------------\n\nTITLE: Querying Transaction Delegate Take Rate Limit in Bittensor with Python\nDESCRIPTION: This example shows how to query the transaction delegate take rate limit in the Bittensor network. It connects to the Finney test network and retrieves the rate limit value that restricts how frequently delegate operations can occur.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nresult = substrate.query('SubtensorModule', 'TxDelegateTakeRateLimit')\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Parsing HTTP Headers for Synapse Reconstruction\nDESCRIPTION: Demonstrates the internal process of parsing received HTTP headers into a structured dictionary for Synapse reconstruction, handling different header types and decoding serialized objects.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nreceived_headers = {\n    'bt_header_axon_address': '127.0.0.1',\n    'bt_header_dendrite_port': '8080',\n    # Other headers...\n}\ninputs = Synapse.parse_headers_to_inputs(received_headers)\n# inputs now contains a structured representation of Synapse properties based on the headers\n```\n\n----------------------------------------\n\nTITLE: Converting Numbers to Human Readable Format in Python\nDESCRIPTION: Function signature for converting numeric values into human-readable format with optional suffix parameter. Used for formatting large numbers into more digestible formats with appropriate unit suffixes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/formatting/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef get_human_readable(num, suffix='H')\n```\n\n----------------------------------------\n\nTITLE: Custom File Formatter Implementation\nDESCRIPTION: BtFileFormatter class that extends logging.Formatter to provide custom time formatting with milliseconds and centered level names for file-based logging.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/format/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass BtFileFormatter(logging.Formatter):\n    def format(self, record):\n        \"\"\"Override format to center the level name.\"\"\"\n        return super().format(record)\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"Override formatTime to add milliseconds.\"\"\"\n        return super().formatTime(record, datefmt)\n```\n\n----------------------------------------\n\nTITLE: Accessing TerminalInfo Properties - Python\nDESCRIPTION: Example showing how to access TerminalInfo object attributes including uuid, hotkey, signature, IP address and processing duration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nuuid=\"5ecbd69c-1cec-11ee-b0dc-e29ce36fec1a\",\nhotkey=\"5EnjDGNqqWnuL2HCAdxeEtN2oqtXZw6BMBe936Kfy2PFz1J1\",\nsignature=\"0x0813029319030129u4120u10841824y0182u091u230912u\"\n\n# Accessing TerminalInfo attributes\nip_address = terminal_info.ip\nprocessing_duration = terminal_info.process_time\n```\n\n----------------------------------------\n\nTITLE: Removing Stake from Hotkey in Bittensor\nDESCRIPTION: Method to remove stake from a specified hotkey UID to the wallet coldkey in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nunstake(self, wallet: 'bittensor.wallet', hotkey_ss58: Optional[str] = None, amount: Union[Balance, float] = None, wait_for_inclusion:bool = True, wait_for_finalization:bool = False, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Comparing Validator Dividends With and Without Liquid Alpha\nDESCRIPTION: Creates a scatter plot comparing dividends for honest validators with and without liquid alpha enabled. Points above the x=y line indicate validators receiving higher dividends with liquid alpha, confirming the approach benefits honest validators.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndf = div_rates[(div_rates.cr_interval == cr_interval) & (div_rates.alpha_high == 0.9) & (div_rates.alpha_low == 0.9) ]\ndividend_df = pd.DataFrame(list(df.dividend.values)).T\n\nfigure(figsize=(10, 7.5), dpi=80)\nplt.scatter(dividend_df.iloc[:-1, 0], la_dividend_df.iloc[:-1, 0])\nplt.plot([0.8, 1.1], [0.8, 1.1])\nplt.title('Change in divided with and without liquid alpha')\nplt.xlabel('Dividend to honest validator without liquid alpha')\nplt.ylabel(f'Dividend to honest validator with liquid alpha\\nalpha_low = {alpha_low}, alpha_high = {alpha_high}')\n```\n\n----------------------------------------\n\nTITLE: Cloning Bittensor Developer Docs Repository\nDESCRIPTION: Clone the Bittensor Developer Docs repository from GitHub to your local machine.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/developer-docs.git\n```\n\n----------------------------------------\n\nTITLE: Stream Formatter with Color and Emoji Support\nDESCRIPTION: BtStreamFormatter class that extends logging.Formatter to provide enhanced console output with colors, emojis, and custom formatting based on log levels.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/format/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass BtStreamFormatter(logging.Formatter):\n    trace = False\n\n    def format(self, record):\n        \"\"\"Override format to apply custom formatting including emojis and colors.\"\"\"\n        return super().format(record)\n\n    def formatTime(self, record, datefmt=None):\n        \"\"\"Override formatTime to add milliseconds.\"\"\"\n        return super().formatTime(record, datefmt)\n\n    def set_trace(self, state=True):\n        \"\"\"Change formatter state.\"\"\"\n        self.trace = state\n```\n\n----------------------------------------\n\nTITLE: Validating SS58 Addresses\nDESCRIPTION: Function to check if a given address is a valid SS58 address for Bittensor. SS58 is the address format used in Substrate-based chains like Bittensor. Returns a boolean indicating validity.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef is_valid_ss58_address(address):\n   \"\"\"Checks if the given address is a valid ss58 address.\n\n   :param address: The address to check.\n   :type address: str\n\n   :returns: True if the address is a valid ss58 address for Bittensor, False otherwise.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Revoking Child Hotkeys with Bittensor CLI\nDESCRIPTION: This command revokes all child hotkeys for a given parent hotkey. It requires specifying the network UID, parent hotkey, and wallet name. Note that it's not possible to revoke a specific child hotkey; all child hotkeys are revoked.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake revoke_children \\\n  --netuid <netuid> \\\n  --hotkey <parent hotkey> \\\n  --wallet.name <coldkey>\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake revoke_children \\\n  --netuid 4 \\\n  --hotkey 5DqJdDLU23m7yf6rZSmbLTshU7Bfn9eCTBkduhF4r9i73B9Y \\\n  --wallet.name Alice\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake revoke_children\n```\n\n----------------------------------------\n\nTITLE: Fixing Decoded Values in StakeInfo Class in Python\nDESCRIPTION: A class method that processes and fixes decoded values for the StakeInfo object. This is likely used during deserialization of stake information from the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/stake_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef fix_decoded_values(decoded):\n    :classmethod:\n\n\n    Fixes the decoded values.\n```\n\n----------------------------------------\n\nTITLE: Blake2 128-bit Concatenated Hash Function for Substrate Storage Keys\nDESCRIPTION: Function that calculates a 16-byte Blake2b hash and concatenates it with the original data. This combined value is used as a key for Substrate storage items.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef blake2_128_concat(data)\n```\n\n----------------------------------------\n\nTITLE: Cloning and Preparing Subtensor Repository\nDESCRIPTION: Clone the Subtensor repository, switch to the main branch, and remove any previous chain state to prepare for compilation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/subtensor.git\ncd subtensor\ngit checkout main\nrm -rf /tmp/blockchain \n```\n\n----------------------------------------\n\nTITLE: Initializing Metagraph in Python\nDESCRIPTION: Creates an instance of the Metagraph class, which represents the neural graph of the Bittensor network. It tracks various attributes of neurons and network state.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nclass Metagraph(netuid, network = settings.DEFAULT_NETWORK, lite = True, sync = True, subtensor = None):\n    # ... implementation details ...\n```\n\n----------------------------------------\n\nTITLE: Nominating a Wallet as Delegate in Bittensor\nDESCRIPTION: Method to designate a wallet's hotkey as a delegate in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nnominate(self, wallet: 'bittensor.Wallet', wait_for_finalization: bool = False, wait_for_inclusion: bool = True) -> bool\n```\n\n----------------------------------------\n\nTITLE: Importing Bittensor Logging Module in Python\nDESCRIPTION: This snippet shows how to import the logging functionality from the bittensor.utils.btlogging module. It provides access to standardized logging tools for the Bittensor package.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom bittensor.utils.btlogging import logging\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing BTCLI from Source\nDESCRIPTION: Series of commands to clone the btcli repository, navigate to its directory, and install it using pip.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-btcli.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/btcli.git\ncd btcli\npip3 install .\n```\n\n----------------------------------------\n\nTITLE: Logging Data in Bittensor\nDESCRIPTION: Demonstrates various ways to log data along with messages using the Bittensor logging module. It shows how to log tensor and numpy array data with different formatting options.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/bt-logging-levels.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport torch\nimport numpy as np\nfrom bittensor.utils.btlogging import logging\n\nraw_weights = torch.tensor([\n    0.0000, 0.0000, 0.0092, 0.0000, 0.0092, 0.0000, 0.0000, 0.0107, 0.0052,\n    0.0092, 0.0000, 0.0052, 0.0107, 0.0107, 0.0175, 0.0000, 0.0052, 0.0092,\n    0.0202, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0092, 0.0184, 0.0061,\n    0.0107, 0.0052, 0.0092, 0.0092, 0.0107, 0.0107, 0.0000, 0.0107, 0.0092,\n    0.0092, 0.0202, 0.0075, 0.0202, 0.0092, 0.0184, 0.0052, 0.0092, 0.0107,\n    0.0092, 0.0000, 0.0052, 0.0052\n])\ntest_weights = np.array([0, 0, 0, 0])\n\nlogging.set_debug()\n\n# Weights followed by string\nlogging.debug(\"Raw weights\", raw_weights)\nlogging.debug(\"Test weights\", test_weights)\nlogging.debug(f\"{raw_weights} Raw weights\")\n\n# String followed by weights\nlogging.debug(\"Raw weights\", suffix=raw_weights)\nlogging.debug(\"Test weights\", test_weights)\nlogging.debug(f\"Raw weights {raw_weights}\")\n\n# Using both prefix and suffix\n# Raw weights is the prefix and test_weights is the suffix\nlogging.debug(\"Raw and test weights\", raw_weights, test_weights)\n```\n\n----------------------------------------\n\nTITLE: Verify Body Integrity Method\nDESCRIPTION: Asynchronous method that verifies the integrity of incoming HTTP request bodies by comparing field hashes with request headers. Critical for ensuring request payload security and preventing tampering.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nasync def verify_body_integrity(request):\n    # Method implementation not shown in snippet\n    # Verifies body integrity by comparing hashes\n    pass\n```\n\n----------------------------------------\n\nTITLE: Querying Archived Blockchain Data with Bittensor Python Library\nDESCRIPTION: This snippet demonstrates how to use the Bittensor Python library to query archived blockchain data from a specific block number. It connects to an archive node and retrieves the metagraph for a given subnet and block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/index.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nmeta = bt.subtensor('archive').metagraph(netuid=18, block=12345)\nprint(meta)\n```\n\n----------------------------------------\n\nTITLE: Running Subtensor Lite Node on Testchain\nDESCRIPTION: Execute the Subtensor node in lite mode connected to the testchain, using warp sync and testnet-specific bootnode configuration.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./target/production/node-subtensor --chain ./chainspecs/raw_spec_testfinney.json --base-path /tmp/blockchain --sync=warp --port 30333 --max-runtime-instances 32 --rpc-max-response-size 2048 --rpc-cors all --rpc-port 9944 --bootnodes /dns/bootnode.test.finney.opentensor.ai/tcp/30333/ws/p2p/12D3KooWPM4mLcKJGtyVtkggqdG84zWrd7Rij6PGQDoijh1X86Vr --no-mdns --prometheus-external --rpc-external\n```\n\n----------------------------------------\n\nTITLE: Unit Conversion Command Syntax\nDESCRIPTION: Syntax for the utils convert command that allows conversion between tao and rao units.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_29\n\nLANGUAGE: bash\nCODE:\n```\nbtcli utils convert [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Creating Multiple ScheduledColdkeySwapInfo Objects from Vector Data in Python\nDESCRIPTION: Classmethod that parses a vector of unsigned 8-bit integers and returns a list of ScheduledColdkeySwapInfo objects.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/scheduled_coldkey_swap_info/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef list_from_vec_u8(vec_u8)\n```\n\n----------------------------------------\n\nTITLE: Transaction Rate Limit Query Method Python Definition\nDESCRIPTION: Method to retrieve the network's transaction rate limit as of a specific blockchain block.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_69\n\nLANGUAGE: python\nCODE:\n```\ndef tx_rate_limit(block = None)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Block Hash in Bittensor\nDESCRIPTION: Fetches the cryptographic hash of a specific block on the Bittensor blockchain, which serves as a unique identifier for blockchain verification and data integrity checking.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef get_block_hash(block = None):\n      Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier\n          representing the cryptographic hash of the block's content, ensuring its integrity and immutability.\n\n      :param block: The block number for which the hash is to be retrieved.\n      :type block: int\n\n      :returns: The cryptographic hash of the specified block.\n      :rtype: str\n\n      The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block's\n          data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the\n          trustworthiness of the blockchain.\n```\n\n----------------------------------------\n\nTITLE: Calculating allowed nonce window in nanoseconds for Bittensor axons in Python\nDESCRIPTION: Function that calculates the allowed time window for a nonce in nanoseconds. It takes the current time and an optional synapse timeout parameter, returning the appropriate nonce window boundary.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/axon_utils/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nallowed_nonce_window_ns(current_time_ns, synapse_timeout = None)\n```\n\n----------------------------------------\n\nTITLE: Blake2 256-bit Hash Function for Substrate Storage Keys\nDESCRIPTION: Helper function that calculates a 32-byte Blake2b hash for the provided data. This hash is used as a key for Substrate storage items in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef blake2_256(data)\n```\n\n----------------------------------------\n\nTITLE: Validator Directory Structure\nDESCRIPTION: Directory structure showing the organization of validator-related files in the OCR subnet, highlighting the forward.py file for communication logic and reward.py for scoring mechanisms.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n...\n├── ocr_subnet\n│   ├── __init__.py\n│  ...\n│   └── validator\n│       ├── __init__.py\n│       ├── corrupt.py\n│       ├── forward.py\n│       ├── generate.py\n│       ├── reward.py\n│       └── utils.py\n...\n```\n\n----------------------------------------\n\nTITLE: Retrieving Weight Commitment Information in Bittensor CRV3\nDESCRIPTION: Fetches CRV3 (Consensus Rank-Weight Voting v3) weight commit information for a specific subnet, returning data about weight commitments and their reveal rounds in the consensus mechanism.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef get_current_weight_commit_info(netuid, block = None):\n      Retrieves CRV3 weight commit information for a specific subnet.\n\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: The blockchain block number for the query. Default is ``None``.\n      :type block: Optional[int]\n\n      :returns: A list of commit details, where each entry is a dictionary with keys 'who', 'serialized_commit', and\n                'reveal_round', or an empty list if no data is found.\n      :rtype: list\n```\n\n----------------------------------------\n\nTITLE: Sudo Commands in Bittensor CLI\nDESCRIPTION: Administrative commands for managing subnet parameters, including setting and getting hyperparameters, managing the senate, and handling proposals.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set\nbtcli sudo get\nbtcli sudo senate\nbtcli sudo proposals\nbtcli sudo senate-vote\nbtcli sudo set-take\nbtcli sudo get-take\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor Wallet SDK from Source\nDESCRIPTION: Steps to clone the repository, set up a virtual environment, and install the Bittensor Wallet SDK from source using maturin.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv btwallet-venv  # create a virtual env\nsource venv/bin/activate  # activate the env\ngit clone https://github.com/opentensor/btwallet.git\ncd btwallet\npip install maturin\nmaturin develop\n```\n\n----------------------------------------\n\nTITLE: Querying Subtensor Map Storage in Bittensor (Python)\nDESCRIPTION: Retrieves map-like data structures from the Subtensor module, providing insights into neuron-specific details or network-wide attributes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_52\n\nLANGUAGE: python\nCODE:\n```\ndef query_map_subtensor(name, block = None, params = None):\n    # Method implementation\n```\n\n----------------------------------------\n\nTITLE: Cloning Bittensor repository\nDESCRIPTION: Git command to clone the Bittensor repository from GitHub for installation from source.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/bittensor.git\n```\n\n----------------------------------------\n\nTITLE: Logging and Handling Errors in Bittensor Axon Server (Python)\nDESCRIPTION: This function logs errors and updates the synapse object with appropriate error details. It handles exceptions, sets status codes, and calculates processing time if a start time is provided.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef log_and_handle_error(synapse, exception, status_code = None, start_time = None):\n    # Function implementation\n```\n\n----------------------------------------\n\nTITLE: Processing Responses from Bittensor Network in Python\nDESCRIPTION: An abstract method declaration for processing the responses received from the network in the SubnetsAPI class. This method must be implemented by concrete subclasses.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/subnets/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@abstractmethod\ndef process_responses(responses):\n    \"\"\"\n    Process the responses from the network.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Bootstrap Version and License Declaration\nDESCRIPTION: Core version declaration and copyright notice for Bootstrap v5.3.3, including MIT license reference and link to authors.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_static/scripts/bootstrap.js.LICENSE.txt#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n/*!\n  * Bootstrap v5.3.3 (https://getbootstrap.com/)\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n```\n\n----------------------------------------\n\nTITLE: Stopping and Cleaning Docker Environment\nDESCRIPTION: This command stops any running Docker containers, removes volumes, and prunes the Docker system. It ensures a clean environment before starting a new Subtensor node.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ndocker compose down --volumes && docker system prune -a --volumes -f\n```\n\n----------------------------------------\n\nTITLE: Defining Transaction-Specific Errors\nDESCRIPTION: Specific error classes for different types of transaction failures extending ChainTransactionError.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/errors/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass StakeError(ChainTransactionError):\n    \"\"\"Error raised when a stake transaction fails.\"\"\"\n    pass\n\nclass TransferError(ChainTransactionError):\n    \"\"\"Error raised when a transfer transaction fails.\"\"\"\n    pass\n\nclass UnstakeError(ChainTransactionError):\n    \"\"\"Error raised when an unstake transaction fails.\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Defining PrometheusInfo Class in Python\nDESCRIPTION: This code snippet defines the PrometheusInfo class, a dataclass representing Prometheus-related information. It includes attributes for block, version, IP, port, and IP type, as well as a class method for fixing decoded values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/prometheus_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass PrometheusInfo:\n\n   block: int\n   version: int\n   ip: str\n   port: int\n   ip_type: int\n\n   @classmethod\n   def fix_decoded_values(prometheus_info_decoded):\n      # Returns a PrometheusInfo object from a prometheus_info_decoded dictionary.\n      pass\n```\n\n----------------------------------------\n\nTITLE: Displaying Subnet Information with Dynamic TAO CLI\nDESCRIPTION: Example output from btcli subnet list command showing subnet statistics including price, market cap, emissions, and stake information for various subnets in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/dtao-guide.md#2025-04-22_snippet_0\n\nLANGUAGE: txt\nCODE:\n```\n        ┃               ┃ Price       ┃ Market Cap  ┃              ┃                         ┃               ┃              ┃\n Netuid ┃ Name          ┃ (τ_in/α_in) ┃ (α * Price) ┃ Emission (τ) ┃ P (τ_in, α_in)          ┃ Stake (α_out) ┃ Supply (α)   ┃ Tempo (k/n)\n━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━╇━━━━━━━━━━━━━\n   0    │ τ root        │ 1.00 τ/Τ    │ τ 5.93m     │ τ 0.0000     │ -, -                    │ Τ 5.93m       │ 5.93m Τ /21M │ -/-\n   3    │ γ templar     │ 0.02 τ/γ    │ τ 57.32     │ τ 0.0197     │ τ 31.44, 1.43k γ        │ 1.18k γ       │ 2.61k γ /21M │ 67/99\n   9    │ ι pretrain    │ 0.02 τ/ι    │ τ 55.38     │ τ 0.0194     │ τ 30.91, 1.46k ι        │ 1.16k ι       │ 2.61k ι /21M │ 73/99\n   1    │ α apex        │ 0.02 τ/α    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k α        │ 1.14k α       │ 2.61k α /21M │ 65/99\n   2    │ β omron       │ 0.02 τ/β    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k β        │ 1.14k β       │ 2.61k β /21M │ 66/99\n   4    │ δ targon      │ 0.02 τ/δ    │ τ 54.45     │ τ 0.0192     │ τ 30.65, 1.47k δ        │ 1.14k δ       │ 2.61k δ /21M │ 68/99\n   ...\n```\n\n----------------------------------------\n\nTITLE: Retrieving Block Hash from Bittensor Blockchain (Python)\nDESCRIPTION: This asynchronous method obtains the cryptographic hash of a specified block on the Bittensor blockchain. The block hash uniquely identifies the block and ensures data integrity in the blockchain.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nget_block_hash(block = None)\n```\n\n----------------------------------------\n\nTITLE: Configuring Ethereum Private Key in JavaScript\nDESCRIPTION: This code snippet demonstrates how to set the Ethereum private key in the config.js file. The private key is used for authentication and transaction signing when interacting with the Bittensor EVM network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/evm-mainnet-with-metamask-wallet.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst ethPrivateKey = \"02c1c4112233snipsnipsnipgh933aca491e090e0b7xxyy1b124b86d9382b01a8\";\n```\n\n----------------------------------------\n\nTITLE: Two x64 Concatenated Hash Function for Substrate Storage Keys\nDESCRIPTION: Helper function that calculates an xxh64 hash and concatenates it with the original data. This is used as a key for several Substrate storage operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef two_x64_concat(data)\n```\n\n----------------------------------------\n\nTITLE: Clipping Validator Weights in Yuma Consensus\nDESCRIPTION: This LaTeX equation shows how validator weights are clipped to the benchmark weight in the Yuma Consensus algorithm.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\overline{W_{ij}} = \\min( W_{ij}, \\overline{W_j} )\n```\n\n----------------------------------------\n\nTITLE: Defining Bittensor Core Settings Constants in Python\nDESCRIPTION: This snippet defines various constants used in the Bittensor core settings. It includes network endpoints, blockchain parameters, and system configurations. These constants are essential for the operation and configuration of the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/settings/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nARCHIVE_ENTRYPOINT = 'wss://archive.chain.opentensor.ai:443'\nBLOCKTIME = 12\nDEFAULT_ENDPOINT = 'wss://entrypoint-finney.opentensor.ai:443'\nDEFAULT_NETWORK = 'finney'\nDELEGATES_DETAILS_URL = 'https://raw.githubusercontent.com/opentensor/bittensor-delegates/main/public/delegates.json'\nFINNEY_ENTRYPOINT = 'wss://entrypoint-finney.opentensor.ai:443'\nFINNEY_TEST_ENTRYPOINT = 'wss://test.finney.opentensor.ai:443'\nNETWORKS = ['finney', 'test', 'archive', 'local', 'subvortex']\nPIPADDRESS = 'https://pypi.org/pypi/bittensor/json'\nSS58_ADDRESS_LENGTH = 48\nSS58_FORMAT = 42\nSUBVORTEX_ENTRYPOINT = 'ws://subvortex.info:9944'\nRAO_SYMBOL: str\nTAO_SYMBOL: str\nTYPE_REGISTRY: dict[str, dict]\nversion_as_int: int\nversion_split\n```\n\n----------------------------------------\n\nTITLE: Logging CUDA Errors in Python\nDESCRIPTION: This function logs any CUDA errors that occur during execution. It doesn't take any parameters and doesn't return any value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/register_cuda/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef log_cuda_errors():\n    \"\"\"Logs any CUDA errors.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Websocket Endpoint URL Formatter\nDESCRIPTION: Function that formats a websocket endpoint URL to ensure proper ws:// or wss:// protocol prefix while preserving port information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/networking/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_formatted_ws_endpoint_url(endpoint_url):\n    \"\"\"Returns a formatted websocket endpoint url.\n    Note: The port (or lack thereof) is left unchanged\n    :param endpoint_url: The endpoint url to format.\n    :type endpoint_url: Optional[str]\n    :returns: The formatted endpoint url. In the form of ws://<endpoint_url> or wss://<endpoint_url>\n    :rtype: formatted_endpoint_url (Optional[str])\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Navigating to the EVM-Bittensor Project Directory\nDESCRIPTION: This command changes the current directory to the newly cloned 'evm-bittensor' folder. It's necessary to be in the correct directory before installing dependencies.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/install.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd evm-bittensor\n```\n\n----------------------------------------\n\nTITLE: Converting SS58 Address to Bytes\nDESCRIPTION: Function to convert a SS58 address to a bytes object. This is useful for operations that require the raw binary representation of the address rather than the encoded format.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef ss58_address_to_bytes(ss58_address):\n   \"\"\"Converts a ss58 address to a bytes object.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Signing and Sending Extrinsics with Nonce\nDESCRIPTION: Helper async function that signs an extrinsic call with the wallet hotkey and submits it to the blockchain. It can add an optional era period and manages the transaction submission process.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/weights/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def sign_and_send_with_nonce(subtensor, call, wallet, wait_for_inclusion, wait_for_finalization, period = None)\n```\n\n----------------------------------------\n\nTITLE: Initializing Bittensor Configuration Example in Python\nDESCRIPTION: Example showing how to initialize and configure various Bittensor modules using the Config class. Demonstrates adding arguments from different components like Axon, Subtensor, Wallet, and logging.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/config/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport argparse\nimport bittensor as bt\n\nparser = argparse.ArgumentParser('Miner')\nbt.Axon.add_args(parser)\nbt.Subtensor.add_args(parser)\nbt.Async_subtensor.add_args(parser)\nbt.Wallet.add_args(parser)\nbt.logging.add_args(parser)\nbt.PriorityThreadPoolExecutor.add_args(parser)\nconfig = bt.config(parser)\n\nprint(config)\n```\n\n----------------------------------------\n\nTITLE: Mock Subtensor State Type Definition\nDESCRIPTION: TypedDict class defining the structure for mocking Subtensor state, including various network parameters and configurations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass MockSubtensorState(TypedDict):\n    Active: dict[int, dict[BlockNumber, bool]]\n    Delegates: dict[str, dict[int, float]]\n    Difficulty: dict[int, dict[BlockNumber, int]]\n    ImmunityPeriod: dict[int, dict[BlockNumber, int]]\n    Kappa: dict[int, dict[BlockNumber, int]]\n    NetworksAdded: dict[int, dict[BlockNumber, bool]]\n    Rho: dict[int, dict[BlockNumber, int]]\n    Stake: dict[str, dict[str, dict[int, int]]]\n    ValidatorBatchSize: dict[int, dict[BlockNumber, int]]\n```\n\n----------------------------------------\n\nTITLE: Converting Strings to Boolean Values\nDESCRIPTION: Function to convert string representations of boolean values to actual boolean types. It accepts various truth-y values ('y', 'yes', 't', 'true', 'on', '1') and false-y values ('n', 'no', 'f', 'false', 'off', '0').\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef strtobool(val):\n   \"\"\"Converts a string to a boolean value.\n\n   truth-y values are 'y', 'yes', 't', 'true', 'on', and '1';\n   false-y values are 'n', 'no', 'f', 'false', 'off', and '0'.\n\n   Raises ValueError if 'val' is anything else.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Converting RAO to TAO units in BTCLI\nDESCRIPTION: New BTCLI command for converting between RAO and TAO units. This allows users to easily convert between the two token denominations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nbtcli utils convert --rao <rao units> --tao <tao units>\n```\n\n----------------------------------------\n\nTITLE: Implementing Shutdown Method for PriorityThreadPoolExecutor\nDESCRIPTION: A method that safely cleans up resources associated with the Executor. It can be called multiple times and supports waiting for running futures to finish before shutting down.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/threadpool/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef shutdown(wait=True):\n   \"\"\"\n   Clean-up the resources associated with the Executor.\n\n   It is safe to call this method several times. Otherwise, no other\n   methods can be called after this one.\n\n   :param wait: If True then shutdown will not return until all running\n                futures have finished executing and the resources used by the\n                executor have been reclaimed.\n   :param cancel_futures: If True then shutdown will cancel all pending\n                          futures. Futures that are completed or running will not be\n                          cancelled.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Resetting CUDA Environment in Python\nDESCRIPTION: This function resets the CUDA environment. It doesn't take any parameters and doesn't return any value.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/register_cuda/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef reset_cuda():\n    \"\"\"Resets the CUDA environment.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating Relative Dividend Rate for Weight Copiers\nDESCRIPTION: Defines a function that calculates the relative dividend rate (G) for weight copiers under different parameter settings. The function processes simulation results to determine how much discount in dividends is given to weight copiers compared to honest validators.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef get_relative_dividend_rate(setup):\n    div_rates = []\n\n    for netuid in setup.netuids:\n        for cr_interval in setup.cr_intervals:\n            for alpha_low in setup.alpha_lows:\n                for alpha_high in setup.alpha_highs:\n                    if alpha_low > alpha_high:\n                        continue\n            \n                    with open(f\"{setup.result_path}/yuma_result_netuid{netuid}_conceal{cr_interval}_al{alpha_low:.1f}_ah{alpha_high:.1f}.pkl\", 'rb') as handle:\n                        _yuma_results = pickle.load(handle)\n\n                    dividend = [\n                        (s[\"validator_reward_normalized\"] / s[\"stake\"]).tolist()\n                        for idx, s in _yuma_results.items()\n                    ]\n\n                    dividend_df = pd.DataFrame(\n                        dividend,\n                        columns=[f\"v{i}\" for i in range(len(dividend[0]) - 1 )] + [\"v_bad\"],\n                    )\n                    \n                    div_last = dividend_df.iloc[-1]\n                    if (div_last.isna()).any():\n                        div_rate = None\n                    else:\n                        div_rate = div_last[-1] / div_last[:-1].median() \n\n                    div_rates.append([netuid, cr_interval, alpha_low, alpha_high, div_rate, div_last])\n\n    div_rates = pd.DataFrame(div_rates, dtype='float64', columns = ['netuid', 'cr_interval', 'alpha_low', 'alpha_high', 'G', 'dividend'])\n    div_rates.index = div_rates.index.map(lambda x : x)\n\n    return div_rates\n```\n\n----------------------------------------\n\nTITLE: Querying BlocksSinceLastStep in Python using SubstrateInterface\nDESCRIPTION: This snippet shows how to query the BlocksSinceLastStep storage item for a specific network ID (netuid). It retrieves the number of blocks since the last mechanism step.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'BlocksSinceLastStep', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Initializing NonTorch Metagraph Example\nDESCRIPTION: Example demonstrating how to initialize a lite version of the metagraph without PyTorch dependency for basic network operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/metagraph/index.rst#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.core.metagraph import Metagraph\n\nmetagraph = Metagraph(netuid=123, network=\"finney\", lite=True, sync=True)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Transaction Rate Limit in Bittensor (Python)\nDESCRIPTION: This asynchronous method retrieves the transaction rate limit for the Bittensor network. It can query this information at a specific blockchain block (by number or hash) and returns the integer value or None if not available. This parameter helps manage network load and prevent congestion.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_59\n\nLANGUAGE: python\nCODE:\n```\ntx_rate_limit(block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: SCALE Encoding Decoder Function\nDESCRIPTION: Function to decode SCALE encoded data based on type name and modifiers. Handles vector and optional types, returning decoded data as a dictionary.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/utils/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef from_scale_encoding(input_, type_name, is_vec = False, is_option = False):\n    \"\"\"Decodes input_ data from SCALE encoding based on the specified type name and modifiers.\"\"\"\n    return Optional[dict]\n```\n\n----------------------------------------\n\nTITLE: Pulling Latest Main Branch Contents\nDESCRIPTION: This command updates the local repository with the latest changes from the remote main branch, ensuring you have the most up-to-date code.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ngit pull\n```\n\n----------------------------------------\n\nTITLE: Getting Explorer URL for Network and Block Hash\nDESCRIPTION: Function to retrieve the explorer URL for a given network and block hash. It uses a network map to look up the appropriate explorer URL based on the provided network identifier.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_explorer_url_for_network(network, block_hash, network_map):\n   \"\"\"Returns the explorer url for the given block hash and network.\n\n   :param network: The network to get the explorer url for.\n   :type network: str\n   :param block_hash: The block hash to get the explorer url for.\n   :type block_hash: str\n   :param network_map: The network maps to get the explorer urls from.\n   :type network_map: dict[str, dict[str, str]]\n\n   :returns: The explorer url for the given block hash and network.\n             Or None if the network is not known.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Utility Functions in Bittensor CLI\nDESCRIPTION: Utility command for performing conversions between minimal units (RAO) and TAO, or other chain-specific conversions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbtcli utils convert\n```\n\n----------------------------------------\n\nTITLE: Initializing Subtensor Instance in Python\nDESCRIPTION: This snippet demonstrates how to initialize a Subtensor instance with configuration, network, and chain endpoint parameters. It explains the required arguments and their purposes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nobj = bt.subtensor( config, network, chain_endpoint )\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Subtensor Methods for Data Operations\nDESCRIPTION: Methods in the MockSubtensor class that simulate data-related operations such as committing data to the blockchain and retrieving commitments without requiring an actual blockchain connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef commit(wallet, netuid, data):\n\n      Commits arbitrary data to the Bittensor network by publishing metadata.\n\n      :param wallet: The wallet associated with the neuron committing the data.\n      :type wallet: bittensor_wallet.Wallet\n      :param netuid: The unique identifier of the subnetwork.\n      :type netuid: int\n      :param data: The data to be committed to the network.\n      :type data: str\n```\n\nLANGUAGE: python\nCODE:\n```\ndef get_commitment(netuid, uid, block = None):\n\n      Retrieves the on-chain commitment for a specific neuron in the Bittensor network.\n\n      :param netuid: The unique identifier of the subnetwork.\n      :type netuid: int\n      :param uid: The unique identifier of the neuron.\n      :type uid: int\n      :param block: The block number to retrieve the commitment from. If None, the latest block is used.\n                    Default is ``None``.\n      :type block: Optional[int]\n\n      :returns: The commitment data as a string.\n      :rtype: str\n```\n\n----------------------------------------\n\nTITLE: Implementing PriorityThreadPoolExecutor Class Method for Argument Parsing\nDESCRIPTION: A class method that accepts specific arguments from a parser, allowing configuration of the ThreadPoolExecutor through command-line arguments.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/threadpool/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef add_args(parser, prefix = None):\n   \"\"\"\n   Accept specific arguments from parser\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Bittensor App Component in TypeScript\nDESCRIPTION: This TypeScript code configures a Bittensor App component, setting up the data provider and defining resources for blog posts with various routes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst App = () => (\n  <Bittensor\n    dataProvider={dataProvider}\n    resources={\n\t[{\n      \t\tname: \"blog_posts\",\n      \t\tlist: \"/blog-posts\",\n      \t\tshow: \"/blog-posts/show/:id\",\n      \t\tcreate: \"/blog-posts/create\",\n      \t\tedit: \"/blog-posts/edit/:id\",},\n\t]}\n  >\n    /* ... */\n  </Bittensor>\n);\n```\n\n----------------------------------------\n\nTITLE: Preparing Synapse Payload in Bittensor SubnetsAPI in Python\nDESCRIPTION: An abstract method declaration for preparing the synapse-specific payload in the SubnetsAPI class. This method must be implemented by concrete subclasses.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/subnets/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@abstractmethod\ndef prepare_synapse(*args, **kwargs):\n    \"\"\"\n    Prepare the synapse-specific payload.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Solving PoW Problem with CUDA in Python\nDESCRIPTION: This function solves the Proof of Work (PoW) problem using CUDA. It takes various parameters to configure the solving process, including the starting nonce, update interval, threads per block, block and hotkey hash, difficulty, and nonce limit. It returns a tuple containing the solution nonce and seal, or -1 for the nonce if no solution is found.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/register_cuda/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef solve_cuda(nonce_start, update_interval, tpb, block_and_hotkey_hash_bytes, difficulty, limit, dev_id = 0):\n    \"\"\"Solves the PoW problem using CUDA.\n\n    :param nonce_start: Starting nonce.\n    :type nonce_start: numpy.int64\n    :param update_interval: Number of nonces to solve before updating block information.\n    :type update_interval: numpy.int64\n    :param tpb: Threads per block.\n    :type tpb: int\n    :param block_and_hotkey_hash_bytes: Keccak(Bytes of the block hash + bytes of the hotkey) 64 bytes.\n    :type block_and_hotkey_hash_bytes: bytes\n    :param difficulty: Difficulty of the PoW problem.\n    :type difficulty: int\n    :param limit: Upper limit of the nonce.\n    :type limit: int\n    :param dev_id: The CUDA device ID. Defaults to ``0``.\n    :type dev_id: int\n\n    :returns:\n\n              Tuple of the nonce and the seal corresponding\n                  to the solution. Returns -1 for nonce if no solution is found.\n    :rtype: (Union[tuple[Any, bytes], tuple[int, bytes], tuple[Any, None]])\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Querying PendingChildKeys in Python\nDESCRIPTION: Retrieves pending child keys that will be applied after cooldown for a specific network and parent.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface, Keypair\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nparent = Keypair.create_from_uri('//Alice').ss58_address\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'PendingChildKeys', [netuid, parent])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using a Synapse Instance in Python\nDESCRIPTION: Example demonstrating how to create a Synapse instance, set its properties, serialize/deserialize it, and check request status. This shows the basic workflow for using the Synapse class for network communication in Bittensor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/synapse/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Creating a Synapse instance with default values\nfrom bittensor.core.synapse import Synapse\n\nsynapse = Synapse()\n\n# Setting properties and input\nsynapse.timeout = 15.0\nsynapse.name = \"MySynapse\"\n\n# Not setting fields that are not defined in your synapse class will result in an error, e.g.:\nsynapse.dummy_input = 1 # This will raise an error because dummy_input is not defined in the Synapse class\n\n# Get a dictionary of headers and body from the synapse instance\nsynapse_dict = synapse.model_dump_json()\n\n# Get a dictionary of headers from the synapse instance\nheaders = synapse.to_headers()\n\n# Reconstruct the synapse from headers using the classmethod 'from_headers'\nsynapse = Synapse.from_headers(headers)\n\n# Deserialize synapse after receiving it over the network, controlled by `deserialize` method\ndeserialized_synapse = synapse.deserialize()\n\n# Checking the status of the request\nif synapse.is_success:\n    print(\"Request succeeded\")\n\n# Checking and setting the status of the request\nprint(synapse.axon.status_code)\nsynapse.axon.status_code = 408 # Timeout\n```\n\n----------------------------------------\n\nTITLE: Block Update Function for Thread-Safe Operations\nDESCRIPTION: Updates current block data and difficulty in a thread-safe manner. Handles block number updates, hash computations with hotkey, and difficulty packing.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef update_curr_block(curr_diff, curr_block, curr_block_num, block_number, block_bytes, diff, hotkey_bytes, lock):\n    \"\"\"Update the current block data with the provided block information and difficulty.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Running Lite Node on Mainchain with Docker\nDESCRIPTION: This command starts a Subtensor lite node connected to the Bittensor mainchain using Docker. It uses the provided script with specific parameters for the network and node type.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/run/subtensor.sh -e docker --network mainnet --node-type lite\n```\n\n----------------------------------------\n\nTITLE: Downloading Metagraphs for Bittensor Subnet Analysis\nDESCRIPTION: Executes the download of metagraphs for the specified Bittensor subnets using the configured experiment setup.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/commit_reveal_diagnostic.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom download_metagraphs import DownloadMetagraph\nDownloadMetagraph(setup = setup).run()\n```\n\n----------------------------------------\n\nTITLE: Running Node.js Scripts for TAO Transfer\nDESCRIPTION: These bash commands are used to execute the Node.js scripts that perform the TAO transfer. The transfer.js script is run first, followed by the withdraw.js script.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/transfer-from-metamask-to-ss58.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode transfer.js\n```\n\nLANGUAGE: bash\nCODE:\n```\nnode withdraw.js\n```\n\n----------------------------------------\n\nTITLE: Using Color Tags in Bittensor Log Messages\nDESCRIPTION: Illustrates how to add color to log messages using color tags in the Bittensor logging module. This feature helps in visually distinguishing different parts of log messages.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/bt-logging-levels.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.utils.btlogging import logging\n\nlogging.warning(\"[red]This will print red[/red] and [yellow]this will print yellow[/yellow]\")\n```\n\n----------------------------------------\n\nTITLE: Type String SCALE Decoder Function\nDESCRIPTION: Function to decode SCALE encoded data using a type string specification. Takes encoded input and type string, returns decoded dictionary data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/utils/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef from_scale_encoding_using_type_string(input_, type_string):\n    \"\"\"Decodes SCALE encoded data to a dictionary based on the provided type string.\"\"\"\n    return Optional[dict]\n```\n\n----------------------------------------\n\nTITLE: Running Weight Copy Simulation\nDESCRIPTION: Executes the weight copy simulation to analyze validator behavior under different liquid alpha parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic_all_SN.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom weight_copy_simulation import WeightCopySimulation\nWeightCopySimulation(setup = setup).run_simulation()\n```\n\n----------------------------------------\n\nTITLE: Defining Version Check Error Exception in Python\nDESCRIPTION: Creates a custom exception class for handling errors during the version check process. This exception inherits from the base Exception class.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/version/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nclass VersionCheckError(Exception):\n    \"\"\"Exception raised for errors in the version check process.\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor Wallet SDK from PyPI\nDESCRIPTION: Commands to create a virtual environment, activate it, and install the Bittensor Wallet SDK using pip.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/install-wallet-sdk.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ python3 -m venv btwallet-venv  # create a virtual env\n$ source btwallet-venv/bin/activate  # activate the env\n$ pip install bittensor-wallet  # install bittensor-wallet\n```\n\n----------------------------------------\n\nTITLE: Subnet Management with btcli subnet\nDESCRIPTION: This is the main command for subnet-related operations. It provides access to various subnet management subcommands.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_12\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet [OPTIONS] COMMAND [ARGS]...\n```\n\n----------------------------------------\n\nTITLE: Converting AxonServeCallParams to Dictionary\nDESCRIPTION: Method that returns a dictionary representation of AxonServeCallParams object, conditionally including the certificate field if it exists.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/types/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef dict():\n    \"\"\"Returns a dict representation of this object. If `self.certificate` is `None`,\n    it is not included in this.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Calculating TAO Reserve Injection in Bittensor Network\nDESCRIPTION: This formula calculates the TAO emission to a specific subnet based on its token price relative to other subnets. It uses the total per block TAO emission and the prices of all subnet tokens.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\Delta\\tau_i = \\Delta\\bar{\\tau} \\times\n\\frac\n  {p_i}\n  {\\sum_{j \\in \\mathbb{S}}\n\\bigl(p_j)}\n$$\n```\n\n----------------------------------------\n\nTITLE: LazyLoadedTorch Utility for Bittensor\nDESCRIPTION: A lazy-loading proxy class for the PyTorch module that delays loading until actually needed, which can improve startup time and resource usage when PyTorch is not required.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\nclass LazyLoadedTorch:\n   \"\"\"A lazy-loading proxy for the torch module.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Displaying BalanceTooLow Error in Bash\nDESCRIPTION: Illustrates the error message when the requested stake amount exceeds the available balance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 2'\n}\n```\n\n----------------------------------------\n\nTITLE: Retrieving Last Drand Round in Bittensor (Python)\nDESCRIPTION: Retrieves the last drand round emitted in Bittensor, which corresponds to when committed weights will be revealed. This information is crucial for understanding the timing of weight revelations in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\ndef last_drand_round():\n    \"\"\"\n    Retrieves the last drand round emitted in bittensor. This corresponds when committed weights will be revealed.\n\n    :returns: The latest Drand round emitted in bittensor.\n    :rtype: int\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Getting UID for Hotkey on Subnet\nDESCRIPTION: This method retrieves the unique identifier for a neuron's hotkey within a specific subnet using its SS58 address. It indicates whether the neuron is active on the subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\n.. py:method:: get_uid_for_hotkey_on_subnet(hotkey_ss58, netuid, block = None)\n\n      Retrieves the unique identifier (UID) for a neuron's hotkey on a specific subnet.\n\n      :param hotkey_ss58: The ``SS58`` address of the neuron's hotkey.\n      :type hotkey_ss58: str\n      :param netuid: The unique identifier of the subnet.\n      :type netuid: int\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: The UID of the neuron if it is registered on the subnet, ``None`` otherwise.\n      :rtype: Optional[int]\n\n      The UID is a critical identifier within the network, linking the neuron's hotkey to its operational and\n          governance activities on a particular subnet.\n```\n\n----------------------------------------\n\nTITLE: Querying Weight Commit-Reveal Interval in Bittensor with Python\nDESCRIPTION: This example demonstrates how to query the interval for the commit-reveal process of weights in a specific Bittensor subnet. It connects to the Finney test network and retrieves the block interval parameter used in the weight setting mechanism.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_55\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'WeightCommitRevealInterval', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Exception Definition for External IP Not Found\nDESCRIPTION: Custom exception class raised when external IP address cannot be determined through various methods (CURL/URLLIB/IPIFY/AWS).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/networking/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ExternalIPNotFound(Exception):\n    \"\"\"Raised if we cannot attain your external ip from CURL/URLLIB/IPIFY/AWS\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Running Lite Node on Testchain with Docker\nDESCRIPTION: This command starts a Subtensor lite node connected to the Bittensor testchain using Docker. It uses the provided script with specific parameters for the network and node type.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/run/subtensor.sh -e docker --network testnet --node-type lite\n```\n\n----------------------------------------\n\nTITLE: Setting up Liquid Alpha Experiment Environment\nDESCRIPTION: Initializes the experimental setup for liquid alpha weight consensus testing by importing required libraries and configuring experiment parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic_all_SN.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os \nimport pickle\n\nimport torch \nimport numpy as np\nimport pandas as pd\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\n\nimport bittensor as bt\n\nfrom experiment_setup import ExperimentSetup\n\nsetup = ExperimentSetup(\n    processes = 1, # processes to run with \n    liquid_alpha = True, \n)\n```\n\n----------------------------------------\n\nTITLE: Setting up EVM Localnet and Subnet in Bash\nDESCRIPTION: Commands to create a subnet, register a neuron, and nominate a hotkey as a delegate on the EVM localnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/staking-precompile.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet create --subtensor.chain_endpoint ws://127.0.0.1:9944\nbtcli subnet register --subtensor.chain_endpoint ws://127.0.0.1:9944\nbtcli root nominate --subtensor.chain_endpoint ws://127.0.0.1:9944\n```\n\n----------------------------------------\n\nTITLE: Root Network Registration\nDESCRIPTION: Asynchronous method to register a neuron at the root level by recycling TAO tokens.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_48\n\nLANGUAGE: python\nCODE:\n```\nasync def root_register(wallet, block_hash = None, wait_for_inclusion = True, wait_for_finalization = True)\n```\n\n----------------------------------------\n\nTITLE: Converting from neuron_info dictionary to AxonInfo object\nDESCRIPTION: A class method that converts a dictionary containing neuron information to an AxonInfo object instance.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef from_neuron_info(neuron_info):\n    \"\"\"\n    Converts a dictionary to an `AxonInfo` object.\n\n    :param neuron_info: A dictionary containing the neuron information.\n    :type neuron_info: dict\n\n    :returns: An instance of AxonInfo created from the dictionary.\n    :rtype: instance (AxonInfo)\n    \"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Import Statements for Documentation Components\nDESCRIPTION: React/Docusaurus import statements for themed image components used in documentation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/dtao-faq.md#2025-04-22_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport ThemedImage from '@theme/ThemedImage';\nimport useBaseUrl from '@docusaurus/useBaseUrl';\n```\n\n----------------------------------------\n\nTITLE: Installing Rust Toolchain for Subtensor\nDESCRIPTION: Set up the Rust toolchain with specific targets and nightly version, necessary for building Subtensor node.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nrustup default stable\nrustup update\nrustup target add wasm32-unknown-unknown\nrustup toolchain install nightly\nrustup target add --toolchain nightly wasm32-unknown-unknown\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor SDK from PyPi\nDESCRIPTION: Pip command to install Bittensor SDK directly from PyPi, which includes btcli.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install bittensor\n```\n\n----------------------------------------\n\nTITLE: Configuring Private Key and RPC Endpoint in JavaScript\nDESCRIPTION: JavaScript code snippet for configuring the Ethereum private key and RPC endpoints in the config.js file for interacting with the Bittensor EVM localnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/evm-localnet-with-metamask-wallet.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst ethPrivateKey = \"02c1c4112233snipsnipsnipgh933aca491e090e0b7xxyy1b124b86d9382b01a8\";\n\nmodule.exports = {\nethPrivateKey,\nsubSeed,\nrpcUrl: rpcUrlLocal,\nwsUrl: wsUrlLocal,\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Proportional Emissions to Root Stakers in Bittensor Network\nDESCRIPTION: This formula calculates the percentage of emissions allocated to root stakers (TAO holders) based on a validator's stake weight proportion of TAO.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\text{proportional emissions (\\%) to root stakers} \n= \\frac{\\tau_{x}{} \\, w_{\\tau}}\n     {\\alpha_{x} + \\tau_{x} \\, w_{\\tau}}\n$$\n```\n\n----------------------------------------\n\nTITLE: Displaying StakeAmountTooLow Error in Bash\nDESCRIPTION: Shows the error message when the staking/unstaking/moving amount is below the minimum TAO equivalent of 500,000 RAO or 0.0005 TAO.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 1'\n}\n```\n\n----------------------------------------\n\nTITLE: Querying Constants from Bittensor Blockchain\nDESCRIPTION: Method to retrieve constant values from specified modules in the Bittensor blockchain. Used for accessing fixed parameters and network configuration values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef query_constant(module_name, constant_name, block = None):\n```\n\n----------------------------------------\n\nTITLE: Setting Child Hotkey Take Rate with Bittensor CLI\nDESCRIPTION: This command sets the take percentage of a child hotkey for a specific network UID. The take rate can be between 0% and 18%. The child hotkey take rate is subnet-specific and applies to all parent hotkeys for which this hotkey is the child hotkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/child-hotkeys.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake set_childkey_take \\\n  --netuid <netuid> \\\n  --hotkey <child hotkey> \\\n  --take <decimal number> \\\n  --wallet.name <coldkey>\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake set_childkey_take \\\n  --netuid 4 \\\n  --hotkey 5DqJdDLU23m7yf6rZSmbLTshU7Bfn9eCTBkduhF4r9i73B9Y \\\n  --take 0.09 \\\n  --wallet.name Alice\n```\n\n----------------------------------------\n\nTITLE: Installing Redis using NPM\nDESCRIPTION: This command installs Redis globally using NPM (Node Package Manager).\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm i -g redis\n```\n\n----------------------------------------\n\nTITLE: Specifying Testnet in Bittensor CLI\nDESCRIPTION: This command shows how to specify the testnet when performing a wallet operation in the Bittensor CLI. It uses the --subtensor.network parameter to set the network to 'test'.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-networks.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet swap_hotkey --subtensor.network test\n```\n\n----------------------------------------\n\nTITLE: Creating Asynchronous Proof-of-Work Solution in Bittensor (Python)\nDESCRIPTION: An asynchronous function that generates a Proof-of-Work solution for registering a wallet on a Bittensor subnet. Supports both CPU and CUDA-based computation with configurable parameters for optimization and monitoring progress.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/async_pow/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def create_pow_async(subtensor, wallet, netuid, output_in_place = True, cuda = False, dev_id = 0, tpb = 256, num_processes = None, update_interval = None, log_verbose = False)\n```\n\n----------------------------------------\n\nTITLE: Configuring BTCLI for Multisig Wallet\nDESCRIPTION: Commands to regenerate the coldkey public key for the multisig wallet and view its dashboard in BTCLI.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/keys/multisig.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w regen_coldkeypub --wallet.name multisig\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli view dashboard --wallet.name multisig\n```\n\n----------------------------------------\n\nTITLE: Using torch Library with Environment Variable\nDESCRIPTION: Setting an environment variable to use the torch library instead of the default numpy library in Bittensor 7.0.0 and later.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nUSE_TORCH=1\n```\n\n----------------------------------------\n\nTITLE: Calculating time difference between current time and synapse nonce in Python\nDESCRIPTION: Function that computes the difference in seconds between the current time and a synapse nonce, along with the allowed delta. Used for validating nonce timing in the Bittensor protocol.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/axon_utils/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ncalculate_diff_seconds(current_time, synapse_timeout, synapse_nonce)\n```\n\n----------------------------------------\n\nTITLE: Installing Protobuf on macOS for Subtensor\nDESCRIPTION: Install the protobuf package on macOS using Homebrew, which is a prerequisite for Subtensor node installation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbrew install protobuf\n```\n\n----------------------------------------\n\nTITLE: Compiling Subtensor Node from Source\nDESCRIPTION: Build the Subtensor node using Cargo with production profile and metadata-hash feature enabled.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-source.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\ncargo build -p node-subtensor --profile=production --features=metadata-hash\n```\n\n----------------------------------------\n\nTITLE: Configuring TAO Token Transfer Amount in JavaScript\nDESCRIPTION: This code snippet shows how to create a transfer transaction for sending 0.1 TAO. It sets up the transaction object with the destination address and the transfer amount, which is represented in wei.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/transfer-between-two-h160-accounts.md#2025-04-22_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\n// Create a transfer transaction to send 0.1 TAO\nconst tx = {\n    to: destinationEthereumAddress,\n    value: \"100000000000000000\",\n};\n```\n\n----------------------------------------\n\nTITLE: Penalizing Out-of-Consensus Bonds in Yuma Consensus\nDESCRIPTION: This LaTeX equation shows how bond weights are penalized if a validator's evaluation of a miner exceeds the consensus evaluation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\widetilde{W_{ij}} \n= (1-\\beta)\\,W_{ij} +\\beta\\,\\overline{W_{ij}}\n```\n\n----------------------------------------\n\nTITLE: Creating Balance Objects from Tao Units in Python (Alternative Method)\nDESCRIPTION: Additional static method that creates a Balance object from a float amount in tao units, similar to from_float. This provides a clear, explicitly named alternative to the from_float method.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/balance/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef from_tao(amount):\n  :staticmethod:\n\n\n  Given tao, return Balance object with rao(``int``) and tao(``float``), where rao = int(tao*pow(10,9))\n\n  :param amount: The amount in tao.\n  :type amount: float\n\n  :returns: A Balance object representing the given amount.\n```\n\n----------------------------------------\n\nTITLE: Defining Logging Constants in Python for Bittensor\nDESCRIPTION: This snippet defines several constants used for configuring logging in the Bittensor project. It includes log formats, logger name, date format, and default values for log file settings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/defines/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nBASE_LOG_FORMAT = '%(asctime)s | %(levelname)s | %(message)s'\n\nBITTENSOR_LOGGER_NAME = 'bittensor'\n\nDATE_FORMAT = '%Y-%m-%d %H:%M:%S'\n\nDEFAULT_LOG_BACKUP_COUNT = 10\n\nDEFAULT_LOG_FILE_NAME = 'bittensor.log'\n\nDEFAULT_MAX_ROTATING_LOG_FILE_SIZE = 26214400\n\nTRACE_LOG_FORMAT = '%(asctime)s | %(levelname)s | %(name)s:%(filename)s:%(lineno)s | %(message)s'\n```\n\n----------------------------------------\n\nTITLE: Querying Weights Rate Limit Parameter in Bittensor Network (Python)\nDESCRIPTION: An asynchronous method that returns the WeightsSetRateLimit hyperparameter for a specific subnet. This parameter governs how frequently neurons can update their weights in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_63\n\nLANGUAGE: python\nCODE:\n```\nasync def weights_rate_limit(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Setting Alpha Values Hyperparameters Syntax in Bittensor\nDESCRIPTION: The command syntax for setting alpha_low and alpha_high hyperparameters in a Bittensor subnet using the btcli command line interface. The command requires specifying the subnet ID (netuid) and the values for alpha_low and alpha_high as comma-separated integers.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set hyperparameters --netuid <your_preferred_netuid> --param alpha_values --value <value-of-alpha_low,value-of-alpha_high>\n```\n\n----------------------------------------\n\nTITLE: Starting Docusaurus Development Server\nDESCRIPTION: Launch a local development server to preview the documentation with live updates.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Using BTCLI with --verbose flag\nDESCRIPTION: New --verbose flag added to all btcli commands in BTCLI 8.3.1 for debugging purposes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Example of using --verbose flag with btcli\nbtcli some_command --verbose\n```\n\n----------------------------------------\n\nTITLE: Installing Dynamic TAO-enabled Bittensor SDK\nDESCRIPTION: Instructions for updating to the Dynamic TAO-enabled version of the Bittensor SDK using pip.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install bittensor\n```\n\n----------------------------------------\n\nTITLE: Specifying Python Package Dependencies for Bittensor Project\nDESCRIPTION: This snippet defines the required Python packages and their minimum versions for a project using Bittensor. It includes libraries for data processing, visualization, and machine learning.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/requirements.txt#2025-04-22_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nbittensor==8.2.0\nnumpy>=2.0.2\npandas>=2.2.3\nplotly>=5.24.1\ntorch>=2.5.0\nmatplotlib>=3.9.2\n```\n\n----------------------------------------\n\nTITLE: Viewing Subnet Details using BTCLI in Bash\nDESCRIPTION: Command to show detailed information about a specific subnet. This is a permissionless read operation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/staking-and-delegation/stakers-btcli-guide.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets show\n```\n\n----------------------------------------\n\nTITLE: Using Dendrite with Context Manager in Async Context\nDESCRIPTION: Example showing how to use the Dendrite class with a context manager in an asynchronous context. The context manager properly handles session creation and cleanup.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/dendrite/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync with dendrite(wallet = bittensor_wallet.Wallet()) as d:\n    print(d)\n    d( <axon> ) # ping axon\n    d( [<axons>] ) # ping multiple\n    d( Axon(), Synapse )\n```\n\n----------------------------------------\n\nTITLE: Wallet Command Group Syntax\nDESCRIPTION: Base syntax for the btcli wallet command group that contains wallet management functions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_30\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet [OPTIONS] COMMAND [ARGS]...\n```\n\n----------------------------------------\n\nTITLE: Using multiple options in BTCLI commands\nDESCRIPTION: Example of using multiple options in a BTCLI command, specifically for the faucet command. This demonstrates how to specify custom network and endpoint settings.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nbtcli w faucet --subtensor.chain_endpoint ws://127.0.0.1:9945 --subtensor.network local\n```\n\n----------------------------------------\n\nTITLE: Hashing Message for Ed25519 Verification in JavaScript\nDESCRIPTION: Code snippet demonstrating how to hash an arbitrary message to fit the 32-byte requirement for the Ed25519 verify precompile.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/ed25519-verify-precompile.md#2025-04-22_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst messageHash = ethers.keccak256(messageHex); // Hash the message to fit into bytes32\n```\n\n----------------------------------------\n\nTITLE: Running Ed25519 Verify Example Script in Node.js\nDESCRIPTION: Command to execute the ed25519-verify.js script using Node.js.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/ed25519-verify-precompile.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnode ed25519-verify.js\n```\n\n----------------------------------------\n\nTITLE: Displaying NotEnoughStakeToWithdraw Error in Bash\nDESCRIPTION: Shows the error message when there's insufficient TAO equivalent stake for removal/movement/transfer, including the unstake fee.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 5'\n}\n```\n\n----------------------------------------\n\nTITLE: Miner Structure in Project\nDESCRIPTION: Directory structure showing the location of the miner.py file that contains the implementation of the base OCR miner using pytesseract.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n...\n├── neurons\n│   ├── __init__.py\n│   ├── miner.py\n│   └── validator.py\n...\n```\n\n----------------------------------------\n\nTITLE: Command Output for Setting Alpha Values in Bittensor\nDESCRIPTION: The terminal output when executing the alpha_values setting command. It shows the wallet unlock process and confirmation of the hyperparameter change with the updated values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/consensus-based-weights.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n>> Enter wallet name (default):    # <my_coldkey>\n>> Enter password to unlock key:   # <password>\n>> ✅ Hyper parameter alpha_values changed to [6554.0, 55706.0]\n```\n\n----------------------------------------\n\nTITLE: Creating List of Tuple StakeInfo Objects from Byte Vector in Python\nDESCRIPTION: A class method that creates a list of StakeInfo objects in tuple format from a vector of bytes. This might be used for specific data processing needs within the Bittensor ecosystem.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/stake_info/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef list_of_tuple_from_vec_u8(vec_u8):\n    :classmethod:\n\n\n    Returns a list of StakeInfo objects from a ``vec_u8``.\n```\n\n----------------------------------------\n\nTITLE: Removing Old Build and Rebuilding HTML Documentation in Bash\nDESCRIPTION: Command to delete the old build directory and regenerate HTML documentation using make.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_sphinx-gen.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nrm -r build && make html\n```\n\n----------------------------------------\n\nTITLE: Displaying RateLimitExceeded Error in Bash\nDESCRIPTION: Illustrates the error message when too many transactions (excluding Axon serve/publish extrinsic) are submitted.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 6'\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Alpha Reserve Injection in Bittensor Network\nDESCRIPTION: This formula determines the alpha injection for a subnet to maintain the token price. It uses the TAO injection and the subnet's token price.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/emissions.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n$$\n\\Delta\\alpha_i = \\frac\n                  {\\Delta\\tau_i}\n                  {p_i}\n$$\n```\n\n----------------------------------------\n\nTITLE: Regenerating Coldkey with Enhanced btcli Command\nDESCRIPTION: Enhanced btcli command for regenerating coldkey, supporting various input formats for the seed phrase.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen_coldkey --mnemonic\n```\n\n----------------------------------------\n\nTITLE: Importing Dependencies and Setting Up Experiment Environment\nDESCRIPTION: Imports necessary libraries and initializes the experiment setup with the specified netuid and liquid_alpha enabled. This prepares the environment for running simulations and analyzing weight copying behavior.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport os \nimport pickle\n\nimport torch \nimport numpy as np\nimport pandas as pd\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.pyplot import figure\n\nimport bittensor as bt\n\nfrom experiment_setup import ExperimentSetup\n\nsetup = ExperimentSetup(\n    netuids = [netuid],\n    liquid_alpha = True, \n)\n```\n\n----------------------------------------\n\nTITLE: Using Dendrite Client in Bittensor Subnet Validator\nDESCRIPTION: This code demonstrates how a subnet validator uses a Dendrite client to transmit Synapse objects to a set of Axons (subnet miners). It waits for responses with a specified timeout.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/learn/bittensor-building-blocks.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nresponses: List[bt.Synapse] = await self.dendrite(\n    axons=axons,\n    synapse=synapse,\n    timeout=timeout,\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Trust Matrix T in LaTeX\nDESCRIPTION: This LaTeX equation defines a 4x4 trust matrix T with elements t_{i,j} where i and j range from 0 to 3. The matrix represents the trust relationships in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/concepts/_equations.md#2025-04-22_snippet_1\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nT  = \\begin{bmatrix} t_{0,0} & t_{0,1} & t_{0,2} & t_{0,3}  \\\\ t_{1,0} & t_{1,1} & t_{1,2} & t_{1,3}  \\\\ t_{2,0} & t_{2,1} & t_{2,2} & t_{2,3} \\\\ t_{3,0} & t_{3,1} & t_{3,2} & t_{3,3} \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Changing to Bittensor directory\nDESCRIPTION: Command to change the current directory to the cloned Bittensor repository.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ncd bittensor\n```\n\n----------------------------------------\n\nTITLE: Running Archive Node on Testchain with Docker\nDESCRIPTION: This command starts a Subtensor archive node connected to the Bittensor testchain using Docker. It uses the provided script with specific parameters for the network and node type.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n./scripts/run/subtensor.sh -e docker --network testnet --node-type archive\n```\n\n----------------------------------------\n\nTITLE: Setting Commit Reveal Hyperparameters\nDESCRIPTION: New subnet hyperparameters added to support the commit reveal feature, including the interval and enable flag.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ncommit_reveal_weights_interval = <integer>\ncommit_reveal_weights_enabled = True\n```\n\n----------------------------------------\n\nTITLE: Downloading Metagraphs for Analysis\nDESCRIPTION: Executes the DownloadMetagraph module to retrieve network metagraphs for the specified setup. These metagraphs contain the network topology and weight information necessary for the simulation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom download_metagraphs import DownloadMetagraph\nDownloadMetagraph(setup = setup).run()\n```\n\n----------------------------------------\n\nTITLE: Displaying ColdKeyInSwapSchedule Error in Bash\nDESCRIPTION: Demonstrates the error message for when a coldkey is set to be swapped, preventing transfer operations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 0'\n}\n```\n\n----------------------------------------\n\nTITLE: Example Calculation of Stake Yield and Slippage in Bittensor Subnet using LaTeX\nDESCRIPTION: This LaTeX formula demonstrates a practical example of calculating stake yield and slippage in a Bittensor subnet. It uses specific values for initial reserves and staking amount to show the impact of slippage on the expected yield.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/staking-unstaking-dtao.md#2025-04-22_snippet_1\n\nLANGUAGE: latex\nCODE:\n```\n\\text{Stake} = 100 - \\frac{ 10 * 100} {10 + 5}\n```\n\n----------------------------------------\n\nTITLE: Stake Addition Command Example\nDESCRIPTION: Example showing how to stake TAO tokens to a specific wallet and hotkey\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake add --amount 100 --wallet-name <my_wallet> --wallet-hotkey <my_hotkey>\n```\n\n----------------------------------------\n\nTITLE: Starting Service in Bittensor Network\nDESCRIPTION: Method to start serving on a specific IP, port, and protocol for a given network UID in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nserve(self, wallet: 'bittensor.wallet', ip: str, port: int, protocol: int, netuid: int, placeholder1: int = 0, placeholder2: int = 0, wait_for_inclusion: bool = False, wait_for_finalization = True, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Torch API Compatibility Decorator Function\nDESCRIPTION: A decorator function that converts numpy-based functions to be compatible with PyTorch inputs and outputs when torch usage is enabled.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef legacy_torch_api_compat(func):\n    \"\"\"Convert function operating on numpy Input&Output to legacy torch Input&Output API if `use_torch()` is True.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Analyzing Relative Dividend Rate for Commit Reveal Strategy in Python\nDESCRIPTION: Calculates and analyzes the relative dividend rate of weight copiers across different commit reveal intervals and subnets, using simulation results to measure the effectiveness of the strategy.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/commit_reveal_diagnostic.ipynb#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndiv_losts = {}\nyuma_results = {}\n\nfor netuid in setup.netuids:\n    div_losts[netuid] = {}\n    yuma_results[netuid] = {}\n    \n    for cr_interval in setup.cr_intervals:\n        file_name = f\"{setup.result_path}/yuma_result_netuid{netuid}_conceal{cr_interval}.pkl\"\n\n        if not os.path.isfile(file_name):\n            continue\n    \n        with open(file_name, 'rb') as handle:\n            _yuma_results = pickle.load(handle)\n\n        dividend = [\n            (s[\"validator_reward_normalized\"] / s[\"stake\"]).tolist()\n            for idx, s in _yuma_results.items()\n        ]\n\n        dividend_df = pd.DataFrame(\n            dividend,\n            columns=[f\"v{i}\" for i in range(len(dividend[0]) - 1 )] + [\"v_bad\"],\n            index = _yuma_results.keys()\n        )\n        \n        div_last = dividend_df.iloc[-1]\n        div_lost = div_last.iloc[-1] / div_last.iloc[:-1].median()\n\n        div_losts[netuid][cr_interval] = div_lost\n        yuma_results[netuid][cr_interval] = _yuma_results\n\ndiv_losts = pd.DataFrame(div_losts, dtype='float64')# index as commit reveal weight interval \ndiv_losts\n```\n\n----------------------------------------\n\nTITLE: Calculating Instant Bond in Yuma Consensus\nDESCRIPTION: This LaTeX equation computes the instant bond of a validator to a miner based on the validator's stake and bond-weight.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_5\n\nLANGUAGE: latex\nCODE:\n```\n\\Delta B_{ij} = \\frac{\\,S_i \\,\\cdot\\, \\widetilde{W_{ij}}\\,}{\n   \\sum_{k \\in \\mathbb{V}} S_k \\,\\cdot\\, \\widetilde{W_{kj}}}\n```\n\n----------------------------------------\n\nTITLE: Defining DTypes Class in Python\nDESCRIPTION: This class extends the built-in dict class to represent data types used in tensors. It includes a 'torch' attribute set to False.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/tensor/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass DTypes(*args, **kwargs):\n    Bases: :py:obj:`dict`\n\n    dict() -> new empty dictionary\n    dict(mapping) -> new dictionary initialized from a mapping object's\n        (key, value) pairs\n    dict(iterable) -> new dictionary initialized as if via:\n        d = {}\n        for k, v in iterable:\n            d[k] = v\n    dict(**kwargs) -> new dictionary initialized with the name=value pairs\n        in the keyword argument list.  For example:  dict(one=1, two=2)\n\n    Initialize self.  See help(type(self)) for accurate signature.\n\n\n    .. py:attribute:: torch\n       :type:  bool\n       :value: False\n```\n\n----------------------------------------\n\nTITLE: Calculating Maximum Logger Name Length in Bittensor\nDESCRIPTION: A function that determines the length of the longest logger name by iterating through all active logger names, useful for formatting log output.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/helpers/index.rst#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef get_max_logger_name_length():\n\n   Calculate and return the length of the longest logger name.\n\n   This function iterates through all active logger names and determines the length of the longest name.\n\n   :returns: The length of the longest logger name.\n   :rtype: max_length (int)\n```\n\n----------------------------------------\n\nTITLE: Defining ProposalVoteData Class in Python for Bittensor Core Chain\nDESCRIPTION: This class represents proposal vote data in the Bittensor blockchain. It includes attributes for tracking votes, proposal details, and a method for decoding SS58 address tuples. The class is initialized with a proposal dictionary and provides structure for handling proposal vote information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/proposal_vote_data/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass ProposalVoteData(proposal_dict):\n\n   ayes: list[str]\n\n   @staticmethod\n   def decode_ss58_tuples(line):\n      \"\"\"Decodes a tuple of ss58 addresses formatted as bytes tuples.\"\"\"\n\n   end: int\n\n   index: int\n\n   nays: list[str]\n\n   threshold: int\n```\n\n----------------------------------------\n\nTITLE: Cloning the Opentensor EVM-Bittensor Repository\nDESCRIPTION: This command clones the Opentensor EVM-Bittensor GitHub repository to the local machine. It's the first step in setting up the project environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/install.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/evm-bittensor.git\n```\n\n----------------------------------------\n\nTITLE: Understanding Genesis Mismatch Error in Bittensor\nDESCRIPTION: This error is generally harmless and occurs due to version mismatches between blockchain validator nodes. It can be ignored as long as the local node is syncing properly.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nReason: Genesis mismatch. Banned, disconnecting.\n```\n\n----------------------------------------\n\nTITLE: Setting Selected Parameters for Further Analysis\nDESCRIPTION: Sets the chosen parameter values (cr_interval, alpha_high, alpha_low) based on the previous analysis. These values will be used for more detailed examination of their effects on dividends.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncr_interval = 15\nalpha_high = 0.9\nalpha_low = 0.9\n```\n\n----------------------------------------\n\nTITLE: Installing Virtual Environment for Sphinx in Python\nDESCRIPTION: Commands to create and activate a virtual environment for Sphinx installation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_sphinx-gen.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython3 -m venv sphinx_venv\nsource sphinx_venv/bin/activate\n```\n\n----------------------------------------\n\nTITLE: Calculating Slippage in TAO Tokens (LaTeX)\nDESCRIPTION: This snippet calculates the slippage in terms of TAO tokens, showing the difference between expected and actual received tokens.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_4\n\nLANGUAGE: latex\nCODE:\n```\n\\begin{split}\n\\text{Slippage} & = \\text{Expected TAO tokens} - \\text{Actual TAO tokens obtained}\\\\\n& = 4.5-3.46 = 1.04\\text{ TAO}\n\\end{split}\n```\n\n----------------------------------------\n\nTITLE: Millifying Numbers in Python\nDESCRIPTION: Function signature for converting numbers into a more readable format using suffixes. Simplifies large numbers by applying appropriate magnitude suffixes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/formatting/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef millify(n)\n```\n\n----------------------------------------\n\nTITLE: Implementing cast_shape Function in Python\nDESCRIPTION: This function casts a raw value to a string representing the tensor shape. It handles various input types and raises exceptions for invalid inputs or non-integer list elements.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/tensor/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef cast_shape(raw):\n    Casts the raw value to a string representing the tensor shape.\n\n    :param raw: The raw value to cast.\n    :type raw: Union[None, list[int], str]\n\n    :returns: The string representing the tensor shape.\n    :rtype: str\n\n    :raises Exception: If the raw value is of an invalid type or if the list elements are not of type int.\n```\n\n----------------------------------------\n\nTITLE: Rendering Cards Component in JSX\nDESCRIPTION: This JSX code renders a Cards component containing multiple Card components. Each Card represents a different module of the Bittensor SDK, including an icon, title, link, and brief description of the module's functionality.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bt-api-ref.md#2025-04-22_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Cards>\n    <Card \n    icon={GiHiveMind}\n    title='Axon'\n    link='pathname:///python-api/autoapi/bittensor/core/axon/index.html'\n    body='Axon services the forward and backward requests from other neurons.' />\n    <Card\n    icon={GiOvermind}\n    title='Dendrite'\n    link='pathname:///python-api/autoapi/bittensor/core/dendrite/index.html'\n    body='Dendrite represents the abstracted implementation of a network client module.' />\n    <Card\n    icon={SiTrpc}\n    title='Extrinsics'\n    link='pathname:///python-api/autoapi/bittensor/core/extrinsics/index.html'\n    body='Set weights, Axon serving, transfer, submit extrinsic, and more.' />\n    <Card\n    icon={GiBrainTentacle}\n    title='Metagraph'\n    link='pathname:///python-api/autoapi/bittensor/core/metagraph/index.html'\n    body='Metagraph neural graph is a dynamic representation of the Bittensor network state.' />\n    <Card\n    icon={PiBrainFill}\n    title='Subtensor'\n    link='pathname:///python-api/autoapi/bittensor/core/subtensor/index.html'\n    body='Subtensor class provides a gateway to the blockchain layer of Bittensor.' />\n    <Card\n    icon={GiBrainStem}\n    title='Synapse'\n    link='pathname:///python-api/autoapi/bittensor/core/synapse/index.html'\n    body='Synapse module serves as a communication schema between neurons (nodes).' />\n</Cards>\n```\n\n----------------------------------------\n\nTITLE: Displaying InsufficientLiquidity Error in Bash\nDESCRIPTION: Shows the error message when the subnet's pool lacks sufficient liquidity for a transaction.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_8\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 7'\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Redis using Yarn\nDESCRIPTION: This command installs Redis globally using Yarn package manager.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add -g redis\n```\n\n----------------------------------------\n\nTITLE: Adding a Footnote Reference in reStructuredText\nDESCRIPTION: This snippet demonstrates how to add a footnote reference in reStructuredText. It includes a link to the sphinx-autoapi GitHub repository.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. [#f1] Created with `sphinx-autoapi <https://github.com/readthedocs/sphinx-autoapi>`_\n```\n\n----------------------------------------\n\nTITLE: Using Prefix and Suffix in Bittensor Log Messages\nDESCRIPTION: Shows how to add context to log messages using prefix and suffix parameters in the Bittensor logging module. This allows for more informative and structured log messages.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/bt-logging-levels.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor.utils.btlogging import logging\n\n# Log a message with a prefix\nlogging.info(\"Process started.\", prefix=\"START\")\n\n# Log a message with a suffix\nlogging.info(\"Process completed.\", suffix=\"END\")\n\n# Log a message with both\nlogging.info(\"Step 1 executed.\", prefix=\"STEP 1\", suffix=\"OK\")\n\n# Log messages without explicit args\nlogging.info(\"Step 1 is\", \"Starting prefix\", \"Ending suffix\")\n```\n\n----------------------------------------\n\nTITLE: Cloning Subtensor Repository with Git\nDESCRIPTION: This command clones the Subtensor repository from GitHub to the local machine. It's the first step in setting up a Subtensor node using Docker.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/opentensor/subtensor.git\n```\n\n----------------------------------------\n\nTITLE: Torch Usage Configuration Function\nDESCRIPTION: Function to force the use of PyTorch instead of numpy for certain operations in the system.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef use_torch():\n    \"\"\"Force the use of torch over numpy for certain operations.\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Incorrect Subtensor Connection Management in Python\nDESCRIPTION: This snippet demonstrates an incorrect way of using the Subtensor class, where the connection is not explicitly closed, potentially leading to resource leaks.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/sdk/managing-subtensor-connections.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport bittensor as bt\nsub = bt.subtensor(\"finney\")\n# calls to subtensor\n\n# no close\n# potential resource leak:\n# the connection is open until/unless garbage collected\n```\n\n----------------------------------------\n\nTITLE: Displaying SlippageTooHigh Error in Bash\nDESCRIPTION: Demonstrates the error message when the slippage exceeds the set limit, suggesting to reduce the transaction amount.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 8'\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deprecated Version Checking Function in Python\nDESCRIPTION: Defines a deprecated function for version checking, maintained for backwards compatibility. It calls the check_version() function internally.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/version/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef version_checking(timeout = 15):\n    \"\"\"Deprecated, kept for backwards compatibility. Use check_version() instead.\n\n    :param timeout: The timeout for calling :func:``check_version`` function. Default is ``15``.\n    :type timeout: int\n    \"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Calculating Miner Aggregate Ranking in Yuma Consensus\nDESCRIPTION: This LaTeX equation computes the aggregate ranking for a miner based on summed rankings of validators, weighted by validators' stake.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_2\n\nLANGUAGE: latex\nCODE:\n```\nR_j = \\sum_{i \\in \\mathbb{V}} S_i \\,\\cdot\\, \\overline{W_{ij}}\n```\n\n----------------------------------------\n\nTITLE: Retrieving CRV3 Weight Commit Information for a Subnet (Python)\nDESCRIPTION: This asynchronous method retrieves the current weight commitment information for a specific subnet using the CRV3 protocol. Returns a list of commit details with sender, serialized commitment data, and reveal round.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nget_current_weight_commit_info(netuid, block = None, block_hash = None, reuse_block = False)\n```\n\n----------------------------------------\n\nTITLE: Setting Root Weights for Subnet Validation in Python\nDESCRIPTION: Asynchronous function for setting weights and values on the Bittensor blockchain for a wallet. Takes a subtensor object, wallet, network UIDs, weights, version key, and transaction confirmation flags. Returns True if the operation was successful.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/asyncex/root/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def set_root_weights_extrinsic(subtensor, wallet, netuids, weights, version_key = 0, wait_for_inclusion = False, wait_for_finalization = False):\n   \"\"\"\n   Sets the given weights and values on chain for wallet hotkey account.\n\n   :param subtensor: The AsyncSubtensor object\n   :type subtensor: bittensor.core.async_subtensor.AsyncSubtensor\n   :param wallet: Bittensor wallet object.\n   :type wallet: bittensor_wallet.Wallet\n   :param netuids: The `netuid` of the subnet to set weights for.\n   :type netuids: Union[NDArray[np.int64], list[int]]\n   :param weights: Weights to set. These must be `float` s and must correspond\n                   to the passed `netuid` s.\n   :type weights: Union[NDArray[np.float32], list[float]]\n   :param version_key: The version key of the validator.\n   :type version_key: int\n   :param wait_for_inclusion: If set, waits for the extrinsic to enter a block before returning `True`, or returns\n                              `False` if the extrinsic fails to enter the block within the timeout.\n   :type wait_for_inclusion: bool\n   :param wait_for_finalization: If set, waits for the extrinsic to be finalized on the chain before returning `\n                                 True`, or returns `False` if the extrinsic fails to be finalized within the timeout.\n   :type wait_for_finalization: bool\n\n   :returns:\n\n             `True` if extrinsic was finalized or included in the block. If we did not wait for finalization/inclusion, the\n                 response is `True`.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Displaying Subtensor Error: Allocator Out of Space (Bash)\nDESCRIPTION: This snippet shows an error message that occurs when a Subtensor archive node stops syncing blocks due to memory allocation failure. This issue has been fixed in a recent update.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/chain-rel-notes.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nFailed to allocate memory: \"Allocator ran out of space\"\n```\n\n----------------------------------------\n\nTITLE: Defining Bond Matrix B in LaTeX\nDESCRIPTION: This LaTeX equation defines a 4x4 bond matrix B with elements b_{i,j} where i and j range from 0 to 3. The matrix represents the bonding relationships between nodes in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/concepts/_equations.md#2025-04-22_snippet_2\n\nLANGUAGE: LaTeX\nCODE:\n```\n$$\nB  = \\begin{bmatrix} b_{0,0} & b_{0,1} & b_{0,2} & b_{0,3}  \\\\ b_{1,0} & b_{1,1} & b_{1,2} & b_{1,3}  \\\\ b_{2,0} & b_{2,1} & b_{2,2} & b_{2,3} \\\\ b_{3,0} & b_{3,1} & b_{3,2} & b_{3,3} \\end{bmatrix}\n$$\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus to GitHub Pages with SSH\nDESCRIPTION: Deploy the built documentation to GitHub Pages using SSH authentication.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ USE_SSH=true yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Importing useBaseUrl Hook in JSX\nDESCRIPTION: This code imports the useBaseUrl hook from Docusaurus, which is used to generate correct URLs for assets in the documentation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/commit-reveal.md#2025-04-22_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\nimport useBaseUrl from '@docusaurus/useBaseUrl';\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Logging Format Constants\nDESCRIPTION: Default log format definitions that include timestamp, log level, file info and message content. Includes both standard and trace format specifications.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/btlogging/format/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nDEFAULT_LOG_FORMAT = '34%(asctime)s39 | 137%(levelname)s0 | %(name)s:%(filename)s:%(lineno)s | %(message)s'\nDEFAULT_TRACE_FORMAT = '34%(asctime)s39 | 137%(levelname)s0 | %(name)s:%(filename)s:%(lineno)s | %(message)s'\n```\n\n----------------------------------------\n\nTITLE: Defining Version Check Threshold in Python\nDESCRIPTION: Sets a constant for the version check threshold in seconds. This value determines how frequently version checks are performed.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/version/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nVERSION_CHECK_THRESHOLD = 86400\n```\n\n----------------------------------------\n\nTITLE: Changing Logging Levels in Bittensor\nDESCRIPTION: Demonstrates how to change logging levels using state methods provided by the Bittensor logging module. These methods allow switching between different logging verbosity levels.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/bt-logging-levels.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom bittensor import logging\n\n# Enable TRACE level logging\nlogging.set_trace()\n\n# Enable DEBUG level logging\nlogging.set_debug()\n\n# Enable INFO level logging\n# This is the default level of logging\nlogging.set_info()\nlogging.set_default()\n\n# Enable WARNING level logging\nlogging.set_warning()\n```\n\n----------------------------------------\n\nTITLE: Displaying Subtensor Error Message Format in Bash\nDESCRIPTION: Shows the standard format for Subtensor error messages, including the error code, message, and custom error data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: [Error Code]'\n}\n```\n\n----------------------------------------\n\nTITLE: Config Clear Example Commands\nDESCRIPTION: Examples showing how to clear specific config fields or the entire configuration\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nbtcli config clear --chain --network\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli config clear --all\n```\n\n----------------------------------------\n\nTITLE: Updating Exponential Moving Average Bond in Yuma Consensus\nDESCRIPTION: This LaTeX equation updates the exponential moving average bond using the instant bond and the previous EMA bond.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/yuma-consensus.md#2025-04-22_snippet_6\n\nLANGUAGE: latex\nCODE:\n```\nB_{ij}^{(t)} = \\alpha \\,\\Delta B_{ij} + (1-\\alpha)\\,B_{ij}^{(t-1)}\n```\n\n----------------------------------------\n\nTITLE: Synchronous Extrinsic Submission in Bittensor (Python)\nDESCRIPTION: Submits an extrinsic to the Bittensor blockchain synchronously. It allows specifying whether to wait for inclusion in a block and/or finalization. This function handles exceptions and logs errors if the submission fails.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/utils/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef submit_extrinsic(subtensor, extrinsic, wait_for_inclusion, wait_for_finalization):\n    # Function implementation not provided in the snippet\n```\n\n----------------------------------------\n\nTITLE: Defining ChainError Hierarchy\nDESCRIPTION: Hierarchy of chain-related error classes extending from SubstrateRequestException.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/errors/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass ChainError(SubstrateRequestException):\n    \"\"\"Base error for any chain related errors.\"\"\"\n    pass\n\nclass ChainConnectionError(ChainError):\n    \"\"\"Error for any chain connection related errors.\"\"\"\n    pass\n\nclass ChainQueryError(ChainError):\n    \"\"\"Error for any chain query related errors.\"\"\"\n    pass\n\nclass ChainTransactionError(ChainError):\n    \"\"\"Error for any chain transaction related errors.\"\"\"\n    pass\n```\n\n----------------------------------------\n\nTITLE: Deploying Docusaurus to GitHub Pages without SSH\nDESCRIPTION: Deploy the built documentation to GitHub Pages using username authentication.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\n$ GIT_USER=<Your GitHub username> yarn deploy\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx Table of Contents for API Reference in reStructuredText\nDESCRIPTION: This snippet sets up a table of contents (toctree) for the API reference documentation. It includes a link to the Bittensor API index and specifies the 'titlesonly' option.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :titlesonly:\n\n   /autoapi/bittensor/index\n```\n\n----------------------------------------\n\nTITLE: Importing React Icons in JavaScript/JSX\nDESCRIPTION: This code snippet imports various icon components from different React icon libraries. These icons are likely used to visually represent different sections or features of the Bittensor SDK documentation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bt-api-ref.md#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { HiAcademicCap } from \"react-icons/hi2\";\nimport { MdInstallDesktop } from \"react-icons/md\";\nimport { FaNetworkWired } from \"react-icons/fa\";\nimport { GiMining } from \"react-icons/gi\";\nimport { GrValidate } from \"react-icons/gr\";\nimport { GiHiveMind } from \"react-icons/gi\";\nimport { GiOvermind } from \"react-icons/gi\";\nimport { GiBrainTentacle } from \"react-icons/gi\";\nimport { PiBrainFill } from \"react-icons/pi\";\nimport { GiBrainStem } from \"react-icons/gi\";\nimport { CiWallet } from \"react-icons/ci\";\nimport { SiTrpc } from \"react-icons/si\";\n```\n\n----------------------------------------\n\nTITLE: Fixing OpenSSL on macOS without Python Virtual Environment\nDESCRIPTION: This command reinstalls openssl to resolve SSL certificate verification errors when not using a Python virtual environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew reinstall openssl\n```\n\n----------------------------------------\n\nTITLE: Addressing Balances.transfer Function Not Found Error\nDESCRIPTION: This error is typically caused by using an outdated version of Bittensor. The solution is to update Bittensor to the latest version.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nValueError: Call function 'Balances.transfer' not found\n```\n\n----------------------------------------\n\nTITLE: Fixing Decoded Values in Python\nDESCRIPTION: Classmethod that performs post-processing to fix or normalize decoded values after initial decoding.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/scheduled_coldkey_swap_info/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@classmethod\ndef fix_decoded_values(decoded)\n```\n\n----------------------------------------\n\nTITLE: Removing Source Files from HTML Build in Bash\nDESCRIPTION: Command to remove the _sources directory containing reStructuredText source files from the HTML build.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_sphinx-gen.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nrm -r build/html/_sources\n```\n\n----------------------------------------\n\nTITLE: Project Structure for OCR Subnet\nDESCRIPTION: Directory structure of the OCR subnet project, highlighting the location of key files including the protocol.py which contains the OCRSynapse definition.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/tutorials/ocr-subnet-tutorial.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n...\n├── ocr_subnet\n│   ├── __init__.py\n│   ├── base\n│   │   ├── __init__.py\n│   │   ...\n│   ├── protocol.py\n...\n```\n\n----------------------------------------\n\nTITLE: Getting All Child Hotkeys with btcli stake child get\nDESCRIPTION: This command retrieves all child hotkeys and their proportions for all subnets. It's used to view the authority delegated to different hotkeys across all subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child get --all-netuids\n```\n\n----------------------------------------\n\nTITLE: Configuring Table of Contents in reStructuredText for Bittensor SDK Documentation\nDESCRIPTION: This snippet sets up the table of contents for the Bittensor SDK documentation using reStructuredText directives. It specifies a maximum depth of 2 and includes a caption.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/index.rst#2025-04-22_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. toctree::\n   :maxdepth: 2\n   :caption: Table of Contents\n```\n\n----------------------------------------\n\nTITLE: Configuring Bittensor App Component in JavaScript\nDESCRIPTION: This JavaScript code configures a Bittensor App component, setting up the data provider and defining resources for blog posts with various routes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_components.md#2025-04-22_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst App = () => (\n  <Bittensor\n    dataProvider={dataProvider}\n    resources={\n\t[{\n      \t\tname: \"blog_posts\",\n      \t\tlist: \"/blog-posts\",\n      \t\tshow: \"/blog-posts/show/:id\",\n      \t\tcreate: \"/blog-posts/create\",\n      \t\tedit: \"/blog-posts/edit/:id\",},\n\t]}\n  >\n    /* ... */\n  </Bittensor>\n);\n```\n\n----------------------------------------\n\nTITLE: Subnetwork Parameter Query Method Python Definition\nDESCRIPTION: Method to retrieve the SubnetworkN hyperparameter for a specified subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_66\n\nLANGUAGE: python\nCODE:\n```\ndef subnetwork_n(netuid, block = None)\n```\n\n----------------------------------------\n\nTITLE: Running Weight Copy Simulation for Bittensor Commit Reveal Strategy\nDESCRIPTION: Initiates the weight copy simulation to evaluate the effectiveness of the commit reveal strategy using the configured experiment parameters.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/commit_reveal_diagnostic.ipynb#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom weight_copy_simulation import WeightCopySimulation\nWeightCopySimulation(setup = setup).run_simulation()\n```\n\n----------------------------------------\n\nTITLE: Switching to Main Branch in Git\nDESCRIPTION: This command switches the Git repository to the main branch, ensuring you're working with the latest stable version of Subtensor.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/using-docker.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngit checkout main\n```\n\n----------------------------------------\n\nTITLE: Delegate Take Setting Command Syntax\nDESCRIPTION: Syntax for the sudo set-take command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_27\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo set-take [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Subnet Information Display\nDESCRIPTION: Commands to display detailed subnet information including participant status and subnet details.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_20\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnets list\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli subnet show [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Displaying TransferDisallowed Error in Bash\nDESCRIPTION: Shows the error message when stake transfer is not allowed in a particular subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 9'\n}\n```\n\n----------------------------------------\n\nTITLE: Calculating Alpha Token Price After Staking (LaTeX)\nDESCRIPTION: This snippet calculates the new relative price of alpha tokens after a staking event, demonstrating the effect of slippage on the token price.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao_cruft.md#2025-04-22_snippet_0\n\nLANGUAGE: latex\nCODE:\n```\n= \\frac{\\text{TAO reserves}}{\\text{α reserves}} = \\frac{15}{66.667} = \\text{0.225 TAO per α}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Relative Dividend Rates Across Different Parameters\nDESCRIPTION: Creates a visualization showing how the relative dividend rate (G) changes with different alpha_low values, grouped by commit-reveal intervals and alpha_high values. This helps subnet owners identify optimal parameter combinations.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/liquid_alpha_diagnostic.ipynb#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nplt.rcParams.update({'font.size': 16})\n\ncols = 5\nfig, axes = plt.subplots(1, cols, sharey=True, figsize=(40, 10), layout='constrained')\n\nfor idx, alpha_high in enumerate(setup.alpha_highs):\n    df = div_rates[div_rates.alpha_high == alpha_high]\n    \n    ax = axes[idx%cols]\n    ax.set_title(f\"alpha_high {round(alpha_high, 2)}\")\n    for cr_interval in df['cr_interval'].unique():\n        _df = df[df.cr_interval == cr_interval]\n        ax.plot(\n            _df['alpha_low'],\n            _df['G'],\n            label = f\"cr_interval {cr_interval}\",\n        )\n    ax.legend(loc=\"upper right\")\n\nfig.supylabel('Relative dividend rate (G)')\nfig.supxlabel('alpha_low')\nfig.suptitle(\"Change in Relative dividend rate (G) under different conditions\")\n```\n\n----------------------------------------\n\nTITLE: Displaying HotkeyAccountDoesntExist Error in Bash\nDESCRIPTION: Demonstrates the error message when a hotkey is not registered on the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-error-messages.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n{'code': 1010, 'message': 'Invalid Transaction', 'data': 'Custom error: 4'\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Project Dependencies with npm\nDESCRIPTION: This command uses npm (Node Package Manager) to install all the dependencies specified in the project's package.json file. This step is crucial for setting up the project environment.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/install.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\n----------------------------------------\n\nTITLE: Using Commit Reveal Feature with btcli Commands\nDESCRIPTION: New btcli command options for using the commit reveal feature, which addresses weight copying issues.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wt commit\nbtcli wt reveal\n```\n\n----------------------------------------\n\nTITLE: Themed Image Component Implementation\nDESCRIPTION: React JSX code for rendering a themed image component with light/dark mode support.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/dtao-faq.md#2025-04-22_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<ThemedImage\nalt=\"Curves\"\nsources={{\n    light: useBaseUrl('/img/docs/dynamic-tao/curves.png'),\n    dark: useBaseUrl('/img/docs/dynamic-tao/curves.png'),\n  }}\nstyle={{width: 650}}\n/>\n```\n\n----------------------------------------\n\nTITLE: Querying Subtensor Map Storage in Python\nDESCRIPTION: Async method specifically for querying map storage from the Subtensor module. Used for retrieving neuron details and network-wide attributes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/async_subtensor/index.rst#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nasync def query_map_subtensor(name, block = None, block_hash = None, reuse_block = False, params = None)\n```\n\n----------------------------------------\n\nTITLE: Console Output for Staking Script (Console)\nDESCRIPTION: This console output shows the results of running the staking script, including slippage calculations, subnet prices, and current stake amounts for each subnet.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/sdk-cheat-sheet.md#2025-04-22_snippet_20\n\nLANGUAGE: console\nCODE:\n```\nEnter your password:\nDecrypting...\n\nslippage for subnet 119\n5.484198655671355\nnetuid 119 price τ0.027592398 stake Ⲃ1.449590749\nslippage for subnet 277\n22.54931028877199\nnetuid 277 price τ0.014734147 stake इ2.714201361\nslippage for subnet 18\n48.319842544421064\nnetuid 18 price τ0.001067641 stake σ28.105321031\nslippage for subnet 5\n36.69607695087895\nnetuid 5 price τ0.001784484 stake ε11.208213619\n\n...\n```\n\n----------------------------------------\n\nTITLE: Installing Bittensor SDK from source\nDESCRIPTION: Pip command to install Bittensor SDK from the local source directory, which also installs btcli.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/getting-started/installation.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install .\n```\n\n----------------------------------------\n\nTITLE: Subnet 16 Configuration in Markdown\nDESCRIPTION: Documentation outlining the basic configuration and identification details for the Audio Generation Subnetwork, including network ID, ownership, and repository links.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/_subnet-pages/subnet-16.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# Subnet 16\n\n## Name\n\nAudio Generation Subnetwork\n\n## Netuid\n16\n\n## Description\n\nThis subnetwork is a decentralized system designed for text-to-audio applications within the Bittensor network.\n\n## Subnet owner\n\nhttps://github.com/UncleTensor/AudioSubnet/\n\n## GitHub\n\nhttps://github.com/UncleTensor/AudioSubnet/\n```\n\n----------------------------------------\n\nTITLE: Batch Unstaking TAO from Multiple Hotkeys in Bittensor Network (Python)\nDESCRIPTION: Method for performing batch unstaking operations from multiple hotkey accounts simultaneously. Takes parameters for wallet, list of hotkey addresses, optional amounts to unstake, and transaction processing options. Returns a boolean indicating success.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_71\n\nLANGUAGE: python\nCODE:\n```\ndef unstake_multiple(wallet, hotkey_ss58s, amounts = None, wait_for_inclusion = True, wait_for_finalization = False)\n```\n\n----------------------------------------\n\nTITLE: Setting Up Experiment Parameters for Commit Reveal Analysis in Python\nDESCRIPTION: Configures experiment parameters including block range, data points, and commit reveal intervals for analyzing the effectiveness of the commit reveal strategy across different Bittensor subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/commit_reveal_diagnostic.ipynb#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport os \nimport pandas as pd\nimport pickle\nfrom experiment_setup import ExperimentSetup\nimport plotly.express as px\n\nend_block = 4766968 # set it to the more recent subtensor block\ndata_points = 200\ntempo = 360\n\nsetup = ExperimentSetup(\n    netuids = [1],\n    start_block = end_block - data_points * tempo,\n    data_points = data_points,\n    processes = 30,\n    cr_intervals = list(range(0, 25, 4)), \n    log = True\n)\n\nprint(setup)\n```\n\n----------------------------------------\n\nTITLE: Checking Wallet Balance - Test2\nDESCRIPTION: Shows how to check the balance of the playground-test2 wallet on the test network after regenerating the coldkey.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli/btcli-playground.md#2025-04-22_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nbtcli wallet regen-coldkey \\\n--mnemonic \"nominee sort fringe gauge tank sure core memory abandon lamp alter flash\" \\\n--wallet.name 'playground-test2' \\\n--no-use-password --wallet.path ~/.bittensor/wallets\n\nbtcli wallet balance \\\n--wallet.name 'playground-test2' \\\n--wallet.path ~/.bittensor/wallets \\\n--network test\n```\n\n----------------------------------------\n\nTITLE: Plotting Relative Dividend Rate vs Commit Reveal Interval in Python\nDESCRIPTION: Creates a line plot using Plotly to visualize the relationship between the relative dividend rate of weight copiers and the commit reveal weight interval across different Bittensor subnets.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/weight_copy/commit_reveal_diagnostic.ipynb#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfig = px.line(\n    div_losts,\n    labels={\n        \"value\": \"Relative dividend rate (G)\".title(),\n        \"index\": \"Commit reveal weight interval (every 360 blocks)\",\n        \"variable\": 'Subnet'\n    },\n    title=\"Relative Dividend Rate Of Weight Copier\",\n    width = 1000 * 1.5,\n    height = 500 * 1.5,\n)\nfig.add_hline(y=1, line_width=3, line_dash=\"dash\", line_color=\"red\", annotation_text = \"\")\nfig.update_layout(template='plotly_white')\n```\n\n----------------------------------------\n\nTITLE: Building Static HTML for Docusaurus\nDESCRIPTION: Generate static HTML content for the documentation in the build directory.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn build\n```\n\n----------------------------------------\n\nTITLE: Resolving SSL Certificate Verification Error on macOS\nDESCRIPTION: This error is caused by an incompatible certifi version in openssl. Two remedies are provided: running the 'Install Certificates.command' or reinstalling openssl/urllib3.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/errors-and-troubleshooting.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nSSLCertVerificationError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer\ncertificate (_ssl.c:1000)\n```\n\n----------------------------------------\n\nTITLE: Senate Vote Command Usage Syntax\nDESCRIPTION: Syntax for the senate-vote command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_23\n\nLANGUAGE: bash\nCODE:\n```\nbtcli sudo senate-vote [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Python Docstring Example - Google Style\nDESCRIPTION: Demonstrates the recommended Google-style format for Python docstrings using the Napoleon extension with Sphinx. Shows proper formatting for arguments, parameter types, and return values.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/WRITING-STYLE-GUIDE.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nArgs:\n\n    path (str): The path of the file to wrap\n    field_storage (FileStorage): The :class:`FileStorage` instance to wrap\n    temporary (bool): Whether or not to delete the file when the File instance is destructed\n\nReturns:\n\n    BufferedFileStorage: A buffered writable file descriptor\n```\n\n----------------------------------------\n\nTITLE: Creating StorageKey from Raw Data in Python\nDESCRIPTION: This class method creates a StorageKey instance from raw storage key bytes. It requires runtime configuration, metadata, and optionally value scale type, pallet, and storage function information.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/storage/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n@classmethod\ndef create_from_data(data, runtime_config, metadata, value_scale_type = None, pallet = None, storage_function = None):\n    \"\"\"\n    Create a StorageKey instance providing raw storage key bytes\n\n    :param data: bytes representation of the storage key\n    :param runtime_config: RuntimeConfigurationObject\n    :param metadata: GenericMetadataVersioned\n    :param value_scale_type: type string of to decode result data\n    :param pallet: name of pallet\n    :param storage_function: name of storage function\n\n    :returns: StorageKey\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Mock Subtensor Methods for Blockchain Operations\nDESCRIPTION: Methods in the MockSubtensor class that simulate blockchain operations such as getting balances, neuron information, and block details without requiring an actual blockchain connection.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/mock/subtensor_mock/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef get_balance(address, block = None):\n\n      Retrieves the balance for given coldkey.\n\n      :param address: coldkey address.\n      :type address: str\n      :param block: The blockchain block number for the query.\n      :type block: Optional[int]\n\n      :returns: Balance object.\n```\n\nLANGUAGE: python\nCODE:\n```\ndef get_current_block():\n\n      Returns the current block number on the Bittensor blockchain. This function provides the latest block number,\n          indicating the most recent state of the blockchain.\n\n      :returns: The current chain block number.\n      :rtype: int\n\n      Knowing the current block number is essential for querying real-time data and performing time-sensitive\n          operations on the blockchain. It serves as a reference point for network activities and data\n          synchronization.\n```\n\nLANGUAGE: python\nCODE:\n```\ndef get_block_hash(block = None):\n\n      Retrieves the hash of a specific block on the Bittensor blockchain. The block hash is a unique identifier\n          representing the cryptographic hash of the block's content, ensuring its integrity and immutability.\n\n      :param block: The block number for which the hash is to be retrieved.\n      :type block: int\n\n      :returns: The cryptographic hash of the specified block.\n      :rtype: str\n\n      The block hash is a fundamental aspect of blockchain technology, providing a secure reference to each block's\n          data. It is crucial for verifying transactions, ensuring data consistency, and maintaining the\n          trustworthiness of the blockchain.\n```\n\n----------------------------------------\n\nTITLE: Python Docstring Example - Deprecated Style\nDESCRIPTION: Shows the discouraged Sphinx-style format for Python docstrings that should be avoided in favor of the Google style.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/WRITING-STYLE-GUIDE.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n:param path: The path of the file to wrap\n:type path: str\n:param field_storage: The :class:`FileStorage` instance to wrap\n:type field_storage: FileStorage\n:param temporary: Whether or not to delete the file when the File instance is destructed\n:type temporary: bool\n:returns: A buffered writable file descriptor\n:rtype: BufferedFileStorage\n```\n\n----------------------------------------\n\nTITLE: Formatting Error Messages for Subtensor Extrinsics\nDESCRIPTION: Function for formatting error messages from Subtensor error information for use in extrinsics. It processes either a dictionary containing error information or a SubstrateRequestException containing dictionary literal arguments.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef format_error_message(error_message):\n   \"\"\"Formats an error message from the Subtensor error information for use in extrinsics.\n\n   :param error_message: A dictionary containing the error information from Subtensor, or a SubstrateRequestException\n                         containing dictionary literal args.\n\n   :returns: A formatted error message string.\n   :rtype: str\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Regenerating Coldkey Public Key with btcli\nDESCRIPTION: This command initializes a wallet for a permissionless workstation with a public key only. It allows reading wallet information without the ability to sign transactions.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/btcli-permissions.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet regen-coldkeypub\n```\n\n----------------------------------------\n\nTITLE: Initializing Bootstrap v5.3.3 JavaScript Library\nDESCRIPTION: This code snippet represents the header comment for the Bootstrap v5.3.3 JavaScript library. It includes version information, copyright notice, and license details.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/btwallet-api/html/_static/scripts/bootstrap.js.LICENSE.txt#2025-04-22_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n/*!\n  * Bootstrap v5.3.3 (https://getbootstrap.com/)\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n```\n\n----------------------------------------\n\nTITLE: Using the Test Token Faucet with GPU Acceleration\nDESCRIPTION: Command for obtaining test TAO tokens through proof of work, using CUDA GPU acceleration with multiple processors.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_38\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet faucet --faucet.num_processes 4 --faucet.cuda.use_cuda\n```\n\n----------------------------------------\n\nTITLE: Configuring Hardhat Networks for Subtensor EVM in JavaScript\nDESCRIPTION: This code snippet demonstrates how to configure Hardhat networks for Subtensor EVM. It sets up three networks: local, testnet (subevm), and mainnet. The configuration includes network URLs, account settings, and specifies Solidity version 0.8.24 for compatibility with EVM version Cancun.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/evm-tutorials/hardhat-config-for-subtensor-evm.md#2025-04-22_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nconst hardhatConfig: HardhatUserConfig = {\n  solidity: \"0.8.24\",\n  defaultNetwork: \"subevm\",\n  networks: {\n    subevm: {\n      url: \"https://test.chain.opentensor.ai\",\n      accounts: [config.ethPrivateKey]\n    },\n    mainnet: {\n      url: \"https://lite.chain.opentensor.ai\",\n      accounts: [config.ethPrivateKey]\n    },\n    local: {\n      url: \"http://127.0.0.1:9944\",\n      accounts: [config.ethPrivateKey]\n    }\n  },\n  mocha: {\n    timeout: 300000\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using hex_to_bytes function in Bittensor SDK\nDESCRIPTION: New reusable hex_to_bytes function added in Bittensor SDK 8.3.1 for converting hex results to bytes.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/bittensor-rel-notes.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Example of using hex_to_bytes function\nfrom bittensor import Subtensor\n\nsubtensor = Subtensor()\nresult_hex = subtensor.get_all_subnets_info()\nresult_bytes = hex_to_bytes(result_hex)\n# Use result_bytes with bt-decode\n```\n\n----------------------------------------\n\nTITLE: Importing ThemedImage Component in JSX\nDESCRIPTION: This code imports the ThemedImage component from the Docusaurus theme, which is used to display themed images in the documentation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subnets/commit-reveal.md#2025-04-22_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\nimport ThemedImage from '@theme/ThemedImage';\n```\n\n----------------------------------------\n\nTITLE: Stopping Axon Server in Python\nDESCRIPTION: Method to stop the Axon server. It is recommended to ensure all ongoing processes are completed before stopping.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/axon/index.rst#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmy_axon.stop()\n```\n\n----------------------------------------\n\nTITLE: Serving Axon in Bittensor Network\nDESCRIPTION: Method to start serving an Axon for a given network UID in the Bittensor network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/reference/_bittensor-api-ref.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nserve_axon(self, netuid: int, axon: 'bittensor.Axon', use_upnpc: bool = False, wait_for_inclusion: bool = False, wait_for_finalization: bool = True, prompt: bool = False) -> bool\n```\n\n----------------------------------------\n\nTITLE: Converting AxonInfo to JSON string\nDESCRIPTION: A method that converts the AxonInfo object to a JSON string representation.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/chain_data/axon_info/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef to_string():\n    \"\"\"Converts the `AxonInfo` object to a string representation using JSON.\"\"\"\n\n```\n\n----------------------------------------\n\nTITLE: Wallet Creation Command Syntax\nDESCRIPTION: Syntax for the wallet create command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_37\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet create [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Child Stake Management Example\nDESCRIPTION: Examples showing how to manage child hotkey stakes in subnets\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child get --all-netuids\n```\n\nLANGUAGE: bash\nCODE:\n```\nbtcli stake child revoke --hotkey <parent_hotkey> --netuid 1\n```\n\n----------------------------------------\n\nTITLE: Wallet Faucet Command Syntax\nDESCRIPTION: Syntax for the wallet faucet command showing the base command structure with options placeholder.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/dynamic-tao/_dtao-btcli.md#2025-04-22_snippet_39\n\nLANGUAGE: bash\nCODE:\n```\nbtcli wallet faucet [OPTIONS]\n```\n\n----------------------------------------\n\nTITLE: Installing Docusaurus Dependencies\nDESCRIPTION: Use Yarn to install Docusaurus and its dependencies for the project.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/README.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn\n```\n\n----------------------------------------\n\nTITLE: Implementing Task Submission for PriorityThreadPoolExecutor\nDESCRIPTION: A method that submits a callable function to be executed with the given arguments and returns a Future instance representing the execution, allowing for asynchronous task handling.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/threadpool/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef submit(fn, *args, **kwargs):\n   \"\"\"\n   Submits a callable to be executed with the given arguments.\n\n   Schedules the callable to be executed as fn(*args, **kwargs) and returns\n   a Future instance representing the execution of the callable.\n\n   :returns: A Future representing the given call.\n   \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Registration Statistics Logger for Bittensor\nDESCRIPTION: A utility class that handles logging and displaying statistics during the registration process. It provides methods for formatting and updating status messages based on current progress.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/registration/pow/index.rst#2025-04-22_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass RegistrationStatisticsLogger(console = None, output_in_place = True):\n   \"\"\"Logs statistics for a registration.\"\"\"\n\n   console = None\n   status: Optional[rich.status.Status]\n\n   @classmethod\n   def get_status_message(stats, verbose = False):\n      \"\"\"Generates the status message based on registration statistics.\"\"\"\n\n   def start(self):\n      pass\n\n   def stop(self):\n      pass\n\n   def update(self, stats, verbose = False):\n      pass\n```\n\n----------------------------------------\n\nTITLE: Identity Function for Substrate Storage Operations\nDESCRIPTION: Function that returns the input data unchanged, used in Substrate storage operations where no hashing is required.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/utils/substrate_utils/hasher/index.rst#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef identity(data)\n```\n\n----------------------------------------\n\nTITLE: Querying Subnet Identities V2 in Python\nDESCRIPTION: Shows how to query identity information for a subnet in v2 format. Takes a netuid parameter and returns SubnetIdentityOfV2 data.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/docs/subtensor-nodes/subtensor-storage-query-examples.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom substrateinterface import SubstrateInterface\nsubstrate = SubstrateInterface(url=\"wss://test.finney.opentensor.ai:443\")\n\nnetuid = 1\nresult = substrate.query('SubtensorModule', 'SubnetIdentitiesV2', [netuid])\nprint(result.value)\n```\n\n----------------------------------------\n\nTITLE: Fetching Metadata from Bittensor Blockchain\nDESCRIPTION: Retrieves metadata from the blockchain for a specified hotkey and network UID. This function allows querying the stored metadata information associated with a particular neuron on the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/extrinsics/serving/index.rst#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nget_metadata(subtensor, netuid, hotkey, block = None)\n```\n\n----------------------------------------\n\nTITLE: Retrieving Neuron Commitment in Bittensor\nDESCRIPTION: Fetches the on-chain commitment data for a specific neuron identified by subnet ID and neuron UID, which represents the neuron's pledged state or configuration in the network.\nSOURCE: https://github.com/opentensor/developer-docs/blob/main/static/python-api/_sources/autoapi/bittensor/core/subtensor/index.rst#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef get_commitment(netuid, uid, block = None):\n      Retrieves the on-chain commitment for a specific neuron in the Bittensor network.\n\n      :param netuid: The unique identifier of the subnetwork.\n      :type netuid: int\n      :param uid: The unique identifier of the neuron.\n      :type uid: int\n      :param block: The block number to retrieve the commitment from. If None, the latest block is used.\n                    Default is ``None``.\n      :type block: Optional[int]\n\n      :returns: The commitment data as a string.\n      :rtype: str\n```"
  }
]