[
  {
    "owner": "simoncropp",
    "repo": "polyfill",
    "content": "TITLE: String Extension Methods in C#\nDESCRIPTION: Extension methods for the string class that add modern functionality like improved Contains methods with StringComparison options, character-based StartsWith/EndsWith, and span-based operations for better performance.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_48\n\nLANGUAGE: C#\nCODE:\n```\nbool Contains(string, char, StringComparison)\nbool Contains(string, string, StringComparison)\nbool Contains(string, char)\nvoid CopyTo(string, Span<char>)\nbool EndsWith(string, char)\nint GetHashCode(string, StringComparison)\nint IndexOf(string, char, StringComparison)\nstring ReplaceLineEndings(string, string)\nstring ReplaceLineEndings(string)\nstring[] Split(string, char, StringSplitOptions)\nstring[] Split(string, char, int, StringSplitOptions)\nbool StartsWith(string, char)\nbool TryCopyTo(string, Span<char>)\n```\n\n----------------------------------------\n\nTITLE: Defining Guard Class Methods for Input Validation in C#\nDESCRIPTION: This code snippet lists the method signatures for the Guard class, which provides various input validation and null checking operations. Methods include checks for file and directory existence, emptiness, null values, and whitespace across different data types and collections.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_guard.include.md#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\nvoid DirectoryExists(String)\nvoid FileExists(String)\nvoid NotEmpty(String)\nvoid NotEmpty<T>(ReadOnlySpan<T>)\nvoid NotEmpty<T>(Span<T>)\nvoid NotEmpty<T>(Nullable<Memory<T>>)\nvoid NotEmpty<T>(Memory<T>)\nvoid NotEmpty<T>(Nullable<ReadOnlyMemory<T>>)\nvoid NotEmpty<T>(ReadOnlyMemory<T>)\nvoid NotEmpty<T>(T) where T : Collections.IEnumerable\nT NotNull<T>(T)\nString NotNull(String)\nString NotNullOrEmpty(String)\nT NotNullOrEmpty<T>(T) where T : Collections.IEnumerable\nMemory<Char> NotNullOrEmpty(Nullable<Memory<Char>>)\nReadOnlyMemory<Char> NotNullOrEmpty(Nullable<ReadOnlyMemory<Char>>)\nString NotNullOrWhiteSpace(String)\nMemory<Char> NotNullOrWhiteSpace(Nullable<Memory<Char>>)\nReadOnlyMemory<Char> NotNullOrWhiteSpace(Nullable<ReadOnlyMemory<Char>>)\nvoid NotWhiteSpace(String)\nvoid NotWhiteSpace(ReadOnlySpan<Char>)\nvoid NotWhiteSpace(Nullable<Memory<Char>>)\nvoid NotWhiteSpace(Nullable<ReadOnlyMemory<Char>>)\nvoid NotWhiteSpace(Span<Char>)\n```\n\n----------------------------------------\n\nTITLE: Stream Async Extension Methods in C#\nDESCRIPTION: Asynchronous extension methods for the Stream class using the newer ValueTask pattern and Memory<T> for more efficient I/O operations. These methods provide modern alternatives to the older Task-based async methods.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_47\n\nLANGUAGE: C#\nCODE:\n```\nTask CopyToAsync(Stream, Stream, CancellationToken)\nValueTask DisposeAsync(Stream)\nValueTask<int> ReadAsync(Stream, Memory<byte>, CancellationToken)\nValueTask WriteAsync(Stream, ReadOnlyMemory<byte>, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: LINQ Extension Methods for IEnumerable<TSource>\nDESCRIPTION: A comprehensive listing of LINQ extension methods available for the IEnumerable<TSource> interface. Each method is presented with its signature and includes a link to the official Microsoft documentation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(IEnumerable<TSource>, Func<TSource, TKey>, TAccumulate, Func<TAccumulate, TSource, TAccumulate>, IEqualityComparer<TKey>?) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<KeyValuePair<TKey, TAccumulate>> AggregateBy<TSource, TKey, TAccumulate>(IEnumerable<TSource>, Func<TSource, TKey>, Func<TKey, TAccumulate>, Func<TAccumulate, TSource, TAccumulate>, IEqualityComparer<TKey>?) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> Append<TSource>(IEnumerable<TSource>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource[]> Chunk<TSource>(IEnumerable<TSource>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<KeyValuePair<TKey, int>> CountBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEqualityComparer<TKey>?) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> DistinctBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IEqualityComparer<TKey>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource ElementAt<TSource>(IEnumerable<TSource>, Index)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? ElementAtOrDefault<TSource>(IEnumerable<TSource>, Index)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> Except<TSource>(IEnumerable<TSource>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> Except<TSource>(IEnumerable<TSource>, TSource, IEqualityComparer<TSource>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> Except<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>, TSource[])\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> ExceptBy<TSource, TKey>(IEnumerable<TSource>, IEnumerable<TKey>, Func<TSource, TKey>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> ExceptBy<TSource, TKey>(IEnumerable<TSource>, IEnumerable<TKey>, Func<TSource, TKey>, IEqualityComparer<TKey>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource FirstOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource FirstOrDefault<TSource>(IEnumerable<TSource>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<(int Index, TSource Item)> Index<TSource>(IEnumerable<TSource>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource LastOrDefault<TSource>(IEnumerable<TSource>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource LastOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? Max<TSource>(IEnumerable<TSource>, IComparer<TSource>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? MaxBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? MaxBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IComparer<TKey>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? Min<TSource>(IEnumerable<TSource>, IComparer<TSource>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? MinBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource? MinBy<TSource, TKey>(IEnumerable<TSource>, Func<TSource, TKey>, IComparer<TKey>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource SingleOrDefault<TSource>(IEnumerable<TSource>, Func<TSource, bool>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTSource SingleOrDefault<TSource>(IEnumerable<TSource>, TSource)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> SkipLast<TSource>(IEnumerable<TSource>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> Take<TSource>(IEnumerable<TSource>, Range)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<TSource> TakeLast<TSource>(IEnumerable<TSource>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nHashSet<TSource> ToHashSet<TSource>(IEnumerable<TSource>, IEqualityComparer<TSource>?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryGetNonEnumeratedCount<TSource>(IEnumerable<TSource>, int)\n```\n\n----------------------------------------\n\nTITLE: Implementing CallerArgumentExpression Attribute in C#\nDESCRIPTION: This snippet demonstrates the usage of the CallerArgumentExpression attribute in C#. It shows how to create a utility method that captures the argument expression for improved error reporting and debugging.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nstatic class FileUtil\n{\n    public static void FileExists(string path, [CallerArgumentExpression(\"path\")] string argumentName = \"\")\n    {\n        if (!File.Exists(path))\n        {\n            throw new ArgumentException($\"File not found. Path: {path}\", argumentName);\n        }\n    }\n}\n\nstatic class FileUtilUsage\n{\n    public static string[] Method(string path)\n    {\n        FileUtil.FileExists(path);\n        return File.ReadAllLines(path);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: StringBuilder Extension Methods\nDESCRIPTION: Collection of StringBuilder extension methods for appending, joining, copying, and manipulating string data. Includes methods for handling interpolated strings, character spans, and various data types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_49\n\nLANGUAGE: C#\nCODE:\n```\nStringBuilder Append(StringBuilder, StringBuilder?, int, int)\nStringBuilder Append(StringBuilder, ReadOnlySpan<char>)\nStringBuilder Append(StringBuilder, AppendInterpolatedStringHandler)\nStringBuilder AppendJoin<T>(StringBuilder, char, IEnumerable<T>)\nStringBuilder Replace(StringBuilder, ReadOnlySpan<char>, ReadOnlySpan<char>)\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan<char> String Operations\nDESCRIPTION: Extension methods for ReadOnlySpan<char> that provide string-like operations without allocating new strings. These methods offer more efficient alternatives to standard string methods.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_40\n\nLANGUAGE: csharp\nCODE:\n```\nbool EndsWith(ReadOnlySpan<char>, string, StringComparison)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nSpanLineEnumerator EnumerateLines(ReadOnlySpan<char>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint GetNormalizedLength(ReadOnlySpan<char>, NormalizationForm)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNormalized(ReadOnlySpan<char>, NormalizationForm)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool SequenceEqual(ReadOnlySpan<char>, string)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool StartsWith(ReadOnlySpan<char>, string, StringComparison)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryNormalize(ReadOnlySpan<char>, Span<char>, int, NormalizationForm)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Index and Range Usage in C#\nDESCRIPTION: This code snippet shows how to use the Index and Range features in C#. It includes examples of substring extraction using range, accessing characters with index from end, and array indexing from the end.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\n[TestFixture]\nclass IndexRangeSample\n{\n    [Test]\n    public void Range()\n    {\n        var substring = \"value\"[2..];\n        Assert.AreEqual(\"lue\", substring);\n    }\n\n    [Test]\n    public void Index()\n    {\n        var ch = \"value\"[^2];\n        Assert.AreEqual('u', ch);\n    }\n\n    [Test]\n    public void ArrayIndex()\n    {\n        var array = new[]\n        {\n            \"value1\",\n            \"value2\"\n        };\n\n        var value = array[^2];\n\n        Assert.AreEqual(\"value1\", value);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Span<char> Extension Methods in C#\nDESCRIPTION: Extension methods for the Span<char> struct, providing string-like operations on character spans. These methods enable efficient text processing without heap allocations, including line enumeration and trimming operations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_44\n\nLANGUAGE: C#\nCODE:\n```\nbool EndsWith(Span<char>, string)\nSpanLineEnumerator EnumerateLines(Span<char>)\nbool SequenceEqual(Span<char>, string)\nbool StartsWith(Span<char>, string)\nSpan<char> TrimEnd(Span<char>)\nSpan<char> TrimStart(Span<char>)\n```\n\n----------------------------------------\n\nTITLE: HttpClient Asynchronous Request Methods with Cancellation in C#\nDESCRIPTION: Extension methods for HttpClient that support cancellation tokens for asynchronous HTTP operations. These methods enable retrieving content as byte arrays, streams, or strings while allowing for operation cancellation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_18\n\nLANGUAGE: C#\nCODE:\n```\nTask<byte[]> GetByteArrayAsync(HttpClient, string, CancellationToken)\nTask<byte[]> GetByteArrayAsync(HttpClient, Uri, CancellationToken)\nTask<Stream> GetStreamAsync(HttpClient, string, CancellationToken)\nTask<Stream> GetStreamAsync(HttpClient, Uri, CancellationToken)\nTask<string> GetStringAsync(HttpClient, string, CancellationToken)\nTask<string> GetStringAsync(HttpClient, Uri, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Guard Validation Methods\nDESCRIPTION: Collection of guard methods for validating various input types including strings, collections, and memory spans. Includes null checks, empty checks, and whitespace validation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_74\n\nLANGUAGE: csharp\nCODE:\n```\nvoid DirectoryExists(string)\nvoid FileExists(string)\nvoid NotEmpty(string?)\nvoid NotEmpty<T>(Memory<T>?)\nvoid NotEmpty<T>(Memory<T>)\nvoid NotEmpty<T>(ReadOnlyMemory<T>?)\nvoid NotEmpty<T>(ReadOnlyMemory<T>)\nvoid NotEmpty<T>(ReadOnlySpan<T>)\nvoid NotEmpty<T>(Span<T>)\nvoid NotEmpty<T>(T?) where T : IEnumerable\nstring NotNull(string?)\nT NotNull<T>(T?) where T : class\nMemory<char> NotNullOrEmpty(Memory<char>?)\nReadOnlyMemory<char> NotNullOrEmpty(ReadOnlyMemory<char>?)\nstring NotNullOrEmpty(string?)\nT NotNullOrEmpty<T>(T?) where T : IEnumerable\nMemory<char> NotNullOrWhiteSpace(Memory<char>?)\nReadOnlyMemory<char> NotNullOrWhiteSpace(ReadOnlyMemory<char>?)\nstring NotNullOrWhiteSpace(string?)\nvoid NotWhiteSpace(Memory<char>?)\nvoid NotWhiteSpace(ReadOnlyMemory<char>?)\nvoid NotWhiteSpace(ReadOnlySpan<char>)\nvoid NotWhiteSpace(Span<char>)\nvoid NotWhiteSpace(string?)\n```\n\n----------------------------------------\n\nTITLE: Joining Strings in C# (StringPolyfill)\nDESCRIPTION: Methods for joining strings and objects using various input types including arrays, ReadOnlySpan, and IEnumerable. Includes overloads with different separator types (char and string) and input types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_70\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(char, object?[])\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(char, ReadOnlySpan<object?>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(char, ReadOnlySpan<string?>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(char, string?[], int, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(char, string?[])\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(string?, ReadOnlySpan<object?>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join(string?, ReadOnlySpan<string?>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nstring Join<T>(char, IEnumerable<T>)\n```\n\n----------------------------------------\n\nTITLE: Stream Async Operations\nDESCRIPTION: Method signatures for asynchronous Stream operations including copying, disposal, reading, and writing with ValueTask support.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_49\n\nLANGUAGE: csharp\nCODE:\n```\nTask CopyToAsync(Stream, Stream, CancellationToken)\nValueTask DisposeAsync(Stream)\nValueTask<int> ReadAsync(Stream, Memory<byte>, CancellationToken)\nValueTask WriteAsync(Stream, ReadOnlyMemory<byte>, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan<T> Extension Methods in C#\nDESCRIPTION: Extension methods for the ReadOnlySpan<T> class including Contains, EndsWith, Split, SplitAny, and StartsWith. These methods provide span-based operations for efficient memory management without allocations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_39\n\nLANGUAGE: C#\nCODE:\n```\nbool Contains<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>\nbool EndsWith<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>?\nSpanSplitEnumerator<T> Split<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>\nSpanSplitEnumerator<T> Split<T>(ReadOnlySpan<T>, ReadOnlySpan<T>) where T : IEquatable<T>\nSpanSplitEnumerator<T> SplitAny<T>(ReadOnlySpan<T>, ReadOnlySpan<T>) where T : IEquatable<T>\nSpanSplitEnumerator<T> SplitAny<T>(ReadOnlySpan<T>, SearchValues<T>) where T : IEquatable<T>\nbool StartsWith<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>?\n```\n\n----------------------------------------\n\nTITLE: Path Manipulation Utility Polyfills\nDESCRIPTION: Polyfill implementations of Path utility methods for file and directory path manipulation. These methods provide functionalities for combining paths, extracting file information, checking path properties, and handling directory separators.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\nstring Combine(ReadOnlySpan<string>)\nbool EndsInDirectorySeparator(ReadOnlySpan<char>)\nbool EndsInDirectorySeparator(string)\nbool Exists(string?)\nReadOnlySpan<char> GetDirectoryName(ReadOnlySpan<char>)\nReadOnlySpan<char> GetExtension(ReadOnlySpan<char>)\nReadOnlySpan<char> GetFileName(ReadOnlySpan<char>)\nReadOnlySpan<char> GetFileNameWithoutExtension(ReadOnlySpan<char>)\nbool HasExtension(ReadOnlySpan<char>)\nReadOnlySpan<char> TrimEndingDirectorySeparator(ReadOnlySpan<char>)\nstring TrimEndingDirectorySeparator(string)\n```\n\n----------------------------------------\n\nTITLE: ConcurrentDictionary GetOrAdd Extension Method\nDESCRIPTION: Extension method that adds parameterized GetOrAdd functionality to ConcurrentDictionary<TKey, TValue>, allowing creation of values with factory methods that accept additional arguments.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nTValue GetOrAdd<TKey, TValue, TArg>(ConcurrentDictionary<TKey, TValue>, TKey, Func<TKey, TArg, TValue>, TArg) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: List<T> Extension Methods\nDESCRIPTION: Collection of extension methods for List<T> that provide additional functionality for capacity management and span-based operations. These methods help optimize memory usage and improve performance.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_30\n\nLANGUAGE: csharp\nCODE:\n```\nvoid AddRange<T>(List<T>, ReadOnlySpan<T>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid CopyTo<T>(List<T>, Span<T>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid EnsureCapacity<T>(List<T>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid InsertRange<T>(List<T>, int, ReadOnlySpan<T>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid TrimExcess<T>(List<T>)\n```\n\n----------------------------------------\n\nTITLE: IEnumerable<T> Zip Extension Methods in C#\nDESCRIPTION: LINQ extension methods for zipping multiple IEnumerable<T> sequences together. These methods combine elements from two or three sequences into tuples, creating a new sequence with corresponding elements grouped together.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<(TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(IEnumerable<TFirst>, IEnumerable<TSecond>, IEnumerable<TThird>)\nIEnumerable<(TFirst First, TSecond Second)> Zip<TFirst, TSecond>(IEnumerable<TFirst>, IEnumerable<TSecond>)\n```\n\n----------------------------------------\n\nTITLE: IReadOnlyDictionary GetValueOrDefault Extensions\nDESCRIPTION: Extension methods for IReadOnlyDictionary that provide safe ways to retrieve values with default fallbacks when keys are not found. These methods avoid exceptions when accessing non-existent keys.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_27\n\nLANGUAGE: csharp\nCODE:\n```\nTValue? GetValueOrDefault<TKey, TValue>(IReadOnlyDictionary<TKey, TValue>, TKey) where TKey : notnull\n```\n\nLANGUAGE: csharp\nCODE:\n```\nTValue GetValueOrDefault<TKey, TValue>(IReadOnlyDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: Random Class Extensions\nDESCRIPTION: Extension methods for the Random class that provide additional randomization capabilities including working with spans and arrays. These methods enable more efficient and flexible random operations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_39\n\nLANGUAGE: csharp\nCODE:\n```\nvoid GetItems<T>(Random, ReadOnlySpan<T>, Span<T>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nT[] GetItems<T>(Random, ReadOnlySpan<T>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nT[] GetItems<T>(Random, T[], int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid NextBytes(Random, Span<byte>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Shuffle<T>(Random, T[])\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Shuffle<T>(Random, Span<T>)\n```\n\n----------------------------------------\n\nTITLE: Math.Clamp Method Polyfills for Multiple Numeric Types\nDESCRIPTION: Polyfill implementations of the Math.Clamp method for various numeric types. These methods constrain a value to be within a specified inclusive range, returning the value if it's within range, or the nearest bound if outside.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\nbyte Clamp(byte, byte, byte)\ndecimal Clamp(decimal, decimal, decimal)\ndouble Clamp(double, double, double)\nfloat Clamp(float, float, float)\nint Clamp(int, int, int)\nlong Clamp(long, long, long)\nnint Clamp(nint, nint, nint)\nnuint Clamp(nuint, nuint, nuint)\nsbyte Clamp(sbyte, sbyte, sbyte)\nshort Clamp(short, short, short)\nuint Clamp(uint, uint, uint)\nulong Clamp(ulong, ulong, ulong)\nushort Clamp(ushort, ushort, ushort)\n```\n\n----------------------------------------\n\nTITLE: FilePolyfill Methods in C#\nDESCRIPTION: A collection of File class polyfill methods for various file operations such as appending, reading, and writing data asynchronously. These methods handle different data types including bytes, text, and lines of strings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\nvoid AppendAllBytes(string, byte[])\nvoid AppendAllBytes(string, ReadOnlySpan<byte>)\nTask AppendAllBytesAsync(string, byte[], CancellationToken)\nTask AppendAllBytesAsync(string, ReadOnlyMemory<byte>, CancellationToken)\nTask AppendAllLinesAsync(string, IEnumerable<string>, CancellationToken)\nTask AppendAllLinesAsync(string, IEnumerable<string>, Encoding, CancellationToken)\nvoid AppendAllText(string, ReadOnlySpan<char>, Encoding)\nvoid AppendAllText(string, ReadOnlySpan<char>)\nTask AppendAllTextAsync(string, ReadOnlyMemory<char>, CancellationToken)\nTask AppendAllTextAsync(string, ReadOnlyMemory<char>, Encoding, CancellationToken)\nTask AppendAllTextAsync(string, string?, CancellationToken)\nTask AppendAllTextAsync(string, string?, Encoding, CancellationToken)\nvoid Move(string, string, bool)\nTask<byte[]> ReadAllBytesAsync(string, CancellationToken)\nTask<string[]> ReadAllLinesAsync(string, CancellationToken)\nTask<string[]> ReadAllLinesAsync(string, Encoding, CancellationToken)\nTask<string> ReadAllTextAsync(string, CancellationToken)\nTask<string> ReadAllTextAsync(string, Encoding, CancellationToken)\nIAsyncEnumerable<string> ReadLinesAsync(string, CancellationToken)\nIAsyncEnumerable<string> ReadLinesAsync(string, Encoding, CancellationToken)\nTask WriteAllBytesAsync(string, byte[], CancellationToken)\nTask WriteAllBytesAsync(string, ReadOnlyMemory<byte>, CancellationToken)\nTask WriteAllLinesAsync(string, IEnumerable<string>, CancellationToken)\nTask WriteAllLinesAsync(string, IEnumerable<string>, Encoding, CancellationToken)\nvoid WriteAllText(string, ReadOnlySpan<char>, Encoding)\nvoid WriteAllText(string, ReadOnlySpan<char>)\nTask WriteAllTextAsync(string, string?, CancellationToken)\nTask WriteAllTextAsync(string, string?, Encoding, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Enum Utility Polyfill Methods\nDESCRIPTION: Polyfill implementations of various utility methods for Enum. These methods include getting names and values of enum members, parsing enum values, and formatting enum values to strings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\nstring[] GetNames<TEnum>() where TEnum : struct, Enum\nTEnum[] GetValues<TEnum>() where TEnum : struct, Enum\nbool IsDefined<TEnum>(TEnum) where TEnum : struct, Enum\nTEnum Parse<TEnum>(ReadOnlySpan<char>, bool) where TEnum : struct, Enum\nTEnum Parse<TEnum>(ReadOnlySpan<char>) where TEnum : struct, Enum\nTEnum Parse<TEnum>(string, bool) where TEnum : struct, Enum\nTEnum Parse<TEnum>(string) where TEnum : struct, Enum\nbool TryFormat<TEnum>(TEnum, Span<char>, int, ReadOnlySpan<char>) where TEnum : struct, Enum\nbool TryParse<TEnum>(ReadOnlySpan<char>, bool, TEnum) where TEnum : struct, Enum\nbool TryParse<TEnum>(ReadOnlySpan<char>, TEnum) where TEnum : struct, Enum\n```\n\n----------------------------------------\n\nTITLE: TextReader Extension Methods\nDESCRIPTION: Async extension methods for TextReader providing cancellable reading operations with Memory<char> and string return types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\nValueTask<int> ReadAsync(TextReader, Memory<char>, CancellationToken)\nTask<string> ReadLineAsync(TextReader, CancellationToken)\nTask<string> ReadToEndAsync(TextReader, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Lock Synchronization Methods\nDESCRIPTION: Implementation of locking mechanisms for synchronization, including methods to enter and exit locks with various timeout options and scoped locking.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_75\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Enter()\nScope EnterScope()\nvoid Exit()\nbool TryEnter()\nbool TryEnter(int)\nbool TryEnter(TimeSpan)\n```\n\n----------------------------------------\n\nTITLE: HttpClient Async Method Signatures with CancellationToken in C#\nDESCRIPTION: Method signatures for HttpClient asynchronous operations that accept CancellationToken. These methods provide cancellable versions of GET operations for byte arrays, streams, and strings using either string URLs or Uri objects.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_22\n\nLANGUAGE: C#\nCODE:\n```\nTask<byte[]> GetByteArrayAsync(HttpClient, string, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<byte[]> GetByteArrayAsync(HttpClient, Uri, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<Stream> GetStreamAsync(HttpClient, string, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<Stream> GetStreamAsync(HttpClient, Uri, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<string> GetStringAsync(HttpClient, string, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<string> GetStringAsync(HttpClient, Uri, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Path Manipulation Methods Polyfill in C#\nDESCRIPTION: Implementation of path manipulation methods including combining paths, checking directory separators, and extracting file and directory information from paths. Supports both string and character span operations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_65\n\nLANGUAGE: C#\nCODE:\n```\nstring Combine(ReadOnlySpan<string>)\nbool EndsInDirectorySeparator(ReadOnlySpan<char>)\nbool EndsInDirectorySeparator(string)\nbool Exists(string?)\nReadOnlySpan<char> GetDirectoryName(ReadOnlySpan<char>)\nReadOnlySpan<char> GetExtension(ReadOnlySpan<char>)\nReadOnlySpan<char> GetFileName(ReadOnlySpan<char>)\nReadOnlySpan<char> GetFileNameWithoutExtension(ReadOnlySpan<char>)\nbool HasExtension(ReadOnlySpan<char>)\nReadOnlySpan<char> TrimEndingDirectorySeparator(ReadOnlySpan<char>)\nstring TrimEndingDirectorySeparator(string)\n```\n\n----------------------------------------\n\nTITLE: Implementing GetValueOrDefault for IReadOnlyDictionary in C#\nDESCRIPTION: Provides GetValueOrDefault implementations for IReadOnlyDictionary, allowing retrieval of values with optional default.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nTValue? GetValueOrDefault<TKey, TValue>(IReadOnlyDictionary<TKey, TValue>, TKey) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nTValue GetValueOrDefault<TKey, TValue>(IReadOnlyDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: string Operations with Enhanced Comparison Options\nDESCRIPTION: Method signatures for string operations with enhanced comparison, character handling, and line ending functionality including Contains, CopyTo, EndsWith, IndexOf, and ReplaceLineEndings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_50\n\nLANGUAGE: csharp\nCODE:\n```\nbool Contains(string, char, StringComparison)\nbool Contains(string, string, StringComparison)\nbool Contains(string, char)\nvoid CopyTo(string, Span<char>)\nbool EndsWith(string, char)\nint GetHashCode(string, StringComparison)\nint IndexOf(string, char, StringComparison)\nstring ReplaceLineEndings(string, string)\nstring ReplaceLineEndings(string)\nstring[] Split(string, char, StringSplitOptions)\nstring[] Split(string, char, int, StringSplitOptions)\nbool StartsWith(string, char)\nbool TryCopyTo(string, Span<char>)\n```\n\n----------------------------------------\n\nTITLE: MethodInfo Delegate Creation Methods\nDESCRIPTION: Methods for creating typed delegates from MethodInfo objects. These methods simplify the process of creating delegates for dynamic method invocation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_33\n\nLANGUAGE: csharp\nCODE:\n```\nT CreateDelegate<T>(MethodInfo) where T : Delegate\n```\n\nLANGUAGE: csharp\nCODE:\n```\nT CreateDelegate<T>(MethodInfo, object?) where T : Delegate\n```\n\n----------------------------------------\n\nTITLE: HashSet<T> Extension Methods in C#\nDESCRIPTION: Extension methods for HashSet<T> operations including capacity management and value retrieval. These methods allow ensuring minimum capacity, trimming excess capacity, and retrieving values efficiently.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_17\n\nLANGUAGE: C#\nCODE:\n```\nvoid EnsureCapacity<T>(HashSet<T>, int)\nvoid TrimExcess<T>(HashSet<T>, int)\nbool TryGetValue<T>(HashSet<T>, T, T)\n```\n\n----------------------------------------\n\nTITLE: IDictionary<TKey, TValue> Extension Methods in C#\nDESCRIPTION: Extension methods for IDictionary<TKey, TValue> providing additional functionality for dictionary operations. These methods enable creating read-only views, removing key-value pairs, and trying to add entries without exceptions.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(IDictionary<TKey, TValue>) where TKey : notnull\nbool Remove<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\nbool TryAdd<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: Implementing MemberInfo Extensions in C#\nDESCRIPTION: Provides extension methods for MemberInfo including GetNullability, GetNullabilityInfo, HasSameMetadataDefinitionAs, and IsNullable.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_30\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityState GetNullability(MemberInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(MemberInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool HasSameMetadataDefinitionAs(MemberInfo, MemberInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsNullable(MemberInfo)\n```\n\n----------------------------------------\n\nTITLE: DateOnly TryFormat Extension Methods\nDESCRIPTION: Extension methods that add TryFormat functionality to DateOnly, allowing formatting of date values into both byte and character spans with formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateOnly, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateOnly, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Extending StringBuilder with AppendLine and Other Methods in C#\nDESCRIPTION: This snippet shows additional extension methods for StringBuilder, including AppendLine overloads and methods for copying, comparing, and manipulating string data within the StringBuilder.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_52\n\nLANGUAGE: C#\nCODE:\n```\nStringBuilder AppendLine(StringBuilder, AppendInterpolatedStringHandler)\nStringBuilder AppendLine(StringBuilder, IFormatProvider?, AppendInterpolatedStringHandler)\nStringBuilder AppendLine(StringBuilder, StringBuilder.AppendInterpolatedStringHandler)\nStringBuilder AppendLine(StringBuilder, IFormatProvider?, StringBuilder.AppendInterpolatedStringHandler)\nvoid CopyTo(StringBuilder, int, Span<char>, int)\nbool Equals(StringBuilder, ReadOnlySpan<char>)\nChunkEnumerator GetChunks(StringBuilder)\nStringBuilder Insert(StringBuilder, int, ReadOnlySpan<char>)\nStringBuilder Replace(StringBuilder, ReadOnlySpan<char>, ReadOnlySpan<char>)\nStringBuilder Replace(StringBuilder, ReadOnlySpan<char>, ReadOnlySpan<char>, int, int)\n```\n\n----------------------------------------\n\nTITLE: OperatingSystem Platform Detection Polyfills\nDESCRIPTION: Polyfill implementations of OperatingSystem methods for platform detection and version checking. These methods allow checking for specific operating systems (Windows, macOS, Linux, etc.) and comparing against minimum version requirements.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\nbool IsAndroid()\nbool IsAndroidVersionAtLeast(int, int, int, int)\nbool IsBrowser()\nbool IsFreeBSD()\nbool IsFreeBSDVersionAtLeast(int, int, int, int)\nbool IsIOS()\nbool IsIOSVersionAtLeast(int, int, int)\nbool IsLinux()\nbool IsMacCatalyst()\nbool IsMacCatalystVersionAtLeast(int, int, int)\nbool IsMacOS()\nbool IsMacOSVersionAtLeast(int, int, int)\nbool IsOSPlatform(string)\nbool IsOSPlatformVersionAtLeast(string, int, int, int, int)\nbool IsTvOS()\nbool IsTvOSVersionAtLeast(int, int, int)\nbool IsWasi()\nbool IsWatchOS()\nbool IsWatchOSVersionAtLeast(int, int, int)\nbool IsWindows()\nbool IsWindowsVersionAtLeast(int, int, int, int)\n```\n\n----------------------------------------\n\nTITLE: Extending Task and Task<TResult> with WaitAsync Methods in C#\nDESCRIPTION: This snippet provides extension methods for Task and Task<TResult> classes, adding WaitAsync functionality. These methods allow tasks to be awaited with timeout and cancellation options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\nTask WaitAsync(Task, CancellationToken)\nTask WaitAsync(Task, TimeSpan)\nTask WaitAsync(Task, TimeSpan, CancellationToken)\nTask<TResult> WaitAsync<TResult>(Task<TResult>, CancellationToken)\nTask<TResult> WaitAsync<TResult>(Task<TResult>, TimeSpan)\nTask<TResult> WaitAsync<TResult>(Task<TResult>, TimeSpan, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Regex Extensions for ReadOnlySpan<char> in C#\nDESCRIPTION: Extension methods for the Regex class that operate on ReadOnlySpan<char> instead of strings, avoiding unnecessary string allocations. Includes methods for enumerating matches and checking if input matches a pattern.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_40\n\nLANGUAGE: C#\nCODE:\n```\nValueMatchEnumerator EnumerateMatches(Regex, ReadOnlySpan<char>)\nValueMatchEnumerator EnumerateMatches(Regex, ReadOnlySpan<char>, int)\nbool IsMatch(Regex, ReadOnlySpan<char>, int)\nbool IsMatch(Regex, ReadOnlySpan<char>)\n```\n\n----------------------------------------\n\nTITLE: Operating System Detection Methods Polyfill in C#\nDESCRIPTION: Collection of methods for detecting operating system type and version. Includes checks for various platforms like Android, iOS, macOS, Linux, Windows, and version comparison functionality.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_64\n\nLANGUAGE: C#\nCODE:\n```\nbool IsAndroid()\nbool IsAndroidVersionAtLeast(int, int, int, int)\nbool IsBrowser()\nbool IsFreeBSD()\nbool IsFreeBSDVersionAtLeast(int, int, int, int)\nbool IsIOS()\nbool IsIOSVersionAtLeast(int, int, int)\nbool IsLinux()\nbool IsMacCatalyst()\nbool IsMacCatalystVersionAtLeast(int, int, int)\nbool IsMacOS()\nbool IsMacOSVersionAtLeast(int, int, int)\nbool IsOSPlatform(string)\nbool IsOSPlatformVersionAtLeast(string, int, int, int, int)\nbool IsTvOS()\nbool IsTvOSVersionAtLeast(int, int, int)\nbool IsWasi()\nbool IsWatchOS()\nbool IsWatchOSVersionAtLeast(int, int, int)\nbool IsWindows()\nbool IsWindowsVersionAtLeast(int, int, int, int)\n```\n\n----------------------------------------\n\nTITLE: SortedList<TKey, TValue> Extension Methods in C#\nDESCRIPTION: Extension methods for the SortedList<TKey, TValue> collection that provide index-based access to keys and values. These methods allow retrieving elements by position rather than by key lookup.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_43\n\nLANGUAGE: C#\nCODE:\n```\nTKey GetKeyAtIndex<TKey, TValue>(SortedList<TKey, TValue>, int)\nTValue GetValueAtIndex<TKey, TValue>(SortedList<TKey, TValue>, int)\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffset TryParse and TryParseExact Polyfill Methods\nDESCRIPTION: Polyfill implementations of TryParse and TryParseExact methods for DateTimeOffset. These methods attempt to parse a string representation of a date and time with offset into a DateTimeOffset value.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_53\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, DateTimeOffset)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeOffset)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTimeOffset)\nbool TryParse(string?, IFormatProvider?, DateTimeOffset)\nbool TryParseExact(ReadOnlySpan<char>, ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTimeOffset)\nbool TryParseExact(ReadOnlySpan<char>, string, IFormatProvider?, DateTimeStyles, DateTimeOffset)\n```\n\n----------------------------------------\n\nTITLE: Int32/Int64 TryParse Method Polyfills for .NET\nDESCRIPTION: Polyfill implementations of various TryParse methods for Int32 (int) and Int64 (long) types. These methods handle parsing integers from different input sources including character spans, byte spans, and strings, with support for format providers and number styles.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<byte>, int)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<char>, int)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, int)\nbool TryParse(string?, IFormatProvider?, int)\n```\n\n----------------------------------------\n\nTITLE: Implementing ReadOnlySpan<char> Extensions in C#\nDESCRIPTION: Provides various extension methods for ReadOnlySpan<char> including string operations and normalization functions.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_38\n\nLANGUAGE: C#\nCODE:\n```\nbool EndsWith(ReadOnlySpan<char>, string, StringComparison)\n```\n\nLANGUAGE: C#\nCODE:\n```\nSpanLineEnumerator EnumerateLines(ReadOnlySpan<char>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nint GetNormalizedLength(ReadOnlySpan<char>, NormalizationForm)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsNormalized(ReadOnlySpan<char>, NormalizationForm)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool SequenceEqual(ReadOnlySpan<char>, string)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool StartsWith(ReadOnlySpan<char>, string, StringComparison)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryNormalize(ReadOnlySpan<char>, Span<char>, int, NormalizationForm)\n```\n\n----------------------------------------\n\nTITLE: IEnumerable<T> Zip Extension Method Signatures in C#\nDESCRIPTION: Method signatures for zipping two or three enumerable sequences together. These methods combine corresponding elements from multiple sequences into tuples, enabling parallel iteration over related collections.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_25\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<(TFirst First, TSecond Second, TThird Third)> Zip<TFirst, TSecond, TThird>(IEnumerable<TFirst>, IEnumerable<TSecond>, IEnumerable<TThird>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nIEnumerable<(TFirst First, TSecond Second)> Zip<TFirst, TSecond>(IEnumerable<TFirst>, IEnumerable<TSecond>)\n```\n\n----------------------------------------\n\nTITLE: Enumerating Regex Matches in C# (RegexPolyfill)\nDESCRIPTION: Methods for enumerating regex matches using ReadOnlySpan<char> input. Includes overloads with different parameter combinations for RegexOptions and TimeSpan.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_66\n\nLANGUAGE: C#\nCODE:\n```\nValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char>, string, RegexOptions, TimeSpan)\n```\n\nLANGUAGE: C#\nCODE:\n```\nValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char>, string, RegexOptions)\n```\n\nLANGUAGE: C#\nCODE:\n```\nValueMatchEnumerator EnumerateMatches(ReadOnlySpan<char>, string)\n```\n\n----------------------------------------\n\nTITLE: Checking Regex Matches in C# (RegexPolyfill)\nDESCRIPTION: Methods for checking if a regex pattern matches using ReadOnlySpan<char> input. Includes overloads with different parameter combinations for RegexOptions and TimeSpan.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_67\n\nLANGUAGE: C#\nCODE:\n```\nbool IsMatch(ReadOnlySpan<char>, string, RegexOptions, TimeSpan)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsMatch(ReadOnlySpan<char>, string, RegexOptions)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsMatch(ReadOnlySpan<char>, string)\n```\n\n----------------------------------------\n\nTITLE: Encoding Span-Based Extension Methods\nDESCRIPTION: Extension methods that add span-based encoding and decoding operations to Encoding, providing more efficient text conversion without intermediate allocations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_16\n\nLANGUAGE: csharp\nCODE:\n```\nint GetByteCount(Encoding, ReadOnlySpan<char>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint GetBytes(Encoding, ReadOnlySpan<char>, Span<byte>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint GetCharCount(Encoding, ReadOnlySpan<byte>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint GetChars(Encoding, ReadOnlySpan<byte>, Span<char>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nstring GetString(Encoding, ReadOnlySpan<byte>)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryGetBytes(Encoding, ReadOnlySpan<char>, Span<byte>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryGetChars(Encoding, ReadOnlySpan<byte>, Span<char>, int)\n```\n\n----------------------------------------\n\nTITLE: ReadOnlySpan<T> Extension Methods\nDESCRIPTION: Method signatures for ReadOnlySpan<T> extensions including Contains, EndsWith, Split, SplitAny, and StartsWith operations that handle generic types with IEquatable<T> constraint.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_41\n\nLANGUAGE: csharp\nCODE:\n```\nbool Contains<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>\nbool EndsWith<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>?\nSpanSplitEnumerator<T> Split<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>\nSpanSplitEnumerator<T> Split<T>(ReadOnlySpan<T>, ReadOnlySpan<T>) where T : IEquatable<T>\nSpanSplitEnumerator<T> SplitAny<T>(ReadOnlySpan<T>, ReadOnlySpan<T>) where T : IEquatable<T>\nSpanSplitEnumerator<T> SplitAny<T>(ReadOnlySpan<T>, SearchValues<T>) where T : IEquatable<T>\nbool StartsWith<T>(ReadOnlySpan<T>, T) where T : IEquatable<T>?\n```\n\n----------------------------------------\n\nTITLE: GuidPolyfill Methods in C#\nDESCRIPTION: A collection of Guid class polyfill methods for creating and parsing GUIDs. These methods include creating version 7 GUIDs and parsing GUIDs from various string formats.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\nGuid CreateVersion7()\nGuid CreateVersion7(DateTimeOffset)\nbool TryParse(ReadOnlySpan<char>, Guid)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, Guid)\nbool TryParse(string?, IFormatProvider?, Guid)\nbool TryParseExact(ReadOnlySpan<char>, ReadOnlySpan<char>, Guid)\n```\n\n----------------------------------------\n\nTITLE: Extending StringBuilder with Append and AppendJoin Methods in C#\nDESCRIPTION: This snippet lists various overloads for the Append and AppendJoin methods of StringBuilder. These methods allow for flexible string concatenation and joining, supporting different data types and formats.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\nStringBuilder Append(StringBuilder, StringBuilder?, int, int)\nStringBuilder Append(StringBuilder, ReadOnlySpan<char>)\nStringBuilder Append(StringBuilder, AppendInterpolatedStringHandler)\nStringBuilder Append(StringBuilder, IFormatProvider?, AppendInterpolatedStringHandler)\nStringBuilder Append(StringBuilder, StringBuilder.AppendInterpolatedStringHandler)\nStringBuilder Append(StringBuilder, IFormatProvider?, StringBuilder.AppendInterpolatedStringHandler)\nStringBuilder AppendJoin<T>(StringBuilder, char, IEnumerable<T>)\nStringBuilder AppendJoin<T>(StringBuilder, string?, IEnumerable<T>)\nStringBuilder AppendJoin(StringBuilder, string?, string?[])\nStringBuilder AppendJoin(StringBuilder, string?, object?[])\nStringBuilder AppendJoin(StringBuilder, char, string?[])\nStringBuilder AppendJoin(StringBuilder, char, object?[])\nStringBuilder AppendJoin<T>(StringBuilder, char, T[])\nStringBuilder AppendJoin<T>(StringBuilder, string, T[])\n```\n\n----------------------------------------\n\nTITLE: DateTimeOffset Extension Methods\nDESCRIPTION: Extension methods for DateTimeOffset that add microsecond precision, deconstruction, and formatting options. These methods enhance DateTimeOffset with higher precision timing and convenient breakdown of components.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_9\n\nLANGUAGE: csharp\nCODE:\n```\nDateTimeOffset AddMicroseconds(DateTimeOffset, double)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Deconstruct(DateTimeOffset, DateOnly, TimeOnly, TimeSpan)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint Microsecond(DateTimeOffset)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint Nanosecond(DateTimeOffset)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateTimeOffset, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateTimeOffset, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: DateTime TryParse and TryParseExact Polyfill Methods\nDESCRIPTION: Polyfill implementations of TryParse and TryParseExact methods for DateTime. These methods attempt to parse a string representation of a date and time into a DateTime value.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, DateTime)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTime)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTime)\nbool TryParse(string?, IFormatProvider?, DateTime)\nbool TryParseExact(ReadOnlySpan<char>, ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTime)\nbool TryParseExact(ReadOnlySpan<char>, string, IFormatProvider?, DateTimeStyles, DateTime)\n```\n\n----------------------------------------\n\nTITLE: Extending TaskCompletionSource<T> with SetCanceled Method in C#\nDESCRIPTION: This snippet shows an extension method for TaskCompletionSource<T>, allowing it to be set as canceled with a specific CancellationToken.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_54\n\nLANGUAGE: C#\nCODE:\n```\nvoid SetCanceled<T>(TaskCompletionSource<T>, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: ConcurrentQueue Clear Extension Method\nDESCRIPTION: Extension method that adds Clear functionality to ConcurrentQueue<T>, allowing removal of all elements from the concurrent queue.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Clear<T>(ConcurrentQueue<T>)\n```\n\n----------------------------------------\n\nTITLE: OrderedDictionary Extensions\nDESCRIPTION: Extension methods for OrderedDictionary<TKey, TValue> that provide safe ways to add and retrieve values. These methods enable more efficient dictionary operations with positional awareness.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_34\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryAdd<TKey, TValue>(OrderedDictionary<TKey, TValue>, TKey, TValue, int) where TKey : notnull\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryGetValue<TKey, TValue>(OrderedDictionary<TKey, TValue>, TKey, TValue, int) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: Math Clamp Methods Polyfill in C#\nDESCRIPTION: Implementation of Clamp methods for various numeric types to constrain values within a specified range. Supports byte, decimal, double, float, int, long, nint, nuint, sbyte, short, uint, ulong, and ushort types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_63\n\nLANGUAGE: C#\nCODE:\n```\nbyte Clamp(byte, byte, byte)\ndecimal Clamp(decimal, decimal, decimal)\ndouble Clamp(double, double, double)\nfloat Clamp(float, float, float)\nint Clamp(int, int, int)\nlong Clamp(long, long, long)\nnint Clamp(nint, nint, nint)\nnuint Clamp(nuint, nuint, nuint)\nsbyte Clamp(sbyte, sbyte, sbyte)\nshort Clamp(short, short, short)\nuint Clamp(uint, uint, uint)\nulong Clamp(ulong, ulong, ulong)\nushort Clamp(ushort, ushort, ushort)\n```\n\n----------------------------------------\n\nTITLE: Stack<T> Extension Methods in C#\nDESCRIPTION: Extension methods for the Stack<T> collection that provide capacity management and safer element access. These methods allow adjusting capacity and safely retrieving elements without exceptions.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_46\n\nLANGUAGE: C#\nCODE:\n```\nvoid EnsureCapacity<T>(Stack<T>, int)\nvoid TrimExcess<T>(Stack<T>, int)\nbool TryPeek<T>(Stack<T>, T)\nbool TryPop<T>(Stack<T>, T)\n```\n\n----------------------------------------\n\nTITLE: Span<char> Extension Methods\nDESCRIPTION: Method signatures for Span<char> extensions including string comparison operations, line enumeration, and trimming functionality.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_46\n\nLANGUAGE: csharp\nCODE:\n```\nbool EndsWith(Span<char>, string)\nSpanLineEnumerator EnumerateLines(Span<char>)\nbool SequenceEqual(Span<char>, string)\nbool StartsWith(Span<char>, string)\nSpan<char> TrimEnd(Span<char>)\nSpan<char> TrimStart(Span<char>)\n```\n\n----------------------------------------\n\nTITLE: Task Extension Methods\nDESCRIPTION: Extension methods for Task class providing async wait operations with cancellation and timeout support.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_50\n\nLANGUAGE: C#\nCODE:\n```\nTask WaitAsync(Task, CancellationToken)\nTask WaitAsync(Task, TimeSpan)\nTask WaitAsync(Task, TimeSpan, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: HashSet<T> Extension Method Signatures in C#\nDESCRIPTION: Method signatures for HashSet<T> capacity management and value retrieval. These methods provide functionality for ensuring capacity, trimming excess memory, and retrieving values without creating new objects.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_21\n\nLANGUAGE: C#\nCODE:\n```\nvoid EnsureCapacity<T>(HashSet<T>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid TrimExcess<T>(HashSet<T>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryGetValue<T>(HashSet<T>, T, T)\n```\n\n----------------------------------------\n\nTITLE: ISet AsReadOnly Extension\nDESCRIPTION: Extension method that creates a read-only wrapper around an ISet<T> instance. This method allows creating immutable views of sets without copying the data.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_28\n\nLANGUAGE: csharp\nCODE:\n```\nReadOnlySet<T> AsReadOnly<T>(ISet<T>)\n```\n\n----------------------------------------\n\nTITLE: Implementing List Extensions in C#\nDESCRIPTION: Provides various extension methods for List<T> including AddRange, CopyTo, EnsureCapacity, InsertRange, and TrimExcess.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_28\n\nLANGUAGE: C#\nCODE:\n```\nvoid AddRange<T>(List<T>, ReadOnlySpan<T>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid CopyTo<T>(List<T>, Span<T>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid EnsureCapacity<T>(List<T>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid InsertRange<T>(List<T>, int, ReadOnlySpan<T>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid TrimExcess<T>(List<T>)\n```\n\n----------------------------------------\n\nTITLE: Generic Task<TResult> Extension Methods\nDESCRIPTION: Generic Task<TResult> extension methods for handling asynchronous operations with result values, including timeout and cancellation support.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_51\n\nLANGUAGE: C#\nCODE:\n```\nTask<TResult> WaitAsync<TResult>(Task<TResult>, CancellationToken)\nTask<TResult> WaitAsync<TResult>(Task<TResult>, TimeSpan)\nTask<TResult> WaitAsync<TResult>(Task<TResult>, TimeSpan, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Span<T> Extension Methods\nDESCRIPTION: Method signature for checking if a Span<T> contains an element that satisfies equality comparison using IEquatable<T>.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_47\n\nLANGUAGE: csharp\nCODE:\n```\nbool Contains<T>(Span<T>, T) where T : IEquatable<T>\n```\n\n----------------------------------------\n\nTITLE: Regex Methods with ReadOnlySpan<char> Support\nDESCRIPTION: Method signatures for Regex operations that work with ReadOnlySpan<char> instead of string, including EnumerateMatches and IsMatch variants.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_42\n\nLANGUAGE: csharp\nCODE:\n```\nValueMatchEnumerator EnumerateMatches(Regex, ReadOnlySpan<char>)\nValueMatchEnumerator EnumerateMatches(Regex, ReadOnlySpan<char>, int)\nbool IsMatch(Regex, ReadOnlySpan<char>, int)\nbool IsMatch(Regex, ReadOnlySpan<char>)\n```\n\n----------------------------------------\n\nTITLE: IDictionary<TKey, TValue> Extension Method Signatures in C#\nDESCRIPTION: Method signatures for dictionary extension methods providing additional functionality. These methods enable creating read-only wrappers, conditional key-value removal, and attempting to add entries without exceptions.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlyDictionary<TKey, TValue> AsReadOnly<TKey, TValue>(IDictionary<TKey, TValue>) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool Remove<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryAdd<TKey, TValue>(IDictionary<TKey, TValue>, TKey, TValue) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: Float TryFormat Methods in C#\nDESCRIPTION: TryFormat extension methods for formatting float values into byte or character spans. These methods provide efficient formatting without allocations, taking format specifications and returning success status.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_15\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(float, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\nbool TryFormat(float, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: DefaultInterpolatedStringHandler Clear Extension Method\nDESCRIPTION: Extension method that adds Clear functionality to DefaultInterpolatedStringHandler, allowing the handler to be reset and reused.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Clear(DefaultInterpolatedStringHandler)\n```\n\n----------------------------------------\n\nTITLE: Implementing CreateDelegate for MethodInfo in C#\nDESCRIPTION: Provides CreateDelegate implementations for MethodInfo, allowing creation of delegate types from method information.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_31\n\nLANGUAGE: C#\nCODE:\n```\nT CreateDelegate<T>(MethodInfo) where T : Delegate\n```\n\nLANGUAGE: C#\nCODE:\n```\nT CreateDelegate<T>(MethodInfo, object?) where T : Delegate\n```\n\n----------------------------------------\n\nTITLE: Enum Utility Methods in C#\nDESCRIPTION: Polyfill methods for working with Enum types, including parsing, formatting, and retrieving enum information. These methods provide additional functionality and flexibility for handling enums.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_60\n\nLANGUAGE: C#\nCODE:\n```\nstring[] GetNames<TEnum>() where TEnum : struct, Enum\nTEnum[] GetValues<TEnum>() where TEnum : struct, Enum\nbool IsDefined<TEnum>(TEnum) where TEnum : struct, Enum\nTEnum Parse<TEnum>(ReadOnlySpan<char>, bool) where TEnum : struct, Enum\nTEnum Parse<TEnum>(ReadOnlySpan<char>) where TEnum : struct, Enum\nTEnum Parse<TEnum>(string, bool) where TEnum : struct, Enum\nTEnum Parse<TEnum>(string) where TEnum : struct, Enum\nbool TryFormat<TEnum>(TEnum, Span<char>, int, ReadOnlySpan<char>) where TEnum : struct, Enum\nbool TryParse<TEnum>(ReadOnlySpan<char>, bool, TEnum) where TEnum : struct, Enum\nbool TryParse<TEnum>(ReadOnlySpan<char>, TEnum) where TEnum : struct, Enum\n```\n\n----------------------------------------\n\nTITLE: Guid TryFormat Methods in C#\nDESCRIPTION: TryFormat extension methods for formatting Guid values into byte or character spans. These methods allow for efficient formatting of GUIDs without memory allocations, taking format specifications and returning success status.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_16\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(Guid, Span<byte>, int, ReadOnlySpan<char>)\nbool TryFormat(Guid, Span<char>, int, ReadOnlySpan<char>)\n```\n\n----------------------------------------\n\nTITLE: Parsing DateTime in C#\nDESCRIPTION: Polyfill methods for parsing DateTime values from various string representations. These methods offer additional parsing options and flexibility compared to built-in methods.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_57\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, DateTime)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTime)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTime)\nbool TryParse(string?, IFormatProvider?, DateTime)\nbool TryParseExact(ReadOnlySpan<char>, ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTime)\nbool TryParseExact(ReadOnlySpan<char>, string, IFormatProvider?, DateTimeStyles, DateTime)\n```\n\n----------------------------------------\n\nTITLE: Long Integer Parsing Methods Polyfill in C#\nDESCRIPTION: Collection of TryParse method implementations for parsing long integers from various data types including byte spans, char spans, and strings. Includes overloads for different format providers and number styles.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_62\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, long)\nbool TryParse(ReadOnlySpan<byte>, long)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, long)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, long)\nbool TryParse(ReadOnlySpan<char>, long)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, long)\nbool TryParse(string?, IFormatProvider?, long)\n```\n\n----------------------------------------\n\nTITLE: Double TryFormat Extension Methods\nDESCRIPTION: Extension methods that add TryFormat functionality to double type, allowing formatting of double values into both byte and character spans with formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_15\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(double, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(double, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Defining a C# Class with Nullable Reference Types\nDESCRIPTION: Example class demonstrating nullable reference type annotations in C#, including a nullable string field, an array of nullable strings, and a dictionary with nullable object values.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_68\n\nLANGUAGE: csharp\nCODE:\n```\nclass NullabilityTarget\n{\n    public string? StringField;\n    public string?[] ArrayField;\n    public Dictionary<string, object?> GenericField;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Deconstruct for KeyValuePair in C#\nDESCRIPTION: Provides a Deconstruct implementation for KeyValuePair, allowing easy unpacking of key-value pairs.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_27\n\nLANGUAGE: C#\nCODE:\n```\nvoid Deconstruct<TKey, TValue>(KeyValuePair<TKey, TValue>, TKey, TValue)\n```\n\n----------------------------------------\n\nTITLE: Extension Methods for IList<T>\nDESCRIPTION: Extension methods available for the IList<T> interface. The method is presented with its signature and includes a link to the official Microsoft documentation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlyCollection<T> AsReadOnly<T>(IList<T>)\n```\n\n----------------------------------------\n\nTITLE: Byte TryFormat Extension Methods\nDESCRIPTION: Extension methods that add TryFormat functionality to the byte type, allowing formatting of byte values into both byte and character spans with formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(byte, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(byte, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Implementing Random Extensions in C#\nDESCRIPTION: Provides various extension methods for Random including GetItems, NextBytes, and Shuffle operations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_37\n\nLANGUAGE: C#\nCODE:\n```\nvoid GetItems<T>(Random, ReadOnlySpan<T>, Span<T>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nT[] GetItems<T>(Random, ReadOnlySpan<T>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nT[] GetItems<T>(Random, T[], int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid NextBytes(Random, Span<byte>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid Shuffle<T>(Random, T[])\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid Shuffle<T>(Random, Span<T>)\n```\n\n----------------------------------------\n\nTITLE: Parsing Double in C#\nDESCRIPTION: Polyfill methods for parsing Double values from various string and byte representations. These methods offer additional parsing options and flexibility compared to built-in methods.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_59\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, double)\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<char>, double)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, double)\nbool TryParse(string?, IFormatProvider?, double)\n```\n\n----------------------------------------\n\nTITLE: Implementing TryFormat for int in C#\nDESCRIPTION: Provides TryFormat implementations for int type, allowing formatting to both byte and char spans with various options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_24\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(int, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(int, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Stack<T> Capacity Management and Try Methods\nDESCRIPTION: Method signatures for capacity management and try-pattern operations on Stack<T>, including EnsureCapacity, TrimExcess, TryPeek, and TryPop.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_48\n\nLANGUAGE: csharp\nCODE:\n```\nvoid EnsureCapacity<T>(Stack<T>, int)\nvoid TrimExcess<T>(Stack<T>, int)\nbool TryPeek<T>(Stack<T>, T)\nbool TryPop<T>(Stack<T>, T)\n```\n\n----------------------------------------\n\nTITLE: DateTime Extension Methods\nDESCRIPTION: Extension methods for DateTime that add microsecond precision, deconstruction capabilities, and formatting options. These methods allow working with higher time precision and decomposing DateTime objects.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nDateTime AddMicroseconds(DateTime, double)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Deconstruct(DateTime, int, int, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Deconstruct(DateTime, DateOnly, TimeOnly)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint Microsecond(DateTime)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nint Nanosecond(DateTime)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateTime, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(DateTime, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: sbyte TryFormat Methods in C#\nDESCRIPTION: TryFormat methods for the sbyte type that allow formatting an 8-bit signed integer to character or byte spans. These methods provide allocation-free number formatting with custom format specifications.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_41\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(sbyte, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\nbool TryFormat(sbyte, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: ConcurrentBag Clear Extension Method\nDESCRIPTION: Extension method that adds Clear functionality to ConcurrentBag<T>, allowing removal of all elements from the concurrent collection.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Clear<T>(ConcurrentBag<T>)\n```\n\n----------------------------------------\n\nTITLE: Integer TryFormat Methods\nDESCRIPTION: Method signatures for formatting integers to byte and character spans with various formatting options. These methods provide efficient ways to format integers without allocating new strings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_26\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(int, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(int, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Long Integer TryFormat Methods\nDESCRIPTION: Method signatures for formatting long integers to byte and character spans with various formatting options. These methods provide efficient ways to format long integers without allocating new strings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_31\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(long, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(long, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Float TryFormat Method Signatures in C#\nDESCRIPTION: Method signatures for formatting floating-point numbers into byte and character spans with format specifiers and providers. These methods allow efficient string conversion without allocations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(float, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(float, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Enumerating Delegate Invocation List in C#\nDESCRIPTION: Polyfill method for enumerating the invocation list of a delegate. This method provides a way to iterate over the individual delegates in a multicast delegate.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_58\n\nLANGUAGE: C#\nCODE:\n```\nInvocationListEnumerator<TDelegate> EnumerateInvocationList<TDelegate>(TDelegate?) where TDelegate : Delegate\n```\n\n----------------------------------------\n\nTITLE: Testing StreamReader Polyfill Extensions in C#\nDESCRIPTION: This code snippet demonstrates how to test StreamReader polyfill extension methods. It contains tests for ReadAsync with Memory<char>, ReadToEndAsync with cancellation token, and ReadLineAsync with cancellation token, ensuring proper functionality of the polyfill implementations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\npartial class PolyfillTests\n{\n    [Test]\n    public async Task StreamReaderReadAsync()\n    {\n        using var stream = new MemoryStream(\"value\"u8.ToArray());\n        var result = new char[5];\n        var memory = new Memory<char>(result);\n        using var reader = new StreamReader(stream);\n        var read = await reader.ReadAsync(memory);\n        Assert.AreEqual(5, read);\n        Assert.IsTrue(\"value\".SequenceEqual(result));\n    }\n\n    [Test]\n    public async Task StreamReaderReadToEndAsync()\n    {\n        using var stream = new MemoryStream(\"value\"u8.ToArray());\n        using var reader = new StreamReader(stream);\n        var read = await reader.ReadToEndAsync(Cancel.None);\n        Assert.AreEqual(\"value\", read);\n    }\n\n    [Test]\n    public async Task StreamReaderReadLineAsync()\n    {\n        using var stream = new MemoryStream(\"line1\\nline2\"u8.ToArray());\n        using var reader = new StreamReader(stream);\n        var read = await reader.ReadLineAsync(CancellationToken.None);\n        Assert.AreEqual(\"line1\", read);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing UInt in C# (UIntPolyfill)\nDESCRIPTION: Methods for parsing uint values from various input types including ReadOnlySpan<byte>, ReadOnlySpan<char>, and string. Includes overloads with different parameter combinations for NumberStyles and IFormatProvider.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_71\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, uint)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(string?, IFormatProvider?, uint)\n```\n\n----------------------------------------\n\nTITLE: Implementing TryFormat for long in C#\nDESCRIPTION: Provides TryFormat implementations for long type, allowing formatting to both byte and char spans with various options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_29\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(long, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(long, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Parsing Short in C# (ShortPolyfill)\nDESCRIPTION: Methods for parsing short values from various input types including ReadOnlySpan<byte>, ReadOnlySpan<char>, and string. Includes overloads with different parameter combinations for NumberStyles and IFormatProvider.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_69\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, short)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(string?, IFormatProvider?, short)\n```\n\n----------------------------------------\n\nTITLE: ULongPolyfill TryParse Methods\nDESCRIPTION: Collection of TryParse method signatures for parsing unsigned long integers from various input formats with optional format providers and number styles.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_72\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, ulong)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, ulong)\nbool TryParse(ReadOnlySpan<byte>, ulong)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, ulong)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, ulong)\nbool TryParse(ReadOnlySpan<char>, ulong)\nbool TryParse(string?, IFormatProvider?, ulong)\n```\n\n----------------------------------------\n\nTITLE: FieldInfo Nullability Extension Methods in C#\nDESCRIPTION: Extension methods for checking nullability information on FieldInfo objects. These methods extract nullability states and information, enabling determination of whether a field can contain null values.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_14\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityState GetNullability(FieldInfo)\nNullabilityInfo GetNullabilityInfo(FieldInfo)\nbool IsNullable(FieldInfo)\n```\n\n----------------------------------------\n\nTITLE: Parsing SByte in C# (SBytePolyfill)\nDESCRIPTION: Methods for parsing sbyte values from various input types including ReadOnlySpan<byte>, ReadOnlySpan<char>, and string. Includes overloads with different parameter combinations for NumberStyles and IFormatProvider.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_68\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, sbyte)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(string?, IFormatProvider?, sbyte)\n```\n\n----------------------------------------\n\nTITLE: Double TryParse Polyfill Methods\nDESCRIPTION: Polyfill implementations of TryParse methods for Double. These methods attempt to parse a string representation of a floating-point number into a double-precision floating-point number.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, double)\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<char>, double)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, double)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, double)\nbool TryParse(string?, IFormatProvider?, double)\n```\n\n----------------------------------------\n\nTITLE: MemberInfo Nullability and Metadata Methods\nDESCRIPTION: Extension methods for MemberInfo that provide nullability information and metadata comparison capabilities. These methods help with reflection scenarios involving nullable reference types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_32\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityState GetNullability(MemberInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(MemberInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool HasSameMetadataDefinitionAs(MemberInfo, MemberInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNullable(MemberInfo)\n```\n\n----------------------------------------\n\nTITLE: short TryFormat Methods in C#\nDESCRIPTION: TryFormat methods for the short (Int16) type that allow formatting a 16-bit signed integer to character or byte spans. These methods provide allocation-free number formatting with custom format specifications.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_42\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(short, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\nbool TryFormat(short, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Integer Parsing Methods Polyfill in C#\nDESCRIPTION: Collection of TryParse method implementations for parsing integers from various data types including byte spans, char spans, and strings. Includes overloads for different format providers and number styles.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_61\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<byte>, int)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, int)\nbool TryParse(ReadOnlySpan<char>, int)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, int)\nbool TryParse(string?, IFormatProvider?, int)\n```\n\n----------------------------------------\n\nTITLE: ParameterInfo Nullability Methods\nDESCRIPTION: Extension methods for ParameterInfo that provide nullability information for parameters. These methods assist with reflection scenarios involving nullable reference types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_35\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityState GetNullability(ParameterInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(ParameterInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNullable(ParameterInfo)\n```\n\n----------------------------------------\n\nTITLE: sbyte TryFormat Methods\nDESCRIPTION: Method signatures for TryFormat operations that format sbyte values into Span<byte> or Span<char> with formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_43\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(sbyte, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\nbool TryFormat(sbyte, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: EventInfo Nullability Extension Methods in C#\nDESCRIPTION: Extension methods for checking nullability information on EventInfo objects. These methods provide access to nullability states and information, allowing determination of whether an event can accept null values.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_13\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityState GetNullability(EventInfo)\nNullabilityInfo GetNullabilityInfo(EventInfo)\nbool IsNullable(EventInfo)\n```\n\n----------------------------------------\n\nTITLE: Decimal TryFormat Extension Methods\nDESCRIPTION: Extension methods that add TryFormat functionality to decimal type, allowing formatting of decimal values into both byte and character spans with custom formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(decimal, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(decimal, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: KeyValuePair Deconstruction Method\nDESCRIPTION: Deconstruction method for KeyValuePair<TKey, TValue> that enables tuple-like unpacking of key-value pairs. This enables more concise syntax when working with dictionary entries.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_29\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Deconstruct<TKey, TValue>(KeyValuePair<TKey, TValue>, TKey, TValue)\n```\n\n----------------------------------------\n\nTITLE: Implementing ParameterInfo Extensions in C#\nDESCRIPTION: Provides extension methods for ParameterInfo including GetNullability, GetNullabilityInfo, and IsNullable.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_33\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityState GetNullability(ParameterInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(ParameterInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsNullable(ParameterInfo)\n```\n\n----------------------------------------\n\nTITLE: UShortPolyfill TryParse Methods\nDESCRIPTION: Collection of TryParse method signatures for parsing unsigned short integers from various input formats with optional format providers and number styles.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_73\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryParse(ReadOnlySpan<byte>, IFormatProvider?, ushort)\nbool TryParse(ReadOnlySpan<byte>, NumberStyles, IFormatProvider?, ushort)\nbool TryParse(ReadOnlySpan<byte>, ushort)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, ushort)\nbool TryParse(ReadOnlySpan<char>, NumberStyles, IFormatProvider?, ushort)\nbool TryParse(ReadOnlySpan<char>, ushort)\nbool TryParse(string?, IFormatProvider?, ushort)\n```\n\n----------------------------------------\n\nTITLE: Using NullabilityInfoContext to Inspect Nullable Reference Types\nDESCRIPTION: Example test method demonstrating how to use NullabilityInfoContext to inspect nullable reference types, checking the nullability state of fields, array elements, and generic type arguments.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_69\n\nLANGUAGE: csharp\nCODE:\n```\n[Test]\npublic void Test()\n{\n    var type = typeof(NullabilityTarget);\n    var arrayField = type.GetField(\"ArrayField\")!;\n    var genericField = type.GetField(\"GenericField\")!;\n\n    var context = new NullabilityInfoContext();\n\n    var arrayInfo = context.Create(arrayField);\n\n    Assert.AreEqual(NullabilityState.NotNull, arrayInfo.ReadState);\n    Assert.AreEqual(NullabilityState.Nullable, arrayInfo.ElementType!.ReadState);\n\n    var genericInfo = context.Create(genericField);\n\n    Assert.AreEqual(NullabilityState.NotNull, genericInfo.ReadState);\n    Assert.AreEqual(NullabilityState.NotNull, genericInfo.GenericTypeArguments[0].ReadState);\n    Assert.AreEqual(NullabilityState.Nullable, genericInfo.GenericTypeArguments[1].ReadState);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing OrderedDictionary Extensions in C#\nDESCRIPTION: Provides TryAdd and TryGetValue implementations for OrderedDictionary, allowing conditional addition and retrieval of key-value pairs.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_32\n\nLANGUAGE: C#\nCODE:\n```\nbool TryAdd<TKey, TValue>(OrderedDictionary<TKey, TValue>, TKey, TValue, int) where TKey : notnull\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryGetValue<TKey, TValue>(OrderedDictionary<TKey, TValue>, TKey, TValue, int) where TKey : notnull\n```\n\n----------------------------------------\n\nTITLE: short TryFormat Methods\nDESCRIPTION: Method signatures for TryFormat operations that format short (Int16) values into Span<byte> or Span<char> with formatting options.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_44\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(short, Span<byte>, int, ReadOnlySpan<char>, IFormatProvider?)\nbool TryFormat(short, Span<char>, int, ReadOnlySpan<char>, IFormatProvider?)\n```\n\n----------------------------------------\n\nTITLE: Using Required Members and SetsRequiredMembers Attribute in C#\nDESCRIPTION: Example of using the required modifier and SetsRequiredMembersAttribute in a C# class to enforce initialization of required members.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_7\n\nLANGUAGE: csharp\nCODE:\n```\npublic class Person\n{\n    public Person()\n    {\n    }\n\n    [SetsRequiredMembers]\n    public Person(string name) =>\n        Name = name;\n\n    public required string Name { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing AsReadOnly for ISet in C#\nDESCRIPTION: Provides an AsReadOnly implementation for ISet, allowing conversion to a read-only set.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_26\n\nLANGUAGE: C#\nCODE:\n```\nReadOnlySet<T> AsReadOnly<T>(ISet<T>)\n```\n\n----------------------------------------\n\nTITLE: Implementing Queue Extensions in C#\nDESCRIPTION: Provides EnsureCapacity and TrimExcess implementations for Queue<T>, allowing capacity management.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_36\n\nLANGUAGE: C#\nCODE:\n```\nvoid EnsureCapacity<T>(Queue<T>, int)\n```\n\nLANGUAGE: C#\nCODE:\n```\nvoid TrimExcess<T>(Queue<T>, int)\n```\n\n----------------------------------------\n\nTITLE: CancellationToken Register Extension Methods\nDESCRIPTION: Extension methods that add registration functionality to CancellationToken, allowing registration of callbacks that receive both object state and cancellation token.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nCancellationTokenRegistration Register(CancellationToken, Action<object?, CancellationToken>, object?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nCancellationTokenRegistration UnsafeRegister(CancellationToken, Action<object?>, object?)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nCancellationTokenRegistration UnsafeRegister(CancellationToken, Action<object?, CancellationToken>, object?)\n```\n\n----------------------------------------\n\nTITLE: SortedList<TKey, TValue> Index Access Methods\nDESCRIPTION: Method signatures for accessing key and value by index in a SortedList<TKey, TValue>, providing positional access to sorted collections.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_45\n\nLANGUAGE: csharp\nCODE:\n```\nTKey GetKeyAtIndex<TKey, TValue>(SortedList<TKey, TValue>, int)\nTValue GetValueAtIndex<TKey, TValue>(SortedList<TKey, TValue>, int)\n```\n\n----------------------------------------\n\nTITLE: Guid TryFormat Method Signatures in C#\nDESCRIPTION: Method signatures for formatting GUIDs into byte and character spans with format specifiers. These methods enable efficient string representation of GUIDs without memory allocations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_20\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(Guid, Span<byte>, int, ReadOnlySpan<char>)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool TryFormat(Guid, Span<char>, int, ReadOnlySpan<char>)\n```\n\n----------------------------------------\n\nTITLE: FieldInfo Nullability Extension Methods\nDESCRIPTION: Extension methods that add nullability information functionality to FieldInfo, enabling runtime nullability analysis of field declarations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_18\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityState GetNullability(FieldInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(FieldInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNullable(FieldInfo)\n```\n\n----------------------------------------\n\nTITLE: DictionaryEntry Deconstruct Extension Method\nDESCRIPTION: Extension method that adds deconstruction capability to DictionaryEntry, enabling tuple-like unpacking of key-value pairs.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_14\n\nLANGUAGE: csharp\nCODE:\n```\nvoid Deconstruct(DictionaryEntry, object, object?)\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies for Span APIs in Legacy Frameworks\nDESCRIPTION: XML configuration for including System.Memory NuGet package when targeting .NET Standard, .NET Framework, or .NET Core 2.x, required for using Span-related polyfills.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_65\n\nLANGUAGE: xml\nCODE:\n```\n<PackageReference Include=\"System.Memory\"\n                  Version=\"4.5.5\"\n                  Condition=\"$(TargetFrameworkIdentifier) == '.NETStandard' or\n                             $(TargetFrameworkIdentifier) == '.NETFramework' or\n                             $(TargetFramework.StartsWith('netcoreapp2'))\" />\n```\n\n----------------------------------------\n\nTITLE: Boolean TryFormat Extension Method\nDESCRIPTION: Extension method that adds TryFormat functionality to the bool type, allowing formatting boolean values into character spans with count tracking.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nbool TryFormat(bool, Span<char>, int)\n```\n\n----------------------------------------\n\nTITLE: Queue<T> Capacity Management Methods\nDESCRIPTION: Methods for managing the capacity of Queue<T> instances. These methods provide fine-grained control over memory usage for queue collections.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_38\n\nLANGUAGE: csharp\nCODE:\n```\nvoid EnsureCapacity<T>(Queue<T>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid TrimExcess<T>(Queue<T>, int)\n```\n\n----------------------------------------\n\nTITLE: Implementing WaitForExitAsync for Process in C#\nDESCRIPTION: Provides an asynchronous WaitForExitAsync method for Process, allowing waiting for process exit with cancellation support.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_34\n\nLANGUAGE: C#\nCODE:\n```\nTask WaitForExitAsync(Process, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: EventInfo Nullability Extension Methods\nDESCRIPTION: Extension methods that add nullability information functionality to EventInfo, enabling runtime nullability analysis of event declarations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_17\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityState GetNullability(EventInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(EventInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNullable(EventInfo)\n```\n\n----------------------------------------\n\nTITLE: Using ModuleInitializerAttribute in C#\nDESCRIPTION: Example of using the ModuleInitializerAttribute to initialize a static field before any other code in the module runs.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\nstatic bool InitCalled;\n\n[Test]\npublic void ModuleInitTest() =>\n    Assert.True(InitCalled);\n\n[ModuleInitializer]\npublic static void ModuleInit() =>\n    InitCalled = true;\n```\n\n----------------------------------------\n\nTITLE: Extending TextReader with Asynchronous Reading Methods in C#\nDESCRIPTION: This snippet provides extension methods for TextReader, adding asynchronous reading capabilities with support for cancellation tokens. These methods enhance the flexibility of reading operations in asynchronous scenarios.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nValueTask<int> ReadAsync(TextReader, Memory<char>, CancellationToken)\nTask<string> ReadLineAsync(TextReader, CancellationToken)\nTask<string> ReadToEndAsync(TextReader, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Implementing PropertyInfo Extensions in C#\nDESCRIPTION: Provides extension methods for PropertyInfo including GetNullability, GetNullabilityInfo, and IsNullable.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_35\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityState GetNullability(PropertyInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(PropertyInfo)\n```\n\nLANGUAGE: C#\nCODE:\n```\nbool IsNullable(PropertyInfo)\n```\n\n----------------------------------------\n\nTITLE: Using SkipLocalsInit Attribute in C#\nDESCRIPTION: Example of using the SkipLocalsInit attribute to prevent the compiler from initializing local variables, potentially improving performance in specific scenarios.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_8\n\nLANGUAGE: csharp\nCODE:\n```\nclass SkipLocalsInitSample\n{\n    [SkipLocalsInit]\n    static void ReadUninitializedMemory()\n    {\n        Span<int> numbers = stackalloc int[120];\n        for (var i = 0; i < 120; i++)\n        {\n            Console.WriteLine(numbers[i]);\n        }\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Polyfill Extensions for TextWriter Class in C#\nDESCRIPTION: This code snippet defines extension methods for the TextWriter class that provide compatibility for methods missing in older .NET frameworks. It includes implementations for FlushAsync with cancellation, Write/WriteAsync with StringBuilder, and various ReadOnlyMemory/ReadOnlySpan extensions that were added in newer .NET versions.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_5\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated />\n#pragma warning disable\n\nnamespace Polyfills;\n\nusing System;\nusing System.Text;\nusing System.IO;\nusing System.Runtime.InteropServices;\nusing System.Threading;\nusing System.Threading.Tasks;\n#if FeatureMemory\nusing System.Buffers;\n#endif\n\nstatic partial class Polyfill\n{\n#if !NET8_0_OR_GREATER\n\n    //https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/IO/TextWriter.cs#L670\n\n    /// <summary>\n    /// Asynchronously clears all buffers for the current writer and causes any buffered data to\n    /// be written to the underlying device.\n    /// </summary>\n    /// <param name=\"cancellationToken\">The <see cref=\"CancellationToken\"/> to monitor for cancellation requests.</param>\n    /// <returns>A <see cref=\"Task\"/> that represents the asynchronous flush operation.</returns>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.flushasync#system-io-textwriter-flushasync(system-threading-cancellationtoken)\n    public static Task FlushAsync(this TextWriter target, CancellationToken cancellationToken)\n    {\n        if (cancellationToken.IsCancellationRequested)\n        {\n            return Task.FromCanceled(cancellationToken);\n        }\n\n        return target.FlushAsync()\n            .WaitAsync(cancellationToken);\n    }\n\n#endif\n\n#if !NETCOREAPP3_0_OR_GREATER\n    /// <summary>\n    /// Equivalent to Write(stringBuilder.ToString()) however it uses the\n    /// StringBuilder.GetChunks() method to avoid creating the intermediate string\n    /// </summary>\n    /// <param name=\"value\">The string (as a StringBuilder) to write to the stream</param>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.write#system-io-textwriter-write(system-text-stringbuilder)\n    public static void Write(this TextWriter target, StringBuilder? value)\n    {\n        if (value == null)\n        {\n            return;\n        }\n\n#if FeatureMemory\n        foreach (ReadOnlyMemory<char> chunk in value.GetChunks())\n        {\n            target.Write(chunk.Span);\n        }\n#else\n        target.Write(value.ToString());\n#endif\n    }\n\n    /// <summary>\n    /// Equivalent to WriteAsync(stringBuilder.ToString()) however it uses the\n    /// StringBuilder.GetChunks() method to avoid creating the intermediate string\n    /// </summary>\n    /// <param name=\"value\">The string (as a StringBuilder) to write to the stream</param>\n    /// <param name=\"cancellationToken\">The token to monitor for cancellation requests.</param>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeasync#system-io-textwriter-writeasync(system-readonlymemory((system-char))-system-threading-cancellationtoken)\n    public static Task WriteAsync(this TextWriter target, StringBuilder? value, CancellationToken cancellationToken = default)\n    {\n        if (cancellationToken.IsCancellationRequested)\n        {\n            return Task.FromCanceled(cancellationToken);\n        }\n\n        if (value == null)\n        {\n            return Task.CompletedTask;\n        }\n\n        return WriteAsyncCore(value, cancellationToken);\n\n        async Task WriteAsyncCore(StringBuilder builder, CancellationToken cancel)\n        {\n#if FeatureValueTask && FeatureMemory\n            foreach (ReadOnlyMemory<char> chunk in builder.GetChunks())\n            {\n                await target.WriteAsync(chunk, cancel).ConfigureAwait(false);\n            }\n#else\n            await target.WriteAsync(builder.ToString())\n                .WaitAsync(cancellationToken);\n#endif\n        }\n    }\n#endif\n\n#if (NETFRAMEWORK || NETSTANDARD2_0 || NETCOREAPP2_0) && FeatureMemory\n#if FeatureValueTask\n\n    /// <summary>\n    /// Asynchronously writes a character memory region to the stream.\n    /// </summary>\n    /// <param name=\"buffer\">The character memory region to write to the stream.</param>\n    /// <param name=\"cancellationToken\">\n    /// The token to monitor for cancellation requests.\n    /// The default value is <see cref=\"CancellationToken.None\"/>.\n    /// </param>\n    /// <returns>A task that represents the asynchronous write operation.</returns>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeasync#system-io-textwriter-writeasync(system-readonlymemory((system-char))-system-threading-cancellationtoken)\n    public static ValueTask WriteAsync(\n        this TextWriter target,\n        ReadOnlyMemory<char> buffer,\n        CancellationToken cancellationToken = default)\n    {\n        // StreamReader doesn't accept cancellation token (pre-netstd2.1)\n        cancellationToken.ThrowIfCancellationRequested();\n\n        if (!MemoryMarshal.TryGetArray(buffer, out var segment))\n        {\n            segment = new(buffer.ToArray());\n        }\n\n        var task = target.WriteAsync(segment.Array!, segment.Offset, segment.Count)\n            .WaitAsync(cancellationToken);\n        return new(task);\n    }\n\n    /// <summary>\n    /// Asynchronously writes the text representation of a character memory region to the stream, followed by a line terminator.\n    /// </summary>\n    /// <param name=\"buffer\">The character memory region to write to the stream.</param>\n    /// <param name=\"cancellationToken\">\n    /// The token to monitor for cancellation requests.\n    /// The default value is <see cref=\"CancellationToken.None\"/>.\n    /// </param>\n    /// <returns>A task that represents the asynchronous write operation.</returns>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writelineasync#system-io-textwriter-writelineasync(system-readonlymemory((system-char))-system-threading-cancellationtoken)\n    public static ValueTask WriteLineAsync(\n        this TextWriter target,\n        ReadOnlyMemory<char> buffer,\n        CancellationToken cancellationToken = default)\n    {\n        // StreamReader doesn't accept cancellation token (pre-netstd2.1)\n        cancellationToken.ThrowIfCancellationRequested();\n\n        if (!MemoryMarshal.TryGetArray(buffer, out var segment))\n        {\n            segment = new(buffer.ToArray());\n        }\n\n        var task = target.WriteLineAsync(segment.Array!, segment.Offset, segment.Count)\n            .WaitAsync(cancellationToken);\n        return new(task);\n    }\n\n#endif\n\n    /// <summary>\n    /// Writes a character span to the text stream.\n    /// </summary>\n    /// <param name=\"buffer\">The character span to write.</param>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.write#system-io-textwriter-write(system-readonlyspan((system-char)))\n    public static void Write(\n        this TextWriter target,\n        ReadOnlySpan<char> buffer)\n    {\n        var pool = ArrayPool<char>.Shared;\n        var array = pool.Rent(buffer.Length);\n\n        try\n        {\n            buffer.CopyTo(new(array));\n            target.Write(array, 0, buffer.Length);\n        }\n        finally\n        {\n            pool.Return(array);\n        }\n    }\n\n    /// <summary>\n    /// Writes the text representation of a character span to the text stream, followed by a line terminator.\n    /// </summary>\n    /// <param name=\"buffer\">The char span value to write to the text stream.</param>\n    //Link: https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.writeline#system-io-textwriter-writeline(system-readonlyspan((system-char)))\n    public static void WriteLine(\n        this TextWriter target,\n        ReadOnlySpan<char> buffer)\n    {\n        var pool = ArrayPool<char>.Shared;\n        var array = pool.Rent(buffer.Length);\n\n        try\n        {\n            buffer.CopyTo(new(array));\n            target.WriteLine(array, 0, buffer.Length);\n        }\n        finally\n        {\n            pool.Return(array);\n        }\n    }\n#endif\n}\n```\n\n----------------------------------------\n\nTITLE: Dictionary Capacity Management Extension Methods\nDESCRIPTION: Extension methods that add capacity management functionality to Dictionary<TKey, TValue>, allowing control of internal storage allocation and optimization.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_13\n\nLANGUAGE: csharp\nCODE:\n```\nvoid EnsureCapacity<TKey, TValue>(Dictionary<TKey, TValue>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid TrimExcess<TKey, TValue>(Dictionary<TKey, TValue>, int)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nvoid TrimExcess<TKey, TValue>(Dictionary<TKey, TValue>)\n```\n\n----------------------------------------\n\nTITLE: Delegate HasSingleTarget Extension Method\nDESCRIPTION: Extension method that adds HasSingleTarget functionality to Delegate, determining if a delegate has exactly one target method.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_12\n\nLANGUAGE: csharp\nCODE:\n```\nbool HasSingleTarget(Delegate)\n```\n\n----------------------------------------\n\nTITLE: Implementing UnscopedRef Attribute in C# Struct\nDESCRIPTION: This code snippet shows how to use the UnscopedRef attribute in a C# struct. It demonstrates the application of this attribute to a property that returns a reference to a field, which is part of the low-level struct improvements in C#.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_11\n\nLANGUAGE: csharp\nCODE:\n```\nstruct UnscopedRefUsage\n{\n    int field1;\n\n    [UnscopedRef] ref int Prop1 => ref field1;\n}\n```\n\n----------------------------------------\n\nTITLE: Span<T> Contains Extension Method in C#\nDESCRIPTION: Extension method for checking if a Span<T> contains a specific value of type T. This method requires T to implement IEquatable<T> for value comparison.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_45\n\nLANGUAGE: C#\nCODE:\n```\nbool Contains<T>(Span<T>, T) where T : IEquatable<T>\n```\n\n----------------------------------------\n\nTITLE: KeyValuePair Creation Method\nDESCRIPTION: Static creation method for KeyValuePair<TKey, TValue> instances.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_76\n\nLANGUAGE: csharp\nCODE:\n```\nKeyValuePair<TKey, TValue> Create<TKey, TValue>(TKey, TValue)\n```\n\n----------------------------------------\n\nTITLE: Parsing DateTimeOffset in C#\nDESCRIPTION: Polyfill methods for parsing DateTimeOffset values from various string representations. These methods provide additional parsing options and flexibility compared to built-in methods.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_56\n\nLANGUAGE: C#\nCODE:\n```\nbool TryParse(ReadOnlySpan<char>, DateTimeOffset)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeOffset)\nbool TryParse(ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTimeOffset)\nbool TryParse(string?, IFormatProvider?, DateTimeOffset)\nbool TryParseExact(ReadOnlySpan<char>, ReadOnlySpan<char>, IFormatProvider?, DateTimeStyles, DateTimeOffset)\nbool TryParseExact(ReadOnlySpan<char>, string, IFormatProvider?, DateTimeStyles, DateTimeOffset)\n```\n\n----------------------------------------\n\nTITLE: PropertyInfo Nullability Methods\nDESCRIPTION: Extension methods for PropertyInfo that provide nullability information for properties. These methods assist with reflection scenarios involving nullable reference types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_37\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityState GetNullability(PropertyInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nNullabilityInfo GetNullabilityInfo(PropertyInfo)\n```\n\nLANGUAGE: csharp\nCODE:\n```\nbool IsNullable(PropertyInfo)\n```\n\n----------------------------------------\n\nTITLE: Enabling NullabilityInfoExtensions via MSBuild Properties\nDESCRIPTION: XML configuration for enabling the PolyNullability feature through MSBuild properties, which provides NullabilityInfoExtensions for working with nullable reference types.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_70\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n  ...\n  <PolyNullability>true</PolyNullability>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: Delegate EnumerateInvocationList Polyfill Method\nDESCRIPTION: Polyfill implementation of EnumerateInvocationList method for Delegate. This method returns an enumerator for the invocation list of a delegate.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_55\n\nLANGUAGE: C#\nCODE:\n```\nInvocationListEnumerator<TDelegate> EnumerateInvocationList<TDelegate>(TDelegate?) where TDelegate : Delegate\n```\n\n----------------------------------------\n\nTITLE: Using init Accessor in C# Property\nDESCRIPTION: Example of using the init accessor in a C# property, which allows the property to be set only during object initialization.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_6\n\nLANGUAGE: csharp\nCODE:\n```\nclass InitSample\n{\n    public int Member { get; init; }\n}\n```\n\n----------------------------------------\n\nTITLE: Using OverloadResolutionPriority Attribute in C#\nDESCRIPTION: This snippet demonstrates the usage of the OverloadResolutionPriority attribute in C#. It shows how to prioritize method overloads using this attribute, which can help guide API usage and resolve ambiguities in overload resolution.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_10\n\nLANGUAGE: csharp\nCODE:\n```\n[TestFixture]\npublic class OverloadResolutionPriorityAttributeTests\n{\n    [Test]\n    public void Run()\n    {\n        int[] arr = [1, 2, 3];\n        //Prints \"Span\" because resolution priority is higher\n        Method(arr);\n    }\n\n    [OverloadResolutionPriority(2)]\n    static void Method(ReadOnlySpan<int> list) =>\n        Console.WriteLine(\"Span\");\n\n    [OverloadResolutionPriority(1)]\n    static void Method(int[] list) =>\n        Console.WriteLine(\"Array\");\n}\n```\n\n----------------------------------------\n\nTITLE: CancellationTokenSource CancelAsync Extension Method\nDESCRIPTION: Extension method that adds async cancellation functionality to CancellationTokenSource, allowing asynchronous cancellation operations.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nTask CancelAsync(CancellationTokenSource)\n```\n\n----------------------------------------\n\nTITLE: HttpContent Async Method Signatures with CancellationToken in C#\nDESCRIPTION: Method signatures for HttpContent asynchronous operations that accept CancellationToken. These methods provide cancellable versions of content reading operations for byte arrays, streams, and strings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_23\n\nLANGUAGE: C#\nCODE:\n```\nTask<byte[]> ReadAsByteArrayAsync(HttpContent, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<Stream> ReadAsStreamAsync(HttpContent, CancellationToken)\n```\n\nLANGUAGE: C#\nCODE:\n```\nTask<string> ReadAsStringAsync(HttpContent, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: ModuleInitializerAttribute Implementation\nDESCRIPTION: Complete implementation of ModuleInitializerAttribute including conditional compilation, XML documentation, and type forwarding for .NET 5+\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_4\n\nLANGUAGE: csharp\nCODE:\n```\n// <auto-generated />\n#pragma warning disable\n\n#if !NET5_0_OR_GREATER\n\nnamespace System.Runtime.CompilerServices;\n\nusing System.Diagnostics;\nusing System.Diagnostics.CodeAnalysis;\n\n/// <summary>\n/// Used to indicate to the compiler that a method should be called\n/// in its containing module's initializer.\n/// </summary>\n//Link: https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.moduleinitializerattribute\n[ExcludeFromCodeCoverage]\n[DebuggerNonUserCode]\n[AttributeUsage(\n    validOn: AttributeTargets.Method,\n    Inherited = false)]\n#if PolyPublic\npublic\n#endif\nsealed class ModuleInitializerAttribute :\n    Attribute;\n#else\nusing System.Runtime.CompilerServices;\n[assembly: TypeForwardedTo(typeof(System.Runtime.CompilerServices.ModuleInitializerAttribute))]\n#endif\n```\n\n----------------------------------------\n\nTITLE: Implementing StringBuilder.Append for ReadOnlySpan<char> in .NET Core 2\nDESCRIPTION: A polyfill implementation of StringBuilder.Append for ReadOnlySpan<char> in .NET Core 2. This implementation may not be as performant as the actual implementation in newer runtimes due to string allocation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\npublic StringBuilder Append(ReadOnlySpan<char> value)\n    => target.Append(value.ToString());\n```\n\n----------------------------------------\n\nTITLE: HttpContent Reading Methods with Cancellation in C#\nDESCRIPTION: Extension methods for HttpContent that support cancellation tokens for content reading operations. These methods allow reading HTTP content as byte arrays, streams, or strings with the ability to cancel the operation.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_19\n\nLANGUAGE: C#\nCODE:\n```\nTask<byte[]> ReadAsByteArrayAsync(HttpContent, CancellationToken)\nTask<Stream> ReadAsStreamAsync(HttpContent, CancellationToken)\nTask<string> ReadAsStringAsync(HttpContent, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies for RuntimeInformation APIs in .NET Framework\nDESCRIPTION: XML configuration for including System.Runtime.InteropServices.RuntimeInformation NuGet package when targeting .NET Framework, required for using RuntimeInformation class and OSPlatform struct.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_67\n\nLANGUAGE: xml\nCODE:\n```\n<PackageReference Include=\"System.Runtime.InteropServices.RuntimeInformation\"\n                  Version=\"4.3.0\"\n                  Condition=\"$(TargetFrameworkIdentifier) == '.NETFramework'\" />\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies for ValueTuple Support in .NET Framework\nDESCRIPTION: XML configuration for including System.ValueTuple NuGet package when targeting .NET Framework 4.6.1 or 4.6.2, required for using ValueTuple polyfills.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_64\n\nLANGUAGE: xml\nCODE:\n```\n<PackageReference Include=\"System.ValueTuple\"\n                  Version=\"4.5.0\"\n                  Condition=\"$(TargetFramework.StartsWith('net46'))\" />\n```\n\n----------------------------------------\n\nTITLE: Process Asynchronous Exit Method\nDESCRIPTION: Asynchronous method for waiting for a process to exit with cancellation support. This method enables better integration with async/await patterns when dealing with external processes.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/api_list.include.md#2025-04-22_snippet_36\n\nLANGUAGE: csharp\nCODE:\n```\nTask WaitForExitAsync(Process, CancellationToken)\n```\n\n----------------------------------------\n\nTITLE: Configuring C# Language Features and Formatting\nDESCRIPTION: Sets up preferences for C# language features, expression-bodied members, and code formatting.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_4\n\nLANGUAGE: EditorConfig\nCODE:\n```\n# Prefer \"var\" everywhere\ncsharp_style_var_for_built_in_types = true:error\ncsharp_style_var_when_type_is_apparent = true:error\ncsharp_style_var_elsewhere = true:error\n\n# Prefer method-like constructs to have a block body\ncsharp_style_expression_bodied_methods = true:error\ncsharp_style_expression_bodied_local_functions = true:error\ncsharp_style_expression_bodied_constructors = true:error\ncsharp_style_expression_bodied_operators = true:error\nresharper_place_expr_method_on_single_line = false\n\n# ... (more C# settings)\n```\n\n----------------------------------------\n\nTITLE: Setting Conditional Constants in Project File\nDESCRIPTION: XML configuration to set conditional constants in a project file, allowing for indirect definition of constants.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_4\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <DefineConstants Condition=\"'$(MyConstant)' == 'true'\">$(DefineConstants);MY_CONSTANT</DefineConstants>\n```\n\n----------------------------------------\n\nTITLE: Conditional Compilation Example - .NET Framework Check\nDESCRIPTION: Example showing conditional compilation directive for .NET Framework, .NET Standard or .NET Core 2.x targets\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n#if NETFRAMEWORK || NETSTANDARD || NETCOREAPP2X\n```\n\n----------------------------------------\n\nTITLE: Implementing UnionBy LINQ Extension Method in C#\nDESCRIPTION: The UnionBy extension method returns the combined set of elements from both collections, eliminating duplicates based on a key. It uses a key selector function to extract the key for comparison. Two overloads are provided, with the second allowing a custom equality comparer.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/notes.txt#2025-04-22_snippet_1\n\nLANGUAGE: C#\nCODE:\n```\npublic static IEnumerable<TSource> UnionBy<TSource, TKey>(this IEnumerable<TSource> first, IEnumerable<TSource> second, Func<TSource, TKey> keySelector);\npublic static IEnumerable<TSource> UnionBy<TSource, TKey>(this IEnumerable<TSource> first, IEnumerable<TSource> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);\n```\n\n----------------------------------------\n\nTITLE: Configuring C# Naming Conventions and Code Style\nDESCRIPTION: Sets up naming conventions for various C# elements and defines code style preferences for C# files.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_2\n\nLANGUAGE: EditorConfig\nCODE:\n```\n# Microsoft .NET properties\ntrim_trailing_whitespace = true\ncsharp_preferred_modifier_order = public, private, protected, internal, new, static, abstract, virtual, sealed, readonly, override, extern, unsafe, volatile, async:suggestion\nresharper_namespace_body = file_scoped\ndotnet_naming_rule.private_constants_rule.severity = warning\ndotnet_naming_rule.private_constants_rule.style = upper_camel_case_style\ndotnet_naming_rule.private_constants_rule.symbols = private_constants_symbols\n# ... (more naming rules)\ndotnet_style_parentheses_in_arithmetic_binary_operators = never_if_unnecessary:none\ndotnet_style_parentheses_in_other_binary_operators = always_for_clarity:none\ndotnet_style_parentheses_in_relational_binary_operators = never_if_unnecessary:none\n```\n\n----------------------------------------\n\nTITLE: Setting LangVersion in Project File\nDESCRIPTION: XML configuration to set the C# language version to the latest stable version in a project file.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_1\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <LangVersion>latest</LangVersion>\n```\n\n----------------------------------------\n\nTITLE: Implementing IntersectBy LINQ Extension Method in C#\nDESCRIPTION: The IntersectBy extension method returns elements from the first collection that have matching keys in the second collection. It takes a key selector function to extract the key for comparison. Two overloads are provided, with the second allowing a custom equality comparer.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/notes.txt#2025-04-22_snippet_0\n\nLANGUAGE: C#\nCODE:\n```\npublic static IEnumerable<TSource> IntersectBy<TSource, TKey>(this IEnumerable<TSource> first, IEnumerable<TKey> second, Func<TSource, TKey> keySelector);\npublic static IEnumerable<TSource> IntersectBy<TSource, TKey>(this IEnumerable<TSource> first, IEnumerable<TKey> second, Func<TSource, TKey> keySelector, IEqualityComparer<TKey> comparer);\n```\n\n----------------------------------------\n\nTITLE: Configuring XML and JSON File Settings\nDESCRIPTION: Defines specific settings for XML, config, and JSON files, including indent size and ReSharper XML settings.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_5\n\nLANGUAGE: EditorConfig\nCODE:\n```\n# Xml files\n[*.{xml,config,nuspec,resx,vsixmanifest,csproj,targets,props}]\nindent_size = 2\n# https://www.jetbrains.com/help/resharper/EditorConfig_XML_XmlCodeStylePageSchema.html#resharper_xml_blank_line_after_pi\nresharper_blank_line_after_pi = false\nresharper_space_before_self_closing = true\n\n[*.json]\nindent_size = 2\n```\n\n----------------------------------------\n\nTITLE: Configuring ReSharper Settings\nDESCRIPTION: Defines ReSharper-specific settings for code style and inspection severities.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_3\n\nLANGUAGE: EditorConfig\nCODE:\n```\n# ReSharper properties\nresharper_object_creation_when_type_not_evident = target_typed\n\n# ReSharper inspection severities\nresharper_arrange_object_creation_when_type_evident_highlighting = error\nresharper_arrange_object_creation_when_type_not_evident_highlighting = error\n# ... (more ReSharper settings)\n```\n\n----------------------------------------\n\nTITLE: Enabling PolyGuard with MSBuild Property\nDESCRIPTION: Shows how to enable the PolyGuard functionality by adding an MSBuild property to a project file. This is the required configuration to use the guard features in the project.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_71\n\nLANGUAGE: xml\nCODE:\n```\n<PropertyGroup>\n  ...\n  <PolyGuard>true</PolyGuard>\n</PropertyGroup>\n```\n\n----------------------------------------\n\nTITLE: ReSharper Directive Example\nDESCRIPTION: Example showing how to disable ReSharper/Rider code formatting issues\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\n// ReSharper disable RedundantUsingDirective\n// ReSharper disable UnusedMember.Global\n```\n\n----------------------------------------\n\nTITLE: Warning Suppression Pragma Example\nDESCRIPTION: Example showing how to disable compiler warnings using pragma directive\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\n#pragma warning disable\n```\n\n----------------------------------------\n\nTITLE: Managing Dependencies for ValueTask APIs in Legacy Frameworks\nDESCRIPTION: XML configuration for including System.Threading.Tasks.Extensions NuGet package when targeting .NET Framework, .NET Standard 2.0, or .NET Core 2.0, required for using ValueTask-related polyfills.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_66\n\nLANGUAGE: xml\nCODE:\n```\n<PackageReference Include=\"System.Threading.Tasks.Extensions\"\n                  Version=\"4.5.4\"\n                  Condition=\"$(TargetFramework) == 'netstandard2.0' or\n                             $(TargetFramework) == 'netcoreapp2.0' or\n                             $(TargetFrameworkIdentifier) == '.NETFramework'\" />\n```\n\n----------------------------------------\n\nTITLE: Configuring SDK Version in global.json\nDESCRIPTION: JSON configuration to set the SDK version and roll-forward policy in the global.json file.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"sdk\": {\n    \"version\": \"9.0.202\",\n    \"rollForward\": \"latestFeature\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Enabling Public Visibility for Polyfill Types\nDESCRIPTION: XML configuration to enable public visibility for Polyfill types in a project file using the PolyPublic property.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/readme.md#2025-04-22_snippet_3\n\nLANGUAGE: xml\nCODE:\n```\n<Project Sdk=\"Microsoft.NET.Sdk\">\n  <PropertyGroup>\n    <PolyPublic>true</PolyPublic>\n```\n\n----------------------------------------\n\nTITLE: Public API Conditional Example\nDESCRIPTION: Example showing how to conditionally make types public based on PolyPublic flag\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/contributing.md#2025-04-22_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\n#if PolyPublic\npublic\n#endif\nsealed class ...\n```\n\n----------------------------------------\n\nTITLE: Configuring EditorConfig Root and General Settings\nDESCRIPTION: Sets up the root EditorConfig file and defines general settings for all files, including indent style.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_0\n\nLANGUAGE: EditorConfig\nCODE:\n```\nroot = true\n# EditorConfig: http://EditorConfig.org\n\n# top-most EditorConfig file\n\n[*]\nindent_style = space\n```\n\n----------------------------------------\n\nTITLE: Configuring C# File Settings\nDESCRIPTION: Defines specific settings for C# files, including indent size and character encoding.\nSOURCE: https://github.com/simoncropp/polyfill/blob/main/src/editorconfig.txt#2025-04-22_snippet_1\n\nLANGUAGE: EditorConfig\nCODE:\n```\n[*.cs]\nindent_size = 4\ncharset = utf-8\n```"
  }
]