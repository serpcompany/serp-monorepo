[
  {
    "owner": "pennylaneai",
    "repo": "pennylane",
    "content": "TITLE: Using jax.jit on QNodes\nDESCRIPTION: This example illustrates how to use ``jax.jit`` to just-in-time compile a PennyLane QNode, potentially improving performance. The ``@jax.jit`` decorator is applied directly above the ``@qml.qnode`` decorator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@jax.jit  # QNode calls will now be jitted, and should run faster.\n@qml.qnode(dev, interface='jax')\ndef circuit4(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RZ(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Importing Qiskit QuantumCircuit into PennyLane QNode\nDESCRIPTION: This example demonstrates how to load a Qiskit QuantumCircuit into a PennyLane QNode. It defines a Qiskit circuit with a symbolic parameter, then uses qml.from_qiskit() to convert it into a PennyLane template inside a QNode. The template is executed with a specified angle, and the expectation value of PauliZ is returned.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit import QuantumCircuit\nfrom qiskit.circuit import Parameter\nimport numpy as np\n\ndev = qml.device('default.qubit', wires=2)\n\ntheta = Parameter('θ')\n\nqc = QuantumCircuit(2)\nqc.rz(theta, [0])\nqc.rx(theta, [0])\nqc.cx(0, 1)\n\n@qml.qnode(dev)\ndef quantum_circuit_with_loaded_subcircuit(x):\n    qml.from_qiskit(qc)({theta: x})\n    return qml.expval(qml.PauliZ(0))\n\nangle = np.pi/2\nresult = quantum_circuit_with_loaded_subcircuit(angle)\n```\n\n----------------------------------------\n\nTITLE: Defining a QNode with a Decorator in PennyLane\nDESCRIPTION: This snippet defines a quantum circuit using the @qml.qnode decorator. It creates a QNode that executes on a specified device and defines a quantum circuit that includes parameterized gates and an expectation value measurement. The 'default.qubit' device is used with 2 wires. It takes a single parameter 'x', applies RZ, CNOT and RY gates, and returns the expectation value of PauliZ on wire 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0,1])\n    qml.RY(x, wires=1)\n    return qml.expval(qml.PauliZ(1))\n\nresult = circuit(0.543)\n```\n\n----------------------------------------\n\nTITLE: Differentiable Quantum Circuits with Program Capture in PennyLane\nDESCRIPTION: This code snippet demonstrates how to define and differentiate a quantum circuit on `default.qubit` with `diff_method=\"adjoint\"` when program capture is enabled. The `qml.capture.enable()` function activates the program capture feature, allowing for differentiation using various methods like 'finite-diff', 'adjoint', and 'backprop'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nqml.capture.enable()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=3), diff_method=\"adjoint\")\ndef f(phi):\n    qml.RX(phi, 0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Using Dataset in PennyLane Circuit\nDESCRIPTION: This code demonstrates how to use a loaded dataset (H2data) within a PennyLane quantum circuit. It uses the 'hf_state', 'vqe_gates', and 'hamiltonian' attributes of the dataset.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\",wires=4)\n@qml.qnode(dev)\ndef circuit():\n    qml.BasisState(H2data.hf_state, wires = [0, 1, 2, 3])\n    for op in H2data.vqe_gates:\n        qml.apply(op)\n    return qml.expval(H2data.hamiltonian)\nprint(circuit())\n```\n\n----------------------------------------\n\nTITLE: Backpropagation with shots=None in PennyLane\nDESCRIPTION: This code demonstrates the correct usage of backpropagation with shots=None. It defines a quantum circuit and calculates its gradient using qml.grad, showcasing that when the configuration is valid, the backpropagation proceeds successfully and provides the expected gradient.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef print_grad():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.expval(qml.Z(wires=0))\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit Definition with Custom Operation in PennyLane\nDESCRIPTION: This code defines a quantum circuit using PennyLane, which includes a custom operation `FlipAndRotate`. It demonstrates how PennyLane handles custom operations, using the `DefaultQubit` device. The circuit calculates the expectation value of PauliZ on qubit 'q1' after applying the custom operation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=[\"q1\", \"q2\", \"q3\"])\n\n@qml.qnode(dev)\ndef circuit(angle):\n    FlipAndRotate(angle, wire_rot=\"q1\", wire_flip=\"q1\")\n    return qml.expval(qml.PauliZ(\"q1\"))\n\n>>> a = np.array(3.14)\n>>> circuit(a)\n-0.9999987318946099\n\n>>> qml.grad(circuit)(a)\n-0.0015926529164868282\n```\n\n----------------------------------------\n\nTITLE: Executing QNodes with Postselection (pycon)\nDESCRIPTION: This code shows the output when executing the QNodes configured with different postselection modes. The `fill_shots` QNode returns an array with the specified number of shots, while the `hw_like` QNode may return an array with fewer shots if invalid samples are discarded.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> fill_shots()\narray([-1., -1., -1., -1., -1., -1., -1., -1., -1., -1.])\n>>> hw_like()\narray([-1., -1., -1., -1., -1., -1., -1.])\n```\n\n----------------------------------------\n\nTITLE: Collecting Statistics for Sequences of Mid-Circuit Measurements in PennyLane (Python)\nDESCRIPTION: This code snippet demonstrates collecting statistics for a sequence of mid-circuit measurements using `qml.sample`. It defines a quantum circuit that applies RX and RY rotations, measures both qubits, and returns samples from both measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit(phi, theta):\n    qml.RX(phi, wires=0)\n    m_0 = qml.measure(wires=0)\n    qml.RY(theta, wires=1)\n    m_1 = qml.measure(wires=1)\n    return qml.sample([m_0, m_1])\n```\n\n----------------------------------------\n\nTITLE: Mid-Circuit Measurement with Conditional Operation in PennyLane (Python)\nDESCRIPTION: This code snippet demonstrates how to perform a mid-circuit measurement using `qml.measure` and how to use the measurement outcome to conditionally apply a quantum gate using `qml.cond`. It defines a quantum node that applies an RY gate, performs a CNOT gate, measures qubit 1, and then conditionally applies another RY gate based on the measurement outcome. The probabilities of qubit 0 and the expected value of the measurement are returned.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef my_qnode(x, y):\n    qml.RY(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    m_0 = qml.measure(1, reset=False, postselect=None)\n\n    qml.cond(m_0, qml.RY)(y, wires=0)\n    return qml.probs(wires=[0]), qml.expval(m_0)\n```\n\n----------------------------------------\n\nTITLE: Computing Higher-Order Derivatives with QNode Arguments\nDESCRIPTION: This code snippet demonstrates another way to compute higher-order derivatives (Hessian) in PennyLane by passing the `max_diff` and `diff_method` arguments to the QNode.  It showcases successive differentiation using `qml.jacobian` and setting `diff_method=\"parameter-shift\"` and `max_diff=2`. The example uses the `default.qubit` device and requires the `pennylane` and `numpy` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, diff_method=\"parameter-shift\", max_diff=2)\ndef circuit(weights):\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(weights[2], wires=1)\n    return qml.expval(qml.PauliZ(1))\n\nweights = np.array([0.1, 0.2, 0.3], requires_grad=True)\nqml.jacobian(qml.jacobian(circuit))(weights)  # hessian\n```\n\n----------------------------------------\n\nTITLE: Changing Number of Shots in PennyLane\nDESCRIPTION: This code demonstrates how to change the number of shots used for executing a QNode, both by modifying the device and using the `shots` keyword argument during function calls. This affects the accuracy of stochastic measurement results.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1, shots=10)\n\n@qml.qnode(dev)\ndef circuit(x, y):\n    qml.RX(x, wires=0)\n    qml.RY(y, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\n# execute the QNode using 10 shots\nresult = circuit(0.54, 0.1)\n\n# execute the QNode again, now using 1 shot\nresult = circuit(0.54, 0.1, shots=1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Quantum Function with PennyLane\nDESCRIPTION: This code defines a quantum function using PennyLane. It imports the pennylane library, defines a function named `my_quantum_function` which accepts two classical inputs x and y. Within the function, quantum operations `qml.RZ`, `qml.CNOT`, and `qml.RY` are applied to the specified wires. Finally, it returns the expectation value of the PauliZ observable on wire 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0,1])\n    qml.RY(y, wires=1)\n    return qml.expval(qml.Z(wires=1))\n```\n\n----------------------------------------\n\nTITLE: Defining a Quantum Circuit and Returning Expectation Values\nDESCRIPTION: This code defines a quantum circuit using PennyLane's `@qml.qnode` decorator, binding it to a device. The `circuit` function applies an `RX` gate on wire 0 and a `CNOT` gate between wires 0 and 1. It then returns the expectation values of `qml.PauliZ(0) @ qml.PauliX(1)` and `qml.PauliZ(0)`. The device is initialized with a list of shots [5, 10, 1000], enabling shot batching for a single execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliX(1)), qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Initializing a PennyLane Device\nDESCRIPTION: This code initializes a PennyLane device. It uses the `qml.device` function to create an instance of a quantum device. The device specified here is `default.qubit`, which is a built-in simulator. The `wires` argument specifies the number of qubits (wires) for the device, and the `shots` argument defines how many times the circuit will be evaluated for statistical quantities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2, shots=1000)\n```\n\n----------------------------------------\n\nTITLE: Calculating Quantum Gradients using JAX\nDESCRIPTION: This snippet showcases how to calculate gradients of a JAX-interfacing QNode using ``jax.grad``. It defines a quantum circuit and computes its gradient with respect to the input parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='jax')\ndef circuit3(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nphi = jnp.array([0.5, 0.1])\ntheta = jnp.array(0.2)\ngrads = jax.grad(circuit3, argnums=(0, 1))\nphi_grad, theta_grad = grads(phi, theta)\n```\n\n----------------------------------------\n\nTITLE: Creating a JAX-Compatible QNode with the Decorator\nDESCRIPTION: This example demonstrates creating a JAX-compatible QNode using the ``@qml.qnode`` decorator with the ``interface='jax'`` argument. The QNode accepts JAX arrays as input and returns JAX arrays.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='jax')\ndef circuit1(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n```\n\n----------------------------------------\n\nTITLE: Counts Measurement of Computational Basis States in PennyLane\nDESCRIPTION: This example shows how to use `qml.counts` without specifying an observable to obtain the counts of observed computational basis states. It returns a dictionary mapping bitstrings to their counts.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.counts()\n```\n\n----------------------------------------\n\nTITLE: Postselection on Mid-Circuit Measurements with PennyLane\nDESCRIPTION: This code demonstrates how to perform postselection on a mid-circuit measurement using PennyLane. The `qml.measure` function now accepts a `postselect` keyword argument, allowing the user to filter measurement outcomes based on specific basis states (0 or 1). In this example, the circuit prepares a Bell state and postselects on measuring |1⟩ in wire 0, ensuring the output of wire 1 is also |1⟩.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev, interface=None)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.measure(0, postselect=1)\n    return qml.expval(qml.PauliZ(1)), qml.sample(wires=1)\n```\n\n----------------------------------------\n\nTITLE: Optimization using TensorFlow Optimizers\nDESCRIPTION: This snippet illustrates how to optimize a TensorFlow-interfacing QNode using TensorFlow's optimizers (tf.keras.optimizers.SGD). It calculates the loss, computes gradients, and applies them using the optimizer.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='tf')\ndef circuit4(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nphi = tf.Variable([0.5, 0.1], dtype=tf.float64)\ntheta = tf.Variable(0.2, dtype=tf.float64)\n\nopt = tf.keras.optimizers.SGD(learning_rate=0.1)\nsteps = 200\n\nfor i in range(steps):\n    with tf.GradientTape() as tape:\n        loss = tf.abs(circuit4(phi, theta) - 0.5)**2\n\n    gradients = tape.gradient(loss, [phi, theta])\n    opt.apply_gradients(zip(gradients, [phi, theta]))\n```\n\n----------------------------------------\n\nTITLE: Evaluating Circuits and Gradients with lightning.qubit\nDESCRIPTION: This interactive console snippet showcases how to evaluate a quantum circuit defined using PennyLane and calculate its gradient using the lightning.qubit device. The device offers optimized performance due to its C++ backend integration.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(f\"Circuit evaluated: {circuit(weights)}\")\nCircuit evaluated: 0.9801286266677633\n>>> print(f\"Circuit gradient:\\n{qml.grad(circuit)(weights)}\")\nCircuit gradient:\n[[[-9.35301749e-17 -1.63051504e-01 -4.14810501e-04]\n  [-7.88816484e-17 -1.50136528e-04 -1.77922957e-04]\n  [-5.20670796e-17 -3.92874550e-02  8.14523075e-05]]\n\n [[-1.14472273e-04  3.85963953e-02 -9.39190132e-18]\n  [-5.76791765e-05 -9.78478343e-02  0.00000000e+00]\n  [ 0.00000000e+00  0.00000000e+00  0.00000000e+00]]]\n```\n\n----------------------------------------\n\nTITLE: Optimization with NumPy Interface\nDESCRIPTION: This code showcases how to optimize a hybrid classical-quantum model using PennyLane optimizers with the NumPy interface. It defines a QNode, a cost function, and then uses the GradientDescentOptimizer to update the circuit parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit4(x):\n    qml.RX(x[0], wires=0)\n    qml.RZ(x[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(x):\n    return np.abs(circuit4(x) - 0.5)**2\n\nopt = qml.GradientDescentOptimizer(stepsize=0.4)\n\nsteps = 100\nparams = np.array([0.011, 0.012, 0.05], requires_grad=True)\n\nfor i in range(steps):\n    # update the circuit parameters\n    params = opt.step(cost, params)\n```\n\n----------------------------------------\n\nTITLE: Importing PennyLane and NumPy\nDESCRIPTION: This snippet shows how to import PennyLane and the wrapped NumPy version provided by PennyLane. This is essential for automatic differentiation and backpropagation of classical computations using familiar NumPy functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n```\n\n----------------------------------------\n\nTITLE: Tracking Resource Requirements with PennyLane Tracker\nDESCRIPTION: Illustrates how to use PennyLane's `Tracker` to monitor the resource requirements of circuits executed by a device. The example defines a simple circuit and executes it with different qubit numbers, tracking the resources used.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit(n_wires):\n    for i in range(n_wires):\n        qml.Hadamard(i)\n    return qml.probs(range(n_wires))\n\nwith qml.Tracker(dev) as tracker:\n    for i in range(1, 5):\n        circuit(i)\n```\n\n----------------------------------------\n\nTITLE: Expectation Value Measurement with PauliZ in PennyLane\nDESCRIPTION: This code snippet defines a quantum function that applies RZ, CNOT, and RY gates and then measures the expectation value of the PauliZ observable on wire 1 using `qml.expval`. It demonstrates a basic measurement in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Combining Mid-Circuit Measurements Arithmetically in PennyLane\nDESCRIPTION: This example demonstrates how to combine mid-circuit measurements arithmetically to create new conditionals within a quantum circuit using PennyLane. It shows how to define a QNode, perform measurements, combine them using standard arithmetic operations, and use the combined result in a conditional operation. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    m0 = qml.measure(wires=0)\n    m1 = qml.measure(wires=1)\n    combined = 2 * m1 + m0\n    qml.cond(combined == 2, qml.RX)(1.3, wires=2)\n    return qml.probs(wires=2)\n```\n\n----------------------------------------\n\nTITLE: Postselecting Mid-Circuit Measurements in PennyLane (Python)\nDESCRIPTION: This code snippet demonstrates how to postselect on a mid-circuit measurement outcome using the `postselect` argument of `qml.measure`. The example defines a quantum node that applies an RX gate to qubit 0, measures qubit 0 with postselection on the outcome 1, and then returns a sample from qubit 0.  Outcomes that do not match the postselection criteria are discarded.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef func(x):\n    qml.RX(x, wires=0)\n    m_0 = qml.measure(0, postselect=1)\n    return qml.sample(wires=0)\n```\n\n----------------------------------------\n\nTITLE: JIT Compiling a Quantum Circuit with Catalyst\nDESCRIPTION: Demonstrates how to use the `@qml.qjit` decorator to compile a quantum circuit using Catalyst. This example defines a quantum node and applies the decorator to optimize its performance.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nfrom jax import numpy as jnp\n\ndev = qml.device(\"lightning.qubit\", wires=2, shots=1000)\n\n@qml.qjit\n@qml.qnode(dev)\ndef circuit(params):\n    qml.Hadamard(0)\n    qml.RX(jnp.sin(params[0]) ** 2, wires=1)\n    qml.CRY(params[0], wires=[0, 1])\n    qml.RX(jnp.sqrt(params[1]), wires=1)\n    return qml.expval(qml.Z(1))\n```\n\n----------------------------------------\n\nTITLE: Decomposing Controlled RX Gate\nDESCRIPTION: This code snippet demonstrates how a controlled RX gate can be decomposed into a sequence of single-qubit rotations and CNOT gates using PennyLane. It showcases the behavior of controlled operators with custom controlled versions and how they decompose. The `qml.ctrl` function is used to create a controlled version of the `qml.RX` gate, and the `.decomposition()` method returns the equivalent circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.ctrl(qml.RX(0.123, wires=1), control=0).decomposition()\n[\n  RZ(1.5707963267948966, wires=[1]),\n  RY(0.0615, wires=[1]),\n  CNOT(wires=[0, 1]),\n  RY(-0.0615, wires=[1]),\n  CNOT(wires=[0, 1]),\n  RZ(-1.5707963267948966, wires=[1])\n]\n```\n\n----------------------------------------\n\nTITLE: Counts Measurement with PauliZ in PennyLane\nDESCRIPTION: This snippet demonstrates how to use `qml.counts` to obtain the counts of each measurement outcome when measuring PauliZ on two qubits. This measurement returns a dictionary with the number of occurrences for each possible outcome.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.counts(qml.PauliZ(0)), qml.counts(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Probability Measurement with Specified Wires in PennyLane\nDESCRIPTION: This example demonstrates how to use the `qml.probs` measurement function to obtain the probabilities of measuring computational basis states on specified wires. The returned probabilities are ordered lexicographically.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_9\n\nLANGUAGE: python3\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[0, 2])\n    return qml.probs(wires=[0, 1])\n```\n\n----------------------------------------\n\nTITLE: PennyLane Circuit Generation for Molecular Simulation\nDESCRIPTION: This code defines a PennyLane quantum circuit for simulating a molecule, utilizing a `DoubleExcitation` gate. It defines a QNode that prepares a Hartree-Fock state and applies a double excitation gate. It returns the expectation value of the molecular Hamiltonian, which is passed to the function via the `mol` keyword argument, and the `args` keyword argument passes the circuit parameters to the double excitation gate.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\nhf_state = np.array([1, 1, 0, 0])\nparams = [np.array([0.0], requires_grad=True)] # initial values of the circuit parameters\n\ndef generate_circuit(mol):\n    @qml.qnode(dev)\n    def circuit(*args):\n        qml.BasisState(hf_state, wires=[0, 1, 2, 3])\n        qml.DoubleExcitation(*args[0][0], wires=[0, 1, 2, 3])\n        return qml.expval(qml.qchem.molecular_hamiltonian(mol, args=args[1:])[0])\n    return circuit\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation of Quantum Function in PennyLane\nDESCRIPTION: This code defines a quantum circuit using PennyLane and calculates its matrix representation. It defines a circuit that applies an RX gate and a Z gate, then obtains the matrix of the entire circuit using qml.matrix.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ndef circuit(theta):\n    qml.RX(theta, wires=1)\n    qml.Z(wires=0)\nqml.matrix(circuit)(np.pi / 4)\n```\n\n----------------------------------------\n\nTITLE: Using Snapshots for Debugging\nDESCRIPTION: Shows how to use `qml.Snapshot` operator to save the device state at specific points in the circuit for debugging purposes.  It then shows how the `qml.snapshots` transform can be used to extract those snapshot states.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, interface=None)\ndef circuit():\n    qml.Snapshot(measurement=qml.expval(qml.Z(0)))\n    qml.Hadamard(wires=0)\n    qml.Snapshot(\"very_important_state\")\n    qml.CNOT(wires=[0, 1])\n    qml.Snapshot()\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Simplifying QNodes with qml.simplify in PennyLane\nDESCRIPTION: This snippet shows how to simplify a QNode using the `@qml.simplify` decorator. This allows PennyLane to optimize the quantum circuit defined within the QNode, such as grouping rotation gates. It utilizes a default qubit device and applies RX, RY, and RZ gates before returning probabilities. The simplified circuit can then be drawn to visualize the effect of the simplification.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.simplify\n@qml.qnode(dev)\ndef circuit(x):\n    (\n        qml.RX(x[0], wires=0)\n        @ qml.RY(x[1], wires=1)\n        @ qml.RZ(x[2], wires=2)\n        @ qml.RX(-1, wires=0)\n        @ qml.RY(-2, wires=1)\n        @ qml.RZ(2, wires=2)\n    )\n    return qml.probs([0, 1, 2])\n\n>>> x = [1, 2, 3]\n>>> print(qml.draw(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: VQE Simulation with PennyLane\nDESCRIPTION: This snippet demonstrates a VQE simulation using PennyLane. It constructs a molecular Hamiltonian, defines a quantum circuit with a double excitation gate, and calculates the expectation value of the Hamiltonian. It requires pennylane and numpy. The output is the expectation value of the Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/chemistry.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=4)\n\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0., 0., -0.66140414], [0., 0., 0.66140414]])\nmolecule = qml.qchem.Molecule(symbols, geometry)\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(molecule)\n\n@qml.qnode(dev)\ndef circuit(params):\n    qml.BasisState(np.array([1, 1, 0, 0]), wires=[0, 1, 2, 3])\n    qml.DoubleExcitation(params, wires=[0, 1, 2, 3])\n    return qml.expval(hamiltonian)\n\nparams = np.array(0.20885146442480412, requires_grad=True)\ncircuit(params)\n```\n\n----------------------------------------\n\nTITLE: Accessing Pauli Operators with Short-Form Names in PennyLane\nDESCRIPTION: This snippet demonstrates how to access Pauli operators using the short-form names I, X, Y, and Z in PennyLane. These are functionally equivalent to the original long-form names but are now the recommended way to access Pauli operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import I, X, Y, Z\n>>> X(0)\nX(0)\n```\n\n----------------------------------------\n\nTITLE: Applying Parameter-Shift Rule to QNode in PennyLane\nDESCRIPTION: This code demonstrates how to apply the parameter-shift rule directly to a QNode to compute gradients in PennyLane. It defines a quantum circuit with trainable weights and uses the `qml.gradients.param_shift` transform to calculate the gradients of the circuit's probabilities with respect to the weights. The example uses the `default.qubit` device and requires the `pennylane` and `numpy` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(weights[2], wires=1)\n    return qml.probs(wires=1)\n\nweights = np.array([0.1, 0.2, 0.3], requires_grad=True)\ncircuit(weights)\nqml.gradients.param_shift(circuit)(weights)\n```\n\n----------------------------------------\n\nTITLE: Differentiable Matrix Representation with PyTorch in PennyLane\nDESCRIPTION: This code demonstrates how to obtain a differentiable matrix representation of a quantum gate using PennyLane and PyTorch. It defines a quantum function, gets its matrix representation, computes the loss, and performs backpropagation to calculate gradients with respect to the gate parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport torch\n\nx = torch.tensor(0.6, requires_grad=True)\nmatrix_fn = qml.matrix(qml.RX)\nmatrix_fn(x, wires=0)\n```\n\nLANGUAGE: python\nCODE:\n```\nloss = torch.real(torch.trace(matrix_fn(x, wires=0)))\nloss.backward()\nx.grad\n```\n\n----------------------------------------\n\nTITLE: Calculating Quantum Gradients with PyTorch\nDESCRIPTION: This snippet demonstrates how to calculate gradients of a PyTorch-interfacing QNode using PyTorch's automatic differentiation capabilities.  By setting `requires_grad=True` for the input tensors and calling `.backward()` on the result, the gradients of the quantum circuit with respect to its parameters are computed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='torch')\ndef circuit3(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nphi = torch.tensor([0.5, 0.1], requires_grad=True)\ntheta = torch.tensor(0.2, requires_grad=True)\nresult = circuit3(phi, theta)\n\nresult.backward()\n```\n\n----------------------------------------\n\nTITLE: Apply NoiseModel to QNode with add_noise transform\nDESCRIPTION: Demonstrates how to apply a previously defined `NoiseModel` to a QNode using the `qml.add_noise` transform. This inserts the specified noise operations into the quantum circuit based on the conditions defined in the noise model.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"lightning.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Y(0)\n    qml.CNOT([0, 1])\n    qml.RY(0.3, wires=2) # triggers c0\n    qml.X(1) # triggers c1\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Gradient-Based Optimizer with Step and Cost in Pycon\nDESCRIPTION: This code demonstrates using the `step_and_cost` method of a gradient-based optimizer to obtain both the next step and the objective function output. It initializes a `GradientDescentOptimizer` and then calls `step_and_cost` to update the parameters and retrieve the cost.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> opt = qml.GradientDescentOptimizer()\n>>> params, cost = opt.step_and_cost(cost_fn, params)\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit with Multiple Measurements\nDESCRIPTION: This code defines a quantum circuit with multiple measurements and enables the new experimental return type. The circuit includes Hadamard and CRX gates and returns probabilities, von Neumann entropy, and expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_return()\ndev = qml.device(\"default.qubit\", wires=2)\n  \n@qml.qnode(dev)\ndef circuit(x):\n    qml.Hadamard(wires=[0])\n    qml.CRX(x, wires=[0, 1])\n    return (qml.probs(wires=[0]), qml.vn_entropy(wires=[0]), qml.probs(wires=0), qml.expval(wires=1))\n```\n\n----------------------------------------\n\nTITLE: Interactive Debugging with Breakpoints\nDESCRIPTION: Demonstrates how to use `qml.breakpoint` for interactive debugging of quantum circuits. This enables stepping through the circuit execution, inspecting the quantum state, and dynamically queuing operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n    \n@qml.qnode(dev)\ndef circuit(x):\n    qml.breakpoint()\n\n    qml.RX(x, wires=0)\n    qml.Hadamard(wires=1)\n\n    qml.breakpoint()\n\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.Z(0))\n\ncircuit(1.23)\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Access Pauli representation of operator\nDESCRIPTION: This snippet showcases how to access the Pauli representation of a PennyLane operator using the `op.pauli_rep` attribute. This representation can be used for faster operator arithmetic within PennyLane. Note: `qml.operation.enable_new_opmath()` must be called before use.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nqml.operation.enable_new_opmath()\nop = X(0) + Y(0)\nop.pauli_rep\n```\n\n----------------------------------------\n\nTITLE: Implementing Prep-Select-Prep template in PennyLane\nDESCRIPTION: This code demonstrates the usage of the new `qml.PrepSelPrep` template, which simplifies the implementation of linear combination of unitaries (LCU) block encoding. It shows the equivalence between using `qml.PrepSelPrep` and explicitly performing `qml.StatePrep`, `qml.Select`, and `qml.adjoint(qml.StatePrep)`. It utilizes numpy for coefficient and unitary setup and PennyLane for quantum operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [0.3, 0.1]\nalphas = (np.sqrt(coeffs) / np.linalg.norm(np.sqrt(coeffs)))\nunitaries = [qml.X(2), qml.Z(2)]\n\nlcu = qml.dot(coeffs, unitaries)\ncontrol = [0, 1]\n\ndef prep_sel_prep(alphas, unitaries):\n    qml.StatePrep(alphas, wires=control, pad_with=0)\n    qml.Select(unitaries, control=control)\n    qml.adjoint(qml.StatePrep)(alphas, wires=control, pad_with=0)\n\n@qml.qnode(qml.device(\"default.qubit\"))\ndef circuit(lcu, control, alphas, unitaries):\n    qml.PrepSelPrep(lcu, control)\n    qml.adjoint(prep_sel_prep)(alphas, unitaries)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Using the reversible differentiation method\nDESCRIPTION: This snippet demonstrates how to use the 'reversible' differentiation method in PennyLane. It defines a quantum circuit as a QNode and specifies `diff_method=\"reversible\"` when creating the QNode. This method trades off extra computation for enhanced memory efficiency, particularly beneficial for circuits with a high density of parametrized gates near the end.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.10.0.md#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n... @qml.qnode(dev, diff_method=\"reversible\")\n... def circuit(x):\n...     qml.RX(x, wires=0)\n...     qml.RX(x, wires=0)\n...     qml.CNOT(wires=[0,1])\n...     return qml.expval(qml.PauliZ(0))\n>>> qml.grad(circuit)(0.5)\n(array(-0.47942554),)\n```\n\n----------------------------------------\n\nTITLE: SciPy Optimization with PennyLane QNode\nDESCRIPTION: This snippet demonstrates how to optimize a PennyLane QNode using SciPy's minimize function. It defines a quantum circuit using PennyLane, a cost function based on the circuit's output, and then uses scipy.optimize.minimize to find the parameters that minimize the cost.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.optimize import minimize\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RZ(x[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(x):\n    return np.abs(circuit(x) - 0.5) ** 2\n\nparams = np.array([0.011, 0.012, 0.05], requires_grad=True)\n\nminimize(cost, params, method='BFGS')\n```\n\n----------------------------------------\n\nTITLE: Importing QASM Code into PennyLane QNode\nDESCRIPTION: This code snippet shows how to import a quantum circuit defined in QASM format into a PennyLane QNode.  It loads the QASM code for a Hadamard gate, converts it into a PennyLane template using qml.from_qasm(), and then uses this template multiple times within a QNode. This QNode is executed on the 'forest.qpu' device and returns the expectation values of PauliX on wires 0 and 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device('forest.qpu', wires=2)\n\nhadamard_qasm = 'OPENQASM 2.0;' \\\n                    'include \"qelib1.inc\";' \\\n                    'qreg q[1];' \\\n                    'h q[0];'\n\napply_hadamard = qml.from_qasm(hadamard_qasm)\n\n@qml.qnode(dev)\ndef circuit_with_hadamards():\n    apply_hadamard(wires=[0])\n    apply_hadamard(wires=[1])\n    qml.Hadamard(wires=[1])\n    return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliX(1))\n\nresult = circuit_with_hadamards()\n```\n\n----------------------------------------\n\nTITLE: JIT Compiling a Hybrid Function with Catalyst\nDESCRIPTION: Shows how to use the `@qml.qjit` decorator to compile a hybrid function that combines quantum and classical processing. The function calculates the gradient of a quantum circuit and performs a classical calculation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n@qml.qjit\ndef hybrid_function(params, x):\n    grad = qml.grad(circuit)(params)\n    return jnp.abs(grad - x) ** 2\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation of a Quantum Operator in PennyLane\nDESCRIPTION: This code calculates the matrix representation of a RX gate using PennyLane. It instantiates an RX gate with a given parameter and then uses the qml.matrix function to obtain its matrix representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nop = qml.RX(0.54, wires=0)\nqml.matrix(op)\n```\n\n----------------------------------------\n\nTITLE: Implementing Grover's Search Algorithm in PennyLane\nDESCRIPTION: Implements Grover's search algorithm using PennyLane, incorporating the defined oracle and GroverOperator template. This showcases the construction of a quantum circuit for searching a marked state with high probability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=wires)\n\n@qml.qnode(dev)\ndef GroverSearch(num_iterations=1):\n    for wire in wires:\n        qml.Hadamard(wire)\n\n    for _ in range(num_iterations):\n        oracle()\n        qml.templates.GroverOperator(wires=wires)\n\n    return qml.probs(wires)\n```\n\n----------------------------------------\n\nTITLE: Mixed-State Training with Backpropagation\nDESCRIPTION: This code demonstrates how to use backpropagation for differentiation with the `default.mixed` device in PennyLane.  A quantum circuit is defined, and backpropagation is explicitly specified as the differentiation method.  The gradient of the circuit's expectation value is then computed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.mixed\", wires=2)\n\n@qml.qnode(dev, interface=\"autograd\", diff_method=\"backprop\")\ndef circuit(x):\n    qml.RY(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(wires=1))\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = np.array(0.5, requires_grad=True)\n>>> circuit(x)\narray(0.87758256)\n>>> qml.grad(circuit)(x)\n-0.479425538604203\n```\n\n----------------------------------------\n\nTITLE: Compiling an Optimization Loop with JAX JIT\nDESCRIPTION: Demonstrates how to compile an entire optimization loop using `@jax.jit`, which includes calls to `@qml.qjit`-compiled functions. This example optimizes parameters using gradient descent.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nimport jaxopt\n\n@jax.jit\ndef optimization():\n    # initial parameter\n    params = jnp.array([0.54, 0.3154])\n\n    # define the optimizer using a qjit-decorated function\n    opt = jaxopt.GradientDescent(circuit, stepsize=0.4)\n    update = lambda i, args: tuple(opt.update(*args))\n\n    # perform optimization loop\n    state = opt.init_state(params)\n    (params, _) = jax.lax.fori_loop(0, 100, update, (params, state))\n\n    return params\n```\n\n----------------------------------------\n\nTITLE: Conditional Operator Based on Mid-Circuit Measurement in PennyLane (Python)\nDESCRIPTION: This code demonstrates how to create a conditional operator controlled by a mid-circuit measurement using `qml.cond`. The code defines a quantum node `qnode_conditional_op_on_zero` that performs an RY gate, applies a CNOT gate, measures qubit 1, and then conditionally applies another RY gate to qubit 0 based on whether the measurement outcome is 0. Finally, it returns the probabilities of qubit 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef qnode_conditional_op_on_zero(x, y):\n    qml.RY(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    m_0 = qml.measure(1)\n\n    qml.cond(m_0 == 0, qml.RY)(y, wires=0)\n    return qml.probs(wires=[0])\n\npars = np.array([0.643, 0.246], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: QNode Interface Declaration with TensorFlow\nDESCRIPTION: This code snippet demonstrates how to define a QNode in PennyLane and specify the TensorFlow interface using the 'interface' argument. This allows the quantum circuit to be treated as a differentiable function within the TensorFlow framework, enabling hybrid quantum-classical training.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, interface=\"tf\")\ndef my_quantum_circuit(...):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Combined Measurements of Expectation and Variance in PennyLane\nDESCRIPTION: This snippet demonstrates how to return multiple measurements from a quantum function, specifically the expectation value of PauliZ and the variance of PauliX on wire 0. It shows how PennyLane can handle combined measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    return qml.expval(qml.PauliZ(0)), qml.var(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: Quantum Gradients with TensorFlow\nDESCRIPTION: This snippet demonstrates how to compute quantum gradients using TensorFlow's `tf.GradientTape`. It uses a TensorFlow-interfacing QNode and calculates the gradients of the QNode's output with respect to the input parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='tf')\ndef circuit(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nphi = tf.Variable([0.5, 0.1])\ntheta = tf.Variable(0.2)\n\nwith tf.GradientTape() as tape:\n    # Use the circuit to calculate the loss value\n    loss = circuit(phi, theta)\n\nphi_grad, theta_grad = tape.gradient(loss, [phi, theta])\n```\n\n----------------------------------------\n\nTITLE: Defining a QNode with Static Arguments in PennyLane\nDESCRIPTION: This code shows how to define a QNode with a static argument using the `static_argnums` keyword. When program capture is enabled, PennyLane can optimize circuit execution by only reconstructing the plxpr representation when static arguments change. This demonstrates how to improve efficiency for repeated circuit executions with fixed parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nqml.capture.enable()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=1), static_argnums=0)\ndef f(x, y):\n    print(\"I constructed plxpr\")\n    qml.RX(x, 0)\n    qml.RY(y, 0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Classical and Quantum Fisher Information Calculation\nDESCRIPTION: This example demonstrates how to calculate the classical and quantum Fisher information using the `qml.qinfo.classical_fisher` and `qml.qinfo.quantum_fisher` functions in PennyLane. It defines a quantum circuit with several gates and then calculates both the classical and quantum Fisher information matrices. These are used in natural gradient optimization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_2\n\nLANGUAGE: python3\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circ(params):\n    qml.RY(params[0], wires=1)\n    qml.CNOT(wires=(1,0))\n    qml.RY(params[1], wires=1)\n    qml.RZ(params[2], wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliX(1) - 0.5 * qml.PauliZ(1))\n\nparams = np.array([0.5, 1., 0.2], requires_grad=True)\ncfim = qml.qinfo.classical_fisher(circ)(params)\nqfim = qml.qinfo.quantum_fisher(circ)(params)\n```\n\n----------------------------------------\n\nTITLE: Optimization using Optax\nDESCRIPTION: This snippet demonstrates how to optimize a QNode using the ``adam`` optimizer from the ``Optax`` library. It includes setting up the optimizer, calculating gradients, and updating parameters within a training loop.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom jax import numpy as jnp\nimport jax\nimport optax\n\nlearning_rate = 0.15\n\ndev = qml.device(\"default.qubit\", wires=1, shots=None)\n\n@jax.jit\n@qml.qnode(dev, interface=\"jax\")\ndef energy(a):\n    qml.RX(a, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\noptimizer = optax.adam(learning_rate)\n\nparams = jnp.array(0.5)\nopt_state = optimizer.init(params)\n\nfor _ in range(200):\n    grads = jax.grad(energy)(params)\n    updates, opt_state = optimizer.update(grads, opt_state)\n    params = optax.apply_updates(params, updates)\n```\n\n----------------------------------------\n\nTITLE: Import PennyLane and JAX\nDESCRIPTION: This snippet shows how to import PennyLane, JAX, and JAX NumPy. These imports are necessary to use the JAX interface with PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax\nimport jax.numpy as jnp\n```\n\n----------------------------------------\n\nTITLE: Building Pauli matrices and tensor product in Python\nDESCRIPTION: This snippet demonstrates how to construct Pauli matrices (I, Z, X) using NumPy and compute the tensor product (Kronecker product) of Z and I to create the ZI operator. It then converts the resulting dense matrix to a sparse CSR matrix using SciPy and prints the matrix along with its non-zero values and column indices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/pauli/pauli_sparse_matrices.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\nimport scipy\n\nI = np.array([[1, 0], [0, 1]])\nZ = np.array([[1, 0], [0, -1]])\nX = np.array([[0, 1], [1, 0]])\n\nZI = np.kron(Z, I)\nZI_CSR = scipy.sparse.csr_matrix(ZI)\nprint(ZI)\nprint(f\"val: {ZI_CSR[ZI_CSR.nonzero()].tolist()[0]}\\ncol: {ZI_CSR.indices}\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Time-Dependent Hamiltonian with Parametrized Coefficients in Python\nDESCRIPTION: This snippet demonstrates how to create a time-dependent Hamiltonian using `qml.pulse.ParametrizedHamiltonian` in PennyLane with JAX. It defines functions for the coefficients and constructs the Hamiltonian as a linear combination of Pauli operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jax import numpy as jnp\n\nf1 = lambda p, t: p * jnp.sin(t) * (t - 1)\nf2 = lambda p, t: p[0] * jnp.cos(p[1]* t ** 2)\n\nXX = qml.PauliX(0) @ qml.PauliX(1)\nYY = qml.PauliY(0) @ qml.PauliY(1)\nZZ = qml.PauliZ(0) @ qml.PauliZ(1)\n\nH =  2 * ZZ + f1 * XX + f2 * YY\n```\n\n----------------------------------------\n\nTITLE: QNode Return Example (Python)\nDESCRIPTION: This snippet demonstrates the updated QNode return system in PennyLane. It defines a QNode that returns both the expectation value of `qml.PauliZ(0)` and the probabilities `qml.probs(0)`. The updated QNode returns a tuple containing these values separately.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.probs(0)\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradients Using Hadamard Test in Pycon\nDESCRIPTION: This snippet shows how to use the Hadamard test gradient transform (`qml.gradients.hadamard_grad`) to calculate the gradient of a quantum circuit. It defines a quantum circuit, initializes parameters, and then calculates the gradient using the `hadamard_grad` transform.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> @qml.qnode(dev)\n... def circuit(params):\n...     qml.RX(params[0], wires=0)\n...     qml.RY(params[1], wires=0)\n...     qml.RX(params[2], wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> params = np.array([0.1, 0.2, 0.3], requires_grad=True)\n>>> qml.gradients.hadamard_grad(circuit)(params)\n(tensor(-0.3875172, requires_grad=True),\n tensor(-0.18884787, requires_grad=True),\n tensor(-0.38355704, requires_grad=True))\n```\n\n----------------------------------------\n\nTITLE: Creating and Using an Attribute in PennyLane\nDESCRIPTION: This code demonstrates how to create and use a custom attribute in PennyLane to group operators with specific properties.  It creates an attribute `pauli_ops` that includes Pauli operators, and shows how to check if a given operator or its name belongs to that attribute. This is used for bookkeeping and efficient device implementations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.ops.qubits.attributes import Attribute\n>>> pauli_ops = Attribute([\"PauliX\", \"PauliY\", \"PauliZ\"])\n\n>>> qml.PauliX(0) in pauli_ops\nTrue\n>>> \"Hadamard\" in pauli_ops\nFalse\n```\n\n----------------------------------------\n\nTITLE: JIT Compilation with Catalyst in PennyLane\nDESCRIPTION: This snippet demonstrates how to use the `qml.qjit` decorator to JIT compile a PennyLane quantum circuit using Catalyst. This includes both quantum and classical processing. Requires PennyLane and pennylane-catalyst.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"lightning.qubit\", wires=2)\n\n@qml.qjit\n@qml.qnode(dev)\ndef circuit(theta):\n    qml.Hadamard(wires=0)\n    qml.RX(theta, wires=1)\n    qml.CNOT(wires=[0,1])\n    return qml.expval(qml.PauliZ(wires=1))\n```\n\n----------------------------------------\n\nTITLE: Quantum Kernel Execution with Shot Vectors in PennyLane\nDESCRIPTION: This code demonstrates how to define a quantum kernel using PennyLane and execute it with shot vectors. It defines a quantum circuit using qml.templates.AngleEmbedding, then defines a kernel function that calls the circuit. The device uses a shot vector for batched execution. X is a set of feature vectors used to compute the kernel matrix.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2, shots=(100, 100))\n@qml.qnode(dev)\ndef circuit(x1, x2):\n    qml.templates.AngleEmbedding(x1, wires=dev.wires)\n    qml.adjoint(qml.templates.AngleEmbedding)(x2, wires=dev.wires)\n    return qml.probs(wires=dev.wires)\n\nkernel = lambda x1, x2: circuit(x1, x2)\n```\n\n----------------------------------------\n\nTITLE: Using Hamiltonian in Quantum Circuit\nDESCRIPTION: This snippet shows how to use a previously defined `qml.Hamiltonian` (in this case, `tfim_ham`) within a PennyLane quantum circuit.  It defines a QNode that calculates the expectation value of the Hamiltonian on a specified device.  Dependencies: `qml.device` and `qml.qnode` are required from PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", shots=1)\n\n@qml.qnode(dev)\ndef circuit():\n    return qml.expval(tfim_ham)\n```\n\n----------------------------------------\n\nTITLE: Deferring Mid-circuit Measurements with @qml.defer_measurements\nDESCRIPTION: This code demonstrates how to use the `@qml.defer_measurements` transform in PennyLane to handle mid-circuit measurements on devices that do not natively support them. The transform converts the QNode into one with terminal measurements and controlled operations.  It utilizes `qml.cond` to apply different operations based on measurement outcomes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\n@qml.defer_measurements\ndef circuit(x):\n    qml.Hadamard(wires=0)\n\n    m = qml.measure(0)\n\n    def op_if_true():\n        return qml.RX(x**2, wires=1)\n\n    def op_if_false():\n        return qml.RY(x, wires=1)\n\n    qml.cond(m==1, op_if_true, op_if_false)()\n\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Validating Ising Model Hamiltonian (Python)\nDESCRIPTION: This snippet demonstrates that the spin Hamiltonian generated from a custom lattice is equivalent to the one generated by `qml.spin.transverse_ising`. This ensures consistency and correctness of the custom lattice implementation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> tfim_ham = qml.spin.transverse_ising('triangle', [3, 3], coupling=1.0, h=0.5)\n>>> tfim_ham == qml.spin.spin_hamiltonian(lattice=lattice)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Automatic Interface Detection for QNodes\nDESCRIPTION: Demonstrates how to use the `interface=\"auto\"` argument in `qml.qnode` to automatically detect the machine learning library being used. This simplifies the integration of PennyLane with different frameworks. Requires PennyLane, NumPy, Torch, TensorFlow, and JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\nimport torch\nimport tensorflow as tf\nfrom jax import numpy as jnp\n\ndev = qml.device(\"default.qubit\", wires=2)\n@qml.qnode(dev, interface=\"auto\")\ndef circuit(weight):\n    qml.RX(weight[0], wires=0)\n    qml.RY(weight[1], wires=1)\n    return qml.expval(qml.PauliZ(0))\n\ninterface_tensors = [[0, 1], np.array([0, 1]), torch.Tensor([0, 1]), tf.Variable([0, 1], dtype=float), jnp.array([0, 1])]\nfor tensor in interface_tensors:\n    res = circuit(weight=tensor)\n    print(f\"Result value: {res:.2f}; Result type: {type(res)}\")\n```\n\n----------------------------------------\n\nTITLE: QNode with JAX JIT and qml.probs\nDESCRIPTION: This snippet defines a quantum node (QNode) using PennyLane, integrates it with JAX for just-in-time (JIT) compilation, and returns the probabilities of measuring the qubit in different basis states. The QNode uses a default.qubit device, applies RX, RY, and CNOT gates, and measures the probabilities of the second qubit. It demonstrates how to leverage JAX JIT compilation for potentially significant performance improvements when working with QNodes that return vector-valued outputs like probabilities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\nx = jnp.array(0.543)\ny = jnp.array(-0.654)\n\n@jax.jit\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"jax\")\ndef circuit(x, y):\n    qml.RX(x, wires=[0])\n    qml.RY(y, wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.probs(wires=[1])\n```\n\n----------------------------------------\n\nTITLE: Creating VQE Cost Function with PennyLane\nDESCRIPTION: This code demonstrates how to create a Variational Quantum Eigensolver (VQE) cost function using PennyLane's `qml.VQECost` class. It requires a circuit ansatz, a Hamiltonian, and a device to execute the quantum circuit. The cost function is then used to evaluate the energy for given parameters using the torch interface.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> H = qml.vqe.Hamiltonian(coeffs, obs)\n>>> cost = qml.VQECost(ansatz, hamiltonian, dev, interface=\"torch\")\n>>> params = torch.rand([4, 3])\n>>> cost(params)\ntensor(0.0245, dtype=torch.float64)\n```\n\n----------------------------------------\n\nTITLE: Quantum Teleportation with Mid-circuit Measurements\nDESCRIPTION: This example demonstrates quantum teleportation in PennyLane using mid-circuit measurements and conditional operations. It prepares an input state, creates a Bell state, performs measurements on the first two qubits, and applies conditional Pauli gates on the third qubit based on the measurement outcomes. The code utilizes `qml.measure()` and `qml.cond()` functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\ninput_state = np.array([1, -1], requires_grad=False) / np.sqrt(2)\n\n@qml.qnode(dev)\ndef teleport(state):\n    # Prepare input state\n    qml.QubitStateVector(state, wires=0)\n\n    # Prepare Bell state\n    qml.Hadamard(wires=1)\n    qml.CNOT(wires=[1, 2])\n\n    # Apply gates\n    qml.CNOT(wires=[0, 1])\n    qml.Hadamard(wires=0)\n\n    # Measure first two wires\n    m1 = qml.measure(0)\n    m2 = qml.measure(1)\n\n    # Condition final wire on results\n    qml.cond(m2 == 1, qml.PauliX)(wires=2)\n    qml.cond(m1 == 1, qml.PauliZ)(wires=2)\n\n    # Return state on final wire\n    return qml.density_matrix(wires=2)\n```\n\n----------------------------------------\n\nTITLE: Using Hamiltonian with qml.expval in QNodes (Python)\nDESCRIPTION: This code snippet demonstrates the recommended way to calculate expectation values using Hamiltonians directly within a QNode using `qml.expval` instead of the deprecated `qml.ExpvalCost`.  It defines a quantum node `ansatz` which applies some quantum function (`some_qfunc`) and then returns the expectation value of the `Hamiltonian` observable. Dependencies: pennylane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef ansatz(params):\n    some_qfunc(params)\n    return qml.expval(Hamiltonian)\n```\n\n----------------------------------------\n\nTITLE: Updating a QNode's Device\nDESCRIPTION: This code snippet demonstrates how to update a QNode's device. It first defines a new device `new_dev` using `lightning.qubit` with the same wires as the original device. Then, it updates the QNode `circuit` to use the new device using `circuit.update(device=new_dev)`, creating a new QNode named `new_circuit`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nnew_dev = qml.device('lightning.qubit', wires=dev_unique_wires.wires)\nnew_circuit = circuit.update(device = new_dev)\nprint(new_circuit.device.name)\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Access Pauli operators via I, X, Y, and Z\nDESCRIPTION: This snippet shows how to easily access Pauli operators using the short-form names I, X, Y, and Z in PennyLane. This simplifies the syntax for defining and working with Pauli operators in quantum computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import I, X, Y, Z\n```\n\n----------------------------------------\n\nTITLE: Returning the quantum state from a QNode in PennyLane\nDESCRIPTION: This example demonstrates how to return the quantum state of a QNode using `qml.state()`. It defines a quantum function, applies some gates, and then returns the quantum state as the output. It also enables tape mode and uses a default qubit device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", wires=3)\nqml.enable_tape()\n\n@qml.qnode(dev)\ndef qfunc(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[0, 2])\n    return qml.state()\n\n>>> qfunc(0.56, 0.1)\narray([0.95985437-0.27601028j, 0.        +0.j        ,\n       0.04803275-0.01381203j, 0.        +0.j        ,\n       0.        +0.j        , 0.        +0.j        ,\n       0.        +0.j        , 0.        +0.j        ])\n```\n\n----------------------------------------\n\nTITLE: Backpropagation Differentiation with Default Qubit\nDESCRIPTION: This code shows how `default.qubit` can dispatch to all interfaces in a backprop-compatible way without being swapped out. It demonstrates using backpropagation for differentiation with the `default.qubit` device and verifies that the device is not swapped for an interface-specific device like `DefaultQubitJax`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev, diff_method=\"backprop\")\ndef f(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nf(jax.numpy.array(0.2))\n```\n\n----------------------------------------\n\nTITLE: Fidelity Calculation between Quantum States\nDESCRIPTION: This example calculates the fidelity between two quantum states using PennyLane's `qml.qinfo.fidelity` function.  Two quantum circuits (`circuit_rx` and `circuit_ry`) are defined, and the fidelity between their output states is computed.  The gradient of the fidelity is also calculated.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=1)\n  \n@qml.qnode(dev)\ndef circuit_rx(x):\n    qml.RX(x[0], wires=0)\n    qml.RZ(x[1], wires=0)\n    return qml.state()\n  \n@qml.qnode(dev)\ndef circuit_ry(y):\n    qml.RY(y, wires=0)\n    return qml.state()\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = np.array([0.1, 0.3], requires_grad=True)\n>>> y = np.array(0.2, requires_grad=True) \n>>> fid_func = qml.qinfo.fidelity(circuit_rx, circuit_ry, wires0=[0], wires1=[0])\n>>> fid_func(x, y)\n0.9905158135644924\n>>> df = qml.grad(fid_func)\n>>> df(x, y)\n(array([-0.04768725, -0.29183666]), array(-0.09489803))\n```\n\n----------------------------------------\n\nTITLE: Resetting Qubits After Mid-Circuit Measurement in PennyLane (Python)\nDESCRIPTION: This code snippet demonstrates how to reset a qubit to the |0⟩ state after a mid-circuit measurement using the `reset=True` argument in `qml.measure`. The example defines a quantum node that applies a PauliX gate to qubit 1, measures qubit 1 and resets it, applies another PauliX gate to qubit 1, and then returns the probabilities of qubit 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef func():\n    qml.PauliX(1)\n    m_0 = qml.measure(1, reset=True)\n    qml.PauliX(1)\n    return qml.probs(wires=[1])\n```\n\n----------------------------------------\n\nTITLE: Drawing a Quantum Circuit with PennyLane\nDESCRIPTION: This code snippet showcases PennyLane's circuit drawing feature using `qnode.draw()`. It allows users to visualize a quantum circuit represented by a QNode instance. The drawing can be customized to display variable names and use either ASCII or Unicode characters, offering different levels of readability and detail.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef qfunc(a, w):\n    qml.Hadamard(0)\n    qml.CRX(a, wires=[0, 1])\n    qml.Rot(w[0], w[1], w[2], wires=[1])\n    qml.CRX(-a, wires=[0, 1])\n\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> result = qfunc(2.3, [1.2, 3.2, 0.7])\n>>> print(qfunc.draw())\n 0: ──H──╭C────────────────────────────╭C─────────╭┤ ⟨Z ⊗ Z⟩\n 1: ─────╰RX(2.3)──Rot(1.2, 3.2, 0.7)──╰RX(-2.3)──╰┤ ⟨Z ⊗ Z⟩\n>>> print(qfunc.draw(charset=\"ascii\"))\n 0: --H--+C----------------------------+C---------+| <Z @ Z>\n 1: -----+RX(2.3)--Rot(1.2, 3.2, 0.7)--+RX(-2.3)--+| <Z @ Z>\n>>> print(qfunc.draw(show_variable_names=True))\n 0: ──H──╭C─────────────────────────────╭C─────────╭┤ ⟨Z ⊗ Z⟩\n 1: ─────╰RX(a)──Rot(w[0], w[1], w[2])──╰RX(-1*a)──╰┤ ⟨Z ⊗ Z⟩\n```\n\n----------------------------------------\n\nTITLE: Fermionic Hamiltonian Parity Transformation in PennyLane\nDESCRIPTION: This code demonstrates the use of 'qml.fermi.parity_transform' to transform a fermionic Hamiltonian to a qubit Hamiltonian using parity mapping.  It initializes a FermiWord, then transforms it into a qubit Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfermi_ham = qml.fermi.FermiWord({(0, 0) : '+', (1, 1) : '-'})\n\nqubit_ham = qml.fermi.parity_transform(fermi_ham, n=6)\n```\n\n----------------------------------------\n\nTITLE: Drawing a Quantum Circuit with PennyLane\nDESCRIPTION: Demonstrates how to draw a quantum circuit using `qml.draw` and `qml.draw_mpl`. It shows how to visualize a quantum circuit and provides an example with a QFT circuit and various gates and measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit')\n\n@qml.qnode(dev)\ndef circuit(x, z):\n    qml.QFT(wires=(0,1,2,3))\n    qml.IsingXX(1.234, wires=(0,2))\n    qml.Toffoli(wires=(0,1,2))\n    mcm = qml.measure(1)\n    mcm_out = qml.measure(2)\n    qml.CSWAP(wires=(0,2,3))\n    qml.RX(x, wires=0)\n    qml.cond(mcm, qml.RY)(np.pi / 4, wires=3)\n    qml.CRZ(z, wires=(3,0))\n    return qml.expval(qml.Z(0)), qml.probs(op=mcm_out)\n\n\nfig, ax = qml.draw_mpl(circuit)(1.2345,1.2345)\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: QNode Construction with Keyword (TensorFlow)\nDESCRIPTION: This snippet creates a TensorFlow-compatible QNode using the `@qml.qnode` decorator with the `interface='tf'` keyword. The circuit takes TensorFlow Variables as input and returns TensorFlow Tensors.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='tf')\ndef circuit(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n```\n\n----------------------------------------\n\nTITLE: Computing Hessian of a Quantum Circuit with JAX-JIT in Python\nDESCRIPTION: This snippet demonstrates how to use JAX-JIT to compute the Hessian of a quantum circuit. It defines a quantum circuit with parameter-shift differentiation and a maximum differentiation order of 2. The `jax.hessian` function is used to compute the Hessian of the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax\nfrom jax import numpy as jnp\n\njax.config.update(\"jax_enable_x64\", True)\n\nqml.enable_return()\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@jax.jit\n@qml.qnode(dev, interface=\"jax-jit\", diff_method=\"parameter-shift\", max_diff=2)\ndef circuit(a, b):\n    qml.RY(a, wires=0)\n    qml.RX(b, wires=1)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\na, b = jnp.array(1.0), jnp.array(2.0)\n```\n\n----------------------------------------\n\nTITLE: Using qml.jacobian with qml.qjit\nDESCRIPTION: This snippet shows how to use `qml.jacobian` with the `@qml.qjit` decorator for hybrid quantum-classical compilation in PennyLane.  This enables automatic differentiation of quantum circuits within JIT-compiled workflows. Requires PennyLane, JAX and Catalyst.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"lightning.qubit\", wires=1)\n\n@qml.qjit\ndef workflow(x):\n\n    @qml.qnode(dev)\n    def circuit(x):\n        qml.RX(np.pi * x[0], wires=0)\n        qml.RY(x[1], wires=0)\n        return qml.probs()\n\n    g = qml.jacobian(circuit)\n\n    return g(x)\n```\n\n----------------------------------------\n\nTITLE: QNode Differentiation Method Specification\nDESCRIPTION: This code snippet shows how to specify the differentiation method to be used for a QNode. In this case, the 'parameter-shift' method is selected, which is suitable for both quantum hardware and simulators. The 'diff_method' argument is used when creating the QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.probs(wires=0)\n```\n\n----------------------------------------\n\nTITLE: Using Transpile Transform for Quantum Circuits\nDESCRIPTION: This code demonstrates the use of the `qml.transforms.transpile` transform to compile a quantum circuit for execution on specific hardware, based on a given coupling map. The `transpile` transform is applied as a decorator to a quantum function, which includes CNOT gates and a PhaseShift gate. The function returns the probabilities of the quantum state. This code requires PennyLane and its dependencies.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=4)\n\n@qml.qnode(dev)\n@qml.transforms.transpile(coupling_map=[(0, 1), (1, 2), (2, 3)])\ndef circuit(param):\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[0, 2])\n    qml.CNOT(wires=[0, 3])\n    qml.PhaseShift(param, wires=0)\n    return qml.probs(wires=[0, 1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Using default.qubit.tf with classical backpropagation\nDESCRIPTION: This snippet demonstrates the usage of the `default.qubit.tf` device for quantum simulation with TensorFlow, utilizing classical backpropagation to compute gradients. It showcases how to define a quantum circuit as a QNode, apply TensorFlow decorators for graph compilation, and compute gradients using `tf.GradientTape`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.10.0.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> dev = qml.device(\"default.qubit.tf\", wires=1)\n>>> @tf.function\n... @qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\n... def circuit(x):\n...     qml.RX(x[1], wires=0)\n...     qml.Rot(x[0], x[1], x[2], wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> weights = tf.Variable([0.2, 0.5, 0.1])\n>>> with tf.GradientTape() as tape:\n...     res = circuit(weights)\n>>> print(tape.gradient(res, weights))\ntf.Tensor([-2.2526717e-01 -1.0086454e+00  1.3877788e-17], shape=(3,), dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Accessing the Pauli Representation of a Composite Operator in PennyLane\nDESCRIPTION: This snippet demonstrates how to access the Pauli representation of a composite operator in PennyLane. If all terms of the composite operator have a valid pauli_rep, then the composite operator will also have a valid pauli_rep in terms of a PauliSentence instance.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> op.pauli_rep\n1.0 * X(0)\n+ 1.0 * X(1)\n+ 1.0 * X(2)\n```\n\n----------------------------------------\n\nTITLE: Extracting Circuit Properties using qml.specs\nDESCRIPTION: Demonstrates how to use the `qml.specs` transform to extract details about a QNode, including depth, number of gates, and number of gradient executions required. It showcases how to obtain resource information of a given quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=4)\n\n@qml.qnode(dev, diff_method='parameter-shift')\ndef circuit(x, y):\n    qml.RX(x[0], wires=0)\n    qml.Toffoli(wires=(0, 1, 2))\n    qml.CRY(x[1], wires=(0, 1))\n    qml.Rot(x[2], x[3], y, wires=0)\n    return qml.expval(qml.Z(0)), qml.expval(qml.X(1))\n```\n\n----------------------------------------\n\nTITLE: Qiskit to PennyLane: Integrating Qiskit measurements\nDESCRIPTION: This snippet shows how to convert a Qiskit circuit that already contains Qiskit-side measurements into PennyLane, allowing the Qiskit measurements to be accessible and used within a PennyLane QNode using `qml.from_qiskit`. It illustrates integrating Qiskit measurement results into a PennyLane mid-circuit measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqc = QuantumCircuit(3, 2)  # Teleportation\n\nqc.rx(0.9, 0)  # Prepare input state on qubit 0\n\nqc.h(1)  # Prepare Bell state on qubits 1 and 2\nqc.cx(1, 2)\n\nqc.cx(0, 1)  # Perform teleportation\nqc.h(0)\nqc.measure(0, 0)\nqc.measure(1, 1)\n\nwith qc.if_test((1, 1)):\n    qc.x(2)\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Construction with Differentiable Parameters\nDESCRIPTION: This snippet demonstrates the construction of a molecular Hamiltonian in PennyLane, leveraging the previously defined molecule and differentiable parameters. It creates a `Molecule` object and then calls `qml.qchem.molecular_hamiltonian` to generate the Hamiltonian. The `args` parameter passes the differentiable parameters to the molecular Hamiltonian constructor, enabling gradient computation with respect to these parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nargs = [geometry, alpha, coeff] # initial values of the differentiable parameters\n\nmolecule = qml.qchem.Molecule(symbols, geometry, alpha=alpha, coeff=coeff)\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(molecule, args=args)\n```\n\n----------------------------------------\n\nTITLE: Computing Gradients with PyTorch Backpropagation\nDESCRIPTION: This interactive console snippet shows how to compute the gradient of a PennyLane circuit using PyTorch backpropagation. The `res.backward()` call computes the gradients, which are then accessed via `p.grad`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> res = circuit(p)\n>>> res.backward()\n>>> print(p.grad)\ntensor([-9.1798e-17, -2.1454e-01, -1.0511e-16], dtype=torch.float64)\n```\n\n----------------------------------------\n\nTITLE: Computing Hessians of QNodes using Parameter-Shift Rule\nDESCRIPTION: This example demonstrates how to compute the Hessian of a QNode using the parameter-shift differentiation method in PennyLane.  The `circuit` function defines a quantum circuit with parameterized rotations, and the `hessian_fn` computes the Hessian using nested `qml.jacobian` and `qml.grad` calls. The resulting Hessian is evaluated at a given parameter value `x`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=1)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef circuit(p):\n    qml.RY(p[0], wires=0)\n    qml.RX(p[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nx = np.array([1.0, 2.0], requires_grad=True)\n```\n\nLANGUAGE: python\nCODE:\n```\nhessian_fn = qml.jacobian(qml.grad(circuit))\nhessian_fn(x)\n```\n\n----------------------------------------\n\nTITLE: QNode with Mid-Circuit Measurements and Classical Processing in Python\nDESCRIPTION: This snippet demonstrates the use of mid-circuit measurements (MCMs) and classical processing on MCMs within a QNode using program capture. It showcases how to define a quantum circuit that measures qubits mid-circuit, performs classical operations on the measurement results, and uses the processed values as gate parameters. This requires enabling program capture using `qml.capture.enable()` and setting `mcm_method=\"deferred\"` in the QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport jax \nimport jax.numpy as jnp\njax.config.update(\"jax_enable_x64\", True)\n\nqml.capture.enable()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=3), mcm_method=\"deferred\")\ndef f(x):\n    m0 = qml.measure(0)\n    m1 = qml.measure(0)\n\n    # classical processing on m0 and m1\n    a = jnp.sin(0.5 * jnp.pi * m0)\n    phi = a - (m1 + 1) ** 4\n\n    qml.s_prod(x, qml.RX(phi, 0))\n\n    return qml.expval(qml.Z(0))\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> f(0.1)\nArray(0.00540302, dtype=float64)\n```\n\n----------------------------------------\n\nTITLE: Building Molecular Hamiltonian using PennyLane\nDESCRIPTION: This snippet demonstrates how to construct a molecular Hamiltonian using PennyLane's qchem module. It uses the `molecular_hamiltonian` function to generate the Hamiltonian from the molecule's symbols and geometry. It requires pennylane and numpy to be installed. The output consists of the Hamiltonian as a PennyLane observable and the number of required qubits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/chemistry.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0., 0., -0.66140414], [0., 0., 0.66140414]])\nmolecule = qml.qchem.Molecule(symbols, geometry)\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(molecule)\n```\n\n----------------------------------------\n\nTITLE: Calculating Quantum Gradients with NumPy QNode\nDESCRIPTION: This code shows how to calculate the gradient of a NumPy-QNode using the `qml.grad` function. It defines a quantum circuit and then creates a QNode gradient function with respect to the QNode parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit3(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nphi = np.array([0.5, 0.1], requires_grad=True)\ntheta = np.array(0.2, requires_grad=True)\ndcircuit = qml.grad(circuit3)\n```\n\n----------------------------------------\n\nTITLE: Counts Measurement with All Outcomes in PennyLane\nDESCRIPTION: This snippet demonstrates using the `all_outcomes=True` argument in `qml.counts` to display all possible measurement outcomes, including those that were not observed (count of 0).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.counts(all_outcomes=True)\n```\n\n----------------------------------------\n\nTITLE: Stochastic Parameter-Shift Differentiation in PennyLane (Pycon)\nDESCRIPTION: This example demonstrates stochastic parameter-shift differentiation for pulse-level circuits in PennyLane. It defines a QNode with `diff_method` set to `qml.gradients.stoch_pulse_grad` and calculates the gradient of the circuit with respect to the parameters using `jax.grad`. It requires `jax` and is restricted to Hamiltonians composed of parametrized Pauli words.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit.jax\", wires=2)\nsin = lambda p, t: jax.numpy.sin(p * t)\nZZ = qml.PauliZ(0) @ qml.PauliZ(1)\nH = 0.5 * qml.PauliX(0) + qml.pulse.constant * ZZ + sin * qml.PauliX(1)\n@qml.qnode(dev, interface=\"jax\", diff_method=qml.gradients.stoch_pulse_grad)\ndef ansatz(params):\n    qml.evolve(H)(params, (0.2, 1.))\n    return qml.expval(qml.PauliY(1))\nparams = [jax.numpy.array(0.4), jax.numpy.array(1.3)]\njax.grad(ansatz)(params)\n```\n\n----------------------------------------\n\nTITLE: Sampling Polynomial Circuit (Python)\nDESCRIPTION: This snippet demonstrates the execution of the quantum circuit defined with `qml.OutPoly`. The expected output is the binary representation of the calculated polynomial, sampled from the output wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit()\narray([0, 1])\n```\n\n----------------------------------------\n\nTITLE: Optimizer Cost Function Flexibility\nDESCRIPTION: Illustrates the increased flexibility of PennyLane optimizers, allowing cost functions to accept any combination of trainable arguments, non-trainable arguments, and keyword arguments.  The example shows how to update multiple parameters at once and how to use list and tuple unpacking.  Requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef cost(x, y, data, scale=1.0):\n    return scale * (x[0]-data)**2 + scale * (y-data)**2\n\nx = np.array([1.], requires_grad=True)\ny = np.array([1.0])\ndata = np.array([2.], requires_grad=False)\n\nopt = qml.GradientDescentOptimizer()\n\n# the optimizer step and step_and_cost methods can\n# now update multiple parameters at once\nx_new, y_new, data = opt.step(cost, x, y, data, scale=0.5)\n(x_new, y_new, data), value = opt.step_and_cost(cost, x, y, data, scale=0.5)\n\n# list and tuple unpacking is also supported\nparams = (x, y, data)\nparams = opt.step(cost, *params)\n```\n\n----------------------------------------\n\nTITLE: Using DiagonalQubitUnitary in PennyLane\nDESCRIPTION: This snippet shows how to use `DiagonalQubitUnitary` to efficiently simulate oracles in PennyLane, which involves diagonal gates often found in IQP circuits. It requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=3)\n\n# Function as a bitstring\nf = np.array([1, 0, 0, 1, 1, 0, 1, 0])\n\n@qml.qnode(dev)\ndef circuit(weights1, weights2):\n    qml.templates.StronglyEntanglingLayers(weights1, wires=[0, 1, 2])\n\n    # Implements the function as a phase-kickback oracle\n    qml.DiagonalQubitUnitary((-1)**f, wires=[0, 1, 2])\n\n    qml.templates.StronglyEntanglingLayers(weights2, wires=[0, 1, 2])\n    return [qml.expval(qml.PauliZ(w)) for w in range(3)]\n```\n\n----------------------------------------\n\nTITLE: Mapping Fermionic Operators to Qubit Operators using Jordan-Wigner in PennyLane\nDESCRIPTION: Demonstrates how to map fermionic operators to qubit operators using the `qml.jordan_wigner` function. It can be used with FermiC, FermiA, Fermi words, and Fermi sentences.  This conversion is crucial for simulating fermionic systems on quantum computers.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.jordan_wigner(qml.FermiA(1))\n0.5 * (Z(0) @ X(1)) + 0.5j * (Z(0) @ Y(1))\n\n>>> qml.jordan_wigner(qml.FermiC(1) * qml.FermiA(1))\n(0.5+0j) * I(1) + (-0.5+0j) * Z(1)\n\n>>> f = 0.5 * qml.FermiC(1) * qml.FermiA(1) + 0.75 * qml.FermiC(2) * qml.FermiA(2)\n>>> qml.jordan_wigner(f)\n(\n    (0.625+0j) * I(1)\n  + (-0.25+0j) * Z(1)\n  + (-0.375+0j) * Z(2)\n)\n```\n\n----------------------------------------\n\nTITLE: Equivalent PennyLane QNode using explicit control flow\nDESCRIPTION: This example presents an equivalent implementation of the previous QNode, but using explicit PennyLane control flow constructs (`qml.for_loop`, `qml.cond`). This eliminates the need for AutoGraph, allowing for direct capture of the quantum program.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef cost(weights, data):\n\n    @qml.for_loop(0, 4, 1)\n    def initialize_loop(w):\n        qml.X(w)\n\n    @qml.for_loop(0, jnp.shape(weights)[0], 1)\n    def layer_loop(i):\n        x = weights[i]\n\n        @qml.for_loop(0, 4, 1)\n        def wire_loop(j):\n\n            @qml.cond(x[j] > 0)\n            def trainable_gate():\n                qml.RX(x[j], wires=j)\n\n            @trainable_gate.else_if(x[j] < 0)\n            def trainable_gate():\n                qml.RY(x[j], wires=j)\n\n            trainable_gate()\n\n        @qml.for_loop(0, 4, 1)\n        def cnot_loop(j):\n            qml.CNOT(wires=[j, jnp.mod((j + 1), 4)])\n\n        wire_loop()\n        cnot_loop()\n\n    initialize_loop()\n    layer_loop()\n    return qml.expval(qml.PauliZ(0) + qml.PauliZ(3))\n```\n\n----------------------------------------\n\nTITLE: Asserting Operator Validity in PennyLane\nDESCRIPTION: Illustrates how to use `qml.ops.functions.assert_valid` to validate a custom operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nqml.ops.functions.assert_valid(op)\n```\n\n----------------------------------------\n\nTITLE: Converting OpenFermion to PennyLane Qubit Operator (PyCon)\nDESCRIPTION: This snippet demonstrates converting a QubitOperator from OpenFermion to a PennyLane object using `qml.from_openfermion`.  It imports the OpenFermion library, creates a QubitOperator, converts it, and prints the PennyLane representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> of_qubit = 0.5 * openfermion.QubitOperator('X0 X5')\n>>> pl_qubit = qml.from_openfermion(of_qubit)\n>>> print(pl_qubit)\n0.5 * (X(0) @ X(5))\n```\n\n----------------------------------------\n\nTITLE: Quantum Snapshots with qml.Snapshot for Debugging\nDESCRIPTION: This code showcases the usage of `qml.Snapshot` operation to save the internal state of a quantum device during execution. The `qml.snapshots` transform is used to retrieve the intermediate device states alongside the results. The example demonstrates snapshots on a `default.qubit` device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, interface=None)\ndef circuit():\n    qml.Snapshot()\n    qml.Hadamard(wires=0)\n    qml.Snapshot(\"very_important_state\")\n    qml.CNOT(wires=[0, 1])\n    qml.Snapshot()\n    return qml.expval(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: Quantum Gradients with Non-Differentiable Data\nDESCRIPTION: This code shows how to calculate gradients when the QNode includes non-differentiable data. `tf.constant` is used to pass non-differentiable data as arguments to the QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, interface='tf')\ndef circuit3(weights, data):\n    qml.AmplitudeEmbedding(data, normalize=True, wires=[0, 1])\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(weights[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nweights = tf.Variable([0.1, 0.2, 0.3])\nrng = np.random.default_rng(seed=111)\ndata = tf.constant(rng.random([4]))\n\nwith tf.GradientTape() as tape:\n    result = circuit3(weights, data)\n```\n\n----------------------------------------\n\nTITLE: Applying Gradient Transforms to QNodes\nDESCRIPTION: This interactive console snippet demonstrates how to apply a quantum gradient transform (specifically `qml.gradients.param_shift`) to a QNode. The transform computes the gradient of the circuit with respect to its input parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circuit(x):\n...     qml.RX(x, wires=0)\n...     qml.CNOT(wires=[0, 1])\n...     return qml.expval(qml.PauliZ(0))\n>>> circuit(0.3)\ntensor(0.95533649, requires_grad=True)\n>>> qml.gradients.param_shift(circuit)(0.5)\narray([[-0.47942554]])\n```\n\n----------------------------------------\n\nTITLE: Using qml.for_loop with qml.qjit\nDESCRIPTION: This snippet shows how to use `qml.for_loop` decorator within a JIT-compiled PennyLane function. This allows for iterative quantum operations with flexible control flow. Requires PennyLane, JAX and Catalyst.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"lightning.qubit\", wires=1)\n\n@qml.qjit\n@qml.qnode(dev)\ndef circuit(n: int, x: float):\n\n    @qml.for_loop(0, n, 1)\n    def loop_rx(i, x):\n        # perform some work and update (some of) the arguments\n        qml.RX(x, wires=0)\n\n        # update the value of x for the next iteration\n        return jnp.sin(x)\n\n    # apply the for loop\n    final_x = loop_rx(x)\n\n    return qml.expval(qml.PauliZ(0)), final_x\n```\n\n----------------------------------------\n\nTITLE: Initializing Devices with Analytic and Finite Shots in PennyLane\nDESCRIPTION: This code snippet demonstrates how to initialize two quantum devices in PennyLane: one for analytic calculations (shots=None) and another for simulations with a finite number of shots (shots=1000). It then defines a simple quantum circuit and creates two QNodes, one for each device.  This showcases the basic setup for comparing analytic versus stochastic results.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndev_analytic = qml.device('default.qubit', wires=1, shots=None)\ndev_finite_shots = qml.device('default.qubit', wires=1, shots=1000)\n\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliZ(wires=0))\n\ncircuit_analytic = qml.QNode(circuit, dev_analytic)\ncircuit_finite_shots = qml.QNode(circuit, dev_finite_shots)\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Grouping observables using pauli module\nDESCRIPTION: This snippet shows how to group observables using the `qml.pauli.group_observables` function. Grouping compatible observables allows for more efficient measurements and optimization in quantum computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nobs = [X(0) @ Y(1), Z(0), Y(0) @ Z(1), Y(1)]\nqml.pauli.group_observables(obs)\n```\n\n----------------------------------------\n\nTITLE: Operator Nesting Structure in PennyLane\nDESCRIPTION: Illustrates how the nesting structure of PennyLane operator math instances affects their type and operands. Demonstrates different ways to construct equivalent operators and how to use simplify() to bring them to a common format.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> op = 0.5 * (X(0) @ X(1)) + 0.5 * (Y(0) @ Y(1))\n>>> type(op)\npennylane.ops.op_math.sum.Sum\n\n>>> op.operands\n(0.5 * (X(0) @ X(1)), 0.5 * (Y(0) @ Y(1)))\n\n>>> type(op.operands[0]), type(op.operands[1])\n(pennylane.ops.op_math.sprod.SProd, pennylane.ops.op_math.sprod.SProd)\n\n>>> op.operands[0].scalar, op.operands[0].base, type(op.operands[0].base)\n(0.5, X(0) @ X(1), pennylane.ops.op_math.prod.Prod)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> op = (0.5 * X(0)) @ X(1) + (0.5 * Y(0)) @ Y(1)\n>>> op.operands\n((0.5 * X(0)) @ X(1), (0.5 * Y(0)) @ Y(1))\n\n>>> type(op.operands[0]), type(op.operands[1])\n(pennylane.ops.op_math.prod.Prod, pennylane.ops.op_math.prod.Prod)\n\n>>> op.operands[0].operands\n(0.5 * X(0), X(1))\n\n>>> type(op.operands[0].operands[0]), type(op.operands[0].operands[1])\n(pennylane.ops.op_math.sprod.SProd,\n pennylane.ops.qubit.non_parametric_ops.PauliX)\n```\n\n----------------------------------------\n\nTITLE: Adjoint Differentiation in PennyLane\nDESCRIPTION: This code demonstrates the usage of adjoint differentiation to compute the gradient of a quantum circuit. The circuit uses the 'default.qubit' device with shots=None, the 'adjoint' differentiation method, and calculates the gradient of an expectation value. It illustrates a scenario where adjoint differentiation is successfully applied.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef print_grad():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, diff_method='adjoint')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.expval(qml.Z(wires=0))\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Circuit Cutting with Monte Carlo Method in PennyLane\nDESCRIPTION: Demonstrates how to use the `@qml.cut_circuit_mc` transform to cut a quantum circuit into smaller fragments for execution on devices with fewer qubits. This method employs a Monte Carlo approach to simulate the original circuit's samples, allowing for reduced qubit requirements at the cost of increased device executions. The example showcases a 3-qubit circuit being cut into two 2-qubit fragments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.cut_circuit_mc\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(0.89, wires=0)\n    qml.RY(0.5, wires=1)\n    qml.RX(1.3, wires=2)\n\n    qml.CNOT(wires=[0, 1])\n    qml.WireCut(wires=1)\n    qml.CNOT(wires=[1, 2])\n\n    qml.RX(x, wires=0)\n    qml.RY(0.7, wires=1)\n    qml.RX(2.3, wires=2)\n    return qml.sample(wires=[0, 2])\n```\n\n----------------------------------------\n\nTITLE: Gradients with Lightning.qubit and Tape Conversion in PennyLane\nDESCRIPTION: This snippet shows an example of calculating the Jacobian of a QNode on ``lightning.qubit`` with capture enabled. Due to tape conversion requirements, the order of arguments may be important.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax\n\nqml.capture.enable()\n\n@qml.qnode(device=qml.device(\"lightning.qubit\", wires=1))\ndef circuit(x, y):\n    qml.RY(y, 0)\n    qml.RX(x, 0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Decomposing Circuits using a Gate Set in PennyLane\nDESCRIPTION: This code demonstrates how to decompose a quantum circuit using a pre-defined set of allowed gates with `qml.transforms.decompose`. A three-wire circuit containing a Hadamard gate and a Toffoli gate is defined, and the `decompose` transform is applied to decompose it into the allowed gates (Toffoli, RX, and RZ). Since the Hadamard gate is not in the gate set, it will be decomposed into allowed rotation gate operators. This showcases the use of gate sets for circuit decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.transforms import decompose\nfrom functools import partial\n\ndev = qml.device('default.qubit')\nallowed_gates = {qml.Toffoli, qml.RX, qml.RZ}\n\n@partial(decompose, gate_set=allowed_gates)\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=[0])\n    qml.Toffoli(wires=[0,1,2])\n    return qml.expval(qml.Z(0))\n    \n>>> print(qml.draw(circuit)())\n```\n\n----------------------------------------\n\nTITLE: Drawing and Executing Quantum Circuit with Control Flow\nDESCRIPTION: This example shows how to draw and execute a quantum circuit that includes Python control flow. The `qml.draw` function visualizes the circuit structure based on the provided input, while calling the circuit executes the quantum operations determined by the control flow logic. This illustrates the integration of Python control flow into PennyLane's circuit execution model.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)(num_loops=3))\n0: ──H────────┤  State\n1: ──RX(1.00)─┤  State\n2: ──H────────┤  State\n>>> circuit(3)\nArray([0.43879125+0.j        , 0.43879125+0.j        ,\n       0.        -0.23971277j, 0.        -0.23971277j,\n       0.43879125+0.j        , 0.43879125+0.j        ,\n       0.        -0.23971277j, 0.        -0.23971277j], dtype=complex64)\n```\n\n----------------------------------------\n\nTITLE: Quantum Parameter Broadcasting with RX gate\nDESCRIPTION: This snippet shows how to create a batched `qml.RX` gate using parameter broadcasting. A NumPy array is passed as a parameter to the `qml.RX` gate, resulting in a batched operation with a `batch_size` equal to the length of the array. The matrix of the batched operator has an additional leading dimension.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = np.array([0.1, 0.2, 0.3], requires_grad=True)\n>>> op = qml.RX(x, 0)\n>>> op.batch_size\n3\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> np.round(qml.matrix(op), 4)\ntensor([[[0.9988+0.j    , 0.    -0.05j  ],\n         [0.    -0.05j  , 0.9988+0.j    ]],\n        [[0.995 +0.j    , 0.    -0.0998j],\n         [0.    -0.0998j, 0.995 +0.j    ]],\n        [[0.9888+0.j    , 0.    -0.1494j],\n         [0.    -0.1494j, 0.9888+0.j    ]]], requires_grad=True)\n>>> qml.matrix(op).shape\n(3, 2, 2)\n```\n\n----------------------------------------\n\nTITLE: Defining Molecular Hamiltonian for Adaptive VQE\nDESCRIPTION: Defines the molecular Hamiltonian required for the adaptive VQE algorithm. This snippet sets up the molecular geometry and uses `qml.qchem.molecular_hamiltonian` to create the Hamiltonian.  Requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"H\", \"H\", \"H\"]\ngeometry = np.array([[0.01076341, 0.04449877, 0.0],\n                      [0.98729513, 1.63059094, 0.0],\n                      [1.87262415, -0.00815842, 0.0]], requires_grad=False)\nH, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, charge = 1)\n```\n\n----------------------------------------\n\nTITLE: Jitting QNodes with Randomness\nDESCRIPTION: This snippet demonstrates how to use jitting with randomness in PennyLane and JAX. The device and QNode creation are wrapped within a function decorated by ``@jax.jit`` and a ``jax.random.PRNGKey`` is passed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nimport pennylane as qml\n\n\n@jax.jit\ndef sample_circuit(phi, theta, key):\n\n    # Device construction should happen inside a `jax.jit` decorated\n    # method when using a PRNGKey.\n    dev = qml.device('default.qubit', wires=2, seed=key, shots=100)\n\n\n    @qml.qnode(dev, interface='jax', diff_method=None)\n    def circuit(phi, theta):\n        qml.RX(phi[0], wires=0)\n        qml.RZ(phi[1], wires=1)\n        qml.CNOT(wires=[0, 1])\n        qml.RX(theta, wires=0)\n        return qml.sample() # Here, we take samples instead.\n\n    return circuit(phi, theta)\n\n# Get the samples from the jitted method.\nsamples = sample_circuit([0.2, 1.0], 5.2, jax.random.PRNGKey(0))\n```\n\n----------------------------------------\n\nTITLE: Using KerasLayer with AngleEmbedding and StronglyEntanglingLayers\nDESCRIPTION: This code shows how to use the `KerasLayer` in PennyLane with `AngleEmbedding` and `StronglyEntanglingLayers` templates. It defines a quantum circuit `layer` that embeds classical data using `AngleEmbedding` and applies `StronglyEntanglingLayers`. A `KerasLayer` is then created from this circuit and applied to an input tensor `x`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\nx = tf.ones((5, 4, 4))\n\n@qml.qnode(dev)\ndef layer(weights, inputs):\n    qml.templates.AngleEmbedding(inputs, wires=range(4))\n    qml.templates.StronglyEntanglingLayers(weights, wires=range(4))\n    return [qml.expval(qml.PauliZ(i)) for i in range(4)]\n\nqlayer = qml.qnn.KerasLayer(layer, {\"weights\": (4, 4, 3)}, output_dim=4)\nout = qlayer(x)\n```\n\n----------------------------------------\n\nTITLE: Defining a Simple Quantum Circuit\nDESCRIPTION: This code defines a simple quantum circuit using PennyLane. It imports the necessary libraries, defines a device, and creates a QNode that applies RX and RY rotations, a CNOT gate, and measures the expectation value of PauliZ on qubit 0.  The circuit is parameterized by a single parameter 'x'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef simple_circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[0], wires=1)\n    qml.CNOT(wires=[1, 0])\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Qiskit to PennyLane: Converting a simple circuit with measurements\nDESCRIPTION: This snippet demonstrates how to convert a simple Qiskit circuit into a PennyLane QNode using `qml.from_qiskit`, including PennyLane measurements. It showcases the ease of incorporating measurements into the converted quantum function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom qiskit import QuantumCircuit\n\nqc = QuantumCircuit(2)\nqc.rx(0.785, 0)\nqc.ry(1.57, 1)\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom PennyLane Device in Python\nDESCRIPTION: This code demonstrates how to define a custom device in PennyLane by inheriting from the Device class and overriding the execute method.  The execute method is the main entry point for running quantum circuits on the device.  It takes a QuantumScriptOrBatch as input and returns the results of the execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.devices import Device, DefaultExecutionConfig\nfrom pennylane.tape import QuantumScript, QuantumScriptOrBatch\n\nclass MyDevice(Device):\n    \"\"\"My Documentation.\"\"\"\n\n    def execute(\n        self,\n        circuits: QuantumScriptOrBatch,\n        execution_config: \"ExecutionConfig\" = DefaultExecutionConfig\n    ):\n        # your implementation here.\n```\n\n----------------------------------------\n\nTITLE: Configuring PennyLane settings using TOML\nDESCRIPTION: This snippet shows an example of a config.toml file, which configures global PennyLane options, as well as plugin and plugin device-specific options. The TOML file is organized into sections for main, strawberryfields, qiskit configurations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/configuration.rst#_snippet_1\n\nLANGUAGE: TOML\nCODE:\n```\n[main]\n# Global PennyLane options.\n# Affects every loaded plugin if applicable.\nshots = 1000\n\n[strawberryfields.global]\n# Options for the Strawberry Fields plugin\n# For more details, see the PennyLane-SF documentation:\n# https://pennylane-sf.readthedocs.io\nhbar = 2\nshots = 100\n\n    [strawberryfields.fock]\n    # Options for the strawberryfields.fock device\n    cutoff_dim = 10\n    hbar = 2\n\n    [strawberryfields.gaussian]\n    # Indentation doesn't matter in TOML files,\n    # but helps provide clarity.\n\n[qiskit.global]\n# Global options for the Qiskit plugin.\n# For more details, see the PennyLane-Qiskit documentation:\n# https://pennylaneqiskit.readthedocs.io/en/latest/index.html\n\nbackend = \"qasm_simulator\"\n\n    [qiskit.aer]\n    # Default options for Qiskit Aer\n\n    # set the default backend options for the Qiskit Aer device\n    # Note that, in TOML, dictionary key-value pairs are defined\n    # using '=' rather than ':'.\n    backend_options = {\"validation_threshold\" = 1e-6}\n\n    [qiskit.ibmq]\n    # Default options for IBMQ\n\n    # IBM Quantum Experience authentication token\n    ibmqx_token = \"XXX\"\n\n    # hardware backend device\n    backend = \"ibmq_rome\"\n\n    # pass (optional) provider information\n    hub = \"MYHUB\"\n    group = \"MYGROUP\"\n    project = \"MYPROJECT\"\n```\n\n----------------------------------------\n\nTITLE: Decomposing in Stages in PennyLane\nDESCRIPTION: Shows how to use the max_expansion argument to control the number of decomposition stages applied to the circuit. \nBy default, the function will decompose the circuit until the desired gate set is reached.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nphase = 1 \ntarget_wires = [0]\nunitary = qml.RX(phase, wires=0).matrix()\nn_estimation_wires = 3\nestimation_wires = range(1, n_estimation_wires + 1)\n\n@qml.qnode(qml.device('default.qubit'))\ndef circuit():\n    # Start in the |+> eigenstate of the unitary\n```\n\n----------------------------------------\n\nTITLE: Qiskit to PennyLane: Handling Parameterized Qiskit Circuits\nDESCRIPTION: This snippet demonstrates how to convert parameterized Qiskit circuits into PennyLane QNodes. It highlights the process of handling parameters defined in Qiskit and passing them as arguments to the resulting PennyLane QNode, allowing for differentiation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit.circuit import Parameter\nfrom pennylane import numpy as np\n\nangle0 = Parameter(\"x\")\nangle1 = Parameter(\"y\")\n\nqc = QuantumCircuit(2, 2)\nqc.rx(angle0, 0)\nqc.ry(angle1, 1)\nqc.cx(1, 0)\n```\n\n----------------------------------------\n\nTITLE: QNode with JAX Interface\nDESCRIPTION: Demonstrates creating a QNode with the JAX interface in PennyLane, allowing the use of JAX for creating, differentiating, and optimizing hybrid quantum-classical models. Requires PennyLane and JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n@qml.qnode(dev, interface=\"jax\", diff_method=\"backprop\")\ndef circuit(x):\n    qml.RX(x[1], wires=0)\n    qml.Rot(x[0], x[1], x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nweights = jnp.array([0.2, 0.5, 0.1])\ngrad_fn = jax.grad(circuit)\nprint(grad_fn(weights))\n```\n\n----------------------------------------\n\nTITLE: Executing batched partial circuit\nDESCRIPTION: This demonstrates how to use the circuit generated by `qml.batch_partial`.  The x parameter is set to a fixed value np.pi / 4 and the circuit is executed for various values of y.  The result is a tensor of expectation values, with each value corresponding to one of the values of y.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> batched_partial_circuit = qml.batch_partial(circuit, x=np.array(np.pi / 4))\n>>> y = np.array([0.2, 0.3, 0.4])\n>>> batched_partial_circuit(y=y)\ntensor([0.69301172, 0.67552491, 0.65128847], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Quantum Function with Operators in PennyLane\nDESCRIPTION: This code defines a quantum function that applies several quantum gates and a noisy channel, then returns the expectation value of a PauliZ observable. It uses PennyLane's RZ, CNOT, RY gates, AmplitudeDamping channel, and PauliZ observable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0,1])\n    qml.RY(y, wires=1)\n    qml.AmplitudeDamping(0.1, wires=0)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Sparse Matrix Representation in PennyLane\nDESCRIPTION: Illustrates how to obtain the sparse matrix representation of a `qml.SparseHamiltonian` operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.sparse.coo import coo_matrix\nimport numpy as np\nrow = np.array([0, 1])\ncol = np.array([1, 0])\ndata = np.array([1, -1])\nmat = coo_matrix((data, (row, col)), shape=(4, 4))\nop = qml.SparseHamiltonian(mat, wires=[\"a\"])\nop.sparse_matrix(wire_order=[\"a\"])\n```\n\n----------------------------------------\n\nTITLE: Reconstructing QNodes with Fourier Series in PennyLane\nDESCRIPTION: This snippet shows how to reconstruct a QNode outputting expectation values along a specified parameter dimension using the `qml.fourier.reconstruct` function. The reconstruction is exact and purely classical, enabling evaluation without quantum executions. The example defines a QNode with scalar and array-valued inputs and reconstructs it with respect to the scalar input.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x, Y, f=1.0):\n    qml.RX(f * x, wires=0)\n    qml.RY(Y[0], wires=0)\n    qml.RY(Y[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(3 * Y[1], wires=1)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Von Neumann Entropy Calculation with PennyLane\nDESCRIPTION: This code demonstrates how to calculate the Von Neumann entropy using PennyLane's `qml.vn_entropy` measurement. It defines a quantum circuit with an IsingXX gate and then computes the entropy of a specified wire. The log_base parameter allows for specifying the base of the logarithm used in the entropy calculation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> @qml.qnode(dev)\n... def circuit_entropy(x):\n...     qml.IsingXX(x, wires=[0,1])\n...     return qml.vn_entropy(wires=[0], log_base=2)\n>>> circuit_entropy(np.pi/2)\n1.0\n```\n\n----------------------------------------\n\nTITLE: Basis Rotation Template in PennyLane\nDESCRIPTION: This code defines a quantum circuit using the `qml.BasisRotation` template to perform a basis transformation. It constructs a unitary matrix from eigenvectors of a given matrix and applies the basis rotation followed by RZ rotations and an adjoint basis rotation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nV = np.array([[ 0.53672126+0.j        , -0.1126064 -2.41479668j],\n              [-0.1126064 +2.41479668j,  1.48694623+0.j        ]])\neigen_vals, eigen_vecs = np.linalg.eigh(V)\numat = eigen_vecs.T\nwires = range(len(umat))\ndef circuit():\n    qml.adjoint(qml.BasisRotation(wires=wires, unitary_matrix=umat))\n    for idx, eigenval in enumerate(eigen_vals):\n        qml.RZ(eigenval, wires=[idx])\n    qml.BasisRotation(wires=wires, unitary_matrix=umat)\n```\n\n----------------------------------------\n\nTITLE: Multiple Non-Commuting Observables in QNode\nDESCRIPTION: This snippet demonstrates the ability to measure expectation values of multiple non-commuting observables within a single QNode. It defines a QNode that applies RX and RZ rotations to a qubit and then measures the expectation values of PauliX and PauliY. This showcases the enhanced functionality of PennyLane in handling non-commuting observables.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=1)\n>>> @qml.qnode(dev)\n... def circuit_rx(x, z):\n...     qml.RX(x, wires=0)\n...     qml.RZ(z, wires=0)\n...     return qml.expval(qml.PauliX(0)), qml.expval(qml.PauliY(0))\n```\n\n----------------------------------------\n\nTITLE: Defer Measurements Transform Example (pycon)\nDESCRIPTION: This code demonstrates how to use the `defer_measurements` transform in PennyLane to defer mid-circuit measurements to the end of the circuit. It applies the transform to a QNode and then executes it with some parameters, showing the differentiable output.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> deferred_qnode = qml.defer_measurements(my_qnode)\n>>> pars = np.array([0.643, 0.246])\n>>> deferred_qnode(*pars)\n(tensor([0.90165331, 0.09834669], requires_grad=True),\n tensor(0.09984972, requires_grad=True))\n```\n\n----------------------------------------\n\nTITLE: Natural Gradient Calculation\nDESCRIPTION: This code snippet shows how to compute the natural gradient and quantum natural gradient using the classical and quantum Fisher information matrices.  It calculates the standard gradient and then applies the Fisher information matrices to obtain the natural gradients, showcasing their impact on optimization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> grad = qml.grad(circ)(params)\n>>> cfim @ grad  # natural gradient\n[ 5.94225615e-01 -2.61509542e-02 -1.18674655e-18]\n>>> qfim @ grad  # quantum natural gradient\n[ 0.59422561 -0.02615095 -0.03989212]\n```\n\n----------------------------------------\n\nTITLE: Inspecting QNode Parameters\nDESCRIPTION: Illustrates how QNode arguments are no longer wrapped as Variable objects, allowing for direct inspection and manipulation of internal QNode parameters.  This example prints the value of the input parameter 'x' within the QNode. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    print(\"Parameter value:\", x)\n    qml.RX(x, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Simulation with TrotterProduct in PennyLane\nDESCRIPTION: This code demonstrates the use of `TrotterProduct` operation in PennyLane for Hamiltonian simulation. Higher-order Trotter-Suzuki methods can be implemented by specifying the `order` and evolution `time`. The example defines a Hamiltonian `H` as a linear combination of Pauli operators and evolves an initial state under this Hamiltonian using `TrotterProduct`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [0.25, 0.75]\nops = [qml.PauliX(0), qml.PauliZ(0)]\nH = qml.dot(coeffs, ops)\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(0)\n    qml.TrotterProduct(H, time=2.4, order=2)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Drawing at Device Level (Python)\nDESCRIPTION: This code demonstrates visualizing a quantum circuit at the 'device' level, showing the circuit after device-specific preprocessing transforms have been applied.  It defines a simple circuit with BasicEntanglerLayers and then prints the device-level drawing using `qml.draw`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 3\nx = np.random.random((2, n_wires))\n\n@qml.qnode(qml.device(\"default.qubit\"))\ndef f():\n    qml.BasicEntanglerLayers(x, range(n_wires))\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Drawing Conditional Circuit for different input\nDESCRIPTION: This shows how `qml.draw` can visualize the circuit based on the result of `qml.cond`. When the input is 3.8, the RX gate is used and drawn. When the input is 0.54, RZ gate is used.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)(3.8))\n0: ──RX(3.80)─┤  Probs\n>>> print(qml.draw(circuit)(0.54))\n0: ──RZ(0.54)─┤  Probs\n```\n\n----------------------------------------\n\nTITLE: Creating Operator Pool for Adaptive VQE\nDESCRIPTION: Creates the operator pool (single and double excitations) for the adaptive VQE algorithm. It uses `qml.qchem.excitations` to generate the excitations and then creates the corresponding PennyLane operations.  Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nn_electrons = 2\nsingles, doubles = qml.qchem.excitations(n_electrons, qubits)\nsingles_excitations = [qml.SingleExcitation(0.0, x) for x in singles]\ndoubles_excitations = [qml.DoubleExcitation(0.0, x) for x in doubles]\noperator_pool = doubles_excitations + singles_excitations\n```\n\n----------------------------------------\n\nTITLE: Efficient Multi-Qubit Control Decomposition (Python)\nDESCRIPTION: This code demonstrates a more efficient decomposition of single-qubit operations with multi-qubit control using fewer CNOT gates. It utilizes `qml.ops.ctrl_decomp_bisect` and prints the resulting circuit diagram after device expansion. It requires `numpy`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nwires = [0, 1, 2, 3, 4, 5]\ncontrol_wires = wires[1:]\n\n@qml.qnode(qml.device('default.qubit', wires=6))\ndef circuit():\n    with qml.QueuingManager.stop_recording():\n        # the decomposition does not un-queue the target\n        target = qml.RX(np.pi/2, wires=0)\n    qml.ops.ctrl_decomp_bisect(target, (1, 2, 3, 4, 5))\n    return qml.state()\n\nprint(qml.draw(circuit, expansion_strategy=\"device\")())\n```\n\n----------------------------------------\n\nTITLE: Computing Higher-Order Derivatives with Gradient Transforms\nDESCRIPTION: This code snippet shows how to compute higher-order derivatives (Hessian) using gradient transforms in PennyLane.  It uses the `param_shift` gradient transform and demonstrates how to stack the results of the gradient transform to compute the Hessian using `qml.jacobian`. The example uses the `default.qubit` device and requires the `pennylane` and `numpy` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(weights[2], wires=1)\n    return qml.expval(qml.PauliZ(1))\n\nweights = np.array([0.1, 0.2, 0.3], requires_grad=True)\ncircuit(weights)\nqml.gradients.param_shift(circuit)(weights)  # gradient\n\ndef f(weights):\n    return np.stack(qml.gradients.param_shift(circuit)(weights))\n\nqml.jacobian(f)(weights)  # hessian\n```\n\n----------------------------------------\n\nTITLE: QNode Specifications with qml.specs Transform\nDESCRIPTION: This code demonstrates the use of the `qml.specs` transform to generate a function that returns specifications and resource information about a QNode, such as depth, number of gates, and number of gradient executions required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=4)\n\n@qml.qnode(dev, diff_method='parameter-shift')\ndef circuit(x, y):\n    qml.RX(x[0], wires=0)\n    qml.Toffoli(wires=(0, 1, 2))\n    qml.CRY(x[1], wires=(0, 1))\n    qml.Rot(x[2], x[3], y, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliX(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> x = np.array([0.05, 0.1, 0.2, 0.3], requires_grad=True)\n>>> y = np.array(0.4, requires_grad=False)\n>>> specs_func = qml.specs(circuit)\n>>> specs_func(x, y)\n{'gate_sizes': defaultdict(int, {1: 2, 3: 1, 2: 1}),\n 'gate_types': defaultdict(int, {'RX': 1, 'Toffoli': 1, 'CRY': 1, 'Rot': 1}),\n 'num_operations': 4,\n 'num_observables': 2,\n 'num_diagonalizing_gates': 1,\n 'num_used_wires': 3,\n 'depth': 4,\n 'num_trainable_params': 4,\n 'num_parameter_shift_executions': 11,\n 'num_device_wires': 4,\n 'device_name': 'default.qubit',\n 'diff_method': 'parameter-shift'}\n```\n\n----------------------------------------\n\nTITLE: Defining a Resource Function for Dynamic Resource Requirements in Python\nDESCRIPTION: This example illustrates how to define a resource function for operators with dynamic resource requirements using `qml.resource_rep`.  It shows how custom decompositions should be registered to a resource function that accepts specific arguments and returns a dictionary of resource estimates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nqml.decomposition.enable_graph()\n\ndef resource_fn(num_wires):\n    return {\n        qml.resource_rep(qml.MultiRZ, num_wires=num_wires - 1): 1,\n        qml.resource_rep(qml.MultiRZ, num_wires=3): 2\n    }\n  \n@qml.register_resources(resource_fn)\ndef my_decomp(theta, wires):\n    qml.MultiRZ(theta, wires=wires[:3])\n    qml.MultiRZ(theta, wires=wires[1:])\n    qml.MultiRZ(theta, wires=wires[:3])\n```\n\n----------------------------------------\n\nTITLE: Executing and Differentiating Pulse-Based Circuits on JAX Simulator in Pycon\nDESCRIPTION: This example shows how to execute and differentiate a pulse-based circuit on the `default.qubit.jax` simulator using JAX. It defines a QNode using the `pulse_circuit`, executes it with specific parameters and time, and then calculates the gradient of the circuit with respect to the parameters using `jax.grad`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit.jax\", wires=2)\n>>> qnode = qml.QNode(pulse_circuit, dev, interface=\"jax\")\n>>> params = (p1, p2)\n>>> qnode(params, time=0.5)\nArray(0.72153819, dtype=float64)\n>>> jax.grad(qnode)(params, time=0.5)\n(Array(-0.11324919, dtype=float64),\n Array([-0.64399616,  0.06326374], dtype=float64))\n```\n\n----------------------------------------\n\nTITLE: Pauli Decomposition of a Matrix in PennyLane\nDESCRIPTION: This code demonstrates how to decompose a matrix into a linear combination of Pauli operators using PennyLane. It converts a given matrix into a PennyLane operator represented as a linear combination of Pauli operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nmat = np.array([[1, 1], [1, -1]])\nh = qml.pauli_decompose(mat)\ntype(h)\n```\n\nLANGUAGE: python\nCODE:\n```\nprint(h)\n```\n\n----------------------------------------\n\nTITLE: Calculate Structure Constants of DLA\nDESCRIPTION: Computes the structure constants (adjoint representation) of a dynamical Lie algebra using `qml.structure_constants`. Structure constants represent how elements of the DLA transform under commutation, providing a useful representation of the DLA's algebraic structure. Requires a list of operators forming the DLA as input.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> dla = [X(0) @ X(1), Z(0), Z(1), Y(0) @ X(1), X(0) @ Y(1), Y(0) @ Y(1)]\n>>> structure_const = qml.structure_constants(dla)\n>>> structure_const.shape\n(6, 6, 6)\n```\n\n----------------------------------------\n\nTITLE: List Comprehension with Expectation Values in PennyLane\nDESCRIPTION: This code uses a list comprehension to return a list of expectation values of PauliZ on different wires. This demonstrates a Pythonic way to perform multiple similar measurements within a quantum function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    return [qml.expval(qml.PauliZ(i)) for i in range(2)]\n```\n\n----------------------------------------\n\nTITLE: Compiling Quantum Circuits with qml.compile (Python)\nDESCRIPTION: Demonstrates how to use the `qml.compile` transform to optimize quantum circuits in PennyLane. It chains together tape and quantum function transforms to create custom optimization pipelines, applying a default sequence of commute_controlled, cancel_inverses, and merge_rotations. Requires PennyLane installation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=[0, 1, 2])\n\n@qml.qnode(dev)\n@qml.compile()\ndef qfunc(x, y, z):\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    qml.Hadamard(wires=2)\n    qml.RZ(z, wires=2)\n    qml.CNOT(wires=[2, 1])\n    qml.RX(z, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RZ(-z, wires=2)\n    qml.RX(y, wires=2)\n    qml.PauliY(wires=2)\n    qml.CZ(wires=[1, 2])\n    return qml.expval(qml.PauliZ(wires=0))\n```\n\n----------------------------------------\n\nTITLE: Loading Specific Attributes of a Dataset\nDESCRIPTION: This snippet demonstrates loading only specific attributes ('molecule' and 'fci_energy') of the 'qchem' dataset. The `attributes` parameter of `qml.data.load` specifies the desired properties.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npart = qml.data.load(\"qchem\", molname=\"H2\", basis=\"STO-3G\", bondlength=1.1, \n                     attributes=[\"molecule\", \"fci_energy\"])[0]\npart.molecule\npart.fci_energy\n```\n\n----------------------------------------\n\nTITLE: JAX-JIT Gradient Computation with PennyLane\nDESCRIPTION: Demonstrates JAX-JIT support for computing gradients of QNodes that return a single vector of probabilities or multiple expectation values. Requires PennyLane, JAX, and lightning.qubit device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nfrom jax import numpy as jnp\nfrom jax.config import config\nconfig.update(\"jax_enable_x64\", True)\n\ndev = qml.device(\"lightning.qubit\", wires=2)\n\n@jax.jit\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"jax\")\ndef circuit(x, y):\n    qml.RY(x, wires=0)\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\nx = jnp.array(1.0)\ny = jnp.array(2.0)\n```\n\n----------------------------------------\n\nTITLE: Expectation Value of Tensor Product in PennyLane\nDESCRIPTION: This code snippet shows how to measure the expectation value of a tensor product of observables (Z ⊗ I ⊗ X) using the `@` operator. It demonstrates the syntax for specifying tensor observables in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_4\n\nLANGUAGE: python3\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RY(y, wires=1)\n    qml.CNOT(wires=[0, 2])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliX(2))\n```\n\n----------------------------------------\n\nTITLE: Defining a Quantum Fourier Transform (QFT) Circuit in PennyLane\nDESCRIPTION: This code defines a quantum circuit that applies the Quantum Fourier Transform (QFT) to a given basis state. The `circuit_qft` function uses `qml.BasisState` to initialize the qubits and then applies the `qml.templates.QFT` operation. The state of the qubits after the QFT is returned.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit_qft(basis_state):\n    qml.BasisState(basis_state, wires=range(3))\n    qml.templates.QFT(wires=range(3))\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Mapping Fermionic Operator to Qubit Basis with Jordan-Wigner in PennyLane\nDESCRIPTION: Demonstrates how to map a fermionic operator (Fermi sentence) to the qubit basis using `qml.jordan_wigner`. This transformation is essential for simulating fermionic systems on quantum computers.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.jordan_wigner(sentence)\n((0.4725+0j)*(Identity(wires=[0]))) + ((-0.4725+0j)*(PauliZ(wires=[3]))) + ((-0.3+0j)*(PauliZ(wires=[0]))) + ((0.3+0j)*(PauliZ(wires=[0]) @ PauliZ(wires=[3])))\n```\n\n----------------------------------------\n\nTITLE: QAOA Circuit Definition - Python\nDESCRIPTION: This code snippet defines the full QAOA circuit, including the initialization of qubits in an equal superposition state and the application of multiple QAOA layers. The `qml.layer` function is used to repeat the `qaoa_layer` with different parameters from the input `params` array.  The number of layers is hardcoded as 2 in this specific example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Repeatedly applies layers of the QAOA ansatz\ndef circuit(params):\n\n    for w in wires:\n        qml.Hadamard(wires=w)\n\n    qml.layer(qaoa_layer, 2, params[0], params[1])\n```\n\n----------------------------------------\n\nTITLE: JAX-JIT Interface with Parameter-Shift Differentiation in PennyLane\nDESCRIPTION: This example shows how to use the JAX-JIT interface with parameter-shift differentiation for a PennyLane quantum circuit. It includes enabling return values, defining a QNode with the `jax-jit` interface, and using `jax.jacobian` to compute the gradient. Requires PennyLane, JAX, and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nfrom jax import numpy as jnp\n\njax.config.update(\"jax_enable_x64\", True)\n\nqml.enable_return()\n\ndev = qml.device(\"lightning.qubit\", wires=2)\n\n@jax.jit\n@qml.qnode(dev, interface=\"jax-jit\", diff_method=\"parameter-shift\")\ndef circuit(a, b):\n    qml.RY(a, wires=0)\n    qml.RX(b, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))\n\na, b = jnp.array(1.0), jnp.array(2.0)\n```\n\n----------------------------------------\n\nTITLE: Defining a Quantum Circuit with Weights\nDESCRIPTION: This code defines a quantum circuit with trainable weights using PennyLane. It uses `partial` from `functools` to bind the `weights` to the circuit function. The circuit applies RX and RY rotations, a CNOT gate, Rot gates with trainable weights, and another CNOT gate, finally returning the expectation value of PauliZ on qubit 0. The x values are assumed to be distinct parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\n\nweights = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\n\n@qml.qnode(dev)\ndef circuit_with_weights(w, x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=1)\n    qml.CNOT(wires=[1, 0])\n\n    qml.Rot(*w[0], wires=0)\n    qml.Rot(*w[1], wires=1)\n    qml.CNOT(wires=[1, 0])\n\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=1)\n    qml.CNOT(wires=[1, 0])\n\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Minimum Entropy Calculation in PennyLane\nDESCRIPTION: This code calculates the minimum entropy of a density matrix using functions available in 'pennylane.math'. It first creates a density matrix from a state vector and then calculates the minimum entropy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_17\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = [1, 0, 0, 1] / np.sqrt(2)\n>>> x = qml.math.dm_from_state_vector(x)\n>>> qml.math.min_entropy(x, indices=[0])\n0.6931471805599455\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading a TorchLayer\nDESCRIPTION: This example demonstrates how to save and load the state dictionary of a PennyLane `TorchLayer` using `torch.save` and `torch.load`. It also sets the `TorchLayer` to evaluation mode (`qlayer.eval()`) after loading the weights. Note this example is referencing a TorchLayer `qlayer` defined earlier.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> torch.save(qlayer.state_dict(), \"weights.pt\")  # Saving\n>>> qlayer.load_state_dict(torch.load(\"weights.pt\"))  # Loading\n>>> qlayer.eval()\n```\n\n----------------------------------------\n\nTITLE: Qiskit to PennyLane: Using Qiskit measurements in PennyLane QNode\nDESCRIPTION: This snippet shows how to define a PennyLane QNode that utilizes a Qiskit circuit with measurements, showcasing how to use the measurement results from the Qiskit circuit within the PennyLane QNode for further computations, such as conditional operations. Device 'dev' must be defined beforehand.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef teleport():\n    m0, m1 = qml.from_qiskit(qc)()\n    qml.cond(m0, qml.Z)(2)\n    return qml.density_matrix(2)\n```\n\n----------------------------------------\n\nTITLE: Example of Missing _unflatten Implementation Error\nDESCRIPTION: This code block demonstrates the error that is raised when the custom operator omits the `_unflatten` custom definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Default Qubit Device Usage with PennyLane\nDESCRIPTION: This code demonstrates the usage of the updated `default.qubit` device in PennyLane. The number of wires is now optional; if wires are not provided at instantiation, the device automatically infers the required number of wires for each circuit provided for execution. The code demonstrates creating a circuit with operations on different wires without explicitly specifying the number of wires during device instantiation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    qml.PauliZ(0)\n    qml.RZ(0.1, wires=1)\n    qml.Hadamard(2)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: GlobalPhase Example with QNode in PennyLane\nDESCRIPTION: This code demonstrates how to use the `qml.GlobalPhase` operator within a `QNode` in PennyLane. It defines a quantum circuit that applies a global phase and returns the state. This example was previously failing due to a validation issue, which has now been resolved. The `qml.qnode` decorator turns the circuit function into a quantum node that is executed on a device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('default.qubit', wires=2))\ndef circuit(x):\n    qml.GlobalPhase(x, wires=0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Merging Amplitude Embedding Gates with PennyLane Transform\nDESCRIPTION: This snippet demonstrates how to use the `merge_amplitude_embedding` transformation to automatically merge all AmplitudeEmbedding gates into one. This can simplify circuits and potentially improve performance. The example defines a QNode with multiple AmplitudeEmbedding gates and applies the transformation to merge them.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.transforms import merge_amplitude_embedding\n\ndev = qml.device(\"default.qubit\", wires = 3)\n  \n@qml.qnode(dev)\n@merge_amplitude_embedding\ndef qfunc():\n    qml.AmplitudeEmbedding([0,1,0,0], wires = [0,1])\n    qml.AmplitudeEmbedding([0,1], wires = 2)\n    return qml.expval(qml.PauliZ(wires = 0))\n```\n\n----------------------------------------\n\nTITLE: QNode-Level Parameter-Shift Gradients with Broadcasting in PennyLane\nDESCRIPTION: This code demonstrates how to enable broadcasting gradients at the QNode level. The QNode is decorated with `diff_method=\"parameter-shift\"` and `broadcast=True`.  This can improve performance when computing gradients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, diff_method=\"parameter-shift\", broadcast=True)\ndef circuit(x, y):\n    qml.RX(x, wires=0)\n    qml.RY(y, wires=1)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Expansion Transform\nDESCRIPTION: This snippet demonstrates the `hamiltonian_expand` tape transform, which takes a tape ending in `qml.expval(H)`, where `H` is a Hamiltonian, and maps it to a collection of tapes which can be executed and passed into a post-processing function yielding the expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nH = qml.PauliZ(0) + 3 * qml.PauliZ(0) @ qml.PauliX(1)\n\nwith qml.tape.QuantumTape() as tape:\n    qml.Hadamard(wires=1)\n    qml.expval(H)\n\ntapes, fn = qml.transforms.hamiltonian_expand(tape)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=3)\n>>> res = dev.batch_execute(tapes)\n>>> fn(res)\n3.999999999999999\n```\n\n----------------------------------------\n\nTITLE: Inspecting ParametrizedHamiltonian and Evaluating with Parameters in Pycon\nDESCRIPTION: This snippet shows how to inspect the created `ParametrizedHamiltonian` and evaluate it with specific parameter values at a given time. The parameters `p1` and `p2` are defined as JAX arrays, and the Hamiltonian is evaluated using these parameters and a time value of 0.5.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> H\nParametrizedHamiltonian: terms=3\n>>> p1 = jnp.array(1.2)\n>>> p2 = jnp.array([2.3, 3.4])\n>>> H((p1, p2), t=0.5)\n(2*(PauliZ(wires=[0]) @ PauliZ(wires=[1]))) + ((-0.2876553231625218*(PauliX(wires=[0]) @ PauliX(wires=[1]))) + (1.517961235535459*(PauliY(wires=[0]) @ PauliY(wires=[1]))))\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Interface with Shot Vectors in PennyLane\nDESCRIPTION: This example demonstrates the use of the TensorFlow interface with shot vectors enabled in PennyLane using `qml.enable_return()`. It includes defining a quantum circuit using PennyLane operations, executing the circuit with TensorFlow variables, and calculating gradients using TensorFlow's `GradientTape`. Requires PennyLane, TensorFlow, and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport tensorflow as tf\nqml.enable_return()\n\ndev = qml.device(\"default.qubit\", wires=2, shots=[1000, 2000, 3000])\n\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\ndef circuit(a):\n    qml.RY(a, wires=0)\n    qml.RX(0.2, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.probs([0, 1])\n```\n\n----------------------------------------\n\nTITLE: Time-Dependent Hamiltonian in PennyLane Circuit (Python)\nDESCRIPTION: This snippet shows how to use a time-dependent Hamiltonian `H` in a PennyLane pulse-level differentiable circuit. It defines a quantum node using `qml.qnode` and applies the `qml.evolve` operation with the Hamiltonian and time parameters, returning the expectation value of `qml.PauliZ(0)`. The circuit uses the 'jax' interface.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit.jax\", wires=wires)\n\n@qml.qnode(dev, interface=\"jax\")\ndef circuit(params):\n    qml.evolve(H)(params, t=[0, 10])\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Define a Qiskit SparsePauliOp\nDESCRIPTION: This code defines a `SparsePauliOp` operator using Qiskit. The operator is a linear combination of Pauli strings, in this case 'II' and 'XY', each with a coefficient of 1.  This object can then be converted to a PennyLane operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit.quantum_info import SparsePauliOp\n\nqk_op = SparsePauliOp([\"II\", \"XY\"])\n```\n\n----------------------------------------\n\nTITLE: Sampling PauliZ on a Bell State with PennyLane\nDESCRIPTION: This example creates a Bell state using Hadamard and CNOT gates and then measures the samples of PauliZ on both qubits. It demonstrates how to set up a quantum device, define a QNode, and sample measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.sample(qml.PauliZ(0)), qml.sample(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Import Quantum Chemistry State\nDESCRIPTION: This code demonstrates how to import a state vector from a PySCF solver object using qml.qchem.import_state and then use it in a PennyLane circuit with qml.StatePrep. It calculates the Hartree-Fock and Configuration Interaction (CI) wave functions using PySCF and imports the CISD state. Dependencies: PennyLane, PySCF.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> from pyscf import gto, scf, ci\n>>> mol = gto.M(atom=[['H', (0, 0, 0)], ['H', (0,0,0.71)]], basis='sto6g')\n>>> myhf = scf.UHF(mol).run()\n>>> myci = ci.UCISD(myhf).run()\n>>> wf_cisd = qml.qchem.import_state(myci, tol=1e-1)\n>>> print(wf_cisd)\n[ 0.        +0.j  0.        +0.j  0.        +0.j  0.1066467 +0.j\n  1.        +0.j  0.        +0.j  0.        +0.j  0.        +0.j\n  2.        +0.j  0.        +0.j  0.        +0.j  0.        +0.j\n -0.99429698+0.j  0.        +0.j  0.        +0.j  0.        +0.j]\n```\n\n----------------------------------------\n\nTITLE: Ctrl Transform in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.ctrl` transform in PennyLane to add control wires to subroutines. It defines a quantum ansatz and creates a new controlled operation using `qml.ctrl`, effectively applying the ansatz conditioned on the state of the control wire.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef my_ansatz(params):\n   qml.RX(params[0], wires=0)\n   qml.RZ(params[1], wires=1)\n\n# Create a new operation that applies `my_ansatz`\n# controlled by the \"2\" wire.\nmy_ansatz2 = qml.ctrl(my_ansatz, control=2)\n\n@qml.qnode(dev)\ndef circuit(params):\n    my_ansatz2(params)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Constructing Fermi Words Directly in PennyLane\nDESCRIPTION: Shows how to create Fermi words directly using the `qml.FermiWord` class. The Fermi word is defined by a dictionary where keys are tuples representing the operator's position and orbital, and values are '+' for creation and '-' for annihilation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.FermiWord({(0, 0): '+', (1, 3): '-', (2, 1): '+'})\na⁺(0) a(3) a⁺(1)\n```\n\n----------------------------------------\n\nTITLE: QuantumScript Initialization Example\nDESCRIPTION: Demonstrates the initialization of a QuantumScript with operations and measurements.  The QuantumScript is created with a PauliX gate on wire 0 and a PauliZ expectation value measurement on wire 0, with 10 shots. The contents of a QuantumScript are immutable after initialization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_tape.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nops = [qml.PauliX(0)]\nmeasurements = [qml.expval(qml.PauliZ(0))]\nQuantumScript(ops, measurements, shots=10)\n```\n\n----------------------------------------\n\nTITLE: Qubit Reuse with Mid-Circuit Measurement and Reset\nDESCRIPTION: This code demonstrates qubit reuse with mid-circuit measurement and reset in PennyLane. The circuit measures a qubit (wire 0), resets it to the |0> state, and then reuses it. It also uses conditional operations based on the measurement outcome. Dependencies: PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit(p):\n    qml.RX(p, wires=0)\n    m = qml.measure(0, reset=True) \n    qml.cond(m, qml.Hadamard)(1)\n\n    qml.RX(p, wires=0)\n    m = qml.measure(0)\n    qml.cond(m, qml.Hadamard)(1)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit hooks in Bash\nDESCRIPTION: Installs the pre-commit hooks for the PennyLane repository. This configures git to run automated code checks before each commit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/pullrequests.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npre-commit install\n```\n\n----------------------------------------\n\nTITLE: Using the qml.layer Template Constructor\nDESCRIPTION: Illustrates the usage of the `qml.layer` template-constructing function, which repeatedly applies a unitary subroutine on a set of wires to a given depth. The code defines a simple quantum subroutine and then uses `qml.layer` to apply it multiple times in a quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef subroutine():\n    qml.Hadamard(wires=[0])\n    qml.CNOT(wires=[0, 1])\n    qml.PauliX(wires=[1])\n\ndev = qml.device('default.qubit', wires=3)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.layer(subroutine, 3)\n    return [qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliZ(1))]\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n>>> print(circuit.draw())\n0: ──H──╭C──X──H──╭C──X──H──╭C──X──┤ ⟨Z⟩\n1: ─────╰X────────╰X────────╰X─────┤ ⟨Z⟩\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Simulation with QDrift in PennyLane\nDESCRIPTION: This code demonstrates the use of `QDrift` operation in PennyLane for Hamiltonian simulation using random product formulas. `QDrift` samples from the Hamiltonian terms with a probability based on the Hamiltonian coefficients. The example defines a Hamiltonian `H` as a linear combination of Pauli operators and evolves an initial state under this Hamiltonian using `QDrift`, specifying the evolution `time` and number of samples `n`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [0.25, 0.75]\nops = [qml.PauliX(0), qml.PauliZ(0)]\nH = qml.dot(coeffs, ops)\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(0)\n    qml.QDrift(H, time=1.2, n = 10)\n    return qml.probs()\n```\n\n----------------------------------------\n\nTITLE: Constructing Execution Configuration in PennyLane\nDESCRIPTION: This example demonstrates how to use `qml.workflow.construct_execution_config` to create an execution configuration object from a QNode. The execution configuration encapsulates various settings related to the execution of the quantum circuit, such as gradient method, device options, and interface.  This helps users customize and manage the execution environment for their quantum programs.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device(\"default.qubit\", wires=1))\ndef circuit(x):\n    qml.RX(x, 0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Batched Shots Specification in PennyLane\nDESCRIPTION: This code demonstrates how to specify batches of shots as a list in PennyLane. The device is initialized with a list of shot values, allowing for course-grained measurement statistics with a single QNode evaluation.  When the QNode is executed, PennyLane will return measurement statistics for each shot value in the list.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> shots_list = [5, 10, 1000]\n>>> dev = qml.device(\"default.qubit\", wires=2, shots=shots_list)\n```\n\n----------------------------------------\n\nTITLE: Using AutoGraph with TensorFlow QNodes in PennyLane\nDESCRIPTION: This snippet demonstrates how to use TensorFlow's AutoGraph feature with PennyLane QNodes for improved performance. The `@tf.function` decorator converts the QNode and cost function into TensorFlow graphs, allowing for more efficient execution. The example computes the gradient of a quantum circuit's output using TensorFlow's `GradientTape`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"lightning.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method=\"adjoint\", interface=\"tf\", max_diff=1)\ndef circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=1)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliZ(0))\n\n@tf.function\ndef cost(x):\n    return tf.reduce_sum(circuit(x))\n\nx = tf.Variable([0.5, 0.7], dtype=tf.float64)\n\nwith tf.GradientTape() as tape:\n    loss = cost(x)\n\ngrad = tape.gradient(loss, x)\n```\n\n----------------------------------------\n\nTITLE: Mid-Circuit Measurements with Tree-Traversal Algorithm in PennyLane\nDESCRIPTION: This snippet demonstrates the use of the `tree-traversal` algorithm for mid-circuit measurements (MCMs) in PennyLane with analytic mode execution (shots=None). It creates a quantum circuit with Hadamard gates, CNOT gates, mid-circuit measurements, and conditional RX gates. The `mcm_method=\"tree-traversal\"` argument specifies the algorithm to be used for handling the measurements. Requires PennyLane and a compatible device (e.g., default.qubit).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\nn_qubits = 5\n\n@qml.qnode(dev, mcm_method=\"tree-traversal\")\ndef circuit():\n    for w in range(n_qubits):\n        qml.Hadamard(w)\n    \n    for w in range(n_qubits - 1):\n        qml.CNOT(wires=[w, w+1])\n\n    for w in range(n_qubits):\n        m = qml.measure(w)\n        qml.cond(m == 1, qml.RX)(0.1967 * (w + 1), w)\n\n    return [qml.expval(qml.Z(w)) for w in range(n_qubits)]\n```\n\n----------------------------------------\n\nTITLE: Quantum Parameter Broadcasting with circuit\nDESCRIPTION: This example demonstrates how to use parameter broadcasting within a quantum circuit. A quantum node (`circuit_rx`) is defined with batched parameters for `qml.RX` and `qml.RZ` gates. The circuit calculates the probabilities of the output state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_9\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=1)\n>>> @qml.qnode(dev)\n... def circuit_rx(x, z):\n...     qml.RX(x, wires=0)\n...     qml.RZ(z, wires=0)\n...     qml.RY(0.3, wires=0)\n...     return qml.probs(wires=0)\n>>> circuit_rx([0.1, 0.2], [0.3, 0.4])\ntensor([[0.97092256, 0.02907744],\n          [0.95671515, 0.04328485]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Converting OpenFermion to PennyLane Fermi Operator (PyCon)\nDESCRIPTION: This snippet demonstrates converting a FermionOperator from OpenFermion to a FermiWord object in PennyLane using `qml.from_openfermion`. It shows the import of the OpenFermion library, the creation of a FermionOperator, its conversion to a FermiWord, and printing of the FermiWord.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> import openfermion\n>>> of_fermionic = openfermion.FermionOperator('0^ 2')\n>>> type(of_fermionic)\n<class 'openfermion.ops.operators.fermion_operator.FermionOperator'>\n>>> pl_fermionic = qml.from_openfermion(of_fermionic)\n>>> type(pl_fermionic)\n<class 'pennylane.fermi.fermionic.FermiWord'>\n>>> print(pl_fermionic)\na⁺(0) a(2)\n```\n\n----------------------------------------\n\nTITLE: Quantum Singular Value Transformation (QSVT) Circuit (Python)\nDESCRIPTION: This snippet demonstrates the creation of a quantum circuit for quantum singular value transformation (QSVT) using PennyLane. It utilizes the `qml.qsvt` function with an input matrix `A` and angles to create the circuit within a QNode. Requires NumPy for matrix definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\nA = np.array([[0.1, 0.2], [0.3, 0.4]])\nangles = np.array([0.1, 0.2, 0.3])\n\n@qml.qnode(dev)\ndef example_circuit(A):\n    qml.qsvt(A, angles, wires=[0, 1])\n    return qml.expval(qml.PauliZ(wires=0))\n```\n\n----------------------------------------\n\nTITLE: QNode Execution with Batched Shots\nDESCRIPTION: This code demonstrates QNode execution using batched shots. The circuit returns two expectation values. With `shots=[5, 10, 1000]`, the output is a `(3, 2)` array, where each row contains the expectation values calculated with the corresponding number of shots.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circuit(x):\n...     qml.RX(x, wires=0)\n...     qml.CNOT(wires=[0, 1])\n...     return qml.expval(qml.PauliZ(0) @ qml.PauliX(1)), qml.expval(qml.PauliZ(0))\n>>> circuit(0.5)\n```\n\n----------------------------------------\n\nTITLE: Register Alternative Custom CNOT Decomposition with Resources\nDESCRIPTION: This snippet shows an alternative custom decomposition for the CNOT gate using RY and Z gates, along with resource requirements (2 RY gates, 1 CZ gate, 2 Z gates). This allows the graph-based decomposition to choose the most resource-efficient decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@qml.register_resources({qml.RY: 2, qml.CZ: 1, qml.Z: 2})\ndef my_cnot2(wires, **__):\n    qml.RY(np.pi/2, wires[1])\n    qml.Z(wires[1])\n    qml.CZ(wires=wires)\n    qml.RY(np.pi/2, wires[1])\n    qml.Z(wires[1])\n```\n\n----------------------------------------\n\nTITLE: Loading Quantum Chemistry Dataset with PennyLane\nDESCRIPTION: This code snippet demonstrates how to load a quantum chemistry dataset using `qml.data.load`. It loads the H2 molecule dataset with the STO-3G basis and a bond length of 1.1, then prints the dataset object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nH2datasets = qml.data.load(\"qchem\", molname=\"H2\", basis=\"STO-3G\", bondlength=1.1)\nprint(H2datasets)\nH2data = H2datasets[0]\n```\n\n----------------------------------------\n\nTITLE: Grouping Observables with Coefficients in PennyLane\nDESCRIPTION: This snippet demonstrates how to group observables and their corresponding coefficients using the `group_observables` function in PennyLane. It showcases the use of qubit-wise commuting ('qwc') grouping and the recursive largest first ('rlf') graph-colouring algorithm.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> import pennylane as qml\n>>> from pennylane.pauli import group_observables, PauliX, PauliY, PauliZ\n>>> obs = [qml.PauliY(0), qml.PauliX(0) @ qml.PauliX(1), qml.PauliZ(1)]\n>>> coeffs = [1.43, 4.21, 0.97]\n>>> obs_groupings, coeffs_groupings = group_observables(obs, coeffs, 'qwc', 'rlf')\n>>> obs_groupings\n[[PauliX(wires=[0]) @ PauliX(wires=[1])],\n [PauliY(wires=[0]), PauliZ(wires=[1])]]\n>>> coeffs_groupings\n[[4.21], [1.43, 0.97]]\n```\n\n----------------------------------------\n\nTITLE: Decomposing MultiControlledX Gate in PennyLane\nDESCRIPTION: This code defines a quantum circuit using PennyLane to decompose a MultiControlledX gate. It initializes a device with specified control, work, and target wires.  Then, it constructs a QuantumTape containing the MultiControlledX operation with given control, target, and work wires, which is then expanded for decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nctrl_wires = [f\"c{i}\" for i in range(5)]\nwork_wires = [f\"w{i}\" for i in range(3)]\ntarget_wires = [\"t0\"]\nall_wires = ctrl_wires + work_wires + target_wires\n\ndev = qml.device(\"default.qubit\", wires=all_wires)\n\nwith qml.tape.QuantumTape() as tape:\n    qml.MultiControlledX(control_wires=ctrl_wires, wires=target_wires, work_wires=work_wires)\n```\n\n----------------------------------------\n\nTITLE: Using default.qubit.autograd Device with Backpropagation\nDESCRIPTION: Demonstrates the usage of the `default.qubit.autograd` device in PennyLane, which is a pure-state qubit simulator written using Autograd. This device supports classical backpropagation (`diff_method=\"backprop\"`) for computing quantum gradients. The code defines a simple quantum circuit and computes its gradient using backpropagation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit.autograd\", wires=1)\n>>> @qml.qnode(dev, diff_method=\"backprop\")\n... def circuit(x):\n...     qml.RX(x[1], wires=0)\n...     qml.Rot(x[0], x[1], x[2], wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> weights = np.array([0.2, 0.5, 0.1])\n>>> grad_fn = qml.grad(circuit)\n>>> print(grad_fn(weights))\narray([-2.25267173e-01, -1.00864546e+00,  6.93889390e-18])\n```\n\n----------------------------------------\n\nTITLE: Using `qml.cond` for conditional execution in Quantum Circuits\nDESCRIPTION: This code demonstrates the use of `qml.cond` for conditional execution of quantum operations based on a classical condition. It defines a quantum circuit that applies either an RX or an RZ gate depending on whether the input `x` is greater than 2.7. Dependencies: requires a PennyLane device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    c = qml.cond(x > 2.7, qml.RX, qml.RZ)\n    c(x, wires=0)\n    return qml.probs(wires=0)\n```\n\n----------------------------------------\n\nTITLE: Pulse Programming with pwc Function\nDESCRIPTION: This snippet shows how to use the `qml.pulse.pwc` function to define a piecewise constant callable coefficient for a `qml.pulse.ParametrizedHamiltonian`. The `timespan` argument specifies the interval over which the function is non-zero.  f * qml.PauliX(0) creates a ParametrizedHamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_27\n\nLANGUAGE: pycon\nCODE:\n```\n>>> timespan = (2, 4)\n>>> f = qml.pulse.pwc(timespan)\n>>> f * qml.PauliX(0)\nParametrizedHamiltonian: terms=1\n```\n\n----------------------------------------\n\nTITLE: PauliSentence operations in PennyLane\nDESCRIPTION: This snippet demonstrates how to create and manipulate PauliSentence objects in PennyLane, which represent linear combinations of Pauli words. It showcases addition, multiplication, and conversion to matrix representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.pauli import PauliWord, PauliSentence\n>>> pw1 = PauliWord({0:\"X\", 1:\"Z\"})\n>>> pw2 = PauliWord({0:\"Y\", 1:\"Z\"})\n>>> ps1 = PauliSentence({pw1: 1.2, pw2: 0.5j})\n>>> ps2 = PauliSentence({pw1: -1.2})\n>>> ps1\n1.2 * X(0) @ Z(1)\n+ 0.5j * Y(0) @ Z(1)\n\n>>> ps1 + ps2\n0.0 * X(0) @ Z(1)\n+ 0.5j * Y(0) @ Z(1)\n\n>>> ps1 @ ps2\n-1.44 * I\n+ (-0.6+0j) * Z(0)\n\n>>> (ps1 + ps2).to_mat(wire_order=[0, 1])\narray([[ 0. +0.j,  0. +0.j,  0.5+0.j,  0. +0.j],\n       [ 0. +0.j,  0. +0.j,  0. +0.j, -0.5+0.j],\n       [-0.5+0.j,  0. +0.j,  0. +0.j,  0. +0.j],\n       [ 0. +0.j,  0.5+0.j,  0. +0.j,  0. +0.j]])\n```\n\n----------------------------------------\n\nTITLE: Using qml.cond with both true and false branches\nDESCRIPTION: Provides a correct implementation of qml.cond by including both 'true_fn' and 'false_fn' to ensure consistent return types. This avoids the ValueError encountered when only the true branch returns a value. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nqml.capture.enable()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2))\ndef circuit():\n\n    def true_branch(x):\n        return qml.X(0)\n\n    def false_branch(x):\n        return qml.Identity(0)\n\n    m0 = qml.measure(0)\n    qml.cond(m0, true_fn=true_branch, false_fn=false_branch)(4)\n\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Constant Over-Rotation with partial_wires - Python\nDESCRIPTION: This example demonstrates how to use `qml.noise.partial_wires` to create a constant-valued over-rotation. It creates an `RX` gate with a fixed parameter of 0.1 and then uses `partial_wires` to ensure that the wires of the noise gate match the original gate.  Finally, it combines it with `rx_condition` from a previous example to form a NoiseModel.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_noise.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> rx_constant = qml.noise.partial_wires(qml.RX(0.1, wires=[0]))\n>>> rx_constant(2)\nRX(0.1, 2)\n\n>>> qml.NoiseModel({rx_condition: rx_constant})\n```\n\n----------------------------------------\n\nTITLE: Running Adaptive Optimization with PennyLane\nDESCRIPTION: Demonstrates how to use the `qml.optimize.AdaptiveOptimizer` to adaptively optimize a quantum circuit. It iteratively adds gates to the circuit based on gradient information. Requires PennyLane and a defined circuit and operator pool.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nopt = qml.optimize.AdaptiveOptimizer()\nfor i in range(len(operator_pool)):\n    circuit, energy, gradient = opt.step_and_cost(circuit, operator_pool, drain_pool=True)\n    print('Energy:', energy)\n    print(qml.draw(circuit)())\n    print('Largest Gradient:', gradient)\n    print()\n    if gradient < 1e-3:\n        break\n```\n\n----------------------------------------\n\nTITLE: Purity Calculation using qml.qinfo.transforms.purity in PennyLane\nDESCRIPTION: This snippet demonstrates how to calculate the purity of a quantum circuit using the `qml.qinfo.transforms.purity` function in PennyLane. It also shows how to compute the gradient of the purity with respect to a circuit parameter. Requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.qinfo.transforms.purity(circuit, wires=[0])(np.pi / 2)\n0.5\n>>> qml.qinfo.transforms.purity(circuit, wires=[0, 1])(np.pi / 2)\n1.0\n```\n\n----------------------------------------\n\nTITLE: Custom Operator Definition: FlipAndRotate in PennyLane\nDESCRIPTION: This code defines a custom PennyLane operator `FlipAndRotate` that conditionally flips a qubit and then rotates another qubit. It includes the definition of the operator's properties, decomposition, and adjoint.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\n\nclass FlipAndRotate(qml.operation.Operation):\n\n    # Define how many wires the operator acts on in total.\n    # In our case this may be one or two, which is why we\n    # use the AnyWires Enumeration to indicate a variable number.\n    num_wires = qml.operation.AnyWires\n\n    # This attribute tells PennyLane what differentiation method to use. Here\n    # we request parameter-shift (or \"analytic\") differentiation.\n    grad_method = \"A\"\n\n    def __init__(self, angle, wire_rot, wire_flip=None, do_flip=False, id=None):\n\n        # checking the inputs --------------\n\n        if do_flip and wire_flip is None:\n            raise ValueError(\"Expected a wire to flip; got None.\")\n\n        # note: we use the framework-agnostic math library since\n        # trainable inputs could be tensors of different types\n        shape = qml.math.shape(angle)\n        if len(shape) > 1:\n            raise ValueError(f\"Expected a scalar angle; got angle of shape {shape}.\")\n\n        #------------------------------------\n\n        # do_flip is not trainable but influences the action of the operator,\n        # which is why we define it to be a hyperparameter\n        self._hyperparameters = {\n            \"do_flip\": do_flip\n        }\n\n        # we extract all wires that the operator acts on,\n        # relying on the Wire class arithmetic\n        all_wires = qml.wires.Wires(wire_rot) + qml.wires.Wires(wire_flip)\n\n        # The parent class expects all trainable parameters to be fed as positional\n        # arguments, and all wires acted on fed as a keyword argument.\n        # The id keyword argument allows users to give their instance a custom name.\n        super().__init__(angle, wires=all_wires, id=id)\n\n    @property\n    def num_params(self):\n        # if it is known before creation, define the number of parameters to expect here,\n        # which makes sure an error is raised if the wrong number was passed\n        return 1\n\n    @staticmethod\n    def compute_decomposition(angle, wires, do_flip):  # pylint: disable=arguments-differ\n        # Overwriting this method defines the decomposition of the new gate, as it is\n        # called by Operator.decomposition().\n        # The general signature of this function is (*parameters, wires, **hyperparameters).\n        op_list = []\n        if do_flip:\n            op_list.append(qml.PauliX(wires=wires[1]))\n        op_list.append(qml.RX(angle, wires=wires[0]))\n        return op_list\n\n    def adjoint(self):\n        # the adjoint operator of this gate simply negates the angle\n        return FlipAndRotate(-self.parameters[0], self.wires[0], self.wires[1], do_flip=self.hyperparameters[\"do_flip\"])\n\n    @classmethod\n    def _unflatten(cls, data, metadata):\n        # as the class differs from the standard `__init__` call signature of\n        # (*data, wires=wires, **hyperparameters), the _unflatten method that\n        # must be defined as well\n        # _unflatten recreates an operation from the serialized data and metadata of ``Operator._flatten``\n        # copied_op = type(op)._unflatten(*op._flatten())\n        wires = metadata[0]\n        hyperparams = dict(metadata[1])\n        return cls(data[0], wire_rot=wires[0], wire_flip=wires[1], do_flip=hyperparams['do_flip'])\n```\n\n----------------------------------------\n\nTITLE: QAOA Cost Function Execution Example - Python\nDESCRIPTION: This code snippet shows an example of executing the defined QAOA cost function with specific parameters. It demonstrates how to call the `cost_function` with a set of parameters and prints the resulting expected value of the cost Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> print(cost_function([[1, 1], [1, 1]]))\n```\n\n----------------------------------------\n\nTITLE: Computing Hartree-Fock Energy Gradient with Jax\nDESCRIPTION: This snippet shows how to compute the Hartree-Fock energy gradient using PennyLane's qml.qchem.hf_energy function and Jax's automatic differentiation capabilities.  The args variable, created in the previous snippet, is used as an argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jax.grad(qml.qchem.hf_energy(mol))(*args)\nArray([[ 0.       ,  0.       ,  0.3650435],\n       [ 0.       ,  0.       , -0.3650435]], dtype=float64)\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Hamiltonian into Pauli Operators\nDESCRIPTION: Shows how to use the `qml.utils.decompose_hamiltonian` function to decompose a Hamiltonian into a linear combination of Pauli operators. The example provides a sample Hamiltonian matrix and demonstrates the decomposition process.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> A = np.array(\n... [[-2, -2+1j, -2, -2],\n... [-2-1j,  0,  0, -1],\n... [-2,  0, -2, -1],\n... [-2, -1, -1,  0]])\n>>> coeffs, obs_list = decompose_hamiltonian(A)\n```\n\n----------------------------------------\n\nTITLE: Calculating Relative Entropy with qml.math\nDESCRIPTION: This code demonstrates calculating the relative entropy between two density matrices using `qml.math.relative_entropy`.  The density matrices `rho` and `sigma` are defined, and then their relative entropy is computed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_29\n\nLANGUAGE: pycon\nCODE:\n```\n>>> rho = np.array([[0.3, 0], [0, 0.7]])\n>>> sigma = np.array([[0.5, 0], [0, 0.5]])\n>>> qml.math.relative_entropy(rho, sigma)\ntensor(0.08228288, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Loading Quantum Datasets with PennyLane\nDESCRIPTION: Demonstrates how to load quantum datasets using the `qml.data.load()` function in PennyLane. It shows how to load a specific dataset (H2 molecule), access its properties, and specify desired attributes to load.  Dependencies include PennyLane and a connection to Xanadu Cloud.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> H2_datasets = qml.data.load(\n...\tdata_name=\"qchem\", molname=\"H2\", basis=\"STO-3G\", bondlength=1.1\n... )\n>>> H2data = H2_datasets[0]\n>>> H2data\n<Dataset = description: qchem/H2/STO-3G/1.1, attributes: ['molecule', 'hamiltonian', ...]>\n```\n\n----------------------------------------\n\nTITLE: Using JAX Interface with Hardware Devices in PennyLane\nDESCRIPTION: This code demonstrates using the JAX interface with a hardware device (Cirq simulator) in PennyLane. It defines a quantum circuit `circuit` with parameterized rotations, and the `qml.qnode` decorator specifies the JAX interface and the parameter-shift differentiation method. The circuit is then evaluated with JAX arrays.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('cirq.simulator', wires=1)\n@qml.qnode(dev, interface=\"jax\", diff_method=\"parameter-shift\")\ndef circuit(x):\n    qml.RX(x[1], wires=0)\n    qml.Rot(x[0], x[1], x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\nweights = jnp.array([0.2, 0.5, 0.1])\nprint(circuit(weights))\n```\n\n----------------------------------------\n\nTITLE: Approximating Derivatives with Finite Differences\nDESCRIPTION: This snippet showcases the use of the `finite_diff()` function in PennyLane to approximate derivatives of arbitrary callable functions. It defines a function `H` that returns a molecular Hamiltonian and then uses `qml.finite_diff` to compute the gradient and second-order derivatives of `H` with respect to its parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef H(x):\n   return qml.qchem.molecular_hamiltonian(['H', 'H'], x)[0]\nx = np.array([0., 0., -0.66140414, 0., 0., 0.66140414])\ngrad_fn = qml.finite_diff(H, N=1)\ngrad = grad_fn(x)\nderiv2_fn = qml.finite_diff(H, N=2, idx=[0, 1])\nderiv2_fn(x)\n```\n\n----------------------------------------\n\nTITLE: Executing Circuit with Combined Mid-Circuit Measurements\nDESCRIPTION: This snippet shows how to execute the quantum circuit defined with combined mid-circuit measurements and retrieves the probabilities. Requires PennyLane and a previously defined quantum circuit `circuit`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit()\n[0.90843735 0.09156265]\n```\n\n----------------------------------------\n\nTITLE: QNode transformation to obtain purity\nDESCRIPTION: This code demonstrates the transform `qml.qinfo.transforms.purity` that transform a QNode returning a state to a function that returns the purity.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.mixed\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.IsingXX(x, wires=[0, 1])\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Differentiable Error Mitigation with ZNE in PennyLane\nDESCRIPTION: This code demonstrates how to apply differentiable zero-noise extrapolation (ZNE) error mitigation to a PennyLane QNode. It defines a noisy simulation device and uses the `qml.transforms.mitigate_with_zne` transform, along with the `qml.transforms.fold_global` and `qml.transforms.poly_extrapolate` functions, to mitigate errors while maintaining differentiability. It requires the `pennylane` and `numpy` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Describe noise\nnoise_gate = qml.DepolarizingChannel\nnoise_strength = 0.1\n\n# Load devices\ndev_ideal = qml.device(\"default.mixed\", wires=1)\ndev_noisy = qml.transforms.insert(noise_gate, noise_strength)(dev_ideal)\n\nscale_factors = [1, 2, 3]\n@mitigate_with_zne(\n  scale_factors,\n  qml.transforms.fold_global,\n  qml.transforms.poly_extrapolate,\n  extrapolate_kwargs={'order': 2}\n)\n@qml.qnode(dev_noisy)\ndef qnode_mitigated(theta):\n    qml.RY(theta, wires=0)\n    return qml.expval(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: Comparing Circuit Outputs After Transformation\nDESCRIPTION: This example compares the output states of two circuits, one with the RX gate before the Hadamard gate, and another with the RX gate after.  The `shift_rx_to_end` transform is applied to the first circuit, effectively moving the RX gate to the end, resulting in equivalent circuits. This illustrates how transforms can be used to modify and optimize quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit1() == circuit2()\nArray([ True,  True], dtype=bool)\n```\n\n----------------------------------------\n\nTITLE: Using qml.adjoint instead of Operation.inv()\nDESCRIPTION: This code snippet provides the updated way to invert a `PauliX` operation using `qml.adjoint` after the deprecation of `Operation.inv()`. This change affects how quantum operations are inverted in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_34\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.adjoint(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: Molecular Hamiltonian Generation with qml.qchem in PennyLane\nDESCRIPTION: Demonstrates how to generate a molecular Hamiltonian using `qml.qchem.molecular_hamiltonian` within the unified `qml.qchem` module. The example shows how to specify atomic symbols and geometry to create the Hamiltonian, and the option to use either the differentiable Hartree-Fock solver or PySCF for Hartree-Fock calculations via the `method` parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0., 0., -0.66140414], [0., 0., 0.66140414]])\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, method=\"dhf\")\n```\n\n----------------------------------------\n\nTITLE: SPSA Gradient Calculation in PennyLane\nDESCRIPTION: This snippet demonstrates how to compute an approximate gradient of a quantum circuit using the SPSA (Simultaneous Perturbation Stochastic Approximation) gradient transform in PennyLane.  It shows how to define a QNode, specify the device, and use `qml.gradients.spsa_grad` to compute the gradient. Requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> x = np.array(0.4, requires_grad=True)\n>>> @qml.qnode(dev)\n... def circuit(x):\n...     qml.RX(x, 0)\n...     qml.RX(x, 1)\n...     return qml.expval(qml.PauliZ(0))\n>>> grad_fn = qml.gradients.spsa_grad(circuit, h=0.1, num_directions=1)\n>>> grad_fn(x)\narray(-0.38876964)\n```\n\n----------------------------------------\n\nTITLE: Calculating derivative with jax.jit in PennyLane\nDESCRIPTION: This code snippet demonstrates how to use `jax.jit` to efficiently calculate derivatives in PennyLane. It defines a quantum circuit with two parameters and uses `jax.jacobian` and `jax.jit` to compute the derivative with respect to only one parameter.  It asserts that only one parameter is trainable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, interface=\"jax-jit\")\ndef circuit(a, b):\n    qml.RX(a, wires=0)\n    qml.RY(b, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\na = jnp.array(0.4)\nb = jnp.array(0.5)\n\njac = jax.jacobian(circuit, argnums=[1])\njac_jit = jax.jit(jac)\n\njac_jit(a, b)\nassert len(circuit.tape.trainable_params) == 1\n```\n\n----------------------------------------\n\nTITLE: Givens Decomposition in PennyLane\nDESCRIPTION: This code demonstrates the use of the `qml.qchem.givens_decomposition` function to decompose a unitary matrix into a sequence of Givens rotation gates with phase shifts and a diagonal phase matrix. It takes a unitary matrix as input and returns the phase matrix and ordered rotations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nunitary = np.array([[ 0.73678+0.27511j, -0.5095 +0.10704j, -0.06847+0.32515j],\n                      [-0.21271+0.34938j, -0.38853+0.36497j,  0.61467-0.41317j],\n                      [ 0.41356-0.20765j, -0.00651-0.66689j,  0.32839-0.48293j]])\n\nphase_mat, ordered_rotations = qml.qchem.givens_decomposition(unitary)\n```\n\n----------------------------------------\n\nTITLE: Decomposing Circuits using a Gate Rule in PennyLane\nDESCRIPTION: This example demonstrates how to decompose a quantum circuit using a gate rule that defines the allowed gates based on a lambda function with `qml.transforms.decompose`. The rule specifies that only single or two-qubit gates are allowed.  The code decomposes a Toffoli gate into single and two-qubit gates.  This showcases the use of gate rules for circuit decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# functions in gate_set can only be used with graph decomposition system disabled\nqml.decomposition.disable_graph()\n\n@partial(decompose, gate_set=lambda op: len(op.wires) <= 2) \n@qml.qnode(dev)\ndef circuit():\n    qml.Toffoli(wires=[0,1,2])\n    return qml.expval(qml.Z(0)) \n\n>>> print(qml.draw(circuit)())\n```\n\n----------------------------------------\n\nTITLE: Adding Noise to Quantum Circuit (Python)\nDESCRIPTION: This snippet demonstrates how to add a predefined `qml.NoiseModel` to a quantum circuit using the `qml.add_noise` transform.  It shows how to define a basic quantum circuit and then apply the noise model, altering the circuit's behavior and resulting in different expectation values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device(\"default.mixed\", wires=3))\ndef circuit():\n    qml.RX(0.1967, wires=0)\n    for i in range(3):\n        qml.Hadamard(i)\n\n    return qml.expval(qml.X(0) @ qml.X(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> noisy_circuit = qml.add_noise(circuit, noise_model)\n>>> print(qml.draw(noisy_circuit)())\n0: ──RX(0.20)──RY(-0.42)────────H──RY(-0.42)──PhaseFlip(0.20)─┤ ╭<X@X>\n1: ──H─────────PhaseFlip(0.20)────────────────────────────────┤ ╰<X@X>\n2: ──H─────────RY(-0.42)──────────────────────────────────────┤    \n>>> print(circuit(), noisy_circuit())\n0.9807168489852615 0.35305806563469433\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Calculate expectation values with Qiskit operator\nDESCRIPTION: This code combines Qiskit circuit conversion using `qml.from_qiskit` and Qiskit operator conversion using `qml.from_qiskit_op` to create a PennyLane QNode for calculating expectation values using an operator defined in Qiskit. This allows for seamless integration of Qiskit components into PennyLane workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nqc = QuantumCircuit(2)  # Create circuit\nqc.rx(0.785, 0)\nqc.ry(1.57, 1)\n\nmeasurements = qml.expval(pl_op)  # Create QNode\nqfunc = qml.from_qiskit(qc, measurements)\nqnode = qml.QNode(qfunc, dev)\n```\n\n----------------------------------------\n\nTITLE: Enable JAX Double Precision\nDESCRIPTION: This snippet demonstrates how to enable double-precision in JAX. This can be important for numerical stability in certain quantum computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\njax.config.update(\"jax_enable_x64\", True)\n```\n\n----------------------------------------\n\nTITLE: QAOA Cost and Mixer Hamiltonians Definition - Python\nDESCRIPTION: This code snippet defines the cost and mixer Hamiltonians for the QAOA algorithm using the provided graph. It utilizes the `qaoa.maxcut` function from PennyLane to generate the Hamiltonians based on the graph's structure. These Hamiltonians are crucial for constructing the QAOA ansatz.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Defines the QAOA cost and mixer Hamiltonians\ncost_h, mixer_h = qaoa.maxcut(graph)\n```\n\n----------------------------------------\n\nTITLE: Configuring Workflow Options with default.qubit in PennyLane\nDESCRIPTION: This snippet demonstrates how to configure workflow options such as `use_device_jacobian_product`, `use_device_gradient`, `grad_on_execution`, and `convert_to_numpy` using `ExecutionConfig` and `setup_execution_config` for the 'default.qubit' device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nconfig = qml.devices.ExecutionConfig(gradient_method=\"adjoint\")\nprocessed_config = qml.device('default.qubit').setup_execution_config(config)\nprocessed_config.use_device_jacobian_product\n```\n\nLANGUAGE: python\nCODE:\n```\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\nprocessed_config.use_device_gradient\n```\n\nLANGUAGE: python\nCODE:\n```\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\nprocessed_config.grad_on_execution\n```\n\nLANGUAGE: python\nCODE:\n```\nTrue\n```\n\nLANGUAGE: python\nCODE:\n```\nprocessed_config.convert_to_numpy\n```\n\nLANGUAGE: python\nCODE:\n```\nTrue\n```\n\n----------------------------------------\n\nTITLE: Create a PennyLane QNode from a Qiskit Circuit\nDESCRIPTION: This code defines a PennyLane QNode that uses the previously converted PennyLane quantum function (from a Qiskit circuit). The QNode executes the quantum function on a `default.qubit` device and returns the expectation value of `Y(0)` and the variance of `Z(1)`. The input to the converted quantum function must specify the wires the circuit operates on.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device(\"default.qubit\"))\ndef pl_circuit_from_qk():\n    pl_qfunc_from_qk(wires=[0, 1])\n    return qml.expval(qml.Y(0)), qml.var(qml.Z(1))\n```\n\n----------------------------------------\n\nTITLE: Creating a Circuit with Custom Resource Operation in PennyLane\nDESCRIPTION: Illustrates how to create a quantum circuit that includes the custom resource operation `CustomOp`. This example shows how the custom operation can be integrated into a standard PennyLane circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=wires)\n\n@qml.qnode(dev)\ndef circ():\n    qml.PauliZ(wires=0)\n    CustomOp(wires)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Terms Representation in PennyLane\nDESCRIPTION: This snippet shows how to represent a Hamiltonian operator as a linear combination of Pauli operators using the `terms` method.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nop = qml.Hamiltonian([1., 2.], [qml.PauliX(0), qml.PauliZ(0)])\nop.terms()\n```\n\n----------------------------------------\n\nTITLE: Listing Available Decompositions for an Operator in Python\nDESCRIPTION: This snippet demonstrates how to list available decompositions for a given operator (CRX) using the new graph-based decomposition system in PennyLane. It first enables the graph decomposition, then lists the decompositions, and prints one of the decomposition rules and its drawn circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import pennylane as qml\n>>> qml.decomposition.enable_graph()\n>>> qml.list_decomps(qml.CRX)\n[<pennylane.decomposition.decomposition_rule.DecompositionRule at 0x136da9de0>,\n  <pennylane.decomposition.decomposition_rule.DecompositionRule at 0x136da9db0>,\n  <pennylane.decomposition.decomposition_rule.DecompositionRule at 0x136da9f00>]\n>>> decomp_rule = qml.list_decomps(qml.CRX)[0]\n>>> print(decomp_rule, \"\\n\")\n@register_resources(_crx_to_rx_cz_resources)\ndef _crx_to_rx_cz(phi: TensorLike, wires: WiresLike, **__):\n    qml.RX(phi / 2, wires=wires[1])\n    qml.CZ(wires=wires)\n    qml.RX(-phi / 2, wires=wires[1])\n    qml.CZ(wires=wires) \n\n>>> print(qml.draw(decomp_rule)(0.5, wires=[0, 1]))\n0: ───────────╭●────────────╭●─┤\n1: ──RX(0.25)─╰Z──RX(-0.25)─╰Z─┤\n```\n\n----------------------------------------\n\nTITLE: Compute Lie Closure\nDESCRIPTION: Computes the Lie closure of a set of operators using `qml.lie_closure`. This function calculates all nested commutators between the provided operators until no new operators are generated, effectively determining the dynamical Lie algebra (DLA). The DLA reveals the range of unitary evolutions the operators can generate.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import X, Y, Z\nops = [X(0) @ X(1), Z(0), Z(1)]\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.commutator(X(0) @ X(1), Z(0))\n-2j * (Y(0) @ X(1))\n>>> qml.commutator(X(0) @ X(1), Z(1))\n-2j * (X(0) @ Y(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.commutator(X(0) @ Y(1), Z(0))\n-2j * (Y(0) @ Y(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> ops = [X(0) @ X(1), Z(0), Z(1)]\n>>> dla = qml.lie_closure(ops)\n>>> dla\n[X(0) @ X(1),\n Z(0),\n Z(1),\n -1.0 * (Y(0) @ X(1)),\n -1.0 * (X(0) @ Y(1)),\n -1.0 * (Y(0) @ Y(1))]\n```\n\n----------------------------------------\n\nTITLE: Density Matrix with Partial Trace in Python\nDESCRIPTION: This code shows how to return the density matrix with partial trace capabilities using `qml.density_matrix`. The code enables tape mode and defines a quantum circuit that applies PauliY and Hadamard gates.  It then returns the density matrix of wire 1, tracing out wire 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_tape()\ndev = qml.device(\"default.qubit\", wires=2)\n\ndef circuit(x):\n    qml.PauliY(wires=0)\n    qml.Hadamard(wires=1)\n    return qml.density_matrix(wires=[1])  # wire 0 is traced out\n```\n\n----------------------------------------\n\nTITLE: Accessing QuantumTape Operations by Index\nDESCRIPTION: This code demonstrates how to access individual quantum operations within a `QuantumTape` object using indexing. It assumes that the `tape` object has already been created and populated with quantum operations and measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> tape[0]\n```\n\n----------------------------------------\n\nTITLE: Creating a Special Object Class in Python\nDESCRIPTION: This snippet defines a `SpecialObject` class that can be used to encode data in an observable. It also defines a `DeviceSupportingNewObservable` class that supports the new observable and returns a `SpecialObject` as the expectation value.  The `SpecialObject` class implements basic operations to enable differentiation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nclass SpecialObject:\n\n    def __init__(self, val):\n        self.val = val\n\n    def __mul__(self, other):\n        new = SpecialObject(self.val)\n        new *= other\n        return new\n\n    ...\n\nclass DeviceSupportingNewObservable(DefaultQubit):\n    name = \"Device supporting NewObservable\"\n    short_name = \"default.qubit.newobservable\"\n    observables = DefaultQubit.observables.union({\"NewObservable\"})\n\n    def expval(self, observable, **kwargs):\n        if self.shots is None and isinstance(observable, NewObservable):\n            val = super().expval(qml.PauliZ(wires=0), **kwargs)\n            return SpecialObject(val)\n\n        return super().expval(observable, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Initializing the default.mixed device in PennyLane\nDESCRIPTION: This code snippet demonstrates how to initialize the `default.mixed` device in PennyLane, which is designed for simulating mixed-state quantum computations. It allows for native support of noisy channels in a circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.mixed\", wires=1)\n```\n\n----------------------------------------\n\nTITLE: Tracking Device VJPs in PennyLane\nDESCRIPTION: This code demonstrates how to use vector-Jacobian products (VJPs) provided by the device in PennyLane using the new device API. The `device_vjp=True` argument selects the device's VJP implementation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device('default.qubit')\n>>> @qml.qnode(dev, diff_method=\"adjoint\", device_vjp=True)\n>>> def circuit(x):\n...     qml.RX(x, wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> with dev.tracker:\n...     g = qml.grad(circuit)(qml.numpy.array(0.1))\n>>> dev.tracker.totals\n{'batches': 1, 'simulations': 1, 'executions': 1, 'vjp_batches': 1, 'vjps': 1}\n>>> g\n-0.09983341664682815\n```\n\n----------------------------------------\n\nTITLE: Sparse Hamiltonian Expectation Value (Python)\nDESCRIPTION: Shows how to compute the expectation value of a sparse Hamiltonian using `qml.SparseHamiltonian` with the 'default.qubit' device. It demonstrates the use of the parameter-shift differentiation method. Requires PennyLane installation, scipy, and a QNode defined with a compatible device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef circuit(param, H):\n    qml.PauliX(0)\n    qml.SingleExcitation(param, wires=[0, 1])\n    return qml.expval(qml.SparseHamiltonian(H, [0, 1]))\n```\n\n----------------------------------------\n\nTITLE: Custom Device Initialization with QubitDevice\nDESCRIPTION: This example demonstrates how to extend the QubitDevice class and override the __init__ method to add custom device arguments, such as hardware_options, and to set specific device configurations like the number of wires and shot number.  It also shows how to define the supported operations and observables.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nclass CustomDevice(QubitDevice):\n    name = 'My custom device'\n    short_name = 'example.mydevice'\n    pennylane_requires = '0.1.0'\n    version = '0.0.1'\n    author = 'Ada Lovelace'\n\n    operations = {\"PauliX\", \"RX\", \"CNOT\"}\n    observables = {\"PauliZ\", \"PauliX\", \"PauliY\"}\n\n    def __init__(self, shots=1024, hardware_options=None):\n        super().__init__(wires=24, shots=shots)\n        self.hardware_options = hardware_options or hardware_defaults\n```\n\n----------------------------------------\n\nTITLE: Defining a Pulse-Based Quantum Circuit in Python\nDESCRIPTION: This code defines a quantum circuit `pulse_circuit` that uses the time-dependent Hamiltonian `H` created previously with `qml.evolve`. The circuit takes parameters and a time value as input, evolves the quantum state under the Hamiltonian, and returns the expectation value of the `qml.PauliX(0) @ qml.PauliY(1)` observable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef pulse_circuit(params, time):\n    qml.evolve(H)(params, time)\n    return qml.expval(qml.PauliX(0) @ qml.PauliY(1))\n```\n\n----------------------------------------\n\nTITLE: Sampling with Mid-Circuit Measurements in PennyLane\nDESCRIPTION: This snippet showcases how to sample from a quantum circuit with mid-circuit measurements in PennyLane. It defines a quantum circuit with mid-circuit measurements and returns samples based on the measurement outcomes. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit(phi, theta):\n    qml.RX(phi, wires=0)\n    m0 = qml.measure(wires=0)\n    qml.RY(theta, wires=1)\n    m1 = qml.measure(wires=1)\n    return qml.sample(op=[m0, m1])\n\nprint(circuit(1.23, 4.56, shots=5))\n```\n\n----------------------------------------\n\nTITLE: Raising PennyLane Operators to a Power\nDESCRIPTION: This code demonstrates raising a PennyLane operator to a power using the ** operator. It creates an exp_op by raising an RZ gate acting on wire 0 to the power of 2. The code then prints the resulting operator and computes its matrix representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> exp_op = qml.RZ(1.0, wires=0) ** 2\n>>> exp_op\nRZ**2(1.0, wires=[0])\n>>> qml.matrix(exp_op)\narray([[0.54030231-0.84147098j, 0.        +0.j        ],\n       [0.        +0.j        , 0.54030231+0.84147098j]])\n```\n\n----------------------------------------\n\nTITLE: Generating Shift Rules for Gradients in PennyLane\nDESCRIPTION: This code demonstrates how to use `qml.gradients.generate_shift_rule` to compute generalized parameter shift rules for determining the gradient of expectation values in PennyLane. It calculates the frequencies from the eigenspectrum of a Hamiltonian and uses these to generate the coefficients and shifts for the parameter shift rule.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrequencies = qml.gradients.eigvals_to_frequencies((-1, 0, 1))\ncoeffs, shifts = qml.gradients.generate_shift_rule(frequencies)\n```\n\n----------------------------------------\n\nTITLE: Per-Call Shot Specification in PennyLane\nDESCRIPTION: This code demonstrates how to specify the number of shots on a per-call basis when evaluating a QNode in PennyLane. The QNode is called with an additional `shots` keyword argument to override the default shot value of the device. This allows flexible control over the number of shots used for each QNode execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=1, shots=10) # default is 10\n>>> @qml.qnode(dev)\n... def circuit(a):\n...     qml.RX(a, wires=0)\n...     return qml.sample(qml.PauliZ(wires=0))\n>>> circuit(0.8)\n[ 1  1  1 -1 -1  1  1  1  1  1]\n>>> circuit(0.8, shots=3)\n[ 1  1  1]\n>>> circuit(0.8)\n[ 1  1  1 -1 -1  1  1  1  1  1]\n```\n\n----------------------------------------\n\nTITLE: Diagonalizing Gates and Eigenvalues in PennyLane\nDESCRIPTION: Demonstrates how to obtain the diagonalizing gates and eigenvalues of a `qml.PauliX` operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nop = qml.PauliX(0)\nop.diagonalizing_gates()\nop.eigvals()\n```\n\n----------------------------------------\n\nTITLE: Gradients of Hamiltonian Coefficients and Parameters\nDESCRIPTION: This interactive console snippet displays the computed gradients of the circuit with respect to the Hamiltonian coefficients and the parameter. The output shows the gradient values for each coefficient and the parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_9\n\nLANGUAGE: pycon\nCODE:\n```\n>>> grad_fn(coeffs, param)\n(array([-0.12777055,  0.0166009 ]), array(0.0917819))\n```\n\n----------------------------------------\n\nTITLE: Covariance Matrix Calculation\nDESCRIPTION: Illustrates how to use the qml.math.cov_matrix() function to compute the covariance matrix of a list of commuting observables. The example constructs a QNode to output the probability distribution and then computes the covariance matrix.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nobs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliY(2)]\nansatz = qml.templates.StronglyEntanglingLayers\n\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev, interface=\"autograd\")\ndef circuit(weights):\n    ansatz(weights, wires=[0, 1, 2])\n    # rotate into the basis of the observables\n    for o in obs_list:\n        o.diagonalizing_gates()\n    return qml.probs(wires=[0, 1, 2])\n```\n\n----------------------------------------\n\nTITLE: Setting data types for a statevector (Python)\nDESCRIPTION: This example demonstrates how to set the data types for a statevector when creating a PennyLane device. It shows how to specify the real and complex data types using the `r_dtype` and `c_dtype` parameters, respectively. The snippet uses the `default.qubit` device and checks the `R_DTYPE` and `C_DTYPE` attributes to confirm the data types have been set correctly. Dependencies: pennylane, numpy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=4, r_dtype=np.float32, c_dtype=np.complex64)\n>>> dev.R_DTYPE\n<class 'numpy.float32'>\n>>> dev.C_DTYPE\n<class 'numpy.complex64'>\n```\n\n----------------------------------------\n\nTITLE: Using RotosolveOptimizer with General Parametrized Circuits\nDESCRIPTION: This snippet illustrates how to use the `RotosolveOptimizer` with a general parametrized quantum circuit. The circuit includes Pauli rotations, controlled Pauli rotations, and single-parameter layers of Pauli rotations.  The cost function returns the expectation value of a tensor product of PauliZ operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=3, shots=None)\n\n@qml.qnode(dev)\ndef cost_function(rot_param, layer_par, crot_param):\n    for i, par in enumerate(rot_param):\n        qml.RX(par, wires=i)\n    for w in dev.wires:\n        qml.RX(layer_par, wires=w)\n    for i, par in enumerate(crot_param):\n        qml.CRY(par, wires=[i, (i+1) % 3])\n\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1) @ qml.PauliZ(2))\n```\n\n----------------------------------------\n\nTITLE: Decomposing Hamiltonian Evolution into Suzuki-Trotter Decomposition\nDESCRIPTION: This example shows how Hamiltonian evolution for a linear combination of operators is decomposed using the Suzuki-Trotter decomposition.  The `num_steps` argument to `qml.evolve` controls the number of Trotter steps.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.evolve(qml.sum(qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0)), num_steps=2).decomposition()\n[RX((1+0j), wires=[0]),\n RY((1+0j), wires=[0]),\n RZ((1+0j), wires=[0]),\n RX((1+0j), wires=[0]),\n RY((1+0j), wires=[0]),\n RZ((1+0j), wires=[0])]\n```\n\n----------------------------------------\n\nTITLE: Using metric_tensor with QNode in PennyLane\nDESCRIPTION: This example showcases how to use the `qml.metric_tensor` transform with a QNode in PennyLane. It computes the metric tensor for a given QNode with specified weights.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.metric_tensor(some_qnode)(weights)\n```\n\n----------------------------------------\n\nTITLE: Creating Fermionic Operators with FermiC and FermiA in PennyLane\nDESCRIPTION: Demonstrates the creation of fermionic creation and annihilation operators using `qml.FermiC` and `qml.FermiA`. The operators are defined by passing the index of the orbital they act on, allowing for the construction of operators like a⁺(0) and a(3).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.FermiC(0)\na⁺(0)\n>>> qml.FermiA(3)\na(3)\n```\n\n----------------------------------------\n\nTITLE: Convert Qiskit QuantumCircuit to PennyLane Quantum Function\nDESCRIPTION: This snippet demonstrates how to convert a Qiskit `QuantumCircuit` to a PennyLane quantum function using the `qml.from_qiskit` function. The PennyLane-Qiskit plugin needs to be installed for this to work. The resulting PennyLane quantum function can then be used within a QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\npl_qfunc_from_qk = qml.from_qiskit(qk_circuit)\n```\n\n----------------------------------------\n\nTITLE: Computing Gradient of Mitigated QNode in PennyLane\nDESCRIPTION: This snippet calculates the gradient of the mitigated QNode using PennyLane's automatic differentiation. It takes an input parameter `theta` and computes the gradient of the expectation value with respect to that parameter.  It showcases the differentiability of the error mitigation process.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> theta = np.array(0.5, requires_grad=True)\n>>> qml.grad(qnode_mitigated)(theta)\n0.5712737447327619\n```\n\n----------------------------------------\n\nTITLE: Add Noise to Circuit with NoiseModel\nDESCRIPTION: Applies the `qml.add_noise` transform to a quantum circuit, inserting noise operations based on the provided `noise_model`. The `add_noise` transform modifies the circuit by inserting additional gates or channels that simulate noise.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncircuit = qml.add_noise(circuit, noise_model)\n```\n\n----------------------------------------\n\nTITLE: Creating a PennyLane Transform Program in Python\nDESCRIPTION: This code shows how to create a TransformProgram in PennyLane and add individual transforms to it.  Transforms are used to modify quantum circuits before execution, such as validating wires, measurements, and decomposing operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nprogram = qml.transforms.core.TransformProgram()\n```\n\n----------------------------------------\n\nTITLE: Define a pyQuil Program\nDESCRIPTION: This snippet defines a quantum program using the pyQuil library. It creates a program, applies a Hadamard gate to qubit 0, and then applies a CNOT gate with qubit 0 as control and qubit 1 as target.  The PennyLane-Rigetti plugin is needed as it is used to parse the pyQuil Program.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pyquil\n\npq_program = pyquil.Program()\npq_program += pyquil.gates.H(0)\npq_program += pyquil.gates.CNOT(0, 1)\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Spin Lattice (Python)\nDESCRIPTION: This snippet creates a custom spin lattice using `qml.spin.Lattice`, defining the lattice structure with parameters such as the number of cells, translation vectors, and atomic positions. The boundary condition is set to False indicating open boundaries. The `lattice_points` can be checked against `qml.spin.generate_lattice`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nlattice = qml.spin.Lattice(\n    n_cells=[3, 3],\n    vectors=[[1, 0], [np.cos(np.pi/3), np.sin(np.pi/3)]],\n    positions=[[0, 0]],\n    boundary_condition=False\n)\n```\n\n----------------------------------------\n\nTITLE: Encode Matrix as Linear Combination of Unitaries\nDESCRIPTION: This snippet demonstrates how to encode an operator A into a quantum circuit by decomposing it into a linear combination of unitaries using qml.StatePrep and qml.Select routines. It defines a function block_encode that prepares a state and applies a selection of unitaries based on the coefficients of the Pauli terms in the operator A. Dependencies: PennyLane, NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> A = qml.PauliX(2) + 2 * qml.PauliY(2) + 3 * qml.PauliZ(2)\n```\n\n----------------------------------------\n\nTITLE: Converting QuantumTape to a List\nDESCRIPTION: This code snippet demonstrates how to convert a `QuantumTape` object into a list of operations and measurements. It iterates through the tape and creates a list containing each quantum operation and measurement within the `QuantumTape` object. This assumes the existence of the `tape` object defined previously.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> list(tape)\n```\n\n----------------------------------------\n\nTITLE: Styling Matplotlib Circuit with PennyLane\nDESCRIPTION: This code snippet demonstrates how to use the `qml.drawer` module to style Matplotlib circuit graphics. It defines a quantum circuit, applies a specific style using `qml.drawer.use_style`, and then draws the circuit using `qml.draw_mpl`. The style can be replaced by any available style specification string (e.g., `\"pennylane\"` or `\"solarized_light\"`).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_drawer.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('lightning.qubit', wires=(0,1,2,3)))\ndef circuit(x, z):\n    qml.QFT(wires=(0,1,2,3))\n    qml.Toffoli(wires=(0,1,2))\n    qml.CSWAP(wires=(0,2,3))\n    qml.RX(x, wires=0)\n    qml.CRZ(z, wires=(3,0))\n    return qml.expval(qml.PauliZ(0))\n\nqml.drawer.use_style(style)\nfig, ax = qml.draw_mpl(circuit)(1.2345, 1.2345)\n```\n\n----------------------------------------\n\nTITLE: Implementing QROM in PennyLane\nDESCRIPTION: This snippet demonstrates how to implement the QROM algorithm in PennyLane. It takes a list of bitstrings as input and uses `qml.QROM` to store the classical data in the form of bitstrings in a quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nbitstrings = [\"010\", \"111\", \"110\", \"000\"]\n\ndev = qml.device(\"default.qubit\", shots = 1)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.BasisEmbedding(2, wires = [0,1])\n\n    qml.QROM(bitstrings = bitstrings,\n            control_wires = [0,1],\n            target_wires = [2,3,4],\n            work_wires = [5,6,7])\n\n    return qml.sample(wires = [2,3,4])\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit())\n[1 1 0]\n```\n\n----------------------------------------\n\nTITLE: Batched Partial Circuit\nDESCRIPTION: This snippet demonstrates the usage of `qml.batch_partial` to create a new function with a batched parameter. A QNode is defined, and `qml.batch_partial` is used to fix the `x` parameter to a specific value, creating a new function `batched_partial_circuit` that only takes `y` as an argument, but `y` can now be a batched array. This allows executing the circuit with a batch dimension in the `y` parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x, y):\n   qml.RX(x, wires=0)\n   qml.RY(y, wires=0)\n   return qml.expval(qml.PauliZ(wires=0))\n```\n\n----------------------------------------\n\nTITLE: Noisy RX Gate Definition - Python\nDESCRIPTION: This snippet defines a noisy quantum function `noisy_rx` that applies an over-rotation to the `RX` gate. It then creates a `NoiseModel` that uses the `rx_condition` Boolean function (defined previously) to apply this noisy operation.  The over-rotation is defined as scaling the original parameter by 0.05.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_noise.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef noisy_rx(op, **metadata):\n    qml.RX(op.parameters[0] * 0.05, op.wires)\n\nnoise_model = qml.NoiseModel({rx_condition: noisy_rx})\n```\n\n----------------------------------------\n\nTITLE: Overriding compute_decomposition method in PennyLane with JAX\nDESCRIPTION: This code snippet demonstrates how to override the `compute_decomposition` method of the `qml.CRY` operation in PennyLane to inject a custom decomposition. It uses JAX for automatic differentiation and verifies that the custom decomposition is used during gradient calculation by printing a message.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nfrom jax import numpy as jnp\n\ndef compute_decomposition(self, phi, wires):\n    print(\"A decomposition has been performed!\")\n    decomp_ops = [\n        qml.RY(phi / 2, wires=wires[1]),\n        qml.CNOT(wires=wires),\n        qml.RY(-phi / 2, wires=wires[1]),\n        qml.CNOT(wires=wires),\n    ]\n    return decomp_ops\n\nqml.CRY.compute_decomposition = compute_decomposition\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef circuit(phi):\n    qml.Hadamard(wires=0)\n    qml.CRY(phi, wires=[0, 1])\n    return qml.expval(qml.PauliZ(1))\n\nphi = jnp.array(0.5)\njax.grad(circuit)(phi)\n```\n\n----------------------------------------\n\nTITLE: Accessing the Pauli Representation of an Operator in PennyLane\nDESCRIPTION: This snippet shows how to access the Pauli representation (pauli_rep) of a PennyLane operator. The Pauli representation allows for faster operator arithmetic. The snippet also demonstrates transforming the PauliSentence back to an Operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nop = X(0) + Y(0)\n>>> op.pauli_rep\n1.0 * X(0)\n+ 1.0 * Y(0)\n>>> type(op.pauli_rep)\npennylane.pauli.pauli_arithmetic.PauliSentence\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> op.pauli_rep.operation()\nX(0) + Y(0)\n```\n\n----------------------------------------\n\nTITLE: Wires Difference using Python\nDESCRIPTION: Demonstrates how to perform difference operations on `Wires` instances using the `difference()` method or the `-` operator. It showcases how to find the wire labels that are present in the first Wires object but not in the second.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> wires1 = Wires([1, 2, 3])\n>>> wires2 = Wires([2, 3, 4])\n>>> wires1.difference(wires2) # or wires1 - wires2\nWires([1])\n```\n\n----------------------------------------\n\nTITLE: Mapping Wires of an Entire QNode\nDESCRIPTION: Illustrates how to use `qml.map_wires()` to map the wires of an entire QNode. It includes defining a quantum circuit, creating a wire map, and applying the function to generate a mapped QNode. The resulting mapped QNode is then executed and drawn.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=[\"A\", \"B\", \"C\", \"D\"])\nwire_map = {0: \"A\", 1: \"B\", 2: \"C\", 3: \"D\"}\n\n@qml.qnode(dev)\ndef circuit():\n    qml.RX(0.54, wires=0)\n    qml.PauliX(1)\n    qml.PauliZ(2)\n    qml.RY(1.23, wires=3)\n    return qml.probs(wires=0)\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> mapped_circuit = qml.map_wires(circuit, wire_map)\n>>> mapped_circuit()\ntensor([0.92885434, 0.07114566], requires_grad=True)\n>>> print(qml.draw(mapped_circuit)())\nA: ──RX(0.54)─┤  Probs\nB: ──X────────┤\nC: ──Z────────┤\nD: ──RY(1.23)─┤\n```\n\n----------------------------------------\n\nTITLE: Decomposing Hamiltonian Evolution into IsingXX Operation\nDESCRIPTION: This example shows how Hamiltonian evolution can be decomposed into PennyLane operations using `qml.evolve`. When the time-evolved Hamiltonian is equivalent to a standard operation, such as `qml.PauliX(0) @ qml.PauliX(1)`, the decomposition returns that operation (in this case, `IsingXX`).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> exp_op = qml.evolve(qml.PauliX(0) @ qml.PauliX(1))\n>>> exp_op.decomposition()\n[IsingXX((2+0j), wires=[0, 1])]\n```\n\n----------------------------------------\n\nTITLE: Creating Transverse-Field Ising Model (Python)\nDESCRIPTION: This snippet creates a transverse-field Ising model Hamiltonian on a 3x3 triangular lattice. It defines custom edges and nodes, and then generates a spin Hamiltonian using `qml.spin.spin_hamiltonian`. The resulting Hamiltonian is equivalent to `qml.spin.transverse_ising`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nedges = [\n    (0, 1), (0, 3), (1, 3)\n]\n\nlattice = qml.spin.Lattice(\n    n_cells=[3, 3],\n    vectors=[[1, 0], [np.cos(np.pi/3), np.sin(np.pi/3)]],\n    positions=[[0, 0]],\n    boundary_condition=False,\n    custom_edges=[[edge, (\"ZZ\", -1.0)] for edge in edges], \n    custom_nodes=[[i, (\"X\", -0.5)] for i in range(3*3)],\n)\n```\n\n----------------------------------------\n\nTITLE: QNode Gradient Computation with argnum in Python\nDESCRIPTION: This snippet computes the gradient of a QNode, specifying the trainable parameters to consider using the `argnum` keyword argument.  It demonstrates how to calculate the gradient with respect to a specific subset of the input parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qnode1 = qml.QNode(circuit, dev, diff_method=\"parameter-shift\", argnum=[0,1])\n>>> print(qml.grad(qnode1)(x,y))\n(array(0.31434679), array(0.67949903))\n```\n\n----------------------------------------\n\nTITLE: Accessing Operands of a Composite Operator in PennyLane\nDESCRIPTION: This snippet shows how to access the operands (constituent operators) of a composite operator using the op.operands attribute in PennyLane. This is useful for inspecting and manipulating the individual components of complex operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> op = qml.sum(X(0), X(1), X(2))\n>>> op.operands\n(X(0), X(1), X(2))\n```\n\n----------------------------------------\n\nTITLE: Differentiable Quantum Gradient Transform in PennyLane\nDESCRIPTION: Demonstrates how to obtain higher-order derivatives by using quantum gradient transforms. The code calls qml.grad on a circuit using the parameter-shift gradient method. The expected output is a tensor with a gradient.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.grad(qml.gradients.param_shift(circuit))(0.5)\ntensor(-0.87758256, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Drawing QNode Before and After Deferring (pycon)\nDESCRIPTION: This example illustrates the effect of the `defer_measurements` transform by drawing the QNode before and after its application. The deferred measurement principle replaces mid-circuit measurements with controlled operations, adding auxiliary qubits to the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(my_qnode)(*pars))\n0: ──RY(0.64)─╭●───────RY(0.25)─┤  Probs\n1: ───────────╰X──┤↗├──║────────┤\n                   ╚═══╩════════╡  <MCM>\n>>> print(qml.draw(deferred_qnode)(*pars))\n0: ──RY(0.64)─╭●────╭RY(0.25)─┤  Probs\n1: ───────────╰X─╭●─│─────────┤\n2: ──────────────╰X─╰●────────┤  <None>\n```\n\n----------------------------------------\n\nTITLE: Pauli Group Construction and Manipulation\nDESCRIPTION: This snippet showcases PennyLane's functionality for constructing and manipulating the Pauli group. It demonstrates how to generate Pauli group elements, multiply them, convert them to strings and back, and calculate their matrix representation. The code relies on the `qml.grouping` module.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.grouping import pauli_group\n>>> pauli_group_1_qubit = list(pauli_group(1))\n>>> pauli_group_1_qubit\n[Identity(wires=[0]), PauliZ(wires=[0]), PauliX(wires=[0]), PauliY(wires=[0])]\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.grouping import pauli_group, pauli_mult\n>>> wire_map = {'a' : 0, 'b' : 1, 'c' : 2}\n>>> pg = list(pauli_group(3, wire_map=wire_map))\n>>> pg[3]\nPauliZ(wires=['b']) @ PauliZ(wires=['c'])\n>>> pg[55]\nPauliY(wires=['a']) @ PauliY(wires=['b']) @ PauliZ(wires=['c'])\n>>> pauli_mult(pg[3], pg[55], wire_map=wire_map)\nPauliY(wires=['a']) @ PauliX(wires=['b'])\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.grouping import pauli_word_to_string, string_to_pauli_word\n>>> pauli_word_to_string(pg[55], wire_map=wire_map)\n'YYZ'\n>>> string_to_pauli_word('ZXY', wire_map=wire_map)\nPauliZ(wires=['a']) @ PauliX(wires=['b']) @ PauliY(wires=['c'])\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.grouping import pauli_word_to_matrix\n>>> wire_map = {'a' : 0, 'b' : 1}\n>>> pauli_word = qml.PauliZ('b')  # corresponds to Pauli 'IZ'\n>>> pauli_word_to_matrix(pauli_word, wire_map=wire_map)\narray([[ 1.,  0.,  0.,  0.],\n       [ 0., -1.,  0., -0.],\n       [ 0.,  0.,  1.,  0.],\n       [ 0., -0.,  0., -1.]])\n```\n\n----------------------------------------\n\nTITLE: Executing and Differentiating PennyLane Circuit\nDESCRIPTION: This code demonstrates how to execute a PennyLane quantum circuit and compute its gradient. It initializes an array of angles, executes the circuit with these angles, and calculates the gradient of the circuit's output with respect to the input angles.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_17\n\nLANGUAGE: pycon\nCODE:\n```\n>>> angles = np.array([1.23, 4.56], requires_grad=True)\n>>> circuit(angles)\ntensor(0.33423773, requires_grad=True)\n>>> qml.grad(circuit)(angles)\narray([-0.9424888,  0.       ])\n```\n\n----------------------------------------\n\nTITLE: Using the SPSA Optimizer\nDESCRIPTION: This code snippet demonstrates how to use the `qml.SPSAOptimizer`.  It initializes the optimizer with a maximum number of iterations and performs optimization steps within a loop.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nmax_iterations = 50\nopt = qml.SPSAOptimizer(maxiter=max_iterations) \n\nfor _ in range(max_iterations):\n    params, cost = opt.step_and_cost(cost, params)\n```\n\n----------------------------------------\n\nTITLE: Decomposing a Quantum Function in PennyLane\nDESCRIPTION: This code demonstrates how to decompose a quantum function using PennyLane's `qml.transforms.decompose`. The `max_expansion` parameter controls how many levels of decomposition are applied.  The example shows how to print the circuit after one and two levels of decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndecompose_once = qml.transforms.decompose(qfunc, max_expansion=1)\ndecompose_twice = qml.transforms.decompose(qfunc, max_expansion=2)\n```\n\n----------------------------------------\n\nTITLE: Hermitian Conjugate of RX Gate in PennyLane\nDESCRIPTION: Shows how to obtain the adjoint (Hermitian conjugate) of a `qml.RX` gate.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nqml.RX(1., wires=0).adjoint()\n```\n\n----------------------------------------\n\nTITLE: Executing the Quantum Circuit\nDESCRIPTION: This snippet demonstrates the execution of the defined quantum circuit and displays the resulting expectation value. The `circuit()` function, previously defined with a Hamiltonian, is called to compute the result. It showcases the practical application of the constructed Hamiltonian within a PennyLane workflow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n-2.0\n```\n\n----------------------------------------\n\nTITLE: Convergence of Expectation Value with Increasing Shots in PennyLane\nDESCRIPTION: This example illustrates how the expectation value converges to the exact value as the number of shots increases. It uses a Hadamard gate and measures the expectation of PauliZ, demonstrating the impact of shot number on measurement accuracy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n# fix seed to make results reproducible\nnp.random.seed(1)\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Construction with OpenFermion-PySCF Backend\nDESCRIPTION: This code demonstrates how to construct a molecular Hamiltonian using the OpenFermion-PySCF backend in PennyLane. It initializes a molecule and then uses the `qml.qchem.molecular_hamiltonian` function with the `method='pyscf'` argument to specify the backend. The backend is set to 'pyscf', but 'openfermion' would also be a valid option if the necessary packages are installed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 2.0]])\nmolecule = qml.qchem.Molecule(symbols, geometry, charge=0, mult=1, basis_name='sto-3g')\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(molecule, method='pyscf')\n```\n\n----------------------------------------\n\nTITLE: Replicating QubitDevice Caching Behavior with QNode\nDESCRIPTION: This code demonstrates how to replicate the removed `QubitDevice` caching behavior by creating a `cache` object (e.g., a dictionary) and passing it to the `QNode`. It defines a quantum circuit using `BasicEntanglerLayers` and an expectation value measurement and then sets up a QNode with a cache. It depends on the numpy library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 4\nwires = range(n_wires)\n\ndev = qml.device('default.qubit', wires=n_wires)\n\ncache = {}\n\n@qml.qnode(dev, diff_method='parameter-shift', cache=cache)\ndef expval_circuit(params):\n    qml.templates.BasicEntanglerLayers(params, wires=wires, rotation=qml.RX)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliY(1) @ qml.PauliX(2) @ qml.PauliZ(3))\n\nshape = qml.templates.BasicEntanglerLayers.shape(5, n_wires)\nparams = np.random.random(shape)\n```\n\n----------------------------------------\n\nTITLE: Differentiable Dipole Moment Observable with qml.qchem in PennyLane\nDESCRIPTION: Shows how to construct a differentiable dipole moment observable using `qml.qchem.dipole_moment`.  This involves defining the molecular structure (symbols and geometry) and then calling the function to create the observable. The constructed dipole moment can then be used for quantum chemistry calculations within PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nsymbols  = ['H', 'H']\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\nmol = qml.qchem.Molecule(symbols, geometry)\nargs = [geometry]\nD = qml.qchem.dipole_moment(mol)(*args)\n```\n\n----------------------------------------\n\nTITLE: Parameter-Shift Gradients with Broadcasting in PennyLane\nDESCRIPTION: This code showcases how to use parameter-shift gradients with broadcasting enabled in PennyLane. It defines a quantum circuit with two parameters, `x` and `y`, applies RX and RY rotations, and returns the expectation value of a tensor product of PauliZ operators. The `qml.gradients.param_shift` transform is used with the `broadcast=True` argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x, y):\n    qml.RX(x, wires=0)\n    qml.RY(y, wires=1)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Running Grover's Search Algorithm in PennyLane\nDESCRIPTION: Demonstrates running Grover's search algorithm for different number of iterations, showing how the probability of the marked state increases with more iterations. It returns tensor values representing the probability distribution over the wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> GroverSearch(num_iterations=1)\ntensor([0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125, 0.03125,\n        0.78125], requires_grad=True)\n>>> GroverSearch(num_iterations=2)\ntensor([0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125, 0.0078125,\n    0.0078125, 0.9453125], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Expectation Value of Pauli String\nDESCRIPTION: Calculates the expectation value of the Pauli string \"ZZZ\" using PennyLane's `qml.expval` and `qml.pauli.string_to_pauli_word` functions. This demonstrates the use of Pauli strings in quantum computations within PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nreturn qml.expval(qml.pauli.string_to_pauli_word(\"ZZZ\"))\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit for Mixed State Device with Backpropagation\nDESCRIPTION: This code defines a quantum circuit for the `default.mixed` device using backpropagation with the JAX interface. It initializes a `default.mixed` device with 2 wires and defines a quantum node that applies `RX` and `RY` gates, returning the expectation value of a sum of `PauliZ` operators. The `diff_method` is set to \"backprop\" and the `interface` is set to \"jax\".\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.mixed\", wires=2)\n\n@qml.qnode(dev, diff_method=\"backprop\", interface=\"jax\")\ndef circuit(angles):\n    qml.RX(angles[0], wires=0)\n    qml.RY(angles[1], wires=1)\n    return qml.expval(qml.PauliZ(0) + qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Qiskit to PennyLane: Convert and differentiate parameterized circuit\nDESCRIPTION: This code converts a parameterized Qiskit circuit to PennyLane, defines measurements and converts it into a QNode. The QNode can then be evaluated and differentiated, showcasing the seamless integration and differentiability of Qiskit circuits within PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nmeasurements = qml.expval(qml.PauliZ(0))\nqfunc = qml.from_qiskit(qc, measurements)\nqnode = qml.QNode(qfunc, dev)\n```\n\n----------------------------------------\n\nTITLE: Preparing a Custom Quantum State and Calculating Expectation Value\nDESCRIPTION: This example shows how to prepare a custom quantum state using `mottonen.MottonenStatePreparation` and then calculate the expectation value of `qml.PauliZ(0)`. It defines a quantum circuit `circuit` that prepares the state specified by `inputstate` and returns the expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\ninputstate = [np.sqrt(0.2), np.sqrt(0.3), np.sqrt(0.4), np.sqrt(0.1)]\n\n@qml.qnode(dev)\ndef circuit():\n    mottonen.MottonenStatePreparation(inputstate,wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Executing with Shot Vectors\nDESCRIPTION: Demonstrates executing a quantum tape with a shot vector.  The result is a tuple of results, where each entry corresponds to the result when using the respective number of shots.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nmeasurements = (qml.expval(qml.Z(0)), qml.probs(wires=0))\ntape = qml.tape.QuantumScript((), measurements, shots=(50,50,50))\nresult = qml.device('default.qubit').execute(tape)\nresult\nresult[0]\ntape = qml.tape.QuantumScript((), [qml.counts(wires=0)], shots=(1, 10, 100))\nqml.device('default.qubit').execute(tape)\n```\n\n----------------------------------------\n\nTITLE: Drawing Compiled Quantum Circuit (Pycon)\nDESCRIPTION: Illustrates how to draw the compiled quantum circuit using `qml.draw` after applying the default compilation pipeline. The output shows the optimized circuit structure. Requires PennyLane installation and a compiled quantum function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(qfunc)(0.2, 0.3, 0.4))\n 0: ──H───RX(0.6)──────────────────┤ ⟨Z⟩\n 1: ──H──╭X────────────────────╭C──┤\n 2: ──H──╰C────────RX(0.3)──Y──╰Z──┤\n```\n\n----------------------------------------\n\nTITLE: Circuit Cutting with Automatic Graph Partitioning in PennyLane\nDESCRIPTION: Illustrates the use of the `cut_circuit` transform with `auto_cutter=True` for automatic graph partitioning in quantum circuits.  This feature leverages the KaHyPar graph partitioning framework to cut arbitrary tape-converted graphs, enabling the distribution of quantum computations across multiple devices or smaller quantum processors. The example requires the separate installation of `KaHyPar`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@qml.cut_circuit(auto_cutter=True)\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    qml.RY(0.9, wires=1)\n    qml.RX(0.3, wires=2)\n    qml.CZ(wires=[0, 1])\n    qml.RY(-0.4, wires=0)\n    qml.CZ(wires=[1, 2])\n    return qml.expval(qml.grouping.string_to_pauli_word(\"ZZZ\"))\n```\n\n----------------------------------------\n\nTITLE: Calculating Polynomial with OutPoly (Python)\nDESCRIPTION: This snippet demonstrates the use of `qml.OutPoly` to encode and compute a polynomial function within a quantum circuit.  It defines a function `f(x1, x2)` representing the polynomial 3x1^2 - x1x2, loads the inputs x1 and x2 into registers using `qml.BasisEmbedding`, applies the `qml.OutPoly` template, and samples the output wires to obtain the result.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nwires = qml.registers({\"x1\": 1, \"x2\": 2, \"output\": 2})\n\ndef f(x1, x2):\n    return 3 * x1 ** 2 - x1 * x2\n\n@qml.qnode(qml.device(\"default.qubit\", shots = 1))\ndef circuit():\n    # load values of x1 and x2\n    qml.BasisEmbedding(1, wires=wires[\"x1\"])\n    qml.BasisEmbedding(2, wires=wires[\"x2\"])\n\n    # apply the polynomial\n    qml.OutPoly(\n        f,\n        input_registers = [wires[\"x1\"], wires[\"x2\"]],\n        output_wires = wires[\"output\"])\n\n    return qml.sample(wires=wires[\"output\"])\n```\n\n----------------------------------------\n\nTITLE: Accessing Dataset Properties\nDESCRIPTION: This snippet shows how to access properties (e.g., 'molecule', 'hf_state') of a loaded dataset.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nH2data.molecule\nprint(H2data.hf_state)\n```\n\n----------------------------------------\n\nTITLE: Tracking Cost and Job ID in PennyLane Device\nDESCRIPTION: This snippet demonstrates how to track custom information, such as cost and job ID, within a PennyLane device using the `tracker.update` method. The code assigns a price for execution and a job ID, then updates the device's tracker with these values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nprice_for_execution = 0.10\njob_id = \"abcde\"\nself.tracker.update(price=price_for_execution, job_id=job_id)\n```\n\n----------------------------------------\n\nTITLE: Using a Custom Device with Tracker in PennyLane\nDESCRIPTION: This snippet shows how to use the custom device `MyDevice` with the simulator tracker to track execution details. It demonstrates executing a quantum tape, accessing the tracker's history, and inspecting information about batches, simulations, executions, results, and resources.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndev = MyDevice()\ntape = qml.tape.QuantumTape([qml.S(0)], [qml.expval(qml.X(0))])\nwith dev.tracker:\n    out = dev.execute(tape)\n```\n\nLANGUAGE: python\nCODE:\n```\n0.0\n```\n\nLANGUAGE: python\nCODE:\n```\ndev.tracker.history\n```\n\nLANGUAGE: python\nCODE:\n```\n{'batches': [1],\n 'simulations': [1],\n 'executions': [1],\n 'results': [0.0],\n 'resources': [Resources(num_wires=1, num_gates=1,\n gate_types=defaultdict(<class 'int'>, {'S': 1}),\n gate_sizes=defaultdict(<class 'int'>, {1: 1}), depth=1,\n shots=Shots(total_shots=None, shot_vector=()))]}\n```\n\n----------------------------------------\n\nTITLE: Minimizing Cost Function with RotosolveOptimizer\nDESCRIPTION: This code demonstrates how to minimize a cost function using the `RotosolveOptimizer`. It initializes the parameters, sets the number of frequencies per parameter, and iteratively performs optimization steps, printing the cost before each step and the minimization substeps.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Initial parameters\ninit_param = [\n    np.array([0.3, 0.2, 0.67], requires_grad=True),\n    np.array(1.1, requires_grad=True),\n    np.array([-0.2, 0.1, -2.5], requires_grad=True),\n]\n# Numbers of frequencies per parameter\nnum_freqs = [[1, 1, 1], 3, [2, 2, 2]]\n\nopt = qml.RotosolveOptimizer()\nparam = init_param.copy()\n```\n\n----------------------------------------\n\nTITLE: PauliWord and PauliSentence Usage in PennyLane\nDESCRIPTION: Demonstrates the use of `qml.pauli.PauliWord` and `qml.pauli.PauliSentence` to represent and manipulate tensor products and linear combinations of Pauli operators in PennyLane. It showcases multiplication and matrix extraction for these operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> pw1 = qml.pauli.PauliWord({0:\"X\", 1:\"Z\"})\n>>> pw2 = qml.pauli.PauliWord({0:\"Y\", 1:\"Z\"})\n>>> pw1, pw2\n(X(0) @ Z(1), Y(0) @ Z(1))\n>>> pw1 * pw2\n(Z(0), 1j)\n>>> pw1.to_mat(wire_order=[0,1])\narray([[ 0,  0,  1,  0],\n       [ 0,  0,  0, -1],\n       [ 1,  0,  0,  0],\n       [ 0, -1,  0,  0]])\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Nested Abstracted Axes\nDESCRIPTION: This snippet demonstrates how to use `abstracted_axes` when the arguments are in a nested structure (e.g., a dictionary). The `abstracted_axes` argument must have the same structure as the arguments, with each tensor replaced by a dictionary indicating which axes are abstract.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nargs = ({\"x\": x, \"y\": y},)\nabstracted_axes = ({\"x\": x_axes, \"y\": y_axes},)\njax.make_jaxpr(f, abstracted_axes=abstracted_axes)(*args)\n```\n\n----------------------------------------\n\nTITLE: Comparing Device Executions with and without Optimization in Pycon\nDESCRIPTION: This code compares the number of device executions with and without observable optimization using the `ExpvalCost` class in PennyLane. The example demonstrates that optimizing measurements can lead to fewer device executions, improving performance. It executes the cost functions and prints the number of executions for both optimized and non-optimized cases.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> cost_opt(params)\n>>> ex_opt = dev.num_executions\n>>> cost_no_opt(params)\n>>> ex_no_opt = dev.num_executions - ex_opt\n>>> print(\"Number of executions:\", ex_no_opt)\nNumber of executions: 2\n>>> print(\"Number of executions (optimized):\", ex_opt)\nNumber of executions (optimized): 1\n```\n\n----------------------------------------\n\nTITLE: Using Hadamard Gradient as Differentiation Method in QNode with JAX in Pycon\nDESCRIPTION: This example demonstrates how to register the Hadamard test gradient transform directly as the quantum gradient transform to use during autodifferentiation with JAX. The circuit is defined with `diff_method=\"hadamard\"`, and the gradient is computed using `jax.jacobian`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> @qml.qnode(dev, interface=\"jax\", diff_method=\"hadamard\")\n... def circuit(params):\n...     qml.RX(params[0], wires=0)\n...     qml.RY(params[1], wires=0)\n...     qml.RX(params[2], wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> params = jax.numpy.array([0.1, 0.2, 0.3])\n>>> jax.jacobian(circuit)(params)\nArray([-0.3875172 , -0.18884787, -0.38355705], dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Batch Input Usage After Breaking Change (Python)\nDESCRIPTION: This example demonstrates the correct usage of `qml.batch_input` after the breaking change. The `argnum` argument is now mandatory and must specify the index of the batched inputs within the quantum tape parameters. In this case, `argnum=1` indicates that 'inputs' is the batched parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_40\n\nLANGUAGE: Python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=None)\n\n@qml.batch_input(argnum=1)\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\ndef circuit(inputs, weights):\n    qml.RY(weights[0], wires=0)\n    qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\n    qml.RY(weights[1], wires=1)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Differentiable Pauli Decomposition\nDESCRIPTION: This code defines a function find_coeffs that calculates the coefficients of a Pauli decomposition of a matrix using qml.pauli_decompose. It is then used with JAX to compute the Jacobian of the coefficients. Dependencies: PennyLane, NumPy, JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef find_coeffs(p):\n    mat = np.array([[3, p], [p, 3]])\n    A = qml.pauli_decompose(mat)\n    return A.coeffs\n```\n\n----------------------------------------\n\nTITLE: Create a Quantum Circuit with Custom Error Operations in PennyLane (Python)\nDESCRIPTION: This code demonstrates the creation of a quantum circuit using PennyLane with the custom error operation, MyErrorOperation. It defines a QNode that applies the custom error operation on different wires and returns the state. The device used is a null.qubit device, meaning the circuit is not executed, and is for resource estimation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"null.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    MyErrorOperation(0.1, wires=0)\n    MyErrorOperation(0.2, wires=1)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Decorator Syntax Recommendation with functools.partial\nDESCRIPTION: This code demonstrates the recommended decorator syntax using `functools.partial` for applying transforms with keyword arguments in PennyLane. It showcases a way to migrate from the deprecated syntax, promoting a clearer and more maintainable structure for applying transformations to quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@functools.partial(transform_fn, **transform_kwargs)\n@qml.qnode(dev)\ndef circuit():\n    ...\n```\n\n----------------------------------------\n\nTITLE: State Gradient with TensorFlow Interface in PennyLane\nDESCRIPTION: This code demonstrates the use of the TensorFlow interface to differentiate the quantum state directly. This example shows how using a complex-number interface (JAX, TensorFlow, or Torch) supports backpropagation through the quantum state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef state_vector_grad_tf():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, interface='tf', diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.state()\n\n    x = tf.Variable([0.1], trainable=True, dtype=np.complex64)\n    with tf.GradientTape() as tape:\n        out = circuit(x)\n\n    print(tape.jacobian(out, [x]))\n```\n\n----------------------------------------\n\nTITLE: Speedier Quantum Natural Gradient with Adjoint Metric Tensor\nDESCRIPTION: Illustrates the use of `qml.adjoint_metric_tensor` to compute the metric tensor for quantum natural gradient calculation, improving performance for larger circuits on statevector simulators. It defines a quantum circuit and computes the metric tensor using the adjoint method. The circuit should only use trainable gates, and shots=None is required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit(x, y):\n    qml.Rot(*x[0], wires=0)\n    qml.Rot(*x[1], wires=1)\n    qml.Rot(*x[2], wires=2)\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[1, 2])\n    qml.CNOT(wires=[2, 0])\n    qml.RY(y[0], wires=0)\n    qml.RY(y[1], wires=1)\n    qml.RY(y[0], wires=2)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliY(1))\n\nx = np.array([[0.2, 0.4, -0.1], [-2.1, 0.5, -0.2], [0.1, 0.7, -0.6]], requires_grad=False)\ny = np.array([1.3, 0.2], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Decomposing Hamiltonian Evolution into PauliRot Operation\nDESCRIPTION: This example shows how a Hamiltonian evolution of a Pauli word (e.g., `qml.PauliZ(0) @ qml.PauliX(1)`) is decomposed into a `qml.PauliRot` operation using the `qml.evolve` function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.evolve(qml.PauliZ(0) @ qml.PauliX(1)).decomposition()\n[PauliRot((2+0j), ZX, wires=[0, 1])]\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Dataset\nDESCRIPTION: This code demonstrates creating a custom dataset using the `qml.data.Dataset` class. It constructs a Hamiltonian, calculates its energies, and then creates a dataset containing the Hamiltonian and energies.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [1, 0.5]\nobservables = [qml.Z(0), qml.X(1)]\nH = qml.Hamiltonian(coeffs, observables)\nenergies, _ = np.linalg.eigh(qml.matrix(H)) #Calculate the energies\ndataset = qml.data.Dataset(data_name = \"Example\", hamiltonian=H, energies=energies)\ndataset.data_name\ndataset.hamiltonian\ndataset.energies\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit with Python Control Flow\nDESCRIPTION: This code snippet demonstrates the use of Python control flow within a quantum circuit when program capture is enabled. It defines a QNode that applies either a Hadamard gate or an RX gate based on the loop index. This showcases the ability to use standard Python `for` and `if` statements to control the execution of quantum operations within PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nqml.capture.enable()\ndev = qml.device(\"default.qubit\", wires=[0, 1, 2])\n\n@qml.qnode(dev)\ndef circuit(num_loops: int):\n    for i in range(num_loops):\n        if i % 2 == 0:\n            qml.H(i)\n        else:\n            qml.RX(1, i)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Convert Qiskit SparsePauliOp to PennyLane Operator and display\nDESCRIPTION: This snippet demonstrates converting a Qiskit SparsePauliOp operator to a PennyLane operator using `qml.from_qiskit_op`. It allows leveraging existing Qiskit operators within PennyLane workflows and displaying the PennyLane operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\npl_op = qml.from_qiskit_op(qiskit_op)\n```\n\n----------------------------------------\n\nTITLE: Using the Custom HOP with `jax.numpy.sum`\nDESCRIPTION: This code defines a `workflow` function that uses the custom `bind_prim` function with `jax.numpy.sum` as the inner function. It creates a jaxpr for this workflow, demonstrating the integration of the custom HOP with a standard JAX function for summing the values of a dynamically sized array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef workflow(x):\n    return bind_prim(jax.numpy.sum, x)\n\njaxpr = jax.make_jaxpr(workflow, abstracted_axes=(\"a\", ))(jax.numpy.array([1,2,3]))\njaxpr\n```\n\n----------------------------------------\n\nTITLE: Summing Operators with qml.op_sum in PennyLane\nDESCRIPTION: This code demonstrates how to sum multiple PennyLane operators using the `qml.op_sum` function. It sums PauliX, PauliY, and PauliZ operators and then accesses the matrix representation and terms of the resulting summed operator. This requires the `pennylane` library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> ops_to_sum = [qml.PauliX(0), qml.PauliY(1), qml.PauliZ(0)]\n>>> summed_ops = qml.op_sum(*ops_to_sum)\n>>> summed_ops\nPauliX(wires=[0]) + PauliY(wires=[1]) + PauliZ(wires=[0])\n>>> qml.matrix(summed_ops)\narray([[ 1.+0.j,  0.-1.j,  1.+0.j,  0.+0.j],\n       [ 0.+1.j,  1.+0.j,  0.+0.j,  1.+0.j],\n       [ 1.+0.j,  0.+0.j, -1.+0.j,  0.-1.j],\n       [ 0.+0.j,  1.+0.j,  0.+1.j, -1.+0.j]])\n>>> summed_ops.terms()\n([1.0, 1.0, 1.0], (PauliX(wires=[0]), PauliY(wires=[1]), PauliZ(wires=[0])))\n```\n\n----------------------------------------\n\nTITLE: Quantum Gradients with Non-Differentiable Data Arguments\nDESCRIPTION: This example demonstrates how to handle non-differentiable data arguments within a PyTorch-interfacing QNode. Setting `requires_grad=False` for the data tensor prevents gradients from being computed with respect to the data, ensuring that only trainable parameters are updated during optimization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev, interface='torch')\ndef circuit3(weights, data):\n    qml.AmplitudeEmbedding(data, normalize=True, wires=[0, 1])\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(weights[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nweights = torch.tensor([0.1, 0.2, 0.3], requires_grad=True)\ndata = torch.tensor([0.4741, 0.9257, 0.5541, 0.3137], requires_grad=False)\nresult = circuit3(weights, data)\nresult.backward()\n```\n\n----------------------------------------\n\nTITLE: Split Non-Commuting Observables\nDESCRIPTION: This snippet demonstrates the usage of the `qml.split_non_commuting` transform, which splits a quantum function based on the commutativity of the observables.  The `@qml.transforms.split_non_commuting` decorator splits the circuit into 2 circuits, one that measures PauliX and another that measures PauliZ.  This is done because PauliX and PauliZ do not commute.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.transforms.split_non_commuting\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x,wires=0)\n    return [qml.expval(qml.PauliX(0)), qml.expval(qml.PauliZ(0))]\n```\n\n----------------------------------------\n\nTITLE: Calculating Hartree-Fock Energy Gradients with Jax in PennyLane\nDESCRIPTION: This code demonstrates how to compute Hartree-Fock energy gradients with respect to atomic coordinates using PennyLane and Jax. It defines a molecule using atomic symbols and geometry, and then uses jax.grad to calculate the energy gradient. The mol.coordinates are passed as arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\nimport jax\n\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\n\nmol = qml.qchem.Molecule(symbols, geometry)\n\nargs = [jax.numpy.array(mol.coordinates)]\n```\n\n----------------------------------------\n\nTITLE: Batch Shots Device Initialization in PennyLane\nDESCRIPTION: This example demonstrates how to initialize a PennyLane device with a batch of shot values. This allows for course-grained statistics across different subsets of shots. The device executes QNodes using the total number of shots but performs statistics on subsets defined by the list/tuple structure. The structure defines the number of shots and how many times that number of shots is repeated.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device(\"my_device\", shots=[5, (10, 3), 100])\n```\n\n----------------------------------------\n\nTITLE: Initializing Clifford Device and Defining Quantum Circuit in PennyLane\nDESCRIPTION: This code initializes the 'default.clifford' device in PennyLane, specifying that the state should be represented in the Tableau form. It then defines a quantum circuit using Clifford gates (CNOT, PauliX, ISWAP, Hadamard) and returns the state vector.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.clifford\", tableau=True)\n@qml.qnode(dev)\ndef circuit():\n    qml.CNOT(wires=[0, 1])\n    qml.PauliX(wires=[1])\n    qml.ISWAP(wires=[0, 1])\n    qml.Hadamard(wires=[0])\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Drawing Mid-Circuit Measurements in PennyLane\nDESCRIPTION: This snippet illustrates how to draw a quantum circuit with mid-circuit measurements using PennyLane's `qml.draw()` function. It defines a quantum circuit with qubit reset, postselection, conditioning, and final measurements. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef circuit():\n    m0 = qml.measure(0, reset=True)\n    m1 = qml.measure(1, postselect=1)\n    qml.cond(m0 - m1 == 0, qml.S)(0)\n    m2 = qml.measure(1)\n    qml.cond(m0 + m1 == 2, qml.T)(0)\n    qml.cond(m2, qml.PauliX)(1)\n```\n\n----------------------------------------\n\nTITLE: Identity Operator with Multiple Wires\nDESCRIPTION: This example demonstrates how to create an identity operator in PennyLane that acts on multiple wires.  It shows how to obtain the matrix representation, sparse matrix representation, and eigenvalues of the identity operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_30\n\nLANGUAGE: pycon\nCODE:\n```\n>>> id_op = qml.Identity([0, 1])\n>>> id_op.matrix()\narray([[1., 0., 0., 0.],\n       [0., 1., 0., 0.],\n       [0., 0., 1., 0.],\n       [0., 0., 0., 1.]])\n>>> id_op.sparse_matrix()\n<4x4 sparse matrix of type '<class 'numpy.float64'>'>\n    with 4 stored elements in Compressed Sparse Row format>\n>>> id_op.eigvals()\narray([1., 1., 1., 1.])\n```\n\n----------------------------------------\n\nTITLE: TwoLocalSwapNetwork Template Example\nDESCRIPTION: This example demonstrates the usage of the `qml.TwoLocalSwapNetwork` template. It creates a quantum device with 5 qubits, initializes random weights, and defines an acquaintances function that applies either a CRY or CRZ gate based on the wire difference. It returns the state of the circuit after applying the TwoLocalSwapNetwork.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_25\n\nLANGUAGE: python3\nCODE:\n```\ndev = qml.device('default.qubit', wires=5)\nweights = np.random.random(size=qml.templates.TwoLocalSwapNetwork.shape(len(dev.wires)))\nacquaintances = lambda index, wires, param: (qml.CRY(param, wires=index)\n                                 if np.abs(wires[0]-wires[1]) else qml.CRZ(param, wires=index))\n@qml.qnode(dev)\ndef swap_network_circuit():\n    qml.templates.TwoLocalSwapNetwork(dev.wires, acquaintances, weights, fermionic=False)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Collect Measurement Statistics for Mid-Circuit Measurements\nDESCRIPTION: This code shows how to collect measurement statistics for mid-circuit measurements in PennyLane. The `qml.measure` function is used to perform a measurement in the middle of the circuit, and the results can be used for further computations within the same circuit. The example returns the expectation value of PauliZ on wire 0, the expectation value of the mid-circuit measurement outcome, and the samples from the mid-circuit measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circ(x, y):\n    qml.RX(x, wires=0)\n    qml.RY(y, wires=1)\n    m0 = qml.measure(1)\n    return qml.expval(qml.PauliZ(0)), qml.expval(m0), qml.sample(m0)\n```\n\n----------------------------------------\n\nTITLE: Deferred Measurements Circuit Output (PyCon)\nDESCRIPTION: This snippet shows the output of a `defer_measurements` transformed circuit without postselection optimization. It displays the circuit with three gates controlled on the measured qubits, each corresponding to a combination that satisfies the condition `mcm0 + mcm1 + mcm2 == 1`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(qml.defer_measurements(node, reduce_postselected=False))(0.6))\n0: ──RX(0.60)──|0⟩⟨0|─╭●─────────────────────────────────────────────┤ ╭<Z@Z>\n1: ──RX(0.60)─────────│──╭●─╭X───────────────────────────────────────┤ │\n2: ──RX(0.60)─────────│──│──│───|1⟩⟨1|─╭○────────╭○────────╭●────────┤ │\n3: ───────────────────│──│──│──────────├RX(0.50)─├RX(0.50)─├RX(0.50)─┤ ╰<Z@Z>\n```\n\n----------------------------------------\n\nTITLE: Using PassthruQNode with TensorFlow for Backpropagation\nDESCRIPTION: This snippet demonstrates the use of `PassthruQNode` with the `default.tensor.tf` device in PennyLane to leverage TensorFlow's automatic differentiation capabilities directly.  This avoids parameter-shift rule calculations. Requires PennyLane and TensorFlow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.tensor.tf', wires=2)\n\n@qml.qnode(dev, diff_method=\"backprop\")\ndef circuit(params):\n    qml.RX(params[0], wires=0)\n    qml.RX(params[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0))\n\nqnode = PassthruQNode(circuit, dev)\nparams = tf.Variable([0.3, 0.1])\n\nwith tf.GradientTape() as tape:\n    tape.watch(params)\n    res = qnode(params)\n\ngrad = tape.gradient(res, params)\n```\n\n----------------------------------------\n\nTITLE: Mapping Wires of an Operator\nDESCRIPTION: Demonstrates the usage of `qml.map_wires()` to map the wires of an arbitrary operator to new wires. It includes an example showcasing the creation of an operator, defining a wire map, and applying the function to remap the wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.RX(0.54, wires=0) + qml.PauliX(1) + (qml.PauliZ(2) @ qml.RY(1.23, wires=3))\n>>> op\n(RX(0.54, wires=[0]) + PauliX(wires=[1])) + (PauliZ(wires=[2]) @ RY(1.23, wires=[3]))\n>>> wire_map = {0: 10, 1: 11, 2: 12, 3: 13}\n>>> qml.map_wires(op, wire_map)\n(RX(0.54, wires=[10]) + PauliX(wires=[11])) + (PauliZ(wires=[12]) @ RY(1.23, wires=[13]))\n```\n\n----------------------------------------\n\nTITLE: VQE Result (Tensor Output)\nDESCRIPTION: This text snippet shows the expected output from a VQE simulation.  It displays the calculated energy as a tensor with a gradient, which enables optimization of the circuit parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/chemistry.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\ntensor(-1.13618912, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: QubitUnitary Decomposition in PennyLane\nDESCRIPTION: Demonstrates the decomposition of a single-qubit QubitUnitary operation into Rot operations in PennyLane. This utilizes the `QubitUnitary.decomposition` method to express a unitary matrix as a sequence of rotations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.QubitUnitary.decomposition(U, wires=0)\n[Rot(-0.24209530281458358, 1.1493817777199102, 1.733058145303424, wires=[0])]\n```\n\n----------------------------------------\n\nTITLE: Adjoint Transform Application to Gate\nDESCRIPTION: This code demonstrates the application of the `qml.adjoint` transform directly to a PennyLane gate. It applies the adjoint of the `qml.RX` gate with a given parameter to a specific wire, effectively applying `RX(-0.123)`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nqml.adjoint(qml.RX)(0.123, wires=0) # applies RX(-0.123)\n```\n\n----------------------------------------\n\nTITLE: Adding Scalar to PennyLane Operator\nDESCRIPTION: This code demonstrates adding a scalar to a PennyLane operator. The scalar is interpreted as a properly-sized identity matrix. The code creates a sum_op by adding 5 to a PauliX gate acting on wire 0, and then it computes the matrix representation of the resulting operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> sum_op = 5 + qml.PauliX(0)\n>>> sum_op.matrix()\narray([[5., 1.],\n       [1., 5.]])\n```\n\n----------------------------------------\n\nTITLE: Estimating Phase with QuantumPhaseEstimation in PennyLane\nDESCRIPTION: This snippet demonstrates how to estimate a phase using the `QuantumPhaseEstimation` template in PennyLane. It sets up a quantum circuit with estimation qubits and a target qubit, applies the `QuantumPhaseEstimation` operation, and then estimates the phase from the resulting probabilities. The estimated phase is rescaled based on the convention of the RX gate.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nn_estimation_wires = 5\nestimation_wires = range(1, n_estimation_wires + 1)\n\ndev = qml.device(\"default.qubit\", wires=n_estimation_wires + 1)\n\n@qml.qnode(dev)\ndef circuit():\n    # Start in the |+> eigenstate of the unitary\n    qml.Hadamard(wires=target_wires)\n\n    QuantumPhaseEstimation(\n        unitary,\n        target_wires=target_wires,\n        estimation_wires=estimation_wires,\n    )\n\n    return qml.probs(estimation_wires)\n\nphase_estimated = np.argmax(circuit()) / 2 ** n_estimation_wires\n\n# Need to rescale phase due to convention of RX gate\nphase_estimated = 4 * np.pi * (1 - phase)\n```\n\n----------------------------------------\n\nTITLE: Converting Qiskit Noise Models to PennyLane\nDESCRIPTION: This snippet demonstrates how to convert a Qiskit noise model into a PennyLane `NoiseModel` using `qml.from_qiskit_noise`.  It first creates a Qiskit noise model with depolarizing errors, then converts it to a PennyLane NoiseModel.  Requires PennyLane, qiskit-aer, and pennylane-qiskit to be installed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport qiskit_aer.noise as noise\n\nerror_1 = noise.depolarizing_error(0.001, 1) # 1-qubit noise\nerror_2 = noise.depolarizing_error(0.01, 2) # 2-qubit noise\n\nnoise_model = noise.NoiseModel()\n\nnoise_model.add_all_qubit_quantum_error(error_1, ['rz', 'ry'])\nnoise_model.add_all_qubit_quantum_error(error_2, ['cx'])\n```\n\n----------------------------------------\n\nTITLE: Defining Initial Circuit for Adaptive VQE\nDESCRIPTION: Defines the initial quantum circuit for the adaptive VQE algorithm. It prepares a Hartree-Fock state and returns the expectation value of the Hamiltonian. Requires PennyLane and a device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nhf_state = qml.qchem.hf_state(n_electrons, qubits)\ndev = qml.device(\"default.qubit\", wires=qubits)\n@qml.qnode(dev)\ndef circuit():\n    qml.BasisState(hf_state, wires=range(qubits))\n    return qml.expval(H)\n```\n\n----------------------------------------\n\nTITLE: Statistics for Composite Mid-Circuit Measurements in PennyLane\nDESCRIPTION: This snippet demonstrates how to compute statistics of composite mid-circuit measurements in PennyLane. It defines a quantum circuit with mid-circuit measurements, composes the results using arithmetic operations, and calculates the expected value of the composite measurement. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit(phi, theta):\n    qml.RX(phi, wires=0)\n    m0 = qml.measure(wires=0)\n    qml.RY(theta, wires=1)\n    m1 = qml.measure(wires=1)\n    return qml.expval(~m0 + m1)\n\nprint(circuit(1.23, 4.56))\n```\n\n----------------------------------------\n\nTITLE: PauliSentence Operations in PennyLane\nDESCRIPTION: Illustrates how to perform operations like addition, multiplication, and matrix extraction using `qml.pauli.PauliSentence`, representing linear combinations of Pauli words in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> ps1 = qml.pauli.PauliSentence({pw1: 1.2, pw2: 0.5j})\n>>> ps2 = qml.pauli.PauliSentence({pw1: -1.2})\n>>> ps1\n1.2 * X(0) @ Z(1)\n+ 0.5j * Y(0) @ Z(1)\n>>> ps1 + ps2\n0.0 * X(0) @ Z(1)\n+ 0.5j * Y(0) @ Z(1)\n>>> ps1 * ps2\n-1.44 * I\n+ (-0.6+0j) * Z(0)\n>>> (ps1 + ps2).to_mat(wire_order=[0,1])\narray([[ 0. +0.j,  0. +0.j,  0.5+0.j,  0. +0.j],\n       [ 0. +0.j,  0. +0.j,  0. +0.j, -0.5+0.j],\n       [-0.5+0.j,  0. +0.j,  0. +0.j,  0. +0.j],\n       [ 0. +0.j,  0.5+0.j,  0. +0.j,  0. +0.j]])\n```\n\n----------------------------------------\n\nTITLE: Custom Tape Transform in PennyLane\nDESCRIPTION: This snippet demonstrates a custom tape transform that shifts all `qml.RX` gates to the end of the circuit.  It uses the `@qml.transform` decorator to define the transformation logic. This example shows how to create and apply custom transforms with program capture enabled, ensuring compatibility with PennyLane's execution model.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nqml.capture.enable()\n\n@qml.transform\ndef shift_rx_to_end(tape):\n    \"\"\"Transform that moves all RX gates to the end of the operations list.\"\"\"\n    new_ops, rxs = [], []\n\n    for op in tape.operations:\n        if isinstance(op, qml.RX):\n            rxs.append(op)\n        else:\n              new_ops.append(op)\n\n    operations = new_ops + rxs\n    new_tape = tape.copy(operations=operations)\n    return [new_tape], lambda res: res[0]\n\n@shift_rx_to_end\n@qml.qnode(qml.device(\"default.qubit\", wires=1))\ndef circuit1():\n    qml.RX(0.1, wires=0)\n    qml.H(wires=0)\n    return qml.state()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=1))\ndef circuit2():\n    qml.H(wires=0)\n    qml.RX(0.1, wires=0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit with Counts and Observables\nDESCRIPTION: This code defines a quantum circuit that returns the counts measurement with observables. It initializes a default qubit device with 2 wires and 1000 shots, then defines a quantum node that applies a Hadamard gate and a CNOT gate, returning the counts measurement for PauliZ(0) and PauliZ(1).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.counts(qml.PauliZ(0)), qml.counts(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Updating list elements with JAX .at and .set in for loop\nDESCRIPTION: This code shows how to update the elements of a JAX array within a for loop using the `.at` and `.set` methods.  It initializes an empty JAX array and then assigns the loop index to each element, as standard Python assignment will not work correctly.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    my_list = jnp.empty(2, dtype=int)\n    for i in range(2):\n        my_list = my_list.at[i].set(i)  # not my_list[i] = i\n    return my_list\n```\n\n----------------------------------------\n\nTITLE: Writing and Reading Custom Dataset\nDESCRIPTION: This code snippet demonstrates how to write a custom dataset to a file using `dataset.write()` and then read it back using `dataset.read()`. It verifies that the data is loaded correctly.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndataset.write(\"./path/to/dataset.h5\")\nread_dataset = qml.data.Dataset()\nread_dataset.read(\"./path/to/dataset.h5\")\nread_dataset.data_name\nread_dataset.hamiltonian\nread_dataset.energies\n```\n\n----------------------------------------\n\nTITLE: Creating Operators from a Generator via Evolution\nDESCRIPTION: This code demonstrates creating operators defined from a generator via `qml.ops.op_math.Evolution`. `qml.ops.op_math.Evolution` defines the exponential of an operator $\\hat{O}$ of the form $e^{ix\\hat{O}}$, with a single trainable parameter, $x$. Limiting to a single trainable parameter allows the use of `qml.gradients.param_shift` to find the gradient with respect to the parameter $x$.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n  \n@qml.qnode(dev, diff_method=qml.gradients.param_shift)\ndef circuit(phi):\n    qml.ops.op_math.Evolution(qml.PauliX(0), -.5 * phi)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Matplotlib Plot with PennyLane Style\nDESCRIPTION: This code demonstrates how to create plots with a PennyLane style using Matplotlib's plt.style.use function.  It uses 'pennylane.drawer.plot' to style matplotlib plots. Dependencies: Matplotlib, NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\nplt.style.use(\"pennylane.drawer.plot\")\nfor i in range(3):\n    plt.plot(np.random.rand(10))\n```\n\n----------------------------------------\n\nTITLE: Backpropagation with PyTorch on default.qubit\nDESCRIPTION: This example demonstrates the usage of native backpropagation with PyTorch on the `default.qubit` device in PennyLane. A quantum circuit is defined using `qml.Rot` and the expectation value of `qml.PauliZ(0)` is returned. Gradients are then computed using `res.backward()`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nx = torch.tensor(0.43316321, dtype=torch.float64, requires_grad=True)\ny = torch.tensor(0.2162158, dtype=torch.float64, requires_grad=True)\nz = torch.tensor(0.75110998, dtype=torch.float64, requires_grad=True)\n\np = torch.tensor([x, y, z], requires_grad=True)\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev, interface=\"torch\", diff_method=\"backprop\")\ndef circuit(x):\n    qml.Rot(x[0], x[1], x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nres = circuit(p)\nres.backward()\n```\n\n----------------------------------------\n\nTITLE: Executing Cached QNode and Verifying Execution Count\nDESCRIPTION: This code snippet demonstrates how to execute a QNode with caching enabled and verifies the number of device executions. The first execution will trigger a computation on the device, while subsequent executions with the same parameters will retrieve the cached result, avoiding additional device executions. It assumes that the 'expval_circuit' function and related variables from the previous snippet exist.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> expval_circuit(params)\ntensor(0.20598436, requires_grad=True)\n>>> dev.num_executions\n1\n>>> expval_circuit(params)\ntensor(0.20598436, requires_grad=True)\n>>> dev.num_executions\n1\n```\n\n----------------------------------------\n\nTITLE: Custom QNode Transformation with qml.qfunc_transform\nDESCRIPTION: This snippet demonstrates how to create a custom QNode transformation using the `@qml.qfunc_transform` decorator. The example defines a transform that scales the parameters of `RX` and `RY` gates based on input parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.qfunc_transform\ndef my_transform(tape, a, b):\n    for op in tape.operations + tape.measurements:\n        if op.name == \"RX\":\n            x = op.parameters[0]\n            qml.RX(qml.math.sin(a) * qml.math.sqrt(x), wires=op.wires)\n        elif op.name == \"RY\":\n            y = op.parameters[0]\n            qml.RX(qml.math.cos(a * b) * y, wires=op.wires)\n        else:\n            op.queue()\n```\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\ndef ansatz(x):\n    qml.Hadamard(wires=0)\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n\n@qml.qnode(dev)\ndef circuit(params, transform_weights):\n    qml.RX(0.1, wires=0)\n\n    # apply the transform to the ansatz\n    my_transform(*transform_weights)(ansatz)(params)\n\n    return qml.expval(qml.PauliZ(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> x = np.array([0.5, 0.3], requires_grad=True)\n>>> transform_weights = np.array([0.1, 0.6], requires_grad=True)\n>>> print(qml.draw(circuit)(x, transform_weights))\n 0: ──RX(0.1)────H──RX(0.0706)──╭C──┤\n 1: ──RX(0.299)─────────────────╰X──┤ ⟨Z⟩\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit(x, transform_weights)\ntensor(0.00672829, requires_grad=True)\n>>> qml.grad(circuit)(x, transform_weights)\n(array([ 0.00671711, -0.00207359]), array([6.69695008e-02, 3.73694364e-06]))\n```\n\n----------------------------------------\n\nTITLE: In-place JAX Array Updates with Operations\nDESCRIPTION: This example demonstrates how to update array values with operations in JAX using the `at` method combined with an operation like `multiply`. It copies an existing array, iterates through it, and multiplies each element by 2.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_38\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    first_dim = x.shape[0]\n    result = jnp.copy(x)\n\n    for i in range(first_dim):\n        result = result.at[i].multiply(2)\n\n    return result\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Device Class in PennyLane\nDESCRIPTION: This snippet demonstrates how to create a custom PennyLane device by subclassing the LegacyDevice class. It defines essential class attributes like name, short_name, pennylane_requires, version, and author, which are mandatory for PennyLane to identify and use the device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.devices import LegacyDevice\n\nclass MyDevice(LegacyDevice):\n    \"\"\"MyDevice docstring\"\"\"\n    name = 'My custom device'\n    short_name = 'example.mydevice'\n    pennylane_requires = '0.1.0'\n    version = '0.0.1'\n    author = 'Ada Lovelace'\n```\n\n----------------------------------------\n\nTITLE: Example Noise Model Setup - Python\nDESCRIPTION: This complete example demonstrates how to set up an artificial noise model in PennyLane. It defines Boolean functions `c0`, `c1`, `c2`, and `c3` based on gate types and parameters.  Noisy operations `n0`, `n1`, `n2`, and `n3` are also defined, and a `NoiseModel` is constructed by mapping the conditions to the noisy operations, also showcasing one-at-a-time construction.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_noise.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Set up the conditions\nc0 = qml.noise.op_eq(qml.PauliX) | qml.noise.op_eq(qml.PauliY)\nc1 = qml.noise.op_eq(qml.Hadamard) & qml.noise.wires_in([0, 1])\nc2 = qml.noise.op_eq(qml.RX)\n\n@qml.BooleanFn\ndef c3(op, **metadata):\n    return isinstance(op, qml.RY) and op.parameters[0] >= 0.5\n\n# Set up noisy ops\nn0 = qml.noise.partial_wires(qml.AmplitudeDamping, 0.4)\n\ndef n1(op, **metadata):\n    ThermalRelaxationError(0.4, metadata[\"t1\"], 0.2, 0.6, op.wires)\n\ndef n2(op, **metadata):\n    qml.RX(op.parameters[0] * 0.05, op.wires)\n\nn3 = qml.noise.partial_wires(qml.PhaseDamping, 0.9)\n\n# Set up noise model\nnoise_model = qml.NoiseModel({c0: n0, c1: n1, c2: n2}, t1=0.04)\nnoise_model += {c3: n3}  # One-at-a-time construction\n```\n\n----------------------------------------\n\nTITLE: JIT Compilation of PennyLane Operators\nDESCRIPTION: This snippet showcases the ability to jit functions of Operator using JAX. Any class inheriting from Operator is now automatically registered as a pytree with JAX. Dependencies: PennyLane, JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> op = qml.adjoint(qml.RX(1.0, wires=0))\n>>> jax.jit(qml.matrix)(op)\nArray([[0.87758255-0.j        , 0.        +0.47942555j],\n       [0.        +0.47942555j, 0.87758255-0.j        ]],      dtype=complex64, weak_type=True)\n```\n\n----------------------------------------\n\nTITLE: JIT-Compiling with MeasurementProcess and QuantumScript\nDESCRIPTION: This code demonstrates that MeasurementProcess and QuantumScript objects are now registered as JAX PyTrees, making it possible to JIT-compile functions with arguments that are a MeasurementProcess or a QuantumScript. The example shows how to create a QuantumTape, define execution keyword arguments, and JIT-compile the `qml.execute` function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\ntape0 = qml.tape.QuantumTape([qml.RX(1.0, 0), qml.RY(0.5, 0)], [qml.expval(qml.PauliZ(0))])\ndev = qml.device('lightning.qubit', wires=5)\n\nexecute_kwargs = {\"device\": dev, \"gradient_fn\": qml.gradients.param_shift, \"interface\":\"jax\"}\n\njitted_execute = jax.jit(qml.execute, static_argnames=execute_kwargs.keys())\njitted_execute((tape0, ), **execute_kwargs)\n```\n\n----------------------------------------\n\nTITLE: Adjoint Transform Example\nDESCRIPTION: This snippet showcases the `qml.adjoint` transform applied to both an instantiated operator (PauliX) and a quantum function (RX). The adjoint transform returns the adjoint (conjugate transpose) of the given operator or quantum function. It highlights the versatility of the `adjoint` transform in handling different types of quantum operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.adjoint(qml.PauliX(0))\nAdjoint(PauliX)(wires=[0])\n>>> qml.adjoint(qml.RX)(1.23, wires=0)\nAdjoint(RX)(1.23, wires=[0])\n```\n\n----------------------------------------\n\nTITLE: Creating a Fermi Sentence by Linearly Combining Fermi Words in PennyLane\nDESCRIPTION: Demonstrates how to create a Fermi sentence by linearly combining Fermi words using the `+` and `-` operators along with scalar coefficients. This allows for the construction of more complex fermionic operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> sentence = 1.2 * word - 0.345 * qml.FermiC(3) * qml.FermiA(3)\n>>> sentence\n1.2 * a⁺(0) a(0) a⁺(3) a(3)\n- 0.345 * a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: Convert Qiskit SparsePauliOp to PennyLane Operator\nDESCRIPTION: This code shows how to convert a Qiskit `SparsePauliOp` into a PennyLane `Operator` using the `qml.from_qiskit_op` function. The PennyLane operator can then be used within PennyLane's quantum machine learning workflows. PennyLane-Qiskit plugin is required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\npl_op = qml.from_qiskit_op(qk_op)\n```\n\n----------------------------------------\n\nTITLE: Accessing Operator Matrix in PennyLane\nDESCRIPTION: Demonstrates how to compute the canonical matrix representation of an operator in PennyLane using the `compute_matrix` method. This method is intended to replace direct access to the `_matrix` attribute. The example shows how to compute the matrix for the RX gate with a parameter value of 0.5.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.RX.compute_matrix(0.5)\n[[0.96891242+0.j         0.        -0.24740396j]\n [0.        -0.24740396j 0.96891242+0.j        ]]\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom JAX Higher Order Primitive (HOP)\nDESCRIPTION: This code defines a custom JAX primitive named `hop` that supports dynamically shaped inputs. It includes an implementation (`def_impl`) that evaluates a jaxpr, and an abstract evaluation rule (`def_abstract_eval`) that returns the abstract values of the jaxpr outputs. It provides a `bind_prim` function to bind the primitive with a given function and arguments after determining their abstracted axes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nprim = jax.core.Primitive(\"hop\")\nprim.multiple_results = True\n\n@prim.def_impl\ndef _(*args, jaxpr, n_consts):\n    return jax.core.eval_jaxpr(jaxpr, args[:n_consts], *args[n_consts:])\n\n@prim.def_abstract_eval\ndef _(*args, jaxpr, n_consts):\n    return [v.aval for v in jaxpr.outvars]\n\ndef bind_prim(f, *args):\n    abstracted_axes, abstract_shapes  = determine_abstracted_axes(args)\n    jaxpr = jax.make_jaxpr(f, abstracted_axes=abstracted_axes)(*args)\n    return prim.bind(*jaxpr.consts, *abstract_shapes, *args, jaxpr=jaxpr.jaxpr, n_consts=len(jaxpr.consts))\n```\n\n----------------------------------------\n\nTITLE: Decomposing QubitUnitary gate with RX, RY, GlobalPhase\nDESCRIPTION: This code showcases the graph-based decomposition system in PennyLane. It decomposes a `QubitUnitary` gate into a sequence of RX, RY, and GlobalPhase gates. It relies on NumPy and PennyLane, and uses the `default.qubit` device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\nfrom functools import partial\nimport numpy as np\nimport pennylane as qml\n\nqml.decomposition.enable_graph()\n\nU = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n\n@partial(qml.transforms.decompose, gate_set={\"RX\", \"RY\", \"GlobalPhase\"})\n@qml.qnode(qml.device(\"default.qubit\"))\ndef circuit():\n    qml.QubitUnitary(np.array([[1, 1], [1, -1]]) / np.sqrt(2), wires=[0])\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: ShotAdaptiveOptimizer Example in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.ShotAdaptiveOptimizer` in PennyLane. It sets up a quantum circuit with a Hamiltonian and optimizes its parameters using the adaptive optimizer, tracking the number of shots used per iteration. The optimizer dynamically adjusts the shot rate based on the variance of the parameter-shift gradient.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> coeffs = [2, 4, -1, 5, 2]\n>>> obs = [\n...   qml.PauliX(1),\n...   qml.PauliZ(1),\n...   qml.PauliX(0) @ qml.PauliX(1),\n...   qml.PauliY(0) @ qml.PauliY(1),\n...   qml.PauliZ(0) @ qml.PauliZ(1)\n... ]\n>>> H = qml.Hamiltonian(coeffs, obs)\n>>> dev = qml.device(\"default.qubit\", wires=2, shots=100)\n>>> cost = qml.ExpvalCost(qml.templates.StronglyEntanglingLayers, H, dev)\n>>> params = qml.init.strong_ent_layers_uniform(n_layers=2, n_wires=2)\n>>> opt = qml.ShotAdaptiveOptimizer(min_shots=10)\n>>> for i in range(5):\n...    params = opt.step(cost, params)\n...    print(f\"Step {i}: cost = {cost(params):.2f}, shots_used = {opt.total_shots_used}\")\n```\n\n----------------------------------------\n\nTITLE: Von Neumann Entropy with qml.math\nDESCRIPTION: This example demonstrates the calculation of Von Neumann entropy using functions from the `qml.math` module. A statevector is created as a PyTorch tensor, and its entropy is computed. The gradient is then calculated with respect to the input tensor.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = torch.tensor([1.0, 0.0, 0.0, 1.0], requires_grad=True)\n>>> en = qml.math.vn_entropy(x / np.sqrt(2.), indices=[0])\n>>> en\ntensor(0.6931, dtype=torch.float64, grad_fn=<DivBackward0>)\n>>> en.backward()\n>>> x.grad\ntensor([-0.3069,  0.0000,  0.0000, -0.3069])\n```\n\n----------------------------------------\n\nTITLE: Simplifying Arithmetic Operations with qml.simplify\nDESCRIPTION: This code demonstrates simplifying arithmetic operations using `qml.simplify`. It creates an operator `op` that applies the adjoint twice to an `RX` gate, and then simplifies it back to the original `RX` gate using `qml.simplify`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_22\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.adjoint(qml.adjoint(qml.RX(x, wires=0))) \n>>> op \nAdjoint(Adjoint(RX))(tensor([1.04719755, 1.57079633], requires_grad=True), wires=[0]) \n>>> qml.simplify(op) \nRX(tensor([1.04719755, 1.57079633], requires_grad=True), wires=[0]) \n```\n\n----------------------------------------\n\nTITLE: Scalar Product of Operators with qml.s_prod in PennyLane\nDESCRIPTION: This code demonstrates the use of the `qml.s_prod` function to take the scalar product of a coefficient and an operator in PennyLane. It multiplies a PauliX operator by a scalar value and then accesses the matrix representation and terms of the resulting scalar-product operator. This maintains differentiability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> sprod_op = qml.s_prod(2.0, qml.PauliX(0))\n>>> sprod_op\n2.0*(PauliX(wires=[0]))\n>>> sprod_op.matrix()\narray([[ 0., 2.],\n       [ 2., 0.]])\n>>> sprod_op.terms()\n([2.0], [PauliX(wires=[0])])\n```\n\n----------------------------------------\n\nTITLE: Execute Integer Comparator Quantum Circuit\nDESCRIPTION: This example shows how to execute the quantum circuit defined using `qml.IntegerComparator`. The result is a numpy array representing the quantum state after the circuit has run.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n[-0.5+0.j  0.5+0.j -0.5+0.j  0.5+0.j]\n```\n\n----------------------------------------\n\nTITLE: Creating Fermi Word by Multiplying Fermi Operators in PennyLane\nDESCRIPTION: Shows how to create a Fermi word by multiplying several Fermi operators together using the `*` operator. The resulting `word` variable represents a sequence of creation and annihilation operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> word = qml.FermiC(0) * qml.FermiA(0) * qml.FermiC(3) * qml.FermiA(3)\n>>> word \na⁺(0) a(0) a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit with Sparse Matrices\nDESCRIPTION: This code snippet demonstrates the use of sparse matrices in a PennyLane quantum circuit. It initializes sparse matrices using `scipy.sparse.csr_array` and applies them using `qml.StatePrep`, `qml.QubitUnitary`, and `qml.ctrl` operations. This example showcases the support for end-to-end sparse execution in PennyLane, improving performance for large, sparse quantum systems.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport scipy\nimport numpy as np\n\nsparse_state = scipy.sparse.csr_array([0, 1, 0, 0])\nmat = np.kron(np.identity(2**12), qml.X.compute_matrix())\nsparse_mat = scipy.sparse.csr_array(mat)\nsparse_x = scipy.sparse.csr_array(qml.X.compute_matrix())\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    qml.StatePrep(sparse_state, wires=range(2))\n\n    for i in range(10):\n        qml.H(i)\n        qml.CNOT(wires=[i, i + 1])\n\n    qml.QubitUnitary(sparse_mat, wires=range(13))\n    qml.ctrl(qml.QubitUnitary(sparse_x, wires=0), control=1)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Defining Readout Noise Model (Python)\nDESCRIPTION: This snippet demonstrates how to define a readout noise model using `qml.noise.meas_eq` and `qml.noise.partial_wires`. It creates a `qml.PhaseFlip` noise channel applied to `qml.expval` measurements, then incorporates this into a `qml.NoiseModel` which also contains gate noise.  It showcases how to include readout errors in simulations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nc0 = qml.noise.meas_eq(qml.expval)\nn0 = qml.noise.partial_wires(qml.PhaseFlip, 0.2)\n\n# gate-based noise\nc1 = qml.noise.wires_in([0, 2]) \nn1 = qml.noise.partial_wires(qml.RY, -0.42)\n\nnoise_model = qml.NoiseModel({c1: n1}, meas_map={c0: n0})\n```\n\n----------------------------------------\n\nTITLE: Gradients with Backprop and Adjoint in PennyLane\nDESCRIPTION: This code demonstrates how to calculate gradients using the backpropagation and adjoint differentiation methods with program capture enabled in PennyLane. It utilizes JAX for automatic differentiation and highlights the compatibility of these methods with ``default.qubit`` and ``lightning.qubit`` devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.Z(0))\n\nbp_qn = circuit.update(diff_method=\"backprop\")\nadj_qn = circuit.update(diff_method=\"adjoint\")\n```\n\n----------------------------------------\n\nTITLE: Using `qml.for_loop` within Quantum Circuits\nDESCRIPTION: This code demonstrates the use of `qml.for_loop` within a PennyLane quantum circuit to repeat operations. The circuit initializes a state using Hadamard gates in a loop and then applies RX and CRY gates in nested loops. The code depends on Jax (`jnp`) and Lightning qubit simulator (`lightning.qubit`).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"lightning.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit(x, n):\n\n    @qml.for_loop(0, n, 1)\n    def init_state(i):\n        qml.Hadamard(wires=i)\n\n    init_state()\n\n    @qml.for_loop(0, n, 1)\n    def apply_operations(i, x):\n        qml.RX(x, wires=i)\n\n        @qml.for_loop(i + 1, n, 1)\n        def inner(j):\n            qml.CRY(x**2, [i, j])\n\n        inner()\n        return jnp.sin(x)\n\n    apply_operations(x)\n    return qml.probs()\n```\n\n----------------------------------------\n\nTITLE: Differentiable Molecular Hamiltonian Construction in PennyLane\nDESCRIPTION: This code demonstrates how to construct a molecular Hamiltonian for the hydrogen molecule using PennyLane's differentiable Hartree-Fock solver. It initializes the molecular geometry and basis set parameters (alpha and coeff) as differentiable variables using `requires_grad=True` and then constructs the Hamiltonian using `qml.qchem.molecular_hamiltonian`. The initial values of the parameters are passed to the function via the `args` keyword argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nsymbols = [\"H\", \"H\"]\n# This initial geometry is suboptimal and will be optimized by the algorithm\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 2.0]], requires_grad=True)\n\n# The exponents and contraction coefficients of the Gaussian basis functions\nalpha = np.array([[3.42525091, 0.62391373, 0.1688554],\n                      [3.42525091, 0.62391373, 0.1688554]], requires_grad = True)\ncoeff = np.array([[0.15432897, 0.53532814, 0.44463454],\n                      [0.15432897, 0.53532814, 0.44463454]], requires_grad = True)\n```\n\n----------------------------------------\n\nTITLE: SingleExcitation Operation in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.SingleExcitation` operation in PennyLane, which is useful for quantum chemistry applications. It creates a quantum circuit with the `SingleExcitation` gate and performs an SO(2) rotation in the subspace spanned by the states :math:`|01\\rangle` and :math:`|10\\rangle`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(phi):\n    qml.PauliX(wires=0)\n    qml.SingleExcitation(phi, wires=[0, 1])\n```\n\n----------------------------------------\n\nTITLE: Optimization using PyTorch Optimizers\nDESCRIPTION: This snippet demonstrates how to optimize a hybrid quantum-classical model using PyTorch optimizers with a PyTorch-interfacing QNode. The example uses the `torch.optim.Adam` optimizer to minimize a cost function defined as the squared difference between the QNode's output and a target value.  It's crucial to use PyTorch optimizers for Torch-interfacing QNodes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport torch\nimport pennylane as qml\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='torch')\ndef circuit4(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RZ(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\ndef cost(phi, theta):\n    return torch.abs(circuit4(phi, theta) - 0.5)**2\n\nphi = torch.tensor([0.011, 0.012], requires_grad=True)\ntheta = torch.tensor(0.05, requires_grad=True)\n\nopt = torch.optim.Adam([phi, theta], lr = 0.1)\n\nsteps = 200\n\ndef closure():\n    opt.zero_grad()\n    loss = cost(phi, theta)\n    loss.backward()\n    return loss\n\nfor i in range(steps):\n    opt.step(closure)\n```\n\n----------------------------------------\n\nTITLE: Hessian Calculation using Parameter Shift\nDESCRIPTION: Illustrates how to calculate the Hessian of a quantum circuit using the second-order parameter shift formula in PennyLane. The Hessian calculation is demonstrated using default.qubit device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 5\nweights = [2.73943676, 0.16289932, 3.4536312, 2.73521126, 2.6412488]\n\ndev = qml.device(\"default.qubit\", wires=n_wires)\n\nwith qml.tape.QubitParamShiftTape() as tape:\n    for i in range(n_wires):\n        qml.RX(weights[i], wires=i)\n\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[2, 1])\n    qml.CNOT(wires=[3, 1])\n    qml.CNOT(wires=[4, 3])\n\n    qml.expval(qml.PauliZ(1))\n\nprint(tape.hessian(dev))\n```\n\n----------------------------------------\n\nTITLE: Wires Symmetric Difference using Python\nDESCRIPTION: Demonstrates how to perform symmetric difference operations on `Wires` instances using the `symmetric_difference()` method or the `^` operator. It showcases how to find the wire labels that are unique to each Wires object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> wires1 = Wires([1, 2, 3])\n>>> wires2 = Wires([2, 3, 4])\n>>> wires1.symmetric_difference(wires2) # or wires1 ^ wires2\nWires([1, 4])\n```\n\n----------------------------------------\n\nTITLE: Differentiating Pulse Programs with PennyLane\nDESCRIPTION: This example demonstrates how to compute the Jacobian of a unitary evolved via `qml.evolve`, using the `jax.jacobian` function. It utilizes a time-dependent Hamiltonian defined using `jnp.polyval` and `qml.PauliZ`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef U(params):\n    H = jnp.polyval * qml.PauliZ(0) # time dependent Hamiltonian\n    Um = qml.evolve(H, dense=False)(params, t=10.)\n    return qml.matrix(Um)\nparams = jnp.array([[0.5]], dtype=complex)\njac = jax.jacobian(U, holomorphic=True)(params)\n```\n\n----------------------------------------\n\nTITLE: Drawing QNodes with qml.draw\nDESCRIPTION: Shows how to use the new qml.draw function to draw QNodes without execution by providing example inputs. The drawn circuit structure may depend on the input arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(a, w):\n    qml.Hadamard(0)\n    qml.CRX(a, wires=[0, 1])\n    qml.Rot(*w, wires=[1])\n    qml.CRX(-a, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: QROM State Preparation with PennyLane\nDESCRIPTION: This code demonstrates how to use the new QROM state preparation technique in PennyLane. It prepares a given state vector on specified wires using the QROMStatePreparation template, utilizing work wires and precision wires. It requires numpy and pennylane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nstate_vector = np.array([0.5, -0.5, 0.5, 0.5])\n\ndev = qml.device(\"default.qubit\")\nwires = qml.registers({\"work_wires\": 1, \"prec_wires\": 3, \"state_wires\": 2})\n\n@qml.qnode(dev)\ndef circuit():\n    qml.QROMStatePreparation(\n        state_vector, wires[\"state_wires\"], wires[\"prec_wires\"], wires[\"work_wires\"]\n    )\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Import PennyLane and PyTorch\nDESCRIPTION: This snippet shows the necessary import statements to use PennyLane with the PyTorch interface.  It imports both the `pennylane` and `torch` libraries, which are essential for creating and manipulating quantum circuits and tensors within the PyTorch framework.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport torch\n```\n\n----------------------------------------\n\nTITLE: QNode Returning Expectation Values of Commuting Pauli Words in Python\nDESCRIPTION: This code demonstrates a QNode returning the expectation values of qubit-wise commuting Pauli words (XX and XI). The `qml.enable_tape()` function enables tape mode, allowing for automatic optimization of measurements. The QNode `f(x)` applies Hadamard gates, a controlled rotation, and an RZ rotation, then returns the expectation values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_tape()\n\n@qml.qnode(dev)\ndef f(x):\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    qml.CRot(0.1, 0.2, 0.3, wires=[1, 0])\n    qml.RZ(x, wires=1)\n    return qml.expval(qml.PauliX(0) @ qml.PauliX(1)), qml.expval(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: PauliWord operations in PennyLane\nDESCRIPTION: This snippet demonstrates the multiplication of two PauliWord objects and the conversion of a PauliWord to a matrix representation. It illustrates the basic arithmetic and matrix representation capabilities of PauliWord objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.pauli import PauliWord\n>>> pw1 = PauliWord({0:\"X\", 1:\"Z\"})\n>>> pw2 = PauliWord({0:\"Y\", 1:\"Z\"})\n>>> pw1 @ pw2\n1j * Z(0)\n>>> pw1.to_mat(wire_order=[0, 1])\narray([[ 0,  0,  1,  0],\n       [ 0,  0,  0, -1],\n       [ 1,  0,  0,  0],\n       [ 0, -1,  0,  0]])\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Mixed State Circuit with JAX\nDESCRIPTION: This code demonstrates calculating the gradient of a quantum circuit running on the `default.mixed` device with the JAX interface. It initializes an array of angles, then calculates the gradient of the circuit's output with respect to these angles using `qml.grad`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> angles = np.array([np.pi/6, np.pi/5], requires_grad=True)\n>>> qml.grad(circuit)(angles)\narray([-0.8660254 , -0.25881905])\n```\n\n----------------------------------------\n\nTITLE: Wires Intersection using Python\nDESCRIPTION: Demonstrates how to perform intersection operations on `Wires` instances using the `intersection()` method or the `&` operator. It showcases how to find the common wire labels between two Wires objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> wires1 = Wires([1, 2, 3])\n>>> wires2 = Wires([2, 3, 4])\n>>> wires1.intersection(wires2) # or wires1 & wires2\nWires([2, 3])\n```\n\n----------------------------------------\n\nTITLE: QubitCarry and QubitSum Operations Example in Python\nDESCRIPTION: This snippet showcases the usage of the new `QubitCarry` and `QubitSum` operations for basic arithmetic. It requires PennyLane and performs the addition of two 1-bit numbers, resulting in a 2-bit output. The snippet demonstrates setting up a quantum circuit with these operations and extracting the output bitstring.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires = 4)\na = 0\nb = 1\n\n@qml.qnode(dev)\ndef circuit():\n    qml.BasisState(np.array([a, b]), wires=[1, 2])\n    qml.QubitCarry(wires=[0, 1, 2, 3])\n    qml.CNOT(wires=[1, 2])\n    qml.QubitSum(wires=[0, 1, 2])\n    return qml.probs(wires=[3, 2])\n\nprobs = circuit()\nbitstrings = tuple(itertools.product([0, 1], repeat = 2))\nindx = np.argwhere(probs == 1).flatten()[0]\noutput = bitstrings[indx]\n```\n\n----------------------------------------\n\nTITLE: Device Wires with Program Capture in PennyLane\nDESCRIPTION: This snippet demonstrates how to initialize a PennyLane device with program capture enabled. It showcases the requirement of specifying the number of wires during device instantiation, which is different from the default behavior when program capture is disabled. It also illustrates how mid-circuit measurements (MCMs) affect the number of wires needed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nqml.capture.enable()\n\n@qml.qnode(qml.device('default.qubit'))\ndef circuit():\n    qml.Hadamard(0)\n    return qml.state()\n\ncircuit = circuit.update(device = qml.device('default.qubit', wires=1))\n\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    m0 = qml.measure(0)\n    return qml.state()\n\ncircuit = circuit.update(device = qml.device('default.qubit', wires=2))\n```\n\n----------------------------------------\n\nTITLE: PennyLane Circuit Drawing with Device-Level Decomposition (Python)\nDESCRIPTION: This code showcases how to use PennyLane's drawing functionality to visualize circuit decomposition at the device level. The drawing shows the operations that are actually executed on the device, including any diagonalizing gates applied for measurements. This example requires the reference.qubit device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('reference.qubit', wires=2))\ndef circuit(x):\n    qml.IsingXX(x, wires=(0,1))\n    qml.CH((0,1))\n    return qml.expval(qml.X(0))\nprint(qml.draw(circuit, level=\"device\")(0.5))\n```\n\n----------------------------------------\n\nTITLE: Parameter Broadcasting with default.qubit in PennyLane\nDESCRIPTION: This code demonstrates the use of native parameter broadcasting in PennyLane's `default.qubit` device. It defines a quantum circuit that applies an RX rotation with the input parameter `x` and returns the expectation value of PauliZ. The `circuit` function is then called with a NumPy array of parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Compiling with Custom Transforms using qml.compile in PennyLane\nDESCRIPTION: This example demonstrates how to use the `@qml.compile` decorator with a custom pipeline of quantum function transforms. It defines a pipeline consisting of `commute_controlled` and `cancel_inverses` transforms, and uses `functools.partial` to apply these transforms using `@qml.compile`. It showcases the flexibility of the `qml.compile` transform in allowing users to define their own circuit optimization strategies.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.transforms import commute_controlled, cancel_inverses\nfrom functools import partial\n\npipeline = [commute_controlled, cancel_inverses]\n\n@partial(qml.compile, pipeline=pipeline)\n@qml.qnode(dev)\ndef qfunc(x, y, z):\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    qml.Hadamard(wires=2)\n    qml.RZ(z, wires=2)\n    qml.CNOT(wires=[2, 1])\n    qml.RX(z, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RZ(-z, wires=2)\n    qml.RX(y, wires=2)\n    qml.Y(wires=2)\n    qml.CZ(wires=[1, 2])\n    return qml.expval(qml.Z(wires=0))\n\n>>> print(qml.draw(qfunc)(0.2, 0.3, 0.4))\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Compute commutator between operators\nDESCRIPTION: This snippet demonstrates the usage of the new `qml.commutator` function to compute the commutator between two PennyLane operators. It allows for determining the commutation relationship between different quantum operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nqml.commutator(X(0), Y(0))\n```\n\n----------------------------------------\n\nTITLE: Adjoint Operator Matrix and Eigenvalues\nDESCRIPTION: This example demonstrates how to obtain the matrix representation and eigenvalues of an adjoint operator created using `qml.adjoint`. It shows that the adjoint operator behaves like any other `Operator` object in PennyLane, allowing users to perform standard operations such as matrix calculation and eigenvalue determination.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.adjoint(qml.S(0))\n>>> qml.matrix(op)\narray([[1.-0.j, 0.-0.j],\n       [0.-0.j, 0.-1.j]])\n>>> qml.eigvals(op)\narray([1.-0.j, 0.-1.j])\n```\n\n----------------------------------------\n\nTITLE: Defining Template Shape and Using BasicEntanglerLayers\nDESCRIPTION: This snippet illustrates how to determine the shape of trainable parameters for a PennyLane template and then use the `BasicEntanglerLayers` template. It utilizes the `qml.templates.BasicEntanglerLayers.shape` method to obtain the expected shape of the weight tensor and then creates a random tensor of that shape to initialize the template.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nshape = qml.templates.BasicEntanglerLayers.shape(n_layers=2, n_wires=4)\nweights = np.random.random(shape)\nqml.templates.BasicEntanglerLayers(weights, wires=range(4))\n```\n\n----------------------------------------\n\nTITLE: Simulate TTN Circuit with Default Tensor in PennyLane\nDESCRIPTION: Demonstrates how to simulate a quantum circuit with a tree tensor network architecture using the `default.tensor` device with the `tn` method in PennyLane. It initializes a device with the specified method, defines a block function, creates a TTN template, and runs a quantum node using the specified device and template weights.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nn_wires = 16\ndev = qml.device(\"default.tensor\", method=\"tn\")\n\ndef block(weights, wires):\n    qml.CNOT(wires=[wires[0], wires[1]])\n    qml.RY(weights[0], wires=wires[0])\n    qml.RY(weights[1], wires=wires[1])\n\nn_block_wires = 2\nn_params_block = 2\nn_blocks = qml.TTN.get_n_blocks(range(n_wires), n_block_wires)\ntemplate_weights = [[0.1, -0.3]] * n_blocks\n\n@qml.qnode(dev)\ndef circuit(template_weights):\n    for i in range(n_wires):\n        qml.Hadamard(i)\n    qml.TTN(range(n_wires), n_block_wires, block, n_params_block, template_weights)\n    return qml.expval(qml.Z(n_wires - 1))\n```\n\n----------------------------------------\n\nTITLE: QNode Construction via Class Constructor (TensorFlow)\nDESCRIPTION: This snippet shows how to create a TensorFlow-compatible QNode using the `qml.QNode` class constructor and specifying the `interface='tf'` keyword. This method allows more explicit control over the interface.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev1 = qml.device('default.qubit', wires=2)\ndev2 = qml.device('default.mixed', wires=2)\n\ndef circuit1(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n\nqnode1 = qml.QNode(circuit1, dev1)\nqnode2 = qml.QNode(circuit1, dev2, interface='tf')\n```\n\n----------------------------------------\n\nTITLE: Estimating Resources with FirstQuantization in PennyLane\nDESCRIPTION: This code snippet demonstrates how to use the `FirstQuantization` class from the `qml.resource` module to estimate the number of non-Clifford gates and logical qubits needed for first quantization molecular simulations. It takes the number of plane waves (n), the number of electrons (eta), and the unit cell volume (omega) as inputs.  The output shows the estimated gate count and qubit count.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_0\n\nLANGUAGE: pycon\nCODE:\n```\n>>> n = 100000        # number of plane waves\n>>> eta = 156         # number of electrons\n>>> omega = 1145.166  # unit cell volume in atomic units\n>>> algo = FirstQuantization(n, eta, omega)\n>>> print(algo.gates, algo.qubits)\n1.10e+13, 4416\n```\n\n----------------------------------------\n\nTITLE: Using Custom Wire Labels in PennyLane Devices\nDESCRIPTION: Demonstrates the use of custom wire labels, such as strings or numbers, in PennyLane devices. The code shows how to define a device with custom wire labels and invoke quantum operations using these labels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=['anc1', 'anc2', 0, 1, 3])\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> @qml.qnode(dev)\n>>> def circuit():\n...    qml.Hadamard(wires='anc2')\n...    qml.CNOT(wires=['anc1', 3])\n...    ...\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=5)\n```\n\n----------------------------------------\n\nTITLE: Differentiable Arguments in NumPy\nDESCRIPTION: This snippet demonstrates how to control which arguments are differentiable by setting the `requires_grad` flag in PennyLane's NumPy arrays. It also highlights that keyword arguments are always considered non-trainable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=5)\n\n@qml.qnode(dev)\ndef circuit(data, weights):\n    qml.AmplitudeEmbedding(data, wires=[0, 1, 2], normalize=True)\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    qml.RZ(weights[2], wires=2)\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[0, 2])\n    return qml.expval(qml.PauliZ(0))\n\nrng = np.random.default_rng(seed=42)  # make the results reproducible\ndata = rng.random([2 ** 3], requires_grad=False)\nweights = np.array([0.1, 0.2, 0.3], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Creating a TorchLayer with a QNode in PennyLane\nDESCRIPTION: This code snippet showcases the creation of a `TorchLayer` in PennyLane, integrating a quantum node (QNode) with a PyTorch neural network. It defines a QNode with angle embedding and basic entangler layers, and then wraps it with a `TorchLayer` for use in a hybrid quantum-classical model. This is a prerequisite for the next snippet showing parameter broadcasting.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nn_qubits = 2\ndev = qml.device(\"default.qubit\", wires=n_qubits)\n\n@qml.qnode(dev)\ndef qnode(inputs, weights):\n    qml.AngleEmbedding(inputs, wires=range(n_qubits))\n    qml.BasicEntanglerLayers(weights, wires=range(n_qubits))\n    return [qml.expval(qml.PauliZ(wires=i)) for i in range(n_qubits)]\n\nn_layers = 6\nweight_shapes = {\"weights\": (n_layers, n_qubits)}\nqlayer = qml.qnn.TorchLayer(qnode, weight_shapes)\n```\n\n----------------------------------------\n\nTITLE: JAX gradient calculation\nDESCRIPTION: This demonstrates the JAX gradient calculation on the previously defined cost function.  The gradient is calculated with respect to the first argument (x) and evaluated at the given x and y values. The output is the gradient of the cost function with respect to x.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jax.grad(cost, argnums=[0])(x, y)\n(Array(-0.2050439, dtype=float32),)\n```\n\n----------------------------------------\n\nTITLE: Deferred Measurements with Postselection (Python)\nDESCRIPTION: This snippet demonstrates the `defer_measurements` transform with postselection and shows how it optimizes the quantum circuit by skipping operations that will never be active due to the postselected state. It displays the original and transformed circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device(\"default.qubit\"))\ndef node(x):\n    qml.RX(x, 0)\n    qml.RX(x, 1)\n    qml.RX(x, 2)\n    mcm0 = qml.measure(0, postselect=0, reset=False)\n    mcm1 = qml.measure(1, postselect=None, reset=True)\n    mcm2 = qml.measure(2, postselect=1, reset=False)\n    qml.cond(mcm0 + mcm1 + mcm2 == 1, qml.RX)(0.5, 3)\n    return qml.expval(qml.Z(0) @ qml.Z(3))\n```\n\n----------------------------------------\n\nTITLE: Iterative Quantum Phase Estimation with PennyLane\nDESCRIPTION: This snippet illustrates how to use `qml.iterative_qpe` for iterative quantum phase estimation in PennyLane. This method estimates the phase of a unitary operator. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", shots=5)\n\n@qml.qnode(dev)\ndef circuit():\n\n  # Initial state\n  qml.PauliX(wires=[0])\n\n  # Iterative QPE\n  measurements = qml.iterative_qpe(qml.RZ(2., wires=[0]), ancilla=[1], iters=3)\n```\n\n----------------------------------------\n\nTITLE: Accessing and Using Dataset Properties in a Circuit\nDESCRIPTION: Demonstrates how to access and utilize properties of a loaded dataset within a PennyLane quantum circuit. It shows how to use the `hf_state`, `vqe_gates`, and `hamiltonian` attributes.  Requires PennyLane and a pre-loaded dataset.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\",wires=4)\n>>> @qml.qnode(dev)\n... def circuit():\n... \tqml.BasisState(H2data.hf_state, wires = [0, 1, 2, 3])\n... \tfor op in H2data.vqe_gates:\n... \t\tqml.apply(op)\n... \treturn qml.expval(H2data.hamiltonian)\n>>> print(circuit())\n-1.0791430411076344\n```\n\n----------------------------------------\n\nTITLE: Block-Encoding with qml.FABLE (Python)\nDESCRIPTION: This code demonstrates the usage of the Fast Approximate BLock-Encodings (FABLE) algorithm via the qml.FABLE template for embedding a matrix into a quantum circuit. It imports numpy, defines a matrix, and creates a QNode to apply FABLE with a specified tolerance.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nA = np.array([[0.1, 0.2], [0.3, 0.4]])\ndev = qml.device('default.qubit', wires=3)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.FABLE(A, tol = 0.001, wires=range(3))  \n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: PennyLane Drawing Style\nDESCRIPTION: This code demonstrates how to create circuit diagrams with a PennyLane style using qml.draw_mpl. It defines a circuit and then uses qml.draw_mpl with style='pennylane' to generate a styled circuit diagram. Dependencies: PennyLane, Matplotlib.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef circuit(x, z):\n    qml.QFT(wires=(0,1,2,3))\n    qml.Toffoli(wires=(0,1,2))\n    qml.CSWAP(wires=(0,2,3))\n    qml.RX(x, wires=0)\n    qml.CRZ(z, wires=(3,0))\n    return qml.expval(qml.PauliZ(0))\n\nqml.draw_mpl(circuit, style=\"pennylane\")(1, 1)\n```\n\n----------------------------------------\n\nTITLE: Obtaining Coefficients and Pure Operators in PennyLane\nDESCRIPTION: This snippet shows how to obtain a list of coefficients and pure operators from a composite operator using the op.terms() method in PennyLane. This method already takes care of arithmetic simplifications.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> op = 0.5 * (X(0) @ X(1) + Y(0) @ Y(1) + 2 * Z(0) @ Z(1)) - 1.5 * I() + 0.5 * I()\n>>> op.terms()\n([0.5, 0.5, 1.0, -1.0], [X(1) @ X(0), Y(1) @ Y(0), Z(1) @ Z(0), I()])\n```\n\n----------------------------------------\n\nTITLE: FlipAndRotate Operator Instantiation, Decomposition, and Adjoint in PennyLane\nDESCRIPTION: Shows how to instantiate the custom `FlipAndRotate` operator, obtain its decomposition, and compute its adjoint.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nop = FlipAndRotate(0.1, wire_rot=\"q3\", wire_flip=\"q1\", do_flip=True)\nop\nop.decomposition()\nop.adjoint()\n```\n\n----------------------------------------\n\nTITLE: QuantumTape Context Example\nDESCRIPTION: Illustrates how to use QuantumTape as a context manager to record quantum operations and measurements.  The QuantumTape records a PauliX gate on wire 0 and a PauliZ expectation value measurement on wire 0 when the context is exited. The tape stores the operations and measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_tape.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nwith QuantumTape(shots=10) as tape:\n    qml.PauliX(0)\n    qml.expval(qml.PauliZ(0))\ntape\n```\n\n----------------------------------------\n\nTITLE: Compute the Center of a DLA\nDESCRIPTION: Calculates the center of a dynamical Lie algebra using `qml.center`. The center consists of operators that commute with all other operators in the DLA. This function helps in identifying invariant or symmetry-preserving elements within the DLA.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\n>>> g = [X(0), X(1) @ X(0), Y(1), Z(1) @ X(0)]\n>>> qml.center(g)\n[X(0)]\n```\n\n----------------------------------------\n\nTITLE: Custom Transform Definition in PennyLane\nDESCRIPTION: This snippet defines a custom transform called shift_rx_to_end that moves all RX gates to the end of the circuit's operations list. It iterates through the operations, separates RX gates, and creates a new tape with the modified order.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\n\nqml.capture.enable()\n\n\n@qml.transform\n\ndef shift_rx_to_end(tape):\n\n    \"\"\"Transform that moves all RX gates to the end of the operations list.\"\"\"\n\n    new_ops, rxs = [], []\n\n\n    for op in tape.operations:\n\n        if isinstance(op, qml.RX):\n\n            rxs.append(op)\n\n        else:\n\n            new_ops.append(op)\n\n        \n\n    operations = new_ops + rxs\n\n    new_tape = tape.copy(operations=operations)\n\n    return [new_tape], lambda res: res[0]\n```\n\n----------------------------------------\n\nTITLE: Initializing FermiC and FermiA Operators in PennyLane\nDESCRIPTION: Demonstrates how to create fermionic creation (FermiC) and annihilation (FermiA) operators in PennyLane. The operators are initialized with the index of the orbital they act on.  FermiC creates a creation operator, while FermiA creates an annihilation operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.FermiC(0)\na⁺(0)\n>>> qml.FermiA(3)\na(3)\n```\n\n----------------------------------------\n\nTITLE: Validating Spin Lattice Points (Python)\nDESCRIPTION: This snippet validates that the `lattice_points` of a custom-defined lattice match the `lattice_points` generated by `qml.spin.generate_lattice` for a standard lattice such as the triangle lattice. It uses `np.allclose` to compare the coordinates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> lp = lattice.lattice_points\n>>> triangular_lattice = qml.spin.generate_lattice('triangle', n_cells=[3, 3])\n>>> np.allclose(lp, triangular_lattice.lattice_points)\nTrue\n```\n\n----------------------------------------\n\nTITLE: Executing QNode with Automatic Interface Detection and Calculating Jacobian in Pycon\nDESCRIPTION: This snippet demonstrates executing the QNode defined with automatic interface detection. It calls the circuit with JAX array parameters and then calculates the Jacobian of the circuit using `jax.jacobian`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(a, b)\n(Array(0.9950042, dtype=float32), Array(-0.19767681, dtype=float32))\n>>> jac = jax.jacobian(circuit)(a, b)\n>>> jac\n(Array(-0.09983341, dtype=float32, weak_type=True), Array(0.01983384, dtype=float32, weak_type=True))\n```\n\n----------------------------------------\n\nTITLE: Unitary Distance Measurement with HilbertSchmidt in PennyLane\nDESCRIPTION: Shows how to use the `qml.HilbertSchmidt` template to measure the distance between two unitaries and define a cost function for learning a unitary.  The example defines a target unitary `U` and a parameterized unitary `V`, then uses `HilbertSchmidt` to compute a cost function that quantifies the difference between them.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nwith qml.tape.QuantumTape(do_queue=False) as u_tape:\n    qml.Hadamard(wires=0)\n\n# Represents unitary V\ndef v_function(params):\n    qml.RZ(params[0], wires=1)\n\n@qml.qnode(dev)\ndef hilbert_test(v_params, v_function, v_wires, u_tape):\n    qml.HilbertSchmidt(v_params, v_function=v_function, v_wires=v_wires, u_tape=u_tape)\n    return qml.probs(u_tape.wires + v_wires)\n\ndef cost_hst(parameters, v_function, v_wires, u_tape):\n    return (1 - hilbert_test(v_params=parameters, v_function=v_function, v_wires=v_wires, u_tape=u_tape)[0])\n```\n\n----------------------------------------\n\nTITLE: Executing Circuit with Parameter Broadcasting in PennyLane\nDESCRIPTION: This snippet executes the defined quantum circuit with an array of parameters, showcasing the parameter broadcasting capability. The function will apply the RX gate to the qubit for each element in the array of parameters. The result is an array of expectation values, each corresponding to one of the input parameters. It requires numpy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(np.array([0.1, 0.3, 0.2]))\ntensor([0.99500417, 0.95533649, 0.98006658], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Molecular Hamiltonian with 6-31G Basis Set in PennyLane\nDESCRIPTION: Illustrates how to use the `6-31G` basis set when constructing a molecular Hamiltonian using `qml.qchem.molecular_hamiltonian`. The `basis` parameter is set to \"6-31g\", allowing for differentiable Hartree-Fock calculations with a more comprehensive basis set compared to the minimal `sto-3g` basis set.  This is applicable for atoms with atomic numbers 1-10.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]])\nH, qubits = qml.qchem.molecular_hamiltonian(symbols, geometry, basis=\"6-31g\")\n```\n\n----------------------------------------\n\nTITLE: Calculating Relative Entropy of Quantum Circuits\nDESCRIPTION: This code demonstrates calculating the relative entropy between two quantum circuits using `qml.qinfo.relative_entropy`.  It defines two parameter arrays `x` and `y`, and then computes the relative entropy between the circuit evaluated at `x` and the circuit evaluated at `y`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_28\n\nLANGUAGE: pycon\nCODE:\n```\n>>> relative_entropy_circuit = qml.qinfo.relative_entropy(circuit, circuit, wires0=[0], wires1=[0])\n>>> x, y = np.array(0.4), np.array(0.6)\n>>> relative_entropy_circuit((x,), (y,))\n0.017750012490703237\n```\n\n----------------------------------------\n\nTITLE: Create and Inspect a JAXPR\nDESCRIPTION: Creates a JAXPR (JAX expression) for the `my_func` function using `jax.make_jaxpr` and then prints the JAXPR and its equations. This demonstrates how JAX represents computations as data structures.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> jaxpr = jax.make_jaxpr(my_func)(0.1)\n>>> jaxpr\n{ lambda ; a:f32[]. let b:f32[1] = my_func a in (b,) }\n>>> jaxpr.jaxpr.eqns\n[a:f32[1] = my_func b]\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Parameters in PennyLane\nDESCRIPTION: This code snippet demonstrates how parameter broadcasting affects the shape of the returned result.  It shows a batched RX gate, and the resulting array from `qml.probs` and `qml.expval` have shapes `(3, 2)` and `(3,)` respectively.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nop = qml.RX((0, np.pi/4, np.pi/2), wires=0)\ntape = qml.tape.QuantumScript((op,), [qml.probs(wires=0)])\nresult = qml.device('default.qubit').execute(tape)\nresult\nresult.shape\ntape = qml.tape.QuantumScript((op,), [qml.expval(qml.Z(0))])\nresult = qml.device('default.qubit').execute(tape)\nresult\nresult.shape\n```\n\n----------------------------------------\n\nTITLE: Observable Addition and Scalar Multiplication in PennyLane\nDESCRIPTION: Demonstrates the addition and scalar multiplication of `qml.PauliX` and `qml.PauliZ` operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nop = qml.PauliX(0) + 0.1 * qml.PauliZ(0)\nop.name\nop\n```\n\n----------------------------------------\n\nTITLE: Drawing MERA Circuit with Wire Reordering\nDESCRIPTION: This code snippet showcases how to draw the MERA circuit using `qml.draw`, specifying the `expansion_strategy` and reordering the wires using the `wire_order` parameter.  It visualizes the quantum circuit implemented with the MERA template. It depends on the previously defined `circuit` and `template_weights`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(circuit,expansion_strategy='device',wire_order=[2,0,1,3])(template_weights))\n```\n\n----------------------------------------\n\nTITLE: Defining Device Wires Property in Python\nDESCRIPTION: This code snippet demonstrates how to define the `wires` property within a PennyLane device class to hardcode the acceptable wire labels. This ensures that the device only operates on specific qubits, as defined by the `Wires` object. This implementation prevents users from initializing the device with arbitrary wire labels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nclass MyDevice(qml.devices.Device):\n\n    def __init__(self, shots=None):\n        super().__init__(shots=shots)\n\n    @property\n    def wires(self):\n        return qml.wires.Wires((0,1,2,3))\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit using Wire Registers in PennyLane\nDESCRIPTION: This snippet demonstrates the usage of wire registers within a quantum circuit in PennyLane. It applies Hadamard gates to Alice's wires, RX gates to Bob1's wires, and a CNOT gate between Alice1 and Bob2 wires.  Finally, it measures the expectation value of the Y operator on Bob1's wires. The circuit utilizes the `qml.registers` feature to organize and access specific wires, making the circuit definition more structured and readable. Requires PennyLane and a compatible device (e.g., default.qubit).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    for w in wire_reg[\"alice\"]:\n        qml.Hadamard(w)\n\n    for w in wire_reg[\"bob1\"]:\n        qml.RX(0.1967, wires=w)\n\n    qml.CNOT(wires=[wire_reg[\"alice1\"][0], wire_reg[\"bob2\"][0]])\n\n    return [qml.expval(qml.Y(w)) for w in wire_reg[\"bob1\"]]\n\nprint(qml.draw(circuit)())\n```\n\n----------------------------------------\n\nTITLE: Initializing a PennyLane Device with Integer Wires\nDESCRIPTION: This code initializes a PennyLane device with a specified number of wires, addressed by consecutive integers starting from 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=3)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Gradient Transforms in PennyLane\nDESCRIPTION: This code snippet shows how to define a custom gradient transform in PennyLane. A decorator `@qml.gradients.gradient_transform` is used to define a new function which computes custom gradients, and then this transform is passed to the QNode via the `diff_method` argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.gradients.gradient_transform\ndef my_gradient_transform(tape):\n    ...\n    return tapes, processing_fn\n\n@qml.qnode(dev, diff_method=my_gradient_transform)\ndef circuit():\n    pass\n```\n\n----------------------------------------\n\nTITLE: Install documentation dependencies (Console)\nDESCRIPTION: This snippet provides the command to install the necessary Python packages for building the PennyLane documentation. It uses pip to install the packages listed in the `doc/requirements.txt` file. These packages include Sphinx, sphinx-automodapi, pygments-github-lexers, m2r, and sphinx-copybutton.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_8\n\nLANGUAGE: console\nCODE:\n```\n$ pip install -r doc/requirements.txt\n```\n\n----------------------------------------\n\nTITLE: Representation of Wires instance in Python\nDESCRIPTION: This snippet demonstrates the new copy-paste friendly representation of Wires instances when printed, using `from pennylane.wires import Wires`.  It showcases how a Wires object containing a list of wire labels is displayed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.wires import Wires\n>>> w = Wires([1, 2, 3])\n>>> w\nWires([1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Iterating QuantumTape Operations\nDESCRIPTION: This code iterates through the `QuantumTape` object and prints each operation. It assumes that the `tape` object has already been created and populated with quantum operations and measurements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> for op in tape:\n...     print(op)\n```\n\n----------------------------------------\n\nTITLE: Capturing a PennyLane QNode with Python Control Flow\nDESCRIPTION: This example demonstrates capturing a PennyLane QNode that includes Python control flow (for loops and if statements) using AutoGraph.  The `make_plxpr` function automatically utilizes AutoGraph by default. The code defines a quantum circuit with parameterized gates controlled by the input `weights` and `data`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef cost(weights, data):\n\n    for w in dev.wires:\n        qml.X(w)\n\n    for x in weights:\n\n        for j, p in enumerate(x):\n            if p > 0:\n                qml.RX(p, wires=j)\n            elif p < 0:\n                qml.RY(p, wires=j)\n\n        for j in range(4):\n            qml.CNOT(wires=[j, jnp.mod((j + 1), 4)])\n\n    return qml.expval(qml.PauliZ(0) + qml.PauliZ(3))\n```\n\n----------------------------------------\n\nTITLE: Custom Compilation Pipeline (Python)\nDESCRIPTION: Shows how to define a custom compilation pipeline using `qml.compile` with specific transforms like `commute_controlled` and `cancel_inverses`. This allows users to tailor the optimization process to their specific needs. Requires PennyLane installation and importing specific transforms.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.transforms import commute_controlled, cancel_inverses\npipeline = [commute_controlled, cancel_inverses]\n\ndev = qml.device('default.qubit', wires=[0, 1, 2])\n\n@qml.qnode(dev)\n@qml.compile(pipeline=pipeline)\ndef qfunc(x, y, z):\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    qml.Hadamard(wires=2)\n    qml.RZ(z, wires=2)\n    qml.CNOT(wires=[2, 1])\n    qml.RX(z, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RZ(-z, wires=2)\n    qml.RX(y, wires=2)\n    qml.PauliY(wires=2)\n    qml.CZ(wires=[1, 2])\n    return qml.expval(qml.PauliZ(wires=0))\n```\n\n----------------------------------------\n\nTITLE: Implementing MERA Template in PennyLane\nDESCRIPTION: This code demonstrates how to use the `qml.MERA` template to implement quantum circuits with the shape of a multi-scale entanglement renormalization ansatz (MERA). It defines a block function, sets up the MERA with specified wires and parameters, and constructs a quantum circuit using `qml.MERA` within a QNode. The code returns the expectation value of a PauliZ operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef block(weights, wires):\n    qml.CNOT(wires=[wires[0],wires[1]])\n    qml.RY(weights[0], wires=wires[0])\n    qml.RY(weights[1], wires=wires[1])\n\nn_wires = 4\nn_block_wires = 2\nn_params_block = 2\nn_blocks = qml.MERA.get_n_blocks(range(n_wires),n_block_wires)\ntemplate_weights = [[0.1,-0.3]]*n_blocks\n\ndev= qml.device('default.qubit',wires=range(n_wires))\n@qml.qnode(dev)\ndef circuit(template_weights):\n    qml.MERA(range(n_wires),n_block_wires,block, n_params_block, template_weights)\n    return qml.expval(qml.PauliZ(wires=1))\n```\n\n----------------------------------------\n\nTITLE: Creating a CommutationDAG in PennyLane\nDESCRIPTION: This code snippet defines a quantum circuit and then creates a CommutationDAG using the `qml.commutation_dag` transform. The resulting DAG represents the non-commutation relationships between the quantum operations in the circuit. The input parameters `x`, `y`, and `z` are used to parametrize the quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> def circuit(x, y, z):\n...     qml.RX(x, wires=0)\n...     qml.RX(y, wires=0)\n...     qml.CNOT(wires=[1, 2])\n...     qml.RY(y, wires=1)\n...     qml.Hadamard(wires=2)\n...     qml.CRZ(z, wires=[2, 0])\n...     qml.RY(-y, wires=1)\n...     return qml.expval(qml.Z(0))\n>>> dag_fn = qml.commutation_dag(circuit)\n>>> dag = dag_fn(np.pi / 4, np.pi / 3, np.pi / 2)\n```\n\n----------------------------------------\n\nTITLE: Sparse Matrix Conversion to Array in Python\nDESCRIPTION: This snippet demonstrates how to convert a sparse matrix, computed using `qml.utils.sparse_hamiltonian`, to a dense NumPy array. It shows the output format of the sparse matrix and the resulting dense array after conversion.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> H_sparse.toarray()\narray([[ 1.+0.j  ,  0.+0.j  ,  0.+0.45j,  0.+0.j  ],\n       [ 0.+0.j  , -1.+0.j  ,  0.+0.j  ,  0.-0.45j],\n       [ 0.-0.45j,  0.+0.j  , -1.+0.j  ,  0.+0.j  ],\n       [ 0.+0.j  ,  0.+0.45j,  0.+0.j  ,  1.+0.j  ]])\n```\n\n----------------------------------------\n\nTITLE: Calculating Adjoint Metric Tensor\nDESCRIPTION: Shows how to calculate the metric tensor using the `qml.adjoint_metric_tensor` function. The previously defined quantum circuit and input parameters are passed to the function. The adjoint method is only applicable for analytic computations with statevector simulators and `shots=None`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nqml.adjoint_metric_tensor(circuit)(x, y)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Resource Operations in PennyLane\nDESCRIPTION: Demonstrates how to define custom quantum operations that specify resource requirements without needing an explicit decomposition or matrix representation. This is achieved by inheriting from `ResourcesOperation` and overriding the `resources()` method.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass CustomOp(qml.resource.ResourcesOperation):\n    def resources(self):\n        n = len(self.wires)\n        r = qml.resource.Resources(\n            num_wires=n,\n            num_gates=n ** 2,\n            depth=5,\n        )\n        return r\n```\n\n----------------------------------------\n\nTITLE: Instantiate Default Tensor Device with Max Bond Dimension\nDESCRIPTION: Demonstrates how to instantiate the `default.tensor` device with a specified `max_bond_dim` to control the approximation in matrix product state simulations. It also creates a `default.qubit` device for comparison and then compares the expectation values calculated using both devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev_dq = qml.device(\"default.qubit\")\nvalue_dq = qml.QNode(f, dev_dq)()\n\ndev_mps = qml.device(\"default.tensor\", max_bond_dim=5)\nvalue_mps = qml.QNode(f, dev_mps)()\n```\n\n----------------------------------------\n\nTITLE: Device Creation with Custom Wires\nDESCRIPTION: This code snippet demonstrates how to create a PennyLane device with custom wire labels and use it in a QNode. It shows how to define a circuit with gates and observables that use the custom wire labels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import *\n\ndev = device('my.device', wires=['q11', 'q12', 'q21', 'q22'])\n\n@qnode(dev)\ndef circuit():\n   Gate1(wires='q22')\n   Gate2(wires=['q21','q11'])\n   Gate1(wires=['q21'])\n   return expval(Obs(wires='q11') @ Obs(wires='q12'))\n```\n\n----------------------------------------\n\nTITLE: Scalar Multiplication with qml.RX operator\nDESCRIPTION: This Python code demonstrates the multiplication of a scalar tensor with a PennyLane operator (qml.RX). It shows how to create the scaled operator and access its scalar value. Dependencies: torch, PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_31\n\nLANGUAGE: pycon\nCODE:\n```\n>>> s_prod = torch.tensor(4) * qml.RX(1.23, 0)\n>>> s_prod\n4*(RX(1.23, wires=[0]))\n>>> s_prod.scalar\ntensor(4)\n```\n\n----------------------------------------\n\nTITLE: Projector Observable Example in Python\nDESCRIPTION: This snippet demonstrates the usage of the new `qml.Projector` observable. It requires PennyLane and shows how to define basis state projectors to compute expectation values. The example uses a circuit that prepares Bell states and then computes the expectation value of the projector onto the |00> basis state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(basis_state):\n    qml.Hadamard(wires=[0])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.Projector(basis_state, wires=[0, 1]))\n```\n\n----------------------------------------\n\nTITLE: Executing TensorFlow Circuit and Calculating Gradients\nDESCRIPTION: This snippet shows how to execute the previously defined PennyLane quantum circuit within a TensorFlow environment and calculate its gradient.  It requires the previously defined circuit `circuit` and the `tf.GradientTape` context. Requires PennyLane, TensorFlow, and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> a = tf.Variable(0.4)\n>>> with tf.GradientTape() as tape:\n...     res = circuit(a)\n...     res = tf.stack([tf.experimental.numpy.hstack(r) for r in res])\n...\n>>> res\n<tf.Tensor: shape=(3, 5), dtype=float64, numpy=\narray([[0.902, 0.951, 0.   , 0.   , 0.049],\n       [0.898, 0.949, 0.   , 0.   , 0.051],\n       [0.892, 0.946, 0.   , 0.   , 0.054]])>\n>>> tape.jacobian(res, a)\n<tf.Tensor: shape=(3, 5), dtype=float64, numpy=\narray([[-0.345     , -0.1725    ,  0.        ,  0.        ,  0.1725    ],\n       [-0.383     , -0.1915    ,  0.        ,  0.        ,  0.1915    ],\n       [-0.38466667, -0.19233333,  0.        ,  0.        ,  0.19233333]])>\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Simplification in PennyLane\nDESCRIPTION: Demonstrates how to simplify a PennyLane Hamiltonian object.  The .simplify() method does not alter the instance in-place and the simplified object must be assigned to a variable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> H1 = qml.Hamiltonian([0.5, 0.5], [X(0) @ X(1), X(0) @ X(1)])\n>>> H1 = H1.simplify()\n```\n\n----------------------------------------\n\nTITLE: Executing Quantum Circuit with FlipSign Operator\nDESCRIPTION: This code executes the quantum circuit defined to use the `FlipSign` operator and shows the resulting quantum state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_37\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\ntensor([ 0.5+0.j  -0.5+0.j 0.5+0.j  0.5+0.j], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Accessing Hamiltonian Grouping Indices\nDESCRIPTION: This interactive console snippet demonstrates how to access the grouping indices of a Hamiltonian object that has been initialized with a specific grouping type. The grouping indices provide information about how the observables are grouped for efficient computation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> H.grouping_indices\n[[0, 1], [2]]\n```\n\n----------------------------------------\n\nTITLE: Training Hamiltonian Coefficients\nDESCRIPTION: This snippet demonstrates how to train Hamiltonian coefficients in PennyLane. A quantum circuit is defined, and the expectation value of a Hamiltonian (with trainable coefficients) is returned. The gradients of the circuit with respect to both the coefficients and a parameter are then computed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\n\ndev = qml.device(\"default.qubit\", wires=2)\n@qml.qnode(dev)\ndef circuit(coeffs, param):\n    qml.RX(param, wires=0)\n    qml.RY(param, wires=0)\n    return qml.expval(\n        qml.Hamiltonian(coeffs, [qml.PauliX(0), qml.PauliZ(0)], simplify=True)\n    )\n\ncoeffs = np.array([-0.05, 0.17])\nparam = np.array(1.7)\ngrad_fn = qml.grad(circuit)\n```\n\n----------------------------------------\n\nTITLE: Initializing Transverse Field Ising Model Hamiltonian in PennyLane\nDESCRIPTION: This code snippet demonstrates how to instantiate a transverse-field Ising model Hamiltonian using PennyLane's `qml.spin.transverse_ising` function. It specifies the lattice type, number of unit cells, and coupling parameters to create a `qml.Hamiltonian` instance. The resulting Hamiltonian can then be used within quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n>>> tfim_ham = qml.spin.transverse_ising(lattice=\"square\", n_cells=[2, 2], coupling=0.5, h=0.2)\n>>> tfim_ham\n(\n    -0.5 * (Z(0) @ Z(1))\n  + -0.5 * (Z(0) @ Z(2))\n  + -0.5 * (Z(1) @ Z(3))\n  + -0.5 * (Z(2) @ Z(3))\n  + -0.2 * X(0)\n  + -0.2 * X(1)\n  + -0.2 * X(2)\n  + -0.2 * X(3)\n)\n```\n\n----------------------------------------\n\nTITLE: Parameter Broadcasting with TorchLayer\nDESCRIPTION: This example demonstrates the parameter broadcasting feature available in PennyLane's `TorchLayer`. It shows how to pass a batch of inputs to the `TorchLayer` and verifies that the quantum device executes only once, indicating that the parameters are being broadcast efficiently.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> batch_size = 10\n>>> inputs = torch.rand((batch_size, n_qubits))\n>>> qlayer(inputs)\n>>> dev.num_executions == 1\nTrue\n```\n\n----------------------------------------\n\nTITLE: Printing Resource Estimates from DoubleFactorization\nDESCRIPTION: This snippet prints the estimated gate count and qubit count obtained from the `DoubleFactorization` class, providing insights into the computational resources needed for the simulation. It requires the `DoubleFactorization` instance to be initialized beforehand.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(algo.gates, algo.qubits)\n103969925, 290\n```\n\n----------------------------------------\n\nTITLE: Creating Fermi Words in PennyLane\nDESCRIPTION: Shows how to create Fermi words by multiplying FermiC and FermiA operators.  Fermi words are n-orbital fermionic operators created by combining creation and annihilation operators. This example creates the operator a⁺(0) a(0) a⁺(3) a(3).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.FermiC(0) * qml.FermiA(0) * qml.FermiC(3) * qml.FermiA(3)\na⁺(0) a(0) a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: Differentiable Purity Calculation in PennyLane\nDESCRIPTION: This example demonstrates how to calculate the gradient of the purity using PennyLane's automatic differentiation capabilities. It requires a quantum circuit defined as `circuit` and utilizes NumPy for numerical operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> param = np.array(np.pi / 4, requires_grad=True)\n>>> qml.grad(qml.qinfo.transforms.purity(circuit, wires=[0]))(param)\n-0.5\n```\n\n----------------------------------------\n\nTITLE: Molecular Hamiltonian with Custom Parameters in PennyLane\nDESCRIPTION: This snippet shows how to build a molecular Hamiltonian with custom charge, multiplicity, basis name, mapping method, active electrons, and active orbitals. It uses the `molecular_hamiltonian` function with specific arguments to customize the Hamiltonian construction. It requires pennylane and numpy. The output consists of the customized Hamiltonian and the number of qubits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/chemistry.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmolecule = qml.qchem.Molecule(\n    symbols,\n    geometry,\n    charge=0,\n    mult=1,\n    basis_name='sto-3g')\nhamiltonian, qubits = qml.qchem.molecular_hamiltonian(\n    molecule,\n    mapping='jordan_wigner',\n    active_electrons=2,\n    active_orbitals=2\n)\n```\n\n----------------------------------------\n\nTITLE: Defining Supported Operations with a Set\nDESCRIPTION: This snippet shows how to define supported operations for a PennyLane device by specifying a set of operation names. This approach allows the device to indicate which specific operations it can natively execute.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\noperations = {\"CNOT\", \"PauliX\"}\n```\n\n----------------------------------------\n\nTITLE: Perform qubitization in PennyLane (Python)\nDESCRIPTION: This code demonstrates the usage of the qml.Qubitization operator for encoding a Hamiltonian into a unitary operator suitable for quantum phase estimation. It defines a Hamiltonian, creates a QNode, initializes an eigenvector, applies quantum phase estimation using qml.iterative_qpe with the Qubitization operator, and returns the probabilities of the measurement outcomes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nH = qml.dot([0.1, 0.3, -0.3], [qml.Z(0), qml.Z(1), qml.Z(0) @ qml.Z(2)])\n@qml.qnode(qml.device(\"default.qubit\"))\ndef circuit():\n    # initialize the eigenvector\n    qml.PauliX(2)\n    # apply QPE\n    measurements = qml.iterative_qpe(\n        qml.Qubitization(H, control = [3,4]), ancilla = 5, iters = 3\n    )\n    return qml.probs(op = measurements)\n```\n\n----------------------------------------\n\nTITLE: Evaluating pwc_from_function Decorated Function\nDESCRIPTION: This example demonstrates how to evaluate a function decorated with `qml.pulse.pwc_from_function`.  It shows that values of `t` within the same bin return the same value, while values outside the specified interval return zero.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_30\n\nLANGUAGE: pycon\nCODE:\n```\n# t=2 and t=2.1 are within the same bin\n>>> f1(3, 2), f1(3, 2.1)\n(DeviceArray(6., dtype=float32), DeviceArray(6., dtype=float32))\n# next bin\n>>> f1(3, 2.2)\nDeviceArray(6.6666665, dtype=float32)\n# outside the interval t=(2, 4)\n>>> f1(3, 5)\nDeviceArray(0., dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Generalized RotosolveOptimizer with frequency spectra\nDESCRIPTION: Illustrates how to use the generalized RotosolveOptimizer in PennyLane, which now supports arbitrary frequency spectra in the cost function. It defines a quantum node (QNode) with arbitrary gates, obtains its frequency spectra using qml.fourier.qnode_spectrum, initializes the RotosolveOptimizer, and minimizes the QNode cost function. Dependencies include NumPy and PennyLane's core and fourier modules.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef qnode(x, Y):\n    qml.RX(2.5 * x, wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RZ(0.3 * Y[0], wires=0)\n    qml.CRY(1.1 * Y[1], wires=[1, 0])\n    return qml.expval(qml.PauliX(0) @ qml.PauliZ(1))\n\nx = np.array(0.8, requires_grad=True)\nY = np.array([-0.2, 1.5], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Optimizing Pauli word measurements in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `optimize_measurements` function from the `pennylane.grouping` module to partition Pauli terms and diagonalize them in the measurement basis. It takes a list of Pauli word observables and their corresponding coefficients as input and returns the partitioned Pauli terms, diagonalizing circuits, and coefficients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.grouping import optimize_measurements\nh, nr_qubits = qml.qchem.molecular_hamiltonian(\"h2\", \"h2.xyz\")\nrotations, grouped_ops, grouped_coeffs = optimize_measurements(h.ops, h.coeffs, grouping=\"qwc\")\n```\n\n----------------------------------------\n\nTITLE: Using fixed_decomps and alt_decomps in decompose transform in Python\nDESCRIPTION: This snippet demonstrates how to use the `fixed_decomps` and `alt_decomps` keyword arguments in the `qml.transforms.decompose` transform to inject new decomposition rules for operators within a QNode. It defines custom decompositions for `IsingXX` and `CNOT` gates and applies them using the `decompose` transform.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nqml.decomposition.enable_graph()\n\n@qml.register_resources({qml.CNOT: 2, qml.RX: 1})\ndef my_isingxx(phi, wires, **__):\n    qml.CNOT(wires=wires)\n    qml.RX(phi, wires=[wires[0]])\n    qml.CNOT(wires=wires)\n\n@qml.register_resources({qml.H: 2, qml.CZ: 1})\ndef my_cnot(wires, **__):\n    qml.H(wires=wires[1])\n    qml.CZ(wires=wires)\n    qml.H(wires=wires[1])\n\n@partial(\n    qml.transforms.decompose,\n    gate_set={\"RX\", \"RZ\", \"CZ\", \"GlobalPhase\"},\n    alt_decomps={qml.CNOT: my_cnot},\n    fixed_decomps={qml.IsingXX: my_isingxx},\n)\n@qml.qnode(qml.device(\"default.qubit\"))\ndef circuit():\n    qml.CNOT(wires=[0, 1])\n    qml.IsingXX(0.5, wires=[0, 1])\n    return qml.state()\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\narray([ 9.68912422e-01+2.66934210e-16j, -1.57009246e-16+3.14018492e-16j,\n       8.83177008e-17-2.94392336e-17j,  5.44955495e-18-2.47403959e-01j])\n```\n\n----------------------------------------\n\nTITLE: Pulse Programming with pwc_from_function Decorator\nDESCRIPTION: This snippet shows how to use the `qml.pulse.pwc_from_function` decorator to create a piecewise constant approximation of a function for use in a `qml.pulse.ParametrizedHamiltonian`. The decorator takes the timespan and the number of bins as arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_29\n\nLANGUAGE: pycon\nCODE:\n```\n>>> @qml.pulse.pwc_from_function((2, 4), num_bins=10)\n... def f1(p, t):\n...     return p * t\n```\n\n----------------------------------------\n\nTITLE: Create NoiseModel with Custom Conditions and Operations\nDESCRIPTION: Shows how to create a `qml.NoiseModel` object by mapping conditions to noise operations.  It combines predefined conditions like `qml.noise.op_eq` and `qml.noise.wires_in` with custom conditions and noise operations to define a complex noise model.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nc1 = qml.noise.op_eq(qml.X) & qml.noise.wires_in([0, 1])\nn1 = qml.noise.partial_wires(qml.AmplitudeDamping, 0.4)\n\nnoise_model = qml.NoiseModel({c0: n0, c1: n1})\n```\n\n----------------------------------------\n\nTITLE: Implementing Device Tracking in PennyLane\nDESCRIPTION: This snippet illustrates how to implement custom device tracking by updating and recording information within the `execute` method of a custom device. The code checks if the tracker is active, updates it with the number of batches and executions, tracks shots for each circuit, and records the tracked information.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nif self.tracker.active:\n    self.tracker.update(batches=1, executions=len(circuits))\n    for c in circuits:\n        self.tracker.update(shots=c.shots)\n    self.tracker.record()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fourier Coefficients with Radial Box Plot\nDESCRIPTION: This snippet demonstrates how to visualize Fourier coefficients using a radial box plot. It creates a figure and two polar subplots using `plt.subplots` with the `subplot_kw=dict(polar=True)` argument. Then, it calls the `radial_box` function, passing the coefficients, degree (2), the axes objects, and boolean arguments to show frequencies and to hide box plot fliers (`show_freqs=True, show_fliers=False`). It requires matplotlib.pyplot and a function named `radial_box` which probably comes from `pennylane.fourier.visualize`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# The subplot axes must be *polar* for the radial plots\nfig, ax = plt.subplots(\n    1, 2, sharex=True, sharey=True,\n    subplot_kw=dict(polar=True),\n    figsize=(15, 8)\n)\nradial_box(coeffs, 2, ax, show_freqs=True, show_fliers=False)\n```\n\n----------------------------------------\n\nTITLE: Vector-valued QNodes and the Jacobian\nDESCRIPTION: This code shows how to compute the Jacobian matrix for a vector-valued QNode using `pennylane.jacobian`. It demonstrates the need to stack the results into a single array before use with the Jacobian function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit5(params):\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RX(params[0], wires=0)\n    qml.RY(params[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliY(0)), qml.expval(qml.PauliZ(1))\n\nj1 = qml.jacobian(lambda x: np.stack(circuit5(x)))\nparams = np.array([np.pi/2, 0.2], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Pauli Operations in PennyLane\nDESCRIPTION: This code demonstrates how to simplify the product of Pauli operators using `qml.simplify` and `qml.prod`. It showcases the replacement of `qml.pauli.pauli_mult` and `qml.pauli.pauli_mult_with_phase` with a new approach using `qml.simplify(qml.prod(...))`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> op = qml.simplify(qml.prod(qml.PauliX(0), qml.PauliZ(0)))\n>>> op\n-1j*(PauliY(wires=[0]))\n>>> [phase], [base] = op.terms()\n>>> phase, base\n(-1j, PauliY(wires=[0]))\n```\n\n----------------------------------------\n\nTITLE: Applying Matrix Transform to Quantum Functions in PennyLane\nDESCRIPTION: Shows how to apply the `qml.matrix` transform to a quantum function that defines a circuit. This computes the matrix representation of the entire circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> def circuit(theta):\n...     qml.RX(theta, wires=1)\n...     qml.PauliZ(wires=0)\n>>> qml.matrix(circuit)(np.pi / 4)\narray([[ 0.92387953+0.j,  0.+0.j ,  0.-0.38268343j,  0.+0.j],\n[ 0.+0.j,  -0.92387953+0.j,  0.+0.j,  0. +0.38268343j],\n[ 0. -0.38268343j,  0.+0.j,  0.92387953+0.j,  0.+0.j],\n[ 0.+0.j,  0.+0.38268343j,  0.+0.j,  -0.92387953+0.j]])\n```\n\n----------------------------------------\n\nTITLE: Converting a PennyLane QNode into a Torch Layer\nDESCRIPTION: This snippet illustrates how to convert a PennyLane QNode into a Torch layer using `qml.qnn.TorchLayer`. It requires a pre-defined QNode and corresponding weight shapes. The resulting Torch layer can then be integrated into a `torch.nn.Sequential` model for hybrid quantum-classical computation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.10.0.md#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n>>> @qml.qnode(dev)\n... def qnode(inputs, weights_0, weight_1):\n...    # define the circuit\n...    # ...\n\n>>> weight_shapes = {\"weights_0\": 3, \"weight_1\": 1}\n>>> qlayer = qml.qnn.TorchLayer(qnode, weight_shapes)\n```\n\n----------------------------------------\n\nTITLE: Cartan Decomposition using PennyLane\nDESCRIPTION: This code performs Cartan decomposition of a Lie algebra using the concurrence_involution. It splits the Lie algebra into two subspaces, k and m, satisfying specific commutation relations. It requires pennylane and pennylane.liealg.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.liealg import concurrence_involution\nk, m = qml.liealg.cartan_decomp(dla, concurrence_involution)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Operators with qml.simplify in PennyLane\nDESCRIPTION: Demonstrates the usage of `qml.simplify` to simplify PennyLane operators, including reducing arithmetic depth, grouping like terms, resolving Pauli operator products, and combining rotation gates. It showcases the function's ability to simplify individual operators, sums, products, and nested operators. This helps to reduce the complexity of quantum circuits and improve efficiency.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.simplify(qml.RX(4*np.pi+0.1, 0 ))\nRX(0.09999999999999964, wires=[0])\n>>> qml.simplify(qml.adjoint(qml.RX(1.23, 0)))\nRX(11.336370614359172, wires=[0])\n>>> qml.simplify(qml.ops.Pow(qml.RX(1, 0), 3))\nRX(3.0, wires=[0])\n>>> qml.simplify(qml.sum(qml.Y(3), qml.Y(3)))\n2.0 * Y(3)\n>>> qml.simplify(qml.RX(1, 0) @ qml.RX(1, 0))\nRX(2.0, wires=[0])\n>>> qml.simplify(qml.prod(qml.X(0), qml.Z(0)))\n-1j * Y(0)\n```\n\n----------------------------------------\n\nTITLE: Sampling Fourier Coefficients with NumPy\nDESCRIPTION: This snippet demonstrates how to sample Fourier coefficients by randomly sampling weights for a quantum circuit. It initializes an empty list called `coeffs`, then iterates 100 times.  Inside the loop, it samples weights from a normal distribution using `np.random.normal`, calculates the Fourier coefficients using a function named `coefficients` applied to a partial function of `circuit_with_weights`, and appends the rounded coefficients to the `coeffs` list. It depends on NumPy and the `circuit_with_weights` and `coefficients` functions being defined elsewhere.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = []\n\nfor _ in range(100):\n    weights = np.random.normal(0, 1, size=(2, 3))\n    c = coefficients(partial(circuit_with_weights, weights), 2, degree=2)\n    coeffs.append(np.round(c, decimals=8))\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit Returning Counts Measurement\nDESCRIPTION: This code defines a quantum circuit that returns the counts measurement. It initializes a default qubit device with 2 wires and 1000 shots, then defines a quantum node that applies a Hadamard gate and a CNOT gate, returning the counts measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=1000)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.counts()\n```\n\n----------------------------------------\n\nTITLE: QNode with static array indexing in for loop\nDESCRIPTION: This code defines a QNode `f` that iterates three times and applies an RX gate to each of the three qubits based on values from the input array `x`. This demonstrates using a for loop with static bounds to index a JAX array within a PennyLane QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n@qml.qnode(dev)\ndef f(x):\n    for i in range(3):\n        qml.RX(x[i], wires=i)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Multiple Abstracted Axes\nDESCRIPTION: This snippet demonstrates how to use `abstracted_axes` with multiple arguments, each having its own dynamic dimensions. It shows how to specify the abstracted axes for each argument in a tuple and how common dynamic sizes are represented by a single tracer variable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\na = 3\nb = 4\nx = jnp.zeros((a, b))\ny = jnp.zeros((4, b))\nx_axes = {0: \"a\", 1: \"b\"}\ny_axes = {1: \"b\"}\nargs = (x, y)\nabstracted_axes = (x_axes, y_axes)\njax.make_jaxpr(f, abstracted_axes=abstracted_axes)(*args)\n```\n\n----------------------------------------\n\nTITLE: Executing QNode with Static and Dynamic Arguments\nDESCRIPTION: This example showcases the behavior of QNodes with static arguments. Changing the static argument `x` triggers plxpr reconstruction (indicated by the print statement), while changing the dynamic argument `y` does not. This illustrates the efficiency gained by avoiding unnecessary recompilation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_9\n\nLANGUAGE: pycon\nCODE:\n```\n>>> f(0.1, 0.2)\nI constructed plxpr\n0.97517043\n>>> f(0.1, 0.3)\n0.9505638\n>>> f(0.2, 0.3)\nI constructed plxpr\n0.93629336\n```\n\n----------------------------------------\n\nTITLE: Adding a Custom Decomposition Rule for CNOT in Python\nDESCRIPTION: This code demonstrates how to add a new decomposition rule for the CNOT gate in PennyLane using the `qml.add_decomps` function. It requires enabling the graph decomposition system, defining a quantum function representing the decomposition, and registering resource requirements using `qml.register_resources`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqml.decomposition.enable_graph()\n\n@qml.register_resources({qml.H: 2, qml.CZ: 1})\ndef my_cnot(wires):\n    qml.H(wires=wires[1])\n    qml.CZ(wires=wires)\n    qml.H(wires=wires[1])\n\nqml.add_decomps(qml.CNOT, my_cnot)\n```\n\n----------------------------------------\n\nTITLE: Adjoint Transform in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.adjoint` transform in PennyLane to apply the adjoint of an arbitrary sequence of operations.  It defines a subroutine and applies both the subroutine and its adjoint within a quantum circuit, using the transform to reverse the operations in the subroutine.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef subroutine(wire):\n    qml.RX(0.123, wires=wire)\n    qml.RY(0.456, wires=wire)\n\ndev = qml.device('default.qubit', wires=1)\n@qml.qnode(dev)\ndef circuit():\n    subroutine(0)\n    qml.adjoint(subroutine)(0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Defining a Batch Transform with @qml.batch_transform in PennyLane\nDESCRIPTION: Defines a batch transform using the `@qml.batch_transform` decorator. This transform generates two tapes: one with RX gates replaced by RY, and another with RX gates replaced by RZ.  It returns a processing function to sum the results of the two tapes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@qml.batch_transform\ndef my_transform(tape, a, b):\n    \"\"\"Generates two tapes, one with all RX replaced with RY,\n    and the other with all RX replaced with RZ.\"\"\"\n    tape1 = qml.tape.JacobianTape()\n    tape2 = qml.tape.JacobianTape()\n\n    # loop through all operations on the input tape\n    for op in tape.operations + tape.measurements:\n        if op.name == \"RX\":\n            with tape1:\n                qml.RY(a * qml.math.abs(op.parameters[0]), wires=op.wires)\n            with tape2:\n                qml.RZ(b * qml.math.abs(op.parameters[0]), wires=op.wires)\n        else:\n            for t in [tape1, tape2]:\n                with t:\n                    qml.apply(op)\n\n    def processing_fn(results):\n        return qml.math.sum(qml.math.stack(results))\n\n    return [tape1, tape2], processing_fn\n```\n\n----------------------------------------\n\nTITLE: Creating a Pauli Rotation Using Special Unitary in Pycon\nDESCRIPTION: This example demonstrates how to create a Pauli rotation using `qml.SpecialUnitary`. It defines parameters `theta` corresponding to a rotation around the X axis. It also defines an equivalent `qml.RX` gate and verifies that their matrix representations are approximately equal.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = 0.412\n>>> theta = x * np.array([1, 0, 0]) # The first entry belongs to the Pauli word \"X\"\n>>> su = qml.SpecialUnitary(theta, wires=0)\n>>> rx = qml.RX(-2 * x, 0) # RX introduces a prefactor -0.5 that has to be compensated\n>>> qml.math.allclose(qml.matrix(su), qml.matrix(rx))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Nested function capture with AutoGraph\nDESCRIPTION: This snippet demonstrates how AutoGraph handles nested functions. Both function `f` and `g` will be converted to use plxpr representation. The nested function `f` contains an `if` statement, and function `g` calls `f` within a `for` loop.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 5:\n        y = x ** 2\n    else:\n        y = x ** 3\n    return y\n\ndef g(x, n):\n    for i in range(n):\n        x = x + f(x)\n    return x\n```\n\n----------------------------------------\n\nTITLE: Defining PennyLane Operators\nDESCRIPTION: This code snippet demonstrates how to define PennyLane operators using `qml.PauliX`. It creates two operators, `op1` and `op2`, which are instances of `qml.PauliX` acting on wire 0, and then assigns `op1` to `op3`. This setup is used to illustrate the changes in equality comparison between PennyLane objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nop1 = qml.PauliX(0)\nop2 = qml.PauliX(0)\nop3 = op1\n```\n\n----------------------------------------\n\nTITLE: QNode Creation with Decorator (NumPy Interface)\nDESCRIPTION: This code demonstrates the creation of a QNode using the decorator syntax with the NumPy interface ('autograd'). It defines a quantum circuit with parameters and returns expectation values. The QNode accepts and returns NumPy arrays.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='autograd')\ndef circuit1(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n```\n\n----------------------------------------\n\nTITLE: Operator Decomposition in PennyLane\nDESCRIPTION: Demonstrates how to decompose a `qml.Rot` operator into a sequence of `qml.RZ` and `qml.RY` operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nop = qml.Rot(0.1, 0.2, 0.3, wires=[\"a\"])\nop.decomposition()\n```\n\n----------------------------------------\n\nTITLE: Calculating Unitary Matrix of a Basis Rotation Circuit\nDESCRIPTION: This snippet computes the unitary matrix of the quantum circuit defined in the previous snippet, which uses the `qml.BasisRotation` template. The output is rounded to three decimal places and normalized by dividing by the first element.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_24\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circ_unitary = qml.matrix(circuit)()\n>>> np.round(circ_unitary/circ_unitary[0][0], 3)\ntensor([[ 1.   -0.j   , -0.   +0.j   , -0.   +0.j   , -0.   +0.j   ],\n        [-0.   +0.j   , -0.516-0.596j, -0.302-0.536j, -0.   +0.j   ],\n        [-0.   +0.j   ,  0.35 +0.506j, -0.311-0.724j, -0.   +0.j   ],\n        [-0.   +0.j   , -0.   +0.j   , -0.   +0.j   , -0.438+0.899j]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Executing Custom Measurement in a QNode with PennyLane\nDESCRIPTION: This code demonstrates how to execute a custom measurement, specifically the `CountState` measurement defined earlier, within a PennyLane QNode. It sets up a quantum device, defines a quantum circuit that applies an RX gate, and then returns the custom measurement. The example illustrates the integration of custom measurements into quantum workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1, shots=10000)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return CountState(state=\"1\")\n```\n\n----------------------------------------\n\nTITLE: Mapping Wires in Device Class\nDESCRIPTION: This code snippet illustrates how to map custom wire labels to integers within a device class using the map_wires method. It demonstrates the translation of custom labels to consecutive integers by default.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# inside the class defining 'my.device', which inherits from the base Device class\ndevice_wires = self.map_wires(op.wires)\nprint(device_wires) # Wires([2, 0])\n```\n\n----------------------------------------\n\nTITLE: Operator with wires as last argument\nDESCRIPTION: This demonstrates the flexibility of passing wires as the final argument to the `S` and `CNOT` operators, instead of using the `wires` keyword. This allows a more concise and readable syntax when defining quantum operations. This snippet showcases how to initialize quantum gates with implicit wire specification.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_26\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.S(0)\nS(wires=[0])\n>>> qml.CNOT((0,1))\nCNOT(wires=[0, 1])\n```\n\n----------------------------------------\n\nTITLE: Drawing and Executing the `qml.for_loop` Circuit\nDESCRIPTION: This snippet first draws the quantum circuit using `qml.draw` with input values 0.5 and 3. Then it runs the circuit with the same input values and returns the probabilities. Finally, it jit-compiles the same function using `qml.qjit` and calls the jit-compiled version to run the circuit and returns the probability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_22\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)(0.5, 3))\n0: ──H──RX(0.50)─╭●────────╭●──────────────────────────────────────┤  Probs\n1: ──H───────────╰RY(0.25)─│──────────RX(0.48)─╭●──────────────────┤  Probs\n2: ──H─────────────────────╰RY(0.25)───────────╰RY(0.23)──RX(0.46)─┤  Probs\n>>> circuit(0.5, 3)\narray([0.125     , 0.125     , 0.09949758, 0.15050242, 0.07594666,\n       0.11917543, 0.08942104, 0.21545687])\n>>> qml.qjit(circuit)(0.5, 3)\nArray([0.125     , 0.125     , 0.09949758, 0.15050242, 0.07594666,\n       0.11917543, 0.08942104, 0.21545687], dtype=float64)\n```\n\n----------------------------------------\n\nTITLE: Setting Device Options with default.tensor in PennyLane\nDESCRIPTION: This snippet demonstrates how to set device-specific options for the 'default.tensor' device using keyword arguments during initialization and how to access these options through the `device_options` attribute of the execution configuration.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.tensor', wires=2, max_bond_dim=4, contract=\"nonlocal\", c_dtype=np.complex64)\ndev.setup_execution_config().device_options\n```\n\nLANGUAGE: python\nCODE:\n```\n{'contract': 'nonlocal',\n 'contraction_optimizer': 'auto-hq',\n 'cutoff': None,\n 'c_dtype': numpy.complex64,\n 'local_simplify': 'ADCRS',\n 'max_bond_dim': 4,\n 'method': 'mps'}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Operation as a Function in PennyLane\nDESCRIPTION: This code snippet demonstrates how a custom quantum operation, in this case, `FlipAndRotate`, can be defined as a standard Python function within a PennyLane circuit. It shows an alternative method to defining a custom gate as a class, which offers less functionality, but is sufficient for simple operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef FlipAndRotate(angle, wire_rot, wire_flip=None, do_flip=False):\n    if do_flip:\n        qml.PauliX(wires=wire_flip)\n    qml.RX(angle, wires=wire_rot)\n```\n\n----------------------------------------\n\nTITLE: Batch Embedding with @qml.batch_input in PennyLane\nDESCRIPTION: This code demonstrates the use of the `@qml.batch_input` transform to enable batching of non-trainable gate parameters in PennyLane. The example defines a quantum circuit with batched inputs and weights, utilizing `qml.AngleEmbedding` and `qml.RY` gates. It demonstrates how to define a QNode that accepts batched inputs.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=None)\n\n@qml.batch_input(argnum=0)\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\ndef circuit(inputs, weights):\n    # add a batch dimension to the embedding data\n    qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\n    qml.RY(weights[0], wires=0)\n    qml.RY(weights[1], wires=1)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Decorator Syntax Deprecation in PennyLane\nDESCRIPTION: This code demonstrates the deprecated decorator syntax for transforms in PennyLane. It showcases the previous method of applying transforms with keyword arguments directly above the `qml.qnode` decorator. This syntax will raise a warning, indicating the need to migrate to a different approach.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n@transform_fn(**transform_kwargs)\n@qml.qnode(dev)\ndef circuit():\n    ...\n```\n\n----------------------------------------\n\nTITLE: Workflow with Custom Primitive Output Shape\nDESCRIPTION: This code defines a workflow that uses the `prim3` primitive with the custom staging rule. It creates a jaxpr for this workflow, demonstrating that the output shape `f32[a,2]` depends on the input `a`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef workflow4(n):\n    return prim3.bind(n)\n\njax.make_jaxpr(workflow4)(2)\n```\n\n----------------------------------------\n\nTITLE: New Multi Dispatch Decorator Usage in PennyLane\nDESCRIPTION: This code demonstrates how to use the new `qml.math.multi_dispatch` decorator for defining functions within PennyLane that handle tensors. It indicates which arguments are tensors and are handled by the different interfaces such as Autograd, Torch, and Tensorflow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.math.multi_dispatch(argnum=[0, 1])\n... def some_function(tensor1, tensor2, option, like):\n...     # the interface string is stored in ``like``.\n...     ...\n```\n\n----------------------------------------\n\nTITLE: Initialize HF State with Parity Basis\nDESCRIPTION: Initializes the Hartree-Fock state with 2 active electrons and 6 orbitals, using the 'parity' basis. This example demonstrates how to define the initial state for quantum chemistry simulations in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> state_parity = qml.qchem.hf_state(2, 6, basis=\"parity\")\n>>> print(state_parity)\n[1 0 0 0 0 0]\n```\n\n----------------------------------------\n\nTITLE: Multiple Non-Commuting Observables in QNode Result\nDESCRIPTION: This demonstrates the output of the `circuit_rx` function that calculates expectation values of non-commuting observables PauliX and PauliY.  The returned result is a tensor of two expectation values. This showcases the ability to compute expectation values for multiple non-commuting observables within a single quantum node.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit_rx(0.1, 0.3)\ntensor([ 0.02950279, -0.09537451], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Using Custom Operators in a PennyLane QNode\nDESCRIPTION: This code demonstrates how to import and use a custom operator (CustomGate) within a PennyLane QNode.  It defines a quantum function my_qfunc that applies a Hadamard gate and the CustomGate to a qubit, then returns the expectation value of PauliZ. The CustomGate is assumed to be defined in MyModule.MySubModule.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom MyModule.MySubModule import CustomGate\n\n@qnode(dev1)\ndef my_qfunc(phi):\n    qml.Hadamard(wires=0)\n    CustomGate(phi, theta, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Defining a QNode with NewObservable in Python\nDESCRIPTION: This snippet defines a QNode that uses the custom `NewObservable` and the device supporting it. This showcases the ability to create differentiable observables that return custom objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndev = DeviceSupportingNewObservable(wires=1, shots=None)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef qnode(x):\n    qml.RY(x, wires=0)\n    return qml.expval(NewObservable(wires=0))\n```\n\n----------------------------------------\n\nTITLE: Simplifying Equivalent Operators in PennyLane\nDESCRIPTION: Demonstrates simplifying different operator structures to a common format and comparing them for equality using `qml.equal`. It shows how `op.simplify()` brings operators to the form :math:`\\sum_i c_i \\hat{O}_i`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> op1 = 0.5 * (X(0) @ X(1)) + 0.5 * (Y(0) @ Y(1))\n>>> op2 = (0.5 * X(0)) @ X(1) + (0.5 * Y(0)) @ Y(1))\n>>> op3 = 0.5 * (X(0) @ X(1) + Y(0) @ Y(1))\n>>> qml.equal(op1, op2), qml.equal(op2, op3), qml.equal(op3, op1)\n(True, False, False)\n\n>>> op1 = op1.simplify()\n>>> op2 = op2.simplify()\n>>> op3 = op3.simplify()\n>>> qml.equal(op1, op2), qml.equal(op2, op3), qml.equal(op3, op1)\n(True, True, True)\n\n>>> op1, op2, op3\n(0.5 * (X(1) @ X(0)) + 0.5 * (Y(1) @ Y(0)),\n 0.5 * (X(1) @ X(0)) + 0.5 * (Y(1) @ Y(0)),\n 0.5 * (X(1) @ X(0)) + 0.5 * (Y(1) @ Y(0)))\n```\n\n----------------------------------------\n\nTITLE: Quantum Arithmetic Operations using PennyLane\nDESCRIPTION: This snippet demonstrates the use of quantum arithmetic operations in PennyLane to perform the calculation (2 + 1) * 3 mod 7 = 2. It uses `qml.Adder` for in-place addition and `qml.OutMultiplier` for out-place multiplication within a quantum circuit. Requires PennyLane and a compatible device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", shots=1)\n\nwire_reg = qml.registers({\n    \"x_wires\": 2, # |x>: stores the result of 2 + 1 = 3\n    \"y_wires\": 2, # |y>: multiples x by 3\n    \"output_wires\": 3, # stores the result of (2 + 1) * 3 m 7 = 2\n    \"work_wires\": 2 # for qml.OutMultiplier\n})\n\n@qml.qnode(dev)\ndef circuit():\n    # In-place addition\n    qml.BasisEmbedding(2, wires=wire_reg[\"x_wires\"])\n    qml.Adder(1, x_wires=wire_reg[\"x_wires\"]) # add 1 to wires [0, 1] \n\n    # Out-place multiplication\n    qml.BasisEmbedding(3, wires=wire_reg[\"y_wires\"])\n    qml.OutMultiplier(\n        wire_reg[\"x_wires\"],\n        wire_reg[\"y_wires\"],\n        wire_reg[\"output_wires\"],\n        work_wires=wire_reg[\"work_wires\"],\n        mod=7\n    ) \n\n    return qml.sample(wires=wire_reg[\"output_wires\"])\n```\n\n----------------------------------------\n\nTITLE: Output of QubitCarry and QubitSum Operations in Python\nDESCRIPTION: This snippet displays the output of the quantum circuit that uses `QubitCarry` and `QubitSum` operations. The output is a tuple representing the 2-bit result of the addition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(output)\n(0, 1)\n```\n\n----------------------------------------\n\nTITLE: Computing Full Metric Tensor with PennyLane\nDESCRIPTION: This code snippet demonstrates how to compute the full metric tensor using the `qml.metric_tensor` transform in PennyLane. It defines a quantum circuit with RX, RY, CNOT, and RZ gates, and then computes the metric tensor using Hadamard tests, which requires an additional wire on the device. The `approx` keyword argument is used to specify whether to compute the full tensor or a block-diagonal approximation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.RX(weights[0], wires=0)\n    qml.RY(weights[1], wires=0)\n    qml.CNOT(wires=[0, 1])\n    qml.RZ(weights[2], wires=1)\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n\nweights = np.array([0.2, 1.2, -0.9], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Using the Shape-Matching HOP with Scalar Multiplication\nDESCRIPTION: This code uses the shape-matching HOP (`prim2`) to define a workflow that multiplies the input array by 2. The jaxpr generated shows that the input and output shapes are both `i32[a]`, ensuring that the shape is preserved across the HOP.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndef workflow3(x):\n    return bind_prim2(lambda x: 2*x, x)\n\njaxpr = jax.make_jaxpr(workflow3, abstracted_axes=(\"a\", ))(jax.numpy.array([1,2,3]))\njaxpr\n```\n\n----------------------------------------\n\nTITLE: In-place JAX Array Updates\nDESCRIPTION: This example demonstrates how to update array values in JAX using the `at` and `set` methods for in-place assignment. It iterates through the array and multiplies each element by 2.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_37\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    first_dim = x.shape[0]\n    result = jnp.empty((first_dim,), dtype=x.dtype)\n\n    for i in range(first_dim):\n        result = result.at[i].set(x[i] * 2)\n\n    return result\n```\n\nLANGUAGE: python\nCODE:\n```\nplxpr = make_plxpr(f)(jnp.zeros(3))\neval_jaxprF(plxpr.jaxpr, plxpr.consts, jnp.array([0.1, 0.2, 0.3]))\n```\n\n----------------------------------------\n\nTITLE: Creating Registers of Wires with qml.registers in Python\nDESCRIPTION: This snippet demonstrates how to create registers of wires using the `qml.registers` function in PennyLane. It showcases the creation of a simple wire register and a nested wire register. The resulting data structure is a dictionary with register names as keys and `qml.wires.Wires` instances as values, facilitating the organization of wires for quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> wire_reg = qml.registers({\"alice\": 4, \"bob\": 3})\n>>> wire_reg\n{'alice': Wires([0, 1, 2, 3]), 'bob': Wires([4, 5, 6])}\n```\n\n----------------------------------------\n\nTITLE: Initializing a PennyLane Device with Custom Wire Labels\nDESCRIPTION: This code initializes a PennyLane device with custom wire labels. Instead of using the default consecutive integer labels, an iterable (in this case, a list) containing unique labels is passed to the `wires` argument of the `qml.device` function. This allows addressing the wires using the specified labels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev_unique_wires = qml.device('default.qubit', wires=['aux', 'q1', 'q2'])\n```\n\n----------------------------------------\n\nTITLE: Returning Probabilities from Photonic QNodes\nDESCRIPTION: Shows how to return probabilities from photonic QNodes in PennyLane, making them end-to-end differentiable. The example uses the `strawberryfields.fock` device and returns the probabilities for a given circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"strawberryfields.fock\", wires=2, cutoff_dim=5)\n>>> @qml.qnode(dev)\n... def circuit(a):\n...     qml.Displacement(a, 0, wires=0)\n...     return qml.probs(wires=0)\n>>> print(circuit(0.5))\n[7.78800783e-01 1.94700196e-01 2.43375245e-02 2.02812704e-03 1.26757940e-04]\n```\n\n----------------------------------------\n\nTITLE: Drawing Transpiled Circuit\nDESCRIPTION: This code demonstrates how to draw the transpiled quantum circuit using `qml.draw`. It visualizes the compiled circuit after the transpilation process has been applied. It depends on the previously defined `circuit` function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(circuit)(0.3))\n```\n\n----------------------------------------\n\nTITLE: Old Operator Equality Behavior in PennyLane\nDESCRIPTION: This code demonstrates the old behavior of PennyLane operators' equality (`==`) comparison. Before the update, two operators created with the same data were considered unequal because their equality was based on their memory addresses. Assigning one operator to another resulted in equality because they pointed to the same memory location.  This code snippet uses the operators defined in the previous snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op1 == op2\nFalse\n>>> op1 == op3\nTrue\n```\n\n----------------------------------------\n\nTITLE: Creating Fermi Sentence from String-based Fermi Words in PennyLane\nDESCRIPTION: Shows how to create a Fermi sentence by linearly combining Fermi words that are created using `qml.fermi.from_string`. This example demonstrates the combination of two Fermi words with scalar coefficients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> word1 = qml.fermi.from_string('0+ 0- 3+ 3-')\n>>> word2 = qml.fermi.from_string('3+ 3-')\n>>> sentence = 1.2 * word1 + 0.345 * word2\n>>> sentence\n1.2 * a⁺(0) a(0) a⁺(3) a(3)\n+ 0.345 * a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: Decomposing with Rule-Based Gate Set (Python)\nDESCRIPTION: This snippet demonstrates decomposing a circuit based on a rule defined by a Boolean function that dictates which gates are allowed in the resulting circuit. Here, it decomposes into gates acting on one or two qubits. The `qml.transforms.decompose` transform is used with a lambda function defining the gate set.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@partial(qml.transforms.decompose, gate_set = lambda op: len(op.wires) <= 2)\n@qml.qnode(dev)\ndef circuit():\n    qml.Toffoli(wires=[0, 1, 2])\n    return qml.expval(qml.Z(0))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(circuit)())\n0: ───────────╭●───────────╭●────╭●──T──╭●─┤  <Z>\n1: ────╭●─────│─────╭●─────│───T─╰X──T†─╰X─┤     \n2: ──H─╰X──T†─╰X──T─╰X──T†─╰X──T──H────────┤\n```\n\n----------------------------------------\n\nTITLE: Reduced Density Matrix Calculation\nDESCRIPTION: This code shows how to calculate the reduced density matrix of a quantum state using PennyLane's `qml.qinfo.reduced_dm` function. A quantum circuit with an IsingXX gate is defined, and the reduced density matrix of wire 0 is calculated. The `qml.state()` measurement is used to get the statevector.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n@qml.qnode(dev)\ndef circuit(x):\n    qml.IsingXX(x, wires=[0,1])\n    return qml.state()\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.qinfo.reduced_dm(circuit, wires=[0])(np.pi/2)\n[[0.5+0.j 0.+0.j]\n [0.+0.j 0.5+0.j]]\n```\n\n----------------------------------------\n\nTITLE: Applying Custom Decompositions to Operations on Devices in PennyLane\nDESCRIPTION: This code demonstrates how to apply custom decompositions to quantum operations at the device level in PennyLane. It defines custom decompositions for the CNOT and Hadamard gates and passes them to a quantum device during initialization.  This custom decomposition will be used when running or drawing QNodes on that device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef custom_cnot(wires):\n    return [\n        qml.Hadamard(wires=wires[1]),\n        qml.CZ(wires=[wires[0], wires[1]]),\n        qml.Hadamard(wires=wires[1])\n    ]\n\ndef custom_hadamard(wires):\n    return [\n        qml.RZ(np.pi, wires=wires),\n        qml.RY(np.pi / 2, wires=wires)\n    ]\n\n# Can pass the operation itself, or a string\ncustom_decomps = {qml.CNOT : custom_cnot, \"Hadamard\" : custom_hadamard}\n\ndecomp_dev = qml.device(\"default.qubit\", wires=3, custom_decomps=custom_decomps)\ndecomp_qnode = qml.QNode(circuit, decomp_dev)\n```\n\n----------------------------------------\n\nTITLE: Operator Functions in PennyLane\nDESCRIPTION: This code demonstrates the use of operator functions in PennyLane to manipulate quantum operators. It creates a product of PauliX and PauliZ operators, adds a Hadamard operator, and multiplies the result by a scalar.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/operations.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nop = qml.prod(qml.PauliX(0), qml.PauliZ(1))\nop = qml.sum(qml.Hadamard(0), op)\nop = qml.s_prod(1.2, op)\nop\n```\n\n----------------------------------------\n\nTITLE: Integer Comparator Operation in PennyLane\nDESCRIPTION: Demonstrates the usage of the `qml.IntegerComparator` operation. It shows how to construct a quantum circuit that compares a basis state representing an integer with a fixed integer L and flips a target qubit based on the comparison result (n >= L or n < L).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.BasisState(np.array([0, 1]), wires=range(2))\n    qml.broadcast(qml.Hadamard, wires=range(2), pattern='single')\n```\n\n----------------------------------------\n\nTITLE: QNode Creation via Class Constructor with PyTorch Interface\nDESCRIPTION: This code shows how to create a PyTorch-compatible QNode using the `qml.QNode` class constructor with the `interface='torch'` argument. This approach allows for more explicit control over the QNode's creation and behavior, and ensures it operates specifically with PyTorch tensors.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev1 = qml.device('default.qubit', wires=2)\ndev2 = qml.device('default.mixed', wires=2)\n\ndef circuit1(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n\nqnode1 = qml.QNode(circuit1, dev1)\nqnode2 = qml.QNode(circuit1, dev2, interface='torch')\n```\n\n----------------------------------------\n\nTITLE: Creating a Special Unitary Operation in Pycon\nDESCRIPTION: This snippet demonstrates how to create a `qml.SpecialUnitary` operation with a given set of parameters. It initializes parameters `thetas` and creates the `SpecialUnitary` gate on wire 0. The matrix representation of the gate is then computed and displayed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> thetas = np.array([0.2, 0.1, -0.5])\n>>> U = qml.SpecialUnitary(thetas, 0)\n>>> qml.matrix(U)\narray([[ 0.8537127 -0.47537233j,  0.09507447+0.19014893j],\n       [-0.09507447+0.19014893j,  0.8537127 +0.47537233j]])\n```\n\n----------------------------------------\n\nTITLE: Grouping Operators with qml.dot\nDESCRIPTION: Illustrates how to use the `grouping_type` argument within the `qml.dot` function to specify operator grouping when constructing a linear combination.  It creates a linear combination of Pauli operators and assigns the grouping indices based on the specified grouping type ('qwc' in this instance).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\na = qml.X(0)\nb = qml.prod(qml.X(0), qml.X(1))\nc = qml.Z(0)\nobs = [a, b, c]\ncoeffs = [1.0, 2.0, 3.0]\n\nop = qml.dot(coeffs, obs, grouping_type=\"qwc\")\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> op.grouping_indices\n((2,), (0, 1))\n```\n\n----------------------------------------\n\nTITLE: Finite Shots Device Result Demonstration in PennyLane\nDESCRIPTION: This example shows the stochastic output obtained when executing a QNode on a device initialized with a finite number of shots (e.g., `shots=1000`). The output is an estimate of the expectation value based on sampling, leading to variations in the result across multiple runs.  It illustrates the inherent randomness introduced by using a finite number of shots in quantum simulations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit_finite_shots()\n-0.062\n>>> circuit_finite_shots()\n0.034\n```\n\n----------------------------------------\n\nTITLE: Estimating Resources with DoubleFactorization in PennyLane\nDESCRIPTION: This code snippet showcases how to use the `DoubleFactorization` class from the `qml.resource` module for estimating resources in second quantization simulations with a double-factorized Hamiltonian. It initializes a molecule, calculates electron integrals, and then uses the `DoubleFactorization` class to estimate the number of gates and qubits required. This requires the `numpy` and `pennylane` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"O\", \"H\", \"H\"]\ngeometry = np.array(\n    [\n        [0.00000000, 0.00000000, 0.28377432],\n        [0.00000000, 1.45278171, -1.00662237],\n        [0.00000000, -1.45278171, -1.00662237],\n    ],\n    requires_grad=False,\n)\n\nmol = qml.qchem.Molecule(symbols, geometry, basis_name=\"sto-3g\")\ncore, one, two = qml.qchem.electron_integrals(mol)()\n\nalgo = DoubleFactorization(one, two)\n```\n\n----------------------------------------\n\nTITLE: Using adjoint and pow for Operator Inversion in PennyLane\nDESCRIPTION: This code demonstrates the replacement of in-place operator inversion (`op.inv()` and `op.inverse=value`) with `qml.adjoint` and `qml.pow`.  It showcases the usage of `qml.adjoint` to compute the adjoint of an operator and `qml.pow` to raise an operator to a power, effectively achieving inversion in a non-in-place manner.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.adjoint(qml.PauliX(0))\nAdjoint(PauliX(wires=[0]))\n>>> qml.pow(qml.PauliX(0), -1)\nPauliX(wires=[0])**-1\n>>> qml.pow(qml.PauliX(0), -1, lazy=False)\nPauliX(wires=[0])\n>>> qml.PauliX(0) ** -1\nPauliX(wires=[0])**-1\n```\n\n----------------------------------------\n\nTITLE: Maintaining consistent variable type in conditional\nDESCRIPTION: This example addresses the issue in the previous snippet by ensuring that all branches of the `if` statement assign `y` with the same dtype (integer in this case). Even if the value in the else block remains conceptually the same, the dtype has to be consistent across the branches.  The else condition is modified to convert the float value to an int.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    y = -1.0\n    if x > 5:\n        y = 4\n    else:\n        y = -1\n    return y\n```\n\n----------------------------------------\n\nTITLE: New Operator Hashing Behavior in PennyLane\nDESCRIPTION: This code demonstrates the new behavior of hashing PennyLane operators. After the update, the hash of an operator is determined by its properties and attributes.  Therefore, two operators created with the same data will have the same hash, causing a set containing them to only store a single instance. This code snippet uses the operators defined in the first example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print({op1, op2})\n{PauliX(wires=[0])}\n```\n\n----------------------------------------\n\nTITLE: Reading Molecular Structure from File in PennyLane\nDESCRIPTION: This snippet demonstrates how to read the atomic structure of a molecule from an external file using the `read_structure` function. It takes the file path as an argument and returns the symbols and geometry of the molecule. It requires pennylane. The output consists of the symbols and the geometry of the molecule.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/chemistry.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nsymbols, geometry = qml.qchem.read_structure('h2.xyz')\n```\n\n----------------------------------------\n\nTITLE: PennyLane Circuit Drawing Output\nDESCRIPTION: This is the output when drawing the pennylane circuit. It visualizes the circuit including the gate operations and their assigned IDs.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n0: ──RX(0.12,\"data\")─┤  \n```\n\n----------------------------------------\n\nTITLE: QNode Creation with Constructor (NumPy Interface)\nDESCRIPTION: This snippet illustrates how to instantiate a QNode object directly using the QNode constructor with the default NumPy interface. It defines a quantum circuit and associates it with different devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev1 = qml.device('default.qubit', wires=2)\ndev2 = qml.device('forest.wavefunction', wires=2)\n\ndef circuit2(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n\nqnode1 = qml.QNode(circuit2, dev1)\nqnode2 = qml.QNode(circuit2, dev2)\n```\n\n----------------------------------------\n\nTITLE: Metric Tensor Transformation\nDESCRIPTION: Demonstrates how to use the qml.metric_tensor function to transform a QNode to produce the Fubini-Study metric tensor with autodifferentiation support. Example showcases the usage with the autograd interface.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev, interface=\"autograd\")\ndef circuit(weights):\n    # layer 1\n    qml.RX(weights[0, 0], wires=0)\n    qml.RX(weights[0, 1], wires=1)\n\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[1, 2])\n\n    # layer 2\n    qml.RZ(weights[1, 0], wires=0)\n    qml.RZ(weights[1, 1], wires=2)\n\n    qml.CNOT(wires=[0, 1])\n    qml.CNOT(wires=[1, 2])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1)), qml.expval(qml.PauliY(2))\n```\n\n----------------------------------------\n\nTITLE: Combining PennyLane Operators with Addition and Subtraction\nDESCRIPTION: This code shows how to combine PennyLane operators using the + and - operators. It constructs a sum_op by adding an RX gate, an RZ gate, and subtracting an RY gate, all acting on wire 0. The code then prints the resulting operator and computes its matrix representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> sum_op = qml.RX(phi=1.23, wires=0) + qml.RZ(phi=3.14, wires=0) - qml.RY(phi=0.12, wires=0)\n>>> sum_op\nRX(1.23, wires=[0]) + RZ(3.14, wires=[0]) + -1*(RY(0.12, wires=[0]))\n>>> qml.matrix(sum_op)\narray([[-0.18063077-0.99999968j,  0.05996401-0.57695852j],\n       [-0.05996401-0.57695852j, -0.18063077+0.99999968j]])\n```\n\n----------------------------------------\n\nTITLE: Collecting Statistics of Mid-Circuit Measurements in PennyLane (Python)\nDESCRIPTION: This code snippet demonstrates how to collect statistics of mid-circuit measurements along with terminal measurement statistics using `qml.probs`. It defines a quantum node that applies an RX gate to qubit 0, measures qubit 0, conditionally applies an RY gate to qubit 1 based on the measurement outcome, and then returns the probabilities of qubit 1 and the probabilities of the mid-circuit measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef func(x, y):\n    qml.RX(x, wires=0)\n    m_0 = qml.measure(0)\n    qml.cond(m_0, qml.RY)(y, wires=1)\n    return qml.probs(wires=1), qml.probs(op=m_0)\n```\n\n----------------------------------------\n\nTITLE: Grouping Hamiltonians in PennyLane\nDESCRIPTION: This example illustrates the updated method for grouping Hamiltonians in PennyLane, replacing the deprecated arguments in `qchem.molecular_hamiltonian()`. It shows how to construct a Hamiltonian and then create a new `qml.Hamiltonian` instance with the desired grouping type and method explicitly specified.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nH, qubits = molecular_hamiltonian(symbols, coordinates)\ngrouped_h = qml.Hamiltonian(\n        H.coeffs,\n        H.ops,\n        grouping_type=grouping_type,\n        groupingmethod=grouping_method,\n    )\n```\n\n----------------------------------------\n\nTITLE: Define a Qiskit QuantumCircuit\nDESCRIPTION: This code defines a simple quantum circuit using Qiskit's `QuantumCircuit` class. It creates a circuit with two qubits and one classical bit, applies a Hadamard gate to the first qubit, and then applies a CNOT gate with the first qubit as control and the second as target.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit import QuantumCircuit\n\nqk_circuit = QuantumCircuit(2, 1)\nqk_circuit.h(0)\nqk_circuit.cx(0, 1)\n```\n\n----------------------------------------\n\nTITLE: Cut Circuit with WireCut Operator\nDESCRIPTION: This code example demonstrates how to use the WireCut operator in PennyLane to cut a circuit. It positions a WireCut operator at a specific location in the circuit. This is combined with the qml.cut_circuit transform to enable circuit cutting functionality.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.cut_circuit\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    qml.RY(0.9, wires=1)\n    qml.RX(0.3, wires=2)\n\n    qml.CZ(wires=[0, 1])\n    qml.RY(-0.4, wires=0)\n\n    qml.WireCut(wires=1)\n\n    qml.CZ(wires=[1, 2])\n```\n\n----------------------------------------\n\nTITLE: Block Encoding Circuit Definition\nDESCRIPTION: This code defines a function to create a block-encoding circuit for a given operator A. It utilizes StatePrep to prepare a state based on the coefficients of the operator and Select to apply a unitary operation based on control wires. Dependencies: PennyLane, NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef block_encode(A, control_wires):\n    probs = A.coeffs / np.sum(A.coeffs)\n    state = np.pad(np.sqrt(probs, dtype=complex), (0, 1))\n    unitaries = A.ops\n\n    qml.StatePrep(state, wires=control_wires)\n    qml.Select(unitaries, control=control_wires)\n    qml.adjoint(qml.StatePrep)(state, wires=control_wires)\n```\n\n----------------------------------------\n\nTITLE: Converting QNode to ZX Diagram using PyZX in PennyLane\nDESCRIPTION: This code shows how to convert a PennyLane QNode into a ZX diagram using the PyZX framework. It defines a quantum circuit with various gates and then decorates it with `@qml.transforms.to_zx`. The decorated QNode, when executed, returns a PyZX graph representing the circuit in the ZX-calculus language.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.transforms.to_zx\n@qml.qnode(device=dev)\ndef circuit(p):\n    qml.RZ(p[0], wires=1),\n    qml.RZ(p[1], wires=1),\n    qml.RX(p[2], wires=0),\n    qml.PauliZ(wires=0),\n    qml.RZ(p[3], wires=1),\n    qml.PauliX(wires=1),\n    qml.CNOT(wires=[0, 1]),\n    qml.CNOT(wires=[1, 0]),\n    qml.SWAP(wires=[0, 1]),\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Computing Kernel Matrix with Batched Shots\nDESCRIPTION: This snippet demonstrates computing a kernel matrix using batched shots in PennyLane. It uses the qml.kernels.square_kernel_matrix function with a previously defined kernel function. X is a randomly generated set of feature vectors.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_17\n\nLANGUAGE: pycon\nCODE:\n```\n>>> X = np.random.random((4, 2))\n>>> qml.kernels.square_kernel_matrix(X, kernel)[:, 0]\ntensor([[[1.  , 0.86, 0.88, 0.92],\n         [0.86, 1.  , 0.75, 0.97],\n         [0.88, 0.75, 1.  , 0.91],\n         [0.92, 0.97, 0.91, 1.  ]],\n        [[1.  , 0.93, 0.91, 0.92],\n         [0.93, 1.  , 0.8 , 1.  ],\n         [0.91, 0.8 , 1.  , 0.91],\n         [0.92, 1.  , 0.91, 1.  ]]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: New Operator Equality Behavior in PennyLane\nDESCRIPTION: This code demonstrates the new behavior of PennyLane operators' equality (`==`) comparison. After the update, two operators created with the same data are considered equal because their equality is based on their content. Assigning one operator to another still results in equality because they point to the same object, but now content equality holds true for identically-defined operators as well. This code snippet uses the operators defined in the first example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op1 == op2\nTrue\n>>> op1 == op3\nTrue\n```\n\n----------------------------------------\n\nTITLE: Accessing Gate Parameter Frequencies in PennyLane\nDESCRIPTION: Demonstrates how to access the parameter frequencies of a quantum gate using the `parameter_frequencies` property.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.CRot(0.4, 0.1, 0.3, wires=[0, 1])\n>>> op.parameter_frequencies\n[(0.5, 1.0), (0.5, 1.0), (0.5, 1.0)]\n```\n\n----------------------------------------\n\nTITLE: Parameter Broadcasting with Quantum Chemistry Operations in PennyLane\nDESCRIPTION: This code demonstrates the use of parameter broadcasting with quantum chemistry operations in PennyLane.  A `SingleExcitation` operation is initialized with an array of parameters, and the shape of the resulting matrix is printed.  This can be useful for efficiently applying the same gate with different parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.SingleExcitation(np.array([0.3, 1.2, -0.7]), wires=[0, 1])\n>>> op.matrix().shape\n(3, 4, 4)\n```\n\n----------------------------------------\n\nTITLE: Flexible QNode Signatures\nDESCRIPTION: Shows an example of a QNode with positional, named, and variable keyword arguments. Demonstrates the flexibility in defining and calling QNodes similar to standard Python functions. Requires PennyLane and PyTorch.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nx = torch.tensor(0.1, requires_grad=True)\ny = torch.tensor([0.2, 0.3], requires_grad=True)\nz = torch.tensor(0.4, requires_grad=True)\n\n@qml.qnode(dev, interface=\"torch\")\ndef circuit(p1, p2=y, **kwargs):\n    qml.RX(p1, wires=0)\n    qml.RY(p2[0] * p2[1], wires=0)\n    qml.RX(kwargs[\"p3\"], wires=0)\n    return qml.var(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Quantum Phase Estimation Initialization (Python)\nDESCRIPTION: This snippet initializes parameters for a Quantum Phase Estimation (QPE) algorithm. `phase` is the phase to be estimated, `target_wires` specifies the qubit on which the unitary acts, `unitary` is the matrix representation of the unitary, `n_estimation_wires` is the number of qubits used to estimate the phase, and `estimation_wires` are the corresponding wire indices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nphase = 1.0\ntarget_wires = [0]\nunitary = qml.RX(phase, wires=0).matrix()\nn_estimation_wires = 1\nestimation_wires = range(1, n_estimation_wires + 1)\n\ndef qfunc():\n    qml.QuantumPhaseEstimation(\n        unitary,\n        target_wires=target_wires,\n        estimation_wires=estimation_wires,\n    )\n```\n\n----------------------------------------\n\nTITLE: Using BitFlip and PhaseFlip Error Channels\nDESCRIPTION: Shows how to use the new BitFlip and PhaseFlip error channels in PennyLane. These channels can be used similarly to existing error channels on mixed state devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.mixed\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.RX(0.3, wires=0)\n    qml.RY(0.5, wires=1)\n    qml.BitFlip(0.01, wires=0)\n    qml.PhaseFlip(0.01, wires=1)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Updating QNode settings in PennyLane\nDESCRIPTION: This example shows how to modify the settings of a `QNode` using the `update` method. The `update` method returns a new `QNode` with the specified settings changed, while retaining the original values for unspecified arguments. In this case, the `diff_method` is updated from 'best' to 'parameter-shift'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit.diff_method)\nbest\n>>> new_circuit = circuit.update(diff_method=\"parameter-shift\")\n>>> print(new_circuit.diff_method)\n'parameter-shift'\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit with PennyLane\nDESCRIPTION: This code defines a quantum circuit using PennyLane. It initializes a default qubit device with 2 wires, defines a quantum node that applies a series of PennyLane operators including PauliZ, RY, PauliX, and op_sum, and returns the expectation value of an observable composed of PauliX and PauliZ operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(angles):\n    qml.prod(qml.PauliZ(0), qml.RY(angles[0], 1))\n    qml.op_sum(qml.PauliX(1), qml.RY(angles[1], 0))\n\n    return qml.expval(qml.op_sum(qml.PauliX(0), qml.PauliZ(1)))\n```\n\n----------------------------------------\n\nTITLE: Inspecting Resource Requirements from Tracker Totals and History in PennyLane\nDESCRIPTION: Shows how to inspect the `tracker.totals` and `tracker.history` after using the `null.qubit` device to predict resource requirements.  This provides information about the number of executions, batches, and the detailed resource usage of the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> tracker.totals\n{'executions': 451, 'batches': 2, 'batch_len': 451}\n>>> tracker.history[\"resources\"][0]\nwires: 50\ngates: 200\ndepth: 77\nshots: Shots(total=None)\ngate_types:\n{'Rot': 100, 'CNOT': 100}\ngate_sizes:\n{1: 100, 2: 100}\n```\n\n----------------------------------------\n\nTITLE: Classical Jacobian Transform in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.transforms.classical_jacobian` transform in PennyLane to extract the Jacobian matrix of the classical part of a QNode. It defines a QNode and then uses the transform to compute the Jacobian, representing the classical dependence between QNode arguments and quantum gate arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circuit(weights):\n...     qml.RX(weights[0], wires=0)\n...     qml.RY(weights[0], wires=1)\n...     qml.RZ(weights[2] ** 2, wires=1)\n...     return qml.expval(qml.PauliZ(0))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> cjac_fn = qml.transforms.classical_jacobian(circuit)\n>>> weights = np.array([1., 1., 1.], requires_grad=True)\n>>> cjac = cjac_fn(weights)\n>>> print(cjac)\n[[1. 0. 0.]\n [1. 0. 0.]\n [0. 0. 2.]]\n```\n\n----------------------------------------\n\nTITLE: Using non-differentiable data with PennyLane QNodes and Autograd\nDESCRIPTION: This code snippet demonstrates how to use non-differentiable data with PennyLane QNodes when using the Autograd interface. It showcases setting the `requires_grad` property to `False` for non-differentiable data passed as QNode arguments or used within gates. This is essential for avoiding errors when using the new PennyLane core.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(weights, data):\n    basis_state = np.array([1, 0, 1, 1], requires_grad=False)\n    qml.BasisState(basis_state, wires=[0, 1, 2, 3])\n    qml.templates.AmplitudeEmbedding(data, wires=[0, 1, 2, 3])\n    qml.templates.BasicEntanglerLayers(weights, wires=[0, 1, 2, 3])\n    return qml.probs(wires=0)\n\ndata = np.array(data, requires_grad=False)\nweights = np.array(weights, requires_grad=True)\ncircuit(weights, data)\n```\n\n----------------------------------------\n\nTITLE: Calculate Jacobian with PyTorch in PennyLane\nDESCRIPTION: This code shows how to compute the Jacobian of a PennyLane quantum circuit using PyTorch's automatic differentiation. It takes two PyTorch tensors as input parameters and uses `torch.autograd.functional.jacobian` to calculate the Jacobian. Requires PennyLane, PyTorch, and a previously defined quantum circuit `circuit`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> a = torch.tensor(0.1, requires_grad=True)\n>>> b = torch.tensor(0.2, requires_grad=True)\n>>> torch.autograd.functional.jacobian(circuit, (a, b))\n((tensor(-0.0998), tensor(0.)), (tensor([-0.0494, -0.0005,  0.0005,  0.0494]), tensor([-0.0991,  0.0991,  0.0002, -0.0002])))\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fourier Coefficients with Panel Plot\nDESCRIPTION: This snippet demonstrates how to visualize Fourier coefficients using a panel plot on the complex plane. It creates a figure and a 5x5 grid of subplots using `plt.subplots`, sharing the x and y axes among the subplots. Then, it calls the `panel` function, passing the coefficients, degree (2), and the axes objects to generate the plot. It depends on matplotlib.pyplot and a function named `panel` which is probably part of the `pennylane.fourier.visualize` module.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n# Need a grid large enough to hold all coefficients up to frequency 2\nfig, ax = plt.subplots(5, 5, figsize=(12, 10), sharex=True, sharey=True)\npanel(coeffs, 2, ax)\n```\n\n----------------------------------------\n\nTITLE: PennyLane adjoint output\nDESCRIPTION: This code shows the result of the corrected adjoint application with AngleEmbedding. The result is a state vector as specified in the circuit_correct function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit_correct(params)\n[ 0.47415988+0.j          0.         0.73846026j  0.         0.25903472j\n -0.40342268+0.j        ]\n```\n\n----------------------------------------\n\nTITLE: Implement Repeat Primitive\nDESCRIPTION: Implements the evaluation rule for the `repeat` primitive.  It unpacks consts and arguments, then it uses `jax.core.eval_jaxpr` to execute the jaxpr repeatedly.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@repeat_prim.def_impl\ndef _(n, *args, jaxpr, n_consts):\n    consts = args[:n_consts]\n    args = args[n_consts:]\n    for _ in range(n):\n        args = jax.core.eval_jaxpr(jaxpr, consts, *args)\n    return args\n```\n\n----------------------------------------\n\nTITLE: Python Console Syntax for Code Examples\nDESCRIPTION: These examples showcase how to use Python console syntax in docstrings for single-line and multi-line statements. This ensures examples are copy-paste ready, allowing users to reproduce the results. Note that PennyLane is assumed to be imported as 'qml' and NumPy as 'np'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(0.5, 0.1)\n[0.43241234312, -0.543534534]\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=1)\n>>> @qml.qnode(dev)\n>>> def circuit(x):\n...     qml.RX(x, wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> circuit(0.5)\n0.8775825618903726\n```\n\n----------------------------------------\n\nTITLE: Trainable Parameter Specification via argnum in PennyLane\nDESCRIPTION: This code demonstrates an alternative method for indicating trainability using the `argnum` keyword in the `qml.grad` function. This method allows you to specify which arguments of the QNode should be considered trainable without requiring `requires_grad=True`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2))\ndef circuit(hyperparam, param):\n  ...\n\nx = np.array([0.1, 0.2])\nqml.grad(circuit, argnum=1)(0.5, x)\n```\n\n----------------------------------------\n\nTITLE: Workaround for Decompose transform with fixed parameter\nDESCRIPTION: Presents a workaround for the decompose transform issue by passing the problematic parameter (ratio_imprim) as a non-traced constant, resolving the error when using program capture and the decompose transform. Requires the pennylane and jax.numpy libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \nimport jax.numpy as jnp\n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.transforms.decompose\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.RandomLayers(weights, wires=[0, 1], ratio_imprim=0.5)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Device Tracker Update (execute)\nDESCRIPTION: This code snippet shows how to update the device tracker in the execute method. It updates the tracker with the number of executions and shots.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nif self.tracker.active:\n    self.tracker.update(executions=1, shots=self._shots)\n    self.tracker.record()\n```\n\n----------------------------------------\n\nTITLE: Custom Boolean Function for RX Gate - Python\nDESCRIPTION: This code demonstrates how to create a custom Boolean function using the `@qml.BooleanFn` decorator to identify an `qml.RX` gate with a maximum parameter value less than 1.0. It shows how to define custom conditions for applying noise based on gate parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_noise.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@qml.BooleanFn\ndef rx_condition(op, **metadata):\n    return isinstance(op, qml.RX) and op.parameters[0] < 1.0\n```\n\n----------------------------------------\n\nTITLE: Transforming Quantum Functions with broadcast_expand\nDESCRIPTION: This example illustrates how to use the `qml.transforms.broadcast_expand` transform to automatically expand quantum functions with batched parameters into multiple quantum evaluations without parameter broadcasting. A quantum node is defined, decorated with `broadcast_expand`, and then drawn to visualize the expanded circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=1)\n>>> @qml.transforms.broadcast_expand()\n>>> @qml.qnode(dev)\n... def circuit_rx(x, z):\n...     qml.RX(x, wires=0)\n...     qml.RZ(z, wires=0)\n...     qml.RY(0.3, wires=0)\n...     return qml.probs(wires=0)\n>>> print(qml.draw(circuit_rx)([0.1, 0.2], [0.3, 0.4]))\n0: ──RX(0.10)──RZ(0.30)──RY(0.30)─┤  Probs\n\\\n0: ──RX(0.20)──RZ(0.40)──RY(0.30)─┤  Probs\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Grouping with qwc\nDESCRIPTION: This snippet shows how to create a PennyLane Hamiltonian with a specified grouping type ('qwc' for quantum weight correlation). This grouping can be accessed by the device for optimized computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nobs = [qml.PauliX(0), qml.PauliX(1), qml.PauliZ(0)]\ncoeffs = np.array([1., 2., 3.])\nH = qml.Hamiltonian(coeffs, obs, grouping_type='qwc')\n```\n\n----------------------------------------\n\nTITLE: Debugging a Quantum Circuit with Breakpoints in PennyLane\nDESCRIPTION: This code demonstrates how to use `qml.breakpoint` to pause the execution of a quantum circuit and enter an interactive debugging prompt. It requires the `pennylane` library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_debugging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\n@qml.qnode(qml.device('default.qubit', wires=(0,1,2)))\ndef circuit(x):\n    qml.breakpoint()\n\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=(0,2))\n\n    for w in (0, 1, 2):\n        qml.RX(2*x, wires=w)\n\n    qml.breakpoint()\n    qml.RX(-x, wires=1)\n    return qml.sample()\n\ncircuit(1.2345)\n```\n\n----------------------------------------\n\nTITLE: Constructing Pairwise Commutation DAG in PennyLane\nDESCRIPTION: Demonstrates how to construct a pairwise-commutation directed acyclic graph (DAG) representation of a quantum circuit using `qml.commutation_dag`. This represents non-commutation between operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> def circuit(x, y, z):\n...     qml.RX(x, wires=0)\n...     qml.RX(y, wires=0)\n...     qml.CNOT(wires=[1, 2])\n...     qml.RY(y, wires=1)\n...     qml.Hadamard(wires=2)\n...     qml.CRZ(z, wires=[2, 0])\n...     qml.RY(-y, wires=1)\n...     return qml.expval(qml.PauliZ(0))\n>>> dag_fn = qml.commutation_dag(circuit)\n>>> dag = dag_fn(np.pi / 4, np.pi / 3, np.pi / 2)\n```\n\n----------------------------------------\n\nTITLE: Nested Function AutoGraph Conversion\nDESCRIPTION: This example highlights the lazy conversion of nested functions in AutoGraph. The inner function `f` is not converted until the outer function `g` is traced. The example demonstrates how to force the conversion of the nested function by tracing the output of `make_plxpr(g)` with values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_34\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 5:\n        y = x ** 2\n    else:\n        y = x ** 3\n    return y\n\ndef g(x, n):\n    for i in range(n):\n        x = x + f(x)\n    return x\n\nag_fn = make_plxpr(g)\n```\n\nLANGUAGE: python\nCODE:\n```\nplxpr = ag_fn(0, 0)\nautograph_source(f)\n```\n\n----------------------------------------\n\nTITLE: Building a Hybrid Quantum-Classical Model in Keras\nDESCRIPTION: This snippet shows how to construct a hybrid quantum model using a Keras Sequential model, incorporating the PennyLane QNode converted into a Keras layer. It requires PennyLane and TensorFlow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmodel = tf.keras.models.Sequential([qlayer, tf.keras.layers.Dense(2)])\n```\n\n----------------------------------------\n\nTITLE: Quantum Gradient with Adjoint Method\nDESCRIPTION: Shows how to use the adjoint differentiation method in PennyLane for faster quantum gradients. This method operates by iteratively applying inverse gates to scan backwards through the circuit. It is compatible with statevector-based devices like default.qubit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nwires = 1\ndevice = qml.device(\"default.qubit\", wires=wires)\n\n@qml.qnode(device, diff_method=\"adjoint\")\ndef f(params):\n    qml.RX(0.1, wires=0)\n    qml.Rot(*params, wires=0)\n    qml.RX(-0.3, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nparams = [0.1, 0.2, 0.3]\nqml.grad(f)(params)\n```\n\n----------------------------------------\n\nTITLE: Gradient Computation with Circuit Cutting\nDESCRIPTION: Shows how to compute the gradient of a quantum circuit that has been cut, using PennyLane's automatic differentiation capabilities. The example demonstrates that circuit cutting is compatible with differentiable computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nqml.grad(circuit)(x)\n```\n\n----------------------------------------\n\nTITLE: PennyLane: Mid-circuit measurements with default.qubit\nDESCRIPTION: This snippet demonstrates how to perform mid-circuit measurements (MCMs) on the `default.qubit` device in PennyLane. It showcases the efficiency of simulating MCMs in finite-shots mode, similar to how it is done on quantum hardware, where each measurement collapses the circuit state. Device 'dev' must be defined and shots specified beforehand.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\", shots=10)\n\n@qml.qnode(dev)\ndef f():\n    for i in range(1967):\n        qml.Hadamard(0)\n        qml.measure(0)\n    return qml.sample(qml.PauliX(0))\n```\n\n----------------------------------------\n\nTITLE: Initialize device and define QNode with for loop\nDESCRIPTION: This code defines a quantum device and a quantum node (QNode) using PennyLane. The QNode contains a for loop that applies a RY gate to a qubit multiple times, with the angle depending on the loop variable. It then returns the expectation value of the PauliZ operator on the qubit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef f():\n    for x in jnp.array([0, 1, 2]):\n        qml.RY(x * jnp.pi / 4, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: PennyLane Hessian Output\nDESCRIPTION: This shows the expected output of the Hessian computation using the previous python code snippet. The output is a tensor of shape (2,2) with the second order derivatives.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> hessian\ntensor([[-0.97517033,  0.01983384],\n        [ 0.01983384, -0.97517033]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Prepare Cosine Window State in PennyLane\nDESCRIPTION: This code demonstrates the use of `CosineWindow` operator in PennyLane to prepare an initial state based on a cosine wave function. The `CosineWindow` operator is used to prepare a state whose amplitudes follow a cosinusoidal distribution over the computational basis. The example uses `matplotlib` to visualize the prepared state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport matplotlib.pyplot as plt\n\ndev = qml.device('default.qubit', wires=4)\n\n@qml.qnode(dev)\ndef example_circuit():\n      qml.CosineWindow(wires=range(4))\n      return qml.state()\noutput = example_circuit()\n\nplt.style.use(\"pennylane.drawer.plot\")\nplt.bar(range(len(output)), output)\nplt.show()\n```\n\n----------------------------------------\n\nTITLE: Drawing Custom Compiled Quantum Circuit (Pycon)\nDESCRIPTION: Illustrates how to draw the compiled quantum circuit using `qml.draw` after applying a custom compilation pipeline. The output shows the optimized circuit structure based on the specified transforms. Requires PennyLane installation and a compiled quantum function with a custom pipeline.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(qfunc)(0.2, 0.3, 0.4))\n 0: ──H───RX(0.4)──RX(0.2)────────────────────────────┤ ⟨Z⟩\n 1: ──H──╭X───────────────────────────────────────╭C──┤\n 2: ──H──╰C────────RZ(0.4)──RZ(-0.4)──RX(0.3)──Y──╰Z──┤\n```\n\n----------------------------------------\n\nTITLE: Program Capture with Catalyst Integration\nDESCRIPTION: This example showcases the integration of program capture with Catalyst. It defines a QNode that applies an RX gate and returns the state of the qubit. The qml.qjit decorator from Catalyst is used to compile the QNode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\n\nqml.capture.enable()\n\n\ndev = qml.device('lightning.qubit', wires=1)\n\n\n@qml.qjit\n\n@qml.qnode(dev)\n\ndef circuit():\n\n    qml.RX(0.1, wires=0)\n\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Hamiltonian Displacement for Ground State Energy in PennyLane\nDESCRIPTION: This snippet shows how to displace a Hamiltonian such that its ground state energy is zero. It computes the minimum eigenvalue of the Hamiltonian and subtracts it from the Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> H = H - np.min(np.linalg.eigvalsh(H.to_mat()))\n```\n\n----------------------------------------\n\nTITLE: Using qml.Hamiltonian in PennyLane\nDESCRIPTION: This snippet demonstrates the use of qml.Hamiltonian, which now dispatches to LinearCombination and offers the same usage and functionality with different implementation details after the removal of the original Hamiltonian class.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n>>> from pennylane import X\n>>> H = qml.Hamiltonian([0.5, 0.5], [X(0), X(1)])\n>>> type(H)\npennylane.ops.op_math.linear_combination.LinearCombination\n```\n\n----------------------------------------\n\nTITLE: Constructing a Hybrid Quantum-Classical Model with Torch\nDESCRIPTION: This code demonstrates the construction of a hybrid quantum-classical model using PyTorch. It assumes that a PennyLane QNode has already been converted into a Torch layer. The snippet shows how to integrate this quantum layer into a sequential model composed of both quantum and classical layers using `torch.nn.Sequential`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.10.0.md#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n>>> model = torch.nn.Sequential(qlayer, torch.nn.Linear(2, 2))\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit with Integer Comparator in PennyLane\nDESCRIPTION: This Python code defines a quantum circuit using PennyLane that includes an integer comparator. It checks if the integer represented by qubits [0, 1] is greater than or equal to 2. The return value is the state of the qubits after the computation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nqml.IntegerComparator(2, geq=False, wires=[0, 1])\nreturn qml.state()\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Gradient Transforms\nDESCRIPTION: This snippet outlines the structure for defining custom quantum gradient transforms in PennyLane using the `@qml.gradients.gradient_transform` decorator. It highlights that the transform must return gradient tapes and a processing function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@qml.gradients.gradient_transform\ndef my_custom_gradient(tape, argnum=None, **kwargs):\n    ...\n    return gradient_tapes, processing_fn\n```\n\n----------------------------------------\n\nTITLE: Loading Quantum Circuits from QASM Files in PennyLane (Deprecated)\nDESCRIPTION: This code demonstrates the deprecated method of loading a quantum circuit from a QASM file using `qml.from_qasm_file`. The recommended approach now involves reading the file content and using `qml.from_qasm`. This snippet shows the suggested replacement, opening the file in read mode and then parsing its contents using `qml.from_qasm`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nwith open(\"test.qasm\", \"r\") as f:\n    circuit = qml.from_qasm(f.read())\n```\n\n----------------------------------------\n\nTITLE: Using set_decomposition Context Manager in PennyLane\nDESCRIPTION: This code shows how to use `qml.transforms.set_decomposition` as a context manager in PennyLane to apply custom decompositions to devices that already exist. Inside the `with` block, the custom decompositions are temporarily applied to the specified device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nwith qml.transforms.set_decomposition(custom_decomps, original_dev):\n    print(qml.draw(original_qnode, expansion_strategy=\"device\")(weights))\n```\n\n----------------------------------------\n\nTITLE: Simplifying Nested Operators with qml.simplify in PennyLane\nDESCRIPTION: This example demonstrates how to simplify a nested operator expression using `qml.simplify`. The nested operator involves sums and products of PennyLane operators. The simplification process includes removing nested products, transforming the product of sums into a sum of products, and grouping like terms in the resulting products. This illustrates the function's ability to handle complex operator structures.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> sum_op = qml.RX(1, 0) + qml.X(0)\n>>> prod1 = qml.X(0) @ sum_op\n>>> nested_op = qml.prod(prod1, qml.RX(1, 0))\n>>> qml.simplify(nested_op)\n(X(0) @ RX(2.0, wires=[0])) + RX(1.0, wires=[0])\n```\n\n----------------------------------------\n\nTITLE: Drawing Decomposed Quantum Circuits in PennyLane\nDESCRIPTION: This code snippet demonstrates how to draw quantum circuits that have been decomposed using PennyLane's drawing functionalities. It uses `qml.draw` to visualize the circuits after one and two levels of decomposition, showcasing the effect of different decomposition levels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(decompose_once)())\n0: ────╭U(M0)¹───────┤  \n1: ──H─╰●───────QFT†─┤  \nM0 = \n[[0.87758256+0.j         0.        -0.47942554j]\n [0.        -0.47942554j 0.87758256+0.j        ]]\n>>> print(qml.draw(decompose_twice)())\n0: ──RZ(1.57)──RY(0.50)─╭X──RY(-0.50)──RZ(-6.28)─╭X──RZ(4.71)─┤  \n1: ──H──────────────────╰●───────────────────────╰●──H†───────┤\n```\n\n----------------------------------------\n\nTITLE: While loop with temporary variable\nDESCRIPTION: This code defines a function `f` that includes a temporary variable `c` inside a `while` loop. The input variable `x` is incremented by a value derived from `c` in each iteration. It illustrates the usage of a temporary variable within the loop's scope that are not passed to any functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    while x < 5:\n        c = \"hi\"\n        x = x + 2 * len(c)\n    return x\n```\n\n----------------------------------------\n\nTITLE: Incompatible type assignments in conditional\nDESCRIPTION: This example shows the error that occurs when assigning a non-JAX-compatible type (string) to a variable within an `if` statement. JAX does not support string types, leading to a `TypeError`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 5:\n        y = \"a\"\n    else:\n        y = \"b\"\n    return y\n```\n\n----------------------------------------\n\nTITLE: TOML Configuration Example\nDESCRIPTION: This TOML snippet is a subsection of the full configuration file, detailing the setup of formatters, filters, handlers, and loggers to control logging behavior. It includes examples for defining a default formatter, applying filters based on process ID or debug level, creating stream and file handlers, and configuring loggers for JAX and PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/logging.rst#_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n###############################################################################\n# Avoid interfering with existing loggers in dependent libraries\n###############################################################################\n\ndisable_existing_loggers = false\nversion = 1\n\n###############################################################################\n# Bind formatters defined locally and those defined in pennylane.logging\n###############################################################################\n\n[formatters]\n[formatters.qml_default_formatter]\n\"()\" = \"pennylane.logging.formatters.formatter.DefaultFormatter\"\n\n[formatters.qml_alt_formatter]\n\"()\" = \"pennylane.logging.formatters.formatter.AnotherLogFormatter\"\n\n[formatters.local_detailed]\nformat = \"\\u001B[38;2;45;145;210m[%(asctime)s][%(levelname)s][<PID %(process)d:%(processName)s>] - %(name)s.%(funcName)s()::\\\"%(message)s\\\"\\u001B[0m\"\n\n[formatters.local_standard]\nformat = \"[%(asctime)s] - %(name)s - %(levelname)s - %(message)s\"\n\n\n###############################################################################\n# Bind LogRecord filters defined in pennylane.logging module\n###############################################################################\n\n[filters]\n# Filter to show messages from the same local process as the Python script\n[filters.qml_LocalProcessFilter]\n\"()\" = \"pennylane.logging.filter.LocalProcessFilter\"\n\n# Filter to show debug level messages only\n[filters.qml_DebugOnlyFilter]\n\"()\" = \"pennylane.logging.filter.DebugOnlyFilter\"\n\n###############################################################################\n# Bind handlers defined in the logging and in pennylane.logging modules\n###############################################################################\n\n[handlers]\n[handlers.qml_debug_stream]\nclass = \"logging.StreamHandler\"\nformatter = \"qml_default_formatter\"\nlevel = \"DEBUG\"\nstream = \"ext://sys.stdout\"\n\n[handlers.qml_debug_stream_alt]\nclass = \"logging.StreamHandler\"\nformatter = \"qml_alt_formatter\"\nlevel = \"DEBUG\"\nstream = \"ext://sys.stdout\"\n\n[handlers.qml_debug_file]\nclass = \"logging.handlers.RotatingFileHandler\"\nformatter = \"local_standard\"\nlevel = \"DEBUG\"\nfilename ='qml_debug.log' # use `/tmp/filename.log` on Linux machines to avoid long-term persistence\nmaxBytes = 16777216 # 16MB per file before splitting\nbackupCount = 10 # Create 'qml_debug.log.1', ... 'qml_debug.log.backupCount' files and rollover when maxBytes is reached\n\n[handlers.local_filtered_detailed_stdout]\nclass = \"logging.StreamHandler\"\nformatter = \"local_standard\"\nlevel = \"DEBUG\"\nstream = \"ext://sys.stdout\"\nfilters = [\"qml_LocalProcessFilter\", \"qml_DebugOnlyFilter\"]\n\n###############################################################################\n# Define logger controls for internal and external packages\n###############################################################################\n\n[loggers]\n\n# Control JAX logging \n[loggers.jax]\nhandlers = [\"qml_debug_stream\",]\nlevel = \"WARN\"\npropagate = false\n\n# Control logging across pennylane\n[loggers.pennylane]\nhandlers = [\"qml_debug_stream\",]\n```\n\n----------------------------------------\n\nTITLE: Using Tapered Operations within a QNode\nDESCRIPTION: Illustrates how a tapered operation, obtained via `qml.qchem.taper_operation`, can be directly incorporated and used within a PennyLane QNode for quantum circuit simulations. The example involves defining a circuit with the tapered operation and measuring an expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=[0, 1])\n>>> @qml.qnode(dev)\n... def circuit(params):\n...     tap_op(params[0])\n...     return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n>>> drawer = qml.draw(circuit, show_all_wires=True)\n>>> print(drawer(params=[3.14159]))\n0: ──Exp(0.00+1.57j Y)─┤ ╭<Z@Z>\n1: ────────────────────┤ ╰<Z@Z>\n```\n\n----------------------------------------\n\nTITLE: Device Initialization\nDESCRIPTION: Demonstrates the qml.device function to initialize a specified device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\ndev1 = qml.device(short_name, wires=2)\n```\n\n----------------------------------------\n\nTITLE: Accessing Terms of Composite Operators\nDESCRIPTION: This code shows how to access the coefficients and operators that make up composite operators formed via Sum or Prod using the terms() method. This feature is akin to accessing the terms of a Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.operation.enable_new_opmath()\n>>> op = X(0) @ (0.5 * X(1) + X(2))\n>>> op.terms()\n([0.5, 1.0],\n [X(1) @ X(0),\n  X(2) @ X(0)])\n```\n\n----------------------------------------\n\nTITLE: Implementing Tree Tensor Network (TTN) Template\nDESCRIPTION: Demonstrates implementing a quantum circuit using a Tree Tensor Network (TTN) template in PennyLane. It defines a block function, specifies the number of wires and block wires, calculates the number of blocks, creates a device, and defines a quantum node (QNode) employing the qml.TTN template. Dependencies include NumPy and PennyLane's core modules.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef block(weights, wires):\n    qml.CNOT(wires=[wires[0], wires[1]])\n    qml.RY(weights[0], wires=wires[0])\n    qml.RY(weights[1], wires=wires[1])\n\nn_wires = 4\nn_block_wires = 2\nn_params_block = 2\nn_blocks = qml.MPS.get_n_blocks(range(n_wires), n_block_wires)\ntemplate_weights = [[0.1, -0.3]] * n_blocks\n\ndev = qml.device(\"default.qubit\", wires=range(n_wires))\n\n@qml.qnode(dev)\ndef circuit(template_weights):\n    qml.TTN(range(n_wires), n_block_wires, block, n_params_block, template_weights)\n    return qml.expval(qml.PauliZ(wires=n_wires - 1))\n```\n\n----------------------------------------\n\nTITLE: State Gradient with Scalar Cost in PennyLane (Autograd)\nDESCRIPTION: This code demonstrates the use of a scalar cost function dependent on the output state to allow autodifferentiation frameworks to backpropagate through them. It defines a quantum circuit, obtains its state, and then calculates a cost based on the state's elements, allowing for successful gradient computation using qml.grad and Autograd.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef state_scalar_grad():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.state()\n\n    def cost_fn(x):\n        out = circuit(x)\n        return np.abs(out[0])\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(cost_fn)(x))\n```\n\n----------------------------------------\n\nTITLE: Collecting Statistics with Arithmetic/Boolean Operators on Mid-Circuit Measurements (Python)\nDESCRIPTION: This code demonstrates collecting statistics of mid-circuit measurements using arithmetic and boolean operators.  It defines a quantum circuit that applies RX and RY rotations, measures both qubits, and returns samples based on the expression `~m_0 - 2 * m_1`, where `m_0` and `m_1` are the measurement results.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit(phi, theta):\n    qml.RX(phi, wires=0)\n    m_0 = qml.measure(wires=0)\n    qml.RY(theta, wires=1)\n    m_1 = qml.measure(wires=1)\n    return qml.sample(~m_0 - 2 * m_1)\n```\n\n----------------------------------------\n\nTITLE: CUDA support with PennyLane and PyTorch\nDESCRIPTION: This snippet demonstrates how to use CUDA for faster execution of PennyLane circuits interfaced with PyTorch. Moving the input parameters to a CUDA device (`torch.device('cuda')`) and ensuring the `diff_method` is set to \"backprop\" will trigger execution on the GPU, which can significantly improve performance for circuits with a large number of wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 20\nn_layers = 10\n\ndev = qml.device('default.qubit', wires=n_wires)\n\nparams_shape = qml.StronglyEntanglingLayers.shape(n_layers=n_layers, n_wires=n_wires)\nparams = torch.rand(params_shape)\n\n@qml.qnode(dev, interface='torch', diff_method=\"backprop\")\ndef circuit_cuda(params):\n    qml.StronglyEntanglingLayers(params, wires=range(n_wires))\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Solving MaxCut Problem with QAOA in PennyLane\nDESCRIPTION: Demonstrates how to construct and solve a MaxCut problem using the QAOA functionality in PennyLane. The code defines a graph, constructs the cost and mixer Hamiltonians using `qml.qaoa.maxcut`, and sets up a quantum circuit with QAOA layers.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nwires = range(3)\ngraph = Graph([(0, 1), (1, 2), (2, 0)])\ncost_h, mixer_h = qaoa.maxcut(graph)\n\ndef qaoa_layer(gamma, alpha):\n    qaoa.cost_layer(gamma, cost_h)\n    qaoa.mixer_layer(alpha, mixer_h)\n\ndef antatz(params, **kwargs):\n\n    for w in wires:\n        qml.Hadamard(wires=w)\n\n    # repeat the QAOA layer two times\n    qml.layer(qaoa_layer, 2, params[0], params[1])\n\ndev = qml.device('default.qubit', wires=len(wires))\ncost_function = qml.VQECost(ansatz, cost_h, dev)\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit for Relative Entropy Calculation\nDESCRIPTION: This code defines a quantum circuit for calculating relative entropy. It initializes a default qubit device with 2 wires and defines a quantum node that applies a `RY` gate and a `CNOT` gate, returning the state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(param):\n    qml.RY(param, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Drawing a Quantum Circuit with PennyLane's Text-Based Drawer\nDESCRIPTION: Shows how to draw a quantum circuit using `qml.draw` with customizable options for decimals and matrix display.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('lightning.qubit', wires=2))\ndef circuit(a, w):\n    qml.Hadamard(0)\n    qml.CRX(a, wires=[0, 1])\n    qml.Rot(*w, wires=[1])\n    qml.CRX(-a, wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit, decimals=2)(a=2.3, w=[1.2, 3.2, 0.7]))\n0: ──H─╭C─────────────────────────────╭C─────────┤ ╭<Z@Z>\n1: ────╰RX(2.30)──Rot(1.20,3.20,0.70)─╰RX(-2.30)─┤ ╰<Z@Z>\n```\n\n----------------------------------------\n\nTITLE: Compute Hessian on Hardware with PennyLane\nDESCRIPTION: This code demonstrates how to compute the Hessian of a QNode on hardware using the `qml.gradients.param_shift_hessian` transform. It defines a quantum circuit and then calculates the Hessian with respect to the input parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nx = np.array([0.1, 0.2], requires_grad=True)\n\nhessian = qml.gradients.param_shift_hessian(circuit)(x)\n```\n\n----------------------------------------\n\nTITLE: Abstract Value Definition for JAX Primitives\nDESCRIPTION: Defines a custom abstract value `AbstractPrimitiveClass` for JAX primitives. This allows JAX to represent the abstract type of the custom class more accurately during tracing and abstract evaluation. The `raise_to_shaped_mappings` is updated to handle this new abstract type.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nclass AbstractPrimitiveClass(jax.core.AbstractValue):\n\n    def __eq__(self, other):\n        return isinstance(other, AbstractPrimitiveClass)\n\n    def __hash__(self):\n        return hash(\"AbstractPrimitiveClass\")\n\njax.core.raise_to_shaped_mappings[AbstractPrimitiveClass] = lambda aval, _: aval\n```\n\n----------------------------------------\n\nTITLE: Inspecting Circuit Specs with Custom Resource Operation in PennyLane\nDESCRIPTION: Demonstrates how to use `qml.specs` to inspect the specifications of a circuit that includes the custom resource operation `CustomOp`.  This allows for verification of the circuit's depth and other resources based on the custom operation's defined resources.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> specs = qml.specs(circ)()\n>>> specs[\"resources\"].depth\n6\n```\n\n----------------------------------------\n\nTITLE: QNode Gradient Computation with Partial argnum in Python\nDESCRIPTION: This snippet computes the gradient of a QNode, specifying only one trainable parameter to consider using the `argnum` keyword argument.  This demonstrates how specifying a subset of parameters impacts the computed Jacobian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qnode2 = qml.QNode(circuit, dev, diff_method=\"parameter-shift\", argnum=[0])\n>>> print(qml.grad(qnode2)(x,y))\n(array(0.31434679), array(0.))\n```\n\n----------------------------------------\n\nTITLE: Constructing a QNode with noisy channels in PennyLane\nDESCRIPTION: This code demonstrates the construction of a QNode that includes non-unitary operations, specifically noisy channels like AmplitudeDamping. It showcases how to define a quantum circuit with parameters, apply quantum operations and a noise channel, and return the expectation value of a PauliZ observable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circuit(params):\n...     qml.RX(params[0], wires=0)\n...     qml.RY(params[1], wires=0)\n...     qml.AmplitudeDamping(0.5, wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> print(circuit([0.54, 0.12]))\n0.9257702929524184\n>>> print(circuit([0, np.pi]))\n0.0\n```\n\n----------------------------------------\n\nTITLE: Optimization using JAXopt\nDESCRIPTION: This example showcases how to optimize a QNode using the ``GradientDescent`` optimizer from the ``JAXopt`` library. The QNode is transformed by ``jax.jit`` to improve performance.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/jax.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax\nimport jaxopt\n\njax.config.update(\"jax_enable_x64\", True)\n\ndev = qml.device(\"default.qubit\", wires=1, shots=None)\n\n@jax.jit\n@qml.qnode(dev, interface=\"jax\")\ndef energy(a):\n    qml.RX(a, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\ngd = jaxopt.GradientDescent(energy, maxiter=5)\n\nres = gd.run(0.5)\noptimized_params = res.params\n```\n\n----------------------------------------\n\nTITLE: QNode with static array indexing in while loop\nDESCRIPTION: This code defines a QNode `f` that uses a `while` loop with a static counter (`i`) to index a JAX array (`x`).  It applies an RX gate to each of the three qubits based on values from the input array `x`, up to `i < 3`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3)\n@qml.qnode(dev)\ndef f(x):\n    i = 0\n    while i < 3:\n        qml.RX(x[i], wires=i)\n        i += 1\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Multiple Measurements on Commuting Observables\nDESCRIPTION: Demonstrates how QNodes can now perform multiple measurements on the same wires, as long as all observables are commuting. The example measures the expectation value of PauliZ on wire 0 and the expectation value of the tensor product of PauliZ on wires 0 and 1. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return [\n        qml.expval(qml.PauliZ(0)),\n        qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n    ]\n```\n\n----------------------------------------\n\nTITLE: QNode with JAX array indexing in for loop\nDESCRIPTION: This code shows the correct way to index an array within a for loop using AutoGraph: converting the list to a JAX array. The QNode `f` then applies an RX gate to each of the three qubits based on values from the JAX array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef f():\n    x = jnp.array([0.1, 0.2, 0.3])\n    for i in range(3):\n        qml.RX(x[i], wires=i)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Code Comments Example in Python\nDESCRIPTION: This example showcases best practices for writing code comments, emphasizing the importance of explaining the implementation or algorithm, rather than describing the code itself. It demonstrates comment placement above the code block, and highlights the use of default arguments to named parameters to avoid Python's late binding closure behaviour.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_4\n\nLANGUAGE: python3\nCODE:\n```\n# Note: in the following template definition, we pass the observable, measurement,\n# and wires as *default arguments* to named parameters. This is to avoid\n# Python's late binding closure behaviour\n# (see https://docs.python-guide.org/writing/gotchas/#late-binding-closures)\ndef circuit(params, _obs=obs, _m=m, _wires=wires, **kwargs):\n    template(params, wires=_wires, **kwargs)\n    return MEASURE_MAP[_m](_obs)\n```\n\n----------------------------------------\n\nTITLE: Install OpenFermion-PySCF and PySCF\nDESCRIPTION: These commands show how to install the OpenFermion-PySCF and PySCF packages using pip, which are required for using the non-differentiable backends. OpenFermion-PySCF serves as the interface between PennyLane and the PySCF electronic structure package.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_7\n\nLANGUAGE: bash\nCODE:\n```\npip install openfermionpyscf\npip install pyscf\n```\n\n----------------------------------------\n\nTITLE: Predicting Resource Requirements with Null Qubit Device in PennyLane\nDESCRIPTION: Demonstrates how to use the `null.qubit` device in conjunction with the `Tracker` to predict resource requirements without actually executing circuits. This is particularly useful for large circuits where full execution would be computationally expensive.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 50\ndev = qml.device(\"null.qubit\", wires=n_wires)\n\nweight_shape = qml.StronglyEntanglingLayers.shape(2, n_wires)\nweights = np.random.random(weight_shape, requires_grad=True)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef circuit(weights):\n    qml.StronglyEntanglingLayers(weights, wires=range(n_wires))\n    return qml.expval(qml.PauliZ(0))\n\nwith qml.Tracker(dev) as tracker:\n    qml.grad(circuit)(weights)\n```\n\n----------------------------------------\n\nTITLE: Drawing Sampling Circuit (Pycon)\nDESCRIPTION: Illustrates how to draw a quantum circuit that returns samples using `qml.draw`. The output shows the circuit structure with the sampling measurement applied to the specified wires. Requires PennyLane installation and a QNode that performs sampling.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit_2)())\n 0: ──H──╭┤ Sample[basis]\n 1: ──H──│┤\n 2: ─────╰┤ Sample[basis]\n```\n\n----------------------------------------\n\nTITLE: Calculating Matrix of RX Gate with Differentiable Parameters in PennyLane\nDESCRIPTION: Demonstrates calculating the matrix representation of an RX gate with respect to a differentiable parameter using `torch.tensor` and `qml.matrix`. It also shows how to compute the loss and gradient.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = torch.tensor(0.6, requires_grad=True)\n>>> matrix_fn = qml.matrix(qml.RX)\n>>> matrix_fn(x, wires=[0])\ntensor([[0.9553+0.0000j, 0.0000-0.2955j],\n          [0.0000-0.2955j, 0.9553+0.0000j]], grad_fn=<AddBackward0>)\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> loss = torch.real(torch.trace(matrix_fn(x, wires=0)))\n>>> loss.backward()\n>>> x.grad\ntensor(-0.2955)\n```\n\n----------------------------------------\n\nTITLE: QNode with Dynamic Parameters and Transform\nDESCRIPTION: This example showcases a QNode with a dynamic parameter that affects the transform's action. It uses a for loop with a dynamic stop value. This example demonstrates the limitation with dynamic parameters and transforms when using program capture.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\n\n@shift_rx_to_end\n\n@qml.qnode(qml.device(\"default.qubit\", wires=4))\n\ndef circuit(stop):\n\n\n    @qml.for_loop(0, stop, 1)\n\n    def loop(i):\n\n        qml.RX(0.1, wires=i)\n\n        qml.H(wires=i)\n\n        \n\n    loop(stop)\n\n\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Operator Instantiation with Jax Arrays in PennyLane\nDESCRIPTION: This snippet demonstrates how to instantiate a `qml.Rot` operator using JAX arrays for the rotation angles and how to verify its type.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jax import numpy as jnp\nop = qml.Rot(jnp.array(0.1), jnp.array(0.2), jnp.array(0.3), wires=[\"a\"])\nisinstance(op, qml.operation.Operator)\n```\n\n----------------------------------------\n\nTITLE: Executing GlobalPhase Circuit\nDESCRIPTION: This code shows how to execute the previously defined quantum circuit with a specific input value. The `circuit` function is called with the parameter 0.5, and it returns the resulting quantum state as a NumPy array. The output represents the complex amplitudes of the qubits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_22\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(0.5)\narray([0.87758256-0.47942554j, 0.        +0.j        ,\n     1.        +0.j        , 0.        +0.j        ])\n```\n\n----------------------------------------\n\nTITLE: Custom CNOT Decomposition in PennyLane\nDESCRIPTION: This snippet defines a custom decomposition for the CNOT gate using Hadamard and CZ gates. It returns a list of PennyLane operations that represent the decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef custom_cnot(wires, **_):\n    return [\n        qml.Hadamard(wires=wires[1]),\n        qml.CZ(wires=[wires[0], wires[1]]),\n        qml.Hadamard(wires=wires[1])\n    ]\n```\n\n----------------------------------------\n\nTITLE: QNode Creation via Decorator with PyTorch Interface\nDESCRIPTION: This snippet demonstrates how to create a PyTorch-compatible QNode using the `@qml.qnode` decorator with the `interface='torch'` argument. The QNode defines a quantum circuit that accepts `torch.tensor` objects as input and returns `torch.tensor` objects as output, enabling seamless integration with PyTorch's automatic differentiation and optimization capabilities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/torch.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev, interface='torch')\ndef circuit(phi, theta):\n    qml.RX(phi[0], wires=0)\n    qml.RY(phi[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    qml.PhaseShift(theta, wires=0)\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.Hadamard(1))\n```\n\n----------------------------------------\n\nTITLE: Explicit Logging with If-Else (Python)\nDESCRIPTION: This snippet demonstrates how to explicitly add logging statements using if-else conditions to check the log level. This approach is useful when constructing the log message is computationally expensive, as it avoids unnecessary calculations when the debug level is not enabled.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/logging.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nif logger.isEnabledFor(logging.DEBUG):\n   logger.debug(\n      \"\"\"Entry with args=(arg_name_1=%s, arg_name_2=%s, ..., arg_name_n=%s)\"\"\",\n      arg_name_1, arg_name_2, ..., arg_name_n,\n   )\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging in PennyLane (Python)\nDESCRIPTION: This snippet shows how to enable logging in a PennyLane workflow. It imports the pennylane library and calls the enable_logging() function, which configures the execution pipeline to log function entries and outputs to the standard output.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/logging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nqml.logging.enable_logging()\n```\n\n----------------------------------------\n\nTITLE: Collapsible Sections JavaScript\nDESCRIPTION: This JavaScript snippet adds functionality to toggle the state of collapsible sections in the generated HTML. When a collapse header is clicked, it toggles the 'up' class on the icon, rotating it.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary_core/class.rst#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n$(\".collapse-header\").click(function () {\n  $(this).children('h2').eq(0).children('i').eq(0).toggleClass(\"up\");\n})\n```\n\n----------------------------------------\n\nTITLE: Simple Quantum Circuit Definition in PennyLane\nDESCRIPTION: This snippet defines a simple quantum circuit using PennyLane with the MultiRZ gate and returns the expectation value of the X operator on qubit 0. It showcases the basic structure of a quantum function in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef circuit():\n    qml.MultiRZ(jnp.array([0.1, 0.2]), wires=[0, 1])\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Running Device Integration Tests with PennyLane\nDESCRIPTION: This command executes the PennyLane device test utility to verify the correctness of probabilities, expectation values, variance, and samples calculated by a specific device. The --device argument specifies the short name of the device to be tested, and --shots defines the number of shots to use for statistical calculations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_15\n\nLANGUAGE: console\nCODE:\n```\npl-device-test --device device_shortname --shots 10000\n```\n\n----------------------------------------\n\nTITLE: Define Custom Noise Operation in PennyLane\nDESCRIPTION: Demonstrates how to define a custom noise operation as a standard quantum function that applies a `qml.RY` gate with an angle proportional to the parameter of the original operation. This function is later used as a noise operation in a `qml.NoiseModel`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef n0(op, **kwargs):\n    qml.RY(op.parameters[0] * 0.05, wires=op.wires)\n```\n\n----------------------------------------\n\nTITLE: Drawing at Different Transformation Levels (PyCon)\nDESCRIPTION: This snippet showcases using `qml.draw` with the `level` parameter to visualize a PennyLane circuit after different transforms have been applied. It displays the circuit at various stages of optimization, highlighting the effects of merging rotations and canceling inverses.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(f, level=0)())  # input program\n0: ──H──Y──RX(0.40)──RX(-0.40)──Y─┤  <X+(2.00*Y)>\n>>> print(qml.draw(f, level=1)())  # rotations merged\n0: ──H──Y──Y─┤  <X+(2.00*Y)>\n>>>  print(qml.draw(f, level=2)())  # inverses cancelled\n0: ──H─┤  <X+(2.00*Y)>\n>>>  print(qml.draw(f, level=3)())  # Hamiltonian expanded\n0: ──H─┤  <X>\n\n0: ──H─┤  <Y>\n```\n\n----------------------------------------\n\nTITLE: While loop with variable update\nDESCRIPTION: This code defines a function `f` that contains a `while` loop. Inside the loop, the input parameter `param` is updated by multiplying it by 1.2, and a counter `n` is incremented. The loop continues as long as `param` is less than 0.5. This illustrates the basic use of a `while` loop that updates a variable within its body.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndef f(param):\n    n = 0.\n    while param < 0.5:\n        param *= 1.2\n        n += 1\n    return n\n```\n\n----------------------------------------\n\nTITLE: Using the shift_operator method of FermiWord\nDESCRIPTION: This code demonstrates how to use the `shift_operator` method of the `qml.fermi.FermiWord` class. This method applies anti-commutator relations to the `FermiWord`. The example shows shifting operators at indices 0 and 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> w = qml.fermi.FermiWord({(0, 0): '+', (1, 1): '-'})\n>>> w\nFermiWord({(0, 0): '+', (1, 1): '-'})\n>>> w.shift_operator(0, 1)\nFermiSentence({FermiWord({(0, 1): '-', (1, 0): '+'}): -1})\n```\n\n----------------------------------------\n\nTITLE: Mapping Wires of a Toffoli Operator\nDESCRIPTION: This example demonstrates the `map_wires` method for operators in PennyLane. It shows how to create a Toffoli operator, define a wire map, and then create a new operator with the wires remapped according to the specified map.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_32\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.Toffoli([0, 1, 2])\n>>> wire_map = {0: 2, 2: 0}\n>>> op.map_wires(wire_map=wire_map)\nToffoli(wires=[2, 1, 0])\n```\n\n----------------------------------------\n\nTITLE: Packaging with setuptools package_data in setup.py (Python)\nDESCRIPTION: This snippet demonstrates how to use the `package_data` argument in `setup.py` to include a TOML configuration file (`device_name.toml`) for a PennyLane device. `include_package_data=True` is also specified. This ensures that the specified file is included when the package is installed, allowing PennyLane to load the device configuration.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom setuptools import setup, find_packages\n\nsetup(\n    ...\n    include_package_data=True,\n    package_data={\n        'package_name' : ['path/to/config/device_name.toml'],\n    },\n    ...\n)\n```\n\n----------------------------------------\n\nTITLE: Automatic Interface Detection Output\nDESCRIPTION: Example output from the automatic interface detection feature, showcasing the detected result type for different machine learning frameworks.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\nResult value: 1.00; Result type: <class 'pennylane.numpy.tensor.tensor'>\nResult value: 1.00; Result type: <class 'pennylane.numpy.tensor.tensor'>\nResult value: 1.00; Result type: <class 'torch.Tensor'>\nResult value: 1.00; Result type: <class 'tensorflow.python.framework.ops.EagerTensor'>\nResult value: 1.00; Result type: <class 'jaxlib.xla_extension.Array'>\n```\n\n----------------------------------------\n\nTITLE: Using the CommutingEvolution Template in PennyLane\nDESCRIPTION: This snippet demonstrates the usage of the `qml.CommutingEvolution` template for time evolution under a commuting Hamiltonian. The template utilizes generalized parameter shift rules for cost function gradients. The example initializes the template within a QNode and specifies a Hamiltonian and its corresponding eigenvalue frequencies.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nn_wires = 2\ndev = qml.device('default.qubit', wires=n_wires)\n\ncoeffs = [1, -1]\nobs = [qml.PauliX(0) @ qml.PauliY(1), qml.PauliY(0) @ qml.PauliX(1)]\nhamiltonian = qml.Hamiltonian(coeffs, obs)\nfrequencies = (2,4)\n\n@qml.qnode(dev)\ndef circuit(time):\n    qml.PauliX(0)\n    qml.CommutingEvolution(hamiltonian, time, frequencies)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Computing Gradients with QNode-Level Broadcasting in PennyLane\nDESCRIPTION: This snippet calculates the gradients of the QNode with broadcasting enabled.  It takes single parameter values for `x` and `y` and computes the gradients with respect to each.  Internally, broadcasting is used during the parameter-shift calculation for potential speedup.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = np.array(0.1, requires_grad=True)\n>>> y = np.array(0.4, requires_grad=True)\n>>> qml.grad(circuit)(x, y)\n(array(-0.09195267), array(-0.38747287))\n```\n\n----------------------------------------\n\nTITLE: Parameter-Shift Hessian with argnum\nDESCRIPTION: This snippet showcases the computation of a subset of the parameter-shift Hessian using the `argnum` keyword argument in `qml.gradients.param_shift_hessian`. It defines a QNode and computes only the diagonal elements of the Hessian matrix. This functionality allows for more efficient computation when only specific entries of the Hessian are required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=0)\n    qml.RX(x[2], wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nargnum = qml.math.eye(3, dtype=bool)\nx = np.array([0.2, -0.9, 1.1], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Applying Vectorized Functions to QNode Collections\nDESCRIPTION: This code demonstrates the usage of `qml.apply` to apply a vectorized function, such as `np.sin`, to a QNode collection. This allows for performing element-wise operations on the outputs of multiple QNodes, enabling the construction of more complex cost functions and computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> qnodes = qml.map(my_template, obs_list, dev, measure=\"expval\")\n>>> cost = qml.apply(np.sin, qnodes)\n>>> cost([0.54, 0.12])\narray([-0.0615095  0.83756375])\n```\n\n----------------------------------------\n\nTITLE: Creating Fermi Sentences in PennyLane\nDESCRIPTION: Illustrates how to create Fermi sentences, which are linear combinations of Fermi words, representing fermionic Hamiltonians. This example constructs the Hamiltonian H = 1.2 a⁺(0) a(0) + 2.3 a⁺(3) a(3).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> h = 1.2 * qml.FermiC(0) * qml.FermiA(0) + 2.3 * qml.FermiC(3) * qml.FermiA(3)\n>>> h\n1.2 * a⁺(0) a(0)\n+ 2.3 * a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: JavaScript for Collapsible Header Toggle\nDESCRIPTION: This JavaScript snippet adds functionality to toggle the rotation of the icon in the collapsible headers.  It uses jQuery to listen for clicks on elements with the class `collapse-header` and toggles the `up` class on the `i` element within the header's `h2`. Requires jQuery.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\n$(\".collapse-header\").click(function () {\n    $(this).children('h2').eq(0).children('i').eq(0).toggleClass(\"up\");\n})\n```\n\n----------------------------------------\n\nTITLE: Printing FermiWord\nDESCRIPTION: This code shows the new string representation when printing a `qml.fermi.FermiWord` object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n>>> w = qml.fermi.FermiWord({(0, 0) : '+', (1, 1) : '-'})\n>>> print(w)\na⁺(0) a(1)\n```\n\n----------------------------------------\n\nTITLE: Executing Quantum Circuit with Sparse Data Structures\nDESCRIPTION: This example executes the quantum circuit defined in the previous snippet, which utilizes sparse matrices for quantum operations. The circuit returns the state vector, demonstrating that PennyLane preserves sparsity throughout the simulation. The output is a NumPy array representing the quantum state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\narray([ 0.     +0.j,  0.03125+0.j,  0.     +0.j, ..., -0.03125+0.j,\n        0.     +0.j,  0.     +0.j])\n```\n\n----------------------------------------\n\nTITLE: New FermionicSWAP gate operation\nDESCRIPTION: This code demonstrates the new `qml.FermionicSWAP` gate operation. This gate implements the exchange of spin orbitals representing fermionic-modes while maintaining proper anti-symmetrization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(phi):\n    qml.BasisState(np.array([0, 1]), wires=[0, 1])\n    qml.FermionicSWAP(phi, wires=[0, 1])\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Minimal PennyLane Device Implementation in Python\nDESCRIPTION: This snippet provides a minimal implementation of a PennyLane device.  The execute method returns 0.0 for QuantumScript and a tuple of 0.0 for each circuit in a QuantumScriptOrBatch.  This demonstrates the basic structure required for a custom device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass MyDevice(Device):\n    \"\"\"My Documentation.\"\"\"\n\n    def execute(\n        self,\n        circuits: QuantumScriptOrBatch,\n        execution_config: \"ExecutionConfig\" = DefaultExecutionConfig\n    ):\n        return 0.0 if isinstance(circuits, qml.tape.QuantumScript) else tuple(0.0 for c in circuits)\n\ndev = MyDevice()\n\n@qml.qnode(dev)\ndef circuit():\n    return qml.state()\n\ncircuit()\n```\n\n----------------------------------------\n\nTITLE: Mutual Information Calculation with PennyLane\nDESCRIPTION: This snippet illustrates how to compute the mutual information between two qubits using PennyLane's `qml.mutual_info` measurement. A quantum circuit with an IsingXX gate is defined, and the mutual information between wires 0 and 1 is calculated. The log_base argument sets the logarithm base.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> @qml.qnode(dev)\n... def circuit(x):\n...     qml.IsingXX(x, wires=[0,1])\n...     return qml.mutual_info(wires0=[0], wires1=[1], log_base=2)\n>>> circuit(np.pi/2)\n2.0\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Tracers and Abstracted Axes\nDESCRIPTION: This code demonstrates generating a JAXPR (JAX's intermediate representation) inside a traced function using `jax.make_jaxpr`. It shows how to specify `abstracted_axes` to avoid errors when dealing with dynamic shapes during tracing. The function `f` calculates the sum of a JAX array with a dynamically determined shape.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef f(n):\n    x = jax.numpy.ones((n,))\n    jaxpr = jax.make_jaxpr(jax.numpy.sum)(x)\n    return jax.core.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, n, x)\n    \njax.make_jaxpr(f)(3)\n```\n\n----------------------------------------\n\nTITLE: Apply Amplitude Amplification in a Quantum Circuit (Python)\nDESCRIPTION: This code demonstrates the use of the qml.AmplitudeAmplification template. It creates a quantum circuit that prepares an initial state using the generator, applies amplitude amplification with a specified number of iterations, and returns the probabilities of the basis states.  The goal is to amplify the amplitude of a specific target state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    generator(wires=range(3)) # prepares |Psi> = U|0>\n    qml.AmplitudeAmplification(U, O, iters=10)\n\n    return qml.probs(wires=range(3))\n```\n\n----------------------------------------\n\nTITLE: Applying Pre-instantiated Operations (Python)\nDESCRIPTION: Demonstrates how to use `qml.apply` to add operations that have already been instantiated to a QNode. This allows for more flexible circuit construction. Requires PennyLane installation and a device defined.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nop = qml.RX(0.4, wires=0)\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RY(x, wires=0)\n    qml.apply(op)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: VQE Circuit Execution (Pycon)\nDESCRIPTION: Executes the VQE circuit defined in the previous snippet and calculates the gradient of the circuit. Requires the previous Python code snippet to be executed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit(w))\n-1.5133943637878295\n>>> print(qml.grad(circuit)(w))\n[[[-8.32667268e-17  1.39122955e+00 -9.12462052e-02]\n  [ 1.02348685e-16 -7.77143238e-01 -1.74708049e-01]]]\n```\n\n----------------------------------------\n\nTITLE: Pow Operator Decomposition and Matrix\nDESCRIPTION: This snippet demonstrates the `qml.ops.op_math.Pow` class, which represents an operator raised to a power. It shows how to obtain the decomposition of the `Pow` operator (resulting in an SX gate) and how to compute its matrix representation.  This example showcases the usage of the `Pow` operator and its functionalities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_17\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.ops.op_math.Pow(qml.PauliX(0), 0.5)\n>>> op.decomposition()\n[SX(wires=[0])]\n>>> qml.matrix(op)\narray([[0.5+0.5j, 0.5-0.5j],\n       [0.5-0.5j, 0.5+0.5j]])\n```\n\n----------------------------------------\n\nTITLE: Cost Function with JAX gradient\nDESCRIPTION: This defines a simple cost function that takes the first element of the probability vector returned by the `circuit` QNode and returns it.  It demonstrates how to compute the gradient of a scalar-valued cost function using JAX's automatic differentiation capabilities, where the cost function itself uses the output of a vector-valued QNode. This is useful when the direct Jacobian of the QNode is not required or supported.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef cost(x, y):\n    return circuit(x, y)[0]\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Device with Modifiers in PennyLane\nDESCRIPTION: This code demonstrates how to create a custom PennyLane device, `MyDevice`, and apply device modifiers like `simulator_tracking` and `single_tape_support` to enhance its functionality. The `execute` method is defined to return a tuple of 0.0 values for each circuit, and the device's tracker is used to monitor executions, simulations, and resources.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n@simulator_tracking\n@single_tape_support\nclass MyDevice(qml.devices.Device):\n\n    def execute(self, circuits, execution_config = qml.devices.DefaultExecutionConfig):\n        return tuple(0.0 for _ in circuits)\n```\n\n----------------------------------------\n\nTITLE: Pytree Example\nDESCRIPTION: Demonstrates how to use pytrees with the `FlatFn` class to unpack and repack function arguments and results. This is helpful for handling functions with complex input/output structures.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.capture.flatfn import FlatFn\n>>> def f(x): # define a function with pytree inputs and outputs\n...     return {\"a\": x[0], \"b\": x[1]+1}\n>>> args = ([0.1, 0.2],) # the arguments to the function\n>>> flatfn = FlatFn(f)\n>>> flatfn.out_tree is None # initialized to None\nTrue\n>>> results = flatfn(*args)\n>>> results\n[0.1, 1.2]\n>>> flatfn.out_tree # set once function is called\nPyTreeDef({'a': *, 'b': *})\n>>> jax.tree_util.tree_unflatten(flatfn.out_tree, results)\n{'a': 0.1, 'b': 1.2}\n```\n\n----------------------------------------\n\nTITLE: QNode with list indexing in for loop (error)\nDESCRIPTION: This code demonstrates the error that occurs when trying to index a standard Python list within a for loop inside a QNode when AutoGraph is enabled. AutoGraph requires that the object being indexed is a JAX array or a dynamic runtime variable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef f():\n    x = [0.1, 0.2, 0.3]\n    for i in range(3):\n        qml.RX(x[i], wires=i)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Inverting a Quantum Template in PennyLane\nDESCRIPTION: This code snippet demonstrates the use of `qml.inv` to invert a quantum template within a QNode. The `@qml.template` decorator is used to define a reusable quantum circuit block. The `qml.inv` function then inverts the operations within the template, effectively applying the inverse of the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.template\ndef ansatz(weights, wires):\n    for idx, wire in enumerate(wires):\n        qml.RX(weights[idx], wires=[wire])\n\n    for idx in range(len(wires) - 1):\n        qml.CNOT(wires=[wires[idx], wires[idx + 1]])\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.inv(ansatz(weights, wires=[0, 1]))\n    return qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Installing PennyLane Development Dependencies (Bash)\nDESCRIPTION: This snippet installs extra packages needed for development processes such as linting, testing, and pre-commit quality checks. The packages are installed using pip and are listed in the `requirements-dev.txt` file.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/installation.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install -r requirements-dev.txt\n```\n\n----------------------------------------\n\nTITLE: Simulate Mixed-State Qutrit Systems\nDESCRIPTION: Demonstrates simulating mixed qutrit states using the `default.qutrit.mixed` device. The example defines a simple quantum circuit with a TRY gate and showcases how to obtain samples, expectation values, and density matrices from the simulation. Qutrit devices enable simulating three-level quantum systems.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qutrit.mixed\")\n\ndef circuit():\n    qml.TRY(0.1, wires=0)\n\n@qml.qnode(dev)\ndef shots_circuit():\n    circuit()\n    return qml.sample(), qml.expval(qml.GellMann(wires=0, index=1))\n\n@qml.qnode(dev)\ndef density_matrix_circuit():\n    circuit()\n    return qml.state()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> shots_circuit(shots=5)\n(array([0, 0, 0, 0, 0]), 0.19999999999999996)\n>>> density_matrix_circuit()\ntensor([[0.99750208+0.j, 0.04991671+0.j, 0.        +0.j],\n       [0.04991671+0.j, 0.00249792+0.j, 0.        +0.j],\n       [0.        +0.j, 0.        +0.j, 0.        +0.j]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: JAX Hessian Computation with qml.enable_return()\nDESCRIPTION: Demonstrates the use of `qml.enable_return()` with the JAX interface to compute the Hessian of a quantum circuit that returns multiple measurements (variance and probabilities). It highlights the ability to handle shots vectors and gradient output types.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\nqml.enable_return()\ndev = qml.device(\"default.qubit\", wires=2, shots=(1, 10000))\n\nparams = jax.numpy.array([0.1, 0.2])\n\n@qml.qnode(dev, interface=\"jax\", diff_method=\"parameter-shift\", max_diff=2)\ndef circuit(x):\n    qml.RX(x[0], wires=[0])\n    qml.RY(x[1], wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.var(qml.PauliZ(0) @ qml.PauliX(1)), qml.probs(wires=[0])\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jax.hessian(circuit)(params)\n((Array([[ 0.,  0.],\n              [ 2., -3.]], dtype=float32),\nArray([[[-0.5,  0. ],\n              [ 0. ,  0. ]],\n            [[ 0.5,  0. ],\n              [ 0. ,  0. ]]], dtype=float32)),\n(Array([[ 0.07677898,  0.0563341 ],\n              [ 0.07238522, -1.830669  ]], dtype=float32),\nArray([[[-4.9707499e-01,  2.9999996e-04],\n              [-6.2500127e-04,  1.2500001e-04]],\n            [[ 4.9707499e-01, -2.9999996e-04],\n              [ 6.2500127e-04, -1.2500001e-04]]], dtype=float32)))\n```\n\n----------------------------------------\n\nTITLE: Decomposing with Gate Set (Python)\nDESCRIPTION: This snippet demonstrates how to use `qml.transforms.decompose` to decompose a circuit into a specified gate set. The example restricts the decomposition to `qml.Toffoli`, `qml.RX`, and `qml.RZ` gates.  The `@partial` decorator pre-configures `qml.transforms.decompose` before it is applied to the quantum node.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\n\ndev = qml.device('default.qubit')\nallowed_gates = {qml.Toffoli, qml.RX, qml.RZ}\n\n@partial(qml.transforms.decompose, gate_set=allowed_gates)\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=[0])\n    qml.Toffoli(wires=[0, 1, 2])\n    return qml.expval(qml.Z(0))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(circuit)())\n0: ──RZ(1.57)──RX(1.57)──RZ(1.57)─╭●─┤  <Z>\n1: ───────────────────────────────├●─┤\n2: ───────────────────────────────╰X─┤\n```\n\n----------------------------------------\n\nTITLE: QNode with Automatic Interface Detection in Python\nDESCRIPTION: This code shows an example of defining a QNode without explicitly specifying the interface.  The interface is automatically determined based on the type of the input parameters (JAX arrays in this case). It defines a simple quantum circuit and returns expectation values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nimport jax.numpy as jnp\n\nqml.enable_return()\na = jnp.array(0.1)\nb = jnp.array(0.2)\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit(a, b):\n    qml.RY(a, wires=0)\n    qml.RX(b, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.expval(qml.PauliY(1))\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit with GellMann Observable in PennyLane\nDESCRIPTION: This Python code demonstrates the use of the `qml.GellMann` observable within a PennyLane quantum circuit. The circuit applies qutrit operations (TClock, TShift, TAdd) and then measures the expectation value of a combination of Gell-Mann matrices on different wires. Dependencies: PennyLane, default.qutrit device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qutrit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.TClock(wires=0)\n    qml.TShift(wires=1)\n    qml.TAdd(wires=[0, 1])\n    return qml.expval(qml.GellMann(wires=0, index=8) + qml.GellMann(wires=1, index=3))\n```\n\n----------------------------------------\n\nTITLE: Enabling tape mode in PennyLane\nDESCRIPTION: This snippet shows how to enable tape mode globally in PennyLane using `qml.enable_tape()`. It then defines a quantum circuit with TensorFlow parameters, applies some quantum operations, and returns the expectation value of a PauliZ observable. This showcases in-QNode classical processing and less restrictive QNode signatures.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_tape()\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev, interface=\"tf\")\ndef circuit(p):\n    print(\"Parameter value:\", p)\n    qml.RX(tf.sin(p[0])**2 + p[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: AllSinglesDoubles Template Usage in Python\nDESCRIPTION: This snippet illustrates the usage of the `AllSinglesDoubles` template in PennyLane for preparing quantum states of molecules using `SingleExcitation` and `DoubleExcitation` operations. It requires PennyLane and its `numpy` and `qchem` submodules. The example sets up a quantum circuit with the template and executes it to obtain an expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import numpy as np\n\nelectrons = 2\nqubits = 4\n\nhf_state = qml.qchem.hf_state(electrons, qubits)\nsingles, doubles = qml.qchem.excitations(electrons, qubits)\n```\n\n----------------------------------------\n\nTITLE: QNode with Positional Arguments for Compatibility\nDESCRIPTION: This snippet illustrates the importance of using positional arguments in PennyLane, especially when program capture is enabled. It demonstrates that using keyword arguments for gate parameters can lead to errors. This example defines a QNode that applies an RX gate and returns the expectation value of the Z operator on qubit 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\n\nqml.capture.enable()\n\n\n@qml.qnode(dev)\n\ndef circuit(angle):\n\n    qml.RX(angle, wires=0)\n\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Class Docstring Example in Python\nDESCRIPTION: This is an example of a class docstring, demonstrating the structure including a single-sentence summary, multi-line description, argument and keyword argument descriptions, attributes, exceptions, see also references, example code block, usage details, and related tutorials.  This documentation is essential for users to understand the class's purpose, usage, and potential issues. It will be automatically listed in the generated documentation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass MyClass:\n    \"\"\"Single sentence that summarizes the class.\n\n    Multi-line description of the class (optional, if required).\n\n    Args:\n        arg1 (type): Description.\n            Continuation line is indented if needed.\n        arg2 (type): description\n\n    Keyword Args:\n        kwarg1 (type): description\n\n    Attributes:\n        attr1 (type): description\n\n    Raises:\n        ExceptionType: description\n\n    .. seealso:: :func:`~.relevant_func`, :class:`~.RelevantClass` (optional)\n\n    **Example**\n\n    Minimal example with 1 or 2 code blocks (required).\n\n    .. details::\n        :title: Usage Details\n\n        More complicated use cases, options, and larger code blocks (optional).\n\n    **Related tutorials**\n\n    Links to any relevant PennyLane demos (optional).\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Constructing a CircuitGraph\nDESCRIPTION: Demonstrates how to construct a directed acyclic graph (DAG) representing causal relations between operators in a quantum circuit using the `CircuitGraph` class.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import CircuitGraph\nfrom pennylane.workflow import construct_tape\n\ndev = qml.device('lightning.qubit', wires=(0,1,2,3))\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(0)\n    qml.CNOT([1, 2])\n    qml.CNOT([2, 3])\n    qml.CNOT([3, 1])\n    return qml.expval(qml.Z(0))\n\n\ncircuit()\ntape = construct_tape(circuit)() \nops = tape.operations\nobs = tape.observables\ng = CircuitGraph(ops, obs, tape.wires)\n```\n\n----------------------------------------\n\nTITLE: Executing Quantum Circuit with Counts and Observables\nDESCRIPTION: This code executes the quantum circuit defined to return counts with PauliZ observables. The resulting dictionaries show the counts for each eigenvalue of the PauliZ operators on wires 0 and 1.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_33\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n({-1: 470, 1: 530}, {-1: 470, 1: 530})\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Abstracted Axes\nDESCRIPTION: This snippet defines a function that calculates the sum of an array and generates its JAXPR using `abstracted_axes` to indicate that the size of the array's first dimension is dynamic. This allows reusing the same JAXPR for different array sizes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndef g(x):\n    return jax.numpy.sum(x)\n\njax.make_jaxpr(g, abstracted_axes=(\"x\",))(jax.numpy.array([1,2,3]))\n```\n\n----------------------------------------\n\nTITLE: Differentiating Overlap Integral in PennyLane\nDESCRIPTION: This code demonstrates how to differentiate the overlap integral with respect to the basis set parameters (alpha and coeff) using PennyLane's automatic differentiation capabilities. It initializes a `Molecule` object and then calculates the gradient of the `overlap_integral` function with respect to alpha and coeff.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nsymbols = [\"H\", \"H\"]\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 2.0]], requires_grad=False)\nalpha = np.array([[3.42525091, 0.62391373, 0.1688554],\n                    [3.42525091, 0.62391373, 0.1688554]], requires_grad = True)\ncoeff = np.array([[0.15432897, 0.53532814, 0.44463454],\n                    [0.15432897, 0.53532814, 0.44463454]], requires_grad = True)\n\nmol = qml.qchem.Molecule(symbols, geometry, alpha=alpha, coeff=coeff)\nargs = [alpha, coeff]\n\na = mol.basis_set[0]\nb = mol.basis_set[1]\n\ng_alpha = qml.grad(qml.qchem.overlap_integral(a, b), argnum = 0)(*args)\ng_coeff = qml.grad(qml.qchem.overlap_integral(a, b), argnum = 1)(*args)\n```\n\n----------------------------------------\n\nTITLE: Drawing Quantum Circuits with Modified Wire Order in PennyLane\nDESCRIPTION: This snippet demonstrates how to use the PennyLane circuit drawer to visualize quantum circuits, including the ability to modify the wire order for customized representation. It showcases the creation of a quantum device and circuit, followed by printing the circuit diagram with both the default and a specified wire order.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=[\"a\", -1, \"q2\"])\n>>> @qml.qnode(dev)\n... def circuit():\n...     qml.Hadamard(wires=-1)\n...     qml.CNOT(wires=[\"a\", \"q2\"])\n...     qml.RX(0.2, wires=\"a\")\n...     return qml.expval(qml.PauliX(wires=\"q2\"))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> print(circuit.draw())\n   a: ─────╭C──RX(0.2)──┤\n  -1: ──H──│────────────┤\n  q2: ─────╰X───────────┤ ⟨X⟩\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> print(circuit.draw(wire_order=[\"q2\", \"a\", -1]))\n  q2: ──╭X───────────┤ ⟨X⟩\n   a: ──╰C──RX(0.2)──┤\n  -1: ───H───────────┤\n```\n\n----------------------------------------\n\nTITLE: Trainable Parameter Initialization in PennyLane with Autograd\nDESCRIPTION: This code demonstrates how to initialize trainable parameters using PennyLane's NumPy wrapper with the `requires_grad=True` attribute when using the Autograd interface. This is a change from previous versions where parameters were automatically trainable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2))\ndef circuit(x):\n  ...\n\nx = np.array([0.1, 0.2], requires_grad=True)\nqml.grad(circuit)(x)\n```\n\n----------------------------------------\n\nTITLE: Printing Weights and Drawing TwoLocalSwapNetwork Circuit\nDESCRIPTION: This snippet prints the random weights used in the `TwoLocalSwapNetwork` template and draws the quantum circuit, illustrating the gate arrangement. The `expansion_strategy` is set to 'device' for a more detailed circuit diagram.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_26\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(weights)\ntensor([0.20308242, 0.91906199, 0.67988804, 0.81290256, 0.08708985,\n        0.81860084, 0.34448344, 0.05655892, 0.61781612, 0.51829044], requires_grad=True)\n>>> print(qml.draw(swap_network_circuit, expansion_strategy = 'device')())\n0: ─╭●────────╭SWAP─────────────────╭●────────╭SWAP─────────────────╭●────────╭SWAP─┤  State\n1: ─╰RY(0.20)─╰SWAP─╭●────────╭SWAP─╰RY(0.09)─╰SWAP─╭●────────╭SWAP─╰RY(0.62)─╰SWAP─┤  State\n2: ─╭●────────╭SWAP─╰RY(0.68)─╰SWAP─╭●────────╭SWAP─╰RY(0.34)─╰SWAP─╭●────────╭SWAP─┤  State\n3: ─╰RY(0.92)─╰SWAP─╭●────────╭SWAP─╰RY(0.82)─╰SWAP─╭●────────╭SWAP─╰RY(0.52)─╰SWAP─┤  State\n4: ─────────────────╰RY(0.81)─╰SWAP─────────────────╰RY(0.06)─╰SWAP─────────────────┤  State\n```\n\n----------------------------------------\n\nTITLE: Listing Available Dataset Names\nDESCRIPTION: This code snippet uses the `qml.data.list_data_names` function to retrieve a list of available dataset names and prints the result.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nqml.data.list_data_names()\n```\n\n----------------------------------------\n\nTITLE: QNode argnum Specification in Python\nDESCRIPTION: This snippet demonstrates the usage of the `argnum` keyword argument for a QNode to define a subset of trainable parameters used to estimate the Jacobian. It requires PennyLane. The example shows how to specify a subset of parameters to consider when computing the gradient.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\nx = np.array(0.543, requires_grad=True)\ny = np.array(-0.654, requires_grad=True)\n\ndef circuit(x,y):\n    qml.RX(x, wires=[0])\n    qml.RY(y, wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n```\n\n----------------------------------------\n\nTITLE: PauliWord instantiation in PennyLane\nDESCRIPTION: This snippet demonstrates how to instantiate a PauliWord object in PennyLane, representing a tensor product of Pauli operators on specified wires. It showcases the basic creation and representation of Pauli words.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.pauli import PauliWord\n>>> pw1 = PauliWord({0:\"X\", 1:\"Z\"})  # X@Z\n>>> pw2 = PauliWord({0:\"Y\", 1:\"Z\"})  # Y@Z\n>>> pw1, pw2\n(X(0) @ Z(1), Y(0) @ Z(1))\n```\n\n----------------------------------------\n\nTITLE: Code Example Using Python Code-Block and pycon\nDESCRIPTION: This snippet illustrates the use of a standard Python code-block combined with Python console syntax to display the output when providing larger and more complicated code blocks. This approach enables clear separation of code and its expected output. It is very similar to the previous, but uses `code-block:: python3` rather than `code-block:: pycon` for the code definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_3\n\nLANGUAGE: rest\nCODE:\n```\n.. code-block:: python3\n\n    dev = qml.device(\"default.qubit\", wires=1)\n    @qml.qnode(dev)\n    def circuit(x):\n        qml.RX(x, wires=0)\n        return qml.expval(qml.PauliZ(0))\n\nExecuting this circuit:\n\n>>> circuit(0.5)\n0.8775825618903726\n```\n\n----------------------------------------\n\nTITLE: QNode Drawing with Catalyst's qjit\nDESCRIPTION: This code demonstrates the compatibility of `qml.draw` with a QNode decorated with `qjit` from PennyLane's Catalyst library. The code defines a quantum circuit on three wires and uses `catalyst.for_loop` within the circuit. The `qml.draw` function is used to visualize the circuit after it has been JIT-compiled by Catalyst.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport catalyst\n\n@catalyst.qjit\n@qml.qnode(qml.device(\"lightning.qubit\", wires=3))\ndef circuit(x, y, z, c):\n    \"\"\"A quantum circuit on three wires.\"\"\"\n\n    @catalyst.for_loop(0, c, 1)\n    def loop(i):\n        qml.Hadamard(wires=i)\n\n    qml.RX(x, wires=0)\n    loop()  \n    qml.RY(y, wires=1)\n    qml.RZ(z, wires=2)\n    return qml.expval(qml.PauliZ(0))\n\ndraw = qml.draw(circuit, decimals=None)(1.234, 2.345, 3.456, 1)\n```\n\n----------------------------------------\n\nTITLE: Wires Attributes Access\nDESCRIPTION: This code snippet shows how to extract the labels as a tuple, list or array from a Wires object. Demonstrates various conversions possible with Wires class.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndevice_wires.labels # (2, 0)\n\ndevice_wires.tolist() # [2, 0]\n\ndevice_wires.toarray() # ndarray([2, 0])\n\nlen(device_wires) # 2\n```\n\n----------------------------------------\n\nTITLE: JAX Array as Positional Argument for MultiRZ (Valid) in PennyLane\nDESCRIPTION: This snippet demonstrates the correct way to pass the angles to ``qml.MultiRZ`` when program capture is enabled, which is to use a JAX numpy array as the positional argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nimport jax.numpy as jnp\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\n```\n\n----------------------------------------\n\nTITLE: Sparse Hamiltonian Computation in Python\nDESCRIPTION: This snippet shows how to compute the sparse matrix representation of a `qml.Hamiltonian` object using `qml.utils.sparse_hamiltonian`. It requires PennyLane and uses `scipy.sparse` for sparse matrix representation. The resulting matrix is in scipy coordinate list (COO) format and can be converted to a dense array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ncoeffs = [1, -0.45]\nobs = [qml.PauliZ(0) @ qml.PauliZ(1), qml.PauliY(0) @ qml.PauliZ(1)]\nH = qml.Hamiltonian(coeffs, obs)\nH_sparse = qml.utils.sparse_hamiltonian(H)\n```\n\n----------------------------------------\n\nTITLE: QNode with Keyword Arguments and Program Capture\nDESCRIPTION: This example demonstrates defining a QNode with keyword arguments and enabling program capture. It shows how JAX-incompatible types can be used as keyword arguments. It uses a for loop to apply RX and RZ gates to the specified wires and returns the expectation value of the X operator on qubit 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\n\nqml.capture.enable()\n\n\ndev = qml.device('default.qubit', wires=2)\n\n\n@qml.qnode(dev)\n\ndef circuit(x, range_of_wires=None):\n\n    for w in range_of_wires:\n\n        qml.RZ(x[0], wires=w)\n\n        qml.RX(x[1], wires=w)\n\n\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Multiplying Operators with qml.prod in PennyLane\nDESCRIPTION: This code snippet illustrates how to multiply PennyLane operators using the `qml.prod` function. It multiplies a PauliZ operator with an RX operator and then accesses the eigenvalues of the resulting product operator. It performs either a matrix product or tensor product of the operators. This requires the `pennylane` library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> theta = 1.23\n>>> prod_op = qml.prod(qml.PauliZ(0), qml.RX(theta, 1))\n>>> prod_op\nPauliZ(wires=[0]) @ RX(1.23, wires=[1])\n>>> qml.eigvals(prod_op)\n[-1.39373197 -0.23981492  0.23981492  1.39373197]\n```\n\n----------------------------------------\n\nTITLE: Nested Results with Batches, Measurements and Shot Vectors\nDESCRIPTION: This code shows an example with all forms of nesting: batch size of 3, three measurements with different fundamental shapes, and a shot vector with three different values.  It demonstrates how to access results.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nop = qml.RX((1.2, 2.3, 3.4), 0)\nms = (qml.expval(qml.Z(0)), qml.probs(wires=0), qml.counts())\ntape = qml.tape.QuantumScript((op,), ms, shots=(1, 100, 1000))\nresult = qml.device('default.qubit').execute(tape)\nresult\nresult[0][0] # first shot value, first measurement\nresult[0][0][0] # first shot value, first measurement, and parameter of 1.2\nresult[1][2] # second shot value, third measurement, all three parameter values\n```\n\n----------------------------------------\n\nTITLE: Bravyi-Kitaev Mapping in PennyLane (Pycon)\nDESCRIPTION: This interactive python console snippet demonstrates the application of the Bravyi-Kitaev mapping to transform a fermionic Hamiltonian into a qubit Hamiltonian using the qml.bravyi_kitaev function. It shows the creation of a fermionic Hamiltonian from a string, applies the mapping, and prints the resulting qubit Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> fermi_ham = qml.fermi.from_string('0+ 1+ 1- 0-')\n>>> qubit_ham = qml.bravyi_kitaev(fermi_ham, n=6, tol=0.0)\n>>> print(qubit_ham)\n0.25 * I(0) + -0.25 * Z(0) + -0.25 * (Z(0) @ Z(1)) + 0.25 * Z(1)\n```\n\n----------------------------------------\n\nTITLE: Quantum Circuit with ControlledQutritUnitary in PennyLane\nDESCRIPTION: This Python code demonstrates the use of `qml.ControlledQutritUnitary` in a PennyLane quantum circuit. It applies TShift and TAdd operations, followed by a controlled qutrit unitary operation controlled by two wires with specific control values ('12'). Requires: PennyLane, default.qutrit device, numpy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qutrit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit(U):\n    qml.TShift(wires=0)\n    qml.TAdd(wires=[0, 1])\n    qml.ControlledQutritUnitary(U, control_wires=[0, 1], control_values='12', wires=2)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Define Generator and Oracle for Amplitude Amplification (Python)\nDESCRIPTION: This code defines a generator and an oracle for use with the AmplitudeAmplification template. The generator creates a uniform superposition state using Hadamard gates, and the oracle flips the sign of a specific target state. The @qml.prod decorator is used to create a quantum operation from a quantum function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n@qml.prod\ndef generator(wires):\n    for wire in wires:\n        qml.Hadamard(wires=wire)\n\nU = generator(wires=range(3))\nO = qml.FlipSign(2, wires=range(3))\n```\n\n----------------------------------------\n\nTITLE: Computing Parameter-Shift Gradients with Broadcasting in PennyLane\nDESCRIPTION: This snippet computes the parameter-shift gradients with broadcasting enabled for the defined quantum circuit. It takes arrays of parameters `x` and `y` as inputs and returns the gradients with respect to each parameter. It requires the `numpy` and `pennylane` libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_9\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = np.array([np.pi/3, np.pi/2], requires_grad=True)\n>>> y = np.array([np.pi/6, np.pi/5], requires_grad=True)\n>>> qml.gradients.param_shift(circuit, broadcast=True)(x, y)\n(tensor([[-0.7795085,  0.       ],\n         [ 0.       , -0.7795085]], requires_grad=True),\ntensor([[-0.125, 0.  ],\n        [0.  , -0.125]], requires_grad=True))\n```\n\n----------------------------------------\n\nTITLE: Import JAX\nDESCRIPTION: Imports the JAX library, which is used for numerical computation and automatic differentiation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n```\n\n----------------------------------------\n\nTITLE: QNode Probability Measurement in PennyLane\nDESCRIPTION: This code snippet demonstrates how to return the probabilities of measuring all possible states in a quantum circuit using PennyLane's `qml.probs()` function.  This allows you to get the probability distribution of the output of the quantum circuit. The probabilities are returned as a NumPy array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nreturn qml.probs()\n```\n\n----------------------------------------\n\nTITLE: Controlling Draw Level with Transforms in PennyLane (Python)\nDESCRIPTION: This snippet demonstrates how to use `qml.draw` to visualize a quantum circuit at different stages of its transformation process. It defines a QNode with multiple transforms and then prints the circuit diagram at different `level` values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n@qml.transforms.split_non_commuting\n@qml.transforms.cancel_inverses\n@qml.transforms.merge_rotations\n@qml.qnode(qml.device(\"default.qubit\"))\ndef f():\n    qml.Hadamard(0)\n    qml.Y(0)\n    qml.RX(0.4, 0)\n    qml.RX(-0.4, 0)\n    qml.Y(0)\n    return qml.expval(qml.X(0) + 2 * qml.Y(0))\n```\n\n----------------------------------------\n\nTITLE: Computing Perturbation Error in PennyLane\nDESCRIPTION: This snippet computes the perturbation error by calling the `perturbation_error` function with the generated fragments and state vectors. The output is a list of complex numbers representing the error for each state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\n>>> perturbation_error(frags, [state1, state2])\n[(-0.9189251160920879+0j), (-4.797716682426851+0j)]\n```\n\n----------------------------------------\n\nTITLE: State Gradient with JAX Interface in PennyLane\nDESCRIPTION: This code demonstrates the use of the JAX interface to differentiate the quantum state directly. This example shows how using a complex-number interface (JAX, TensorFlow, or Torch) supports backpropagation through the quantum state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef state_vector_grad_jax():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, interface='jax', diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.state()\n\n    x = jnp.array([0.1], dtype=np.complex64)\n    print(jax.jacrev(circuit, holomorphic=True)(x))\n```\n\n----------------------------------------\n\nTITLE: Improved JAX Support with Vector-Valued QNodes\nDESCRIPTION: Demonstrates improved JAX interface support for evaluating vector-valued QNodes in PennyLane.  A QNode is defined that returns basis-state probabilities. The QNode is then evaluated, and its Jacobian is computed using JAX's `jacobian` function. Dependencies include JAX and PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\nx = jnp.array(0.543)\ny = jnp.array(-0.654)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"jax\")\ndef circuit(x, y):\n    qml.RX(x, wires=[0])\n    qml.RY(y, wires=[1])\n    qml.CNOT(wires=[0, 1])\n    return qml.probs(wires=[1])\n```\n\n----------------------------------------\n\nTITLE: Using SPSA Gradient as Differentiation Method in QNode with JAX in Pycon\nDESCRIPTION: This code demonstrates how to use the SPSA gradient transform as a differentiation method for a QNode. It defines a QNode with `diff_method=\"spsa\"` and specifies parameters for the SPSA method, such as `h` and `num_directions`. The gradient is computed using `jax.jacobian`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_9\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=1)\n>>> @qml.qnode(dev, interface=\"jax\", diff_method=\"spsa\", h=0.05, num_directions=20)\n... def circuit(x):\n...     qml.RX(x, 0)\n...     return qml.expval(qml.PauliZ(0))\n>>> jax.jacobian(circuit)(jax.numpy.array(0.5))\nArray(-0.4792258, dtype=float32, weak_type=True)\n```\n\n----------------------------------------\n\nTITLE: Suppressing ComplexWarning Messages in Workflows\nDESCRIPTION: This code snippet shows how to suppress 'ComplexWarning' messages that may appear during differentiable workflows involving both complex and float types, particularly with certain interfaces. These warnings are common in backpropagation due to complex casting and do not indicate an error, but can be suppressed if desired.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\nwarnings.filterwarnings(\"ignore\", category=np.ComplexWarning)\n```\n\n----------------------------------------\n\nTITLE: Convert pyQuil Program to PennyLane Quantum Function\nDESCRIPTION: This code demonstrates how to convert a pyQuil `Program` to a PennyLane quantum function using the `qml.from_pyquil` function. The resulting quantum function can then be used within a QNode. The PennyLane-Rigetti plugin must be installed for this to work.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\npl_qfunc_from_pq = qml.from_pyquil(pq_program)\n\n@qml.qnode(qml.device(\"default.qubit\"))\ndef pl_circuit_from_pq():\n    pl_qfunc_from_pq(wires=[0, 1])\n    return qml.expval(qml.Y(0)), qml.var(qml.Z(1))\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Registers of Wires with qml.registers in Python\nDESCRIPTION: This snippet demonstrates the creation of nested registers of wires using the `qml.registers` function.  It showcases how to organize wires into hierarchical structures using nested dictionaries. The wire labels are ordered based on the appearance and nestedness within the dictionary.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> wire_reg = qml.registers({\"alice\": {\"alice1\": 1, \"alice2\": 2}, \"bob\": {\"bob1\": 2, \"bob2\": 1}})\n>>> wire_reg\n{'alice1': Wires([0]), 'alice2': Wires([1, 2]), 'alice': Wires([0, 1, 2]), 'bob1': Wires([3, 4]), 'bob2': Wires([5]), 'bob': Wires([3, 4, 5])}\n```\n\n----------------------------------------\n\nTITLE: Basis Rotation in qml.qchem with electron_integrals\nDESCRIPTION: Demonstrates how to use `qml.qchem.basis_rotation()` to calculate coefficients, observables, and basis rotation transformation matrices for constructing a qubit Hamiltonian in the rotated basis of molecular orbitals. It depends on `qml.qchem.electron_integrals()` for computing electron integrals.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> symbols  = ['H', 'H']\n>>> geometry = np.array([[0.0, 0.0, 0.0], [1.398397361, 0.0, 0.0]], requires_grad = False)\n>>> mol = qml.qchem.Molecule(symbols, geometry)\n>>> core, one, two = qml.qchem.electron_integrals(mol)()\n>>> coeffs, ops, unitaries = qml.qchem.basis_rotation(one, two, tol_factor=1.0e-5)\n>>> unitaries\n[tensor([[-1.00000000e+00, -5.46483514e-13],\n       [ 5.46483514e-13, -1.00000000e+00]], requires_grad=True),\ntensor([[-1.00000000e+00,  3.17585063e-14],\n        [-3.17585063e-14, -1.00000000e+00]], requires_grad=True),\ntensor([[-0.70710678, -0.70710678],\n        [-0.70710678,  0.70710678]], requires_grad=True),\ntensor([[ 2.58789009e-11,  1.00000000e+00],\n        [-1.00000000e+00,  2.58789009e-11]], requires_grad=True)]\n```\n\n----------------------------------------\n\nTITLE: Projector Expectation Value with State Vector\nDESCRIPTION: This snippet demonstrates using a state vector with `qml.Projector` to compute the expectation value on a quantum circuit. The `circuit` function calculates the expectation value of a projector onto a specified state. The states are provided as numpy arrays.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n@qml.qnode(dev)\ndef circuit(state):\n    return qml.expval(qml.Projector(state, wires=[0, 1]))\nzero_state = [0, 0]\nplusplus_state = np.array([1, 1, 1, 1]) / 2\n```\n\n----------------------------------------\n\nTITLE: Using qml.bloq_registers with Qualtran\nDESCRIPTION: This code demonstrates how to use qml.bloq_registers to determine the required wires for complex Qualtran Bloqs with multiple registers. It retrieves the registers for a TextbookQPE bloq.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.phase_estimation import RectangularWindowState, TextbookQPE\n>>> from qualtran.bloqs.basic_gates import ZPowGate\n>>> textbook_qpe = TextbookQPE(ZPowGate(exponent=2 * 0.234), RectangularWindowState(3))\n>>> registers = qml.bloq_registers(textbook_qpe)\n```\n\n----------------------------------------\n\nTITLE: Quantum Monte Carlo Template in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.templates.QuantumMonteCarlo` template for performing quantum Monte Carlo estimation of an expectation value on a simulator. It approximates the expectation value of sine squared over a standard normal distribution using the template.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.stats import norm\n\nm = 5\nM = 2 ** m\nn = 10\nN = 2 ** n\ntarget_wires = range(m + 1)\nestimation_wires = range(m + 1, n + m + 1)\n\nxmax = np.pi  # bound to region [-pi, pi]\nxs = np.linspace(-xmax, xmax, M)\n\nprobs = np.array([norm().pdf(x) for x in xs])\nprobs /= np.sum(probs)\n\nfunc = lambda i: np.sin(xs[i]) ** 2\n\ndev = qml.device(\"default.qubit\", wires=(n + m + 1))\n\n@qml.qnode(dev)\ndef circuit():\n    qml.templates.QuantumMonteCarlo(\n        probs,\n        func,\n        target_wires=target_wires,\n        estimation_wires=estimation_wires,\n    )\n    return qml.probs(estimation_wires)\n\nphase_estimated = np.argmax(circuit()[:int(N / 2)]) / N\nexpectation_estimated = (1 - np.cos(np.pi * phase_estimated)) / 2\n```\n\n----------------------------------------\n\nTITLE: Rotosolve Optimization Steps with Full Output\nDESCRIPTION: This snippet shows how to perform optimization steps with the Rotosolve optimizer, including retrieving the full output. It prints the cost before each step and the cost of the minimization substeps. The optimizer used for the substeps is specified as 'brute'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfor step in range(3):\n    param, cost, sub_cost = opt.step_and_cost(\n        cost_function,\n        *param,\n        num_freqs=num_freqs,\n        full_output=True,\n        optimizer=\"brute\",\n    )\n    print(f\"Cost before step: {cost}\")\n    print(f\"Minimization substeps: {np.round(sub_cost, 6)}\")\n```\n\n----------------------------------------\n\nTITLE: Initializing a PennyLane Device\nDESCRIPTION: This Python snippet shows how to initialize a PennyLane device using its name. The `qml.device()` function is used to create an instance of the device based on the provided name.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\ndev1 = qml.device(name)\n```\n\n----------------------------------------\n\nTITLE: Transforming a QNode Using Batch Transform Decorator in PennyLane\nDESCRIPTION: Applies a custom batch transform (`my_transform`) to a QNode using decorator syntax. The QNode consists of a Hadamard gate, an RX gate, and an expectation value measurement of PauliX. The transform modifies the circuit based on its definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> @my_transform(0.65, 2.5)\n... @qml.qnode(dev)\n... def circuit(x):\n...     qml.Hadamard(wires=0)\n...     qml.RX(x, wires=0)\n...     return qml.expval(qml.PauliX(0))\n>>> print(circuit(-0.5))\n1.2629730888100839\n```\n\n----------------------------------------\n\nTITLE: Differentiating Circuit Probabilities with PennyLane\nDESCRIPTION: This code demonstrates the usage of `qml.probs()` measurement function in PennyLane, allowing for the differentiation of variational circuit probabilities. It defines a quantum circuit and returns the probabilities of measuring specific wires. The QNode, returning probabilities, fully supports autodifferentiation, making it suitable for optimization tasks.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(x):\n    qml.Hadamard(wires=0)\n    qml.RY(x, wires=0)\n    qml.RX(x, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.probs(wires=[0])\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit(0.2)\n[0.40066533 0.59933467]\n```\n\n----------------------------------------\n\nTITLE: Quantum Tape to MultiDiGraph Conversion in PennyLane\nDESCRIPTION: This code snippet demonstrates how to convert a PennyLane quantum tape to a MultiDiGraph using the `qml.qcut.tape_to_graph` function.  It then iterates through the adjacency list of the graph to print the connections between operations based on their wire assignments. This uses the `networkx` package.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> g2 = qml.qcut.tape_to_graph(tape)\n>>> type(g2)\n<class 'networkx.classes.multidigraph.MultiDiGraph'>\n>>> for k, v in g2.adjacency():\n...    print(k, v)\nH(0) {expval(Z(0)): {0: {'wire': 0}}}\nCNOT(wires=[1, 2]) {CNOT(wires=[2, 3]): {0: {'wire': 2}}, CNOT(wires=[3, 1]): {0: {'wire': 1}}}\nCNOT(wires=[2, 3]) {CNOT(wires=[3, 1]): {0: {'wire': 3}}}\nCNOT(wires=[3, 1]) {}\nexpval(Z(0)) {}\n```\n\n----------------------------------------\n\nTITLE: QSVT Circuit Drawing (Pycon)\nDESCRIPTION: This snippet shows how to draw the expanded quantum tape of the QSVT circuit created using `qml.qsvt`. It expands the quantum tape to a depth of 1 and then prints the drawn circuit with 2 decimal places. It is used to visualize the circuit structure consisting of BlockEncode and PCPhase operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nexample_circuit(A)\nprint(example_circuit.qtape.expand(depth=1).draw(decimals=2))\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Multiple Quantum Tapes in PennyLane\nDESCRIPTION: Shows how to unwrap multiple quantum tapes simultaneously using the `qml.tape.Unwrap` context manager.  This allows you to temporarily convert the trainable parameters of several tapes to numpy arrays and floats, which can be useful for interoperability with other frameworks.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> with qml.tape.Unwrap(tape1, tape2):\n```\n\n----------------------------------------\n\nTITLE: Calculate Spectral Norm Error of a Quantum Circuit (Pycon)\nDESCRIPTION: This interactive python console snippet shows how to use qml.specs to calculate the total spectral norm error of a quantum circuit that includes custom error operations. It demonstrates the expected output, which is a dictionary containing the SpectralNormError.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.specs(circuit)()['errors']\n{'SpectralNormError': SpectralNormError(0.30000000000000004)}\n```\n\n----------------------------------------\n\nTITLE: Installing PennyLane with pip\nDESCRIPTION: This command installs PennyLane and its dependencies using pip, the Python package installer. It ensures that the latest version of PennyLane is installed and ready to use.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/README.md#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\npython -m pip install pennylane\n```\n\n----------------------------------------\n\nTITLE: Implementing Matrix Product State (MPS) Template\nDESCRIPTION: Shows how to implement quantum circuits with a Matrix Product State (MPS) tensor network structure in PennyLane. It defines a block function, specifies the number of wires and block wires, creates a device, and defines a quantum node (QNode) that uses the qml.MPS template to construct the circuit. Dependencies include NumPy and PennyLane's core modules.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ndef block(weights, wires):\n    qml.CNOT(wires=[wires[0], wires[1]])\n    qml.RY(weights[0], wires=wires[0])\n    qml.RY(weights[1], wires=wires[1])\n\nn_wires = 4\nn_block_wires = 2\nn_params_block = 2\ntemplate_weights = np.array([[0.1, -0.3], [0.4, 0.2], [-0.15, 0.5]], requires_grad=True)\n\ndev = qml.device(\"default.qubit\", wires=range(n_wires))\n\n@qml.qnode(dev)\ndef circuit(weights):\n    qml.MPS(range(n_wires), n_block_wires, block, n_params_block, weights)\n    return qml.expval(qml.PauliZ(wires=n_wires - 1))\n```\n\n----------------------------------------\n\nTITLE: State Gradient Error in PennyLane (Autograd)\nDESCRIPTION: This code demonstrates an error when attempting to differentiate the state directly using Autograd. It defines a quantum circuit and attempts to calculate the Jacobian of the state, which is not directly supported in Autograd without a scalar cost function, resulting in a ValueError.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndef state_vector_grad():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.state()\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.jacobian(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Circuit Cutting Example\nDESCRIPTION: Demonstrates a simple quantum circuit execution in PennyLane with circuit cutting support. It includes defining an input parameter `x`, executing the circuit with a specific value, and computing the gradient of the circuit output with respect to the input. The `qml.grad` function is used for differentiation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nx = np.array(0.531, requires_grad=True)\ncircuit(0.531)\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom PennyLane Template\nDESCRIPTION: This snippet showcases how to create a custom quantum template in PennyLane by defining a function that applies quantum gates. The example defines a `MyTemplate` function that applies an RX gate based on input parameters. The circuit is then defined using this custom template.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/templates.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\n\ndef MyTemplate(a, b, wires):\n    c = np.sin(a) + b\n    qml.RX(c, wires=wires[0])\n\nn_wires = 3\ndev = qml.device('default.qubit', wires=n_wires)\n\n@qml.qnode(dev)\ndef circuit(a, b):\n    MyTemplate(a, b, wires=range(n_wires))\n    return qml.expval(qml.PauliZ(0))\n\n# >>> circuit(2, 3)\n# -0.7195065654396784\n```\n\n----------------------------------------\n\nTITLE: Drawing a TorchLayer with PennyLane\nDESCRIPTION: This snippet demonstrates how to use `qml.draw()` to visualize a PennyLane `TorchLayer`. It prints a text-based representation of the quantum circuit within the `TorchLayer`, showing the operations and their corresponding wires. This requires the `inputs` variable to be defined from the previous example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_22\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(qlayer, show_matrices=False)(inputs))\n0: ─╭AngleEmbedding(M0)─╭BasicEntanglerLayers(M1)─┤  <Z>\n1: ─╰AngleEmbedding(M0)─╰BasicEntanglerLayers(M1)─┤  <Z>\n```\n\n----------------------------------------\n\nTITLE: List as Positional Argument for MultiRZ (Invalid) in PennyLane\nDESCRIPTION: This code snippet shows that using a standard Python list as the positional argument for the angles in the ``qml.MultiRZ`` operation is not valid when program capture is enabled. It demonstrates that passing a list directly will lead to a TypeError, while using a list as a keyword argument is acceptable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=2)\n@qml.qnode(dev)\ndef circuit():\n    qml.MultiRZ([0.1, 0.2], wires=[0, 1])\n    return qml.expval(qml.X(0))\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=2)\n@qml.qnode(dev)\ndef circuit():\n    qml.MultiRZ(theta=[0.1, 0.2], wires=[0, 1])\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Datasets with PennyLane\nDESCRIPTION: Shows how to create custom datasets using the `qml.data.Dataset` class in PennyLane.  The example demonstrates constructing a dataset with a Hamiltonian and corresponding energies. Requires PennyLane and NumPy.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> example_hamiltonian = qml.Hamiltonian(coeffs=[1,0.5], observables=[qml.PauliZ(wires=0),qml.PauliX(wires=1)])\n>>> example_energies, _ = np.linalg.eigh(qml.matrix(example_hamiltonian))\n>>> example_dataset = qml.data.Dataset(\n...\tdata_name = 'Example', hamiltonian=example_hamiltonian, energies=example_energies\n... )\n>>> example_dataset.data_name\n'Example'\n>>> example_dataset.hamiltonian\n  (0.5) [X1]\n+ (1) [Z0]\n>>> example_dataset.energies\narray([-1.5, -0.5,  0.5,  1.5])\n```\n\n----------------------------------------\n\nTITLE: Compute Jacobian with JAX in PennyLane\nDESCRIPTION: This snippet calculates the Jacobian of a PennyLane quantum circuit using JAX.  It uses the `jax.jacobian` function with `argnums` to specify the arguments with respect to which the Jacobian is computed.  Requires PennyLane, JAX, NumPy, and a previously defined quantum circuit `circuit`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> jax.jacobian(circuit, argnums=[0, 1])(a, b)\n((Array(0.35017549, dtype=float64, weak_type=True),\nArray(-0.4912955, dtype=float64, weak_type=True)),\n(Array(5.55111512e-17, dtype=float64, weak_type=True),\nArray(0., dtype=float64, weak_type=True)))\n```\n\n----------------------------------------\n\nTITLE: Reflect about a state using qml.Reflection (Python)\nDESCRIPTION: This code showcases the usage of the qml.Reflection operation. It defines an operator `U` (in this case, a Hadamard gate) that prepares a desired state, and then uses `qml.Reflection(U)` to reflect about that state within a quantum circuit. The circuit returns the final state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nU = qml.Hadamard(wires=0)\n\ndev = qml.device('default.qubit')\n@qml.qnode(dev)\ndef circuit():\n    qml.Reflection(U)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Using lightning.qubit Device in PennyLane\nDESCRIPTION: This snippet demonstrates how to use the lightning.qubit device, which is a fast state-vector simulator now included with PennyLane installations. It defines a quantum circuit with strongly entangling layers and calculates the expectation value of PauliZ on wire 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nwires = 3\nlayers = 2\ndev = qml.device(\"lightning.qubit\", wires=wires)\n\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef circuit(weights):\n    qml.templates.StronglyEntanglingLayers(weights, wires=range(wires))\n    return qml.expval(qml.PauliZ(0))\n\nweights = qml.init.strong_ent_layers_normal(layers, wires, seed=1967)\n```\n\n----------------------------------------\n\nTITLE: Constructing Molecules in PennyLane QChem\nDESCRIPTION: This code constructs a molecule using the `qml.qchem.Molecule` class, specifying the atomic symbols and geometry. The `load_data=True` argument enables loading basis set data from the `basis-set-exchange` package, requiring it to be installed. Dependencies: `numpy` and the `basis-set-exchange` package.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nsymbols  = ['Ti', 'Ti']\ngeometry = np.array([[0.0, 0.0, -1.1967],\n                    [0.0, 0.0,  1.1967]], requires_grad=True)\nmol = qml.qchem.Molecule(symbols, geometry, load_data=True)\n```\n\n----------------------------------------\n\nTITLE: Execution Config and Transforms in PennyLane (Python)\nDESCRIPTION: This code snippet shows the workflow for using the setup_execution_config, preprocess_transforms, and execute methods of a PennyLane device.  The initial_config is processed, a transform program is created and applied, and finally, the circuit batch is executed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nexecution_config = dev.setup_execution_config(initial_config)\n    transform_program = dev.preprocess_transforms(execution_config)\n    circuit_batch, postprocessing = transform_program(initial_circuit_batch)\n    results = dev.execute(circuit_batch, execution_config)\n    final_results = postprocessing(results)\n```\n\n----------------------------------------\n\nTITLE: Converting Pauli words to binary representation in PennyLane\nDESCRIPTION: This code demonstrates converting Pauli words to their binary symplectic vector space representation using `pauli_to_binary`.  It includes defining a wire map and converting two Pauli words into their binary vector representations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from pennylane.grouping import pauli_to_binary\n>>> from pennylane.wires import Wires\n>>> wire_map = {Wires('a'): 0, Wires('b'): 1}\n>>> pauli_vec_1 = pauli_to_binary(qml.PauliX('a') @ qml.PauliY('b'))\n>>> pauli_vec_2 = pauli_to_binary(qml.PauliZ('a') @ qml.PauliZ('b'))\n>>> pauli_vec_1\n[1. 1. 0. 1.]\n>>> pauli_vec_2\n[0. 0. 1. 1.]\n```\n\n----------------------------------------\n\nTITLE: Setuptools Entry Point Configuration\nDESCRIPTION: This code shows how to configure the setuptools entry points to expose a custom PennyLane device to the PennyLane library. It includes the short name and the path to the device class.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndevices_list = [\n        'example.mydevice1 = MyModule.MySubModule:MyDevice1'\n        'example.mydevice2 = MyModule.MySubModule:MyDevice2'\n    ],\nsetup(entry_points={'pennylane.plugins': devices_list})\n```\n\n----------------------------------------\n\nTITLE: Pattern Matching Optimization in PennyLane\nDESCRIPTION: Demonstrates the use of `qml.transforms.pattern_matching_optimization` to replace a sequence of two `pennylane.S` gates with a `pennylane.PauliZ` gate in a quantum circuit.  A quantum tape is used to define the pattern to be matched, and the optimization transform is applied to the circuit's quantum function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef circuit():\n    qml.S(wires=0)\n    qml.PauliZ(wires=0)\n    qml.S(wires=1)\n    qml.CZ(wires=[0, 1])\n    qml.S(wires=1)\n    qml.S(wires=2)\n    qml.CZ(wires=[1, 2])\n    qml.S(wires=2)\n    return qml.expval(qml.PauliX(wires=0))\n```\n\nLANGUAGE: python\nCODE:\n```\nwith qml.tape.QuantumTape() as pattern:\n    qml.S(wires=0)\n    qml.S(wires=0)\n    qml.PauliZ(wires=0)\n```\n\n----------------------------------------\n\nTITLE: Grouping Observables with PennyLane\nDESCRIPTION: This snippet demonstrates how to group observables using the `group_observables` function in PennyLane. It shows how to partition a list of observables into groupings based on a binary relation (e.g., qubit-wise commuting).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> import pennylane as qml\n>>> from pennylane.pauli import group_observables, PauliX, PauliY, PauliZ\n>>> observables = [qml.PauliY(0), qml.PauliX(0) @ qml.PauliX(1), qml.PauliZ(1)]\n>>> obs_groupings = group_observables(observables)\n>>> obs_groupings\n[[PauliX(wires=[0]) @ PauliX(wires=[1])],\n [PauliY(wires=[0]), PauliZ(wires=[1])]]\n```\n\n----------------------------------------\n\nTITLE: Hadamard Gradient Variant in PennyLane\nDESCRIPTION: This code demonstrates using the 'reversed-hadamard' differentiation method in PennyLane. It defines a simple quantum circuit and calculates its gradient with respect to a parameter.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev, diff_method=\"reversed-hadamard\")\ndef circuit(x):\n    qml.RX(x, 0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Constructing Fermi Sentences Directly in PennyLane\nDESCRIPTION: Demonstrates how to create Fermi sentences using the `qml.FermiSentence` class. Fermi sentences are constructed by passing a dictionary where the keys are Fermi words and the values are their corresponding coefficients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fermi.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> fw1 = qml.FermiWord({(0, 0): '+', (1, 0): '-'}) \n>>> fw2 = qml.FermiWord({(0, 3): '+', (1, 3): '-'}) \n>>> qml.FermiSentence({fw1: 1.2, fw2: 2.3})\n1.2 * a⁺(0) a(0)\n+ 2.3 * a⁺(3) a(3)\n```\n\n----------------------------------------\n\nTITLE: Adjoint Differentiation with device_vjp and probs in PennyLane\nDESCRIPTION: This code demonstrates adjoint differentiation using `device_vjp=True` to compute the gradient of a quantum circuit's probabilities. It showcases a situation where the adjoint method, combined with the device's vjp, is used to calculate the gradient of a scalar cost function dependent on the output probabilities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('default.qubit'), diff_method=\"adjoint\", device_vjp=True)\ndef circuit(x):\n    qml.IsingXX(x, wires=(0,1))\n    return qml.probs(wires=(0,1))\n\ndef cost(x):\n    probs = circuit(x)\n    target = np.array([0, 0, 0, 1])\n    return qml.math.norm(probs-target)\n```\n\n----------------------------------------\n\nTITLE: Decompose QuantumPhaseEstimation with Hadamard gate\nDESCRIPTION: This code snippet demonstrates the application of a Hadamard gate on target wires followed by the QuantumPhaseEstimation operation on the target and estimation wires. This sets up the quantum circuit for phase estimation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nqml.Hadamard(wires=target_wires)\nqml.QuantumPhaseEstimation(\n    unitary,\n    target_wires=target_wires,\n    estimation_wires=estimation_wires,\n)\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Quantum Tape Parameters in PennyLane\nDESCRIPTION: Demonstrates unwrapping parameters within a PennyLane QuantumTape using a context manager. This allows temporary access to the tape's parameters as NumPy arrays for operations that require them, while preserving the original parameter types outside the context.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_24\n\nLANGUAGE: pycon\nCODE:\n```\n>>> with tf.GradientTape():\n...     with qml.tape.QuantumTape() as tape:\n...         qml.RX(tf.Variable(0.1), wires=0)\n...         qml.RY(tf.constant(0.2), wires=0)\n...         qml.RZ(tf.Variable(0.3), wires=0)\n...     with tape.unwrap():\n...         print(\"Trainable params:\", tape.trainable_params)\n...         print(\"Unwrapped params:\", tape.get_parameters())\nTrainable params: {0, 2}\nUnwrapped params: [0.1, 0.3]\n>>> print(\"Original parameters:\", tape.get_parameters())\nOriginal parameters: [<tf.Variable 'Variable:0' shape=() dtype=float32, numpy=0.1>,\n  <tf.Variable 'Variable:0' shape=() dtype=float32, numpy=0.3>]\n```\n\n----------------------------------------\n\nTITLE: Differentiable Execution of Batches of Circuits in PennyLane\nDESCRIPTION: Illustrates the differentiable execution of batches of circuits using the `pennylane.interfaces.batch` module.  The code defines a cost function that executes two tapes in batch using `execute`, and computes the gradient of the cost function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.interfaces.batch import execute\n\ndef cost_fn(x):\n    with qml.tape.JacobianTape() as tape1:\n        qml.RX(x[0], wires=[0])\n        qml.RY(x[1], wires=[1])\n        qml.CNOT(wires=[0, 1])\n        qml.var(qml.PauliZ(0) @ qml.PauliX(1))\n\n    with qml.tape.JacobianTape() as tape2:\n        qml.RX(x[0], wires=0)\n        qml.RY(x[0], wires=1)\n        qml.CNOT(wires=[0, 1])\n        qml.probs(wires=1)\n\n    result = execute(\n        [tape1, tape2], dev,\n        gradient_fn=qml.gradients.param_shift,\n        interface=\"autograd\"\n    )\n    return result[0] + result[1][0, 0]\n\nres = qml.grad(cost_fn)(params)\n```\n\n----------------------------------------\n\nTITLE: Accessing Static Methods for Resource Estimation in PennyLane\nDESCRIPTION: This code demonstrates how to directly access the static methods `qubit_cost` and `gate_cost` of the `FirstQuantization` class to estimate resource requirements with specific parameters. It takes parameters such as the number of plane waves, number of electrons, unit cell volume, and accuracy as inputs and outputs the estimated qubit and gate costs respectively.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.resource.FirstQuantization.qubit_cost(100000, 156, 169.69608, 0.01)\n4377\n>>> qml.resource.FirstQuantization.gate_cost(100000, 156, 169.69608, 0.01)\n3676557345574\n```\n\n----------------------------------------\n\nTITLE: Executing Quantum Circuit with Counts Measurement\nDESCRIPTION: This code executes the previously defined quantum circuit that returns the counts measurement. The resulting dictionary shows the number of times each computational basis state was measured.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_31\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n{'00': 495, '11': 505}\n```\n\n----------------------------------------\n\nTITLE: Enable PennyLane Logging\nDESCRIPTION: This code demonstrates how to enable Python-native logging in PennyLane using qml.logging.enable_logging(). It creates a simple QNode and executes it to showcase the logging output. Dependencies: PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nqml.logging.enable_logging()  # enables logging\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef f(x):\n    qml.RX(x, wires=0)\n    return qml.state()\n\nf(0.5)\n```\n\n----------------------------------------\n\nTITLE: Converting FermiWord to Sparse Matrix\nDESCRIPTION: This code snippet demonstrates the use of the `to_mat` method for `qml.fermi.FermiWord` to convert it to a matrix representation. The `format` keyword argument allows specifying the output matrix format, such as 'dense' (NumPy array) or 'csr' (Compressed Sparse Row).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> w = qml.fermi.FermiWord({(0, 0) : '+', (1, 1) : '-'}) \n>>> w.to_mat(format=\"dense\")\narray([[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]])\n>>> w.to_mat(format=\"csr\")\n<4x4 sparse matrix of type '<class 'numpy.complex128'>'\n  with 1 stored elements in Compressed Sparse Row format>\n```\n\n----------------------------------------\n\nTITLE: Tensor product of Pauli matrices XZI in Python\nDESCRIPTION: This snippet computes the tensor product of Pauli matrices X, Z, and I (XZI) using NumPy's kron function. It converts the resulting dense matrix to a sparse CSR matrix using SciPy and prints the matrix along with its non-zero values and column indices. This illustrates how the sparse representation changes with each tensor product.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/pauli/pauli_sparse_matrices.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nXZI = np.kron(X, ZI)\nXZI_CSR = scipy.sparse.csr_matrix(XZI)\nprint(XZI)\nprint(f\"val: {XZI_CSR[XZI_CSR.nonzero()].tolist()[0]}\\ncol: {XZI_CSR.indices}\")\n```\n\n----------------------------------------\n\nTITLE: Installing PennyLane-Catalyst\nDESCRIPTION: This snippet shows the command to install the PennyLane-Catalyst plugin, which enables hybrid quantum-classical JIT compilation features. Requires pip.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\npip install pennylane-catalyst\n```\n\n----------------------------------------\n\nTITLE: Calculate Spectral Norm Error between Unitaries in PennyLane (Python)\nDESCRIPTION: This code demonstrates how to calculate the spectral norm error between two unitary operations using the SpectralNormError.get_error method. It imports pennylane and defines two RY operations with slightly different rotation angles to calculate the error between them.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane.resource import ErrorOperation, SpectralNormError\n\nintended_op = qml.RY(0.40, 0)\nactual_op = qml.RY(0.41, 0) # angle of rotation is slightly off\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Handlers in TOML\nDESCRIPTION: This TOML configuration snippet shows how to add a file handler (`qml_debug_file`) to the PennyLane logger.  By adding this handler, log output will be directed to both the standard output stream (`qml_debug_stream`) and a file named `qml_debug.log` in the execution directory. The logging level is also specified, which can be set to `TRACE` for maximum verbosity.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/logging.rst#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n# Control logging across pennylane\n[loggers.pennylane]\nhandlers = [\"qml_debug_stream\", \"qml_debug_file\"]\nlevel = \"DEBUG\" # Set to TRACE for highest verbosity\npropagate = false\n```\n\n----------------------------------------\n\nTITLE: One-Qubit Decomposition using PennyLane\nDESCRIPTION: This code demonstrates the usage of the `one_qubit_decomposition` transform in PennyLane to decompose a single-qubit unitary matrix into a sequence of rotations. It showcases how to specify the rotation basis and return the global phase.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from pennylane.transforms import one_qubit_decomposition\n>>> U = np.array([[-0.28829348-0.78829734j,  0.30364367+0.45085995j],\n...               [ 0.53396245-0.10177564j,  0.76279558-0.35024096j]])\n>>> one_qubit_decomposition(U, 0, \"ZYZ\")\n[RZ(tensor(12.32427531, requires_grad=True), wires=[0]),\n RY(tensor(1.14938178, requires_grad=True), wires=[0]),\n RZ(tensor(1.73305815, requires_grad=True), wires=[0])]\n>>> one_qubit_decomposition(U, 0, \"XYX\", return_global_phase=True)\n[RX(tensor(10.84535137, requires_grad=True), wires=[0]),\n RY(tensor(1.39749741, requires_grad=True), wires=[0]),\n RX(tensor(0.45246584, requires_grad=True), wires=[0]),\n (0.38469215914523336-0.9230449299422961j)*(Identity(wires=[0]))]\n```\n\n----------------------------------------\n\nTITLE: QAOA Layer Definition - Python\nDESCRIPTION: This code snippet defines a single layer of the QAOA ansatz using the cost and mixer Hamiltonians. It applies the `qaoa.cost_layer` and `qaoa.mixer_layer` functions, with `gamma` and `alpha` as variational parameters.  This layer forms the building block for the full QAOA circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Defines a layer of the QAOA ansatz from the cost and mixer Hamiltonians\ndef qaoa_layer(gamma, alpha):\n    qaoa.cost_layer(gamma, cost_h)\n    qaoa.mixer_layer(alpha, mixer_h)\n```\n\n----------------------------------------\n\nTITLE: Improved String Representation of ParametrizedHamiltonian in PennyLane\nDESCRIPTION: Shows the improved string representation of `ParametrizedHamiltonian`. It defines functions `f1` and `f2` and observables, then uses `qml.dot` to create a `ParametrizedHamiltonian` and displays its string representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> def f1(p, t): return p[0] * jnp.sin(p[1] * t)\n>>> def f2(p, t): return p * t\n>>> coeffs = [2., f1, f2]\n>>> observables =  [qml.PauliX(0), qml.PauliY(0), qml.PauliZ(0)]\n>>> qml.dot(coeffs, observables)\n  (2.0*(PauliX(wires=[0])))\n+ (f1(params_0, t)*(PauliY(wires=[0])))\n+ (f2(params_1, t)*(PauliZ(wires=[0])))\n```\n\n----------------------------------------\n\nTITLE: Installing and Using the lightning.qubit Device\nDESCRIPTION: Shows how to install and use the `lightning.qubit` device, an experimental C++ state-vector simulator for PennyLane. It uses the Eigen library for fast linear algebra calculations. The snippet demonstrates the installation via pip and the device initialization within PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n$ pip install pennylane-lightning\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"lightning.qubit\", wires=2)\n```\n\n----------------------------------------\n\nTITLE: HTML for Method Details Header\nDESCRIPTION: This HTML snippet creates a collapsible header for the method details section, similar to the attribute details header. It leverages Bootstrap classes to provide the collapsible functionality. It relies on Bootstrap's CSS and JavaScript for styling and behavior.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_7\n\nLANGUAGE: html\nCODE:\n```\n<a class=\"meth-details-header collapse-header\" data-toggle=\"collapse\" href=\"#methDetails\" aria-expanded=\"false\" aria-controls=\"methDetails\">\n   <h2 style=\"font-size: 24px;\">\n      <i class=\"fas fa-angle-down rotate\" style=\"float: right;\"></i> Methods\n   </h2>\n</a>\n<div class=\"collapse\" id=\"methDetails\">\n```\n\n----------------------------------------\n\nTITLE: Modifying a circuit mid-run with CNOT in PennyLane (PyCon)\nDESCRIPTION: This snippet demonstrates how to modify a quantum circuit mid-run using PennyLane operations, specifically the CNOT gate. It shows how to add a CNOT gate to a circuit and then prints a debug drawing of the resulting circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n[pldb] qml.CNOT(wires=(0,2))\nCNOT(wires=[0, 2])\n[pldb] print(qml.debug_tape().draw(wire_order=[0,1,2]))\n0: ──H─╭●─╭●─┤  \n2: ────╰X─╰X─┤  \n```\n\n----------------------------------------\n\nTITLE: QNode Execution with Example Input in Pycon\nDESCRIPTION: This code shows an example input to the QNode `f(x)` defined in the previous snippet and the corresponding output using `pycon`. It shows a tensor returned representing the expectation values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> f(0.4)\ntensor([0.89431013, 0.9510565 ], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Implement Quantum Circuit with Breakpoint for Debugging\nDESCRIPTION: Demonstrates the use of `qml.breakpoint()` within a quantum circuit to pause the simulation and enter an interactive debugging console. This allows for inspection of the circuit's state and operations during execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(qml.device('default.qubit', wires=(0,1,2)))\ndef circuit(x):\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=(0,2))\n    qml.breakpoint()\n\n    qml.RX(x, wires=1)\n    qml.RY(x, wires=2)\n    qml.breakpoint()\n\n    return qml.sample()\n\ncircuit(1.2345)\n```\n\n----------------------------------------\n\nTITLE: QNode with list indexing in while loop (error)\nDESCRIPTION: This code demonstrates an error when trying to index a standard Python list within a `while` loop inside a QNode. AutoGraph requires the object being indexed to be a JAX array. This results in a `TracerIntegerConversionError`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef f():\n    x = [0.1, 0.2, 0.3]\n    i = 0\n    while i < 3:\n        qml.RX(x[i], wires=i)\n        i += 1\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Add autosummary table (reStructuredText)\nDESCRIPTION: This snippet demonstrates how to add an autosummary table to the ``__init__.py`` docstring using the ``literalinclude`` directive. This table will contain all modules within the package, enabling easy navigation and discovery of the package's structure in the documentation. The ``:language: rest`` directive specifies that the included file contains reStructuredText.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_6\n\nLANGUAGE: rest\nCODE:\n```\n.. literalinclude:: example_module_autosummary.txt\n    :language: rest\n```\n\n----------------------------------------\n\nTITLE: SciPy Optimization with Gradient Computation\nDESCRIPTION: This snippet enhances the previous example by including gradient information in the SciPy optimization process. It utilizes PennyLane's qml.grad function to compute the gradient of the cost function and passes it to the scipy.optimize.minimize function using the 'jac' keyword argument.  The `argnum` keyword specifies which arguments are trainable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/numpy.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nminimize(cost, params, method='BFGS', jac=qml.grad(cost, argnum=0))\n```\n\n----------------------------------------\n\nTITLE: State Gradient with Torch Interface in PennyLane\nDESCRIPTION: This code demonstrates the use of the Torch interface to differentiate the quantum state directly. This example shows how using a complex-number interface (JAX, TensorFlow, or Torch) supports backpropagation through the quantum state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef state_vector_grad_torch():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, interface='torch', diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.state()\n\n    x = torch.tensor([0.1], requires_grad=True, dtype=torch.complex64)\n    print(torch.autograd.functional.jacobian(circuit, (x,)))\n```\n\n----------------------------------------\n\nTITLE: Calculating Fourier Coefficients\nDESCRIPTION: This code calculates the Fourier coefficients of a quantum circuit using the `coefficients` function from `pennylane.fourier`.  It takes the quantum circuit, the length of the input vector, and the maximum frequency as input, and returns an array of Fourier coefficients.  The coefficients are then rounded for readability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.fourier import coefficients\n>>> coeffs = coefficients(simple_circuit, 1, 2)\n>>> print(np.round(coeffs, decimals=4))\n```\n\n----------------------------------------\n\nTITLE: Using jax.vmap for Parameter Broadcasting in PennyLane\nDESCRIPTION: Demonstrates how to use jax.vmap to handle parameter broadcasting with program capture enabled in PennyLane. This is a best practice to avoid compatibility issues when dealing with multiple parameters. It requires the jax and pennylane libraries.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \nimport jax\n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Comparing Unequal Observables and Hamiltonians in PennyLane\nDESCRIPTION: This code snippet demonstrates the `compare()` method when the Hamiltonian and observable are not equivalent. It defines a Hamiltonian `H` and an observable `obs` with different Pauli operators on different wires, then compares them, resulting in `False`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> H = qml.Hamiltonian([2], [qml.PauliZ(0)])\n>>> obs = qml.PauliZ(1) @ qml.Identity(0)\n>>> print(H.compare(obs))\nFalse\n```\n\n----------------------------------------\n\nTITLE: Using LieAlgebraOptimizer in PennyLane\nDESCRIPTION: This code snippet showcases the `LieAlgebraOptimizer`, a quantum-aware optimizer in PennyLane.  It initializes a quantum device and defines a quantum circuit with RX, RY, and CNOT gates.  The optimizer is then used to optimize the circuit without explicitly defined parameters, growing the circuit during the optimization process.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\nH = -1.0 * qml.PauliX(0) - qml.PauliZ(1) - qml.PauliY(0) @ qml.PauliX(1)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.RX(0.1, wires=[0])\n    qml.RY(0.5, wires=[1])\n    qml.CNOT(wires=[0,1])\n    qml.RY(0.6, wires=[0])\n    return qml.expval(H)\nopt = qml.LieAlgebraOptimizer(circuit=circuit, stepsize=0.1)\n```\n\n----------------------------------------\n\nTITLE: Tapering Hartree-Fock State\nDESCRIPTION: Illustrates how to taper the Hartree-Fock (HF) state for quantum chemistry algorithms using PennyLane, which involves transforming the initial HF state to act on a reduced number of qubits. It leverages previously determined symmetries to perform the transformation. Dependencies include the generators and pauli operators from the Hamiltonian symmetry analysis.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nn_elec = mol.n_electrons\nn_qubits = mol.n_orbitals * 2\n\nhf_tapered = qml.hf.transform_hf(\n    generators, paulix_ops, opt_sector, n_elec, n_qubits\n)\n```\n\n----------------------------------------\n\nTITLE: Inspecting Resources of Custom Operation in PennyLane\nDESCRIPTION: Shows how to create an instance of the `CustomOp` defined in the previous snippet and inspect its resource requirements using the `resources()` method. This allows for verification of the defined resource estimates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> wires = [0, 1, 2]\n>>> c = CustomOp(wires)\n>>> c.resources()\nwires: 3\ngates: 9\ndepth: 5\nshots: Shots(total=None)\ngate_types:\n{}\ngate_sizes:\n{}\n```\n\n----------------------------------------\n\nTITLE: QAOA Cost Function Definition - Python\nDESCRIPTION: This code snippet defines the QAOA cost function using a PennyLane device and a QNode. It executes the `circuit` function with the given parameters and returns the expected value of the cost Hamiltonian `cost_h`. The `@qml.qnode` decorator compiles the quantum function for execution on the specified device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Defines the device and the QAOA cost function\ndev = qml.device('default.qubit', wires=len(wires))\n@qml.qnode(dev)\ndef cost_function(params):\n    circuit(params)\n    return qml.expval(cost_h)\n```\n\n----------------------------------------\n\nTITLE: Scatter Element Addition in PennyLane with TensorFlow\nDESCRIPTION: This snippet demonstrates the usage of `qml.math.scatter_element_add` for adding multiple values at multiple indices in a tensor. The function supports all interfaces, including TensorFlow, JAX, and NumPy.  This functionality extends previous versions by adding several values at once.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nX = tf.zeros((3, 2, 9), dtype=tf.float64)\nindices = [(0, 0, 1, 2, 2), (0, 0, 0, 0, 1), (1, 3, 8, 6, 7)]\nvalues = [1 * i for i in range(1,6)]\nqml.math.scatter_element_add(X, indices, values)\n```\n\n----------------------------------------\n\nTITLE: Compute Grouping After Construction\nDESCRIPTION: Demonstrates how to compute or change the grouping of a `Sum` operator after its initial construction, utilizing the `compute_grouping` method. This allows for dynamically adjusting the grouping type and method based on the current context or computational requirements.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\na = qml.X(0)\nb = qml.prod(qml.X(0), qml.X(1))\nc = qml.Z(0)\nobs = [a, b, c]\ncoeffs = [1.0, 2.0, 3.0]\n\nop = qml.dot(coeffs, obs)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> op.grouping_indices is None\nTrue\n>>> op.compute_grouping(grouping_type=\"qwc\")\n>>> op.grouping_indices\n((2,), (0, 1))\n```\n\n----------------------------------------\n\nTITLE: Adding Operators to Existing Attributes in PennyLane\nDESCRIPTION: This code snippet shows how to dynamically add a new operator to an existing PennyLane attribute, like `self_inverses`. This allows users to extend the functionality of PennyLane and optimize device implementations by informing the system about the specific properties of their custom operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.ops.qubits.attributes import self_inverses\n>>> self_inverses.add(\"MyGate\")\n```\n\n----------------------------------------\n\nTITLE: Creating QuantumScript from a Queued Function\nDESCRIPTION: Demonstrates how to capture a quantum function using AnnotatedQueue and convert it into a QuantumScript. The quantum function is queued into the AnnotatedQueue, and then QuantumScript.from_queue is used to create the script.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_tape.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nwith qml.queuing.AnnotatedQueue() as q:\n    qfunc(*args, **kwargs)\nQuantumScript.from_queue(q)\n```\n\n----------------------------------------\n\nTITLE: QNode probabilities output\nDESCRIPTION: This shows the output of the previously defined QNode after applying the JAX compiled circuit with the specified x and y parameters.  The output is an array of probabilities for the two basis states. This snippet demonstrates the result of executing the JAX-compiled QNode defined earlier.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_12\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(x, y)\nArray([0.8397495 , 0.16025047], dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Executing AllSinglesDoubles Circuit in Python\nDESCRIPTION: This snippet demonstrates the execution of the previously defined quantum circuit using the `AllSinglesDoubles` template. It shows how to call the circuit with the required parameters and obtain the expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(params, hf_state, singles=singles, doubles=doubles)\ntensor(-0.73772194, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Create Controlled Gate Sequences with ControlledSequence\nDESCRIPTION: This code demonstrates the use of the `ControlledSequence` operator in PennyLane to create controlled gate sequences raised to decreasing powers. The operator is used to implement a sub-block in quantum phase estimation. The example shows how to create a circuit using the ControlledSequence operator with the specified controlled unitary operator and control wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires = 4)\n\n@qml.qnode(dev)\ndef circuit():\n    for i in range(3):\n        qml.Hadamard(wires = i)\n    qml.ControlledSequence(qml.RX(0.25, wires = 3), control = [0, 1, 2])\n    qml.adjoint(qml.QFT)(wires = range(3))\n    return qml.probs(wires = range(3))\n```\n\n----------------------------------------\n\nTITLE: Inspecting Noise Model (Python)\nDESCRIPTION: This snippet shows how to inspect the created `qml.NoiseModel` and verify that it contains the specified gate noise and readout noise mappings. The output visually confirms the structure of the noise model.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> noise_model\nNoiseModel({\n  WiresIn([0, 2]): RY(phi=-0.42)\n},\nmeas_map = {\n    MeasEq(expval): PhaseFlip(p=0.2)\n})\n```\n\n----------------------------------------\n\nTITLE: Using the PauliRot gate in PennyLane\nDESCRIPTION: This snippet demonstrates the usage of the `PauliRot` gate in PennyLane, which performs an arbitrary Pauli rotation on multiple qubits. The function `circuit` returns the expectation value of PauliZ on each wire. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=4)\n\n@qml.qnode(dev)\ndef circuit(angle):\n    qml.PauliRot(angle, \"IXYZ\", wires=[0, 1, 2, 3])\n    return [qml.expval(qml.PauliZ(wire)) for wire in [0, 1, 2, 3]]\n```\n\n----------------------------------------\n\nTITLE: While loop variable assignment in test statement (ignored)\nDESCRIPTION: This code demonstrates that variable assignments made within the test condition of a `while` loop are ignored by AutoGraph. The function `fn` attempts to update `i` within the test condition, but this update is not captured during AutoGraph conversion.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_31\n\nLANGUAGE: python\nCODE:\n```\ndef fn(limit):\n    i = 0\n    y = 0\n    while (i := y) < limit:\n        y += 1\n    return i\n```\n\n----------------------------------------\n\nTITLE: VQE with Hamiltonian Observable (Python)\nDESCRIPTION: Demonstrates setting up a VQE problem by passing a `qml.Hamiltonian` object directly as an observable to the QNode. It illustrates how to define the Hamiltonian and the circuit with entangling layers. Requires PennyLane installation and a device defined.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\nH = qml.Hamiltonian([1., 2., 3.],  [qml.PauliZ(0), qml.PauliY(0), qml.PauliZ(1)])\nw = qml.init.strong_ent_layers_uniform(1, 2, seed=1967)\n\n@qml.qnode(dev)\ndef circuit(w):\n    qml.templates.StronglyEntanglingLayers(w, wires=range(2))\n    return qml.expval(H)\n```\n\n----------------------------------------\n\nTITLE: Decompose transform with control flow error\nDESCRIPTION: Illustrates a potential error when using the decompose transform with operators that contain control flow (e.g., if statements) when program capture is enabled. Specifically, it demonstrates the problem with RandomLayers and provides a workaround.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \nimport jax.numpy as jnp\n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.transforms.decompose\n@qml.qnode(dev)\ndef circuit(weights, arg):\n    qml.RandomLayers(weights, wires=[0, 1], ratio_imprim=arg)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Register Custom CNOT Decomposition with Resources\nDESCRIPTION: This code snippet demonstrates how to register a custom CNOT decomposition using Hadamard and CZ gates and associates resource requirements with it (2 Hadamard gates, 1 CZ gate). This is used within the graph-based decomposition system to determine resource efficiency.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n@qml.register_resources({qml.H: 2, qml.CZ: 1})\ndef my_cnot(wires, **__):\n    qml.H(wires=wires[1])\n    qml.CZ(wires=wires)\n    qml.H(wires=wires[1])\n```\n\n----------------------------------------\n\nTITLE: Saving and Loading Custom Datasets\nDESCRIPTION: Illustrates how to save and load custom datasets using the `write()` and `read()` methods of the `qml.data.Dataset` class. This enables persistence and reuse of custom quantum datasets. Requires PennyLane and a custom dataset.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> example_dataset.write('./path/to/dataset.dat')\n>>> read_dataset = qml.data.Dataset()\n>>> read_dataset.read('./path/to/dataset.dat')\n>>> read_dataset.data_name\n'Example'\n>>> read_dataset.hamiltonian\n  (0.5) [X1]\n+ (1) [Z0]\n>>> read_dataset.energies\narray([-1.5, -0.5,  0.5,  1.5])\n```\n\n----------------------------------------\n\nTITLE: Using QuantumTape Context Manager for Recording Quantum Operations\nDESCRIPTION: This example shows how to use `qml.tape.QuantumTape` and `tape.stop_recording()` to control the recording of quantum operations in PennyLane. It demonstrates how to temporarily stop recording operations within a tape using the `stop_recording()` context manager.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nwith qml.tape.QuantumTape():\n    qml.RX(0, wires=0)\n    current_tape = qml.tape.get_active_tape()\n    with current_tape.stop_recording():\n        qml.RY(1.0, wires=1)\n    qml.RZ(2, wires=1)\n```\n\n----------------------------------------\n\nTITLE: Sample Gradient (Incorrect) in PennyLane\nDESCRIPTION: This code demonstrates an incorrect calculation of the gradient when attempting to backpropagate through samples. The example showcases that attempting to compute the gradient in this scenario will not raise an error, but the results will be incorrect.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef sample_backward():\n    dev = qml.device('default.qubit', wires=1, shots=20)\n\n    @qml.qnode(dev)\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.sample(wires=0)\n\n    x = np.array([np.pi / 2])\n    print(qml.jacobian(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Capturing QNode without AutoGraph\nDESCRIPTION: This code demonstrates capturing the QNode that uses explicit control flow constructs (previous example) with AutoGraph disabled. The `autograph=False` argument is passed to `make_plxpr` to prevent AutoGraph from being used during capture.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nplxpr = make_plxpr(cost, autograph=False)(weights, data)\njax.core.eval_jaxpr(plxpr.jaxpr, plxpr.consts, weights, data)\n```\n\n----------------------------------------\n\nTITLE: Manually Validating Sampled Properties of QuantumScript\nDESCRIPTION: Illustrates how to manually validate if measurements in a `QuantumScript` are sampled, replacing the removed `QuantumScript.is_sampled` and `QuantumScript.all_sampled` properties.  This requires importing measurement types from `pennylane.measurements`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.measurements import *\nsample_types = (SampleMP, CountsMP, ClassicalShadowMP, ShadowExpvalMP)\nis_sample_type = [isinstance(m, sample_types) for m in tape.measurements]\nis_sampled = any(is_sample_type)\nall_sampled = all(is_sample_type)\n```\n\n----------------------------------------\n\nTITLE: Executing a Batch of Quantum Tapes\nDESCRIPTION: This code showcases how to execute a batch (tuple or list) of multiple quantum tapes. The result is a tuple where each entry represents the result for the corresponding tape.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntape1 = qml.tape.QuantumScript([qml.X(0)], [qml.state()])\ntape2 = qml.tape.QuantumScript([qml.Hadamard(0)], [qml.counts()], shots=100)\ntape3 = qml.tape.QuantumScript([], [qml.expval(qml.Z(0)), qml.expval(qml.X(0))])\nbatch = (tape1, tape2, tape3)\nqml.device('default.qubit').execute(batch)\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Measurement with SampleMeasurement in PennyLane\nDESCRIPTION: This code defines a custom measurement process using PennyLane's `SampleMeasurement` class. It creates a `CountState` class that inherits from `SampleMeasurement` and counts the number of samples obtained for a specific state. This allows for customized measurement strategies within PennyLane's quantum computations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.measurements import SampleMeasurement\n\nclass CountState(SampleMeasurement):\n    def __init__(self, state: str):\n        self.state = state  # string identifying the state, e.g. \"0101\"\n        wires = list(range(len(state)))\n        super().__init__(wires=wires)\n\n    def process_samples(self, samples, wire_order, shot_range, bin_size):\n        counts_mp = qml.counts(wires=self._wires)\n        counts = counts_mp.process_samples(samples, wire_order, shot_range, bin_size)\n        return counts.get(self.state, 0)\n\n    def __copy__(self):\n        return CountState(state=self.state)\n```\n\n----------------------------------------\n\nTITLE: Calculating Operator Matrix within a QNode\nDESCRIPTION: Demonstrates the error that occurs when trying to compute the matrix of an operator inside a QNode using qml.matrix with program capture enabled. This highlights a limitation in directly calculating matrices within the QNode. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n    mat = qml.matrix(qml.X(0))\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Comparing Observables and Hamiltonians in PennyLane\nDESCRIPTION: This code snippet shows how to use the `compare()` method to check if an observable is equivalent to a Hamiltonian in PennyLane. It defines a Hamiltonian `H` and an observable `obs` and compares them using `H.compare(obs)`, printing the boolean result.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> H = qml.Hamiltonian([1], [qml.PauliZ(0)])\n>>> obs = qml.PauliZ(0) @ qml.Identity(1)\n>>> print(H.compare(obs))\nTrue\n```\n\n----------------------------------------\n\nTITLE: Combined Expectation Value and Counts Measurement in PennyLane\nDESCRIPTION: This code shows how to return both expectation values and counts from a single QNode. This is useful for cases where differentiability is needed for the expectation values but counts are also required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/measurements.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=0)\n    qml.CNOT(wires=[0,1])\n    qml.X(1)\n    return qml.expval(qml.PauliZ(0)),qml.expval(qml.PauliZ(1)), qml.counts()\n```\n\n----------------------------------------\n\nTITLE: Replacing qml.ExpvalCost with qml.expval\nDESCRIPTION: Shows how to use `qml.expval()` within a QNode to define a cost function, replacing the deprecated `qml.ExpvalCost`. This demonstrates the recommended approach for defining cost functions in newer PennyLane versions. Requires the `Hamiltonian` to be defined elsewhere.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef cost_function(params):\n    some_qfunc(params)\n    return qml.expval(Hamiltonian)\n```\n\n----------------------------------------\n\nTITLE: Extract Block-Encoded Matrix from Quantum Circuit (Pycon)\nDESCRIPTION: This interactive python console snippet shows how to extract the block-encoded matrix from the quantum circuit created using qml.FABLE. It calculates the matrix representation of the circuit and extracts the relevant submatrix, demonstrating the block-encoding process.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> mat = qml.matrix(circuit)()\n>>> 2 * mat[0:2, 0:2]\narray([[0.1+0.j, 0.2+0.j],\n       [0.3+0.j, 0.4+0.j]])\n```\n\n----------------------------------------\n\nTITLE: Higher-Order Primitives with Adjoint (Unsupported) in PennyLane\nDESCRIPTION: This code demonstrates the use of a higher-order primitive (qml.ctrl) within a QNode when using the adjoint differentiation method. This is currently unsupported with program capture and will raise an error.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\",wires=2)\n\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef f(x):\n    qml.ctrl(qml.RX, control=0)(x, 1)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Creating a Keras Layer from a PennyLane QNode\nDESCRIPTION: This snippet demonstrates how to convert a PennyLane QNode into a Keras layer using the `KerasLayer` class. This enables the creation of hybrid quantum-classical models using the Keras API. It requires PennyLane and TensorFlow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.qnn import KerasLayer\n\n@qml.qnode(dev)\ndef circuit(inputs, weights_0, weight_1):\n   # define the circuit\n   # ...\n\nweight_shapes = {\"weights_0\": 3, \"weight_1\": 1}\nqlayer = qml.qnn.KerasLayer(circuit, weight_shapes, output_dim=2)\n```\n\n----------------------------------------\n\nTITLE: Computing Atomic and Molecular Orbitals in PennyLane\nDESCRIPTION: This snippet demonstrates how to compute the values of atomic and molecular orbitals at a given position using the `atomic_orbital` and `molecular_orbital` functions. These functions can be used to evaluate the orbitals at different positions, enabling the plotting of the spatial shape of orbitals. This example sets up a Hydrogen molecule and calculates atomic and molecular orbital values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nsymbols  = ['H', 'H']\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.0]], requires_grad = False)\nmol = hf.Molecule(symbols, geometry)\nhf.generate_scf(mol)()\n\nao = mol.atomic_orbital(0)\nmo = mol.molecular_orbital(1)\n```\n\n----------------------------------------\n\nTITLE: Circuit Drawing with Inverted Operations\nDESCRIPTION: This snippet showcases the updated circuit drawer in PennyLane, which now displays inverted operations and wires where probabilities are returned from the device. It defines a simple quantum circuit with an inverted S gate and uses `qml.probs` to return probabilities, demonstrating the new visualization capabilities. The `qml.draw()` method is used to generate the circuit diagram as a string.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circuit(theta):\n...     qml.RX(theta, wires=0)\n...     qml.CNOT(wires=[0, 1])\n...     qml.S(wires=1).inv()\n...     return qml.probs(wires=[0, 1])\n>>> circuit(0.2)\narray([0.99003329, 0.        , 0.        , 0.00996671])\n>>> print(circuit.draw())\n0: ──RX(0.2)──╭C───────╭┤ Probs\n1: ───────────╰X──S⁻¹──╰┤ Probs\n```\n\n----------------------------------------\n\nTITLE: DoubleExcitation Operation in PennyLane\nDESCRIPTION: This code demonstrates the usage of the `qml.DoubleExcitation` operation in PennyLane, which is useful for quantum chemistry applications. It creates a quantum circuit with the `DoubleExcitation` gate and performs an SO(2) rotation in the subspace spanned by the states :math:`|1100\\rangle` and :math:`|0011\\rangle`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(phi):\n    qml.PauliX(wires=0)\n    qml.PauliX(wires=1)\n    qml.DoubleExcitation(phi, wires=[0, 1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Using convert_to_numpy_parameters in PennyLane\nDESCRIPTION: This code snippet demonstrates how to use `convert_to_numpy_parameters` to unwrap parameters in a QuantumScript, replacing the deprecated `tape.unwrap()` method. It imports the necessary function from `pennylane.transforms`, creates a `QuantumTape`, and then unwraps it to convert the parameters to NumPy arrays. This ensures compatibility with later versions of PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.transforms import convert_to_numpy_parameters\n\nqscript = qml.tape.QuantumTape([qml.RX(torch.tensor(0.1234), 0)],\n                                     [qml.expval(qml.Hermitian(torch.eye(2), 0))] )\nunwrapped_qscript = convert_to_numpy_parameters(qscript)\n\ntorch_params = qscript.get_parameters()\nnumpy_params = unwrapped_qscript.get_parameters()\n```\n\n----------------------------------------\n\nTITLE: Using Execution Configuration in PennyLane\nDESCRIPTION: This example shows how to construct and print the execution configuration for a PennyLane circuit. The `qml.workflow.construct_execution_config` function takes a QNode and its arguments and returns an ExecutionConfig object. This object holds information like the gradient method, device options, and interface used for the circuit's execution. The printed output shows the configuration details.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_27\n\nLANGUAGE: pycon\nCODE:\n```\n>>> config = qml.workflow.construct_execution_config(circuit)(1)\n>>> print(config)\nExecutionConfig(grad_on_execution=False,\n                use_device_gradient=True,\n                use_device_jacobian_product=False,\n                gradient_method='backprop',\n                gradient_keyword_arguments={},\n                device_options={'max_workers': None,\n                                'prng_key': None,\n                                'rng': Generator(PCG64) at 0x15F6BB680},\n                interface=<Interface.NUMPY: 'numpy'>,\n                derivative_order=1,\n                mcm_config=MCMConfig(mcm_method=None, postselect_mode=None),\n                convert_to_numpy=True)\n```\n\n----------------------------------------\n\nTITLE: Obtaining Frequency Spectra\nDESCRIPTION: Demonstrates how to obtain the frequency spectra of a quantum node (QNode) using `qml.fourier.qnode_spectrum`. This information is crucial for utilizing the generalized `RotosolveOptimizer`. The QNode and input parameters must be defined beforehand.  This is a key step in the generalized Rotosolve optimization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nspectra = qml.fourier.qnode_spectrum(qnode)(x, Y)\n```\n\n----------------------------------------\n\nTITLE: Dynamical Lie Algebra Computation\nDESCRIPTION: This code snippet demonstrates how to compute the dynamical Lie algebra from a set of generators using qml.lie_closure. It defines a set of generators (Pauli operators) and then computes the Lie closure to obtain the dynamical Lie algebra. It relies on pennylane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import X, Y, Z, I\nn = 2\ngens = [qml.X(0), qml.X(0) @ qml.X(1), qml.Y(1)]\ndla = qml.lie_closure(gens)\n```\n\n----------------------------------------\n\nTITLE: XXZ Model Hamiltonian Construction in PennyLane\nDESCRIPTION: This snippet demonstrates how to construct the spin-1/2 XXZ model Hamiltonian using PauliWord objects in PennyLane. It shows how to define the Hamiltonian terms and sum them to create the overall Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_pauli.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nn = 4\nJ_orthogonal = 1.5\nops = [\n    J_orthogonal * (PauliWord({i:\"X\", (i+1)%n:\"X\"}) + PauliWord({i:\"Y\", (i+1)%n:\"Y\"}))\n    for i in range(n)\n]\n\nJ_zz = 0.5\nops += [J_zz * PauliWord({i:\"Z\", (i+1)%n:\"Z\"}) for i in range(n)]\n\nh = 2.\nops += [h * PauliWord({i:\"Z\"}) for i in range(n)]\n\nH = sum(ops)\n```\n\n----------------------------------------\n\nTITLE: Analytic Device Result Demonstration in PennyLane\nDESCRIPTION: This example shows the output when executing a QNode on a device initialized with `shots=None`. The output is deterministic and represents the exact expectation value calculated analytically. The example demonstrates that repeated calls produce the same result.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit_analytic()\n0.0\n>>> circuit_analytic()\n0.0\n```\n\n----------------------------------------\n\nTITLE: Evaluating pwc Function\nDESCRIPTION: This example demonstrates how to evaluate the piecewise constant function created by `qml.pulse.pwc`.  The `params` array provides the bin values, and `t` determines which bin's value is returned. Values outside the defined timespan return zero.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_28\n\nLANGUAGE: pycon\nCODE:\n```\n>>> f(params=[1.2, 2.3, 3.4, 4.5], t=3.9)\nDeviceArray(4.5, dtype=float32)\n>>> f(params=[1.2, 2.3, 3.4, 4.5], t=6)  # zero outside the range (2, 4)\nDeviceArray(0., dtype=float32)\n```\n\n----------------------------------------\n\nTITLE: Enabling QNode caching in PennyLane\nDESCRIPTION: This code illustrates how to enable QNode caching by passing a `caching` argument to the QNode decorator.  This allows the QNode to reuse the results of previous device executions, improving performance. Note that caching is only supported in tape mode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\nqml.enable_tape()\n\n@qml.qnode(dev, caching=10)  # cache up to 10 evaluations\ndef qfunc(x):\n    qml.RX(x, wires=0)\n    qml.RX(0.3, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(1))\n\nqfunc(0.1)  # first evaluation executes on the device\nqfunc(0.1)  # second evaluation accesses the cached result\n```\n\n----------------------------------------\n\nTITLE: Creating Fermionic Operators with qml.qchem.excitations\nDESCRIPTION: This code shows how to use the `fermionic` keyword argument of the `qml.qchem.excitations` function to obtain fermionic operators. When set to `True`, the function returns a list of `FermiWord` objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> singles, doubles = excitations(electrons, orbitals, fermionic=True)\n>>> print(singles)\n[FermiWord({(0, 0): '+', (1, 2): '-'}), FermiWord({(0, 1): '+', (1, 3): '-'})]\n```\n\n----------------------------------------\n\nTITLE: Creating a QNode Explicitly\nDESCRIPTION: This code snippet demonstrates how to explicitly create a QNode in PennyLane. It imports the numpy library and then creates a QNode object by passing the `my_quantum_function` (previously defined) and the `dev_unique_wires` device (previously initialized with custom wire labels) to the `qml.QNode` constructor. This binds the quantum function to the specified device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\ncircuit = qml.QNode(my_quantum_function, dev_unique_wires)\n```\n\n----------------------------------------\n\nTITLE: Add package documentation (reStructuredText)\nDESCRIPTION: This snippet demonstrates how to include content from a separate reStructuredText file, specifically for package documentation. The ``literalinclude`` directive is used to embed the contents of `example_package_rst.txt` into the documentation. The ``:language: rest`` directive ensures correct parsing as reStructuredText.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_7\n\nLANGUAGE: rest\nCODE:\n```\n.. literalinclude:: example_package_rst.txt\n    :language: rest\n```\n\n----------------------------------------\n\nTITLE: Parameter-Shift Hessian Result\nDESCRIPTION: This snippet shows the output of the hessian computation. Since `argnum` is an identity matrix, only the diagonal elements of the Hessian are calculated. This is used as an optimization when only the diagonal elements are needed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.gradients.param_shift_hessian(circuit, argnum=argnum)(x)\ntensor([[-0.09928388,  0.        ,  0.        ],\n        [ 0.        , -0.27633945,  0.        ],\n        [ 0.        ,  0.        , -0.09928388]], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Circuit Drawing with Program Capture\nDESCRIPTION: This example illustrates the potential issues with using qml.draw or qml.draw_mpl with program capture enabled. The output may not accurately represent the circuit's structure or parameter values.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\n\nqml.capture.enable()\n\n\n@qml.transforms.merge_rotations\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2))\n\ndef f(x):\n\n    qml.X(0)\n\n    qml.X(0)\n\n    qml.RX(x, 0)\n\n    qml.RX(x, 0)\n```\n\n----------------------------------------\n\nTITLE: Getting Tensor Interface with qml.math.get_interface in Python\nDESCRIPTION: This code snippet demonstrates how to use `qml.math.get_interface` to determine the interface of multiple tensors. The function now accepts a variable number of arguments, one for each tensor, to dispatch the interface determination.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_34\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.math.get_interface(*[torch_scalar, torch_tensor, numpy_tensor])\n'torch'\n>>> qml.math.get_interface(torch_scalar, torch_tensor, numpy_tensor)\n'torch'\n```\n\n----------------------------------------\n\nTITLE: Accessing Nodes in a PennyLane CommutationDAG\nDESCRIPTION: This code snippet demonstrates how to access nodes and their properties within a CommutationDAG using the `get_nodes()` and `get_node()` methods. It shows how to retrieve node information such as the operation represented by the node, its successors, and its predecessors. This is useful for analyzing the commutation relationships between operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> nodes = dag.get_nodes()\n>>> nodes\nNodeDataView({0: <pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x7f461c4bb580>, ...}, data='node')\n\n>>> second_node = dag.get_node(2)\n>>> second_node\n<pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x136f8c4c0>\n>>> second_node.op\nCNOT(wires=[1, 2])\n>>> second_node.successors\n[3, 4, 5, 6]\n>>> second_node.predecessors\n[]\n```\n\n----------------------------------------\n\nTITLE: Defining an Oracle for Grover's Algorithm in PennyLane\nDESCRIPTION: Defines an oracle that marks the 'all ones' state with a negative sign using Hadamard and Toffoli gates. This is a crucial component for implementing Grover's search algorithm in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nn_wires = 3\nwires = list(range(n_wires))\n\ndef oracle():\n    qml.Hadamard(wires[-1])\n    qml.Toffoli(wires=wires)\n    qml.Hadamard(wires[-1])\n```\n\n----------------------------------------\n\nTITLE: Wires Union using Python\nDESCRIPTION: Demonstrates how to perform union operations on `Wires` instances using the `union()` method or the `|` operator. It showcases how to combine the wire labels from two Wires objects into a single Wires object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> wires1 = Wires([1, 2, 3])\n>>> wires2 = Wires([2, 3, 4])\n>>> wires1.union(wires2) # or wires1 | wires2\nWires([1, 2, 3, 4])\n```\n\n----------------------------------------\n\nTITLE: In-QNode Classical Processing with TensorFlow\nDESCRIPTION: Demonstrates differentiable classical processing within a QNode using TensorFlow. Defines a quantum circuit that includes a classical TensorFlow operation and returns the expectation value of a PauliZ observable.  Requires PennyLane and TensorFlow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev, interface=\"tf\")\ndef circuit(p):\n    qml.RX(tf.sin(p[0])**2 + p[1], wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Clifford+T Decomposition in PennyLane\nDESCRIPTION: This snippet demonstrates how to decompose a quantum circuit into the Clifford+T gateset using the `qml.clifford_t_decomposition()` transform in PennyLane.  It uses the Solovay-Kitaev algorithm to approximately decompose the circuit. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\")\n\n@qml.qnode(dev)\ndef circuit():\n    qml.RX(1.1, 0)\n    return qml.state()\n\ncircuit = qml.clifford_t_decomposition(circuit, epsilon=0.1)\n```\n\n----------------------------------------\n\nTITLE: Determining Abstracted Axes for JAXPR Compilation\nDESCRIPTION: This function, `determine_abstracted_axes`, takes a tree structure of arguments and determines which axes are dynamic (abstracted) based on the type of the shape elements.  If a shape element is an integer, it's considered static; otherwise, it's considered dynamic and assigned a letter from the alphabet. The result is the corresponding abstract shape for each input argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nalphabet = \"abcdefghijklmnop\"\ndef determine_abstracted_axes(args):\n    \n    leaves, structure = jax.tree_util.tree_flatten(args)\n    abstracted_axes = []\n    abstract_shapes = []\n    \n    for l in leaves:\n        l_shape = []\n        for s in l.shape:\n            if isinstance(s, int): # not abstract\n                l_shape.append(()) # maybe this should be empty tuple?\n            else:\n                l_shape.append(alphabet[len(abstract_shapes)])\n                abstract_shapes.append(s)\n        abstracted_axes.append(tuple(l_shape) if len(l_shape) != 1 else l_shape[0]) # maybe ?\n    abstracted_axes = jax.tree_util.tree_unflatten(structure, abstracted_axes)\n    return abstracted_axes, abstract_shapes\n```\n\n----------------------------------------\n\nTITLE: Partitioning Pauli words into anticommutative groupings in PennyLane\nDESCRIPTION: This snippet showcases how to partition Pauli words into anticommutative groupings using the `group_observables` function and the Recursive Largest First (RLF) graph coloring heuristic.  It demonstrates how to define a list of Pauli words and then group them based on anticommutativity.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import PauliX, PauliY, PauliZ, Identity\nfrom pennylane.grouping import group_observables\npauli_words = [\n    Identity('a') @ Identity('b'),\n    Identity('a') @ PauliX('b'),\n    Identity('a') @ PauliY('b'),\n    PauliZ('a') @ PauliX('b'),\n    PauliZ('a') @ PauliY('b'),\n    PauliZ('a') @ PauliZ('b')\n]\ngroupings = group_observables(pauli_words, grouping_type='anticommuting', method='rlf')\n```\n\n----------------------------------------\n\nTITLE: Circuit Drawer with Unused Wires\nDESCRIPTION: Demonstrates the updated circuit drawer's ability to include unused or inactive wires by passing the `show_all_wires` argument. The example defines a quantum circuit and then uses the circuit drawer to visualize it, including all wires, even those not directly involved in any operations.  Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=[-1, \"a\", \"q2\", 0])\n\n@qml.qnode(dev)\ndef circuit():\n    qml.Hadamard(wires=-1)\n    qml.CNOT(wires=[-1, \"q2\"])\n    return qml.expval(qml.PauliX(wires=\"q2\"))\n```\n\n----------------------------------------\n\nTITLE: Import OpenQASM Circuit into PennyLane\nDESCRIPTION: This code demonstrates how to import a quantum circuit defined in OpenQASM 2.0 into PennyLane using `qml.from_qasm`. It then defines a QNode that executes the imported circuit and returns the expectation value of `Y(0)` and the variance of `Z(1)`.  The PennyLane-Qiskit plugin is needed as it is used to parse the OpenQASM.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\npl_qfunc_from_oq = qml.from_qasm(oq_circuit)\n\n@qml.qnode(qml.device(\"default.qubit\"))\ndef pl_circuit_from_oq():\n    pl_qfunc_from_oq(wires=[0, 1])\n    return qml.expval(qml.Y(0)), qml.var(qml.Z(1))\n```\n\n----------------------------------------\n\nTITLE: Inspecting QuantumTape Shape and Numeric Type\nDESCRIPTION: This code snippet demonstrates how to inspect the shape and numeric type of a `QuantumTape` object's output, given a specified device. It assumes the tape object has been defined and populated with a quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> tape.shape(dev)\n(1, 4)\n>>> tape.numeric_type\ncomplex\n```\n\n----------------------------------------\n\nTITLE: Defining Hamiltonian as Sum of Observables in PennyLane\nDESCRIPTION: This snippet demonstrates how to define a Hamiltonian as a sum of observables using PennyLane. It creates a Hamiltonian `H` by combining PauliZ and PauliX operators and a Hamiltonian term. The resulting Hamiltonian is then printed, showing its composition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> H = 3 * qml.PauliZ(0) - (qml.PauliX(0) @ qml.PauliX(1)) + qml.Hamiltonian([4], [qml.PauliZ(0)])\n>>> print(H)\n(7.0) [Z0] + (-1.0) [X0 X1]\n```\n\n----------------------------------------\n\nTITLE: PyTorch Interface with Parameter-Shift Differentiation in PennyLane\nDESCRIPTION: This snippet demonstrates how to use the PyTorch interface with parameter-shift differentiation method in PennyLane. It defines a quantum circuit with two parameters, executes it, and calculates the Jacobian using `torch.autograd.functional.jacobian`. Requires PennyLane, PyTorch.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nimport torch\n\nqml.enable_return()\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"torch\")\ndef circuit(a, b):\n    qml.RY(a, wires=0)\n    qml.RX(b, wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.PauliZ(0)), qml.probs([0, 1])\n```\n\n----------------------------------------\n\nTITLE: Differentiable Group Observables Transform in PennyLane with JAX\nDESCRIPTION: Shows how to use the differentiable `group_observables` transform in PennyLane with JAX. The code defines a function `group` that applies the transform and returns grouped coefficients, then computes its Jacobian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport jax\nfrom jax import numpy as jnp\n\ncoeffs = jnp.array([1., 2., 3.])\nobs = [PauliX(wires=0), PauliX(wires=1), PauliZ(wires=1)]\n\ndef group(coeffs, select=None):\n  _, grouped_coeffs = qml.grouping.group_observables(obs, coeffs)\n  # in this example, grouped_coeffs is a list of two jax tensors\n  # [Array([1., 2.], dtype=float32), Array([3.], dtype=float32)]\n  return grouped_coeffs[select]\n\njac_fn = jax.jacobian(group)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Composite Operators in PennyLane\nDESCRIPTION: This snippet demonstrates how to simplify composite operators using the simplify() method or the qml.simplify() function in PennyLane. Simplification reduces the number of terms in the operator by combining like terms. Simplification does not happen in-place, so the original operator remains unchanged.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n>>> op = 0.5 * X(0) + 0.5 * Y(0) - 1.5 * X(0) - 0.5 * Y(0) # no simplification by default\n>>> op.simplify()\n-1.0 * X(0)\n>>> qml.simplify(op)\n-1.0 * X(0)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> op\n(\n    0.5 * X(0)\n  + 0.5 * Y(0)\n  + -1 * 1.5 * X(0)\n  + -1 * 0.5 * Y(0)\n)\n```\n\n----------------------------------------\n\nTITLE: Marking Input-Encoding Gates in a Quantum Circuit\nDESCRIPTION: This code demonstrates how to mark input-encoding gates in a quantum circuit using the 'id' parameter. This is necessary for calculating the frequencies supported by the circuit. The circuit applies RX and RY rotations with the id 'x', followed by a CNOT gate, and measures the expectation value of PauliZ on qubit 0.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef simple_circuit_marked(x):\n    qml.RX(x[0], wires=0, id=\"x\")\n    qml.RY(x[0], wires=1, id=\"x\")\n    qml.CNOT(wires=[1, 0])\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Comparing Parametric Operators with qml.equal\nDESCRIPTION: This code showcases the use of `qml.equal` to compare the equality of parametric operators. It compares two identical `RX` gates and two different `RY` gates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.equal(qml.RX(1.23, 0), qml.RX(1.23, 0))\nTrue\n>>> qml.equal(qml.RY(4.56, 0), qml.RY(7.89, 0))\nFalse\n```\n\n----------------------------------------\n\nTITLE: Executing Transformed Circuit in PennyLane\nDESCRIPTION: This code demonstrates the execution of a transformed quantum circuit using PennyLane.  The circuit is decorated with the `scale_shots` transform, effectively doubling the number of shots used for sampling. The example showcases the seamless integration of transform programs with QNodes and their impact on circuit execution results.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(shots=1)\narray([False, False])\n```\n\n----------------------------------------\n\nTITLE: Executing Circuit with Multiple Measurements and New Return Type\nDESCRIPTION: This code executes a quantum circuit with multiple measurements, utilizing the experimental return type. The circuit returns a tuple of tensors representing different measurement types.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_35\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(0.5)\n(tensor([0.5, 0.5], requires_grad=True), tensor(0.08014815, requires_grad=True), tensor([0.5, 0.5], requires_grad=True), tensor(0.93879128, requires_grad=True))\n```\n\n----------------------------------------\n\nTITLE: JIT Compiling with Control Flow using AutoGraph\nDESCRIPTION: Illustrates the use of the `autograph=True` keyword argument in `@qml.qjit` to capture imperative Python control flow in compiled programs. The control flow is interpreted at runtime.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n@qml.qjit(autograph=True)\n@qml.qnode(dev)\ndef circuit(x: int):\n\n    if x < 5:\n        qml.Hadamard(wires=0)\n    else:\n        qml.T(wires=0)\n\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Listing Available Datasets\nDESCRIPTION: This code shows how to use the `qml.data.list_datasets` function to get a nested dictionary representing the available datasets and their structures. It then accesses and prints the keys of different levels of the dictionary.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\navailable_data = qml.data.list_datasets()\navailable_data.keys()\navailable_data[\"qchem\"].keys()\navailable_data['qchem']['H2'].keys()\nprint(available_data['qchem']['H2']['STO-3G'])\n```\n\n----------------------------------------\n\nTITLE: Setting Module Name with Jinja2\nDESCRIPTION: This snippet dynamically sets the module name (`mod`) based on the provided module. It checks the length of the module split by '.' and joins the parts, prefixing it with 'qml.' if needed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary_core/base.rst#_snippet_1\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% if module.split(\".\")[1:] | length >= 1 %}\n\t{% set mod = module.split(\".\")[1:] | join(\".\") %}\n\t{% set mod = \"qml.\" + mod %}\n{% else %}\n\t{% set mod = \"qml\" %}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Sphinx Autoclass Directive for Class Documentation\nDESCRIPTION: This snippet uses the Sphinx autoclass directive to automatically generate documentation for a specified class. The `:show-inheritance:` option displays the class's inheritance hierarchy. This assumes Sphinx is configured correctly to find and parse the class definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_2\n\nLANGUAGE: jinja\nCODE:\n```\n.. autoclass:: {{ fullname }}\n   :show-inheritance:\n```\n\n----------------------------------------\n\nTITLE: QNode with JAX array indexing in while loop\nDESCRIPTION: This code shows how to properly index an array within a `while` loop using AutoGraph by converting the list to a JAX array. The QNode `f` then applies an RX gate to each of the three qubits based on values from the JAX array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef f():\n    x = jnp.array([0.1, 0.2, 0.3])\n    i = 0\n    while i < 3:\n        qml.RX(x[i], wires=i)\n        i += 1\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Executing Measurements in PennyLane\nDESCRIPTION: This code demonstrates how different quantum measurements (probs, expval, counts, sample) result in different data types returned by the PennyLane device execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef example_value(m):\n    tape = qml.tape.QuantumScript((), (m,), shots=50)\n    return qml.device('default.qubit').execute(tape)\n\nexample_value(qml.probs(wires=0))\nexample_value(qml.expval(qml.Z(0)))\nexample_value(qml.counts(wires=0))\nexample_value(qml.sample(wires=0))\n```\n\n----------------------------------------\n\nTITLE: Trace Distance Calculation via QNode Transform in PennyLane\nDESCRIPTION: Demonstrates trace distance calculation as a QNode transform using `qml.qinfo.trace_distance`.  A quantum circuit is defined, and then the trace distance between two instances of the circuit with different parameters is calculated.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit(param):\n    qml.RY(param, wires=0)\n    qml.CNOT(wires=[0, 1])\n    return qml.state()\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> trace_distance_circuit = qml.qinfo.trace_distance(circuit, circuit, wires0=[0], wires1=[0])\n>>> x, y = np.array(0.4), np.array(0.6)\n>>> trace_distance_circuit((x,), (y,))\n0.047862689546603415\n```\n\n----------------------------------------\n\nTITLE: Output of Clifford Circuit in Tableau Form\nDESCRIPTION: This is the expected output of the 'circuit()' function when executed with the 'default.clifford' device in PennyLane. The output is the state of the system represented in the Tableau form.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\narray([[0, 1, 1, 0, 0],\n       [1, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0],\n       [1, 0, 0, 1, 1]])\n```\n\n----------------------------------------\n\nTITLE: Define Repeat Function\nDESCRIPTION: Defines a function `repeat` that repeats a given function `func` a specified number of times `n`. It returns a new function that executes the input function `n` times.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef repeat(func: Callable, n: int) -> Callable:\n    def new_func(*args, **kwargs):\n        for _ in range(n):\n            args = func(*args, **kwargs)\n        return args\n    return new_func\n```\n\n----------------------------------------\n\nTITLE: Using the Rotoselect Optimizer\nDESCRIPTION: This snippet demonstrates the use of the `RotoselectOptimizer` to optimize a quantum function with respect to both parameters and rotation operations. It requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nopt = qml.optimize.RotoselectOptimizer()\nx = [0.3, 0.7]\ngenerators = [qml.RX, qml.RY]\nfor _ in range(100):\n    x, generators = opt.step(f, x, generators)\n```\n\n----------------------------------------\n\nTITLE: QNode Sampling (Python)\nDESCRIPTION: Demonstrates how to return computational basis samples directly from a QNode using `qml.sample()`. The first example returns samples for all wires, and the second example returns samples for specified wires. Requires PennyLane installation and a QNode defined with a compatible device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3, shots=5)\n\n@qml.qnode(dev)\ndef circuit_1():\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    return qml.sample()\n\n@qml.qnode(dev)\ndef circuit_2():\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    return qml.sample(wires=[0,2])    # no observable provided and wires specified\n```\n\n----------------------------------------\n\nTITLE: Accessing Tensor Product Terms Using op.operands\nDESCRIPTION: This snippet shows how to access the terms of a tensor product using the `op.operands` attribute, replacing the deprecated `op.obs` attribute. This is relevant when migrating from older PennyLane versions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nop = X(0) @ X(1)\nassert op.operands == (X(0), X(1))\n```\n\n----------------------------------------\n\nTITLE: String Representations of PennyLane Operators\nDESCRIPTION: This snippet demonstrates the improved string representations of PennyLane operators, which are shorter and can be copied and pasted as valid PennyLane code. It shows how sums with many terms are broken up into multiple lines for readability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> 0.5 * X(0)\n0.5 * X(0)\n>>> 0.5 * (X(0) + Y(1))\n0.5 * (X(0) + Y(1))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> 0.5 * (X(0) @ X(1)) + 0.7 * (X(1) @ X(2)) + 0.8 * (X(2) @ X(3))\n(\n    0.5 * (X(0) @ X(1))\n  + 0.7 * (X(1) @ X(2))\n  + 0.8 * (X(2) @ X(3))\n)\n```\n\n----------------------------------------\n\nTITLE: Generating Pauli Basis Strings for Special Unitary Operation in Pycon\nDESCRIPTION: This snippet demonstrates how to generate Pauli basis strings for use with the `qml.SpecialUnitary` operation. It shows the output for 1 and 2 wires, demonstrating the lexicographical order of the Pauli words.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_4\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.ops.qubit.special_unitary.pauli_basis_strings(1) # 4**1-1 = 3 Pauli words\n['X', 'Y', 'Z']\n>>> qml.ops.qubit.special_unitary.pauli_basis_strings(2) # 4**2-1 = 15 Pauli words\n['IX', 'IY', 'IZ', 'XI', 'XX', 'XY', 'XZ', 'YI', 'YX', 'YY', 'YZ', 'ZI', 'ZX', 'ZY', 'ZZ']\n```\n\n----------------------------------------\n\nTITLE: Integrating Qualtran Bloqs with PennyLane\nDESCRIPTION: This code shows how to integrate Qualtran bloqs into PennyLane circuits using qml.FromBloq. It applies a CNOT gate from Qualtran in a PennyLane circuit and returns the state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom qualtran.bloqs.basic_gates import CNOT\n\n>>> dev = qml.device(\"default.qubit\")\n>>> @qml.qnode(dev)\n... def circuit():\n...    qml.X(wires=0)\n...    qml.FromBloq(CNOT(), wires=[0, 1])\n...    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Calculating Operator Matrix within a QNode (Alternative Syntax)\nDESCRIPTION: Demonstrates the error that occurs when trying to compute the matrix of an operator inside a QNode using qml.matrix with program capture enabled, using an alternative syntax. This highlights a limitation in directly calculating matrices within the QNode. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n    mat = qml.matrix(qml.X)(0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: QubitDevice Execute Method\nDESCRIPTION: This code snippet demonstrates the default execution process of the QubitDevice.execute method in PennyLane. It checks the validity of operations and observables, applies the circuit operations, generates computational basis samples if shots are requested, computes the required statistics, and returns the results as an array.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nself.check_validity(circuit.operations, circuit.observables)\n\n# apply all circuit operations\nself.apply(circuit.operations, rotations=circuit.diagonalizing_gates)\n\n# generate computational basis samples\nif self.shots is not None or circuit.is_sampled:\n    self._samples = self.generate_samples()\n\n# compute the required statistics\nresults = self.statistics(circuit)\n\nreturn self._asarray(results)\n```\n\n----------------------------------------\n\nTITLE: Deprecating a Feature with a Warning Message in Python\nDESCRIPTION: This code snippet demonstrates how to add a deprecation warning to a feature in PennyLane. It uses the `warnings.warn` function to inform users about the upcoming removal of the feature and suggests an alternative.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/deprecations_removals.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwarnings.warn(\n    \"<name-of-feature> is deprecated and will be removed in version <target-version>. \"\n    \"Instead, please use <name-of-preferred-way-to-achieve-functionality>.\",\n    qml.PennyLaneDeprecationWarning,\n)\n```\n\n----------------------------------------\n\nTITLE: Evaluating captured QNode with AutoGraph\nDESCRIPTION: This code snippet showcases how to evaluate the captured PennyLane QNode (from the previous snippet) using AutoGraph and `eval_jaxpr`. It initializes the input data (`weights` and `data`), creates the `plxpr` representation, and then evaluates the resulting JAX expression.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nweights = jnp.linspace(-1, 1, 20).reshape([5, 4])\ndata = jnp.ones([4])\nplxpr = make_plxpr(cost)(weights, data)\neval_jaxpr(plxpr.jaxpr, plxpr.consts, weights, data)\n```\n\n----------------------------------------\n\nTITLE: Creating Fermionic Operators from String in PennyLane\nDESCRIPTION: Illustrates how to create a fermionic operator using `qml.fermi.from_string` by passing a string that represents multiple creation and annihilation operators being multiplied by each other. The string uses symbols like '+' for creation and '-' for annihilation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.fermi.from_string('0+ 1- 0+ 1-')\na⁺(0) a(1) a⁺(0) a(1)\n>>> qml.fermi.from_string('0^ 1 0^ 1')\na⁺(0) a(1) a⁺(0) a(1)\n```\n\n----------------------------------------\n\nTITLE: Creating a Multi-Controlled T Gate Using ControlledQubitUnitary\nDESCRIPTION: This snippet demonstrates how to create a multi-controlled T gate using the `ControlledQubitUnitary` operation in PennyLane. It shows how to apply the T gate to a target qubit based on the state of multiple control qubits. The `control_values` argument specifies the required states of the control qubits for the gate to be applied.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nT = qml.T._matrix()\nqml.ControlledQubitUnitary(T, control_wires=[0, 1, 3], wires=2, control_values=\"110\")\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Dynamic Shapes\nDESCRIPTION: This snippet generates a JAXPR for a function that creates an array of ones with a given shape. With dynamic shapes enabled, the JAXPR can handle dynamic sizes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\njax.make_jaxpr(f)(3)\n```\n\n----------------------------------------\n\nTITLE: Initializing Parameters with BasicEntanglerLayers in PennyLane\nDESCRIPTION: This snippet demonstrates how to initialize the parameters for the BasicEntanglerLayers template in PennyLane. It shows how to use the `shape` method to determine the required shape of the weight tensor and then create random weights using NumPy. The circuit is then executed with these weights.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/templates.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane.templates import BasicEntanglerLayers\nfrom pennylane import numpy as np\n\nn_wires = 3\ndev = qml.device('default.qubit', wires=n_wires)\n\n@qml.qnode(dev)\ndef circuit(weights):\n    BasicEntanglerLayers(weights=weights, wires=range(n_wires))\n    return qml.expval(qml.PauliZ(0))\n\nshape = BasicEntanglerLayers.shape(n_layers=2, n_wires=n_wires)\nnp.random.seed(42)  # to make the result reproducible\nweights = np.random.random(size=shape)\n\n# >>> circuit(weights)\n# tensor(0.72588592, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: QAOA Cost and Mixer Hamiltonian Generation in Python\nDESCRIPTION: This snippet demonstrates how to use the `qml.qaoa.max_weight_cycle` function to generate cost and mixer Hamiltonians for solving the maximum-weighted cycle problem using QAOA. It requires the `networkx` library for graph creation and uses PennyLane's `qml.qaoa` module. The snippet outputs the cost Hamiltonian and a mapping dictionary.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> a = np.random.random((3, 3))\n>>> np.fill_diagonal(a, 0)\n>>> g = nx.DiGraph(a)  # create a random directed graph\n>>> cost, mixer, mapping = qml.qaoa.max_weight_cycle(g)\n>>> print(cost)\n  (-0.9775906842165344) [Z2]\n+ (-0.9027248603361988) [Z3]\n+ (-0.8722207409852838) [Z0]\n+ (-0.6426184210832898) [Z5]\n+ (-0.2832594164291379) [Z1]\n+ (-0.0778133996933755) [Z4]\n>>> print(mapping)\n{0: (0, 1), 1: (0, 2), 2: (1, 0), 3: (1, 2), 4: (2, 0), 5: (2, 1)}\n```\n\n----------------------------------------\n\nTITLE: Projector Expectation Value Computation\nDESCRIPTION: This code calculates the expectation value of the projector for different input states. It computes the expectation value of the projector for both the zero state and the plus-plus state. Requires `circuit` function and state definitions from the previous snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_25\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit(zero_state)\ntensor(1., requires_grad=True)\n>>> circuit(plusplus_state)\ntensor(0.25, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Drawing decomposed circuit in PennyLane\nDESCRIPTION: This code demonstrates how to visualize the decomposed quantum circuit using `qml.draw`.  It prints the sequence of quantum gates equivalent to the original `QubitUnitary` gate after decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_3\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)())\n0: ──RX(0.00)──RY(1.57)──RX(3.14)──GlobalPhase(-1.57)─┤  <Z>\n```\n\n----------------------------------------\n\nTITLE: QuantumScript with Repeated Operation\nDESCRIPTION: Illustrates how QuantumScript can efficiently store and reuse the same operation multiple times in a circuit, reducing memory footprint. The same T gate is repeated 100 times in the QuantumScript.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_tape.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nop = qml.T(0)\nQuantumScript([op] * 100, [qml.probs(wires=0)])\n```\n\n----------------------------------------\n\nTITLE: Device Caching Example in PennyLane\nDESCRIPTION: Illustrates how to create a PennyLane device with caching enabled. The `cache` argument specifies the size of the cache, which improves performance by storing and reusing quantum circuit evaluations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2, cache=10)\n```\n\n----------------------------------------\n\nTITLE: Old Multi Dispatch Decorator Usage in PennyLane\nDESCRIPTION: This code demonstrates the old method of handling multiple dispatches using `qml.math._multi_dispatch`. The new `qml.math.multi_dispatch` is preferred and should be used for new functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> def some_function(tensor1, tensor2, option):\n...     interface = qml.math._multi_dispatch([tensor1, tensor2])\n...     ...\n```\n\n----------------------------------------\n\nTITLE: Differentiable Qubit Reuse Circuit\nDESCRIPTION: This snippet calculates the gradient of the qubit reuse circuit defined above using JAX. It showcases that qubit reuse and reset are fully differentiable in PennyLane. Dependencies: PennyLane, JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\n>>> jax.grad(circuit)(0.4)\nArray(-0.35867804, dtype=float32, weak_type=True)\n```\n\n----------------------------------------\n\nTITLE: Output of SelectPauliRot circuit in PennyLane\nDESCRIPTION: This code shows the expected output from the `SelectPauliRot` circuit defined above. It displays the state vector resulting from the quantum computation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit())\n[0.87758256+0.j 0.47942554+0.j 0.        +0.j 0.        +0.j\n 0.        +0.j 0.        +0.j 0.        +0.j 0.        +0.j]\n```\n\n----------------------------------------\n\nTITLE: Executing a Single Tape with Multiple Measurements\nDESCRIPTION: This code showcases executing a single quantum tape with multiple measurements. The result is a tuple where each entry corresponds to the respective measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntape = qml.tape.QuantumScript((), (qml.expval(qml.Z(0)), qml.probs(wires=0), qml.state()))\nqml.device('default.qubit').execute(tape)\n```\n\n----------------------------------------\n\nTITLE: Creating Mixed State Device with Readout Error\nDESCRIPTION: This code demonstrates creating a `default.mixed` device with readout error. It initializes a device with 2 wires and a `readout_prob` of 0.1. A quantum node is defined to return the expectation value of `PauliZ(0)`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_26\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.mixed\", wires=2, readout_prob=0.1)\n>>> @qml.qnode(dev)\n... def circuit():\n...     return qml.expval(qml.PauliZ(0))\n>>> circuit()\narray(0.8)\n```\n\n----------------------------------------\n\nTITLE: Projector Observable Expectation Value Calculation for |11> in Python\nDESCRIPTION: This snippet calculates the expectation value of the `qml.Projector` observable for the |11> basis state. It's similar to the previous example but uses a different basis state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> basis_state = [1, 1]\n>>> circuit(basis_state)\ntensor(0.5, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Dot Product of Coefficients and Operators\nDESCRIPTION: This snippet demonstrates the use of `qml.dot` to compute the dot product between a vector of coefficients and a list of PennyLane operators.  The `pauli=True` argument creates Pauli operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_31\n\nLANGUAGE: pycon\nCODE:\n```\n>>> coeffs = np.array([1.1, 2.2])\n>>> ops = [qml.PauliX(0), qml.PauliY(0)]\n>>> qml.dot(coeffs, ops)\n(1.1*(PauliX(wires=[0]))) + (2.2*(PauliY(wires=[0])))\n>>> qml.dot(coeffs, ops, pauli=True)\n1.1 * X(0) + 2.2 * Y(0)\n```\n\n----------------------------------------\n\nTITLE: Instantiate QNode Directly from Qiskit Circuit with Measurements\nDESCRIPTION: This snippet shows how to instantiate a PennyLane QNode directly from a Qiskit circuit, specifying the measurements to be performed. The `measurements` argument overrides any terminal measurements defined within the Qiskit circuit itself. This approach integrates Qiskit circuits seamlessly into PennyLane's quantum computing workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nmeasurements = [qml.expval(qml.Y(0)), qml.var(qml.Z(1))]\npl_qfunc_from_qk = qml.from_qiskit(qk_circuit, measurements=measurements)\npl_circuit_from_qk = qml.QNode(pl_qfunc_from_qk, qml.device(\"default.qubit\"))\n```\n\n----------------------------------------\n\nTITLE: Backpropagation Error with shots > 0 in PennyLane\nDESCRIPTION: This code demonstrates the error that arises when using backpropagation with a device that has shots greater than zero.  Backpropagation is an analytic method and only supports ``shots=None``, when this is not the case a QuantumFunctionError will be raised. The example defines a quantum circuit and attempts to calculate its gradient using qml.grad.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef print_grad():\n    dev = qml.device('default.qubit', wires=1, shots=100)\n\n    @qml.qnode(dev, diff_method='backprop')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.expval(qml.Z(wires=0))\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Compiling with Default Transforms using qml.compile in PennyLane\nDESCRIPTION: This code demonstrates the use of the `@qml.compile` decorator to apply a sequence of default transforms to a quantum function. The default transforms include `commute_controlled`, `cancel_inverses`, and `merge_rotations`.  It shows how PennyLane can automatically optimize a quantum circuit by applying these transforms to simplify gate sequences and improve performance.  A default qubit device is initialized and used to define the quantum node.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=[0, 1, 2])\n\n@qml.compile\n@qml.qnode(dev)\ndef circuit(x, y, z):\n    qml.Hadamard(wires=0)\n    qml.Hadamard(wires=1)\n    qml.Hadamard(wires=2)\n    qml.RZ(z, wires=2)\n    qml.CNOT(wires=[2, 1])\n    qml.RX(z, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RX(x, wires=0)\n    qml.CNOT(wires=[1, 0])\n    qml.RZ(-z, wires=2)\n    qml.RX(y, wires=2)\n    qml.Y(wires=2)\n    qml.CZ(wires=[1, 2])\n    return qml.expval(qml.Z(wires=0))\n\n>>> print(qml.draw(circuit)(0.2, 0.3, 0.4))\n```\n\n----------------------------------------\n\nTITLE: Replacing Operation.inv() with qml.adjoint in PennyLane\nDESCRIPTION: This code snippet demonstrates how to replace the deprecated `Operation.inv()` method with `qml.adjoint` for inverting quantum operations in PennyLane. It is a breaking change that requires users to update their code accordingly.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_33\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.PauliX(0).inv()\n```\n\n----------------------------------------\n\nTITLE: Accessing Operator Terms in PennyLane\nDESCRIPTION: Illustrates how to obtain scalar coefficients and tensor product operators from a PennyLane operator using the `op.terms()` method. The `terms` method returns a tuple of coefficients and operators.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/new_opmath.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> coeffs, ops = op1.terms()\n>>> coeffs, ops\n([0.5, 0.5], [X(1) @ X(0), Y(1) @ Y(0)])\n```\n\n----------------------------------------\n\nTITLE: Decomposing Toffoli gate with symbolic operators\nDESCRIPTION: This code demonstrates the use of symbolic operators (e.g., `Adjoint`) in the `gate_set` argument of the `decompose` transform when the graph-based decomposition system is enabled. It decomposes a Toffoli gate into T, Adjoint(T), H, and CNOT gates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nfrom functools import partial\nimport pennylane as qml\n\nqml.decomposition.enable_graph()\n \n@partial(qml.transforms.decompose, gate_set={\"T\", \"Adjoint(T)\", \"H\", \"CNOT\"})\n@qml.qnode(qml.device(\"default.qubit\"))\ndef circuit():\n    qml.Toffoli(wires=[0, 1, 2])\n```\n\n----------------------------------------\n\nTITLE: Getting Transform Program (PyCon)\nDESCRIPTION: Demonstrates how to get the transform program applied to a QNode using `qml.workflow.get_transform_program`. This allows you to inspect the sequence of transforms that are applied to the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.workflow.get_transform_program(f)\nTransformProgram(merge_rotations, cancel_inverses, split_non_commuting, validate_device_wires, mid_circuit_measurements, decompose, validate_measurements, validate_observables, no_sampling)\n```\n\n----------------------------------------\n\nTITLE: Simplifying Hamiltonians in PennyLane\nDESCRIPTION: This example illustrates the `simplify()` method for Hamiltonians in PennyLane. It constructs a Hamiltonian `H` with redundant terms and then simplifies it using `H.simplify()`. The simplified Hamiltonian is printed, demonstrating the combination of like terms.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\n>>> H = qml.Hamiltonian([1, 2], [qml.PauliZ(0), qml.PauliZ(0) @ qml.Identity(1)])\n>>> H.simplify()\n>>> print(H)\n(3.0) [Z0]\n```\n\n----------------------------------------\n\nTITLE: Drawing Toffoli gate decomposition in PennyLane\nDESCRIPTION: This code showcases how to visualize the decomposed Toffoli gate circuit using `qml.draw()`. The output displays the circuit implemented with T, Adjoint(T), H, and CNOT gates, representing the decomposition of the Toffoli gate.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_6\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)())\n0: ───────────╭●───────────╭●────╭●──T──╭●─┤  \n1: ────╭●─────│─────╭●─────│───T─╰X──T†─╰X─┤  \n2: ──H─╰X──T†─╰X──T─╰X──T†─╰X──T──H────────┤\n```\n\n----------------------------------------\n\nTITLE: Output state after reflecting about a given state (Pycon)\nDESCRIPTION: This interactive python console snippet shows the output state after reflecting about a given state using the qml.Reflection operation. The expected output is a tensor representing the state vector.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> circuit()\ntensor([0.-6.123234e-17j, 1.+6.123234e-17j], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Projector Observable Expectation Value Calculation in Python\nDESCRIPTION: This snippet calculates the expectation value of the `qml.Projector` observable for the |00> basis state.  It demonstrates calling the quantum circuit with the specified basis state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> basis_state = [0, 0]\n>>> circuit(basis_state)\ntensor(0.5, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Checking diagonal property of operation in PennyLane\nDESCRIPTION: This example demonstrates how to check if an operation is diagonal in the Z basis using the `diagonal_in_z_basis` attribute in PennyLane. Custom operations can be added to this attribute at runtime.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.ops.qubit.attributes import diagonal_in_z_basis\n\nif op in diagonal_in_z_basis:\n    # do something\n```\n\n----------------------------------------\n\nTITLE: Adaptive Optimization Output Example\nDESCRIPTION: Example output from running the adaptive optimization algorithm, showcasing the energy, circuit structure, and largest gradient at each step.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\nEnergy: -1.246549938420637\n0: ─╭BasisState(M0)─╭G²(0.20)─┤ ╭<𝓗>\n1: ─├BasisState(M0)─├G²(0.20)─┤ ├<𝓗>\n2: ─├BasisState(M0)─│─────────┤ ├<𝓗>\n3: ─├BasisState(M0)─│─────────┤ ├<𝓗>\n4: ─├BasisState(M0)─├G²(0.20)─┤ ├<𝓗>\n5: ─╰BasisState(M0)─╰G²(0.20)─┤ ╰<𝓗>\nLargest Gradient: 0.14399872776755085\n\nEnergy: -1.2613740231529604\n0: ─╭BasisState(M0)─╭G²(0.20)─╭G²(0.19)─┤ ╭<𝓗>\n1: ─├BasisState(M0)─├G²(0.20)─├G²(0.19)─┤ ├<𝓗>\n2: ─├BasisState(M0)─│─────────├G²(0.19)─┤ ├<𝓗>\n3: ─├BasisState(M0)─│─────────╰G²(0.19)─┤ ├<𝓗>\n4: ─├BasisState(M0)─├G²(0.20)───────────┤ ├<𝓗>\n5: ─╰BasisState(M0)─╰G²(0.20)───────────┤ ╰<𝓗>\nLargest Gradient: 0.1349349562423238\n\nEnergy: -1.2743971719780331\n0: ─╭BasisState(M0)─╭G²(0.20)─╭G²(0.19)──────────┤ ╭<𝓗>\n1: ─├BasisState(M0)─├G²(0.20)─├G²(0.19)─╭G(0.00)─┤ ├<𝓗>\n2: ─├BasisState(M0)─│─────────├G²(0.19)─│────────┤ ├<𝓗>\n3: ─├BasisState(M0)─│─────────╰G²(0.19)─╰G(0.00)─┤ ├<𝓗>\n4: ─├BasisState(M0)─├G²(0.20)────────────────────┤ ├<𝓗>\n5: ─╰BasisState(M0)─╰G²(0.20)────────────────────┤ ╰<𝓗>\nLargest Gradient: 0.00040841755397108586\n```\n\n----------------------------------------\n\nTITLE: Output of Parity Transformed Fermionic Hamiltonian\nDESCRIPTION: This is the expected output of printing the qubit Hamiltonian after applying the 'qml.fermi.parity_transform' function in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qubit_ham)\n-0.25j * Y(0) + (-0.25+0j) * (X(0) @ Z(1)) + (0.25+0j) * X(0) + 0.25j * (Y(0) @ Z(1))\n```\n\n----------------------------------------\n\nTITLE: Generating Auto Directive with Jinja2\nDESCRIPTION: This snippet generates a reStructuredText autodoc directive for the PennyLane object. It uses the `module`, `objtype`, and `objname` variables to create the directive.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary_core/base.rst#_snippet_3\n\nLANGUAGE: Jinja2\nCODE:\n```\n.. currentmodule:: {{ module }}\n\n.. auto{{ objtype }}:: {{ objname }}\n```\n\n----------------------------------------\n\nTITLE: Applying Batch Transforms to Tapes in PennyLane\nDESCRIPTION: Demonstrates how to apply a batch transform directly to a tape.  The transform returns processed tapes and a post-processing function.  The `execute` function from `pennylane.interfaces.batch` is used to execute the tapes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> tapes, fn = my_transform(tape, 0.65, 2.5)\n>>> from pennylane.interfaces.batch import execute\n>>> dev = qml.device(\"default.qubit\", wires=1)\n>>> res = execute(tapes, dev, interface=\"autograd\", gradient_fn=qml.gradients.param_shift)\n1.2629730888100839\n```\n\n----------------------------------------\n\nTITLE: Calculating the Circuit Spectrum\nDESCRIPTION: This code snippet calculates the frequencies supported by the input-encoding gates of a quantum circuit using the `circuit_spectrum` function from `pennylane.fourier`. It iterates through the resulting dictionary, printing each key (encoding-gate id) and its corresponding frequency set.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.fourier import circuit_spectrum\n>>> freqs = circuit_spectrum(simple_circuit_marked)([0.1])\n>>> for k, v in freqs.items():\n>>>     print(k, \":\", v)\n```\n\n----------------------------------------\n\nTITLE: Sparse Hamiltonian Expectation Value Execution (Pycon)\nDESCRIPTION: Executes the QNode defined in the previous snippet, passing in a sparse identity matrix. It showcases the output of computing the expectation value of the sparse Hamiltonian. Requires scipy to create the sparse matrix.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit([0.5], scipy.sparse.eye(4).tocoo()))\n0.9999999999999999\n```\n\n----------------------------------------\n\nTITLE: Draw Block Encoding Circuit\nDESCRIPTION: This snippet demonstrates how to draw the block encoding circuit using PennyLane's drawing functionality. It calls the block_encode function defined previously and prints the circuit diagram. Dependencies: PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(block_encode, show_matrices=False)(A, control_wires=[0, 1]))\n0: ─╭|Ψ⟩─╭Select─╭|Ψ⟩†─┤\n1: ─╰|Ψ⟩─├Select─╰|Ψ⟩†─┤\n2: ──────╰Select───────┤\n```\n\n----------------------------------------\n\nTITLE: Computing Jacobian with JAX\nDESCRIPTION: Example of using `jax.jacobian` to compute the gradient of a quantum circuit defined with PennyLane and JAX.  Requires the circuit defined in the previous snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jax.jacobian(circuit, argnums=[0, 1])(x, y)\n(Array([-0.84147098,  0.35017549], dtype=float64, weak_type=True),\n Array([ 4.47445479e-18, -4.91295496e-01], dtype=float64, weak_type=True))\n```\n\n----------------------------------------\n\nTITLE: Quantum Kernel Calculation with PennyLane\nDESCRIPTION: This code snippet demonstrates how to calculate quantum kernels using PennyLane's new `qml.kernels` module. It defines a quantum circuit as a kernel, computes kernel matrices for training and testing data, and applies noise mitigation techniques.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nnum_wires = 6\nwires = range(num_wires)\ndev = qml.device('default.qubit', wires=wires)\n\n@qml.qnode(dev)\ndef kernel_circuit(x1, x2):\n    qml.templates.AngleEmbedding(x1, wires=wires)\n    qml.adjoint(qml.templates.AngleEmbedding)(x2, wires=wires)\n    return qml.probs(wires)\n\nkernel = lambda x1, x2: kernel_circuit(x1, x2)[0]\nX_train = np.random.random((10, 6))\nX_test = np.random.random((5, 6))\n\n# Create symmetric square kernel matrix (for training)\nK = qml.kernels.square_kernel_matrix(X_train, kernel)\n\n# Compute kernel between test and training data.\nK_test = qml.kernels.kernel_matrix(X_train, X_test, kernel)\nK1 = qml.kernels.mitigate_depolarizing_noise(K, num_wires, method='single')\n```\n\n----------------------------------------\n\nTITLE: Removing SWAP Gates with PennyLane Transform\nDESCRIPTION: This snippet showcases the `undo_swaps` transformation, which automatically removes all SWAP gates from a circuit. This is useful for optimizing circuits and simplifying their structure. The example defines a QNode with several SWAP gates and uses the transformation to eliminate them.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=3)\n\n@qml.qnode(dev)\n@qml.transforms.undo_swaps\ndef qfunc():\n    qml.Hadamard(wires=0)\n    qml.PauliX(wires=1)\n    qml.SWAP(wires=[0,1])\n    qml.SWAP(wires=[0,2])\n    qml.PauliY(wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Execute ControlledQutritUnitary Quantum Circuit\nDESCRIPTION: This example shows how to execute a quantum circuit using `qml.ControlledQutritUnitary` with a given unitary matrix U. The result is a tensor representing the quantum state after the circuit has run.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_29\n\nLANGUAGE: pycon\nCODE:\n```\n>>> U = np.array([[1, 1, 0], [1, -1, 0], [0, 0, np.sqrt(2)]]) / np.sqrt(2)\n>>> circuit(U)\ntensor([0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n        0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n        0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n        0.+0.j, 0.+0.j, 0.+0.j], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Jacobian of Group Observables Transform in PennyLane with JAX\nDESCRIPTION: Calculates the Jacobian of the `group` function defined in the previous snippet, demonstrating that the `group_observables` transform is differentiable.  The output shows the Jacobian matrices for different selections of grouped coefficients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jac_fn(coeffs, select=0)\n[[1. 0. 0.]\n [0. 1. 0.]]\n\n>>> jac_fn(coeffs, select=1)\n[[0., 0., 1.]]\n```\n\n----------------------------------------\n\nTITLE: Optimization Results\nDESCRIPTION: This snippet shows the output of the molecular geometry and parameter optimization loop, printing the step number, energy, and maximum absolute force at each step.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_4\n\nLANGUAGE: text\nCODE:\n```\nStep: 0, Energy: -1.0491709019856188, Maximum Absolute Force: 0.1580194718925249\nStep: 5, Energy: -1.1349862621177522, Maximum Absolute Force: 0.037660768852544046\nStep: 10, Energy: -1.1399960666483346, Maximum Absolute Force: 0.005175323916673413\nStep: 15, Energy: -1.140321384816611, Maximum Absolute Force: 0.0004138319900744425\nStep: 20, Energy: -1.1403680839339787, Maximum Absolute Force: 8.223248376348913e-06\n```\n\n----------------------------------------\n\nTITLE: Trace Distance Calculation via Post-Processing in PennyLane\nDESCRIPTION: Illustrates trace distance calculation using flexible post-processing via `qml.math.trace_distance`.  Two density matrices, `rho` and `sigma`, are defined, and their trace distance is computed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> rho = np.array([[0.3, 0], [0, 0.7]])\n>>> sigma = np.array([[0.5, 0], [0, 0.5]])\n>>> qml.math.trace_distance(rho, sigma)\n0.19999999999999998\n```\n\n----------------------------------------\n\nTITLE: Using adjoint with AngleEmbedding in PennyLane\nDESCRIPTION: This snippet highlights the correct way to apply the `qml.adjoint` transform to a quantum template, specifically `AngleEmbedding`. It demonstrates the correct way to pass the template function itself to adjoint, rather than the evaluated result.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n@qml.qnode(dev)\ndef circuit_correct(params):\n    # Note the difference:                  v                         v\n    qml.adjoint(qml.templates.AngleEmbedding)(params, wires=dev.wires)\n    return qml.state()\n\nparams = list(range(1, 3))\n```\n\n----------------------------------------\n\nTITLE: Applying Batch Transforms to Existing QNodes in PennyLane\nDESCRIPTION: Shows how to apply a batch transform to an existing QNode.  A new QNode is created by applying the transform, and then it's executed with some weights.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> new_qnode = my_transform(existing_qnode, *transform_weights)\n>>> new_qnode(weights)\n```\n\n----------------------------------------\n\nTITLE: Adjoint Method of FermiWord\nDESCRIPTION: This code shows how to use the `adjoint` method of the `qml.fermi.FermiWord` class to obtain the adjoint (Hermitian conjugate) of the operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> w = qml.fermi.FermiWord({(0, 0): '+', (1, 1): '-'})\n>>> w.adjoint()\nFermiWord({(0, 1): '+', (1, 0): '-'})\n```\n\n----------------------------------------\n\nTITLE: Decomposing operation using PennyLane\nDESCRIPTION: This code snippet demonstrates how to decompose an operation using the `decompose()` method in PennyLane. It returns a list of operations that implement the original operation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> op.decompose()\n[RZ(0.3, wires=[0])]\n```\n\n----------------------------------------\n\nTITLE: Molecular Geometry and Parameter Optimization Loop in PennyLane\nDESCRIPTION: This code snippet performs a loop to optimize the molecular geometry, basis set parameters, and circuit parameters using gradient descent.  It computes gradients with respect to the circuit parameters, nuclear coordinates, Gaussian exponents, and Gaussian contraction coefficients, and then updates the corresponding parameters. It prints the energy and maximum absolute force every 5 steps.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qchem.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfor n in range(21):\n\n    mol = qml.qchem.Molecule(symbols, geometry, alpha=alpha, coeff=coeff)\n    args = [params, geometry, alpha, coeff] # initial values of the differentiable parameters\n\n    # compute gradients with respect to the circuit parameters and update the parameters\n    g_params = qml.grad(generate_circuit(mol), argnum = 0)(*args)\n    params = params - 0.25 * g_params[0]\n\n    # compute gradients with respect to the nuclear coordinates and update geometry\n    g_coor = qml.grad(generate_circuit(mol), argnum = 1)(*args)\n    geometry = geometry - 0.5 * g_coor\n\n    # compute gradients with respect to the Gaussian exponents and update the exponents\n    g_alpha = qml.grad(generate_circuit(mol), argnum = 2)(*args)\n    alpha = alpha - 0.25 * g_alpha\n\n    # compute gradients with respect to the Gaussian contraction coefficients and update them\n    g_coeff = qml.grad(generate_circuit(mol), argnum = 3)(*args)\n    coeff = coeff - 0.25 * g_coeff\n\n    if n%5 == 0:\n        print(f'Step: {n}, Energy: {generate_circuit(mol)(*args)}, Maximum Absolute Force: {abs(g_coor).max()}')\n```\n\n----------------------------------------\n\nTITLE: Installing pre-commit with pip in Bash\nDESCRIPTION: Installs the pre-commit package using pip. This is a prerequisite for using pre-commit hooks for automated code formatting and quality checks.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/pullrequests.rst#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install pre-commit\n```\n\n----------------------------------------\n\nTITLE: Convert Qiskit SparsePauliOp to PennyLane Operator\nDESCRIPTION: This snippet demonstrates converting a Qiskit SparsePauliOp operator to a PennyLane operator using `qml.from_qiskit_op`. It allows leveraging existing Qiskit operators within PennyLane workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom qiskit.quantum_info import SparsePauliOp\n\nqiskit_op = SparsePauliOp([\"II\", \"XY\"])\n```\n\n----------------------------------------\n\nTITLE: Manual Circuit Drawing with MPLDrawer in PennyLane\nDESCRIPTION: Demonstrates manual circuit drawing using the `MPLDrawer` class from `pennylane.circuit_drawer`. The code creates a drawer, labels wires, and adds box gates, CNOT gates, and measurements to the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.circuit_drawer import MPLDrawer\n\ndrawer = MPLDrawer(n_wires=3, n_layers=3)\n\ndrawer.label([r\"$|\\Psi\\rangle$\", r\"$|\\theta\\rangle$\", \"aux\"])\n\ndrawer.box_gate(layer=0, wires=[0, 1, 2], text=\"Entangling Layers\", text_options={'rotation': 'vertical'})\ndrawer.box_gate(layer=1, wires=[0, 1], text=\"U(θ)\")\n\ndrawer.CNOT(layer=2, wires=[1, 2])\ndrawer.measure(layer=3, wires=2)\n\ndrawer.fig.suptitle('My Circuit', fontsize='xx-large')\n```\n\n----------------------------------------\n\nTITLE: Running Device Integration Tests with pl-device-test\nDESCRIPTION: Illustrates how to invoke the integrated device test suite using the `pl-device-test` command line program. The test suite can be used to run basic integration tests on core or external devices. The code shows how to run the test against a specific device with specified shots and analytic parameters.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.11.0.md#_snippet_6\n\nLANGUAGE: console\nCODE:\n```\n$ pl-device-test --device=default.qubit --shots=1234 --analytic=False\n```\n\n----------------------------------------\n\nTITLE: State Preparation with Imported State\nDESCRIPTION: This snippet prepares a quantum state using the imported wave function wf_cisd obtained from the previous quantum chemistry calculation. The state preparation is performed using qml.StatePrep within a QNode. Dependencies: PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device('default.qubit', wires=4)\n>>> @qml.qnode(dev)\n... def circuit():\n...     qml.StatePrep(wf_cisd, wires=range(4))\n...     return qml.state()\n>>> print(circuit())\n[ 0.        +0.j  0.        +0.j  0.        +0.j  0.1066467 +0.j\n  1.        +0.j  0.        +0.j  0.        +0.j  0.        +0.j\n  2.        +0.j  0.        +0.j  0.        +0.j  0.        +0.j\n -0.99429698+0.j  0.        +0.j  0.        +0.j  0.        +0.j]\n```\n\n----------------------------------------\n\nTITLE: Defining a New Observable Class in Python\nDESCRIPTION: This snippet defines a custom observable class `NewObservable` in PennyLane. It inherits from `qml.operation.Observable` and implements the `diagonalizing_gates` method. This custom observable can be used with devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.devices import DefaultQubit\n\nclass NewObservable(qml.operation.Observable):\n    \"\"\"NewObservable\"\"\"\n\n    num_wires = qml.operation.AnyWires\n    num_params = 0\n    par_domain = None\n\n    def diagonalizing_gates(self):\n        \"\"\"Diagonalizing gates\"\"\"\n        return []\n```\n\n----------------------------------------\n\nTITLE: Testing Deprecation Warning in Python with pytest\nDESCRIPTION: This code snippet shows how to test if a deprecation warning is raised when a deprecated feature is called. It uses `pytest.warns` to assert that the correct warning is raised, including the expected warning message.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/deprecations_removals.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndef test_my_feature_is_deprecated():\n    \"\"\"Test that my_feature is deprecated.\"\"\"\n    with pytest.warns(qml.PennyLaneDeprecationWarning, match=\"my_feature is deprecated\"):\n        _ = my_feature()\n```\n\n----------------------------------------\n\nTITLE: Handling TensorFlow Errors in DefaultQubit Device\nDESCRIPTION: This snippet describes a fix in `qml.devices.qubit.apply_operation` that addresses a `tf.errors.UnimplementedError` when applying `PauliZ` or `CNOT` gates to large TensorFlow states. The logic falls back to the tensordot method when the error is encountered.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_9\n\n\n\n----------------------------------------\n\nTITLE: Extracting Givens Decomposition Results\nDESCRIPTION: This snippet shows the output of the `qml.qchem.givens_decomposition` function. It displays the phase matrix and the ordered rotations, which are tuples containing the rotation matrix and the wires on which to apply the rotation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_22\n\nLANGUAGE: pycon\nCODE:\n```\n>>> phase_mat\ntensor([-0.20604358+0.9785369j , -0.82993272+0.55786114j,\n        0.56230612-0.82692833j], requires_grad=True)\n>>> ordered_rotations\n[(tensor([[-0.65087861-0.63937521j, -0.40933651-0.j        ],\n          [-0.29201359-0.28685265j,  0.91238348-0.j        ]], requires_grad=True),\n  (0, 1)),\n(tensor([[ 0.47970366-0.33308926j, -0.8117487 -0.j        ],\n          [ 0.66677093-0.46298215j,  0.5840069 -0.j        ]], requires_grad=True),\n  (1, 2)),\n(tensor([[ 0.36147547+0.73779454j, -0.57008306-0.j        ],\n          [ 0.2508207 +0.51194108j,  0.82158706-0.j        ]], requires_grad=True),\n  (0, 1))]\n```\n\n----------------------------------------\n\nTITLE: Sparse Matrix Format Specification\nDESCRIPTION: This snippet demonstrates how to specify the sparse matrix format and wire order when calling the `sparse_matrix` method of a PennyLane operator. It shows how to retrieve a CNOT gate's sparse matrix in different formats (dok, csc) and with a custom wire order. This allows users to leverage different sparse matrix formats for optimized memory usage and performance.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op = qml.CNOT([0,1])\n>>> type(op.sparse_matrix(format='dok'))\nscipy.sparse._dok.dok_matrix\n>>> type(op.sparse_matrix(format='csc'))\nscipy.sparse._csc.csc_matrix\n>>> print(op.sparse_matrix(wire_order=[1,0]))\n```\n\n----------------------------------------\n\nTITLE: Sampling Circuit Definition in PennyLane\nDESCRIPTION: This code defines a PennyLane quantum circuit that applies an RX rotation based on the input parameter 'x' to the qubit with wire 0 and then samples the qubit. It demonstrates a simple example of creating a quantum circuit and using the qml.sample function to retrieve samples from the circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nqml.RX(x[0], wires=0)\nreturn qml.sample(wires=0)\n```\n\n----------------------------------------\n\nTITLE: Applying Unitary to Rotation Transform in PennyLane\nDESCRIPTION: Applies the `unitary_to_rot` transform to a quantum function containing `QubitUnitary` operations, decomposing them into `Rot` gates. This facilitates gradient computation with respect to parameters used in constructing the unitary matrices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef qfunc_with_qubit_unitary(angles):\n    z, x = angles[0], angles[1]\n\n    Z_mat = np.array([[np.exp(-1j * z / 2), 0.0], [0.0, np.exp(1j * z / 2)]])\n\n    c = np.cos(x / 2)\n    s = np.sin(x / 2) * 1j\n    X_mat = np.array([[c, -s], [-s, c]])\n\n    qml.Hadamard(wires=\"a\")\n    qml.QubitUnitary(Z_mat, wires=\"a\")\n    qml.QubitUnitary(X_mat, wires=\"b\")\n    qml.CNOT(wires=[\"b\", \"a\"])\n    return qml.expval(qml.PauliX(wires=\"a\"))\n```\n\n----------------------------------------\n\nTITLE: Create a Quantum Circuit with TrotterProduct and QuantumPhaseEstimation (Python)\nDESCRIPTION: This code creates a quantum circuit using PennyLane that includes TrotterProduct and QuantumPhaseEstimation operations. It defines a Hamiltonian, creates a QNode, and applies the Trotter product and quantum phase estimation with a custom error operation. This demonstrates error propagation through algorithmic building blocks.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('null.qubit')\nhamiltonian = qml.dot([1.0, 0.5, -0.25], [qml.X(0), qml.Y(0), qml.Z(0)])\n\n@qml.qnode(dev)\ndef circuit():\n    qml.TrotterProduct(hamiltonian, time=0.1, order=2)\n    qml.QuantumPhaseEstimation(MyErrorOperation(0.01, wires=0), estimation_wires=[1, 2, 3])\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Calculating Gradient of Quantum Circuit with Adjoint Differentiation\nDESCRIPTION: This example calculates the gradient of the quantum circuit `f` defined in the previous snippet, using the adjoint differentiation method. It requires the `jnp` library (JAX NumPy) for array manipulation. The expected output is the gradient value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.grad(f)(jnp.array(0.1))\nArray(-0.09983342, dtype=float64, weak_type=True)\n```\n\n----------------------------------------\n\nTITLE: Drawing a QNode with Matplotlib in PennyLane\nDESCRIPTION: This code snippet demonstrates how to draw a quantum circuit (QNode) using Matplotlib in PennyLane. It defines a simple quantum circuit with QFT, Toffoli, CSWAP, RX, and CRZ gates, then uses `qml.draw_mpl` to generate the circuit diagram as a Matplotlib figure.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=4)\n\n@qml.qnode(dev)\ndef circuit(x, z):\n    qml.QFT(wires=(0,1,2,3))\n    qml.Toffoli(wires=(0,1,2))\n    qml.CSWAP(wires=(0,2,3))\n    qml.RX(x, wires=0)\n    qml.CRZ(z, wires=(3,0))\n    return qml.expval(qml.PauliZ(0))\nfig, ax = qml.draw_mpl(circuit)(1.2345, 1.2345)\nfig.show()\n```\n\n----------------------------------------\n\nTITLE: Executing Hessian Computation in Pycon\nDESCRIPTION: This code snippet shows how to execute the Hessian computation of the circuit defined above using jax.hessian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_13\n\nLANGUAGE: pycon\nCODE:\n```\n>>> jax.hessian(circuit, argnums=[0, 1])(a, b)\n(((Array(-0.54030231, dtype=float64, weak_type=True),\n   Array(0., dtype=float64, weak_type=True)),\n  (Array(-1.76002563e-17, dtype=float64, weak_type=True),\n   Array(0., dtype=float64, weak_type=True))),\n ((Array(0., dtype=float64, weak_type=True),\n   Array(-1.00700085e-17, dtype=float64, weak_type=True)),\n  (Array(0., dtype=float64, weak_type=True),\n  Array(0.41614684, dtype=float64, weak_type=True))))\n```\n\n----------------------------------------\n\nTITLE: Matrix of an Empty QNode\nDESCRIPTION: This code demonstrates how `qml.matrix` now works with empty QNodes, returning an identity matrix.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef node():\n    return qml.expval(qml.Z(0))\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.matrix(node)()\narray([[1., 0.],\n       [0., 1.]])\n```\n\n----------------------------------------\n\nTITLE: Device Resource Tracker (Python)\nDESCRIPTION: Illustrates how to use the `qml.Tracker` to track device executions, shots, and batches during gradient computation. This functionality aids in monitoring large batches and remote jobs. Requires PennyLane installation and a QNode defined with a device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=1, shots=100)\n\n@qml.qnode(dev, diff_method=\"parameter-shift\")\ndef circuit(x):\n    qml.RX(x, wires=0)\n    return qml.expval(qml.PauliZ(0))\n\nx = np.array(0.1)\n\nwith qml.Tracker(circuit.device) as tracker:\n    qml.grad(circuit)(x)\n```\n\n----------------------------------------\n\nTITLE: Configuring Postselection Modes (python3)\nDESCRIPTION: This code demonstrates how to configure the `postselect_mode` argument in PennyLane to handle invalid shots when postselecting mid-circuit measurements with finite shots. It shows how to use `fill-shots` and `hw-like` modes to either sample the postselected value unconditionally or discard invalid samples, respectively.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/dynamic_quantum_circuits.rst#_snippet_9\n\nLANGUAGE: python3\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=3, shots=10)\n\ndef circ():\n    qml.Hadamard(0)\n    m_0 = qml.measure(0, postselect=1)\n    return qml.sample(qml.PauliZ(0))\n\nfill_shots = qml.QNode(circ, dev, mcm_method=\"one-shot\", postselect_mode=\"fill-shots\")\nhw_like = qml.QNode(circ, dev, mcm_method=\"one-shot\", postselect_mode=\"hw-like\")\n```\n\n----------------------------------------\n\nTITLE: Adjoint Differentiation Error with shots > 0 in PennyLane\nDESCRIPTION: This code demonstrates an error that is raised when using the adjoint differentiation method with a device that has shots greater than zero. The adjoint differentiation algorithm is analytic by nature and does not support finite shots.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\ndef print_grad_ok():\n    dev = qml.device('default.qubit', wires=1, shots=100)\n\n    @qml.qnode(dev, diff_method='adjoint')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.expval(qml.Z(wires=0))\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Define a JAX Primitive\nDESCRIPTION: Defines a new JAX primitive named `my_func`. It includes an implementation that squares the input and an abstract evaluation rule that returns a shaped array with the same data type.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nmy_func_prim = jax.core.Primitive(\"my_func\")\n\n@my_func_prim.def_impl\ndef _(x):\n    return x**2\n\n@my_func_prim.def_abstract_eval\ndef _(x):\n    return jax.core.ShapedArray((1,), x.dtype)\n\ndef my_func(x):\n    return my_func_prim.bind(x)\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fourier Coefficients with Violin Plot\nDESCRIPTION: This snippet demonstrates how to visualize a distribution of Fourier coefficients using a violin plot. It first creates a figure and a set of subplots using `plt.subplots`.  Then, it calls the `violin` function, passing the coefficients, the degree (2), the axes objects, and a boolean to show frequencies on the plot (`show_freqs=True`). It relies on matplotlib.pyplot and a function called `violin` which likely comes from `pennylane.fourier.visualize`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfig, ax = plt.subplots(2, 1, sharey=True, figsize=(15, 4))\nviolin(coeffs, 2, ax, show_freqs=True)\n```\n\n----------------------------------------\n\nTITLE: Define Custom Noise Condition with BooleanFn in PennyLane\nDESCRIPTION: Illustrates how to define a custom noise condition using `qml.BooleanFn` that inserts noise if a `qml.RY` operator is encountered with a rotation angle less than 0.5.  The function is decorated with `qml.BooleanFn` to create a callable noise condition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.BooleanFn\ndef c0(op):\n    return isinstance(op, qml.RY) and op.parameters[0] < 0.5\n```\n\n----------------------------------------\n\nTITLE: Accessing Molecular Properties\nDESCRIPTION: This snippet demonstrates how to access the number of electrons in a constructed molecule object using the `n_electrons` attribute.  It relies on the molecule object (`mol`) defined in the previous code snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> mol.n_electrons\n44\n```\n\n----------------------------------------\n\nTITLE: Custom single_tape_execution function in PennyLane\nDESCRIPTION: This Python code defines a custom execution function named `single_tape_execution` that processes samples from a quantum tape, handles different shot configurations, and returns the processed results. It iterates through shot bins, processes subsamples using measurement processes, and adjusts the results based on the number of measurements and shot partitioning.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef single_tape_execution(tape) -> qml.typing.Result:\n    samples = get_samples(tape)\n    results = []\n    for lower, upper in tape.shots.bins():\n        sub_samples = samples[lower:upper]\n        results.append(\n            tuple(mp.process_samples(sub_samples, tape.wires) for mp in tape.measurements)\n        )\n    if len(tape.measurements) == 1:\n        results = tuple(res[0] for res in results)\n    if tape.shots.has_partitioned_shots:\n        results = results[0]\n    return results\n```\n\n----------------------------------------\n\nTITLE: Adding Transforms to a PennyLane Program (Python)\nDESCRIPTION: Demonstrates adding transforms to a PennyLane TransformProgram. Includes validate_device_wires, validate_measurements, defer_measurements, split_non_commuting, and decompose. A custom supports_operation function is used as a stopping condition for decomposition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.devices.preprocess import validate_device_wires, validate_measurements, decompose\n\nprogram.add_transform(validate_device_wires, wires=qml.wires.Wires((0,1,2)), name=\"my_device\")\nprogram.add_transform(validate_measurements, name=\"my_device\")\nprogram.add_transform(qml.defer_measurements)\nprogram.add_transform(qml.transforms.split_non_commuting)\n\ndef supports_operation(op): \n    return getattr(op, \"name\", None) in operation_names\n    \nprogram.add_transform(decompose, stopping_condition=supports_operation, name=\"my_device\")\nprogram.add_transform(qml.transforms.broadcast_expand)\n```\n\n----------------------------------------\n\nTITLE: QNode with dynamic array indexing in for loop\nDESCRIPTION: This code demonstrates using a for loop with a dynamic bound (`n`) to index a JAX array within a PennyLane QNode.  The QNode `f` applies a RY gate to the first qubit based on values from the input array `x`, up to the index specified by `n`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef f(n):\n    x = jnp.array([0.0, 1 / 4 * jnp.pi, 2 / 4 * jnp.pi])\n    for i in range(n):\n        qml.RY(x[i], wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Defining Device Capabilities with TOML\nDESCRIPTION: This TOML configuration file defines the capabilities of a quantum device, including supported gates, observables, and measurement processes. It also specifies compilation options such as QJIT compatibility and support for mid-circuit measurements. The file is used by PennyLane to understand the device's limitations and optimize circuit execution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_7\n\nLANGUAGE: toml\nCODE:\n```\nschema = 3\n\n# The set of all gate types supported at the runtime execution interface of the\n# device, i.e., what is supported by the `execute` method. The gate definitions\n# should have the following format:\n#\n#   GATE = { properties = [ PROPS ], conditions = [ CONDS ] }\n#\n# where PROPS and CONS are zero or more comma separated quoted strings.\n#\n# PROPS: additional support provided for each gate.\n#        - \"controllable\": if a controlled version of this gate is supported.\n#        - \"invertible\": if the adjoint of this operation is supported.\n#        - \"differentiable\": if device gradient is supported for this gate.\n# CONDS: constraints on the support for each gate.\n#        - \"analytic\" or \"finiteshots\": if this operation is only supported in\n#          either analytic execution or with shots, respectively.\n#\n[operators.gates]\n\nPauliX = { properties = [\"controllable\", \"invertible\"] }\nPauliY = { properties = [\"controllable\", \"invertible\"] }\nPauliZ = { properties = [\"controllable\", \"invertible\"] }\nRY = { properties = [\"controllable\", \"invertible\", \"differentiable\"] }\nRZ = { properties = [\"controllable\", \"invertible\", \"differentiable\"] }\nCRY = { properties = [\"invertible\", \"differentiable\"] }\nCRZ = { properties = [\"invertible\", \"differentiable\"] }\nCNOT = { properties = [\"invertible\"] }\n\n# Observables supported by the device for measurements. The observables defined\n# in this section should have the following format:\n#\n#   OBSERVABLE = { conditions = [ CONDS ] }\n#\n# where CONDS is zero or more comma separated quoted strings, same as above.\n#\n# CONDS: constraints on the support for each observable.\n#        - \"analytic\" or \"finiteshots\": if this observable is only supported in\n#          either analytic execution or with shots, respectively.\n#        - \"terms-commute\": if a composite operator is only supported under the\n#          condition that its terms commute.\n#\n[operators.observables]\n\nPauliX = { }\nPauliY = { }\nPauliZ = { }\nHamiltonian = { conditions = [ \"terms-commute\" ] }\nSum = { conditions = [ \"terms-commute\" ] }\nSProd = { }\nProd = { }\n\n# Types of measurement processes supported on the device. The measurements in\n# this section should have the following format:\n#\n#   MEASUREMENT_PROCESS = { conditions = [ CONDS ] }\n#\n# where CONDS is zero or more comma separated quoted strings, same as above.\n#\n# CONDS: constraints on the support for each measurement process.\n#        - \"analytic\" or \"finiteshots\": if this measurement is only supported\n#          in either analytic execution or with shots, respectively.\n#\n[measurement_processes]\n\nExpectationMP = { }\nSampleMP = { }\nCountsMP = { conditions = [\"finiteshots\"] }\nStateMP = { conditions = [\"analytic\"] }\n\n# Additional support that the device may provide that informs the compilation\n# process. All accepted fields and their default values are listed below.\n[compilation]\n\n# Whether the device is compatible with qjit.\nqjit_compatible = false\n\n# Whether the device requires run time generation of the quantum circuit.\nruntime_code_generation = false\n\n# Whether the device supports allocating and releasing qubits during execution.\ndynamic_qubit_management = false\n\n# Whether simultaneous measurements on overlapping wires is supported.\noverlapping_observables = true\n\n# Whether simultaneous measurements of non-commuting observables is supported.\n# If false, a circuit with multiple non-commuting measurements will have to be\n# split into multiple executions for each subset of commuting measurements.\nnon_commuting_observables = false\n\n# Whether the device supports initial state preparation.\ninitial_state_prep = false\n\n# The methods of handling mid-circuit measurements that the device supports,\n# e.g., \"one-shot\", \"tree-traversal\", \"device\", etc. An empty list indicates\n# that the device does not support mid-circuit measurements.\nsupported_mcm_methods = [ ]\n```\n\n----------------------------------------\n\nTITLE: Installing Catalyst and CUDA Quantum\nDESCRIPTION: Installs the necessary packages for using CUDA Quantum with PennyLane. This includes both Catalyst and the CUDA Quantum package.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_5\n\nLANGUAGE: Bash\nCODE:\n```\npip install pennylane-catalyst cuda_quantum\n```\n\n----------------------------------------\n\nTITLE: Mapping a Template over Observables with PennyLane\nDESCRIPTION: This code demonstrates how to use `qml.map` to map a quantum circuit template over a list of observables. The function returns a `QNodeCollection`, allowing for simultaneous evaluation of multiple QNodes. This is useful for performing the same quantum circuit with different measurement objectives.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.8.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> def my_template(params, wires, **kwargs):\n>>>    qml.RX(params[0], wires=wires[0])\n>>>    qml.RX(params[1], wires=wires[1])\n>>>    qml.CNOT(wires=wires)\n\n>>> obs_list = [qml.PauliX(0) @ qml.PauliZ(1), qml.PauliZ(0) @ qml.PauliX(1)]\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> qnodes = qml.map(my_template, obs_list, dev, measure=\"expval\")\n>>> qnodes([0.54, 0.12])\narray([-0.06154835  0.99280864])\n```\n\n----------------------------------------\n\nTITLE: Extracting Shape and Numeric Type from QuantumTape\nDESCRIPTION: This code shows how to extract the shape and numeric type of the output returned by a quantum tape after execution, using the `QuantumTape.shape` method and `QuantumTape.numeric_type` attribute. It defines a simple quantum circuit with RY and RX gates, and then uses the `QuantumTape` object to determine the shape and data type of the resulting state vector. It uses the numpy library to define an array as a parameter to the quantum circuit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\na = np.array([0.1, 0.2, 0.3])\n\ndef func(a):\n    qml.RY(a[0], wires=0)\n    qml.RX(a[1], wires=0)\n    qml.RY(a[2], wires=0)\n\nwith qml.tape.QuantumTape() as tape:\n    func(a)\n    qml.state()\n```\n\n----------------------------------------\n\nTITLE: QASM Circuit Loading with qml.from_qasm\nDESCRIPTION: Demonstrates how to load a circuit from a QASM file using `qml.from_qasm` after opening the file in read mode. This replaces the deprecated `qml.from_qasm_file` function.  Requires the `qml` module to be imported.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nwith open(\"test.qasm\", \"r\") as f:\n    circuit = qml.from_qasm(f.read())\n```\n\n----------------------------------------\n\nTITLE: Enable JAX Dynamic Shapes\nDESCRIPTION: This code snippet shows how to enable experimental dynamic shapes support using JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\n\njax.config.update(\"jax_dynamic_shapes\", True)\n```\n\n----------------------------------------\n\nTITLE: Import PennyLane and TensorFlow\nDESCRIPTION: This code snippet demonstrates how to import the necessary libraries, PennyLane and TensorFlow, to use PennyLane with the TensorFlow interface.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/interfaces/tf.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport tensorflow as tf\n```\n\n----------------------------------------\n\nTITLE: Commutator Calculation with Pauli Operators\nDESCRIPTION: This code demonstrates how to calculate the commutator of two Pauli operators (PauliWord instances) using the 'commutator' method. It initializes two Pauli words and then calculates their commutator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.35.0.md#_snippet_18\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op1 = PauliWord({0: \"X\", 1: \"X\"})\n>>> op2 = PauliWord({0: \"Y\"}) + PauliWord({1: \"Y\"})\n>>> op1.commutator(op2)\n2j * Z(0) @ X(1)\n+ 2j * X(0) @ Z(1)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Operation to diagonal_in_z_basis\nDESCRIPTION: This example demonstrates how to add custom operations to the `diagonal_in_z_basis` attribute at runtime.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.20.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndiagonal_in_z_basis.add(\"MyCustomOp\")\n```\n\n----------------------------------------\n\nTITLE: Installing PennyLane Data Dependencies\nDESCRIPTION: This command installs the required dependencies (aiohttp, fsspec, and h5py) for using the pennylane.data module.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\npip install aiohttp fsspec h5py\n```\n\n----------------------------------------\n\nTITLE: Using Decorators for Logging (Python)\nDESCRIPTION: This snippet shows how to use decorators from pennylane.logging to add logging support to functions and methods. The debug_logger decorator is used for regular functions/methods, while debug_logger_init is used for class __init__ methods. This allows for automatic logging of function calls and arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/logging.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# debug_logger can be used to decorate any method or free function\n# debug_logger_init can be used to decorate class __init__ methods.\nfrom pennylane.logging import debug_logger, debug_logger_init\n\n@debug_logger\ndef my_func(arg1, arg2):\n   return arg1 + arg2\n```\n\n----------------------------------------\n\nTITLE: Class Definition with JAX Primitive Metaclass\nDESCRIPTION: Defines a class `PrimitiveClass` that uses the `PrimitiveMeta` metaclass. This creates a JAX primitive associated with the class, allowing it to be used in JAX's tracing and differentiation workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nclass PrimitiveClass(metaclass=PrimitiveMeta):\n\n    def __init__(self, a):\n        self.a = a\n\n    def __repr__(self):\n        return f\"PrimitiveClass({self.a})\"\n```\n\n----------------------------------------\n\nTITLE: Visualizing Fourier Coefficients with a Bar Plot\nDESCRIPTION: This code generates a bar plot to visualize the Fourier coefficients of a quantum circuit using `pennylane.fourier.visualize.bar` and `matplotlib`. It sets up the axes using `plt.subplots`, then calls the `bar` function to plot the coefficients, displaying the real and imaginary parts in separate panels.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_fourier.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.fourier.visualize import *\n>>> import matplotlib.pyplot as plt\n\n>>> fig, ax = plt.subplots(2, 1, sharex=True, sharey=True) # Set up the axes\n>>> bar(coeffs, 1, ax)\n```\n\n----------------------------------------\n\nTITLE: Define a Quantum Circuit in OpenQASM 2.0\nDESCRIPTION: This snippet defines a quantum circuit using the OpenQASM 2.0 language. The circuit includes a Hadamard gate on qubit 0 and a CNOT gate with qubit 0 as control and qubit 1 as target. This string representation is then used for importing into PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/importing_workflows.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\noq_circuit = (\n    \"\"\"\n    OPENQASM 2.0;\n    include \\\"qelib1.inc\\\";\n    qreg q[2];\n    creg c[2];\n\n    h q[0];\n    cx q[0], q[1];\n    \"\"\"\n)\n```\n\n----------------------------------------\n\nTITLE: Operator Equality and Hashing Updates\nDESCRIPTION: Demonstrates the updated behaviour of `Operator.__eq__` and `Operator.__hash__` in PennyLane. This example shows how operator equality is now determined using `qml.equal` and how unique, equal operators now have the same hash.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nqml.RX(0.1, wires=0) == qml.RX(0.1, wires=0)\nTrue\n{qml.PauliZ(0), qml.PauliZ(0)}\n{PauliZ(wires=[0])}\n```\n\n----------------------------------------\n\nTITLE: Workaround using callable variable in qml.while_loop\nDESCRIPTION: Shows a workaround for the lambda function limitation in qml.while_loop by assigning the lambda function to a callable variable. This enables the while loop to function correctly with program capture. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n\n    func = lambda x: x > 3\n\n    @qml.while_loop(func)\n    def loop(a):\n        a += 1\n        return a\n\n    a = 0\n    loop(a)\n    \n    qml.RX(0, wires=0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Finite Difference Gradient Transform (Pycon)\nDESCRIPTION: Illustrates the usage of `qml.gradients.finite_diff` to compute the gradient using finite differences. Requires PennyLane installation, numpy, and a quantum circuit defined using `JacobianTape`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> params = np.array([0.3,0.4,0.5], requires_grad=True)\n>>> with qml.tape.JacobianTape() as tape:\n...     qml.RX(params[0], wires=0)\n...     qml.RY(params[1], wires=0)\n...     qml.RX(params[2], wires=0)\n...     qml.expval(qml.PauliZ(0))\n...     qml.var(qml.PauliZ(0))\n>>> tape.trainable_params = {0, 1, 2}\n>>> gradient_tapes, fn = qml.gradients.finite_diff(tape)\n```\n\n----------------------------------------\n\nTITLE: Sampling Measurements with PennyLane\nDESCRIPTION: This code snippet demonstrates how to sample measurements within a PennyLane quantum circuit. It uses a list comprehension to create a list of samples for each measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nreturn [qml.sample(op=meas) for meas in measurements]\n```\n\n----------------------------------------\n\nTITLE: Executing Prep-Select-Prep Circuit\nDESCRIPTION: This snippet executes the quantum circuit defined using the `qml.PrepSelPrep` template. It calculates the state of the circuit and rounds the result to two decimal places for display. It depends on numpy and the previously defined circuit function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_16\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import numpy as np\n>>> np.round(circuit(lcu, control, alphas, unitaries), decimals=2)\ntensor([1.+0.j -0.+0.j -0.+0.j -0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j], requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Eval Jaxpr with Dynamic Shapes\nDESCRIPTION: This snippet demonstrates another limitation of dynamic shapes: executing a JAXPR with `eval_jaxpr`. It shows that attempting to evaluate a JAXPR generated with dynamic shapes results in an `XlaRuntimeError`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef k(n):\n    return jax.numpy.ones((n,))\n\njaxpr = jax.make_jaxpr(k)(3)\njax.core.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, 3)\n```\n\n----------------------------------------\n\nTITLE: KerasLayer with Backpropagation in Tape Mode in Python\nDESCRIPTION: This code demonstrates differentiating a QNode within a `KerasLayer` using classical backpropagation in tape mode. It defines a QNode `f` that includes angle embedding and strongly entangling layers.  The QNode interface is \"tf\" and the differentiation method is \"backprop\". It then creates a `KerasLayer` wrapping this QNode and computes the Jacobian using `tf.GradientTape()`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_tape()\n\ndev = qml.device(\"default.qubit.tf\", wires=2)\n\n@qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\ndef f(inputs, weights):\n    qml.templates.AngleEmbedding(inputs, wires=range(2))\n    qml.templates.StronglyEntanglingLayers(weights, wires=range(2))\n    return [qml.expval(qml.PauliZ(i)) for i in range(2)]\n\nweight_shapes = {\"weights\": (3, 2, 3)}\n\nqlayer = qml.qnn.KerasLayer(f, weight_shapes, output_dim=2)\n\ninputs = tf.constant(np.random.random((4, 2)), dtype=tf.float32)\n\nwith tf.GradientTape() as tape:\n    out = qlayer(inputs)\n\ntape.jacobian(out, qlayer.trainable_weights)\n```\n\n----------------------------------------\n\nTITLE: Class Definition with Metaclass\nDESCRIPTION: Defines a class `MyClass` that uses the `MyMetaClass` metaclass. This demonstrates how the metaclass's `__init__` method is called during class definition, and how the class can then be instantiated using the metaclass's `__call__` method.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nclass MyClass(metaclass=MyMetaClass):\n\n    def __init__(self, *args, **kwargs):\n        print(\"now creating an instance in __init__\")\n        self.args = args\n        self.kwargs = kwargs\n```\n\n----------------------------------------\n\nTITLE: QNode Sampling Output (Pycon)\nDESCRIPTION: Shows the output of the QNode sampling examples, displaying the sampled bitstrings for both circuits. The first example samples all three qubits, while the second samples only qubits 0 and 2. Requires executing the Python code defining the QNodes.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit_1())\n[[1, 0, 0],\n [1, 1, 0],\n [1, 0, 0],\n [0, 0, 0],\n [0, 1, 0]]\n\n>>> print(circuit_2())\n[[1, 0],\n [1, 0],\n [1, 0],\n [0, 0],\n [0, 0]]\n```\n\n----------------------------------------\n\nTITLE: Verifying the New CNOT Decomposition Rule in Python\nDESCRIPTION: This snippet shows how to verify the newly added decomposition rule for the CNOT gate. It lists the available decompositions for the CNOT gate and prints the last added rule, which should be the custom one.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> my_new_rule = qml.list_decomps(qml.CNOT)[-1]\n>>> print(my_new_rule)\n@qml.register_resources({qml.H: 2, qml.CZ: 1})\ndef my_cnot(wires):\n    qml.H(wires=wires[1])\n    qml.CZ(wires=wires)\n    qml.H(wires=wires[1])\n```\n\n----------------------------------------\n\nTITLE: Defining Device Stopping Condition with BooleanFn\nDESCRIPTION: This code illustrates how to define the stopping_condition property for a PennyLane device using BooleanFn. This determines which operations and measurement processes are supported by the device. The function should return True for supported operations and False otherwise.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@property\ndef stopping_condition(self):\n    def accepts_obj(obj):\n        return obj.name in {'CNOT', 'PauliX', 'PauliY', 'PauliZ'}\n    return qml.BooleanFn(accepts_obj)\n```\n\n----------------------------------------\n\nTITLE: While loop with variable update\nDESCRIPTION: This code defines a function `f` with a `while` loop that increments the input variable `x` by 2 until `x` is no longer less than 5. It demonstrates the ability to update variables within a `while` loop using AutoGraph.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    while x < 5:\n        x = x + 2\n    return x\n```\n\n----------------------------------------\n\nTITLE: Installing Catalyst with pip\nDESCRIPTION: Installs the PennyLane-Catalyst compiler using pip. Catalyst is required for just-in-time compilation of quantum workflows in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_0\n\nLANGUAGE: Bash\nCODE:\n```\npip install pennylane-catalyst\n```\n\n----------------------------------------\n\nTITLE: Executing Transformed Quantum Function in PennyLane\nDESCRIPTION: Executes the transformed quantum function using a PennyLane device and computes the gradient with respect to the input parameters. This demonstrates the use of `unitary_to_rot` for differentiable quantum programming.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=[\"a\", \"b\"])\n>>> transformed_qfunc = qml.transforms.unitary_to_rot(qfunc_with_qubit_unitary)\n>>> transformed_qnode = qml.QNode(transformed_qfunc, dev)\n>>> input = np.array([0.3, 0.4], requires_grad=True)\n>>> transformed_qnode(input)\ntensor(0.95533649, requires_grad=True)\n>>> qml.grad(transformed_qnode)(input)\narray([-0.29552021,  0.        ])\n```\n\n----------------------------------------\n\nTITLE: Wires Usage Example\nDESCRIPTION: This code snippet shows how to use the Wires class to represent and manipulate wire labels in PennyLane. It demonstrates creating a Wires object, accessing labels via indexing and slicing, and printing the resulting Wires instances.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.wires import Wires\n\nwires = Wires(['auxiliary', 0, 1])\nprint(wires.labels) # ('auxiliary', 0, 1)\nprint(wires[0]) # 'auxiliary'\nprint(wires[0:1]) # Wires(['auxiliary'])\n```\n\n----------------------------------------\n\nTITLE: Interactive Data Selection with PennyLane\nDESCRIPTION: Illustrates the use of `qml.data.load_interactive()` to interactively select and load quantum datasets. This function guides the user through a series of prompts to specify the dataset and its attributes. Requires PennyLane and access to datasets hosted on Xanadu Cloud.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_2\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.data.load_interactive()\nPlease select a data name:\n\t1) qspin\n\t2) qchem\nChoice [1-2]: 1\nPlease select a sysname:\n\t...\nPlease select a periodicity:\n\t...\nPlease select a lattice:\n\t...\nPlease select a layout:\n\t...\nPlease select attributes:\n\t...\nForce download files? (Default is no) [y/N]: N\nFolder to download to? (Default is pwd, will download to /datasets subdirectory):\n\nPlease confirm your choices:\ndataset: qspin/Ising/open/rectangular/4x4\nattributes: ['parameters', 'ground_states']\nforce: False\ndest folder: datasets\nWould you like to continue? (Default is yes) [Y/n]:\n<Dataset = description: qspin/Ising/open/rectangular/4x4, attributes: ['parameters', 'ground_states']>\n```\n\n----------------------------------------\n\nTITLE: Deprecating QubitDevice Caching in PennyLane\nDESCRIPTION: This snippet demonstrates the deprecated caching ability provided by `QubitDevice` and the preferred way to use the caching abilities of the QNode. It defines a quantum circuit using PennyLane and demonstrates how to use the QNode's cache.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\ncache = {}\n\n@qml.qnode(dev, diff_method='parameter-shift', cache=cache)\ndef circuit():\n    qml.RY(0.345, wires=0)\n    return qml.expval(qml.PauliZ(0))\n```\n\nLANGUAGE: pycon\nCODE:\n```\n>>> for _ in range(10):\n...    circuit()\n>>> dev.num_executions\n1\n```\n\n----------------------------------------\n\nTITLE: Using Custom Wire Labels in Quantum Function\nDESCRIPTION: This code snippet demonstrates how to use custom wire labels, defined during device initialization, within a quantum function. The `qml.RZ`, `qml.CNOT`, and `qml.RY` operations address the qubits (wires) using the labels 'q1', 'aux', and 'q2', respectively. The function returns the expectation value of the `qml.PauliZ` observable on wire 'q2'.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/circuits.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef my_quantum_function(x, y):\n    qml.RZ(x, wires='q1')\n    qml.CNOT(wires=['aux' ,'q1'])\n    qml.RY(y, wires='q2')\n    return qml.expval(qml.PauliZ('q2'))\n```\n\n----------------------------------------\n\nTITLE: Inspecting Resource Requirements from PennyLane Tracker History\nDESCRIPTION: Shows how to access and inspect the resource requirements of individual circuits from the `Tracker`'s history. The example retrieves the list of `resources` and prints the resources of the first circuit, as well as the number of wires for each circuit in the history.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n>>> resources = tracker.history[\"resources\"]\n>>> resources[0]\nwires: 1\ngates: 1\ndepth: 1\nshots: Shots(total=None)\ngate_types:\n{'Hadamard': 1}\ngate_sizes:\n{1: 1}\n>>> [r.num_wires for r in resources]\n[1, 2, 3, 4]\n```\n\n----------------------------------------\n\nTITLE: Updating variable in for loop\nDESCRIPTION: This code demonstrates updating a variable `x` within a for loop. The function `f` iterates through a list and adds each element to `x`, showcasing how AutoGraph handles variable updates across loop iterations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    for y in [0, 4, 5]:\n        x = x + y\n    return x\n```\n\n----------------------------------------\n\nTITLE: Sample Forward Pass in PennyLane\nDESCRIPTION: This code demonstrates a forward pass using qml.sample which is supported. The code defines a quantum circuit with sampling, illustrating that a forward pass is supported and will work as expected.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef sample_forward():\n    dev = qml.device('default.qubit', wires=1, shots=20)\n\n    @qml.qnode(dev)\n    def circuit(x):\n```\n\n----------------------------------------\n\nTITLE: Demonstrate Amplitude Amplification Results (Pycon)\nDESCRIPTION: This interactive python console snippet shows the output probabilities after applying amplitude amplification in a quantum circuit. It demonstrates that the amplitude of the target state (in this case, the |2> state) has been amplified.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> print(np.round(circuit(), 3))\n[0.01  0.01  0.931 0.01  0.01  0.01  0.01  0.01 ]\n```\n\n----------------------------------------\n\nTITLE: Defining custom decomposition with DecompositionNotApplicable\nDESCRIPTION: This code illustrates how to define a custom decomposition rule and mark it as not applicable under certain conditions using `DecompositionNotApplicable`. It registers a decomposition for `QubitUnitary` that is only applicable for single-qubit gates.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane.decomposition import DecompositionNotApplicable\nfrom pennylane.math.decomposition import zyz_rotation_angles\n\ndef _zyz_resource(num_wires):\n    if num_wires != 1:\n        # This decomposition is only applicable when num_wires is 1\n        raise DecompositionNotApplicable\n    return {qml.RZ: 2, qml.RY: 1, qml.GlobalPhase: 1}\n\n@qml.register_resources(_zyz_resource)\ndef zyz_decomposition(U, wires, **__):\n    phi, theta, omega, phase = zyz_rotation_angles(U, return_global_phase=True)\n    qml.RZ(phi, wires=wires[0])\n    qml.RY(theta, wires=wires[0])\n    qml.RZ(omega, wires=wires[0])\n    qml.GlobalPhase(-phase)\n\nqml.add_decomps(QubitUnitary, zyz_decomposition)\n```\n\n----------------------------------------\n\nTITLE: Square-Root X Gate in Python\nDESCRIPTION: This code demonstrates the use of the square-root X gate (`qml.SX`). The code defines a quantum circuit that applies the SX gate on wire 0 and then returns the expectation value of the PauliZ operator on the same wire.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.SX(wires=[0])\n    return qml.expval(qml.PauliZ(wires=[0]))\n```\n\n----------------------------------------\n\nTITLE: Device Level Drawing Example (PyCon)\nDESCRIPTION: This snippet uses `qml.draw` with `level=\"device\"` to visualize the circuit after device-specific transforms have been applied.  It demonstrates the final circuit structure that is executed on the specified device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> print(qml.draw(f, level=\"device\")())\n0: ──RX(0.28)─╭●────╭X──RX(0.70)─╭●────╭X─┤  <X>\n1: ──RX(0.52)─╰X─╭●─│───RX(0.65)─╰X─╭●─│──┤     \n2: ──RX(0.00)────╰X─╰●──RX(0.03)────╰X─╰●─┤     \n```\n\n----------------------------------------\n\nTITLE: Complex Conjugation using qml.math.conj\nDESCRIPTION: Demonstrates the use of `qml.math.conj` to compute the complex conjugate of a tensor-like object. This function dispatches to the appropriate tensor manipulation framework to maintain differentiability.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_22\n\nLANGUAGE: python\nCODE:\n```\na = np.array([1.0 + 2.0j])\nqml.math.conj(a)\n```\n\n----------------------------------------\n\nTITLE: Higher-Order Primitives and Transforms\nDESCRIPTION: This snippet demonstrates the interaction between higher-order primitives (for loops) and transforms when program capture is enabled. It illustrates that transforms do not apply through higher-order primitives.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\n\nqml.capture.enable()\n\n\ndev = qml.device('default.qubit', wires=1)\n\n\n@qml.transforms.merge_rotations\n\n@qml.qnode(dev)\n\ndef circuit():\n\n    qml.RX(0.1, wires=0)\n\n\n    for _ in range(4):\n\n        qml.RX(0.1, wires=0)\n\n        qml.RX(0.1, wires=0)\n\n\n    qml.RX(0.1, wires=0)\n\n\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Updating list elements with JAX .at and .set in while loop\nDESCRIPTION: This code shows how to update the elements of a JAX array within a `while` loop using the `.at` and `.set` methods.  It initializes an empty JAX array and then assigns the loop index to each element.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\ndef f():\n    my_list = jnp.empty(2, dtype=int)\n    i = 0\n    while i < 2:\n        my_list = my_list.at[i].set(i)  # not my_list[i] = i\n        i += 1\n    return my_list\n```\n\n----------------------------------------\n\nTITLE: AutoGraph Conversion Example\nDESCRIPTION: This example shows how AutoGraph converts a Python function containing a for loop and returns the converted code. It requires the PennyLane library and demonstrates the use of `qml.capture.autograph.autograph_source` to view the converted code.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_33\n\nLANGUAGE: python\nCODE:\n```\ndef f(n):\n    x = - jnp.log(n)\n    for k in range(1, n + 1):\n        x = x + 1 / k\n    return x\n```\n\nLANGUAGE: python\nCODE:\n```\nplxpr = make_plxpr(f)(0)\nprint(qml.capture.autograph.autograph_source(f))\n```\n\n----------------------------------------\n\nTITLE: Scaling and Composing PennyLane Operators\nDESCRIPTION: This code illustrates how to scale and compose PennyLane operators using the * and @ operators. It creates a prod_op by scaling an RX gate by 2 and composing it with an RY gate, both acting on wire 0. The code then prints the resulting operator and computes its matrix representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_20\n\nLANGUAGE: pycon\nCODE:\n```\n>>> prod_op = 2*qml.RX(1, wires=0) @ qml.RY(2, wires=0)\n>>> prod_op\n2*(RX(1, wires=[0])) @ RY(2, wires=[0])\n>>> qml.matrix(prod_op)\narray([[ 0.94831976-0.80684536j, -1.47692053-0.51806945j],\n       [ 1.47692053-0.51806945j,  0.94831976+0.80684536j]])\n```\n\n----------------------------------------\n\nTITLE: Approximate MPS Simulation with Default Tensor in PennyLane\nDESCRIPTION: Shows how to perform approximate matrix product state (MPS) simulations using the `default.tensor` device with a specified `max_bond_dim`. It defines a quantum circuit using the `SimplifiedTwoDesign` template and compares the expectation values calculated using `default.qubit` and `default.tensor` devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport numpy as np\n\nn_layers = 10\nn_wires = 10\n\ninitial_shape, weights_shape = qml.SimplifiedTwoDesign.shape(n_layers, n_wires)\nnp.random.seed(1967)\ninitial_layer_weights = np.random.random(initial_shape)\nweights = np.random.random(weights_shape)\n\ndef f():\n    qml.SimplifiedTwoDesign(initial_layer_weights, weights, range(n_wires))\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Device Jacobian Error with default.qubit in PennyLane\nDESCRIPTION: This code demonstrates the error that arises when trying to use the 'device' differentiation method with the 'default.qubit' device, which does not provide a native jacobian method. It defines a quantum circuit and attempts to calculate its gradient using qml.grad.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndef print_grad():\n    dev = qml.device('default.qubit', wires=1, shots=None)\n\n    @qml.qnode(dev, diff_method='device')\n    def circuit(x):\n        qml.RX(x[0], wires=0)\n        return qml.expval(qml.Z(wires=0))\n\n    x = np.array([0.1], requires_grad=True)\n    print(qml.grad(circuit)(x))\n```\n\n----------------------------------------\n\nTITLE: Framework-Agnostic Processing with qml.proc in Pycon\nDESCRIPTION: This example showcases the use of the `qml.proc` module, providing framework-agnostic processing functions for array and tensor manipulation. The call dispatches to the correct framework (e.g., torch, tensorflow).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> x = torch.tensor([1., 2.])\n>>> qml.proc.ones_like(x)\ntensor([1, 1])\n>>> y = tf.Variable([[0], [5]])\n>>> qml.proc.ones_like(y, dtype=np.complex128)\n<tf.Tensor: shape=(2, 1), dtype=complex128, numpy=\narray([[1.+0.j],\n       [1.+0.j]])>\n```\n\n----------------------------------------\n\nTITLE: Tapering Qubits with Molecular Symmetries in PennyLane\nDESCRIPTION: Demonstrates how to reduce the number of qubits required to simulate Hamiltonians by leveraging molecular symmetries using PennyLane. This involves generating the qubit Hamiltonian, determining its symmetries, and then tapering the Hamiltonian. Dependencies include NumPy and PennyLane's hf module.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.21.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# molecular geometry\nsymbols = [\"He\", \"H\"]\ngeometry = np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.4588684632]])\nmol = qml.hf.Molecule(symbols, geometry, charge=1)\n\n# generate the qubit Hamiltonian\nH = qml.hf.generate_hamiltonian(mol)(geometry)\n\n# determine Hamiltonian symmetries\ngenerators, paulix_ops = qml.hf.generate_symmetries(H, len(H.wires))\nopt_sector = qml.hf.optimal_sector(H, generators, mol.n_electrons)\n\n# taper the Hamiltonian\nH_tapered = qml.hf.transform_hamiltonian(H, generators, paulix_ops, opt_sector)\n```\n\n----------------------------------------\n\nTITLE: Using temporary variable in for loop\nDESCRIPTION: This code demonstrates the use of a temporary variable `c` within a for loop. The function `f` iterates through a list, calculates a value using `c` and the current element, and then adds it to `x`, showcasing that temporary variables are allowed within a loop with no type restrictions as long as they aren't passed to a function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    for y in [0, 4, 5]:\n        c = 2\n        x = x + y * c\n    return x\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Abstracted Axes Specified\nDESCRIPTION: This code demonstrates generating a JAXPR with a dynamic shape argument by explicitly specifying the abstracted axes.  It uses `jax.make_jaxpr` to create the jaxpr and specifies that the `n` argument (which determines the shape of `x`) is an abstracted axis.  It prints the \"inner jaxpr\" and demonstrates how `n` is promoted to an explicit input.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef f(n):\n    x = jax.numpy.ones((n,))\n    jaxpr = jax.make_jaxpr(jax.numpy.sum, abstracted_axes=(\"n\",))(x)\n    print(\"inner jaxpr: \", jaxpr)\n    return jax.core.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, n, x)\n    \njax.make_jaxpr(f)(3)\n```\n\n----------------------------------------\n\nTITLE: List Container Copying in PennyLane\nDESCRIPTION: Demonstrates that while parameter data is shared between shallow copies of PennyLane operations, the list container itself is not a reference. This allows modifying the parameters of the copied operation without mutating the original operation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_15\n\nLANGUAGE: pycon\nCODE:\n```\n>>> op.data is op2.data\nFalse\n```\n\n----------------------------------------\n\nTITLE: Applying simulator_tracking Decorator in PennyLane\nDESCRIPTION: This code demonstrates how to apply the `@qml.devices.modifiers.simulator_tracking` decorator to a custom device class `MyDevice` extending the `Device` class. The decorator enables simulator-like tracking behavior, useful when the device can simultaneously measure non-commuting measurements or handle parameter broadcasting.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@qml.devices.modifiers.simulator_tracking\nclass MyDevice(Device):\n    ...\n```\n\n----------------------------------------\n\nTITLE: AutoGraph Enabled Control Flow\nDESCRIPTION: This example shows how native Python control flow is preserved as a loop in the compiled program with AutoGraph enabled. This function uses a simple for loop with division and exponentiation operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    for i in range(2):\n        print(i, x)\n        x = x / 2\n    return x ** 2\nplxpr = make_plxpr(f, autograph=True)(0.0)\n```\n\n----------------------------------------\n\nTITLE: Define function with enumeration and dynamic variable\nDESCRIPTION: This code defines a function `f` that iterates through a JAX array `weights` using `enumerate`, accessing both the index `i` and the elements `x` and `y`. It performs calculations based on these values and returns the result, demonstrating how AutoGraph handles unpacking and enumeration through JAX arrays.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\ndef f(weights):\n    z = 0.\n    for i, (x, y) in enumerate(weights):\n        z = i * x + i ** 2 * y\n    return z\n```\n\n----------------------------------------\n\nTITLE: Workaround using regular function in qml.while_loop\nDESCRIPTION: Shows a workaround by using a regular Python function instead of a lambda function as the condition for qml.while_loop. This is another approach to resolve the AutoGraph issue with lambda functions. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\ndef func(x):\n    return x > 3\n\n@qml.qnode(dev)\ndef circuit():\n\n    @qml.while_loop(func)\n    def loop(a):\n        a += 1\n        return a\n\n    a = 0\n    loop(a)\n    \n    qml.RX(0, wires=0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Changing variable type within conditional\nDESCRIPTION: This code showcases the error that arises when changing the type of a variable within an `if` statement without also changing it in the `else` branch. The initial type of `y` is float, but it changes to integer within the 'if' condition. The resulting error stems from inconsistent types across conditional branches.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    y = -1.0\n    if x > 5:\n        y = 4\n    return y\n```\n\n----------------------------------------\n\nTITLE: Create HF State for Bravyi-Kitaev Mapping (Pycon)\nDESCRIPTION: This interactive python console snippet shows how to create a Hartree-Fock state compatible with the Bravyi-Kitaev mapping using qml.qchem.hf_state. It specifies the number of active electrons and spin orbitals, and sets the basis to \"bravyi_kitaev\".\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\n>>> state_bk = qml.qchem.hf_state(2, 6, basis=\"bravyi_kitaev\")\n>>> print(state_bk)\n[1 0 0 0 0 0]\n```\n\n----------------------------------------\n\nTITLE: Differentiable Batch Transforms in PennyLane\nDESCRIPTION: Demonstrates that batch transforms in PennyLane are fully differentiable.  The code calculates the gradient of a circuit that has been transformed using a batch transform.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_17\n\nLANGUAGE: pycon\nCODE:\n```\n>>> gradient = qml.grad(circuit)(-0.5)\n>>> print(gradient)\n2.5800122591960153\n```\n\n----------------------------------------\n\nTITLE: Converting binary representation to Pauli operator in PennyLane\nDESCRIPTION: This code snippet shows how to convert a binary vector representation back to a Pauli operator using `binary_to_pauli`.  It calculates the sum of two binary vector representations modulo 2 and converts the result back into an operator representation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_5\n\nLANGUAGE: pycon\nCODE:\n```\n>>> from pennylane.grouping import binary_to_pauli\n>>> binary_to_pauli((pauli_vec_1 + pauli_vec_2) % 2, wire_map)\nTensor product ['PauliY', 'PauliX']: 0 params, wires ['a', 'b']\n```\n\n----------------------------------------\n\nTITLE: Quantum Dot Product in PennyLane\nDESCRIPTION: This snippet demonstrates the usage of `qml.dot` to group coefficients together with corresponding Pauli operators in PennyLane. It showcases how to create a linear combination of Pauli operators with specified coefficients.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.29.0.md#_snippet_32\n\nLANGUAGE: pycon\nCODE:\n```\n>>> qml.dot(coeffs=[2, 2, 2], ops=[qml.PauliX(0), qml.PauliY(1), qml.PauliZ(2)])\n2*(PauliX(wires=[0]) + PauliY(wires=[1]) + PauliZ(wires=[2]))\n```\n\n----------------------------------------\n\nTITLE: Define a Custom Error Operation in PennyLane (Python)\nDESCRIPTION: This code defines a custom error operation, MyErrorOperation, inheriting from ErrorOperation. It overrides the error method to return a SpectralNormError instance based on a given error value. This is a building block for error propagation in larger quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass MyErrorOperation(ErrorOperation):\n    def __init__(self, error_val, wires):\n        self.error_val = error_val\n        super().__init__(wires=wires)\n\n    def error(self):\n        return SpectralNormError(self.error_val)\n```\n\n----------------------------------------\n\nTITLE: QNode with Pythonic Control Flow (Autograph)\nDESCRIPTION: This snippet demonstrates the use of Pythonic control flow (for loop) within a QNode. The autograph=False argument disables the automatic conversion of Pythonic control flow to PennyLane's control flow primitives.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2), autograph=False)\n\ndef circuit():\n\n    for _ in range(10):\n\n        qml.RX(0.1, 0)\n\n\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Define function with dynamic range\nDESCRIPTION: This code defines a function `f` that takes an integer `n` as input and uses it as the upper bound of a `range` function within a loop. Inside the loop, it updates a variable `x` based on the loop variable `k`.  This demonstrates that AutoGraph supports the `range` function even with a dynamic variable as input.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef f(n):\n    x = -jnp.log(n)\n    for k in range(1, n + 1):\n        x = x + 1 / k\n    return x\n```\n\n----------------------------------------\n\nTITLE: Jacobian of Pauli Decomposition Coefficients\nDESCRIPTION: This snippet calculates the Jacobian of the coefficients obtained from pauli_decompose using JAX. It showcases the differentiability of the pauli_decompose function. Dependencies: PennyLane, NumPy, JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n>>> import jax\n>>> from jax import numpy as np\n>>> jax.jacobian(find_coeffs)(np.array(2.))\nArray([0., 1.], dtype=float32, weak_type=True)\n```\n\n----------------------------------------\n\nTITLE: Incorrect Use of lambda in qml.while_loop\nDESCRIPTION: Illustrates the error when using a lambda function as the condition for qml.while_loop, which is not supported by AutoGraph. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml \n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\", wires=1)\n\n@qml.qnode(dev)\ndef circuit():\n\n    @qml.while_loop(lambda a: a > 3)\n    def loop(a):\n        a += 1\n        return a\n\n    a = 0\n    loop(a)\n\n    qml.RX(0, wires=0)\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Dynamically Configuring default.qubit Device in PennyLane\nDESCRIPTION: This example shows how to dynamically configure a 'default.qubit' device by creating an `ExecutionConfig` object and passing it to the `execute` method. This allows modifying the device's behavior during execution without changing its initial properties.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit')\nconfig = qml.devices.ExecutionConfig(device_options={\"rng\": 42})\ntape = qml.tape.QuantumTape([qml.Hadamard(0)], [qml.sample(wires=0)], shots=10)\ndev.execute(tape, config)\n```\n\nLANGUAGE: python\nCODE:\n```\narray([1, 0, 1, 1, 0, 1, 1, 1, 0, 0])\n```\n\nLANGUAGE: python\nCODE:\n```\ndev.execute(tape, config)\n```\n\nLANGUAGE: python\nCODE:\n```\narray([1, 0, 1, 1, 0, 1, 1, 1, 0, 0])\n```\n\n----------------------------------------\n\nTITLE: Pauli Operator Simplification\nDESCRIPTION: Demonstrates using `qml.simplify(qml.prod(pauli_1, pauli_2))` to simplify the product of two Pauli operators, replacing the removed `qml.pauli.pauli_mult` and `qml.pauli.pauli_mult_with_phase` functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nop = qml.simplify(qml.prod(qml.PauliX(0), qml.PauliZ(0)))\nop\n-1j*(PauliY(wires=[0]))\n[phase], [base] = op.terms()\nphase, base\n(-1j, PauliY(wires=[0]))\n```\n\n----------------------------------------\n\nTITLE: Transforming a QNode in PennyLane\nDESCRIPTION: Demonstrates how to apply a transform to a QNode in PennyLane. A transform takes a QNode instance and returns a new function that accepts the same arguments as the QNode and returns the desired outcome.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/inspecting_circuits.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.qnode(dev, diff_method='parameter-shift')\n... def my_qnode(x, a=True):\n...     # ...\n>>> new_func = my_transform(qnode)\n\nThis new function accepts the same arguments as the QNode and returns the desired outcome,\nsuch as a dictionary of the QNode's properties, a matplotlib figure drawing the circuit,\nor a DAG representing its connectivity structure.\n\n>>> new_func(0.1, a=False)\n```\n\n----------------------------------------\n\nTITLE: Listing Available Attributes for Dataset\nDESCRIPTION: This code retrieves and prints a list of available attributes for the 'qchem' dataset using the `qml.data.list_attributes` function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nqml.data.list_attributes(data_name=\"qchem\")\n```\n\n----------------------------------------\n\nTITLE: Metaclass Definition in Python\nDESCRIPTION: Defines a simple metaclass `MyMetaClass` that intercepts class creation and instantiation. The `__init__` method is called when a new type is created, adding a class property. The `__call__` method is invoked when an instance of the class is created, adding print statements around the default instantiation behavior.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nclass MyMetaClass(type):\n\n    def __init__(cls, *args, **kwargs):\n        print(f\"Creating a new type {cls} with {args}, {kwargs}. \")\n\n        # giving every class a property\n        cls.a = \"a\"\n\n    def __call__(cls, *args, **kwargs):\n        print(f\"creating an instance of type {cls} with {args}, {kwargs}. \")\n        inst = cls.__new__(cls, *args, **kwargs)\n        inst.__init__(*args, **kwargs)\n        return inst\n```\n\n----------------------------------------\n\nTITLE: JIT Compiling with CUDA Quantum\nDESCRIPTION: Demonstrates how to use the `@qml.qjit` decorator with the `compiler=\"cuda_quantum\"` argument to compile quantum circuits using CUDA Quantum.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_workflows.rst#_snippet_6\n\nLANGUAGE: Python\nCODE:\n```\ndev = qml.device(\"softwareq.qpp\", wires=2)\n\n@qml.qjit(compiler=\"cuda_quantum\")\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x[0], wires=0)\n    qml.RY(x[1], wires=1)\n    qml.CNOT(wires=[0, 1])\n    return qml.expval(qml.Y(0))\n```\n\n----------------------------------------\n\nTITLE: Execute GellMann Quantum Circuit\nDESCRIPTION: This snippet executes the quantum circuit defined to use qml.GellMann and returns the expectation value as a floating point number.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_27\n\nLANGUAGE: pycon\nCODE:\n```\n>>> circuit()\n-0.42264973081037416\n```\n\n----------------------------------------\n\nTITLE: Output from Rotosolve Optimization Steps\nDESCRIPTION: This is the console output showing the cost before each Rotosolve step, and the cost of each minimization substep. The optimization steps reduce the cost function to near its minimum value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.18.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\nCost before step: 0.042008210392535605\nMinimization substeps: [-0.230905 -0.863336 -0.980072 -0.980072 -1.       -1.       -1.      ]\nCost before step: -0.999999999068121\nMinimization substeps: [-1. -1. -1. -1. -1. -1. -1.]\nCost before step: -1.0\nMinimization substeps: [-1. -1. -1. -1. -1. -1. -1.]\n```\n\n----------------------------------------\n\nTITLE: Qutrit Basis State Preparation in PennyLane\nDESCRIPTION: Shows how to prepare qutrit basis states using `qml.QutritBasisState`.  A qutrit circuit is defined that prepares the [1, 1] basis state and then applies the `TAdd` operation, returning the probabilities of the second qutrit.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.31.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nwires = range(2)\ndev = qml.device(\"default.qutrit\", wires=wires)\n\n@qml.qnode(dev)\ndef qutrit_circuit():\n    qml.QutritBasisState([1, 1], wires=wires)\n    qml.TAdd(wires=wires)\n    return qml.probs(wires=1)\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> qutrit_circuit()\narray([0., 0., 1.])\n```\n\n----------------------------------------\n\nTITLE: Grouping Observables Example\nDESCRIPTION: Illustrates how to group commuting observables in PennyLane to reduce the number of circuit executions. It showcases the usage of `qml.pauli.group_observables` to split a list of observables and coefficients into commuting groups.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/compiling_circuits.rst#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nobs = [qml.Y(0), qml.X(0) @ qml.X(1), qml.Z(1)]\ncoeffs = [1.43, 4.21, 0.97]\ngroupings = qml.pauli.group_observables(obs, coeffs, 'anticommuting', 'lf')\nobs_groupings, coeffs_groupings = groupings\nobs_groupings\n```\n\nLANGUAGE: python\nCODE:\n```\ncoeffs_groupings\n```\n\n----------------------------------------\n\nTITLE: Native Python Control Flow Example\nDESCRIPTION: This example shows how native Python control flow is evaluated at compile time when AutoGraph is disabled. The loop is unrolled, and tracers are printed for each iteration of the loop. This function showcases a simple for loop and division.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_35\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    for i in range(2):\n        print(i, x)\n        x = x / 2\n    return x ** 2\nplxpr = make_plxpr(f, autograph=False)(0.0)\n```\n\n----------------------------------------\n\nTITLE: Accessing Nodes in PennyLane Commutation DAG\nDESCRIPTION: Illustrates how to access nodes and their properties in the commutation DAG, including successors, predecessors, and the underlying operation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> nodes = dag.get_nodes()\n>>> nodes\nNodeDataView({0: <pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x7f461c4bb580>, ...}, data='node')\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> second_node = dag.get_node(2)\n>>> second_node\n<pennylane.transforms.commutation_dag.CommutationDAGNode object at 0x136f8c4c0>\n>>> second_node.op\nCNOT(wires=[1, 2])\n>>> second_node.successors\n[3, 4, 5, 6]\n>>> second_node.predecessors\n[]\n```\n\n----------------------------------------\n\nTITLE: Building Harmonic Oscillator State Vectors in PennyLane\nDESCRIPTION: This code builds state vectors in the harmonic oscillator basis using the `HOState` class, specifying the number of modes, gridpoints, and initial state configurations. This setup is used for computing the perturbation error.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_30\n\nLANGUAGE: python\nCODE:\n```\n>>> gridpoints = 5\n>>> state1 = HOState(n_modes, gridpoints, {(0, 0): 1})\n>>> state2 = HOState(n_modes, gridpoints, {(1, 1): 1})\n```\n\n----------------------------------------\n\nTITLE: Debugging AutoGraph Conversion with Control Flow\nDESCRIPTION: This code defines a function `f` containing a for loop and conditional (if/else) statement to compute `y` and update `x` based on a comparison. It is used to demonstrate how to debug AutoGraph conversion by examining the `plxpr` representation of the compiled function and checking the captured control flow.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_32\n\nLANGUAGE: python\nCODE:\n```\ndef f(x, n):\n\n    for i in range(n):\n\n        if x > 5:\n            y = x ** 2\n        else:\n            y = x ** 3\n\n        x = x + y\n```\n\n----------------------------------------\n\nTITLE: Device Tracker Update (batch_execute)\nDESCRIPTION: This code snippet shows how to update the device tracker in the batch_execute method. It updates the tracker with the number of batches and the length of each batch.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nif self.tracker.active:\n    self.tracker.update(batches=1, batch_len=len(circuits))\n    self.tracker.record()\n```\n\n----------------------------------------\n\nTITLE: Broadcasting with Non-Tensorlike Arrays\nDESCRIPTION: This example demonstrates broadcasting with a non-tensorlike array (CountsMP) and how `broadcast_expand` transforms the result object into a NumPy ndarray of dtype object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ntape = qml.tape.QuantumScript((op,), (qml.counts(),), shots=50)\nresult = qml.device('default.qubit').execute(tape)\nresult\nbatch, fn = qml.transforms.broadcast_expand(tape)\nfn(qml.device('default.qubit').execute(batch))\n```\n\n----------------------------------------\n\nTITLE: Generating Vibrational Fragments in PennyLane\nDESCRIPTION: This snippet calls the `vibrational_fragments` function with the initialized parameters to get the harmonic and anharmonic fragments of the vibrational Hamiltonian. The function is part of the PennyLane Labs module for Trotter error estimation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_29\n\nLANGUAGE: python\nCODE:\n```\n>>> frags = vibrational_fragments(n_modes, freqs, taylor_coeffs)\n```\n\n----------------------------------------\n\nTITLE: Multiplying FermiWord with a JAX Array\nDESCRIPTION: This code shows how to multiply a `qml.fermi.FermiWord` object with a JAX array. The resulting object is a `FermiSentence` with the JAX array as the coefficient. This enhances compatibility between fermionic operators and JAX workflows.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.39.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> import jax.numpy as jnp\n>>> w = qml.fermi.FermiWord({(0, 0) : '+', (1, 1) : '-'})\n>>> jnp.array([3]) * w\nFermiSentence({FermiWord({(0, 0): '+', (1, 1): '-'}): Array([3], dtype=int32)})\n```\n\n----------------------------------------\n\nTITLE: Accessing Device Wires\nDESCRIPTION: This code snippet shows how to access and print the Wires object associated with a PennyLane device and an operation. It demonstrates how the device and operation store the wire labels internally.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nprint(dev.wires) #  Wires(['q11', 'q12', 'q21', 'q22'])\n\nop = Gate2(wires=['q21','q11'])\nprint(op.wires) # Wires(['q21', 'q11'])\n```\n\n----------------------------------------\n\nTITLE: Importing and Initializing for Trotter Error Calculation in PennyLane\nDESCRIPTION: This code snippet imports necessary modules from PennyLane and NumPy for calculating Trotter error. It initializes random harmonic frequencies and Taylor coefficients to create a vibrational Hamiltonian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_28\n\nLANGUAGE: python\nCODE:\n```\n>>> from pennylane.labs.trotter_error import HOState, vibrational_fragments, perturbation_error\n>>> import numpy as np\n>>> n_modes = 2\n>>> r_state = np.random.RandomState(42)\n>>> freqs = r_state.random(n_modes)\n>>> taylor_coeffs = [\n>>>     np.array(0),\n>>>     r_state.random(size=(n_modes, )),\n>>>     r_state.random(size=(n_modes, n_modes)),\n>>>     r_state.random(size=(n_modes, n_modes, n_modes))\n>>> ]\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Static Argnums\nDESCRIPTION: This snippet defines a function that creates an array of ones with a given shape and attempts to generate its JAXPR. When dynamic shapes are disabled, it results in a TypeError unless `static_argnums` is used to treat the shape as a static argument.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n%xmode Minimal\ndef f(n):\n    return jax.numpy.ones((n,))\n\njax.make_jaxpr(f)(3)\n```\n\n----------------------------------------\n\nTITLE: Formatting with Black in Bash\nDESCRIPTION: Formats the PennyLane source code and tests using Black with a line length of 100 characters.  This ensures PEP8 compliance. It operates on the 'pennylane' and 'tests' directories.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/pullrequests.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nblack -l 100 pennylane tests\n```\n\n----------------------------------------\n\nTITLE: Device Resource Tracker Output (Pycon)\nDESCRIPTION: Shows the output of the `qml.Tracker`, displaying the total executions, shots, batches, batch lengths, and the history of these values. Requires executing the previous Python code snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> tracker.totals\n{'executions': 3, 'shots': 300, 'batches': 1, 'batch_len': 2}\n>>> tracker.history\n{'executions': [1, 1, 1],\n 'shots': [100, 100, 100],\n 'batches': [1],\n 'batch_len': [2]}\n>>> tracker.latest\n{'batches': 1, 'batch_len': 2}\n```\n\n----------------------------------------\n\nTITLE: Using Device.supports_observable with string arguments in PennyLane\nDESCRIPTION: This snippet shows how to use the `Device.supports_observable` method with a string argument to check if a device supports a specific observable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.5.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev.supports_observable('PauliX')\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing PennyLane in Development Mode (Bash)\nDESCRIPTION: This snippet clones the PennyLane repository from GitHub, navigates into the cloned directory, and installs PennyLane in development mode using pip. The `-e` flag allows for changes to the source code to be immediately reflected when importing PennyLane in Python.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/installation.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone https://github.com/PennyLaneAI/pennylane\ncd pennylane\npip install -e .\n```\n\n----------------------------------------\n\nTITLE: Executing and Printing the Sampling Circuit\nDESCRIPTION: This snippet initializes a NumPy array 'x' with a value of pi/2, then executes the 'circuit' function with this array as input. The resulting samples from the circuit are then printed to the console. This demonstrates how to run the defined PennyLane circuit and view the output samples.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nx = np.array([np.pi / 2])\nprint(circuit(x))\n```\n\n----------------------------------------\n\nTITLE: Drawing Circuit with qml.apply (Pycon)\nDESCRIPTION: Shows how to draw the circuit after applying an operation using `qml.apply`. The output displays the circuit structure with the applied operation included. Requires the previous Python code snippet to be executed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)(0.6))\n 0: ──RY(0.6)──RX(0.4)──┤ ⟨Z⟩\n```\n\n----------------------------------------\n\nTITLE: Circuit Cutting with @qml.cut_circuit in PennyLane\nDESCRIPTION: This code demonstrates how to use the `@qml.cut_circuit` transform in PennyLane to run a three-wire circuit on a two-wire device. The circuit is partitioned into smaller fragments using `WireCut` operations, and the results are combined to recover the expected output. It uses the `default.qubit` device and includes a QNode definition.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.22.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.cut_circuit\n@qml.qnode(dev)\ndef circuit(x):\n    qml.RX(x, wires=0)\n    qml.RY(0.9, wires=1)\n    qml.RX(0.3, wires=2)\n\n    qml.CZ(wires=[0, 1])\n    qml.RY(-0.4, wires=0)\n\n    qml.WireCut(wires=1)\n\n    qml.CZ(wires=[1, 2])\n\n    return qml.expval(qml.grouping.string_to_pauli_word(\"ZZZ\"))\n```\n\n----------------------------------------\n\nTITLE: Matrix Representation with Wire Order in PennyLane\nDESCRIPTION: Shows how to obtain the matrix representation of a `qml.PauliRot` operator with a specified wire order.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nop = qml.PauliRot(0.2, \"X\", wires=[\"b\"])\nop.matrix(wire_order=[\"a\", \"b\"])\n```\n\n----------------------------------------\n\nTITLE: Device Tracker Update (custom)\nDESCRIPTION: This code snippet demonstrates how to update the device tracker with custom information, such as cost and a job ID.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/legacy_plugins.rst#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nprice_for_execution = 0.10\njob_id = \"abcde\"\nself.tracker.update(price=price_for_execution, job_id=job_id)\n```\n\n----------------------------------------\n\nTITLE: Modifying QubitDevice Statistics Method Signature in PennyLane\nDESCRIPTION: The signature of the `QubitDevice.statistics` method has been changed to accept a `QuantumTape` object instead of a list of observables and a circuit. This modification impacts how statistics are calculated on qubit devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\ndef statistics(self, circuit: QuantumTape, shot_range=None, bin_size=None):\n```\n\n----------------------------------------\n\nTITLE: Defining a Module Logger (Python)\nDESCRIPTION: This snippet demonstrates how to define a module logger in PennyLane. It imports the logging module and retrieves a logger instance using the __name__ of the current module.  This logger will track directories, filenames and function names based on the formatter configuration.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/logging.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nlogger = logging.getLogger(__name__)\n```\n\n----------------------------------------\n\nTITLE: Calculate Spectral Norm Error between Unitaries in PennyLane (Pycon)\nDESCRIPTION: This interactive python console snippet outputs the spectral norm error between two unitary operations using the SpectralNormError.get_error method. It shows the expected output of the get_error method from the previous snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n>>> SpectralNormError.get_error(intended_op, actual_op)\n0.004999994791668309\n```\n\n----------------------------------------\n\nTITLE: Accessing QuantumTape Items\nDESCRIPTION: Shows how to access the recorded operations and their metadata in a QuantumTape.  The `items()` method returns a list of tuples, where each tuple contains an operation and its corresponding metadata (e.g., parameter bindings).\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_tape.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\ntape.items()\n```\n\n----------------------------------------\n\nTITLE: Custom Staging Rule for Dynamic Output Shapes\nDESCRIPTION: This code defines a custom staging rule that hijacks how `DynamicJaxTracer` creates equations for the `prim3` primitive. It allows the shape of the output to depend on a dynamic input (`invars[0]` which represents `n` in the example). It directly creates a `DShapedArray` with the desired dynamic shape, bypassing the default abstract evaluation logic.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom jax._src.interpreters import partial_eval as pe\n\ndef custom_staging_rule(jaxpr_trace, *invars, **params):\n    new_shapes = [jax.core.DShapedArray((invars[0],2), jax.numpy.float32.dtype)]\n    out_tracers = [pe.DynamicJaxprTracer(jaxpr_trace, o) for o in new_shapes]\n    eqn = pe.new_jaxpr_eqn(\n        [jaxpr_trace.getvar(x) for x in invars],\n        [jaxpr_trace.makevar(o) for o in out_tracers],\n        prim3,\n        params,\n        jax.core.no_effects,\n    )\n    jaxpr_trace.frame.add_eqn(eqn)\n    return out_tracers\n\npe.custom_staging_rules[prim3] = custom_staging_rule\n```\n\n----------------------------------------\n\nTITLE: Observable Optimization with ExpvalCost in Python\nDESCRIPTION: This snippet illustrates how to use the `ExpvalCost` class to optimize observable measurements. The `optimize=True` argument enables qubit-wise commuting group evaluation using the `qml.grouping` module, potentially reducing the number of device executions. It initializes commuting observables, a Hamiltonian, a device, and an ansatz before defining the cost functions.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqml.enable_tape()\ncommuting_obs = [qml.PauliX(0), qml.PauliX(0) @ qml.PauliZ(1)]\nH = qml.vqe.Hamiltonian([1, 1], commuting_obs)\n\ndev = qml.device(\"default.qubit\", wires=2)\nansatz = qml.templates.StronglyEntanglingLayers\n\ncost_opt = qml.ExpvalCost(ansatz, H, dev, optimize=True)\ncost_no_opt = qml.ExpvalCost(ansatz, H, dev, optimize=False)\n\nparams = qml.init.strong_ent_layers_uniform(3, 2)\n```\n\n----------------------------------------\n\nTITLE: Rydberg System Hamiltonian Construction in PennyLane (Python)\nDESCRIPTION: This snippet demonstrates how to construct a Rydberg-system Hamiltonian using PennyLane's pulse programming module. It utilizes `qml.pulse.rydberg_drive` and `qml.pulse.rydberg_interaction` to define the Hamiltonian, and requires the `jax` library for numerical operations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.30.0.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom jax import numpy as jnp\n\natom_coordinates = [[0, 0], [0, 4], [4, 0], [4, 4]]\nwires = [0, 1, 2, 3]\n    \namplitude = lambda p, t: p * jnp.sin(jnp.pi * t)\nphase = jnp.pi / 2\ndetuning = 3 * jnp.pi / 4\n\nH_d = qml.pulse.rydberg_drive(amplitude, phase, detuning, wires)\nH_i = qml.pulse.rydberg_interaction(atom_coordinates, wires)\nH = H_d + H_i\n```\n\n----------------------------------------\n\nTITLE: Loading Specific Attributes from a Dataset\nDESCRIPTION: Shows how to load only specific attributes of a dataset using the `attributes` keyword argument in `qml.data.load()`. This allows users to retrieve only the necessary data, improving efficiency. It requires PennyLane and a quantum dataset available on Xanadu Cloud.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_1\n\nLANGUAGE: pycon\nCODE:\n```\n>>> H2_hamiltonian = qml.data.load(\n...\tdata_name=\"qchem\", molname=\"H2\", basis=\"STO-3G\", bondlength=1.1,\n...\tattributes=[\"molecule\", \"hamiltonian\"]\n... )[0]\n>>> H2_hamiltonian.hamiltonian\n<Hamiltonian: terms=15, wires=[0, 1, 2, 3]>\n```\n\n----------------------------------------\n\nTITLE: Drawing a Defer Measurement Circuit in PennyLane\nDESCRIPTION: This snippet demonstrates how to draw a quantum circuit with deferred measurements using PennyLane. It utilizes the `qml.draw` and `qml.defer_measurements` functions to visualize the simplified circuit after optimization.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(qml.defer_measurements(node))(0.6))\n0: ──RX(0.60)──|0⟩⟨0|─╭●─────────────────┤ ╭<Z@Z>\n1: ──RX(0.60)─────────│──╭●─╭X───────────┤ │\n2: ──RX(0.60)─────────│──│──│───|1⟩⟨1|───┤ │\n3: ───────────────────│──│──│──╭RX(0.50)─┤ ╰<Z@Z>\n4: ───────────────────╰X─│──│──│─────────┤\n5: ──────────────────────╰X─╰●─╰○────────┤\n```\n\n----------------------------------------\n\nTITLE: Drawing a PennyLane Circuit with Operator ID\nDESCRIPTION: This snippet demonstrates how to draw a PennyLane circuit using `qml.draw` and `qml.draw_mpl`, including the operator IDs. The ID is specified when instantiating the operator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> def circuit():\n...     qml.RX(0.123, id=\"data\", wires=0)\n>>> print(qml.draw(circuit)())\n```\n\n----------------------------------------\n\nTITLE: Consistent array dtypes in conditional\nDESCRIPTION: This example corrects the previous issue by ensuring that all branches assign the variable `y` with the same dtype (float64). This resolves the `ValueError` and allows the plxpr representation to be created successfully.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 1:\n        y = jnp.array([1.0, 2.0, 3.0])\n    else:\n        y = jnp.array([4.0, 5.0, 6.0])\n    return jnp.sum(y)\n```\n\n----------------------------------------\n\nTITLE: Converting Qiskit Noise Models to PennyLane output\nDESCRIPTION: This is the output of converting a qiskit noise model using the function `qml.from_qiskit_noise`\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.38.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.from_qiskit_noise(noise_model)\nNoiseModel({\n  OpIn(['RZ', 'RY']): QubitChannel(num_kraus=4, num_wires=1)\n  OpIn(['CNOT']): QubitChannel(num_kraus=16, num_wires=2)\n})\n```\n\n----------------------------------------\n\nTITLE: Repeat with Pytrees\nDESCRIPTION: Redefines the `repeat` function to handle pytrees for arbitrary inputs and outputs. It uses `FlatFn` to flatten the inputs and unflatten the outputs, allowing the repeated function to work with complex data structures.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef repeat(func, n: int):\n    def new_func(*args, **kwargs):\n\n        func_bound_kwargs = partial(func, **kwargs)\n        flat_fn = FlatFn(func_bound_kwargs)\n\n        jaxpr = jax.make_jaxpr(flat_fn)(*args)\n        flat_args, _ = jax.tree_util.tree_flatten(args)\n        n_consts = len(jaxpr.consts)\n        results = repeat_prim.bind(n, *jaxpr.consts, *flat_args, jaxpr=jaxpr.jaxpr, n_consts=n_consts)\n\n        # repack the results back into the cached pytree\n        assert flat_fn.out_tree is not None\n        return jax.tree_util.tree_unflatten(flat_fn.out_tree, results)\n    return new_func\n```\n\n----------------------------------------\n\nTITLE: Non-Interpreted JAX Primitive Definition\nDESCRIPTION: Defines a `NonInterpPrimitive` class that inherits from `jax.core.Primitive`. This custom primitive behaves like a standard Python function when evaluated with a `JVPTrace`, allowing the use of the chain rule without explicitly defining a JVP rule. An instance `fd_prim_2` of this primitive is created for the finite difference implementation. A wrapper function `finite_diff_2` binds the primitive to the input arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nclass NonInterpPrimitive(jax.core.Primitive):\n    \"\"\"A subclass to JAX's Primitive that works like a Python function\n    when evaluating JVPTracers.\"\"\"\n\n    def bind_with_trace(self, trace, args, params):\n        \"\"\"Bind the ``NonInterpPrimitive`` with a trace.\n        If the trace is a ``JVPTrace``, it falls back to a standard Python function call.\n        Otherwise, the bind call of JAX's standard Primitive is used.\"\"\"\n        if isinstance(trace, jax.interpreters.ad.JVPTrace):\n            return self.impl(*args, **params)\n        return super().bind_with_trace(trace, args, params)\n\nfd_prim_2 = NonInterpPrimitive(\"finite_diff_2\")\nfd_prim_2.multiple_results = True\nfd_prim_2.def_impl(finite_diff_impl) # This also defines the behaviour with a JVP tracer\n\ndef finite_diff_2(x, fun, delta=1e-5):\n    return fd_prim_2.bind(x, fun, delta)\n```\n\n----------------------------------------\n\nTITLE: Finite Difference Implementation (Python)\nDESCRIPTION: Defines a finite difference differentiation routine `finite_diff_impl` for a function `fun` with a single scalar argument. It calculates the approximate derivative using the central difference method.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_16\n\nLANGUAGE: python\nCODE:\n```\ndef finite_diff_impl(x, fun, delta):\n    \"\"\"Finite difference differentiation routine. Only supports differentiating\n    a function `fun` with a single scalar argument, for simplicity.\"\"\"\n\n    out_plus = fun(x + delta)\n    out_minus = fun(x - delta)\n    return tuple((out_p - out_m) / (2 * delta) for out_p, out_m in zip(out_plus, out_minus))\n\ndef fun(x):\n    return (x**2, 4 * x - 3, x**23)\n```\n\n----------------------------------------\n\nTITLE: PennyLane Circuit Output Example\nDESCRIPTION: This example shows the output of a PennyLane circuit. The output is a list of NumPy arrays, where each array represents samples generated by a different measurement.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.34.0.md#_snippet_10\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(circuit())\n[array([0, 0, 0, 0, 0]), array([1, 0, 0, 0, 0]), array([0, 1, 1, 1, 1])]\n```\n\n----------------------------------------\n\nTITLE: Computing Jacobian of QNode with NewObservable in Python\nDESCRIPTION: This snippet computes the Jacobian of the QNode that returns a `SpecialObject`. It demonstrates the differentiation of a custom observable returning a custom object.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_23\n\nLANGUAGE: pycon\nCODE:\n```\n>>> result = qml.jacobian(qnode)(0.2)\n>>> print(result)\n<__main__.SpecialObject object at 0x7fd2c54721f0>\n>>> print(result.item().val)\n-0.19866933079506116\n```\n\n----------------------------------------\n\nTITLE: AllSinglesDoubles Template Circuit Definition in Python\nDESCRIPTION: This snippet shows how to define a quantum circuit using the `AllSinglesDoubles` template and execute it to obtain an expectation value. It requires PennyLane and its `numpy` and `templates` submodules. The example sets up a quantum circuit with the template and executes it to obtain an expectation value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.templates import AllSinglesDoubles\n\nwires = range(qubits)\n\ndev = qml.device('default.qubit', wires=wires)\n\n@qml.qnode(dev)\ndef circuit(weights, hf_state, singles, doubles):\n    AllSinglesDoubles(weights, wires, hf_state, singles, doubles)\n    return qml.expval(qml.PauliZ(0))\n\nparams = np.random.normal(0, np.pi, len(singles) + len(doubles))\n```\n\n----------------------------------------\n\nTITLE: Example Sampling Output\nDESCRIPTION: This shows an example output from the sampling circuit. Each element in the array represents a sample from the qubit after the RX rotation is applied.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/unsupported_gradients.rst#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n[0 1 0 0 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0]\n```\n\n----------------------------------------\n\nTITLE: Horizontal Cartan Subalgebra Computation\nDESCRIPTION: This code demonstrates the computation of the horizontal Cartan subalgebra of m using horizontal_cartan_subalgebra. It also shows how to check if the elements in a are mutually commuting via qml.liealg.check_abelian.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.41.0.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.liealg import horizontal_cartan_subalgebra\nnewg, k, mtilde, a, new_adj = horizontal_cartan_subalgebra(k, m, return_adjvec=True)\n```\n\n----------------------------------------\n\nTITLE: Tapering Operations in qml.qchem using Z2 Symmetries\nDESCRIPTION: Demonstrates how to use `qml.qchem.taper_operation` to taper a gate operation according to :math:`\\mathbb{Z}_2` symmetries of the Hamiltonian.  It shows how to prepare the necessary inputs such as symmetry generators, Pauli-X operators, and an optimal sector.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_19\n\nLANGUAGE: pycon\nCODE:\n```\n>>> symbols = ['He', 'H']\n>>> geometry =  np.array([[0.0, 0.0, 0.0], [0.0, 0.0, 1.4589]])\n>>> mol = qml.qchem.Molecule(symbols, geometry, charge=1)\n>>> H, n_qubits = qml.qchem.molecular_hamiltonian(symbols, geometry)\n>>> generators = qml.qchem.symmetry_generators(H)\n>>> paulixops = qml.qchem.paulix_ops(generators, n_qubits)\n>>> paulix_sector = qml.qchem.optimal_sector(H, generators, mol.n_electrons)\n>>> tap_op = qml.qchem.taper_operation(qml.SingleExcitation, generators, paulixops,\n...                paulix_sector, wire_order=H.wires, op_wires=[0, 2])\n>>> tap_op(3.14159)\n[Exp(1.5707949999999993j PauliY)]\n```\n\n----------------------------------------\n\nTITLE: Sorting Python Imports with isort in Bash\nDESCRIPTION: Sorts Python imports using isort with specified options for Python 3.11 compatibility, Black profile, line length, project path, and file skipping.  This ensures consistent import ordering.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/pullrequests.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nisort --py 311 --profile black -l 100 -p ./pennylane --skip __init__.py --filter-files ./pennylane ./tests\n```\n\n----------------------------------------\n\nTITLE: Jinja Template for Underline Generation\nDESCRIPTION: This snippet creates an underline based on the class name using Jinja templating. It is intended for visual formatting under the title. No specific dependencies are required as this uses Jinja's templating capabilities.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_1\n\nLANGUAGE: jinja\nCODE:\n```\n{{ underline }}\n```\n\n----------------------------------------\n\nTITLE: Evaluating the JAXPR with a Dynamic Shaped Array\nDESCRIPTION: This code demonstrates evaluating a JAXPR created with the custom HOP. It explicitly uses `jax.core.eval_jaxpr` to evaluate the `jaxpr.jaxpr` with the constants and the dynamic shaped array as arguments. This evaluates the jaxpr from the above example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\njax.core.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, 2, jax.numpy.array([1,1]))\n```\n\n----------------------------------------\n\nTITLE: Define Repeat Primitive\nDESCRIPTION: Defines a JAX primitive for the `repeat` function using staged processing. It binds the function's JAXPR as metadata. It handles keyword arguments, consts and normal positional arguments by converting consts into positional arguments.  It demonstrates how higher-order primitives can be implemented in JAX.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nrepeat_prim = jax.core.Primitive(\"repeat\")\nrepeat_prim.multiple_results = True\n\nfrom functools import partial\nfrom typing import Callable\n\ndef repeat(func: Callable, n: int) -> Callable:\n    def new_func(*args, **kwargs):\n        func_bound_kwargs = partial(func, **kwargs)\n        jaxpr = jax.make_jaxpr(func_bound_kwargs)(*args)\n        n_consts = len(jaxpr.consts)\n        return repeat_prim.bind(n, *jaxpr.consts, *args, jaxpr=jaxpr.jaxpr, n_consts=n_consts)\n    return new_func\n```\n\n----------------------------------------\n\nTITLE: Drawing Split Non-Commuting Observables\nDESCRIPTION: This demonstrates drawing the circuit generated using `qml.transforms.split_non_commuting`.  Since qml.PauliX and qml.PauliZ do not commute, the single circuit is split into two separate circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.24.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print(qml.draw(circuit)(0.5))\n0: ──RX(0.50)─┤  <X>\n\\\n0: ──RX(0.50)─┤  <Z>\n```\n\n----------------------------------------\n\nTITLE: Registering PennyLane Devices with setuptools entry_points\nDESCRIPTION: This snippet illustrates how to register custom PennyLane devices using setuptools entry points in the `setup.py` file. It defines a list of devices, specifying their names and the corresponding module and class where they are defined.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\ndevices_list = [\n    'example.mydevice1 = MyModule.MySubModule:MyDevice1'\n    'example.mydevice2 = MyModule.MySubModule:MyDevice2'\n],\nsetup(entry_points={'pennylane.plugins': devices_list})\n```\n\n----------------------------------------\n\nTITLE: Defining Device Configuration File Path in Python\nDESCRIPTION: This code snippet shows how to define the `config_filepath` class variable within a PennyLane device class. This variable points to a TOML configuration file that describes the device's capabilities, such as supported gates and features.  The `path.join` function ensures that the file path is constructed correctly regardless of the operating system.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom os import path\nfrom pennylane.devices import Device\n\nclass MyDevice(Device):\n    \"\"\"My Documentation.\"\"\"\n\n    config_filepath = path.join(path.dirname(__file__), \"relative/path/to/config.toml\")\n```\n\n----------------------------------------\n\nTITLE: Using the broadcasting function\nDESCRIPTION: This snippet demonstrates how to construct templates easily using the `qml.broadcast()` function, which applies single quantum operations or other templates to wires in a specific pattern. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.templates import template\n\n@template\ndef mytemplate(pars, wires):\n    qml.Hadamard(wires=wires)\n    qml.RY(pars, wires=wires)\n\ndev = qml.device('default.qubit', wires=3)\n\n@qml.qnode(dev)\ndef circuit(pars):\n    qml.broadcast(mytemplate, pattern=\"single\", wires=[0,1,2], parameters=pars)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Evaluating nested function capture\nDESCRIPTION: This code snippet evaluates the plxpr representation of the nested function using `eval_jaxpr`. It initializes the input with the correct type and shape, as required by the `make_plxpr` function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nplxpr = make_plxpr(g)(0.0, 1)  # initialize with arguments of correct type and shape\neval_jaxpr(plxpr.jaxpr, plxpr.consts, 0.4, 6)\n```\n\n----------------------------------------\n\nTITLE: Jinja Template for Removing __init__ Method\nDESCRIPTION: This Jinja code removes the `__init__` method from the methods list if it exists. This is likely to prevent redundant or overwhelming documentation of the constructor. It relies on the `methods` variable being a Python list that supports `remove()`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_3\n\nLANGUAGE: jinja\nCODE:\n```\n{% if '__init__' in methods %}\n  {% set caught_result = methods.remove('__init__') %}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Quantum Gradient Method Definition in PennyLane\nDESCRIPTION: Defines a function `gradient_method` that generates quantum tapes for gradient computation and a classical processing function to process the results. This separates quantum and classical processing steps for gradient calculations in tape mode.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\ndef gradient_method(idx, param, **options):\n    # generate the quantum tapes that must be computed\n    # to determine the quantum gradient\n    tapes = quantum_gradient_tapes(self)\n\n    def processing_fn(results):\n        # perform classical processing on the evaluated tapes\n        # returning the evaluated quantum gradient\n        return classical_processing(results)\n\n    return tapes, processing_fn\n```\n\n----------------------------------------\n\nTITLE: Previous Operator Equality and Hashing Behaviour\nDESCRIPTION: Demonstrates the previous behaviour of `Operator.__eq__` and `Operator.__hash__` in PennyLane. This example showcases the behaviour prior to the changes in operator equality and hashing, for comparison.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nqml.RX(0.1, wires=0) == qml.RX(0.1, wires=0)\nFalse\n{qml.PauliZ(0), qml.PauliZ(0)}\n{PauliZ(wires=[0]), PauliZ(wires=[0])}\n```\n\n----------------------------------------\n\nTITLE: Defining PennyLane Operators for Hashing\nDESCRIPTION: This code snippet demonstrates how to define two PennyLane operators using `qml.PauliX`. Both operators, `op1` and `op2`, are instances of `qml.PauliX` acting on wire 0. This setup is used to illustrate the changes in how operators are hashed.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nop1 = qml.PauliX(0)\nop2 = qml.PauliX(0)\n```\n\n----------------------------------------\n\nTITLE: Defining Quantum Circuit with FlipSign Operator\nDESCRIPTION: This code defines a quantum circuit using the `FlipSign` operator. It initializes a default qubit device with 2 wires, applies Hadamard gates to each wire, applies the `FlipSign` operator to the state [0, 1], and returns the state.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nbasis_state = [0, 1]\n\ndev = qml.device(\"default.qubit\", wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n  for wire in list(range(2)):\n        qml.Hadamard(wires = wire)\n  qml.FlipSign(basis_state, wires = list(range(2)))\n  return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Creating plxpr with AutoGraph\nDESCRIPTION: This snippet demonstrates how to create a plxpr representation of a Python function using AutoGraph. The `make_plxpr` function is used to capture the function, and the resulting plxpr object can then be evaluated using `eval_jaxpr` from `jax.core`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.capture import make_plxpr\n\ndef f(x):\n    if x > 5:\n        x = x ** 2\n    return x\n\n\nplxpr = make_plxpr(f)(0.0)  # x will be a float\n```\n\n----------------------------------------\n\nTITLE: Custom HOP with Shape Matching Requirement\nDESCRIPTION: This code defines another custom JAX primitive (`prim2`) that enforces that the output shape of the inner function *matches* one of the inputs. This is useful for scenarios like for loops or while loops where the output shapes are expected to be the same as the input shapes. The implementation and abstract evaluation rules are adapted to this constraint.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nprim2 = jax.core.Primitive(\"hop\")\nprim2.multiple_results = True\n\n@prim2.def_impl\ndef _(*args, jaxpr, n_consts, in_abstract_inds):\n    return jax.core.eval_jaxpr(jaxpr, args[:n_consts], *args[n_consts:])\n\n@prim2.def_abstract_eval\ndef _(*args, jaxpr, n_consts, n_abstract_inds):\n    return args[n_consts+n_abstract_inds:]\n\ndef bind_prim2(f, *args):\n    abstracted_axes, abstract_shapes  = determine_abstracted_axes(args)\n    jaxpr = jax.make_jaxpr(f, abstracted_axes=abstracted_axes)(*args)\n    return prim2.bind(*jaxpr.consts, *abstract_shapes, *args,\n                      jaxpr=jaxpr.jaxpr,\n                      n_consts=len(jaxpr.consts),\n                      n_abstract_inds=len(abstract_shapes)\n                     )\n```\n\n----------------------------------------\n\nTITLE: Boolean Function for Wire Check - Python\nDESCRIPTION: This example demonstrates how to create a Boolean function that checks if an operation is acting on a specific wire using `qml.noise.wires_eq`.  It creates a function that returns `True` if an operation acts on wire 0, and `False` otherwise. `qml.PauliX` is used here as an example.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_noise.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n>>> fn = qml.noise.wires_eq(0)\n>>> op1, op2 = qml.PauliX(0), qml.PauliX(1)\n>>> fn(op1)\nTrue\n>>> fn(op2)\nFalse\n```\n\n----------------------------------------\n\nTITLE: Generating Underline with Jinja2\nDESCRIPTION: This snippet generates an underline for the object name using '=' characters. The length of the underline is determined by the length of the `mod` variable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary_core/base.rst#_snippet_2\n\nLANGUAGE: Jinja2\nCODE:\n```\n{{ mod }}.{{ objname }}\n={% for i in range(mod|length) %}={% endfor %}{{ underline }}\n```\n\n----------------------------------------\n\nTITLE: Standard JAX Primitive Definition for Finite Difference\nDESCRIPTION: Promotes the `finite_diff_impl` function to a standard `jax.core.Primitive` named `finite_diff`. A wrapper function `finite_diff` binds the primitive to the input arguments.  No JVP rule is defined.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\nfd_prim = jax.core.Primitive(\"finite_diff\")\nfd_prim.multiple_results = True\nfd_prim.def_impl(finite_diff_impl)\n\ndef finite_diff(x, fun, delta=1e-5):\n    return fd_prim.bind(x, fun, delta)\n```\n\n----------------------------------------\n\nTITLE: Printing QNode Information with PyTorch Interface (Python)\nDESCRIPTION: This snippet demonstrates how to print a QNode object in PennyLane, displaying information about the device, quantum function, number of wires, and interface used. The QNode is configured with the 'default.qubit' device, a function named 'circuit', two wires, and the PyTorch interface. This improvement enhances the debugging and understanding of QNode configurations.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.3.0.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> print(qnode)\n<QNode: device='default.qubit', func=circuit, wires=2, interface=PyTorch>\n```\n\n----------------------------------------\n\nTITLE: Metaclass for JAX Primitives\nDESCRIPTION: Defines a metaclass `PrimitiveMeta` that creates a JAX primitive for each new class defined with it.  The `__init__` method sets up the primitive, defines its implementation (`def_impl`) to handle normal class creation, and defines its abstract evaluation (`def_abstract_eval`) to return a shaped array. The `__call__` method binds the primitive to the arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nclass PrimitiveMeta(type):\n\n    def __init__(cls, *args, **kwargs):\n        # here we set up the primitive\n        primitive = jax.core.Primitive(cls.__name__)\n\n        @primitive.def_impl\n        def _(*inner_args, **inner_kwargs):\n            # just normal class creation if not tracing\n            return type.__call__(cls, *inner_args, **inner_kwargs)\n\n        @primitive.def_abstract_eval\n        def _(*inner_args, **inner_kwargs):\n            # here we say that we just return an array of type float32 and shape (1,)\n            # other abstract types could be used instead\n            return jax.core.ShapedArray((1,), jax.numpy.float32)\n\n        cls._primitive = primitive\n\n    def __call__(cls, *args, **kwargs):\n        return cls._primitive.bind(*args, **kwargs)\n```\n\n----------------------------------------\n\nTITLE: Evaluating plxpr with eval_jaxpr\nDESCRIPTION: This snippet shows how to evaluate a plxpr representation using `eval_jaxpr` from `jax.core`. It requires the `jaxpr` and `consts` attributes from the plxpr object, as well as the input arguments for the original function.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom jax.core import eval_jaxpr\neval_jaxpr(plxpr.jaxpr, plxpr.consts, 5.3)  # evaluate f(5.3)\n```\n\n----------------------------------------\n\nTITLE: Getting Interface with qml.math.get_interface\nDESCRIPTION: This example shows how to use the `qml.math.get_interface` function to determine the interface of tensors (e.g., 'torch' or 'numpy').\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.27.0.md#_snippet_33\n\nLANGUAGE: pycon\nCODE:\n```\n>>> torch_scalar = torch.tensor(1)\n>>> torch_tensor = torch.Tensor([2, 3, 4])\n>>> numpy_tensor = np.array([5, 6, 7])\n>>> qml.math.get_interface(torch_scalar)\n'torch'\n>>> qml.math.get_interface(numpy_tensor)\n'numpy'\n```\n\n----------------------------------------\n\nTITLE: Shallow Copying Operations in PennyLane\nDESCRIPTION: Demonstrates shallow copying of PennyLane operations using the `copy` module. While the list container is not a reference, parameter data is shared between the original and copied operation until one of the tape's parameter list is modified.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> import copy\n>>> op = qml.RX(0.2, wires=0)\n>>> op2 = copy.copy(op)\n>>> op.data[0] is op2.data[0]\nTrue\n```\n\n----------------------------------------\n\nTITLE: Packaging with MANIFEST.in\nDESCRIPTION: This snippet shows how to include a data file using a `MANIFEST.in` file.  The `include` directive specifies the path to the file (`device_name.toml`) that should be included in the distribution. This is used in conjunction with `include_package_data=True` in the `setup.py` file. The file path should be relative to the project's root directory.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/plugins.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\ninclude path/to/config/device_name.toml\n```\n\n----------------------------------------\n\nTITLE: Sphinx Autoattribute Directive for Attributes\nDESCRIPTION: This snippet uses the Sphinx autoattribute directive to generate detailed documentation for each attribute.  The `if item not in inherited_members` condition ensures that only attributes defined in the current class are documented, preventing duplication from inherited members. This assumes the `inherited_members` variable is properly populated.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_6\n\nLANGUAGE: jinja\nCODE:\n```\n{% for item in attributes %}\n{%- if item not in inherited_members %}\n.. autoattribute:: {{ item }}\n{%- endif %}\n{%- endfor %}\n```\n\n----------------------------------------\n\nTITLE: HTML for Attribute Details Header\nDESCRIPTION: This HTML snippet creates a collapsible header for the attribute details section. It uses Bootstrap classes (`collapse-header`, `collapse`, `fas`, `fa-angle-down`) to implement the collapsible functionality.  It relies on Bootstrap's CSS and JavaScript for styling and behavior.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_4\n\nLANGUAGE: html\nCODE:\n```\n<a class=\"attr-details-header collapse-header\" data-toggle=\"collapse\" href=\"#attrDetails\" aria-expanded=\"false\" aria-controls=\"attrDetails\">\n   <h2 style=\"font-size: 24px;\">\n      <i class=\"fas fa-angle-down rotate\" style=\"float: right;\"></i> Attributes\n   </h2>\n</a>\n<div class=\"collapse\" id=\"attrDetails\">\n```\n\n----------------------------------------\n\nTITLE: Batch Input Usage Before Breaking Change (Python)\nDESCRIPTION: This example shows how `qml.batch_input` was used before a breaking change. The `argnum` argument was optional, defaulting to 0, assuming batched inputs were the first argument of the quantum circuit. This no longer works, and `argnum` must now be specified.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.25.0.md#_snippet_39\n\nLANGUAGE: Python\nCODE:\n```\ndev = qml.device(\"default.qubit\", wires=2, shots=None)\n\n@qml.batch_input()  # argnum = 0\n@qml.qnode(dev, diff_method=\"parameter-shift\", interface=\"tf\")\ndef circuit(inputs, weights):  # argument `inputs` is batched\n    qml.RY(weights[0], wires=0)\n    qml.AngleEmbedding(inputs, wires=range(2), rotation=\"Y\")\n    qml.RY(weights[1], wires=1)\n    return qml.expval(qml.PauliZ(1))\n```\n\n----------------------------------------\n\nTITLE: Slicing with Dynamic Shapes\nDESCRIPTION: This snippet demonstrates a limitation of dynamic shapes: slicing into a dynamically sized array. It shows that attempting to slice a dynamically sized array results in a `TracerBoolConversionError`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef h(x):\n    return x[0]\n\njax.make_jaxpr(h, abstracted_axes=(\"x\", ) )(jax.numpy.array([0, 1, 2]))\n```\n\n----------------------------------------\n\nTITLE: JAXPR Generation with Static Shape\nDESCRIPTION: This snippet generates a JAXPR for a function that creates an array of ones, specifying the shape argument as static. This allows JAXPR generation when dynamic shapes are disabled, but the resulting JAXPR is specific to the given shape.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\njax.make_jaxpr(f, static_argnums=0)(3)\n```\n\n----------------------------------------\n\nTITLE: Enable Dynamic Shapes in JAX\nDESCRIPTION: This snippet enables the experimental dynamic shapes feature in JAX. This allows creating arrays with sizes that depend on abstract values during JAXPR generation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\njax.config.update(\"jax_dynamic_shapes\", True)\n```\n\n----------------------------------------\n\nTITLE: Initializing Random Number Generator and Matrices with NumPy\nDESCRIPTION: This code snippet demonstrates how to initialize a random number generator using NumPy and generate random matrices using different distributions. The first matrix is created with a uniform distribution between 0 and 1, while the second matrix is created with a standard normal distribution, and its gradient is disabled.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane import numpy as np\n\nrng = np.random.default_rng()\nrandom_mat1 = rng.random((3,2))\nrandom_mat2 = rng.standard_normal(3, requires_grad=False)\n```\n\n----------------------------------------\n\nTITLE: Accessing Configuration Settings in PennyLane using Python\nDESCRIPTION: This snippet demonstrates how to access the loaded PennyLane configuration, view the configuration filepath, print the configuration options, and access them via keys.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/configuration.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n>>> import pennylane as qml\n>>> qml.default_config.path\n'config.toml'\n>>> print(qml.default_config)\n{'main': {'shots': 1000},\n 'default': {'gaussian': {'hbar': 2}},\n 'strawberryfields': {'fock': {'cutoff_dim': 10, 'shots': 1000, 'hbar': 2}}\n}\n```\n\n----------------------------------------\n\nTITLE: Metric Tensor Transform with functools.partial\nDESCRIPTION: Illustrates how to pass additional arguments to the `qml.metric_tensor` transform when decorating a QNode, using `functools.partial`.  This approach replaces the previously-recommended method of directly passing the arguments to the decorator.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom functools import partial\n\n@partial(qml.metric_tensor, approx=\"block-diag\")\n@qml.qnode(dev)\ndef circuit(weights):\n    ...\n```\n\n----------------------------------------\n\nTITLE: Executing probs Measurement with Empty Wires\nDESCRIPTION: This code shows how executing a quantum circuit with `qml.probs()` with empty wires returns a probability distribution.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/workflow/return_types_spec.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nqml.probs().wires\ntape = qml.tape.QuantumScript([qml.S(0)], (qml.probs(),))\nqml.device('default.qubit').execute(tape)\nqml.device('default.mixed', wires=(0,1,2)).execute(tape)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Autosummary Directive for Attributes\nDESCRIPTION: This snippet uses the Sphinx autosummary directive to create a summary table of class attributes.  The `:nosignatures:` option suppresses the display of signatures. This relies on Sphinx autosummary extension to be enabled.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_5\n\nLANGUAGE: jinja\nCODE:\n```\n.. autosummary::\n   :nosignatures:\n{% for item in attributes %}\n   ~{{ name }}.{{ item }}\n{%- endfor %}\n```\n\n----------------------------------------\n\nTITLE: Import JAX\nDESCRIPTION: This snippet imports the JAX library, which is a prerequisite for using any JAX functionality.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n```\n\n----------------------------------------\n\nTITLE: File Structure for Adding New Module to Docs\nDESCRIPTION: This code shows how to structure the RST file for documenting new modules in PennyLane.  It contains the include directive to include the actual code, and the language to use for syntax highlighting.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_5\n\nLANGUAGE: rest\nCODE:\n```\n.. literalinclude:: example_module_rst.txt\n   :language: rest\n```\n\n----------------------------------------\n\nTITLE: Using qml.cond with missing false branch\nDESCRIPTION: Demonstrates the error that occurs when using qml.cond without providing a 'false_fn' when the 'true_fn' returns a value. This showcases the requirement for matching return types in both branches when program capture is enabled. Requires the pennylane library.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\n\nqml.capture.enable()\n\n@qml.qnode(qml.device(\"default.qubit\", wires=2))\ndef circuit():\n\n    def true_branch(x):\n        return qml.X(0)\n\n    m0 = qml.measure(0)\n    qml.cond(m0, true_branch)(4)\n\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Set environment variables for M1 Mac (Bash)\nDESCRIPTION: This snippet provides commands to set environment variables required to install the grpcio package (a TensorFlow dependency) on M1 Macs running Python 3.8. Setting `GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1` and `GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1` resolves installation issues specific to this configuration.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_10\n\nLANGUAGE: bash\nCODE:\n```\nexport GRPC_PYTHON_BUILD_SYSTEM_OPENSSL=1\nexport GRPC_PYTHON_BUILD_SYSTEM_ZLIB=1\n```\n\n----------------------------------------\n\nTITLE: Creating and Iterating over QuantumTape Objects\nDESCRIPTION: This code shows how to create a `QuantumTape` object and iterate over its contained operations and measurements. It uses a `with` statement to define a quantum circuit within the tape, including RX, RY, and CNOT gates, as well as an expectation value measurement. The code then demonstrates iterating over the tape and accessing individual operations by index.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nwith qml.tape.QuantumTape() as tape:\n    qml.RX(0.432, wires=0)\n    qml.RY(0.543, wires=0)\n    qml.CNOT(wires=[0, 'a'])\n    qml.RX(0.133, wires='a')\n    qml.expval(qml.PauliZ(wires=[0]))\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom Transform in PennyLane with Scaling Shots\nDESCRIPTION: This code snippet defines a custom transform called `scale_shots` that scales the number of shots in a quantum tape. It takes a quantum tape and a shot scaling factor as input, creates a new tape with the scaled shots, and returns the new tape along with a post-processing function. It demonstrates how to integrate transform programs with the QNode in PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.32.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\ndef null_postprocessing(results: qml.typing.ResultBatch) -> qml.typing.Result:\n    return results[0]\n\n@qml.transforms.core.transform\ndef scale_shots(tape: qml.tape.QuantumTape, shot_scaling) -> (Tuple[qml.tape.QuantumTape], Callable):\n    new_shots = tape.shots.total_shots * shot_scaling\n    new_tape = qml.tape.QuantumScript(tape.operations, tape.measurements, shots=new_shots)\n    return (new_tape, ), null_postprocessing\n\ndev = qml.devices.experimental.DefaultQubit2()\n\n@partial(scale_shots, shot_scaling=2)\n@qml.qnode(dev, interface=None)\ndef circuit():\n    return qml.sample(wires=0)\n```\n\n----------------------------------------\n\nTITLE: Applying Permutations to Wires\nDESCRIPTION: Demonstrates how to use the Permute subroutine in PennyLane to apply permutations to wires.  This allows reordering the qubits for specific quantum algorithms.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.14.0.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\ndev = qml.device('default.qubit', wires=5)\n\n@qml.qnode(dev)\ndef apply_perm():\n    # Send contents of wire 4 to wire 0, of wire 2 to wire 1, etc.\n    qml.templates.Permute([4, 2, 0, 1, 3], wires=dev.wires)\n    return qml.expval(qml.PauliZ(0))\n```\n\n----------------------------------------\n\nTITLE: Calculating Expectation Value in PennyLane\nDESCRIPTION: This snippet demonstrates how to calculate the expectation value of a matrix for pure states using `qml.math.expectation_value`.  It requires a state vector and an operator matrix as input.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.37.0.md#_snippet_21\n\nLANGUAGE: pycon\nCODE:\n```\n>>> state_vector = [1/np.sqrt(2), 0, 1/np.sqrt(2), 0]\n>>> operator_matrix = qml.matrix(qml.PauliZ(0), wire_order=[0,1])\n>>> qml.math.expectation_value(operator_matrix, state_vector)\ntensor(-2.23711432e-17+0.j, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Unwrapping PennyLane NumPy Tensors\nDESCRIPTION: This snippet demonstrates the use of the `unwrap()` method to convert a PennyLane NumPy tensor to a standard NumPy array or Python scalar. It converts a PennyLane NumPy array `x` to a Python scalar using `x.unwrap()` and prints the result, losing differentiability information.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n>>> x = np.array(1.543, requires_grad=False)\n>>> x.unwrap()\n1.543\n```\n\n----------------------------------------\n\nTITLE: Using ArbitraryStatePreparation and ArbitraryUnitary Templates\nDESCRIPTION: This snippet demonstrates how to use the `ArbitraryStatePreparation` and `ArbitraryUnitary` templates in PennyLane, which prepare an arbitrary basis state and perform an arbitrary unitary transformation, respectively.  They use the `PauliRot` gate. Requires PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ndev = qml.device('default.qubit', wires=3)\n\n@qml.qnode(dev)\ndef circuit(weights1, weights2):\n      qml.templates.ArbitraryStatePreparation(weights1, wires=[0, 1, 2])\n      qml.templates.ArbitraryUnitary(weights2, wires=[0, 1, 2])\n      return qml.probs(wires=[0, 1, 2])\n```\n\n----------------------------------------\n\nTITLE: PennyLane NumPy Array Summation\nDESCRIPTION: This snippet illustrates how the `np.sum()` function now returns a PennyLane tensor instead of a Python scalar. It demonstrates summing the elements of a NumPy array `x` and printing the resulting tensor with `requires_grad=True`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\n>>> np.sum(x)\ntensor(6, requires_grad=True)\n```\n\n----------------------------------------\n\nTITLE: Disable Dynamic Shapes in JAX\nDESCRIPTION: This snippet disables the experimental dynamic shapes feature in JAX. It's used to demonstrate the default behavior when dynamic shapes are not enabled.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\njax.config.update(\"jax_dynamic_shapes\", False)\n```\n\n----------------------------------------\n\nTITLE: PennyLane NumPy Array Indexing\nDESCRIPTION: This snippet shows the change in PennyLane's NumPy module where array element indexing now returns a PennyLane tensor instead of a Python scalar. It demonstrates accessing an element of a NumPy array `x` and printing the resulting tensor.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.12.0.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\n>>> x = np.array([1, 2, 3], requires_grad=False)\n>>> x[0]\ntensor(1, requires_grad=False)\n```\n\n----------------------------------------\n\nTITLE: Using Device.supports_observable with class arguments in PennyLane\nDESCRIPTION: This snippet shows how to use the `Device.supports_observable` method with a class argument to check if a device supports a specific observable.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.5.0.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\ndev.supports_observable(qml.PauliX)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Autosummary Directive for Methods\nDESCRIPTION: This snippet generates a summary table of the class's methods using the Sphinx autosummary directive.  The `:nosignatures:` option is used to prevent signature display in the summary. This expects that the Sphinx autosummary extension is enabled.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_8\n\nLANGUAGE: jinja\nCODE:\n```\n.. autosummary::\n{% for item in methods %}\n   ~{{ name }}.{{ item }}\n{%- endfor %}\n```\n\n----------------------------------------\n\nTITLE: MaxCut Graph and Wires Definition in QAOA - Python\nDESCRIPTION: This code snippet defines the wires and the graph on which the MaxCut problem is being performed using PennyLane and NetworkX. It imports necessary libraries, defines the number of wires, and creates a graph representing the connections between the wires.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/code/qml_qaoa.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nfrom pennylane import qaoa\nfrom networkx import Graph\n\n# Defines the wires and the graph on which MaxCut is being performed\nwires = range(3)\ngraph = Graph([(0, 1), (1, 2), (2, 0)])\n```\n\n----------------------------------------\n\nTITLE: Device Resource Tracker with Callback (Pycon)\nDESCRIPTION: Demonstrates how to use a custom callback function with `qml.Tracker` to monitor device information updates during execution, specifically printing the total shots. Requires PennyLane installation and a QNode defined with a device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_11\n\nLANGUAGE: pycon\nCODE:\n```\n>>> def shots_info(totals, history, latest):\n...     print(\"Total shots: \", totals['shots'])\n>>> with qml.Tracker(circuit.device, callback=shots_info) as tracker:\n...     qml.grad(circuit)(0.1)\nTotal shots:  100\nTotal shots:  200\nTotal shots:  300\nTotal shots:  300\n```\n\n----------------------------------------\n\nTITLE: Mismatched array dtypes in conditional\nDESCRIPTION: This example shows a case where different branches assign a variable with different dtypes, resulting in a `ValueError`. The error indicates a mismatch in the output abstract values due to the type inconsistency.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 1:\n        y = jnp.array([1.0, 2.0, 3.0])\n    else:\n        y = jnp.array([4, 5, 6])\n    return jnp.sum(y)\n```\n\n----------------------------------------\n\nTITLE: Enabling Logging in PennyLane\nDESCRIPTION: This code snippet demonstrates how to enable PennyLane's logging functionality with the default configurations defined in the `log_config.toml` file. It imports the PennyLane library and then calls the `enable_logging()` function. This will log function entries and outputs to the default handler, typically the standard output stream.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/logging.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nqml.logging.enable_logging()\n...\n```\n\n----------------------------------------\n\nTITLE: Control Flow with Adjoint (Unsupported) in PennyLane\nDESCRIPTION: This snippet shows an example of using control flow (for loop) within a QNode when using the adjoint differentiation method. This is not currently supported with program capture enabled and will result in an error.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport jax\n\nqml.capture.enable()\n\ndev = qml.device(\"default.qubit\",wires=2)\n\n@qml.qnode(dev, diff_method=\"adjoint\")\ndef f(x):\n    for i in range(2):\n        qml.RX(x, wires=i)\n    return qml.expval(qml.Z(0))\n```\n\n----------------------------------------\n\nTITLE: Adding a New Template to the Template Gallery in PennyLane\nDESCRIPTION: This code shows how to add a new template to PennyLane's template gallery by including a `gallery-item` directive in the `doc/introduction/templates.rst` file.  The item links to the template's documentation and includes a short description and a static image, which should follow the style and dimensions of the other template icons.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/adding_operators.rst#_snippet_16\n\nLANGUAGE: None\nCODE:\n```\n.. gallery-item::\n    :link: ../code/api/pennylane.templates.<templ_type>.MyNewTemplate.html\n    :description: MyNewTemplate\n    :figure: ../_static/templates/<templ_type>/my_new_template.png\n```\n\n----------------------------------------\n\nTITLE: Mismatched return shapes in conditional\nDESCRIPTION: This example shows a scenario where different branches of an `if` statement return arrays with different shapes, leading to a `ValueError` during plxpr creation.  The error arises because the abstract values of the returned values do not match.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/autograph.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef f(x):\n    if x > 5:\n        return jnp.array([1, 2])\n    return jnp.array([0])\n```\n\n----------------------------------------\n\nTITLE: Directly Calling Metric Tensor Transform\nDESCRIPTION: Demonstrates an alternative approach to using the `qml.metric_tensor` transform, which involves calling the transform directly instead of decorating a QNode. This provides more explicit control over the transformation process.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n@qml.qnode(dev)\ndef circuit(weights):\n    ...\n\ntransformed_circuit = qml.metric_tensor(circuit, approx=\"block-diag\")\n```\n\n----------------------------------------\n\nTITLE: Old Operator Hashing Behavior in PennyLane\nDESCRIPTION: This code demonstrates the old behavior of hashing PennyLane operators. Before the update, the hash of an operator was determined by its memory address. Therefore, two operators created with the same data had different hashes, even though they represented the same operation. This meant that a set containing two such operators would contain both instances.  This code snippet uses the operators defined in the previous snippet.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.33.0.md#_snippet_14\n\nLANGUAGE: pycon\nCODE:\n```\n>>> print({op1, op2})\n{PauliX(wires=[0]), PauliX(wires=[0])}\n```\n\n----------------------------------------\n\nTITLE: Executing Batch of Gradient Tapes in PennyLane\nDESCRIPTION: Demonstrates executing a batch of gradient tapes using a PennyLane device and processing the results with a function. This snippet highlights the usage of batch execution for efficient computation of gradients in quantum circuits.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.17.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\n>>> res = dev.batch_execute(gradient_tapes)\n>>> fn(res)\narray([[-0.69688381, -0.32648317, -0.68120105],\n         [ 0.8788057 ,  0.41171179,  0.85902895]])\n```\n\n----------------------------------------\n\nTITLE: Build the HTML documentation (Bash)\nDESCRIPTION: This snippet provides the command to build the HTML documentation for PennyLane. It uses the `make` command within the top-level directory of the project.  The generated documentation can be found in the `doc/_build/html/` directory.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nmake docs\n```\n\n----------------------------------------\n\nTITLE: Fixing Tensor Observable Order Dependency in PennyLane\nDESCRIPTION: This code snippet demonstrates how the order of observables in a Tensor Observable could affect the expected value calculation. The fix ensures that the order of Identity and PauliZ operators does not influence the result, providing consistent outputs regardless of the observable definition sequence.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.23.0.md#_snippet_19\n\nLANGUAGE: python\nCODE:\n```\n>>> @qml.qnode(dev)\n... def circ(op):\n...   qml.RX(0.12, wires=0)\n...   qml.RX(1.34, wires=1)\n...   qml.RX(3.67, wires=2)\n...   return qml.expval(op)\n>>> op1 = qml.Identity(wires=0) @ qml.Identity(wires=1) @ qml.PauliZ(wires=2)\n>>> op2 = qml.PauliZ(wires=2) @ qml.Identity(wires=0) @ qml.Identity(wires=1)\n>>> print(circ(op1), circ(op2))\n```\n\n----------------------------------------\n\nTITLE: Including Reference File with Jinja2\nDESCRIPTION: This snippet includes a reference file using the Jinja2 templating engine. The `referencefile` variable determines which file to include.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary_core/base.rst#_snippet_0\n\nLANGUAGE: Jinja2\nCODE:\n```\n{% if referencefile %}\n.. include:: {{ referencefile }}\n{% endif %}\n```\n\n----------------------------------------\n\nTITLE: Jinja Template for Class Name Replacement\nDESCRIPTION: This snippet uses Jinja templating to replace 'pennylane' with 'qml' in the fully qualified class name.  It's used at the top of the documentation page to customize the displayed name. No external dependencies are explicitly required as this is Jinja templating.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_0\n\nLANGUAGE: jinja\nCODE:\n```\n{{ fullname | replace(\"pennylane\", \"qml\") }}\n```\n\n----------------------------------------\n\nTITLE: Calculate Spectral Norm Error of a Circuit with TrotterProduct and QPE (Pycon)\nDESCRIPTION: This interactive python console snippet shows how to use qml.specs to calculate the total spectral norm error of a quantum circuit that contains TrotterProduct and QuantumPhaseEstimation. It demonstrates the expected output, which is a dictionary containing the SpectralNormError value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.36.0.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n>>> qml.specs(circuit())[\"errors\"]\n{'SpectralNormError': SpectralNormError(0.07616666666666666)}\n```\n\n----------------------------------------\n\nTITLE: Modifying QubitDevice Statistics Method Signature in PennyLane\nDESCRIPTION: The signature of the `QubitDevice.statistics` method has been changed to accept a `QuantumTape` object instead of a list of observables and a circuit.  This modification impacts how statistics are calculated on qubit devices.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.28.0.md#_snippet_17\n\nLANGUAGE: python\nCODE:\n```\ndef statistics(self, observables, shot_range=None, bin_size=None, circuit=None):\n```\n\n----------------------------------------\n\nTITLE: Documenting Module-Level Variables in Python\nDESCRIPTION: This snippet demonstrates documenting module-level variables using a triple-quote docstring placed *below* the variable definition. The docstring should clearly indicate the variable's type and purpose. This helps provide context and clarity within the module.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/guide/documentation.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nx = {\"John\": 23, \"James\": 54}\n\"\"\"dict[str, int]: stores the ages of known users\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing SelectPauliRot template in PennyLane\nDESCRIPTION: This code demonstrates the usage of the new `SelectPauliRot` template in PennyLane. It applies a sequence of uniformly controlled rotations to a target qubit. It requires NumPy and PennyLane to be installed, and defines a quantum circuit using the `default.qubit` device.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-dev.md#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nangles = np.array([1.0, 2.0, 3.0, 4.0])\n\nwires = qml.registers({\"control\": 2, \"target\": 1})\ndev = qml.device(\"default.qubit\", wires=3)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.SelectPauliRot(\n      angles,\n      control_wires=wires[\"control\"],\n      target_wire=wires[\"target\"],\n      rot_axis=\"Y\")\n    return qml.state()\n```\n\n----------------------------------------\n\nTITLE: Deprecated Metric Tensor Transform Approach\nDESCRIPTION: Shows the previously-recommended approach for passing arguments to `qml.metric_tensor`, which is now deprecated. This code is provided for informational purposes, demonstrating how not to implement the functionality in newer versions of PennyLane.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/development/deprecations.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n@qml.metric_tensor(approx=\"block-diag\")\n@qml.qnode(dev)\ndef circuit(weights):\n    ...\n```\n\n----------------------------------------\n\nTITLE: JAXPR with Dynamically Shaped Input using `determine_abstracted_axes`\nDESCRIPTION: This code demonstrates using the `determine_abstracted_axes` function to automatically determine the abstracted axes for a JAXPR. The `f` function creates a JAX array with a dynamic shape and calculates its sum using `jax.make_jaxpr` with the automatically determined abstracted axes.  The abstract shapes are then passed to `eval_jaxpr` to actually evaluate the jaxpr.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_14\n\nLANGUAGE: python\nCODE:\n```\ndef f(n):\n    x = jax.numpy.ones((n,))\n    abstracted_axes, abstract_shapes = determine_abstracted_axes((x,))\n    jaxpr = jax.make_jaxpr(jax.numpy.sum, abstracted_axes=abstracted_axes)(x)\n    return jax.core.eval_jaxpr(jaxpr.jaxpr, jaxpr.consts, *abstract_shapes, x)\n    \njax.make_jaxpr(f)(3)\n```\n\n----------------------------------------\n\nTITLE: Sphinx Automethod Directive for Methods\nDESCRIPTION: This snippet uses the Sphinx automethod directive to generate detailed documentation for each method. It excludes inherited methods using the `if item not in inherited_members` condition, similar to the attribute documentation.  It assumes `inherited_members` is correctly populated.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/_templates/autosummary/class_no_inherited.rst#_snippet_9\n\nLANGUAGE: jinja\nCODE:\n```\n{% for item in methods %}\n{%- if item not in inherited_members %}\n.. automethod:: {{ item }}\n{%- endif %}\n{%- endfor %}\n```\n\n----------------------------------------\n\nTITLE: Tracking Device Executions in Pycon\nDESCRIPTION: This code demonstrates how to track the number of device executions using the `num_executions` attribute of a PennyLane device. It defines a simple quantum circuit, executes it in a loop, and then prints the value of `dev.num_executions`.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_8\n\nLANGUAGE: pycon\nCODE:\n```\n>>> dev = qml.device(\"default.qubit\", wires=2)\n>>> @qml.qnode(dev)\n... def circuit(x, y):\n...    qml.RX(x, wires=[0])\n...    qml.RY(y, wires=[1])\n...    qml.CNOT(wires=[0, 1])\n...    return qml.expval(qml.PauliZ(0) @ qml.PauliX(1))\n>>> for _ in range(10):\n...    circuit(0.432, 0.12)\n>>> print(dev.num_executions)\n10\n```\n\n----------------------------------------\n\nTITLE: Resource Estimation with QuantumTape in Pycon\nDESCRIPTION: This code demonstrates resource estimation using the `QuantumTape` class. It creates a tape, adds quantum operations, and then uses `tape.get_resources()` to obtain a dictionary of operation counts and `tape.get_depth()` to compute the circuit depth.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_7\n\nLANGUAGE: pycon\nCODE:\n```\n>>> with qml.tape.QuantumTape() as tape:\n...    qml.Hadamard(wires=0)\n...    qml.RZ(0.26, wires=1)\n...    qml.CNOT(wires=[1, 0])\n...    qml.Rot(1.8, -2.7, 0.2, wires=0)\n...    qml.Hadamard(wires=1)\n...    qml.CNOT(wires=[0, 1])\n...    qml.expval(qml.PauliZ(0) @ qml.PauliZ(1))\n>>> tape.get_resources()\n{'Hadamard': 2, 'RZ': 1, 'CNOT': 2, 'Rot': 1}\n>>> tape.get_depth()\n4\n```\n\n----------------------------------------\n\nTITLE: TensorFlow Integration with Backpropagation\nDESCRIPTION: This snippet demonstrates the integration of PennyLane with TensorFlow using the backpropagation differentiation method. It defines a quantum circuit and calculates its gradient with respect to the input parameters using TensorFlow's `GradientTape`. This enables seamless integration of quantum computations into TensorFlow workflows. The `default.tensor.tf` device and `tensorflow` interface are required.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.9.0.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n>>> dev = qml.device(\"default.tensor.tf\", wires=1)\n>>> @qml.qnode(dev, interface=\"tf\", diff_method=\"backprop\")\n>>> def circuit(x):\n...     qml.RX(x[1], wires=0)\n...     qml.Rot(x[0], x[1], x[2], wires=0)\n...     return qml.expval(qml.PauliZ(0))\n>>> vars = tf.Variable([0.2, 0.5, 0.1])\n>>> with tf.GradientTape() as tape:\n...     res = circuit(vars)\n>>> tape.gradient(res, vars)\n<tf.Tensor: shape=(3,), dtype=float32, numpy=array([-2.2526717e-01, -1.0086454e+00,  1.3877788e-17], dtype=float32)>\n```\n\n----------------------------------------\n\nTITLE: Hijacking Class Instantiation with Metaclass\nDESCRIPTION: Defines a metaclass `MetaClass2` that hijacks class instantiation. Instead of creating an instance of the class, the `__call__` method returns a fixed value (2.0). This demonstrates how metaclasses can completely override the default instantiation behavior.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nclass MetaClass2(type):\n\n    def __call__(cls, *args, **kwargs):\n        return 2.0\n\nclass MyClass2(metaclass=MetaClass2):\n\n    def __init__(self, *args, **kwargs):\n        print(\"Am I here?\")\n        self.args = args\n```\n\n----------------------------------------\n\nTITLE: QuantumPhaseEstimation Template in PennyLane\nDESCRIPTION: The following Python code defines a `unitary` matrix corresponding to a rotation from an `RX` gate with phase 5. This matrix will be used as input for the Quantum Phase Estimation template.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.15.0.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\n>>> phase = 5\n>>> target_wires = [0]\n>>> unitary = qml.RX(phase, wires=0).matrix\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom JAX Primitive with Dynamic Output Shape\nDESCRIPTION: This code defines a custom JAX primitive (`prim3`) that returns an array with a dynamically determined shape using unstable JAX internals.  This demonstrates the creation of a primitive whose output shape is determined at runtime and is dependent on one of the input arguments.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/intro_to_dynamic_shapes.md#_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nprim3 = jax.core.Primitive(\"dynamic_output\")\nprim3.multiple_results = True\n```\n\n----------------------------------------\n\nTITLE: Metaclass for JAX Primitives with Custom Abstract Value\nDESCRIPTION: Redefines the `PrimitiveMeta` metaclass to use the custom `AbstractPrimitiveClass` in the `def_abstract_eval` method.  This allows JAX to accurately represent the abstract type of the class during tracing and abstract evaluation.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nclass PrimitiveMeta2(type):\n\n    def __init__(cls, *args, **kwargs):\n        # here we set up the primitive\n        primitive = jax.core.Primitive(cls.__name__)\n\n        @primitive.def_impl\n        def _(*inner_args, **inner_kwargs):\n            # just normal class creation if not tracing\n            return type.__call__(cls, *inner_args, **inner_kwargs)\n\n        @primitive.def_abstract_eval\n        def _(*inner_args, **inner_kwargs):\n            # here we say that we just return an array of type float32 and shape (1,)\n            # other abstract types could be used instead\n            return AbstractPrimitiveClass()\n\n        cls._primitive = primitive\n\n    def __call__(cls, *args, **kwargs):\n        return cls._primitive.bind(*args, **kwargs)\n\nclass PrimitiveClass2(metaclass=PrimitiveMeta2):\n\n    def __init__(self, a):\n        self.a = a\n\n    def __repr__(self):\n        return f\"PrimitiveClass({self.a})\"\n```\n\n----------------------------------------\n\nTITLE: Abstract Evaluation for Repeat Primitive\nDESCRIPTION: Defines the abstract evaluation rule for the `repeat` primitive. It returns the abstract values of the arguments, assuming the output types match the input types.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/pennylane/capture/explanations.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n@repeat_prim.def_abstract_eval\ndef _(n, *args, jaxpr, n_consts):\n    return args[n_consts:]\n```\n\n----------------------------------------\n\nTITLE: Accessing Intermediate Forward Pass Values in Python\nDESCRIPTION: This code snippet demonstrates how to access the value of the intermediate forward pass when computing the gradient of a cost function using `qml.grad` with the Autograd interface. The `grad_fn.forward` property stores the cost function value.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.13.0.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\ndef cost_fn(x, y):\n    return 2 * np.sin(x[0]) * np.exp(-x[1]) + x[0] ** 3 + np.cos(y)\n\nparams = np.array([0.1, 0.5], requires_grad=True)\ndata = np.array(0.65, requires_grad=False)\ngrad_fn = qml.grad(cost_fn)\n\ngrad_fn(params, data)  # perform backprop and evaluate the gradient\ngrad_fn.forward  # the cost function value\n```\n\n----------------------------------------\n\nTITLE: Loading Multiple Datasets with PennyLane\nDESCRIPTION: This code loads multiple datasets for the H2 molecule with different bond lengths (0.5 and 1.1) and the basis set to 'full'. The `qml.data.load` function returns a list of `Dataset` objects.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/introduction/data.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nH2datasets = qml.data.load(\"qchem\", molname=\"H2\", basis=\"full\", bondlength=[0.5, 1.1])\nprint(H2datasets)\n```\n\n----------------------------------------\n\nTITLE: Invalid JAX Type with MultiRZ in PennyLane\nDESCRIPTION: This example highlights the importance of using valid JAX data types with program capture. It demonstrates that using a ``range`` object for the ``wires`` argument in ``qml.MultiRZ`` will result in a TypeError. Using jax.numpy array or list of integers solves this issue.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/news/program_capture_sharp_bits.rst#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax.numpy as jnp\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.MultiRZ(jnp.array([0.1, 0.2]), wires=range(2))\n    return qml.expval(qml.X(0))\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pennylane as qml\nimport jax.numpy as jnp\n\nqml.capture.enable()\n\ndev = qml.device('default.qubit', wires=2)\n\n@qml.qnode(dev)\ndef circuit():\n    qml.MultiRZ(jnp.array([0.1, 0.2]), wires=[0, 1])\n    return qml.expval(qml.X(0))\n```\n\n----------------------------------------\n\nTITLE: Quantum Monte Carlo Transform\nDESCRIPTION: This code demonstrates the usage of the `quantum_monte_carlo` transform to transform an input circuit into the full quantum Monte Carlo algorithm, allowing for estimation of expectation values using quantum methods.\nSOURCE: https://github.com/pennylaneai/pennylane/blob/master/doc/releases/changelog-0.16.0.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom scipy.stats import norm\n\nm = 5\nM = 2 ** m\n\nxmax = np.pi  # bound to region [-pi, pi]\nxs = np.linspace(-xmax, xmax, M)\n\nprobs = np.array([norm().pdf(x) for x in xs])\nprobs /= np.sum(probs)\n\nfunc = lambda i: np.sin(xs[i]) ** 2\nr_rotations = np.array([2 * np.arcsin(np.sqrt(func(i))) for i in range(M)])\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pennylane.templates.state_preparations.mottonen import (\n    _uniform_rotation_dagger as r_unitary,\n)\n\nn = 6\nN = 2 ** n\n\na_wires = range(m)\nwires = range(m + 1)\ntarget_wire = m\nestimation_wires = range(m + 1, n + m + 1)\n\ndev = qml.device(\"default.qubit\", wires=(n + m + 1))\n\ndef fn():\n    qml.templates.MottonenStatePreparation(np.sqrt(probs), wires=a_wires)\n    r_unitary(qml.RY, r_rotations, control_wires=a_wires[::-1], target_wire=target_wire)\n\n@qml.qnode(dev)\ndef qmc():\n    qml.quantum_monte_carlo(fn, wires, target_wire, estimation_wires)()\n    return qml.probs(estimation_wires)\n\nphase_estimated = np.argmax(qmc()[:int(N / 2)]) / N\n```\n\nLANGUAGE: python\nCODE:\n```\n>>> (1 - np.cos(np.pi * phase_estimated)) / 2\n0.42663476277231915\n```"
  }
]