[
  {
    "owner": "zeromq",
    "repo": "zeromq.org",
    "content": "TITLE: Implementing a Hello World Server with ZeroMQ in C++\nDESCRIPTION: This C++ snippet uses the zmqpp library to build a basic ZeroMQ reply server that listens on TCP port 5555. The server initializes a ZeroMQ context, creates a reply socket, binds it to the endpoint, receives incoming messages, simulates processing by sleeping for one second, and sends back a 'World' response. Dependencies include the zmqpp library, threading, chrono, and standard C++ headers. It takes no arguments but expects clients to send requests to \"tcp://*:5555\", responding with a standard message each time; it is single-threaded and handles one message at a time.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/zmqpp/hello_world_server.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n//  Hello World server\n\n#include <zmqpp/zmqpp.hpp>\n#include <string>\n#include <iostream>\n#include <chrono>\n#include <thread>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  const string endpoint = \"tcp://*:5555\";\n\n  // initialize the 0MQ context\n  zmqpp::context context;\n\n  // generate a pull socket\n  zmqpp::socket_type type = zmqpp::socket_type::reply;\n  zmqpp::socket socket (context, type);\n\n  // bind to the socket\n  socket.bind(endpoint);\n  while (1) {\n    // receive the message\n    zmqpp::message message;\n    // decompose the message \n    socket.receive(message);\n    string text;\n    message >> text;\n\n    //Do some 'work'\n    std::this_thread::sleep_for(std::chrono::seconds(1));\n    cout << \"Received Hello\" << endl;\n    socket.send(\"World\");\n  }\n\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending a String Over ZeroMQ Socket in C\nDESCRIPTION: This function sends a given C string over a ZeroMQ socket by using the zmq_send function. The string is duplicated using strdup to ensure a separate memory allocation and its length is determined by strlen. It requires the libzmq library and expects a valid ZeroMQ socket pointer and a null-terminated C string. Output is sent to the socket as a single message frame. Input size is limited by the practical RAM allocation, but no explicit length check is done.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_strings_send_recv.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void\ns_send_string (void *socket, const char *string) {\n\tzmq_send (socket, strdup(string), strlen(string), 0);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ REQ Client in C\nDESCRIPTION: This C code demonstrates a basic ZeroMQ client using the REQ socket type. It initializes a ZeroMQ context and socket, connects to a server listening on 'tcp://localhost:5555'. The client then enters a loop, sending 'Hello' messages 10 times and waiting to receive a reply after each message using `zmq_send` and `zmq_recv`. It depends on the `zmq.h` header from the libzmq library and standard C headers (`string.h`, `stdio.h`, `unistd.h`). After the loop, it cleans up by closing the socket and destroying the context.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Hello World client\n#include <zmq.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main (void)\n{\n    printf (\"Connecting to hello world server…\\n\");\n    void *context = zmq_ctx_new ();\n    void *requester = zmq_socket (context, ZMQ_REQ);\n    zmq_connect (requester, \"tcp://localhost:5555\");\n\n    int request_nbr;\n    for (request_nbr = 0; request_nbr != 10; request_nbr++) {\n        char buffer [10];\n        printf (\"Sending Hello %d…\\n\", request_nbr);\n        zmq_send (requester, \"Hello\", 5, 0);\n        zmq_recv (requester, buffer, 10, 0);\n        printf (\"Received World %d\\n\", request_nbr);\n    }\n    zmq_close (requester);\n    zmq_ctx_destroy (context);\n    return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending Requests with ZeroMQ in C++ using cppzmq\nDESCRIPTION: This snippet initializes a ZeroMQ context with one IO thread and sets up a REQ (request) socket using the cppzmq library. It connects to a local ZeroMQ server at tcp://localhost:5555 and sends a total of ten \"Hello\" messages, printing out each reply received synchronously. Dependencies include cppzmq and ZeroMQ; ensure the server endpoint exists and is reachable. The main parameters include the iteration count (number of requests) and the static message sent. Input is not dynamic, and output is to the standard output stream, both for sending and receiving acknowledgment messages. The snippet assumes the server follows the ZeroMQ REQ/REP pattern for correct synchronous communication.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <string>\\n#include <iostream>\\n\\n#include <zmq.hpp>\\n\\nint main()\\n{\\n    // initialize the zmq context with a single IO thread\\n    zmq::context_t context{1};\\n\\n    // construct a REQ (request) socket and connect to interface\\n    zmq::socket_t socket{context, zmq::socket_type::req};\\n    socket.connect(\\\"tcp://localhost:5555\\\");\\n\\n    // set up some static data to send\\n    const std::string data{\\\"Hello\\\"};\\n\\n    for (auto request_num = 0; request_num < 10; ++request_num) \\n    {\\n        // send the request message\\n        std::cout << \\\"Sending Hello \\\" << request_num << \\\"...\\\" << std::endl;\\n        socket.send(zmq::buffer(data), zmq::send_flags::none);\\n        \\n        // wait for reply from server\\n        zmq::message_t reply{};\\n        socket.recv(reply, zmq::recv_flags::none);\\n\\n        std::cout << \\\"Received \\\" << reply.to_string(); \\n        std::cout << \\\" (\\\" << request_num << \\\")\\\";\\n        std::cout << std::endl;\\n    }\\n\\n    return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ Hello World ROUTER Server in Go\nDESCRIPTION: This Go code snippet demonstrates a basic ZeroMQ server using a ROUTER socket with the goczmq library. It binds to 'tcp://*:5555', waits to receive multipart messages (expecting client identity frame followed by payload), logs the received message, simulates work with a one-second delay, and sends a two-part reply ('identity frame', 'World') back to the client. Requires the 'github.com/zeromq/goczmq' library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/goczmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\n```Go\npackage main\n\nimport (\n\t\"log\"\n\t\"time\"\n\n\t\"github.com/zeromq/goczmq\"\n)\n\nfunc main() {\n\t// Create a router socket and bind it to port 5555.\n\trouter, err := goczmq.NewRouter(\"tcp://*:5555\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer router.Destroy()\n\n\tlog.Println(\"router created and bound\")\n\n\tfor {\n\t\t// Receive the message. Here we call RecvMessage, which\n\t\t// will return the message as a slice of frames ([][]byte).\n\t\t// Since this is a router socket that support async\n\t\t// request / reply, the first frame of the message will\n\t\t// be the routing frame.\n\t\trequest, err := router.RecvMessage()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tlog.Printf(\"router received '%s' from '%v'\", request[1], request[0])\n\n\t\t// Do some 'work'\n\t\ttime.Sleep(time.Second * 1)\n\n\t\t// Send a reply. First we send the routing frame, which\n\t\t// lets the dealer know which client to send the message.\n\t\t// The FlagMore flag tells the router there will be more\n\t\t// frames in this message.\n\t\terr = router.SendFrame(request[0], goczmq.FlagMore)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tlog.Printf(\"router sent 'World'\")\n\n\t\t// Next send the reply. The FlagNone flag tells the router\n\t\t// that this is the last frame of the message.\n\t\terr = router.SendFrame([]byte(\"World\"), goczmq.FlagNone)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Sending Requests to a ZeroMQ Server with zmq4 (Go)\nDESCRIPTION: This Go code snippet shows how to use the zmq4 library to create a ZeroMQ REQ socket, connect it to a server over TCP, and exchange simple request-reply messages in a loop. Dependencies include the github.com/pebbe/zmq4 package. Key inputs are the server endpoint (\"tcp://localhost:5555\") and the request payload (\"Hello\"); outputs are printed to stdout as each reply is received. This example demonstrates a synchronous client pattern and assumes that a compatible REP server is listening on the specified endpoint.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/hello_world_client.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n        \"fmt\"\n\n        zmq \"github.com/pebbe/zmq4\"\n)\n\nfunc main() {\n        zctx, _ := zmq.NewContext()\n\n        // Socket to talk to server\n        fmt.Printf(\"Connecting to the server...\\n\")\n        s, _ := zctx.NewSocket(zmq.REQ)\n        s.Connect(\"tcp://localhost:5555\")\n\n        // Do 10 requests, waiting each time for a response\n        for i := 0; i < 10; i++ {\n                fmt.Printf(\"Sending request %d...\\n\", i)\n                s.Send(\"Hello\", 0)\n\n                msg, _ := s.Recv(0)\n                fmt.Printf(\"Received reply %d [ %s ]\\n\", i, msg)\n        }\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Requests with zmqpp in C++\nDESCRIPTION: This code snippet implements a basic ZeroMQ REQ client using the zmqpp library in C++. The client creates a REQ socket, connects to a local server endpoint at tcp://localhost:5555, and sends ten 'Hello' messages, receiving and printing responses after each request. Dependencies include the zmqpp C++ library and the standard C++ I/O and string libraries. The endpoint, message content, and number of cycles are configurable in the code, and the output is printed to the console. The code is intended for educational use or as a template for more complex zmqpp client applications.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/zmqpp/hello_world_client.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n//  Hello World client\\n#include <zmqpp/zmqpp.hpp>\\n#include <string>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nint main(int argc, char *argv[]) {\\n  const string endpoint = \"tcp://localhost:5555\";\\n\\n  // initialize the 0MQ context\\n  zmqpp::context context;\\n\\n  // generate a push socket\\n  zmqpp::socket_type type = zmqpp::socket_type::req;\\n  zmqpp::socket socket (context, type);\\n\\n  // open the connection\\n  cout << \"Connecting to hello world server…\" << endl;\\n  socket.connect(endpoint);\\n  int request_nbr;\\n  for (request_nbr = 0; request_nbr != 10; request_nbr++) {\\n    // send a message\\n    cout << \"Sending Hello \" << request_nbr <<\"…\" << endl;\\n    zmqpp::message message;\\n    // compose a message from a string and a number\\n    message << \"Hello\";\\n    socket.send(message);\\n    string buffer;\\n    socket.receive(buffer);\\n    \\n    cout << \"Received World \" << request_nbr << endl;\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a NetMQ Request-Reply Client in C#\nDESCRIPTION: This C# code snippet demonstrates a simple ZeroMQ client using the NetMQ library. It creates a RequestSocket, connects to 'tcp://localhost:5555', sends 'Hello' 10 times in a loop, and prints the received 'World' response for each request. It requires the NetMQ library to be referenced and assumes a corresponding ZeroMQ server is running and listening on the specified address and port.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n```csharp\nusing System;\nusing NetMQ;\nusing NetMQ.Sockets;\n\nstatic class Program\n{\n    public static void Main()\n    {\n        Console.WriteLine(\"Connecting to hello world server…\");\n        using(var requester = new RequestSocket())\n        {\n            requester.Connect(\"tcp://localhost:5555\");\n\n            int requestNumber;\n            for (requestNumber = 0; requestNumber != 10; requestNumber++)\n            {\n                Console.WriteLine(\"Sending Hello {0}...\", requestNumber);\n                requester.SendFrame(\"Hello\");\n                string str = requester.ReceiveFrameString();\n                Console.WriteLine(\"Received World {0}\", requestNumber);\n            }\n        }\n    }    \n}\n```\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple String Frames Sequentially with NetMQ in C#\nDESCRIPTION: This C# snippet demonstrates sending a multi-part message where each part is a string. It uses the `SendMoreFrame` method of a NetMQ socket to queue frames ('HELLO', 'beautiful') and concludes the message with `SendMore` (or `SendFrame` for the last part, though `SendMore` is shown here likely as a typo, it should be `SendFrame`). The message is only sent when the final frame is provided. Requires an initialized NetMQ socket instance.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/messages_strings_send_recv_multi.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nsocket.SendMoreFrame(\"HELLO\")\n    .SendMoreFrame(\"beautiful\")\n    .SendMore(\"WORLD!\");\n```\n\n----------------------------------------\n\nTITLE: Releasing a ZeroMQ Message in C\nDESCRIPTION: Demonstrates proper resource management for ZeroMQ messages in C using zmq_msg_close. This function is necessary to free resources associated with a message after it is no longer in use. It takes a pointer to zmq_msg_t as input and must be called for each message initialized to avoid memory leaks.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_2\n\nLANGUAGE: C\nCODE:\n```\nzmq_msg_close(&msg);\n```\n\n----------------------------------------\n\nTITLE: Creating a ZeroMQ SUB Socket and Subscribing to a Topic in C++\nDESCRIPTION: This C++ snippet demonstrates setting up a ZeroMQ subscriber using the cppzmq library. It initializes a context, creates a SUB socket, connects to 'tcp://localhost:5555', subscribes specifically to the 'status' topic using `zmq::sockopt::subscribe`, and then continuously receives and prints multipart messages associated with that topic. The code uses `zmq::recv_multipart` for handling messages composed of multiple parts. Dependencies include `zmq.hpp` and `zmq_addon.hpp` from cppzmq, and standard C++ libraries.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n//  Subscribe to the 'status'\n#include <string>\n#include <iostream>\n#include <vector>\n\n#include <zmq.hpp>\n#include <zmq_addon.hpp>\n\nint main()\n{\n    // initialize the zmq context with a single IO thread\n    zmq::context_t context{1};\n\n    // construct a SUB (subscriber) socket and connect to interface\n    zmq::socket_t subscriber{context, zmq::socket_type::sub};\n    subscriber.connect(\"tcp://localhost:5555\");\n    \n    // set topics you want to sub\n    subscriber.set(zmq::sockopt::subscribe, \"status\");\n\n    while(true){\n        // Receive all parts of the message\n        std::vector<zmq::message_t> recv_msgs;\n        zmq::recv_result_t result =\n            zmq::recv_multipart(subscriber, std::back_inserter(recv_msgs));\n        assert(result && \"recv failed\");\n        assert(*result == 2);\n\n        std::cout << \"Subscriber: [\" << recv_msgs[0].to_string() << \"] \"\n                  << recv_msgs[1].to_string() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic PUSH/PULL Pattern with CZMQ in C\nDESCRIPTION: Demonstrates a simple intra-process message passing using CZMQ's high-level API. It creates PUSH and PULL sockets bound to an in-process address, sends a string message from PUSH to PULL, receives and prints it using helper functions, and then cleans up the sockets. Depends on the CZMQ library (`czmq.h`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_6\n\nLANGUAGE: c\nCODE:\n```\n#include <czmq.h>\nint main (void)\n{\n    zsock_t *push = zsock_new_push (\"inproc://example\");\n    zsock_t *pull = zsock_new_pull (\"inproc://example\");\n    zstr_send (push, \"Hello, World\");\n\n    char *string = zstr_recv (pull);\n    puts (string);\n    zstr_free (&string);\n\n    zsock_destroy (&pull);\n    zsock_destroy (&push);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Hello World Response Server with NetMQ in C#\nDESCRIPTION: This snippet demonstrates the creation of a simple response server using the NetMQ library in C#. It binds a ResponseSocket to TCP port 5555, continuously receives incoming messages, logs receipt, simulates work with a one-second sleep, and responds with a static reply ('World'). Dependencies include the NetMQ NuGet package. Key parameters include the bind endpoint (tcp://*:5555) and the response message. The server expects string messages from clients and always replies with the string 'World'. This example is ideal for basic ZeroMQ/NetMQ learning and prototyping.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing System;\nusing System.Threading;\nusing NetMQ;\nusing NetMQ.Sockets;\n\nstatic class Program\n{\n    public static void Main()\n    {        \n        using (var responder = new ResponseSocket())\n        {\n            responder.Bind(\"tcp://*:5555\");\n\n            while (true) \n            {\n                string str = responder.ReceiveFrameString();\n                Console.WriteLine(\"Received Hello\");\n                Thread.Sleep(1000);  //  Do some 'work'\n                responder.SendFrame(\"World\");\n            }\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Binding a ZeroMQ REP Socket Server in Rust\nDESCRIPTION: This Rust snippet creates a simple ZeroMQ server using the rust-zmq crate. It binds a REP socket to tcp://*:5555, waits for a 'Hello' message from clients, prints the received message, and replies with 'World'. Dependencies include the rust-zmq library, and some standard library threading/timing components. The server runs in an infinite loop, demonstrating how to interact with ZeroMQ sockets, manage synchronous request/reply cycles, and utilize basic error handling with assertions. Input messages from clients are strings, and outputs are the hardcoded response string 'World'.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/rust/rust-zmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n#!\\[crate_name = \"helloworld_server\"\\]\n\n//! Hello World server in Rust\n//! Binds REP socket to tcp://*:5555\n//! Expects \"Hello\" from client, replies with \"World\"\n\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let context = zmq::Context::new();\n    let responder = context.socket(zmq::REP).unwrap();\n\n    assert!(responder.bind(\"tcp://*:5555\").is_ok());\n\n    let mut msg = zmq::Message::new();\n    loop {\n        responder.recv(&mut msg, 0).unwrap();\n        println!(\"Received {}\", msg.as_str().unwrap());\n        thread::sleep(Duration::from_millis(1000));\n        responder.send(\"World\", 0).unwrap();\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Running a Hello World ZeroMQ Server using CZMQ in C\nDESCRIPTION: This C code snippet implements a Hello World server using the CZMQ library, leveraging ZeroMQ\\'s REQ-REP (request-reply) pattern. It creates a REP (reply) socket, binds it to TCP port 5555, and enters a loop to receive messages from clients, print a message when data is received, pause for a second, and respond with \\'World\\'. Required dependencies include the CZMQ library and an appropriate ZeroMQ runtime. Key parameters include the socket address \\'tcp://*:5555\\' and use of zsock_new/ZMQ_REP and supporting functions. The main input is string messages from clients, and the main output is the fixed response. The server expects input over TCP and will only reply with \\'World\\' regardless of input, illustrating a simple synchronous server.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Hello World server\\n#include <czmq.h>\\n\\nint main (void)\\n{\\n    //  Socket to talk to clients\\n    zsock_t *responder = zsock_new (ZMQ_REP);\\n    int rc = zsock_bind (responder, \\\"tcp://*:5555\\\");\\n    assert (rc == 5555);\\n\\n    while (1) {\\n        char *str = zstr_recv (responder);\\n        printf (\\\"Received Hello\\\\n\\\");\\n        sleep (1);          //  Do some 'work'\\n        zstr_send (responder, \\\"World\\\");\\n        zstr_free (&str);\\n    }\\n    return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Request-Response Server with NetMQ in C#\nDESCRIPTION: This snippet implements a ZeroMQ response server using NetMQ in C#. It binds to a TCP socket, waits for a client message, prints the received message, and sends a response ('World'). Requires the NetMQ package. Should be paired with a request client and extended with error handling for robustness. Inputs: message from client; outputs: reply message and log.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/csharp.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var server = new ResponseSocket())\\n{\\n    server.Bind(\\\"tcp://*:5556\\\");\\n    string msg = server.ReceiveFrameString();\\n    Console.WriteLine(\\\"From Client: {0}\\\", msg);\\n    server.SendFrame(\\\"World\\\");\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Building and Sending a Multi-Frame String Message with zmsg in CZMQ (C)\nDESCRIPTION: Illustrates creating and sending a multi-frame message using the `zmsg_t` class. A new message object is created with `zmsg_new()`. String frames are added sequentially using `zmsg_addstr()`. Finally, the entire message is sent using `zmsg_send()`, which also consumes and destroys the message object (`strings` will be set to NULL). Requires an initialized CZMQ socket (`socket`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv_multi.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nzmsg_t *strings = zmsg_new ();\nzmsg_addstr (\"HELLO\");\nzmsg_addstr (\"beautiful\");\nzmsg_addstr (\"WORLD\");\nzmsg_send (&strings, socket);\n```\n\n----------------------------------------\n\nTITLE: Handling Requests with ZeroMQ Reply Socket - JavaScript\nDESCRIPTION: Demonstrates a ZeroMQ Reply socket serving as a synchronous RPC server. The server binds to a port, waits for messages (here, expected as a number in string format), doubles the received value, and sends the result back. Dependencies: zeromq.js, intended as a pair with a matching Request client. Expects numeric strings as messages and outputs doubled integers.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_6\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Reply()\n\n  await sock.bind(\"tcp://127.0.0.1:3000\")\n\n  for await (const [msg] of sock) {\n    await sock.send(2 * parseInt(msg, 10))\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Initializing ZeroMQ Server with pyzmq - Python\nDESCRIPTION: This snippet implements a Python ZeroMQ server using pyzmq, binding a REP socket to tcp://*:5555. It waits for requests from clients, simulates work with a one-second sleep, then replies with a static message. Dependencies include the pyzmq and time modules. The server listens indefinitely for incoming messages and expects to receive b\\\"Hello\\\"; parameter changes may be needed for different ports, messages, or networks.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/python.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n#\n#   Hello World server in Python\n#   Binds REP socket to tcp://*:5555\n#   Expects b\"Hello\" from client, replies with b\"World\"\n#\n\nimport time\nimport zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind(\"tcp://*:5555\")\n\nwhile True:\n    #  Wait for next request from client\n    message = socket.recv()\n    print(\"Received request: %s\" % message)\n\n    #  Do some 'work'\n    time.sleep(1)\n\n    #  Send reply back to client\n    socket.send(b\"World\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Simple ZeroMQ Request-Reply Server in C\nDESCRIPTION: This C code implements a basic ZeroMQ server using the `ZMQ_REP` (reply) socket type. It initializes a ZeroMQ context, creates a reply socket, binds it to TCP port 5555 (`tcp://*:5555`), and enters an infinite loop. Inside the loop, it waits to receive a message using `zmq_recv`, prints a confirmation message (\"Received Hello\"), simulates work by pausing for 1 second using `sleep(1)`, and then sends the string \"World\" back to the client using `zmq_send`. The program depends on the `libzmq` library and includes standard C headers for I/O, string manipulation, and assertions.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Hello World server\n#include <zmq.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <assert.h>\n\nint main (void)\n{\n    //  Socket to talk to clients\n    void *context = zmq_ctx_new ();\n    void *responder = zmq_socket (context, ZMQ_REP);\n    int rc = zmq_bind (responder, \"tcp://*:5555\");\n    assert (rc == 0);\n\n    while (1) {\n        char buffer [10];\n        zmq_recv (responder, buffer, 10, 0);\n        printf (\"Received Hello\\n\");\n        sleep (1);          //  Do some 'work'\n        zmq_send (responder, \"World\", 5, 0);\n    }\n    return 0;\n}\n\n```\n\n----------------------------------------\n\nTITLE: Sending a String Message with NetMQ in C#\nDESCRIPTION: This snippet demonstrates how to send a string message (\\\"Hello\\\") using the SendFrame method on a NetMQ socket in C#. It requires the NetMQ library and a properly initialized and connected socket. The message is transmitted over the network to a remote ZeroMQ peer; no response is expected from this operation.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/messages_strings_send_recv.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nsocket.SendFrame(\"Hello\");\n```\n\n----------------------------------------\n\nTITLE: Installing goczmq Go Package\nDESCRIPTION: Shows the command to install the `goczmq` Go package using `go get`. This command fetches and installs version 4 of the `goczmq` library, which requires prior installation of `libzmq` and `CZMQ` as prerequisites.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/go.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngo get gopkg.in/zeromq/goczmq.v4\n```\n\n----------------------------------------\n\nTITLE: TypeScript Import and Usage Examples with ZeroMQ - TypeScript\nDESCRIPTION: Demonstrates how to import and instantiate ZeroMQ sockets using TypeScript. The code shows both named and namespace import styles, and how to create Request and Reply sockets with the provided type definitions. Dependencies: TypeScript 3.0.x or later, and zeromq.js with its type declarations installed. Intended for use in TypeScript environments, highlighting compatibility and typing support.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_7\n\nLANGUAGE: ts\nCODE:\n```\nimport {Request} from \"zeromq\"\n// or as namespace\nimport * as zmq from \"zeromq\"\n\nconst reqSock = new Request()\n//...\nconst repSock = new zmq.Reply()\n```\n\n----------------------------------------\n\nTITLE: Sub/Pub Message Forwarding with azmq and Boost Asio in C++\nDESCRIPTION: This C++ example showcases the azmq library, which provides Boost Asio style bindings for ZeroMQ. It sets up an Asio I/O service, creates a SUB socket connecting to two TCP endpoints and subscribing to 'NASDAQ' topics, and a PUB socket bound to an IPC endpoint. It then enters an infinite loop, receiving messages on the subscriber and forwarding them through the publisher. Depends on azmq, Boost Asio, and libzmq.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/cplusplus.md#_snippet_1\n\nLANGUAGE: C++\nCODE:\n```\n```C++\n#include <azmq/socket.hpp>\n#include <boost/asio.hpp>\n#include <array>\n\nnamespace asio = boost::asio;\n\nint main(int argc, char** argv) {\n    asio::io_service ios;\n    azmq::sub_socket subscriber(ios);\n    subscriber.connect(\"tcp://192.168.55.112:5556\");\n    subscriber.connect(\"tcp://192.168.55.201:7721\");\n    subscriber.set_option(azmq::socket::subscribe(\"NASDAQ\"));\n\n    azmq::pub_socket publisher(ios);\n    publisher.bind(\"ipc://nasdaq-feed\");\n\n    std::array<char, 256> buf;\n    for (;;) {\n        auto size = subscriber.receive(asio::buffer(buf));\n        publisher.send(asio::buffer(buf));\n    }\n    return 0;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ REP Server in Java\nDESCRIPTION: This Java code demonstrates a simple ZeroMQ server using the `jeromq` library. It creates a REP (Reply) socket, binds it to `tcp://*:5555`, and enters an infinite loop. In the loop, it receives a message from a client using `socket.recv()`, prints the received message, sends back the fixed response \"world\" using `socket.send()`, and then pauses for one second using `Thread.sleep()`. It utilizes `ZContext` for managing ZeroMQ resources safely with a try-with-resources block. Dependencies include the `jeromq` library (`org.zeromq.*` imports).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/hello_world_server.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n//  Hello World server in Java\n//  Binds REP socket to tcp://*:5555\n//  Expects \"Hello\" from client, replies with \"World\"\n\nimport org.zeromq.SocketType;\nimport org.zeromq.ZMQ;\nimport org.zeromq.ZContext;\n\npublic class hwserver\n{\n  public static void main(String[] args) throws Exception\n  {\n    try (ZContext context = new ZContext()) {\n      //  Socket to talk to clients\n      ZMQ.Socket socket = context.createSocket(SocketType.REP);\n      socket.bind(\"tcp://*:5555\");\n\n      while (!Thread.currentThread().isInterrupted()) {\n        byte[] reply = socket.recv(0);\n        System.out.println(\n          \"Received \" + \": [\" + new String(reply, ZMQ.CHARSET) + \"]\"\n        );\n        String response = \"world\";\n        socket.send(response.getBytes(ZMQ.CHARSET), 0);\n        Thread.sleep(1000); //  Do some 'work'\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Receiving Multiple String Frames Sequentially from Socket in JeroMQ - Java\nDESCRIPTION: This snippet shows how to receive consecutive string frames from a JeroMQ socket by making multiple recvStr calls in Java. Each call retrieves a single string frame in sequence from the incoming multipart message. Requires an established JeroMQ socket already receiving a multi-frame message. Inputs are the socket; outputs are individual string frames assigned to variables.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv_multi.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nString hello     = socket.recvStr();\nString beautiful = socket.recvStr();\nString world \\t = socket.recvStr();\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic ZeroMQ REP Server in Go\nDESCRIPTION: This Go code snippet demonstrates setting up and running a simple ZeroMQ server using the `zmq4` library. It initializes a ZeroMQ context, creates a REP (Reply) socket, binds it to all interfaces on port 5555 (`tcp://*:5555`), and enters an infinite loop. Inside the loop, it waits to receive a message from a client, logs the received message, simulates work with a 1-second delay using `time.Sleep`, and finally sends the string \"World\" back as a reply. It depends on the standard `log` and `time` packages, as well as the external `github.com/pebbe/zmq4` package.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/hello_world_server.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n        \"log\"\n        \"time\"\n\n        zmq \"github.com/pebbe/zmq4\"\n)\n\nfunc main() {\n        zctx, _ := zmq.NewContext()\n\n        s, _ := zctx.NewSocket(zmq.REP)\n        s.Bind(\"tcp://*:5555\")\n\n        for {\n                // Wait for next request from client\n                msg, _ := s.Recv(0)\n                log.Printf(\"Received %s\\n\", msg)\n\n                // Do some 'work'\n                time.Sleep(time.Second * 1)\n\n                // Send reply back to client\n                s.Send(\"World\", 0)\n        }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages with PUB Socket using cppzmq in C++\nDESCRIPTION: This C++ snippet demonstrates publishing multipart messages with topics using ZeroMQ's cppzmq library. It initializes a zmq::context_t for handling socket operations, constructs a publisher (PUB) socket, binds it to \"tcp://*:5555\", and enters an infinite loop where it sends topic-labelled messages on the 'status' topic. Dependencies include the cppzmq library and its C++ header files; this snippet requires the ZeroMQ system library installed and linked. It expects no input, sends multipart string messages, and serves as a starting template for topic-based pub/sub architectures using cppzmq in C++.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n//  Send a message on the 'status' topic\\n#include <string>\\n#include <iostream>\\n\\n#include <zmq.hpp>\\n\\nint main()\\n{\\n    // initialize the zmq context with a single IO thread\\n    zmq::context_t context{1};\\n\\n    // construct a PUB (publisher) socket and connect to interface\\n    zmq::socket_t publisher{context, zmq::socket_type::pub};\\n    publisher.bind(\"tcp://*:5555\");\\n\\n    // Send a multipart messages forever\\n    while(true){\\n        // Each consists of a topic envelope and content\\n        publisher.send(zmq::str_buffer(\"status\"), zmq::send_flags::sndmore);\\n        publisher.send(zmq::str_buffer(\"Message in status\"));\\n    }\\n\\n    return 0;\\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to ZeroMQ Topics with pyzmq in Python\nDESCRIPTION: This snippet shows how to set up a ZeroMQ SUB socket in Python using the pyzmq library to subscribe to messages under the \\'status\\' topic from a publisher on \\'tcp://localhost:5555\\'. The code connects the subscriber, specifies interest with ZMQ_SUBSCRIBE, and enters a loop to receive and print multi-part messages. It also configures signal handling so the process exits cleanly on Ctrl-C (SIGINT). Requires the pyzmq package and a running ZeroMQ publisher on the specified address. Expects the publisher to send multipart messages prefixed with the topic string.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport signal\nimport zmq\n\n\nsignal.signal(signal.SIGINT, signal.SIG_DFL)\n\ncontext = zmq.Context()\n\nsocket = context.socket(zmq.SUB)\nsocket.connect('tcp://localhost:5555')\nsocket.setsockopt(zmq.SUBSCRIBE, b'status')\n\nwhile True:\n    message = socket.recv_multipart()\n    print(f'Received: {message}')\n```\n\n----------------------------------------\n\nTITLE: Implementing Router-Dealer Pattern with goczmq in Go\nDESCRIPTION: Demonstrates a basic asynchronous request-reply pattern using `goczmq` in Go. It sets up a Router socket listening on TCP port 5555 and a Dealer socket connecting to it. The Dealer sends a 'Hello' message frame, the Router receives it (including the routing ID frame), sends back a 'World' reply using the routing ID, and the Dealer receives the reply. Error handling using `log.Fatal` and socket resource management with `defer Destroy()` are included. Requires the `goczmq` library (`github.com/zeromq/goczmq`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/go.md#_snippet_1\n\nLANGUAGE: golang\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/zeromq/goczmq\"\n)\n\nfunc main() {\n\t// Create a router socket and bind it to port 5555.\n\trouter, err := goczmq.NewRouter(\"tcp://*:5555\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer router.Destroy()\n\n\tlog.Println(\"router created and bound\")\n\n\t// Create a dealer socket and connect it to the router.\n\tdealer, err := goczmq.NewDealer(\"tcp://127.0.0.1:5555\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer dealer.Destroy()\n\n\tlog.Println(\"dealer created and connected\")\n\n\t// Send a 'Hello' message from the dealer to the router.\n\t// Here we send it as a frame ([]byte), with a FlagNone\n\t// flag to indicate there are no more frames following.\n\terr = dealer.SendFrame([]byte(\"Hello\"), goczmq.FlagNone)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Println(\"dealer sent 'Hello'\")\n\n\t// Receive the message. Here we call RecvMessage, which\n\t// will return the message as a slice of frames ([][]byte).\n\t// Since this is a router socket that support async\n\t// request / reply, the first frame of the message will\n\t// be the routing frame.\n\trequest, err := router.RecvMessage()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Printf(\"router received '%s' from '%v'\", request[1], request[0])\n\n\t// Send a reply. First we send the routing frame, which\n\t// lets the dealer know which client to send the message.\n\t// The FlagMore flag tells the router there will be more\n\t// frames in this message.\n\terr = router.SendFrame(request[0], goczmq.FlagMore)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Printf(\"router sent 'World'\")\n\n\t// Next send the reply. The FlagNone flag tells the router\n\t// that this is the last frame of the message.\n\terr = router.SendFrame([]byte(\"World\"), goczmq.FlagNone)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// Receive the reply.\n\treply, err := dealer.RecvMessage()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tlog.Printf(\"dealer received '%s'\", string(reply[0]))\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a ZeroMQ Publisher in Python using pyzmq\nDESCRIPTION: This Python script demonstrates a basic ZeroMQ publisher using the `pyzmq` library. It initializes a ZeroMQ context, creates a PUB socket, and binds it to listen on all network interfaces on TCP port 5555. It then enters a loop that iterates five times, sending two byte string messages in each iteration: `b'status 5'` (which implies topic 'status' and message '5' in pub/sub pattern) and `b'All is well'`, with a one-second pause between iterations. The script requires the `pyzmq` library and also sets the default signal handler for SIGINT (Ctrl+C) to allow graceful termination.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n```Python\nimport signal\nimport time\nimport zmq\n\n\nsignal.signal(signal.SIGINT, signal.SIG_DFL)\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.PUB)\nsocket.bind('tcp://*:5555')\n\nfor i in range(5):\n    socket.send(b'status 5')\n    socket.send(b'All is well')\n    time.sleep(1)\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Request-Reply Client with libzmq in C\nDESCRIPTION: Implements a simple ZeroMQ client using the low-level libzmq API. It initializes a context, creates a REQ (Request) socket, and connects to the server at `tcp://localhost:5555`. It then sends 10 \"Hello\" requests sequentially, waiting for and printing the corresponding \"World\" reply after each request. Finally, it closes the socket and destroys the context. Depends on `zmq.h` and standard C libraries.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_8\n\nLANGUAGE: c\nCODE:\n```\n#include <zmq.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n\nint main (void)\n{\n    printf (\"Connecting to hello world server…\\n\");\n    void *context = zmq_ctx_new ();\n    void *requester = zmq_socket (context, ZMQ_REQ);\n    zmq_connect (requester, \"tcp://localhost:5555\");\n\n    int request_nbr;\n    for (request_nbr = 0; request_nbr != 10; request_nbr++) {\n        char buffer [10];\n        printf (\"Sending Hello %d…\\n\", request_nbr);\n        zmq_send (requester, \"Hello\", 5, 0);\n        zmq_recv (requester, buffer, 10, 0);\n        printf (\"Received World %d\\n\", request_nbr);\n    }\n    zmq_close (requester);\n    zmq_ctx_destroy (context);\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Request-Reply Server with libzmq in C\nDESCRIPTION: Implements a simple ZeroMQ server using the low-level libzmq API. It initializes a context, creates a REP (Reply) socket, binds it to listen on TCP port 5555 on all interfaces, and enters an infinite loop. In the loop, it waits to receive a message, prints a confirmation, simulates work with `sleep(1)`, and sends back a \"World\" reply. Depends on `zmq.h` and standard C libraries.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_7\n\nLANGUAGE: c\nCODE:\n```\n#include <zmq.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <assert.h>\n\nint main (void)\n{\n    //  Socket to talk to clients\n    void *context = zmq_ctx_new ();\n    void *responder = zmq_socket (context, ZMQ_REP);\n    int rc = zmq_bind (responder, \"tcp://*:5555\");\n    assert (rc == 0);\n\n    while (1) {\n        char buffer [10];\n        zmq_recv (responder, buffer, 10, 0);\n        printf (\"Received Hello\\n\");\n        sleep (1);          //  Do some 'work'\n        zmq_send (responder, \"World\", 5, 0);\n    }\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Specific Topic with NetMQ in C#\nDESCRIPTION: This C# snippet shows how to use the `Subscribe` method of a `SubscriberSocket` instance (presumably named `sub`) from the NetMQ library. Calling `Subscribe` with a specific string ('status') filters incoming messages, ensuring the socket only receives messages prefixed with that topic.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n//  Subscribe to the 'status'\nsub.Subscribe(\"status\");\n```\n\n----------------------------------------\n\nTITLE: Sending a String as a ZFrame with Jeromq in Java\nDESCRIPTION: This snippet illustrates creating a `ZFrame` object from a string and then sending that frame over a ZeroMQ socket using Jeromq. This approach provides more control over the message frame itself compared to sending a raw string.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv.md#_snippet_2\n\nLANGUAGE: java\nCODE:\n```\nZFrame stringFrame = new ZFrame(\"HELLO\");\nstringFrame.send(socket, 0);\n```\n\n----------------------------------------\n\nTITLE: Implementing a Simple ZeroMQ REP Server Using JeroMQ in Java\nDESCRIPTION: This Java code implements a simple ZeroMQ server using the JeroMQ library. It creates a REP (reply) socket, binds to port 5555, waits for incoming messages, prints each message it receives, and replies to every client with the hardcoded string \"Hello, world!\". Dependencies include the org.zeromq.JeroMQ library and its classes ZMQ and ZContext; ensure your project includes this library and the correct imports. The code runs indefinitely until interrupted, expects messages as byte arrays, and prints them using the configured charset.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/java.md#_snippet_0\n\nLANGUAGE: Java\nCODE:\n```\nimport org.zeromq.ZMQ;\nimport org.zeromq.ZContext;\n\npublic class HelloWorldServer\n{\n    public static void main(String[] args) throws Exception\n    {\n        try (ZContext context = new ZContext()) {\n            // Socket to talk to clients\n            ZMQ.Socket socket = context.createSocket(ZMQ.REP);\n            socket.bind(\"tcp://*:5555\");\n\n            while (!Thread.currentThread().isInterrupted()) {\n                // Block until a message is received\n                byte[] reply = socket.recv(0);\n\n                // Print the message\n                System.out.println(\n                    \"Received: [\" + new String(reply, ZMQ.CHARSET) + \"]\"\n                );\n\n                // Send a response\n                String response = \"Hello, world!\";\n                socket.send(response.getBytes(ZMQ.CHARSET), 0);\n            }\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Publishing Status Topic Using ZeroMQ in C#\nDESCRIPTION: This snippet demonstrates how to send a message on the 'status' topic using the ZeroMQ library in C#. The pub.SendMoreFrame method sends the topic name as a multipart prefix, while SendFrame transmits the actual message content ('All is well'). Requires the ZeroMQ (NetMQ or similar) library, and presumes an initialized PUB socket instance named 'pub'. Inputs include the topic string and payload. The output is the message broadcast to all subscribers of the 'status' topic. The snippet should be part of a correctly configured PUB/SUB messaging setup.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\n//  Send a message on the 'status' topic\\npub.SendMoreFrame(\"status\").SendFrame(\"All is well\");\n```\n\n----------------------------------------\n\nTITLE: Setting up a Hello World REP Server with ZeroMQ (Python)\nDESCRIPTION: This code illustrates a basic ZeroMQ 'Hello World' server in Python using the pyzmq library. It creates a REP socket bound to tcp://*:5555, awaits a b\"Hello\" message from clients, simulates work with a 1-second delay, and responds with b\"World\". Required dependencies include the 'pyzmq' Python module. The server continuously runs, accepting messages and replying; key parameters include the bind address (tcp://*:5555), message content, and a work simulation duration. It expects binary messages and replies with a static response.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#\n#   Hello World server in Python\n#   Binds REP socket to tcp://*:5555\n#   Expects b\"Hello\" from client, replies with b\"World\"\n#\n\nimport time\nimport zmq\n\ncontext = zmq.Context()\nsocket = context.socket(zmq.REP)\nsocket.bind(\"tcp://*:5555\")\n\nwhile True:\n    #  Wait for next request from client\n    message = socket.recv()\n    print(f\"Received request: {message}\")\n\n    #  Do some 'work'\n    time.sleep(1)\n\n    #  Send reply back to client\n    socket.send(b\"World\")\n```\n\n----------------------------------------\n\nTITLE: Installing pyzmq with pip - Bash\nDESCRIPTION: This snippet demonstrates how to install the pyzmq package, which provides Python bindings for ZeroMQ, using the pip package manager. This is a prerequisite for running the Python server and client examples. Ensure that Python and pip are available in your environment before running this command.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/python.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pyzmq\n```\n\n----------------------------------------\n\nTITLE: Sending Hello Requests over ZeroMQ with CZMQ in C\nDESCRIPTION: This code snippet implements a basic ZeroMQ REQ client using the CZMQ library in C. It connects to a local server at tcp://localhost:5555, iterates 10 times to send a 'Hello' string, waits for a response, and prints output for each request/response cycle. Dependencies include the CZMQ library and its proper installation. The main functions used are zsock_new, zsock_connect, zstr_send, zstr_recv, and zsock_destroy. No input arguments are required, and the output consists of sequential request/response logs to stdout. The code assumes a corresponding REP server is available and running on the specified port.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Hello World client\\n#include <czmq.h>\\n\\nint main (void)\\n{\\n    printf (\\\"Connecting to hello world server…\\\\n\\\");\\n    zsock_t *requester = zsock_new (ZMQ_REQ);\\n    zsock_connect (requester, \\\"tcp://localhost:5555\\\");\\n\\n    int request_nbr;\\n    for (request_nbr = 0; request_nbr != 10; request_nbr++) {\\n        printf (\\\"Sending Hello %d…\\\\n\\\", request_nbr);\\n        zstr_send (requester, \\\"Hello\\\");\\n        char *str = zstr_recv (requester);\\n        printf (\\\"Received World %d\\\\n\\\", request_nbr);\\n        zstr_free (&str);\\n    }\\n    zsock_destroy (&requester);\\n    return 0;\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Broadcasting Messages with ZeroMQ Radio Socket in C++\nDESCRIPTION: This code snippet implements a message broadcaster using the cppzmq library for ZeroMQ in C++. It initializes a ZeroMQ context and creates a Radio socket, binding to TCP port 5555. The program cyclically sends messages to three groups ('group1', 'group2', 'group3'), setting the group for each message and printing the destination to the console. Required dependencies include the cppzmq and ZeroMQ libraries. Inputs include no command-line arguments; outputs are messages sent to groups over TCP and console print statements. The program runs indefinitely and assumes the network port is available and not blocked by firewalls.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/raddsh_radio_example.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <chrono>\\n#include <cstdlib>\\n#include <iostream>\\n#include <string>\\n#include <thread>\\n#include <zmq.hpp>\\n\\nint main() {\\n  // Initialize the zmq context with a single IO thread\\n  zmq::context_t context{1};\\n\\n  // Construct a Radio socket and connect to interface.\\n  zmq::socket_t radio{context, zmq::socket_type::radio};\\n  radio.bind(\"tcp://*:5555\");\\n\\n  // Send messages forever, alternating between 3 groups.\\n  for (uint32_t i = 1; true; i = (i % 3 == 0) ? 1 : i + 1) {\\n    std::string group = \"group\" + std::to_string(i);\\n    std::string payload = \"This is for \" + group;\\n    zmq::message_t msg{payload};\\n    msg.set_group(group.c_str());\\n    radio.send(msg, zmq::send_flags::none);\\n    std::cout << \"Sent a message to \" << group << \"\\n\";\\n    std::this_thread::sleep_for(std::chrono::seconds(1));\\n  }\\n\\n  return EXIT_SUCCESS;\\n}\n```\n\n----------------------------------------\n\nTITLE: Connecting ZeroMQ REQ Server - Java JeroMQ Example\nDESCRIPTION: This Java snippet illustrates how to implement a basic ZeroMQ REQ client using the JeroMQ pure-Java library. The client establishes a request socket to tcp://localhost:5555, sends a series of \"Hello\" messages, and waits for corresponding \"World\" replies for each iteration. Dependencies include the org.zeromq:jeromq library, and the socket communication is managed within a try-with-resources ZContext for proper resource handling. The example shows the usage of ZMQ.Socket, connecting, sending, and receiving string messages in sequence, serving as a template for request-reply interactions. The input is a hardcoded \"Hello\" string per request, and the output is a printed reply from the server; it assumes that a compatible server is running on port 5555.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/hello_world_client.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n//  Hello World client in Java\\n//  Connects REQ socket to tcp://localhost:5555\\n//  Sends \\\"Hello\\\" to server, expects \\\"World\\\" back\\n\\nimport org.zeromq.SocketType;\\nimport org.zeromq.ZMQ;\\nimport org.zeromq.ZContext;\\n\\npublic class hwclient\\n{\\n    public static void main(String[] args)\\n    {\\n        try (ZContext context = new ZContext()) {\\n            System.out.println(\\\"Connecting to hello world server\\\");\\n\\t\\t\\t//  Socket to talk to server\\n            ZMQ.Socket socket = context.createSocket(SocketType.REQ);\\n            socket.connect(\\\"tcp://localhost:5555\\\");\\n\\n            for (int requestNbr = 0; requestNbr != 10; requestNbr++) {\\n                String request = \\\"Hello\\\";\\n                System.out.println(\\\"Sending Hello \\\" + requestNbr);\\n                socket.send(request.getBytes(ZMQ.CHARSET), 0);\\n\\n                byte[] reply = socket.recv(0);\\n                System.out.println(\\n                    \\\"Received \\\" + new String(reply, ZMQ.CHARSET) + \\\" \\\" +\\n                    requestNbr\\n                );\\n            }\\n        }\\n    }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Installing rbzmq Gem with Custom libzmq Path using Bash\nDESCRIPTION: This command installs the `zmq` gem while explicitly specifying the installation directory of the `libzmq` library using the `--with-zmq-dir` flag. This is useful when `libzmq` is installed in a non-standard location.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/ruby.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq -- --with-zmq-dir=/opt/local\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Topics with czmq in C\nDESCRIPTION: This code snippet demonstrates how to use the czmq library in C to subscribe to the \\'status\\' topic on a subscriber socket in a ZeroMQ PUB/SUB pattern. The function \\'zsock_set_subscribe\\' is used, taking the subscriber socket and string topic as arguments, thereby instructing the socket to filter incoming messages by the specified topic prefix. Dependencies include the czmq library, and the subscriber socket (\\'sub\\') must be previously created and initialized. The key parameters are the subscriber socket object and the topic string.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Subscribe to the 'status'\nzsock_set_subscribe(sub, \"status\");\n```\n\n----------------------------------------\n\nTITLE: Building and Installing ZeroMQ Library with Bash\nDESCRIPTION: This Bash snippet guides users through cloning the libzmq repository, generating build scripts, configuring the build to use libsodium, compiling, and installing ZeroMQ. Dependencies include git, automake/autoconf, and that libsodium has been installed. Sudo privileges are needed for installation. After execution, ZeroMQ is available system-wide with security features enabled.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/zmqpp/download.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Build, check, and install the latest version of ZeroMQ\\ngit clone git://github.com/zeromq/libzmq.git\\ncd libzmq\\n./autogen.sh\\n./configure --with-libsodium && make\\nsudo make install\\nsudo ldconfig\\ncd ../\n```\n\n----------------------------------------\n\nTITLE: Sending Hello World Requests via zeromq.js in Node.js\nDESCRIPTION: This JavaScript snippet implements a ZeroMQ client using the zeromq.js library. The script creates a Request socket, connects to a server at 'tcp://localhost:5555', and executes a loop to send a 'Hello' message 10 times, waiting asynchronously for a response after each send. It requires Node.js and the 'zeromq' npm package, assumes the server is running and listening at the specified address, and demonstrates asynchronous communication by awaiting message responses. Input to this script is programmatic (no user input), and output consists of console logs displaying send/receive actions. There are no explicit limitations, but concurrent or failed connections are not handled.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/hello_world_client.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//  Hello World client\nconst zmq = require('zeromq');\n\nasync function runClient() {\n  console.log('Connecting to hello world server…');\n\n  //  Socket to talk to server\n  const sock = new zmq.Request();\n  sock.connect('tcp://localhost:5555');\n\n  for (let i = 0; i < 10; i++) {\n    console.log('Sending Hello ', i);\n    await sock.send('Hello');\n    const [result] = await sock.receive();\n    console.log('Received ', result.toString(), i);\n  }\n}\n\nrunClient();\n```\n\n----------------------------------------\n\nTITLE: Constructing and Sending Multi-Frame Messages with ZMsg - JeroMQ - Java\nDESCRIPTION: This snippet illustrates creating a multipart message by adding string frames to a ZMsg object and sending it over a socket in Java using JeroMQ. The ZMsg class provides a higher-level abstraction for multipart messages, supporting add for frame addition and send for transmission. Requires the ZMsg class (from JeroMQ) and a configured socket. Inputs are the individual string frames and the socket; output is a single sent multipart message.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv_multi.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nZMsg *strings = new ZMsg();\nstrings.add(\"HELLO\");\nstrings.add(\"beautiful\");\nstrings.add(\"WORLD\");\nstrings.send(socket);\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ Hello World REP Server in Haskell\nDESCRIPTION: This Haskell code implements a simple ZeroMQ REP (reply) server using the zeromq4-haskell library. It binds to 'tcp://*:5555', waits for 'Hello' messages from clients, simulates processing by waiting one second, and then sends 'World' as a reply. Dependencies include the zeromq4-haskell and bytestring packages. Key parameters include the socket type (Rep), the bind address, and the use of ByteString for message encoding/decoding. The server outputs received messages to the console and expects each communication to follow the request-reply pattern; it does not handle multiple concurrent connections or complex message formats.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/haskell/zeromq4-haskell/hello_world_server.md#_snippet_0\n\nLANGUAGE: haskell\nCODE:\n```\n-- This lets us conviniently use efficient ByteString to send and recieve messages\\n{-# LANGUAGE OverloadedStrings #-}         \\n\\n{-$\\n   Hello World server in Haskell\\n   Binds REP socket to tcp://*:5555\\n   Expects \\\"Hello\\\" from client, replies with \\\"World\\\"\\n-$}\\n\\nimport System.ZMQ4.Monadic (runZMQ, socket, bind, send, receive, Socket, Rep(..))\\nimport Control.Monad (forever)\\nimport Control.Monad.IO.Class (liftIO)\\nimport Control.Concurrent (threadDelay)\\nimport Data.ByteString.Char8 (pack, unpack)\\n\\nmain :: IO ()\\nmain = runZMQ $ do\\n    repSocket <- socket Rep\\n    bind repSocket \\\"tcp://*:5555\\\"\\n    forever $ do\\n        --  Wait for next request from client\\n        message <- receive repSocket\\n        liftIO $ putStrLn (\\\"Received request: \\\" ++ unpack message)\\n\\n        --  Do some 'work' (waiting for 1 second here)\\n        liftIO $ threadDelay (1 * 1000000)\\n\\n        --  Send reply back to client\\n        send repSocket [] (pack \\\"World\\\")\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ Hello World Server in Zig\nDESCRIPTION: This Zig code snippet demonstrates a basic ZeroMQ server using the 'zzmq' library. It initializes a REP (Reply) socket, binds it to 'tcp://127.0.0.1:5555', and enters a loop to receive messages, log them, simulate work by sleeping for one second, and send back the string 'World' as a reply. Dependencies include the Zig standard library ('std') and the 'zzmq' library. Proper memory management is handled using a GeneralPurposeAllocator and defer statements for deinitialization.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\n```zig\nconst std = @import(\"std\");\nconst zzmq = @import(\"zzmq\");\n\npub fn main() !void {\n    std.log.info(\"Starting the server...\", .{});\n\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        if (gpa.deinit() == .leak)\n            @panic(\"Memory leaked\");\n    }\n\n    const allocator = gpa.allocator();\n\n    var socket = try zzmq.ZSocket.init(allocator, zzmq.ZSocketType.Rep);\n    defer socket.deinit();\n\n    _ = try socket.bind(\"tcp://127.0.0.1:5555\");\n\n    while (true) {\n        // Wait for next request from client\n        {\n            var frame = try socket.receive();\n            defer frame.deinit();\n\n            const data = try frame.data();\n\n            std.log.info(\"Received: {s}\", .{data});\n        }\n\n        // Do some 'work'\n        std.time.sleep(std.time.ns_per_s);\n\n        // Send reply back to client\n        {\n            var frame = try zzmq.ZFrame.init(\"World\");\n            defer frame.deinit();\n\n            try socket.send(&frame, .{});\n        }\n    }\n}\n\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing ZeroMQ REP Socket Server in Node.js\nDESCRIPTION: This snippet creates an asynchronous ZeroMQ server using Node.js and the zeromqjs library. It binds a REP socket to 'tcp://*:5555', listens for incoming messages (expecting 'Hello' from clients), and replies with 'World'. Requires installing the 'zeromq' npm package. The server runs indefinitely, outputting received messages to the console, and is intended for demonstration and testing of the request-reply messaging pattern.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/hello_world_server.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//  Hello World server\\n//  Binds REP socket to tcp://*:5555\\n//  Expects \\\"Hello\\\" from client, replies with \\\"World\\\"\\n\\nconst zmq = require('zeromq');\\n\\nasync function runServer() {\\n  const sock = new zmq.Reply();\\n\\n  await sock.bind('tcp://*:5555');\\n\\n  for await (const [msg] of sock) {\\n    console.log('Received ' + ': [' + msg.toString() + ']');\\n    await sock.send('World');\\n    // Do some 'work'\\n  }\\n}\\n\\nrunServer();\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ REQ Client in Rust\nDESCRIPTION: This Rust code demonstrates a basic ZeroMQ client using the `rust-zmq` library. It establishes a connection to a server at `tcp://localhost:5555` using a REQ socket. The client then iterates 10 times, sending a \"Hello\" message and waiting to receive a corresponding reply from the server in each iteration, printing the received message content. It requires the `rust-zmq` crate dependency.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/rust/rust-zmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\n```rust\n#![crate_name = \"helloworld_client\"]\n\n//! Hello World client\n\nfn main() {\n    println!(\"Connecting to hello world server...\\n\");\n\n    let context = zmq::Context::new();\n    let requester = context.socket(zmq::REQ).unwrap();\n\n    assert!(requester.connect(\"tcp://localhost:5555\").is_ok());\n\n    let mut msg = zmq::Message::new();\n\n    for request_nbr in 0..10 {\n        println!(\"Sending Hello {}...\", request_nbr);\n        requester.send(\"Hello\", 0).unwrap();\n\n        requester.recv(&mut msg, 0).unwrap();\n        println!(\"Received World {}: {}\", msg.as_str().unwrap(), request_nbr);\n    }\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ZeroMQ REQ Client in Python\nDESCRIPTION: This Python script demonstrates a simple ZeroMQ client using the REQ socket type. It initializes a ZeroMQ context, connects a REQ socket to `tcp://localhost:5555`, and sends \"Hello\" messages 10 times, printing the \"World\" reply received from the server for each request. It depends on the `pyzmq` library and requires a corresponding ZeroMQ REP server running and listening.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n#\n#   Hello World client in Python\n#   Connects REQ socket to tcp://localhost:5555\n#   Sends \"Hello\" to server, expects \"World\" back\n#\n\nimport zmq\n\ncontext = zmq.Context()\n\n#  Socket to talk to server\nprint(\"Connecting to hello world server…\")\nsocket = context.socket(zmq.REQ)\nsocket.connect(\"tcp://localhost:5555\")\n\n#  Do 10 requests, waiting each time for a response\nfor request in range(10):\n    print(f\"Sending request {request} …\")\n    socket.send(b\"Hello\")\n\n    #  Get the reply.\n    message = socket.recv()\n    print(f\"Received reply {request} [ {message} ]\")\n\n```\n\n----------------------------------------\n\nTITLE: Initializing ZeroMQ Client with pyzmq - Python\nDESCRIPTION: This snippet provides a Python client for ZeroMQ using pyzmq, connecting a REQ socket to tcp://localhost:5555. It demonstrates sending 10 b\\\"Hello\\\" messages to the server and awaiting b\\\"World\\\" responses for each. Dependencies include only pyzmq, and the server must already be running. Key parameters are the address (tcp://localhost:5555) and number of requests (10), which can be adjusted for different use cases.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/python.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n#\n#   Hello World client in Python\n#   Connects REQ socket to tcp://localhost:5555\n#   Sends \"Hello\" to server, expects \"World\" back\n#\n\nimport zmq\n\ncontext = zmq.Context()\n\n#  Socket to talk to server\nprint(\"Connecting to hello world server…\")\nsocket = context.socket(zmq.REQ)\nsocket.connect(\"tcp://localhost:5555\")\n\n#  Do 10 requests, waiting each time for a response\nfor request in range(10):\n    print(\"Sending request %s …\" % request)\n    socket.send(b\"Hello\")\n\n    #  Get the reply.\n    message = socket.recv()\n    print(\"Received reply %s [ %s ]\" % (request, message))\n```\n\n----------------------------------------\n\nTITLE: Sending and Receiving Requests with ZeroMQ in Zig using zzmq\nDESCRIPTION: This Zig code snippet implements a ZeroMQ client leveraging the zzmq library. It sets up a REQ socket, connects to a server at tcp://127.0.0.1:5555, and performs 10 request-reply cycles, sending the string 'Hello' and logging the server's replies. Dependencies include the Zig standard library (std) and zzmq. Key parameters include the allocator for resource management, the connection endpoint, and the socket/frame objects. The inputs are hardcoded message strings, and the output is console log messages with server replies. Proper memory and resource management is enforced via defer statements, ensuring stable operation and clear error handling.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: Zig\nCODE:\n```\nconst std = @import(\"std\");\nconst zzmq = @import(\"zzmq\");\n\npub fn main() !void {\n    std.log.info(\"Connecting to the server...\", .{});\n\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        if (gpa.deinit() == .leak)\n            @panic(\"Memory leaked\");\n    }\n\n    const allocator = gpa.allocator();\n\n    var socket = try zzmq.ZSocket.init(allocator, zzmq.ZSocketType.Req);\n    defer socket.deinit();\n\n    try socket.connect(\"tcp://127.0.0.1:5555\");\n\n    // Do 10 requests, waiting each time for a response\n    for (0..9) |i| {\n        // Send the request\n        {\n            std.log.info(\"Sending request {}...\", .{i});\n\n            var frame = try zzmq.ZFrame.init(\"Hello\");\n            defer frame.deinit();\n\n            try socket.send(&frame, .{});\n        }\n\n        // Receive the reply\n        {\n            var frame = try socket.receive();\n            defer frame.deinit();\n\n            const data = try frame.data();\n\n            std.log.info(\"Received reply {} [ {s} ]\", .{ i, data });\n        }\n    }\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Basic ZeroMQ REP Server in C++\nDESCRIPTION: This C++ code snippet demonstrates a simple ZeroMQ server using the REP (Reply) socket pattern with the `cppzmq` wrapper. It initializes a ZeroMQ context, binds a REP socket to TCP port 5555, waits for incoming requests, prints them, simulates processing time with a 1-second sleep, and sends a fixed 'World' string as a reply. Requires the `cppzmq` library and standard C++ libraries (`string`, `chrono`, `thread`, `iostream`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/hello_world_server.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <string>\n#include <chrono>\n#include <thread>\n#include <iostream>\n\n#include <zmq.hpp>\n\nint main() \n{\n    using namespace std::chrono_literals;\n\n    // initialize the zmq context with a single IO thread\n    zmq::context_t context{1};\n\n    // construct a REP (reply) socket and bind to interface\n    zmq::socket_t socket{context, zmq::socket_type::rep};\n    socket.bind(\"tcp://*:5555\");\n\n    // prepare some static data for responses\n    const std::string data{\"World\"};\n\n    for (;;) \n    {\n        zmq::message_t request;\n\n        // receive a request from client\n        socket.recv(request, zmq::recv_flags::none);\n        std::cout << \"Received \" << request.to_string() << std::endl;\n\n        // simulate work\n        std::this_thread::sleep_for(1s);\n\n        // send the reply to the client\n        socket.send(zmq::buffer(data), zmq::send_flags::none);\n    }\n\n    return 0;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a ZeroMQ DEALER Client using goczmq in Go\nDESCRIPTION: This Go code snippet demonstrates how to create a ZeroMQ DEALER client using the `goczmq` library. It establishes a connection to a ROUTER endpoint (`tcp://127.0.0.1:5555`), sends 10 \"Hello\" messages as individual frames, and awaits a reply for each message using `SendFrame` and `RecvMessage`. The code includes basic error checking using `log.Fatal` and logs communication steps. It depends on the `log` and `github.com/zeromq/goczmq` packages and requires a running ZeroMQ ROUTER server listening on the specified address and port.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/goczmq/hello_world_client.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\npackage main\n\nimport (\n\t\"log\"\n\n\t\"github.com/zeromq/goczmq\"\n)\n\nfunc main() {\n\t// Create a dealer socket and connect it to the router.\n\tdealer, err := goczmq.NewDealer(\"tcp://127.0.0.1:5555\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer dealer.Destroy()\n\n\tlog.Println(\"dealer created and connected\")\n\n\t// Do 10 requests, waiting each time for a response\n\tfor i := 0; i < 10; i++ {\n\t\t// Send a 'Hello' message from the dealer to the router.\n\t\t// Here we send it as a frame ([]byte), with a FlagNone\n\t\t// flag to indicate there are no more frames following.\n\t\terr = dealer.SendFrame([]byte(\"Hello\"), goczmq.FlagNone)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tlog.Println(\"dealer sent 'Hello'\")\n\n\t\t// Receive the reply.\n\t\treply, err := dealer.RecvMessage()\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\n\t\tlog.Printf(\"dealer received '%s'\", string(reply[0]))\n\t}\n}\n\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic ZeroMQ REP Server in Erlang with Chumak\nDESCRIPTION: This Erlang code defines a module 'hello_world_server' that implements a ZeroMQ REP socket server using the 'chumak' library. The 'main' function initializes chumak, creates and binds a REP socket to tcp://localhost:5555. The 'loop' function handles incoming requests by printing them and sending back the reply 'Hello Friend'. Requires Erlang and the chumak library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/erlang/chumak/hello_world_server.md#_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-module(hello_world_server).\n-export([main/0]).\n\nmain() ->\n    application:start(chumak),\n    {ok, Socket} = chumak:socket(rep, \"hello world server\"),\n\n    {ok, _BindPid} = chumak:bind(Socket, tcp, \"localhost\", 5555),\n    loop(Socket).\n\nloop(Socket) ->\n    Reply = chumak:recv(Socket),\n    io:format(\"Question: ~p\\n\", [Reply]),\n    chumak:send(Socket, <<\"Hello Friend\">>),\n    loop(Socket).\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ Request Client with Chumak in Erlang\nDESCRIPTION: This Erlang code demonstrates how to create a simple client that communicates with a ZeroMQ server using the Chumak library. It initializes the Chumak application, sets up a request socket, connects to 'localhost' on port 5555, and then sends ten 'Hello' messages, printing both sent and received messages. Dependencies include the 'chumak' Erlang library, a running ZeroMQ server at the specified endpoint, and Erlang/OTP configured with Chumak installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/erlang/chumak/hello_world_client.md#_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n-module(hello_world_client).\n-export([main/0]).\n\nmain() ->\n    application:start(chumak),\n    {ok, Socket} = chumak:socket(req, \"hello world client\"),\n\n    {ok, Pid} = chumak:connect(Socket, tcp, \"localhost\", 5555),\n\n    send_messages(Socket, 10).\n\nsend_messages(Socket, 0) ->\n    ok;\n\nsend_messages(Socket, N) ->\n    io:format(\"Sending Hello ~p\\n...\", [N]),\n    ok = chumak:send(Socket, <<\"Hello\">>),\n\n    {ok, RecvMessage} = chumak:recv(Socket),\n    io:format(\"Received: ~p\\n\", [RecvMessage]),\n\n    send_messages(Socket, N-1).\n```\n\n----------------------------------------\n\nTITLE: Receiving a String from ZeroMQ Socket in C\nDESCRIPTION: This function receives up to 255 characters from a ZeroMQ socket using zmq_recv and writes them into a local buffer. It ensures the output is null-terminated, duplicates the buffer content, and returns a newly allocated C string. The function depends on libzmq and requires a valid ZeroMQ socket pointer. If more than 255 bytes are sent, extra data is truncated. On receive error, it returns NULL.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_strings_send_recv.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\n//  Receive string from socket and convert into C string\n//  Chops string at 255 chars, if it's longer\nstatic char *\ns_recv_string (void *socket) {\n    char buffer [256];\n    int size = zmq_recv (socket, buffer, 255, 0);\n    if (size == -1)\n        return NULL;\n    if (size > 255)\n        size = 255;\n    buffer [size] = \\0;\n    /* use strndup(buffer, sizeof(buffer)-1) in *nix */\n    return strdup (buffer);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding ZeroMQ OBS Repository and Installing on Debian 9\nDESCRIPTION: Adds the ZeroMQ Open Build Service (OBS) repository for the latest stable release (without draft APIs) to a Debian 9 system's sources list, imports the repository's GPG key, and then installs the ZeroMQ development package (`libzmq3-dev`). Requires root or sudo privileges.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\necho \"deb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/ ./\" >> /etc/apt/sources.list\nwget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/Release.key -O- | sudo apt-key add\napt-get install libzmq3-dev\n```\n\n----------------------------------------\n\nTITLE: Receiving a Simple String Message with Jeromq in Java\nDESCRIPTION: This snippet shows how to receive a string message directly from a ZeroMQ socket using the `socket.recvStr()` method in Jeromq. This method blocks until a message is available and returns it as a Java String, assuming default character encoding.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv.md#_snippet_1\n\nLANGUAGE: java\nCODE:\n```\nString hello = socket.recvStr()\n```\n\n----------------------------------------\n\nTITLE: Receiving Multiple String Frames as a List with NetMQ in C#\nDESCRIPTION: This C# snippet shows how to receive a multi-part message where all parts are expected to be strings. It utilizes the `ReceiveMultipartStrings` method of a NetMQ socket, which blocks until a complete message is received and returns all frames as a `List<string>`. Requires an initialized NetMQ socket instance ready to receive.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/messages_strings_send_recv_multi.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nList<string> strings = socket.ReceiveMultipartStrings();\n```\n\n----------------------------------------\n\nTITLE: Building ZeroMQ.js from Source using npm (Shell)\nDESCRIPTION: This command forces the installation of the `zeromq` npm package by compiling it from source code, using the `--build-from-source` flag. This bypasses the use of prebuilt binaries and requires necessary build tools (C++17 compiler, make, Python, CMake, curl) and Node.js 10+ or Electron 3+.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/download.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nnpm install zeromq@6.0.0-beta.17 --build-from-source\n```\n\n----------------------------------------\n\nTITLE: Receiving Multi-part String Message with ZeroMQ in C\nDESCRIPTION: This C code snippet demonstrates receiving a multi-part message composed of string frames from a ZeroMQ socket. It uses a `do-while` loop to repeatedly receive frames (using an assumed helper function `s_recv_string`) until the `ZMQ_RCVMORE` socket option, checked via `zmq_getsockopt`, indicates that no more parts are pending for the current message. Received strings are stored in the `strings` array. Requires a ZeroMQ socket configured for receiving and assumes the existence of `s_recv_string` for handling individual frame reception.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_strings_send_recv_multi.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nchar *strings[25];\nint rcvmore;\nsize_t option_len = sizeof (int);\nint index = 0;\ndo {\n    strings[index++] = s_recv_string (socket);\n    zmq_getsockopt (socket, ZMQ_RCVMORE, &rcvmore, &option_len);\n} while (rcvmore);\n```\n\n----------------------------------------\n\nTITLE: Building azmq on Linux/OS X using CMake and Make\nDESCRIPTION: This sequence of shell commands demonstrates the standard procedure for building the azmq library on Unix-like systems (Linux, OS X). It involves creating a build directory, running CMake to configure the build system, compiling the code with Make, executing tests, and finally installing the library. Requires CMake, a C++11 compiler, Make, Boost, and ZeroMQ to be installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/azmq/download.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ mkdir build && cd build\n$ cmake ..\n$ make\n$ make test\n$ make install\n```\n\n----------------------------------------\n\nTITLE: Implementing Request-Response Client with NetMQ in C#\nDESCRIPTION: This snippet demonstrates a ZeroMQ request client using NetMQ in C#. It connects to a TCP endpoint, sends a message ('Hello'), receives a response from the server, and prints the reply. Required dependency: NetMQ library (install via NuGet). Requires a matching server endpoint and proper exception handling in production. Inputs: none, outputs: prints server's response to console.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/csharp.md#_snippet_0\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var client = new RequestSocket())\\n{\\n    client.Connect(\\\"tcp://127.0.0.1:5556\\\");\\n    client.SendFrame(\\\"Hello\\\");\\n    var msg = client.ReceiveFrameString();\\n    Console.WriteLine(\\\"From Server: {0}\\\", msg);\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Building azmq on Windows using CMake and CTest\nDESCRIPTION: These commands outline the process for building the azmq library on Windows using CMake. A build directory is created, CMake generates the build files (e.g., for Visual Studio), the project is compiled in the 'Release' configuration, and tests are executed using CTest. Requires CMake, a C++11 compiler (like Visual Studio), Boost, and ZeroMQ.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/azmq/download.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n> mkdir build\n> cd build\n> cmake ..\n> cmake --build . --config Release\n> ctest . -C Release\n```\n\n----------------------------------------\n\nTITLE: Sending a Message with cppzmq in C++\nDESCRIPTION: This C++ example demonstrates the basic usage of the cppzmq header-only binding. It initializes a ZeroMQ context, creates a PUSH socket, binds it to an in-process communication endpoint ('inproc://test'), and sends a simple string message asynchronously using zmq::buffer and the dontwait flag. Requires the cppzmq header and the underlying libzmq library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/cplusplus.md#_snippet_0\n\nLANGUAGE: C++\nCODE:\n```\n```C++\n#include <string>\n#include <zmq.hpp>\nint main()\n{\n   zmq::context_t ctx;\n   zmq::socket_t sock(ctx, zmq::socket_type::push);\n   sock.bind(\"inproc://test\");\n   const std::string_view m = \"Hello, world\";\n   sock.send(zmq::buffer(m), zmq::send_flags::dontwait);\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish-Subscribe Subscriber with NetMQ in C#\nDESCRIPTION: This snippet shows a ZeroMQ subscriber using NetMQ in C#. It connects to a publisher endpoint, subscribes to messages on topic 'A', and enters an infinite loop to receive topic and message frames, printing each received pair. Dependency: NetMQ. The subscription is static ('A'), with the loop intended for demonstration. Inputs: messages from publisher; outputs: logged messages to console.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/csharp.md#_snippet_2\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var subscriber = new SubscriberSocket())\\n{\\n    subscriber.Connect(\\\"tcp://127.0.0.1:5556\\\");\\n    subscriber.Subscribe(\\\"A\\\");\\n\\n    while (true)\\n    {\\n        var topic = subscriber.ReceiveFrameString();\\n        var msg = subscriber.ReceiveFrameString();\\n        Console.WriteLine(\\\"From Publisher: {0} {1}\\\", topic, msg);\\n    }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Sending Topic-Based Message with ZeroMQ Publisher in C\nDESCRIPTION: This C code snippet demonstrates sending a multi-part message using a ZeroMQ publisher socket (`pub`). The first `zmq_send` call sends the topic string 'status' (6 bytes) with the `ZMQ_SNDMORE` flag, indicating that more message parts will follow. The second `zmq_send` call sends the actual message payload 'All is well' (11 bytes) without the flag, completing the message. This assumes `pub` is a previously initialized and bound ZeroMQ publisher socket.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Send a message on the 'status' topic\nzmq_send (pub, \"status\", 6, ZMQ_SNDMORE);\nzmq_send (pub, \"All is well\", 11, 0);\n```\n\n----------------------------------------\n\nTITLE: Sending a Multipart Message with Topic using zstr_sendx in C (CZMQ)\nDESCRIPTION: This C snippet demonstrates using the CZMQ function `zstr_sendx` to publish a multipart message. It sends the string 'All is well' under the topic 'status' via a publisher socket represented by the `pub` variable (assumed to be a `zsock_t*` or similar). The `NULL` terminates the variable arguments list specifying the message parts. This function requires an initialized CZMQ publisher socket.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Send a message on the 'status' topic\nzstr_sendx (pub, \"status\", \"All is well\", NULL);\n```\n\n----------------------------------------\n\nTITLE: Sending Multi-part String Message with ZeroMQ in C\nDESCRIPTION: This function `s_send_strings` sends an array of C strings over a ZeroMQ socket as a multi-part message. It iterates through the input string array, sending each string as a frame using `zmq_send`. The `ZMQ_SNDMORE` flag is set for all frames except the last one, signaling to ZeroMQ that more parts of the message will follow. Requires a valid ZeroMQ socket, an array of strings, and the count of strings. Note: `strdup` is used, implying dynamic memory allocation for each sent string.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_strings_send_recv_multi.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nstatic void\ns_send_strings (void *socket, const char[] *strings, int no_of_strings) {\n    for (index = 0; index < no_of_strings; index++) {\n        int FLAG = (index + 1) == no_of_strings ? 0 : ZMQ_SNDMORE;\n        zmq_send (socket, strdup(strings[index]), strlen(strings[index]), FLAG);\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Publishing a Topic and Message using Jeromq in Java\nDESCRIPTION: This Java code snippet demonstrates sending a two-part message using a Jeromq publisher socket (`pub`). The `sendMore` method sends the topic name (\"Status\") and indicates that another part of the message will follow. The subsequent `send` method sends the actual message content (\"All is well\"). This mechanism allows subscribers to filter messages based on the topic. It assumes `pub` is an already initialized and connected `ZMQ.Socket` of type PUB.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n//  Send a message on the 'status' topic\npub.sendMore(\"Status\");\npub.send(\"All is well\");\n```\n\n----------------------------------------\n\nTITLE: Sending a Simple String Message with Jeromq in Java\nDESCRIPTION: This snippet demonstrates sending a string directly to a ZeroMQ socket using the `socket.send()` method in Jeromq. The string is sent as a single-frame message where the frame's data length matches the string's length.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nsocket.send(\"HELLO\");\n```\n\n----------------------------------------\n\nTITLE: Sending Multi-Frame Strings Using Socket sendMore in JeroMQ - Java\nDESCRIPTION: This snippet demonstrates sending multiple string frames as a single multipart message using the JeroMQ socket's sendMore and send methods in Java. Each call to sendMore queues part of the message, and the message is actually sent when send (without 'More') is called for the last part. Requires JeroMQ library and an established socket. Inputs are the socket and strings to be sent; outputs are the strings transmitted as a single logical message.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv_multi.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\nsocket.sendMore (socket, \"HELLO\");\nsocket.sendMore (socket, \"beautiful\");\nsocket.send (socket, \"WORLD!\");\n```\n\n----------------------------------------\n\nTITLE: Illustrating C++ Function Argument Naming\nDESCRIPTION: Example demonstrating the convention of suffixing function arguments with an underscore (_) to distinguish them from member variables with potentially the same name. It also shows the '_t' suffix convention for type identifiers (structs) and constructor initializer list formatting.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_3\n\nLANGUAGE: cpp\nCODE:\n```\nstruct complex_t\n{\n    complex_t (float real_, float imaginary_) :\n        real (real_),\n        imaginary (imaginary_)\n    {\n    }\n\n    float real;\n    float imaginary;\n};\n```\n\n----------------------------------------\n\nTITLE: Sending a Topic Message with ZeroMQ.js Publisher\nDESCRIPTION: This Node.js snippet uses the `zeromqjs` library to send a multipart message via a publisher socket (`pub`). The first part of the message array designates the topic ('status'), and the second part is the message content ('All is well'). This requires a pre-configured and connected ZeroMQ publisher socket instance named `pub`.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//  Send a message on the 'status' topic\npub.send(['status', 'All is well']);\n```\n\n----------------------------------------\n\nTITLE: Sending Requests with ZeroMQ Request Socket - JavaScript\nDESCRIPTION: Implements a Request socket as a ZeroMQ client. The code connects to a Reply server and sends a string message ('4'), then awaits a response and logs the result. Dependencies: zeromq.js. The Reply server must be running on the same endpoint. Expects a numeric string as request input and a single response from the server.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_5\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Request()\n\n  sock.connect(\"tcp://127.0.0.1:3000\")\n  console.log(\"Producer bound to port 3000\")\n\n  await sock.send(\"4\")\n  const [result] = await sock.receive()\n\n  console.log(result)\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Messages with ZeroMQ Subscriber Socket - JavaScript\nDESCRIPTION: Implements a Subscriber using ZeroMQ that connects to a Publisher and subscribes to a specific topic ('kitty cats'). The socket listens for and logs all multipart messages matching the topic. Dependencies: zeromq.js. Requires a running Publisher on the specified endpoint. Expects topic-based messages as input, outputs received message details to the console.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Subscriber()\n\n  sock.connect(\"tcp://127.0.0.1:3000\")\n  sock.subscribe(\"kitty cats\")\n  console.log(\"Subscriber connected to port 3000\")\n\n  for await (const [topic, msg] of sock) {\n    console.log(\n      \"received a message related to:\",\n      topic,\n      \"containing message:\",\n      msg,\n    )\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Pushing Messages with ZeroMQ Push Socket - JavaScript\nDESCRIPTION: Implements a ZeroMQ Push socket in Node.js to act as a producer. The code initializes a Push socket, binds it to a TCP endpoint, and enters an infinite loop sending the message 'some work' every 500 milliseconds. Dependencies: zeromq.js must be installed. Key parameters: connection string for bind (port 3000). Expects no input, repeatedly pushes messages to connected Pull sockets.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Push()\n\n  await sock.bind(\"tcp://127.0.0.1:3000\")\n  console.log(\"Producer bound to port 3000\")\n\n  while (true) {\n    await sock.send(\"some work\")\n    await new Promise(resolve => {\n      setTimeout(resolve, 500)\n    })\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages with ZeroMQ Publisher Socket - JavaScript\nDESCRIPTION: Creates a ZeroMQ Publisher socket that broadcasts multipart messages to any connected subscribers. It binds to a TCP port and continuously sends a two-part message (topic and content) every 500ms. Dependencies: zeromq.js. Expects no input, and is intended for use with Subscriber sockets interested in the given topic.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_3\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Publisher()\n\n  await sock.bind(\"tcp://127.0.0.1:3000\")\n  console.log(\"Publisher bound to port 3000\")\n\n  while (true) {\n    console.log(\"sending a multipart message envelope\")\n    await sock.send([\"kitty cats\", \"meow!\"])\n    await new Promise(resolve => {\n      setTimeout(resolve, 500)\n    })\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Setting ZMQ_SUBSCRIBE Option in C\nDESCRIPTION: This C code snippet demonstrates how to configure a ZeroMQ subscriber socket (`sub`) to receive messages associated with a specific topic ('status'). It uses the `zmq_setsockopt` function with the `ZMQ_SUBSCRIBE` option, providing the topic string and its length. This requires the `libzmq` library and an initialized subscriber socket.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\n//  Subscribe to the 'status' topic\nzmq_setsockopt (sub, ZMQ_SUBSCRIBE, \"status\", strlen (\"status\"));\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Topic in ZeroMQ using JavaScript (zeromqjs)\nDESCRIPTION: This snippet demonstrates how to subscribe a ZeroMQ subscriber socket (`sub`) to messages prefixed with the topic 'status'. The `subscribe` method filters incoming messages, only delivering those that start with the specified string. This requires an initialized and connected `zeromqjs` subscriber socket instance named `sub`.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n//  Subscribe to the 'status'\nsub.subscribe('status');\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Topic Using JeroMQ in Java\nDESCRIPTION: This code demonstrates how to subscribe to the 'status' topic using the subscribe method of a ZeroMQ socket in Java with the JeroMQ library. The 'sub.subscribe(\"status\")' call ensures that only messages tagged with the 'status' topic are received by this subscriber. Requires an instance of a SUB (subscriber) socket created via JeroMQ, and assumes the socket has been successfully connected to a publisher endpoint. The input parameter is the topic string, and only messages with matching topics will be delivered. This example assumes a string-based topic and does not handle message receipt or error cases.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: java\nCODE:\n```\n//  Subscribe to the 'status'\nsub.subscribe(\"status\");\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish-Subscribe Publisher with NetMQ in C#\nDESCRIPTION: This example demonstrates a ZeroMQ publisher using NetMQ in C#. The publisher binds to a TCP endpoint and, in an infinite loop, sends incrementing integer values on topic 'A' every second. Dependency: NetMQ; ensure thread safety and graceful shutdown in production. Inputs: none; outputs: topics and messages broadcast to any subscribers.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/csharp.md#_snippet_3\n\nLANGUAGE: csharp\nCODE:\n```\nusing (var publisher = new PublisherSocket())\\n{\\n    publisher.Bind(\\\"tcp://*:5556\\\");\\n\\n    int i = 0;\\n\\n    while (true)\\n    {\\n        publisher\\n            .SendMoreFrame(\\\"A\\\") // Topic\\n            .SendFrame(i.ToString()); // Message\\n\\n        i++;\\n        Thread.Sleep(1000);\\n    }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Pulling Messages with ZeroMQ Pull Socket - JavaScript\nDESCRIPTION: Implements a ZeroMQ Pull socket in Node.js to act as a worker. The code connects to a TCP endpoint, then asynchronously iterates over incoming messages, printing each after converting it to a string. Dependencies: zeromq.js. The endpoint must already be bound by a Push socket (e.g., the producer). Outputs each received message to the console.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_2\n\nLANGUAGE: js\nCODE:\n```\nconst zmq = require(\"zeromq\")\n\nasync function run() {\n  const sock = new zmq.Pull()\n\n  sock.connect(\"tcp://127.0.0.1:3000\")\n  console.log(\"Worker connected to port 3000\")\n\n  for await (const [msg] of sock) {\n    console.log(\"work: %s\", msg.toString())\n  }\n}\n\nrun()\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Code Block Bracing Style (Control Statements)\nDESCRIPTION: Illustrates the bracing style for C++ control statements like 'if', 'else', 'for', and 'while'. The opening brace is placed on the same line as the control statement.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_5\n\nLANGUAGE: cpp\nCODE:\n```\nif (sum > 1000) {\n    //  Code goes here.\n} else {\n    //  More code.\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Multipart Messages in Perl (ZMQ::FFI)\nDESCRIPTION: Shows how to send and receive multipart messages using ZMQ::FFI in Perl with DEALER/ROUTER sockets. A DEALER socket, configured with an identity 'dealer', sends an array of strings ('ABC', 'DEF', 'GHI') as a single multipart message using `send_multipart`. The ROUTER socket receives the multipart message using `recv_multipart`, automatically prepending the sender's identity to the received parts. Requires the `ZMQ::FFI` module and Perl 5.012+.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/perl.md#_snippet_3\n\nLANGUAGE: perl\nCODE:\n```\nuse 5.012;\nuse ZMQ::FFI qw(ZMQ_DEALER ZMQ_ROUTER);\n\nmy $endpoint = \"ipc://zmq-ffi-$$\";\nmy $ctx      = ZMQ::FFI->new();\n\nmy $d = $ctx->socket(ZMQ_DEALER);\n$d->set_identity('dealer');\n\nmy $r = $ctx->socket(ZMQ_ROUTER);\n\n$d->connect($endpoint);\n$r->bind($endpoint);\n\n$d->send_multipart([qw(ABC DEF GHI)]);\n\nsay join ' ', $r->recv_multipart;\n# dealer ABC DEF GHI\n```\n\n----------------------------------------\n\nTITLE: Implementing a ZeroMQ DISH Subscriber in C++\nDESCRIPTION: This C++ snippet demonstrates the setup and usage of a ZeroMQ DISH socket using the cppzmq library. It initializes a ZeroMQ context with one I/O thread, creates a DISH socket, connects it to a TCP endpoint presumed to be hosted by a RADIO socket (localhost:5555), joins two specific message groups ('group1' and 'group2'), and then enters an infinite loop. Within the loop, it waits to receive messages belonging to the joined groups and prints their content to the standard output. Key dependencies are the `zmq.hpp` header from the cppzmq library and the underlying ZeroMQ library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/cppzmq/raddsh_dish_example.md#_snippet_0\n\nLANGUAGE: cpp\nCODE:\n```\n#include <cstdlib>\n#include <iostream>\n#include <zmq.hpp>\n\nint main() {\n  // Initialize the zmq context with a single IO thread\n  zmq::context_t context{1};\n\n  // Construct a Dish socket and connect to interface\n  zmq::socket_t dish{context, zmq::socket_type::dish};\n  dish.connect(\"tcp://localhost:5555\");\n\n  // Join message groups\n  dish.join(\"group1\");\n  dish.join(\"group2\");\n\n  // Receive messages forever\n  while (true) {\n    std::cout << \"Waiting to receive...\\n\";\n    zmq::message_t msg;\n    dish.recv(msg, zmq::recv_flags::none);\n    std::cout << \"Received a message: \" << msg.to_string() << \"\\n\";\n  }\n\n  return EXIT_SUCCESS;\n}\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple String Frames at Once with zstr_sendx in CZMQ (C)\nDESCRIPTION: Shows how to send multiple string frames as a single multipart message using the variadic function `zstr_sendx`. This function takes the socket and a variable number of string arguments, terminated by a `NULL` pointer. It sends all provided strings as separate frames in one atomic operation. Requires an initialized CZMQ socket (`socket`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv_multi.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nzstr_sendx (socket, \"HELLO\", \"beautiful\", \"WORLD!\", NULL);\n```\n\n----------------------------------------\n\nTITLE: Defining C++ Code Block Bracing Style (Functions/Structs)\nDESCRIPTION: Shows the required bracing style for C++ functions, structures, classes, enums, and namespaces in libzmq. Both the opening and closing braces are placed on separate lines, indented consistently.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_4\n\nLANGUAGE: cpp\nCODE:\n```\nvoid fx ()\n{\n    //  Code goes here.\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic ZeroMQ Communication in Ruby\nDESCRIPTION: This Ruby code snippet demonstrates a basic ZeroMQ setup. It initializes a ZMQ context, creates an UPSTREAM socket bound to a local address, and a DOWNSTREAM socket connecting to the same address. It sends two messages ('Hello World!' and 'QUIT') from the outbound socket and then enters a loop receiving messages on the inbound socket, printing them until 'QUIT' is received. Requires the 'zmq' gem.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/ruby.md#_snippet_3\n\nLANGUAGE: ruby\nCODE:\n```\nrequire \"zmq\"\n\ncontext = ZMQ::Context.new(1)\n\nputs \"Opening connection for READ\"\ninbound = context.socket(ZMQ::UPSTREAM)\ninbound.bind(\"tcp://127.0.0.1:9000\")\n\noutbound = context.socket(ZMQ::DOWNSTREAM)\noutbound.connect(\"tcp://127.0.0.1:9000\")\np outbound.send(\"Hello World!\")\np outbound.send(\"QUIT\")\n\nloop do\n  data = inbound.recv\n  p data\n  break if data == \"QUIT\"\nend\n```\n\n----------------------------------------\n\nTITLE: Connecting and Receiving with zzmq PAIR Socket in Zig\nDESCRIPTION: This Zig code snippet shows the client side of a PAIR socket interaction using the `zzmq` library. It initializes a PAIR socket, dynamically constructs the endpoint string using the port obtained from the server (assumed to be in the `port` variable), connects to that endpoint, receives a message frame, extracts the data, and ensures resources (`socket`, `endpoint`, `frame`) are deinitialized. Requires `allocator` and `port` to be defined.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/zig.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\nconst zzmq = @import(\"zzmq\");\n\nvar socket = try zzmq.ZSocket.init(allocator, zzmq.ZSocketType.Pair);\ndefer socket.deinit();\n\nconst endpoint = try std.fmt.allocPrint(allocator, \"tcp://127.0.0.1:{}\", .{port});\ndefer allocator.free(endpoint);\n\ntry socket.connect(endpoint);\n\n// receive a message\nvar frame = try socket.receive();\ndefer frame.deinit();\n\nconst data = try frame.data();\n```\n\n----------------------------------------\n\nTITLE: Sending Formatted String Messages over ZeroMQ using CZMQ in C\nDESCRIPTION: Shows how to send a formatted C string over a ZeroMQ socket by using a printf-style format and variable arguments. Requires inclusion and linkage with the czmq library and a valid initialized socket. Accepts a format string with arguments; the message is composed and then sent as one frame. Useful for constructing messages dynamically before transmission over ZeroMQ.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv.md#_snippet_1\n\nLANGUAGE: c\nCODE:\n```\nzstr_sendf (socket, \"%s-%d\", \"HELLO\", 1);\n```\n\n----------------------------------------\n\nTITLE: Installing rbzmq Gem using Bash\nDESCRIPTION: This command installs the ZeroMQ Ruby gem (`zmq`) using the `gem` package manager. It assumes that the underlying `libzmq` library is already installed and discoverable by the system.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/ruby.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq\n```\n\n----------------------------------------\n\nTITLE: Initializing and Sending with zzmq PAIR Socket in Zig\nDESCRIPTION: This snippet demonstrates initializing a ZeroMQ PAIR socket using the `zzmq` library in Zig. It binds the socket to a dynamically assigned port on the local interface (`tcp://127.0.0.1:!`), prepares a message frame, sends it over the socket, and ensures resources (`socket`, `frame`) are deinitialized using `defer`. Assumes `allocator` and `data` are defined elsewhere.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/zig.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\nconst zzmq = @import(\"zzmq\");\n\nvar socket = try zzmq.ZSocket.init(allocator, zzmq.ZSocketType.Pair);\ndefer socket.deinit();\n\nconst port = try socket.bind(\"tcp://127.0.0.1:!\");\n\n// send a message\nvar frame = try zzmq.ZFrame.init(data);\ndefer frame.deinit();\n\ntry socket.send(&frame, .{});\n```\n\n----------------------------------------\n\nTITLE: Sending Multiple String Frames Individually with zstr_sendm in CZMQ (C)\nDESCRIPTION: Demonstrates sending multiple string frames individually using `zstr_sendm`. The `zstr_sendm` function signals that more frames will follow, deferring the actual network transmission until `zstr_send` (or another function without the 'm' suffix) is called for the final frame. This allows building a multi-part message incrementally. Requires an initialized CZMQ socket (`socket`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv_multi.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nzstr_sendm (socket, \"HELLO\");\nzstr_sendm (socket, \"beautiful\");\nzstr_send (socket, \"WORLD!\");\n```\n\n----------------------------------------\n\nTITLE: Installing ZMQ::FFI Perl Module via cpanm\nDESCRIPTION: This shell command utilizes the 'cpanm' utility (a popular CPAN client) to install the ZMQ::FFI Perl module. The '-v' flag enables verbose output, showing detailed steps of the installation process. ZMQ::FFI provides Foreign Function Interface (FFI) based ZeroMQ bindings for Perl. Prerequisites include having 'cpanm', Perl, and the ZeroMQ library installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/perl/perlzmq/download.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncpanm -v ZMQ::FFI\n```\n\n----------------------------------------\n\nTITLE: Installing goczmq via go get for CZMQ master - Shell\nDESCRIPTION: Installs the latest version of the goczmq Go library using the 'go get' tool. This requires Go to be installed and available in the system's PATH. The primary dependency is the CZMQ C library, as well as its dependencies (libsodium, libzmq). Running this command fetches and installs the current master branch from GitHub. No inputs are needed beyond a configured Go environment, and it outputs the installed library in the $GOPATH. Limitations: must have network access and proper dependencies pre-installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/goczmq/download.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/zeromq/goczmq\n```\n\n----------------------------------------\n\nTITLE: Managing Multiple Sockets Using Poller and Observables (FsNetMQ, F#)\nDESCRIPTION: Illustrates the use of FsNetMQ poller in F# to monitor multiple sockets concurrently using IObservable patterns. This example covers how to subscribe to new messages from both dealer and subscriber sockets, merge their observables, and process messages using functional reactive programming. Dependencies include FsNetMQ and a working understanding of F# observable streams. Sockets must be connected and subscribed as appropriate before use.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/fsharp.md#_snippet_1\n\nLANGUAGE: fsharp\nCODE:\n```\nuse poller = Poller.create ()\nuse dealer = Socket.dealer ()\nuse subscriber = Socker.sub ()\n\n// Connecting and subscribing...\n\nlet dealerObservable =\n  Poller.addSocket poller dealer\n  |> Observable.map Frame.recv\n\nlet subObservable =\n  Poller.addSocket poller subscriber\n  |> Observable.map Frame.recv\n\nuse observer =\n  Observable.merge dealerObservable subObservable\n  |> Observable.subscribe (fun msg -> printfn \"%A\" msg)\n\nPoller.run poller\n```\n\n----------------------------------------\n\nTITLE: Sending and Receiving ZeroMQ Messages in C\nDESCRIPTION: Shows the use of libzmq functions to send and receive messages over ZeroMQ sockets in C. Requires a configured ZeroMQ context and socket, as well as properly initialized zmq_msg_t messages. The functions take socket pointers and message pointers as parameters; outputs are the number of bytes sent/received or -1 on error. Proper message lifecycle management is needed for both sending and receiving sides.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_1\n\nLANGUAGE: C\nCODE:\n```\n// Sending a message\nzmq_msg_send(&msg, socket, 0);\n\n// Receiving a message\nzmq_msg_t recv_msg;\nzmq_msg_init(&recv_msg);\nzmq_msg_recv(&recv_msg, socket, 0);\n```\n\n----------------------------------------\n\nTITLE: Installing goczmq for CZMQ 4.2 via go get - Shell\nDESCRIPTION: Fetches and installs the version 4 series of goczmq with compatibility for CZMQ 4.2 using the 'go get' command. The command is designed for use with Go and expects that CZMQ 4.2 is (or will soon be) released and installed; it fetches from the v4 branch using the gopkg.in service. Key requirements are the relevant CZMQ C library version and Go toolchain. The result is the v4 implementation installed in the Go workspace. Limitations: as noted, CZMQ 4.2 may not yet be available.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/goczmq/download.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngo get gopkg.in/zeromq/goczmq.v4\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ.js with Prebuilt Binaries using npm (Shell)\nDESCRIPTION: This command installs the specified version (6.0.0-beta.17) of the `zeromq` npm package. It prioritizes using prebuilt binaries if available for the target platform (Node.js 10.2+ or Electron 3+). If prebuilt binaries are unavailable, it will attempt to build from source.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/download.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install zeromq@6.0.0-beta.17\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ.js with DRAFT Sockets Enabled using npm (Shell)\nDESCRIPTION: This command installs the `zeromq` npm package by compiling it from source with support for DRAFT API sockets enabled, using the `--zmq-draft` flag. This is necessary for using experimental or draft ZeroMQ features. Requires the standard build tools.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/download.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nnpm install zeromq@6.0.0-beta.17 --zmq-draft\n```\n\n----------------------------------------\n\nTITLE: Installing dartzmq via flutter pub – Bash\nDESCRIPTION: This snippet demonstrates how to add the dartzmq package to a Flutter project using the flutter pub add command. The command fetches the latest version of dartzmq and updates the pubspec.yaml accordingly. It requires Flutter and Dart SDK to be installed, and is typically executed in the root directory of a Flutter project. No input arguments are necessary, and running the command integrates dartzmq as a dependency; no output is produced unless an error occurs.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/dart.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nflutter pub add dartzmq\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Mode via YAML Front Matter\nDESCRIPTION: This YAML snippet, enclosed in triple-dashed lines indicating front matter, sets the 'headless' property to 'true'. This configuration is commonly used by static site generators (like Hugo, Jekyll) or content management systems to control the rendering of a specific page, often omitting standard layout elements like headers and footers.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/azmq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Configuration in YAML\nDESCRIPTION: This YAML snippet, typically used as front matter in a content file, sets the 'headless' configuration parameter to 'true'. This instructs a processing system (like a static site generator) that the page should be rendered without standard surrounding elements (e.g., header, footer) or might be treated purely as data.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nheadless: true\n```\n\n----------------------------------------\n\nTITLE: Implementing Actor Pattern with FsNetMQ in F#\nDESCRIPTION: Shows how to use an Actor (thread with an attached socket) with FsNetMQ and Poller in F#. The actor pattern allows sending messages to the actor, supporting cancellation through an end message, and using a poller for concurrent socket management within the actor. Dependencies are FsNetMQ and compatible .NET runtime. Functionality assumes sockets or other poller registrations are added in place of placeholder comments before signaling readiness.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/fsharp.md#_snippet_2\n\nLANGUAGE: fsharp\nCODE:\n```\n// Actor is disposable, so whenever you call dispose\n// on the actor the end message will be sent and the thread will exit\nlet actor =\n  Actor.create (fun shim ->\n    use poller = Poller.create ()\n\n    // Registering for the end message which will cancel the actor\n    use emObserver = Poller.registerEndMessage poller shim\n\n    // Creating sockets and adding them to the poller\n    ...\n\n    // Signalling that the actor is ready, this will let the Actor.create function to return\n    Actor.signal shim\n\n    Poller.run poller\n```\n\n----------------------------------------\n\nTITLE: Sending String Messages over ZeroMQ using CZMQ in C\nDESCRIPTION: Demonstrates sending a C string as a single-frame message over a ZeroMQ socket using the czmq library. Requires that the czmq library is installed and linked to your project. The socket parameter must be a valid ZeroMQ socket. The function encodes the given C string and transmits it as one message frame; the length of the string determines the frame length. Returns 0 on success or -1 on failure.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv.md#_snippet_0\n\nLANGUAGE: c\nCODE:\n```\nzstr_send (socket, \"HELLO\");\n```\n\n----------------------------------------\n\nTITLE: Receiving a String Message with NetMQ in C#\nDESCRIPTION: This snippet shows how to receive a string message from a socket using the ReceiveFrameString function provided by NetMQ. It assumes an active NetMQ socket and a sender transmitting string data. The returned value, str, contains the message received from the remote peer as a C# string.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/csharp/netmq/messages_strings_send_recv.md#_snippet_1\n\nLANGUAGE: csharp\nCODE:\n```\nstring str = socket.ReceiveFrameString();\n```\n\n----------------------------------------\n\nTITLE: Implementing PUSH/PULL Pattern with zimq in Zig\nDESCRIPTION: This complete Zig example demonstrates the PUSH/PULL messaging pattern using the `zimq` library. It initializes a ZeroMQ context, creates PULL and PUSH sockets, binds the PULL socket and connects the PUSH socket using an in-process transport (`inproc://#1`), sends a constant string message from PUSH to PULL, receives the message into a buffer on the PULL side, and prints the received message content. It uses `defer` for resource cleanup.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/zig.md#_snippet_4\n\nLANGUAGE: zig\nCODE:\n```\nconst std = @import(\"std\");\nconst zimq = @import(\"zimq\");\n\npub fn main() !void {\n    const context: *zimq.Context = try .init();\n    defer context.deinit();\n\n    const pull: *zimq.Socket = try .init(context, .pull);\n    defer pull.deinit();\n\n    const push: *zimq.Socket = try .init(context, .push);\n    defer push.deinit();\n\n    try pull.bind(\"inproc://#1\");\n    try push.connect(\"inproc://#1\");\n\n    const message = \"hello\";\n    try push.sendConst(message, message.len, .{});\n\n    var buffer: zimq.Message = .empty();\n    _ = try pull.recvMsg(&buffer, .{});\n\n    std.debug.print(\"{s}\\n\", .{buffer.slice().?});\n}\n```\n\n----------------------------------------\n\nTITLE: Installing dartzmq Package using Flutter CLI - Bash\nDESCRIPTION: This Bash code snippet shows the command to add the dartzmq package to a Flutter project. It requires that libzmq is installed on the system as a prerequisite. The command updates the project's pubspec.yaml to include dartzmq as a dependency, enabling usage of ZeroMQ bindings in Dart. This command should be run from the root directory of a Flutter application. No arguments are required except the package name.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/dart/dartzmq/download.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nflutter pub add dartzmq\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Mode in YAML Front Matter\nDESCRIPTION: This YAML snippet represents front matter, commonly used in static site generators. The 'headless: true' directive instructs the generator (like Hugo) not to render this specific content file as an individual page on the website. Instead, its data and content become available for use in other templates, such as lists or summaries.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Property in YAML Front Matter\nDESCRIPTION: This YAML snippet defines front matter for a content file. The 'headless: true' property typically instructs a static site generator (like Hugo) that this content file should not be rendered as a regular page and might not appear in lists. It's often used for content bundles or resources referenced by other pages.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/haskell/zeromq4-haskell/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Integrating zimq Dependency in build.zig\nDESCRIPTION: This Zig build script snippet shows how to configure the fetched `zimq` dependency within a `build.zig` file. It creates a dependency object `zimq` using `b.dependency` and then adds the `zimq` module provided by the dependency to the main executable or library (`exe` in this case) using `addImport`. This makes `import(\"zimq\")` usable in the project's source code.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/zig.md#_snippet_3\n\nLANGUAGE: zig\nCODE:\n```\nconst zimq = b.dependency(\"zimq\", .{\n    .target = target,\n    .optimize = optimize,\n});\n// Replace `exe` with your actual library or executable\nexe.root_module.addImport(\"zimq\", zimq.module(\"zimq\"));\n```\n\n----------------------------------------\n\nTITLE: Adding zeromq Dependency via Cargo.toml - Rust - TOML\nDESCRIPTION: This TOML snippet enables the 'zeromq' crate as a dependency in a Rust project by specifying it in the Cargo.toml under [dependencies] with version '0.3.5'. This allows incorporating the native Rust implementation of ZeroMQ for messaging functionality without relying on C bindings.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/rust.md#_snippet_3\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nzeromq = \"0.3.5\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ on Windows using Batch (vcpkg)\nDESCRIPTION: Installs CZMQ as a 32-bit shared library using the `vcpkg` package manager on Windows. Assumes `vcpkg.exe` is in the current directory or path. Requires `vcpkg` to be correctly set up.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_3\n\nLANGUAGE: batch\nCODE:\n```\n.\\vcpkg.exe install czmq\n```\n\n----------------------------------------\n\nTITLE: Declaring chumak Dependency in rebar.config (Erlang)\nDESCRIPTION: This Erlang configuration snippet demonstrates how to add the `chumak` ZeroMQ library as a project dependency using rebar3. It should be placed within the `deps` list in the `rebar.config` file. The placeholder \"X.Y.Z\" must be replaced with a specific version number obtained from the chumak releases on GitHub or hex.pm. This configuration instructs rebar3 to fetch and manage the specified version of the `chumak` library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/erlang/chumak/download.md#_snippet_0\n\nLANGUAGE: erlang\nCODE:\n```\n{deps,[\n\t{chumak, \"X.Y.Z\"}\n]}.\n```\n\n----------------------------------------\n\nTITLE: Generating Ant Build File from Maven pom.xml Using Bash\nDESCRIPTION: This snippet provides the bash command necessary to generate an Ant build file from an existing Maven pom.xml using the Maven Ant plugin. This requires that both Maven and Ant are installed and available in the system's PATH. The command 'mvn ant:ant' processes pom.xml and produces build.xml, allowing Java projects to be built with Ant using the Maven-defined dependencies.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/download.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nmvn ant:ant\n```\n\n----------------------------------------\n\nTITLE: Initializing Router/Dealer Sockets with FsNetMQ in F#\nDESCRIPTION: Demonstrates setting up a ROUTER/DEALER socket pattern for asynchronous messaging using FsNetMQ in F#. The snippet shows how to create, bind, and connect sockets, and how to send and receive framed binary messages. Requires installing the FsNetMQ package and familiarity with the ZeroMQ socket model. Key parameters include the bind/connect URIs and the content of the frame. The code assumes prior initialization of the Socket module.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/fsharp.md#_snippet_0\n\nLANGUAGE: fsharp\nCODE:\n```\nuse router = Socket.router ()\nrouter.bind socket \"tcp://*:6566\"\n\nuse dealer = Socket.dealer ()\nSocket.connect socket \"tcp://127.0.0.1:6566\"\n\nFrame.send dealer \"Hello\"B\n\nlet frame,more = Frame.recv router\n```\n\n----------------------------------------\n\nTITLE: Cloning and Installing libsodium with Bash\nDESCRIPTION: This Bash snippet demonstrates how to clone the libsodium source code, generate build scripts, configure the build, run tests, and install it system-wide. It requires git, automake/autoconf, and standard build tools. No parameters are needed, but sudo privileges are required for installation. The process results in libsodium being available system-wide, necessary for ZeroMQ security features.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/zmqpp/download.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Build, check, and install libsodium\\ngit clone git://github.com/jedisct1/libsodium.git\\ncd libsodium\\n./autogen.sh\\n./configure && make check\\nsudo make install\\nsudo ldconfig\\ncd ../\n```\n\n----------------------------------------\n\nTITLE: Creating a ZeroMQ REQ Client in Haskell\nDESCRIPTION: This Haskell snippet implements a ZeroMQ client using the REQ (Request) socket type via the `zeromq4-haskell` library. It connects to a server at 'tcp://localhost:5555', sends the message 'Hello' ten times using `send`, and waits for a reply using `receive` after each request, printing status updates. The `OverloadedStrings` language extension is enabled for convenient use of `ByteString`. Key dependencies include `System.ZMQ4.Monadic` for ZeroMQ operations within a monadic context and `Data.ByteString.Char8` for converting between `String` and `ByteString`. It requires a corresponding ZeroMQ server (REP socket) running on the specified address.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/haskell/zeromq4-haskell/hello_world_client.md#_snippet_0\n\nLANGUAGE: haskell\nCODE:\n```\n-- This lets us conviniently use efficient ByteString to send and recieve messages\n{-# LANGUAGE OverloadedStrings #-}\n\n{- \n   Hello World client in Haskell\n   Connects REQ socket to tcp://localhost:5555\n   Sends \"Hello\" to server, expects \"World\" back\n-}\n\nimport System.ZMQ4.Monadic (runZMQ, socket, connect, send, receive, Socket, Req(..))\nimport Control.Monad (forM_)\nimport Control.Monad.IO.Class (liftIO)\nimport Data.ByteString.Char8 (pack, unpack)\n\nmain :: IO ()\nmain = runZMQ $ do\n    --  Socket to talk to server\n    reqSocket <- socket Req\n    connect reqSocket \"tcp://localhost:5555\"\n\n    --  Do 10 requests, waiting each time for a response\n    forM_ [1..10] $ \\i -> do\n        liftIO $ putStrLn (\"Sending request \" ++ show i ++ \"...\")\n        send reqSocket [] (pack \"Hello\")\n\n        --  Get the reply\n        message <- receive reqSocket\n        liftIO $ putStrLn (\"Received reply \" ++ show i ++ \" [\" ++ unpack message ++ \"]\")\n\n```\n\n----------------------------------------\n\nTITLE: Accessing ZeroMQ Message Content and Metadata in C\nDESCRIPTION: Illustrates retrieving information and data from a ZeroMQ message in C using libzmq functions. Functions include fetching the raw data buffer, getting the size of the message, and checking if more message parts are available (for multipart messages). Each function requires a valid zmq_msg_t pointer and returns either a pointer, integer size, or boolean indicating more parts.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_3\n\nLANGUAGE: C\nCODE:\n```\nvoid *data = zmq_msg_data(&msg);\nsize_t size = zmq_msg_size(&msg);\nint more = zmq_msg_more(&msg);\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish-Subscribe Pattern in Perl (ZMQ::FFI)\nDESCRIPTION: Illustrates the publish-subscribe (PUB/SUB) pattern using ZMQ::FFI in Perl. It shows how a SUB socket can subscribe to all topics ('') or specific topics ('topic1', 'topic2') and receive messages sent by a PUB socket. Includes handling for slow subscribers using `usleep` to wait before checking for messages. Requires `ZMQ::FFI`, `Time::HiRes` modules, and Perl 5.012+.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/perl.md#_snippet_2\n\nLANGUAGE: perl\nCODE:\n```\nuse 5.012;\nuse ZMQ::FFI qw(ZMQ_PUB ZMQ_SUB);\nuse Time::HiRes q(usleep);\n\nmy $endpoint = \"ipc://zmq-ffi-$$\";\nmy $ctx      = ZMQ::FFI->new();\n\nmy $s = $ctx->socket(ZMQ_SUB);\nmy $p = $ctx->socket(ZMQ_PUB);\n\n$s->connect($endpoint);\n$p->bind($endpoint);\n\n# all topics\n{\n    $s->subscribe('');\n\n    until ($s->has_pollin) {\n        # compensate for slow subscriber\n        usleep 100_000;\n        $p->send('ohhai');\n    }\n\n    say $s->recv();\n    # ohhai\n\n    $s->unsubscribe('');\n}\n\n# specific topics\n{\n    $s->subscribe('topic1');\n    $s->subscribe('topic2');\n\n    until ($s->has_pollin) {\n        usleep 100_000;\n        $p->send('topic1 ohhai');\n        $p->send('topic2 ohhai');\n    }\n\n    while ($s->has_pollin) {\n        say join ' ', $s->recv();\n        # topic1 ohhai\n        # topic2 ohhai\n    }\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Request-Reply Pattern in Perl (ZMQ::FFI)\nDESCRIPTION: Demonstrates a basic request-reply (REQ/REP) messaging pattern using ZMQ::FFI in Perl. A REQ socket connects and sends a message ('ohhai'), while a REP socket binds to the same IPC endpoint and receives the message. Requires the `ZMQ::FFI` module and Perl 5.012+.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/perl.md#_snippet_1\n\nLANGUAGE: perl\nCODE:\n```\nuse 5.012;\nuse ZMQ::FFI qw(ZMQ_REQ ZMQ_REP);\n\nmy $endpoint = \"ipc://zmq-ffi-$$\";\nmy $ctx      = ZMQ::FFI->new();\n\nmy $s1 = $ctx->socket(ZMQ_REQ);\n$s1->connect($endpoint);\n\nmy $s2 = $ctx->socket(ZMQ_REP);\n$s2->bind($endpoint);\n\n$s1->send('ohhai');\n\nsay $s2->recv();\n# ohhai\n```\n\n----------------------------------------\n\nTITLE: Implementing Non-blocking Push-Pull with AnyEvent in Perl (ZMQ::FFI)\nDESCRIPTION: Demonstrates a non-blocking push-pull (PUSH/PULL) pattern using ZMQ::FFI integrated with the AnyEvent and EV event loops in Perl. A PUSH socket connects and sends messages ('foo', 'bar', 'baz') periodically using an AE::timer. A PULL socket binds and uses an AE::io watcher on its file descriptor (`get_fd()`) to react to incoming messages, receiving them asynchronously with `recv()` when `has_pollin` is true. The EV event loop is run until all three messages are received. Requires `ZMQ::FFI`, `AnyEvent`, `EV` modules, and Perl 5.012+.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/perl.md#_snippet_4\n\nLANGUAGE: perl\nCODE:\n```\nuse 5.012;\nuse ZMQ::FFI qw(ZMQ_PUSH ZMQ_PULL);\nuse AnyEvent;\nuse EV;\n\nmy $endpoint = \"ipc://zmq-ffi-$$\";\nmy $ctx      = ZMQ::FFI->new();\nmy @messages = qw(foo bar baz);\n\n\nmy $pull = $ctx->socket(ZMQ_PULL);\n$pull->bind($endpoint);\n\nmy $fd = $pull->get_fd();\n\nmy $recv = 0;\nmy $w = AE::io $fd, 0, sub {\n    while ( $pull->has_pollin ) {\n        say $pull->recv();\n        # foo, bar, baz\n\n        $recv++;\n        if ($recv == 3) {\n            EV::break();\n        }\n    }\n};\n\n\nmy $push = $ctx->socket(ZMQ_PUSH);\n$push->connect($endpoint);\n\nmy $sent = 0;\nmy $t;\n$t = AE::timer 0, .1, sub {\n    $push->send($messages[$sent]);\n\n    $sent++;\n    if ($sent == 3) {\n        undef $t;\n    }\n};\n\nEV::run();\n```\n\n----------------------------------------\n\nTITLE: Formatting Git Commit Messages\nDESCRIPTION: Example demonstrating the required format for Git commit messages. It includes a short summary line (max 70 chars) starting with 'Problem: ' and a detailed description starting with 'Solution: ', formatted with line breaks under 80 characters.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\nProblem: Windows build script requires edit of VS version\n\nSolution: Use CMD.EXE environment variable to extract\nDevStudio version number and build using it.\n```\n\n----------------------------------------\n\nTITLE: Copying and Moving ZeroMQ Messages in C\nDESCRIPTION: Details how to duplicate or transfer ownership of message contents with zmq_msg_copy and zmq_msg_move in C using libzmq. Both functions operate on pairs of zmq_msg_t pointers and return a status indicating success or failure. Copying keeps both the source and destination messages valid; moving invalidates the source message after the operation.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_5\n\nLANGUAGE: C\nCODE:\n```\nzmq_msg_t msg_copy, msg_move;\nzmq_msg_init(&msg_copy);\nzmq_msg_init(&msg_move);\nzmq_msg_copy(&msg_copy, &msg);\nzmq_msg_move(&msg_move, &msg);\n```\n\n----------------------------------------\n\nTITLE: Receiving and Processing a Multi-Frame String Message with zmsg in CZMQ (C)\nDESCRIPTION: Shows how to receive a multi-frame message as a `zmsg_t` object using `zmsg_recv()`. Individual string frames are then extracted (popped) from the received message object using `zmsg_popstr()`. This removes the frame from the `zmsg_t` object and returns a pointer to the newly allocated string data. The caller owns the popped strings and is responsible for freeing their memory, as well as destroying the potentially remaining `zmsg_t` object if not all frames are popped. Requires an initialized CZMQ socket (`socket`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv_multi.md#_snippet_4\n\nLANGUAGE: c\nCODE:\n```\nzmsg_t *strings = zmsg_recv (socket);\nchar *hello = zmsg_popstr (strings);\nchar *beautiful = zmsg_popstr (strings);\nchar *world = zmsg_popstr (strings);\n```\n\n----------------------------------------\n\nTITLE: Illustrating C++ Commenting Style\nDESCRIPTION: Demonstrates the preferred C++ commenting style for libzmq. It shows the use of C++ line comments (//) preceded by two spaces, starting with a capital letter, and ending with a period. It also illustrates breaking code into small, commented pieces followed by a blank line.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_1\n\nLANGUAGE: cpp\nCODE:\n```\n//  Compute the factorial.\nint factorial = 1;\nfor (int i = 2; i != 11; i++)\n    factorial *= i;\n\n//  Present the result to the user.\ncout << \"Factorial of 10 is \" << factorial << \".\" << endl;\n```\n\n----------------------------------------\n\nTITLE: Formatting Single-Statement C++ Control Blocks\nDESCRIPTION: Demonstrates that even if a control block ('if', 'while', 'for', 'else') contains only a single statement, that statement should be placed on a separate line following the control statement.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_6\n\nLANGUAGE: cpp\nCODE:\n```\nif (end)\n    exit (1);\n```\n\n----------------------------------------\n\nTITLE: Setting CGO Build Flags on Windows (PowerShell)\nDESCRIPTION: These PowerShell commands demonstrate how to set the `CGO_CFLAGS` and `CGO_LDFLAGS` environment variables on Windows. These variables tell the C compiler where to find the ZeroMQ header files (`-I`) and library files (`-L`, `-l`) respectively, which is necessary for building the `zmq4` Go package. The example uses paths typical for a `vcpkg` installation and notes the required DLL for deployment.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/download.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$env:CGO_CFLAGS='-ID:/dev/vcpkg/installed/x64-windows/include'\n$env:CGO_LDFLAGS='-LD:/dev/vcpkg/installed/x64-windows/lib -l:libzmq-mt-4_3_4.lib'\n```\n\n----------------------------------------\n\nTITLE: Illustrating Disallowed Internal Calls to Public C++ Interfaces\nDESCRIPTION: Provides an example of a forbidden practice in libzmq: calling a public interface function (`f`) from another public interface function (`fsucc`) within the same component's implementation. This is disallowed to maintain public invariants, simplify code changes, prevent confusing profiling results, and avoid potential deadlocks (e.g., with mutexes).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_15\n\nLANGUAGE: cpp\nCODE:\n```\nint f(int x) { return g (x); }\nint fsucc(int x) { return f (x) + 1; }\n```\n\n----------------------------------------\n\nTITLE: Receiving Multiple String Frames Directly with zstr_recvx in CZMQ (C)\nDESCRIPTION: Demonstrates receiving multiple string frames from a socket directly into `char*` variables using the variadic function `zstr_recvx`. It takes the socket and a variable number of pointers to `char*`, terminated by a `NULL` pointer. The function allocates memory for each received string frame and assigns the pointers. The caller is responsible for freeing the allocated memory for each string (`hello`, `beautiful`, `world`). Requires an initialized CZMQ socket (`socket`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv_multi.md#_snippet_3\n\nLANGUAGE: c\nCODE:\n```\nchar *hello, beautiful, world;\nzstr_recvx (socket, &hello, &beautiful, &world, NULL);\n```\n\n----------------------------------------\n\nTITLE: Sending a Message on the 'status' Topic in <language name>\nDESCRIPTION: This comment indicates the location in the code where a message should be sent, specifically tagged with the 'status' topic. This is part of a publish-subscribe pattern implementation, likely using ZeroMQ.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/archetypes/examples/pubsub_topics_pub.md#_snippet_0\n\nLANGUAGE: <language name>\nCODE:\n```\n//  Send a message on the 'status' topic\n```\n\n----------------------------------------\n\nTITLE: Initializing a ZeroMQ Message in C\nDESCRIPTION: Demonstrates how to initialize a message structure in ZeroMQ using C and the libzmq library. Required dependencies include libzmq headers and a linked ZeroMQ library. The functions allow initialization of empty messages, messages with a specific size, or with user-provided data. Input parameters vary: for zmq_msg_init you provide a message pointer; for zmq_msg_init_size you provide a message pointer and a size, and for zmq_msg_init_data you provide a data buffer and size. These functions return status codes and initialize the zmq_msg_t structure which must be properly released later.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_0\n\nLANGUAGE: C\nCODE:\n```\n#include <zmq.h>\n\nzmq_msg_t msg1;\nzmq_msg_init(&msg1); // Initializes an empty message\n\nzmq_msg_t msg2;\nzmq_msg_init_size(&msg2, 128); // Initializes a message of 128 bytes\n\nvoid *buffer = malloc(64);\nzmq_msg_t msg3;\nzmq_msg_init_data(&msg3, buffer, 64, free, NULL); // Initializes a message with data and custom free\n```\n\n----------------------------------------\n\nTITLE: Working with ZeroMQ Message Properties in C\nDESCRIPTION: Covers usage of zmq_msg_get and zmq_msg_set to access and modify ZeroMQ message properties via libzmq in C. These functions allow getting/setting specific message properties such as group membership or routing. Each takes a zmq_msg_t pointer and a property selector, optionally a value for setting. Results or status codes are returned depending on the operation.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/messages_func.md#_snippet_4\n\nLANGUAGE: C\nCODE:\n```\nint prop = zmq_msg_get(&msg, ZMQ_MORE);\nzmq_msg_set(&msg, ZMQ_GROUP, 1);\n```\n\n----------------------------------------\n\nTITLE: Receiving Entire Multi-Frame Message with ZMsg.recvMsg and Parsing Frames - JeroMQ - Java\nDESCRIPTION: This snippet demonstrates receiving a multipart message atomically using ZMsg.recvMsg and extracting its string frames sequentially using popString, with JeroMQ in Java. This approach handles the entire message as a unit, making frame extraction explicit and ordered. Requires JeroMQ's ZMsg and socket. Inputs are the receiving socket; outputs are the split string frames.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv_multi.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nZMsg strings = ZMsg.recvMsg(socket);\nString hello     = strings.popString();\nString beautiful = strings.popString();\nString world     = strings.popString();\n```\n\n----------------------------------------\n\nTITLE: Receiving a ZFrame and Extracting String Content with Jeromq in Java\nDESCRIPTION: This snippet demonstrates how to receive a message as a `ZFrame` object from a ZeroMQ socket using the static `ZFrame.recvFrame()` method in Jeromq. It then shows how to extract the string content from the received frame using the `getString()` method, specifying the character set (ZMQ.CHARSET) used during serialization.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/messages_strings_send_recv.md#_snippet_3\n\nLANGUAGE: java\nCODE:\n```\nZFrame stringFrame = ZFrame.recvFrame(socket);\nString hello = stringFrame.getString(ZMQ.CHARSET);\n```\n\n----------------------------------------\n\nTITLE: Receiving String Messages over ZeroMQ using CZMQ in C\nDESCRIPTION: Illustrates how to receive a message as a C string from a ZeroMQ socket using the czmq library. The provided socket must be valid and connected. The returned pointer is a dynamically allocated C string containing the received message, or NULL in case of failure or interruption. The caller is responsible for freeing the returned string after use.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/messages_strings_send_recv.md#_snippet_2\n\nLANGUAGE: c\nCODE:\n```\nchar *string = zstr_recv (socket);\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ.js Linking Against Shared Library using npm (Shell)\nDESCRIPTION: This command installs the `zeromq` npm package by building it from source while linking against a pre-existing shared ZeroMQ library (`libzmq`) on the system, specified by the `--zmq-shared` flag. This skips downloading the bundled `libzmq`. Requires build tools and a compatible shared `libzmq` library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/nodejs/zeromqjs/download.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install zeromq@6.0.0-beta.17 --zmq-shared\n```\n\n----------------------------------------\n\nTITLE: Verifying CGO Enabled Status in Go (Shell)\nDESCRIPTION: This shell command checks the Go environment variable `CGO_ENABLED`. A value of `1` indicates that CGO is enabled, allowing Go programs to call C code. This is required for the `zmq4` library, as it wraps the C ZeroMQ library. Cross-compilation typically disables CGO and is therefore not supported.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/download.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ go env CGO_ENABLED\n1\n```\n\n----------------------------------------\n\nTITLE: Installing zeromq Using Cargo - Rust - Bash\nDESCRIPTION: This Bash command uses Cargo to add the 'zeromq' crate, a native Rust implementation of ZeroMQ. Cargo must be installed, and the command should be executed from within a Rust project's root directory. It automatically updates Cargo.toml and resolves crate versions and dependencies.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/rust.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ncargo add zeromq\n\n```\n\n----------------------------------------\n\nTITLE: Installing zeromq via npm for Node.js - Shell\nDESCRIPTION: Demonstrates how to install the ZeroMQ JavaScript bindings using npm. This command downloads and installs the zeromq package from the npm registry, making the ZeroMQ library available for use in Node.js projects. It requires Node.js and npm to be installed and run from a terminal or command prompt within the target project directory.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/nodejs.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm install zeromq\n```\n\n----------------------------------------\n\nTITLE: Installing zmq using Cargo - Rust - Bash\nDESCRIPTION: This Bash command installs the Rust 'zmq' binding for libzmq using the Cargo package manager. It requires Cargo to be installed and will add the 'zmq' crate as a dependency to the project's manifest. No parameters are needed; just run the command within your project directory. Output is reflected in the project's Cargo.toml.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/rust.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ncargo add zmq\n\n```\n\n----------------------------------------\n\nTITLE: Installing zmq4 Package with Go Get (Shell)\nDESCRIPTION: This shell command uses the standard Go toolchain command `go get` to download, compile, and install the `zmq4` package from its GitHub repository (`github.com/pebbe/zmq4`). This command should be run after ensuring all prerequisites are met.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/download.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\ngo get github.com/pebbe/zmq4\n```\n\n----------------------------------------\n\nTITLE: Building and Serving the ZeroMQ Website Locally (Bash)\nDESCRIPTION: These commands first install the necessary CSS and JavaScript dependencies using npm, and then use Make to compile the website and start a local Hugo development server on port 1313. Requires Node.js, npm, and Make to be installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/README.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake serve\n```\n\n----------------------------------------\n\nTITLE: Checking ZeroMQ Version with pkg-config (Shell)\nDESCRIPTION: This shell command uses `pkg-config` to check if the ZeroMQ library (`libzmq`) is installed and retrieves its version. This is a prerequisite check primarily for Linux and Darwin systems before installing the `zmq4` Go wrapper.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/zmq4/download.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ pkg-config --modversion libzmq\n4.3.1\n```\n\n----------------------------------------\n\nTITLE: Installing pebbe/zmq4 Go Package\nDESCRIPTION: Provides the command to install the `pebbe/zmq4` Go package using `go get`. This binding interacts directly with `libzmq`, which must be installed as a prerequisite before running this command.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/go.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngo get github.com/pebbe/zmq4\n```\n\n----------------------------------------\n\nTITLE: Generating Hugo Example Stubs for ZeroMQ Documentation (Bash)\nDESCRIPTION: This shell command uses the Hugo static site generator to create new example stub files for the ZeroMQ documentation. It utilizes a predefined 'examples' archetype to generate content under the specified language and framework directory. Requires Hugo to be installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nhugo new --kind examples docs/examples/<your language>/<your framework name>\n```\n\n----------------------------------------\n\nTITLE: Forcing Source Build of PyZMQ with pip - Python\nDESCRIPTION: Shows how to force a source compilation of the PyZMQ library using pip by disabling usage of binary wheels. This is useful when a user wishes to link against a pre-installed or custom version of libzmq. It requires an appropriate compiler toolchain and any dependencies, such as a pre-installed libzmq, to be available. The command should be executed in a terminal, and may fail if dependencies are missing or an unsupported environment is detected.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/download.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npip install --no-binary=:all: pyzmq\n```\n\n----------------------------------------\n\nTITLE: Configuring JeroMQ Dependency in Maven XML for Java\nDESCRIPTION: This snippet demonstrates how to add JeroMQ as a dependency in a Maven project's pom.xml file. It includes both stable (0.5.3) and SNAPSHOT (0.6.0-SNAPSHOT) versions, and provides configuration instructions for using the Sonatype snapshot repository if the latest builds are not found. Required dependencies include Maven and access to the appropriate repositories; modify 'groupId', 'artifactId', and 'version' as needed. Inputs are to be placed in pom.xml, and no outputs are produced; the result is that Maven will resolve and download the specified dependencies during the build.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/download.md#_snippet_0\n\nLANGUAGE: xml\nCODE:\n```\n<dependency>\\n<groupId>org.zeromq</groupId>\\n<artifactId>jeromq</artifactId>\\n<version>0.5.3</version>\\n</dependency>\\n\\n<!-- for the latest SNAPSHOT -->\\n<dependency>\\n<groupId>org.zeromq</groupId>\\n<artifactId>jeromq</artifactId>\\n<version>0.6.0-SNAPSHOT</version>\\n</dependency>\\n\\n<!-- If you can't find the latest snapshot -->\\n<repositories>\\n<repository>\\n<id>sonatype-nexus-snapshots</id>\\n<url>https://oss.sonatype.org/content/repositories/snapshots</url>\\n<releases>\\n<enabled>false</enabled>\\n</releases>\\n<snapshots>\\n<enabled>true</enabled>\\n</snapshots>\\n</repository>\\n</repositories>\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ on Debian-based systems using Bash\nDESCRIPTION: Installs the CZMQ development library (`libczmq-dev`) using the `apt-get` package manager on Ubuntu, Debian, or Mint systems. This command requires root privileges or `sudo`.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\napt-get install libczmq-dev\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ Development Package on Ubuntu/Debian/Mint using apt-get\nDESCRIPTION: Installs the ZeroMQ development package (`libzmq3-dev`) on Debian-based Linux distributions like Ubuntu and Mint using the `apt-get` package manager. This provides the necessary files for developing ZeroMQ applications.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\napt-get install libzmq3-dev\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ on macOS using Brew\nDESCRIPTION: Uses the Homebrew package manager to install the ZeroMQ library on macOS. Requires Homebrew (brew) to be previously installed and configured.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nbrew install zmq\n```\n\n----------------------------------------\n\nTITLE: Conceptual ZeroMQ Request-Reply Server\nDESCRIPTION: Placeholder for the 'Hello World' server example code. This server demonstrates the basic ZeroMQ request-reply pattern. It creates a REP (response) socket, binds it to a specific port (e.g., 5555), and waits to receive requests, sending back replies. The example highlights ZeroMQ's simplicity, requiring minimal configuration and using simple string messages. It utilizes blocking receive calls.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/get-started.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\n{{< example hello_world_server >}}\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ Development Package on Fedora using dnf\nDESCRIPTION: Installs the ZeroMQ development package (`zeromq-devel`) on Fedora Linux distributions using the `dnf` package manager. This package typically includes headers and libraries needed for compiling applications against libzmq.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndnf install zeromq-devel\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ on Arch Linux using pacman\nDESCRIPTION: Installs the ZeroMQ package on Arch Linux using the `pacman` package manager with the `-S` flag for synchronization (installation).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npacman -S zeromq\n```\n\n----------------------------------------\n\nTITLE: Compiling and Installing zmqpp C++ Binding with Bash\nDESCRIPTION: This Bash snippet illustrates cloning, compiling, and installing the zmqpp C++ binding for ZeroMQ. It assumes ZeroMQ and any security dependencies are already installed. The commands also provide build and install checks for validation. No extra parameters are required but sudo is needed for installation. On completion, zmqpp will be available for C++ development.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/cpp/zmqpp/download.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Now install ZMQPP\\ngit clone git://github.com/zeromq/zmqpp.git\\ncd zmqpp\\nmake\\nmake check\\nsudo make install\\nmake installcheck\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ via vcpkg - Shell\nDESCRIPTION: These shell commands allow you to install the CZMQ library on Windows using vcpkg. They support building the library as a 32-bit or 64-bit library, enabling optional dependencies like libcurl, libmicrohttpd, and lz4, including draft APIs, and installing the latest head version. Dependencies include having vcpkg installed in your system. Key parameters involve build configurations (architecture, features, head flag). Input: Command-line instructions; Output: CZMQ installed via vcpkg.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/czmq/download.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg.exe install czmq\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg.exe install czmq:x64-windows-static\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg.exe install czmq[curl,httpd,lz4]:x64-windows\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg install czmq[draft]\n\n```\n\nLANGUAGE: shell\nCODE:\n```\nvcpkg.exe install czmq --head\n\n```\n\n----------------------------------------\n\nTITLE: Creating Server and Client with fszmq in F# (DEPRECATED)\nDESCRIPTION: Demonstrates a full server-client round-trip using the now-deprecated fszmq library in F#. The server creates a REP socket to handle 'hello' and 'goodbye' requests, sending 'world' or 'goodbye' in reply; the client sends multiple requests and prints server responses. Requires manual installation of libzmq and fszmq NuGet package; illustrates socket setup, string encoding/decoding, message loop, and correct disposal of all resources. Inputs are string messages; outputs are printed logs and verifiable message exchanges.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/fsharp.md#_snippet_3\n\nLANGUAGE: fsharp\nCODE:\n```\nopen fszmq\nopen fszmq.Context\nopen fszmq.Socket\n\nlet server () =\n  // create a ZMQ context\n  use context = new Context()\n\n  // create reply socket\n  use server  = rep context\n  // begin receiving connections\n  bind server \"tcp://*:5555\"\n\n  let rec loop () =\n    // process request (i.e. 'recv' a message from our 'server')\n    // NOTE: it's convenient to 'decode' the (binary) message into a string\n    match server |> recv |> decode with\n    | \"hello\"   ->  // valid request; send a reply back\n                    // NOTE: \"...\"B is short-hand for a byte array of ASCII-encoded chars\n                    \"world\"B |>> server\n                    // wait for next request\n                    loop()\n    | _         ->  // invalid request; stop receiving connections\n                    \"goodbye\"B |>> server\n\n  // wait for next request\n  loop ()\n\nlet client () =\n  // create a ZMQ context\n  use context = new Context()\n\n  // create a request socket\n  use client  = req context\n  // connect to the server\n  \"tcp://localhost:5555\" |> connect client\n\n  for i in 1 .. 10 do\n    // 'send' a request to the server\n    let request = if i = 10 then \"goodbye\" else \"hello\"\n    // NOTE: we need to 'encode' a string to binary (before transmission)\n    request |> encode |> send client\n    printfn \"(%i) sent: %s\" i request\n    // receive and print a reply from the server\n    let reply = (recv >> decode) client\n    printfn \"(%i) got: %s\" i reply\n```\n\n----------------------------------------\n\nTITLE: Configuring zzmq Dependency in build.zig (Zig)\nDESCRIPTION: This Zig snippet demonstrates how to configure the previously declared `zzmq` dependency within the `build.zig` file. It retrieves the dependency object, adds the `zzmq` module to the executable's imports (using `addModule` for Zig < 0.12 or `exe.root_module.addImport` for Zig >= 0.12), and links the necessary system libraries `czmq` and the C standard library (`libc`).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/download.md#_snippet_1\n\nLANGUAGE: zig\nCODE:\n```\nconst zzmq = b.dependency(\"zzmq\", .{\n    .target = target,\n    .optimize = optimize,\n});\n\n// Note: starting with zig 0.12 the function will be \n//       `exe.root_module.addImport` instead of `exe.addModule`\nexe.addModule(\"zzmq\", zzmq.module(\"zzmq\"));\n\nexe.linkSystemLibrary(\"czmq\");\nexe.linkLibC();\n```\n\n----------------------------------------\n\nTITLE: Declaring zzmq Dependency in build.zig.zon (Zig)\nDESCRIPTION: This Zig snippet shows how to declare the `zzmq` library as a dependency within the `build.zig.zon` file for a Zig 0.11 project. It specifies the source URL pointing to a specific tagged release archive on GitHub and includes a content hash for verification. This step makes the dependency available to the Zig build system.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/download.md#_snippet_0\n\nLANGUAGE: zig\nCODE:\n```\n.{\n    .dependencies = .{\n        .zzmq = .{\n            .url = \"https://github.com/nine-lives-later/zzmq/archive/refs/tags/v0.1.0-zig0.11.tar.gz\",\n            .hash = \"122080e22e9823dc0a4567c71553c4884978a33877c9b3d46f4594ca5f299d534f9b\",\n        },\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ with Draft APIs on Windows using Batch (vcpkg)\nDESCRIPTION: Installs CZMQ including the optional draft APIs by enabling the 'draft' feature using the `vcpkg` package manager on Windows. Assumes `vcpkg.exe` is in the current directory or path. Requires `vcpkg` to be correctly set up.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_5\n\nLANGUAGE: batch\nCODE:\n```\n.\\vcpkg install czmq[draft]\n```\n\n----------------------------------------\n\nTITLE: Installing PyZMQ with pip - Python\nDESCRIPTION: Demonstrates installing the PyZMQ Python library via pip, retrieving pre-built binary wheels suitable for the host platform. This approach is cross-platform and recommended for most users wanting to quickly get PyZMQ without needing to build from source. The command should be run in a terminal with Python and pip installed; no additional parameters are required unless a specific version is needed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/download.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install pyzmq\n```\n\n----------------------------------------\n\nTITLE: Installing `zmq` Gem with Custom `libzmq` Paths (Windows/Bash)\nDESCRIPTION: Installs the `zmq` gem on Windows, specifying both the main directory (`--with-zmq-dir`) and the specific library file directory (`--with-zmq-lib`) for a custom `libzmq` installation. This is often required on Windows where library locations might not be standard.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/ruby/rbzmq/download.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq -- --with-zmq-dir=c:/src/zeromq-4.3.2 --with-zmq-lib=c:/src/zeromq-4.3.2/src/.libs\n```\n\n----------------------------------------\n\nTITLE: Installing `zmq` Gem with RubyGems (Bash)\nDESCRIPTION: This command uses the RubyGems package manager (`gem`) to install the `zmq` gem. It assumes that the prerequisite `libzmq` library is already installed and accessible in the system's standard library paths.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/ruby/rbzmq/download.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ on macOS using Bash\nDESCRIPTION: Installs the CZMQ library using the Homebrew (`brew`) package manager on macOS. Requires Homebrew to be previously installed on the system.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nbrew install czmq\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ System Dependencies via apt (Shell)\nDESCRIPTION: These shell commands show how to install the required CZMQ library (version 4.0 or higher) on Debian-based Linux distributions like Ubuntu using the apt package manager. The `libczmq-dev` package is needed for compiling projects that use `zzmq`, while `libczmq` is required at runtime. Sudo privileges are necessary.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/download.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# Building on Ubuntu, PoP_OS, ZorinOS, etc.\nsudo apt install libczmq-dev\n\n# Running on Ubuntu, PoP_OS, ZorinOS, etc.\nsudo apt install libczmq\n```\n\n----------------------------------------\n\nTITLE: Installing libzmq Development Libraries on Debian-based and RHEL-based Systems - Shell\nDESCRIPTION: Provides shell commands to install the system-level ZeroMQ development libraries required by PyZMQ when compiling from source. The snippet covers installation on both Debian-based (using apt-get) and RHEL-based (using yum) Linux distributions. These dependencies are prerequisites for building PyZMQ against a system-provided libzmq, and must be run with appropriate privileges (using sudo).\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/python/pyzmq/download.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n# Debian-based\nsudo apt-get install libzmq3-dev\n\n# RHEL-based\nsudo yum install libzmq3-devel\n```\n\n----------------------------------------\n\nTITLE: Installing ZMQ::FFI using cpanm (Shell)\nDESCRIPTION: Installs the ZMQ::FFI Perl module using the `cpanm` command-line tool. The `-v` flag enables verbose output during installation. This module provides Perl bindings for the ZeroMQ library.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/perl.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ncpanm -v ZMQ::FFI\n```\n\n----------------------------------------\n\nTITLE: Fetching zimq Dependency using Zig Fetch\nDESCRIPTION: This shell command uses the Zig build system's `fetch` command to download the `zimq` library from its GitHub repository and add it as a dependency to the current Zig project. The `--save` flag likely updates a manifest file (`build.zig.zon` typically) to record this dependency.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/zig.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nzig fetch --save git+https://github.com/uyha/zimq.git\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ Static Library on Windows using Batch (vcpkg)\nDESCRIPTION: Installs CZMQ as a 64-bit static library using the `vcpkg` package manager on Windows, specifying the x64-windows-static triplet. Assumes `vcpkg.exe` is in the current directory or path. Requires `vcpkg` to be correctly set up.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_4\n\nLANGUAGE: batch\nCODE:\n```\n.\\vcpkg.exe install czmq:x64-windows-static\n```\n\n----------------------------------------\n\nTITLE: Installing ZeroMQ Development Package on SUSE using zypper\nDESCRIPTION: Installs the ZeroMQ development package (`zeromq-devel`) on SUSE Linux distributions using the `zypper` package manager.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/c/libzmq/download.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nzypper install zeromq-devel\n```\n\n----------------------------------------\n\nTITLE: Adding zmq Dependency via Cargo.toml - Rust - TOML\nDESCRIPTION: This TOML snippet demonstrates how to manually specify the 'zmq' crate as a dependency within a project's Cargo.toml file for Rust. The specified version is '0.10.5'. Ensure the [dependencies] section exists or add it to your manifest. This enables the use of libzmq via Rust bindings in your project.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/rust.md#_snippet_1\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nzmq = \"0.10.5\"\n\n```\n\n----------------------------------------\n\nTITLE: Installing CZMQ on Fedora using Bash\nDESCRIPTION: Installs the CZMQ development library (`czmq-devel`) using the `dnf` package manager on Fedora systems. This command requires root privileges or `sudo`.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/c.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndnf install czmq-devel\n```\n\n----------------------------------------\n\nTITLE: Installing rbzmq Gem on Windows with Custom Paths using Bash\nDESCRIPTION: This command demonstrates installing the `zmq` gem on a Windows system, providing specific paths for both the `libzmq` installation directory (`--with-zmq-dir`) and the library files (`--with-zmq-lib`). This is necessary for the gem installation to locate the required C libraries and headers.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/ruby.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq -- --with-zmq-dir=c:/src/zeromq-4.3.2 --with-zmq-lib=c:/src/zeromq-4.3.2/src/.libs\n```\n\n----------------------------------------\n\nTITLE: Installing `zmq` Gem with Custom `libzmq` Path (Unix/Bash)\nDESCRIPTION: Installs the `zmq` gem while specifying a custom installation directory for the `libzmq` library using the `--with-zmq-dir` flag. This is necessary if `libzmq` is installed in a non-standard location (e.g., /opt/local) and the gem installer cannot find it automatically.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/ruby/rbzmq/download.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngem install zmq -- --with-zmq-dir=/opt/local\n```\n\n----------------------------------------\n\nTITLE: Building and Running the ZeroMQ Website with Docker (Bash)\nDESCRIPTION: This sequence of commands outlines the Docker-based local setup. First, npm installs host-side dependencies (potentially for build tooling). Then, `make docker-build` constructs the Docker image containing the website and its environment. Finally, `make docker-run` starts a container from the built image, serving the website on port 80. Requires Node.js, npm, Make, and Docker to be installed.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/README.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpm install\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake docker-build\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake docker-run\n```\n\n----------------------------------------\n\nTITLE: Placeholder: Example Usage of ZeroMQ DISH Socket\nDESCRIPTION: This placeholder indicates where a code example demonstrating how a ZeroMQ DISH socket subscribes to specific groups to receive messages from RADIO sockets should be placed. DISH sockets only receive messages and cannot send.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/socket_api.md#_snippet_2\n\nLANGUAGE: plaintext\nCODE:\n```\n{{< example raddsh_dish_example >}}\n```\n\n----------------------------------------\n\nTITLE: Installing goczmq for CZMQ Before 4.0 via go get - Shell\nDESCRIPTION: For systems using CZMQ prior to version 4.0, this command uses 'go get' to install the older major version of goczmq via gopkg.in. It assumes Go is set up and requires legacy versions of the CZMQ C library as well as any other listed dependencies. Running this command results in goczmq v1 being placed in the Go workspace. Inputs are minimal (just the shell command), and it is limited to use with earlier CZMQ (pre-4.0) deployments.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/go/goczmq/download.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngo get gopkg.in/zeromq/goczmq.v1\n```\n\n----------------------------------------\n\nTITLE: Structuring C++ Header Files with Include Guards\nDESCRIPTION: Example showing the standard structure for libzmq header files. It includes initial comments, standard include guards (#ifndef, #define, #endif) separated by a newline, namespace usage, and ending with a single newline. The naming convention for include guards is mentioned (__ZMQ_FOO_HPP_INCLUDED__) along with a note that it needs revision.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_14\n\nLANGUAGE: cpp\nCODE:\n```\n/* Initial comments */\n\n#ifndef GUARD\n#define GUARD\n\nnamespace xyz\n{\n    // main content\n}\n\n#endif\n```\n\n----------------------------------------\n\nTITLE: JCZMQ Example Placeholder in Java\nDESCRIPTION: This snippet is a placeholder indicating where a JCZMQ Java usage example will be provided. No executable code is included yet; this is intended to be replaced with concrete sample code demonstrating JCZMQ (the JNI binding for czmq in Java) usage. No dependencies, parameters, or I/O are shown in this placeholder.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/languages/java.md#_snippet_1\n\nLANGUAGE: Java\nCODE:\n```\nTBD...\n\n```\n\n----------------------------------------\n\nTITLE: Placeholder for ZeroMQ Hello World Server Code in <language name>\nDESCRIPTION: This code block is a placeholder intended to contain the source code for a ZeroMQ 'Hello World' server. The specific implementation details depend on the chosen '<language name>' and '<library or framework name>'. The server typically binds to a socket, waits for a client request, and sends a response.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/archetypes/examples/hello_world_server.md#_snippet_0\n\nLANGUAGE: <language name>\nCODE:\n```\n```<language name>\n```\n```\n\n----------------------------------------\n\nTITLE: Placeholder for ZeroMQ Hello World Client in <language name>\nDESCRIPTION: This code block is a placeholder intended to contain the implementation of a basic ZeroMQ 'Hello World' client using the specified <language name> and <library or framework name>. The client typically connects to a server, sends a request (e.g., 'Hello'), and waits for a reply (e.g., 'World'). The surrounding metadata specifies the example name ('hello_world_client'), language, and library/framework.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/archetypes/examples/hello_world_client.md#_snippet_0\n\nLANGUAGE: <language name>\nCODE:\n```\n\n```\n\n----------------------------------------\n\nTITLE: Spacing for C++ Function Calls and Subscripts\nDESCRIPTION: Demonstrates the spacing rule for C++: function calls and array subscripts should be separated from the preceding expression by a single space.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_11\n\nLANGUAGE: cpp\nCODE:\n```\nfx (my_array [0]);\n```\n\n----------------------------------------\n\nTITLE: Spacing for C++ Definitions and Initializations\nDESCRIPTION: Shows consistent spacing rules applied to function definitions, direct-initialization, constructor initializer lists, and function-like operators (e.g., `new`, `std::malloc`). A space is used similarly to function calls.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_12\n\nLANGUAGE: cpp\nCODE:\n```\nstruct foo_t\n{\n    foo_t (int a_, int b_) :\n        a (a_),\n        b (b_)\n    {\n    }\n\n    void foo (int n) const;\n};\n\nfoo_t *p = new foo_t (1, 2);\nvoid *q = std::malloc (sizeof (foo_t));\n```\n\n----------------------------------------\n\nTITLE: Spacing for C++ Style Casts\nDESCRIPTION: Illustrates that C++ style casts (`reinterpret_cast`, `static_cast`) should have spaces separating the cast operator from the type arguments enclosed in angle brackets.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_13\n\nLANGUAGE: cpp\nCODE:\n```\nstd::intptr_t n = reinterpret_cast <std::intptr_t> (&x);\nchar *p = static_cast <char *> (q);\n```\n\n----------------------------------------\n\nTITLE: Demonstrating C++ Identifier Naming Conventions\nDESCRIPTION: Example showing identifier naming rules in libzmq. Identifiers are lowercase, use underscores to separate words, should be meaningful, and short names like 'i' are acceptable only for loop control variables.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_2\n\nLANGUAGE: cpp\nCODE:\n```\nint sum = 0;\nfor (int i = 0; i != 100; i++)\n     sum += i;\n```\n\n----------------------------------------\n\nTITLE: Formatting PHP String Concatenation\nDESCRIPTION: Illustrates the requirement to separate the PHP string concatenation operator ('.') from adjacent variables or strings with spaces.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_10\n\nLANGUAGE: php\nCODE:\n```\n$foo = $bar . \" \" . $bat;\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Mode Configuration in YAML\nDESCRIPTION: This snippet demonstrates setting a configuration flag named 'headless' to the boolean value 'true' using YAML syntax. This is typically used in configuration files (often called Front Matter in static site generators) to control page-specific settings, like whether a page should have a visible header or be treated differently during processing.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/java/jeromq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Setting 'headless' Property in YAML Front Matter\nDESCRIPTION: This YAML snippet defines the 'headless' property within front matter, setting its value to true. This configuration is typically used by static site generators or content management systems to indicate that the corresponding content should not generate its own dedicated page or URL, potentially serving as a content bundle or resource instead. It requires a system capable of parsing YAML front matter.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/perl/perlzmq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Handling C++ Indentation Collision in Control Statements\nDESCRIPTION: Shows how to handle potential indentation confusion when a control statement (like 'if') is broken into multiple lines. The subsequent lines of the control statement should be indented by 6 spaces (instead of the standard 4) to distinguish them clearly from the controlled block.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_7\n\nLANGUAGE: cpp\nCODE:\n```\nif (very_long_variable_name == 10000 &&\n      another_horrendous_variable_name == 1000000 &&\n      ludicrously_long_variable_name == 1000000000)\n    counter++;\n```\n\n----------------------------------------\n\nTITLE: Formatting C++ Binary Operators\nDESCRIPTION: Example showing that binary operators (like addition '+') should be separated from adjacent expressions by single spaces.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_9\n\nLANGUAGE: cpp\nCODE:\n```\nz = x + y;\n```\n\n----------------------------------------\n\nTITLE: Formatting C++ Unary Operators\nDESCRIPTION: Example showing that unary operators (like increment '++') should not be separated from their operand by any space.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/how-to-contribute.md#_snippet_8\n\nLANGUAGE: cpp\nCODE:\n```\ncounter++;\n```\n\n----------------------------------------\n\nTITLE: Conceptual ZeroMQ Request-Reply Client\nDESCRIPTION: Placeholder for the 'Hello World' client example code. This client complements the server example, demonstrating the request side of the ZeroMQ request-reply pattern. It creates a REQ (request) socket, connects to the server's endpoint, and sends messages, subsequently waiting for replies. The `send` method is blocking by default, potentially pausing if the high watermark is reached or no server is connected.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/get-started.md#_snippet_1\n\nLANGUAGE: text\nCODE:\n```\n{{< example hello_world_client >}}\n```\n\n----------------------------------------\n\nTITLE: Placeholder: Setting and Getting Routing ID for ZeroMQ SERVER Socket\nDESCRIPTION: This placeholder indicates where a code example demonstrating how a ZeroMQ SERVER socket sets the routing_id on an outgoing message to target a specific CLIENT peer should be placed. The SERVER socket uses this ID, obtained from incoming messages, to route replies.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/socket_api.md#_snippet_0\n\nLANGUAGE: plaintext\nCODE:\n```\n{{< example clisrv set_get_routing_id >}}\n```\n\n----------------------------------------\n\nTITLE: Placeholder: Example Usage of ZeroMQ RADIO Socket\nDESCRIPTION: This placeholder represents a code example showing how to use a ZeroMQ RADIO socket to publish messages associated with specific groups. RADIO sockets distribute messages to all connected DISH sockets subscribed to that group.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/socket_api.md#_snippet_1\n\nLANGUAGE: plaintext\nCODE:\n```\n{{< example raddsh_radio_example >}}\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Topic in PUB/SUB - <library or framework name> - <language name>\nDESCRIPTION: This code snippet is intended to illustrate the process of subscribing to a specific topic (\\'status\\') in a PUB/SUB system using an unspecified programming language and library. The snippet only contains a comment without any executable statements, serving as a conceptual placeholder. Dependencies and specific syntax details are not provided, so users need to adapt it based on their chosen language and framework.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/archetypes/examples/pubsub_topics_sub.md#_snippet_0\n\nLANGUAGE: <language name>\nCODE:\n```\n//  Subscribe to the 'status'\\n\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Flag in YAML Front Matter\nDESCRIPTION: This YAML block constitutes the front matter for the content file. It sets the 'headless' property to 'true'. In static site generators like Hugo, this configuration prevents the generator from creating a dedicated output page (e.g., HTML file) for this specific content file. Instead, the content might be used as a data source, resource bundle, or included within other pages.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/rust/rust-zmq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```\n\n----------------------------------------\n\nTITLE: Setting Headless Mode with YAML Front Matter\nDESCRIPTION: This YAML Front Matter block sets the `headless` property to `true`. This configuration is typically used by static site generators or content management systems to control how a specific page or document is rendered, often omitting standard layout elements like headers and footers. It's a common way to provide metadata about the content.\nSOURCE: https://github.com/zeromq/zeromq.org/blob/master/content/docs/examples/zig/zzmq/index.md#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n---\nheadless: true\n---\n```"
  }
]