[
  {
    "owner": "trpc",
    "repo": "trpc",
    "content": "TITLE: Defining Basic tRPC Procedures in TypeScript\nDESCRIPTION: This snippet shows how to initialize tRPC with a typed context, import Zod for validation, and define a router with both a query (\"hello\") and a mutation (\"goodbye\") procedure. The query returns a greeting message, while the mutation simulates a side effect by invoking a context function and then returns a different message. This requires \"@trpc/server\" and \"zod\", and expects that a context containing the asynchronous method 'signGuestBook' is supplied. Inputs and outputs are simple objects; these procedures illustrate baseline patterns for tRPC endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n\nconst appRouter = router({\n  // Queries are the best place to fetch data\n  hello: publicProcedure.query(() => {\n    return {\n      message: 'hello world',\n    };\n  }),\n\n  // Mutations are the best place to do things like updating a database\n  goodbye: publicProcedure.mutation(async (opts) => {\n    await opts.ctx.signGuestBook();\n\n    return {\n      message: 'goodbye!',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic tRPC Router in TypeScript\nDESCRIPTION: Shows how to define a simple tRPC router with a greeting procedure. This creates an API endpoint that can be exposed to the frontend through an adapter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/routers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\n// ---cut---\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  greeting: publicProcedure.query(() => 'hello tRPC v10!'),\n});\n\n// Export only the type of a router!\n// This prevents us from importing server code on the client.\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Client for Type-Safe API Calls in TypeScript\nDESCRIPTION: Demonstrates how to use the initialized tRPC client to make type-safe API calls. It includes examples of querying and mutating data through the client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\n\nconst frodo = await client.createUser.mutate({ name: 'Frodo' });\n// => { id: 'id_frodo', name: 'Frodo' };\n```\n\n----------------------------------------\n\nTITLE: Adding Mutation Procedure in TypeScript\nDESCRIPTION: This snippet demonstrates how to add a 'userCreate' mutation procedure to a tRPC router. It uses Zod for input validation and interacts with a database to create a new user.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst appRouter = router({\n  // ...\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) => {\n      const { input } = opts;\n      //      ^?\n      // Create a new user in the database\n      const user = await db.user.create(input);\n      //    ^?\n      return user;\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Client in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a tRPC client using the httpBatchLink. It imports the AppRouter type from the server to ensure type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n//     👆 **type-only** import\n\n// Pass AppRouter as generic here. 👇 This lets the `trpc` object know\n// what procedures are available on the server and their input/output types.\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC API Handler for Next.js\nDESCRIPTION: This snippet demonstrates how to create a basic tRPC API handler for a Next.js project. It uses createNextApiHandler to set up the handler with the appRouter and createContext function.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/nextjs.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC Client Configuration\nDESCRIPTION: Sets up tRPC client hooks and configuration for use in Next.js application, including base URL handling and HTTP batch link setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/setup.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined')\n    // browser should use relative path\n    return '';\n\n  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n\n  if (process.env.RENDER_INTERNAL_HOSTNAME)\n    // reference for render.com\n    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;\n\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      links: [\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n          async headers() {\n            return {\n              // authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Reusable Base Procedures for Authentication and Authorization\nDESCRIPTION: This example shows how to create reusable base procedures for authentication and organization-specific authorization. It defines 'authedProcedure' to ensure a user is logged in and 'organizationProcedure' to validate organization membership.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n\ntype Organization = {\n  id: string;\n  name: string;\n};\ntype Membership = {\n  role: 'ADMIN' | 'MEMBER';\n  Organization: Organization;\n};\ntype User = {\n  id: string;\n  memberships: Membership[];\n};\ntype Context = {\n  /**\n   * User is nullable\n   */\n  user: User | null;\n};\n\nconst t = initTRPC.context<Context>().create();\n\nexport const publicProcedure = t.procedure;\n\n// procedure that asserts that the user is logged in\nexport const authedProcedure = t.procedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n    //     ^?\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return opts.next({\n    ctx: {\n      // ✅ user value is known to be non-null now\n      user: ctx.user,\n    },\n  });\n});\n\n// procedure that a user is a member of a specific organization\nexport const organizationProcedure = authedProcedure\n  .input(z.object({ organizationId: z.string() }))\n  .use(function isMemberOfOrganization(opts) {\n    const membership = opts.ctx.user.memberships.find(\n      (m) => m.Organization.id === opts.input.organizationId,\n    );\n    if (!membership) {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n      });\n    }\n    return opts.next({\n      ctx: {\n        Organization: membership.Organization,\n      },\n    });\n  });\n\nexport const appRouter = t.router({\n  whoami: authedProcedure.query(async (opts) => {\n    // user is non-nullable here\n    const { ctx } = opts;\n    //      ^?\n    return ctx.user;\n  }),\n  addMember: organizationProcedure\n    .input(\n      z.object({\n        email: z.string().email(),\n      }),\n    )\n    .mutation((opts) => {\n      // ctx contains the non-nullable user & the organization being queried\n      const { ctx } = opts;\n      //       ^?\n\n      // input includes the validate email of the user being invited & the validated organizationId\n      const { input } = opts;\n      //       ^?\n\n      return '...';\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Importing AppRouter in TypeScript\nDESCRIPTION: This snippet shows how to import the AppRouter type from the server router file. It's a crucial step for setting up tRPC in a React application.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  getUser: t.procedure.input(z.object({ id: z.string() })).query(() => ({ name: 'foo' })),\n  createUser: t.procedure.input(z.object({ name: z.string() })).mutation(() => 'bar'),\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Instance with TypeScript\nDESCRIPTION: Basic initialization of a tRPC instance, creating a router and public procedure. This setup should be done once per application to avoid issues with multiple instances.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/routers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// You can use any variable name you like.\n// We use t to keep things simple.\nconst t = initTRPC.create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for SSR in Next.js\nDESCRIPTION: This snippet demonstrates how to set up the tRPC client for server-side rendering in a Next.js application. It includes configuration for both client-side and server-side requests, handling of headers, and optional superjson transformation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        transformer: superjson, // optional - adds superjson serialization\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    return {\n      transformer: superjson, // optional - adds superjson serialization\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Using useMutation() Hook in React Component\nDESCRIPTION: This snippet demonstrates how to use the useMutation() hook from tRPC in a React component. It shows handling a login mutation, including disabling the button during the mutation and displaying error messages.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useMutation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const mutation = trpc.login.useMutation();\n\n  const handleLogin = () => {\n    const name = 'John Doe';\n\n    mutation.mutate({ name });\n  };\n\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <button onClick={handleLogin} disabled={mutation.isPending}>\n        Login\n      </button>\n\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Hooks in TypeScript\nDESCRIPTION: This snippet demonstrates how to create strongly-typed React hooks from the AppRouter type signature using createTRPCReact. These hooks will be used for making tRPC calls in the React components.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Context with JWT Authorization\nDESCRIPTION: Implementation of createContext function that extracts and verifies JWT token from request headers to establish user context for tRPC procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/authorization.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';\n\nexport async function createContext({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) {\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      const user = await decodeAndVerifyJwtToken(\n        req.headers.authorization.split(' ')[1],\n      );\n      return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n\n  return {\n    user,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Defining an Authorization Middleware in tRPC (TypeScript)\nDESCRIPTION: This snippet defines a reusable tRPC middleware `adminProcedure` using `publicProcedure.use()`. It checks if the context (`ctx`) contains a user object with `isAdmin` set to true. If the user is not an admin, it throws a `TRPCError` with the code 'UNAUTHORIZED'. Otherwise, it proceeds to the next middleware or the procedure resolver, passing the user context along.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n```twoslash include admin\nimport { TRPCError, initTRPC } from '@trpc/server';\n\ninterface Context {\n  user?: {\n    id: string;\n    isAdmin: boolean;\n    // [..]\n  };\n}\n\nconst t = initTRPC.context<Context>().create();\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n\nexport const adminProcedure = publicProcedure.use(async (opts) => {\n  const { ctx } = opts;\n  if (!ctx.user?.isAdmin) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @include: admin\n```\n```\n\n----------------------------------------\n\nTITLE: HTTP Server and Router Configuration\nDESCRIPTION: Sets up the tRPC HTTP server with router definitions for user operations including listing, retrieving by ID, and creating users.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from \"@trpc/server/adapters/standalone\";\nimport { z } from \"zod\";\nimport { db } from \"./db\";\nimport { publicProcedure, router } from \"./trpc\";\n\nconst appRouter = router({\n  userList: publicProcedure\n    .query(async () => {\n      const users = await db.user.findMany();\n      return users;\n    }),\n  userById: publicProcedure\n    .input(z.string())\n    .query(async (opts) => {\n      const { input } = opts;\n      const user = await db.user.findById(input);\n      return user;\n    }),\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) => {\n      const { input } = opts;\n      const user = await db.user.create(input);\n      return user;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n\nconst server = createHTTPServer({\n  router: appRouter,\n});\n\nserver.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Implementing Error Handling with onError in tRPC\nDESCRIPTION: This code shows how to use the onError method in tRPC to handle errors before they are sent to the client. It provides access to error details, request context, and allows for custom error handling logic.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-handling.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\n  // ...\n  onError(opts) {\n    const { error, type, path, input, ctx, req } = opts;\n    console.error('Error:', error);\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\n      // send to bug reporting\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Querying and Mutating with tRPC Client in TypeScript\nDESCRIPTION: This code snippet shows how to use the tRPC client to query for a user by ID and create a new user. It demonstrates the inferred types from the server procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Inferred types\nconst user = await trpc.userById.query('1');\n//    ^?\n\nconst createdUser = await trpc.userCreate.mutate({ name: 'sachinraja' });\n//    ^?\n```\n\n----------------------------------------\n\nTITLE: Adding Query and Mutation Endpoints to tRPC Router\nDESCRIPTION: Expands on the previous example by adding both a query and a mutation endpoint to the tRPC router. Uses Zod for input validation in the mutation endpoint.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/quickstart.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\nconst appRouter = trpc\n  .router()\n  .query('getUser', {\n    input: (val: unknown) => {\n      if (typeof val === 'string') return val;\n      throw new Error(`Invalid input: ${typeof val}`);\n    },\n    async resolve(req) {\n      req.input; // string\n      return { id: req.input, name: 'Bilbo' };\n    },\n  })\n  .mutation('createUser', {\n    // validate input with Zod\n    input: z.object({ name: z.string().min(5) }),\n    async resolve(req) {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: req.input,\n      });\n    },\n  });\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Hooks with createTRPCNext\nDESCRIPTION: Setup code for creating type-safe tRPC hooks with the createTRPCNext function, including URL configuration for different environments and HTTP link setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nfunction getBaseUrl() {\n  if (typeof window !== 'undefined')\n    // browser should use relative path\n    return '';\n\n  if (process.env.VERCEL_URL)\n    // reference for vercel.com\n    return `https://${process.env.VERCEL_URL}`;\n\n  if (process.env.RENDER_INTERNAL_HOSTNAME)\n    // reference for render.com\n    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;\n\n  // assume localhost\n  return `http://localhost:${process.env.PORT ?? 3000}`;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      links: [\n        httpBatchLink({\n          /**\n           * If you want to use SSR, you need to use the server's full URL\n           * @see https://trpc.io/docs/v11/ssr\n           **/\n          url: `${getBaseUrl()}/api/trpc`,\n\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              // authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    };\n  },\n  /**\n   * @see https://trpc.io/docs/v11/ssr\n   **/\n  ssr: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Server Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a tRPC router with procedures for listing, retrieving, and creating posts. It uses Zod for input validation and defines the AppRouter type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query(({ input }) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation(({ input }) => {\n        // imaginary db call\n        return { id: 1, ...input };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Using Authorization Middleware in a tRPC Router (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use the previously defined `adminProcedure` middleware. It creates an `adminRouter` where the `secretPlace` query procedure is protected by the `adminProcedure`. This ensures only admin users can access this specific endpoint. The `adminRouter` is then nested within the main `appRouter`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @filename: trpc.ts\n// @include: admin\n// @filename: _app.ts\n// ---cut---\nimport { adminProcedure, publicProcedure, router } from './trpc';\n\nconst adminRouter = router({\n  secretPlace: adminProcedure.query(() => 'a key'),\n});\n\nexport const appRouter = router({\n  foo: publicProcedure.query(() => 'bar'),\n  admin: adminRouter,\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Setting up Fastify Server with tRPC Plugin\nDESCRIPTION: Configuration of a Fastify server with tRPC plugin. It includes error handling, context creation, and server startup. The code also demonstrates how to properly type the tRPC options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fastifyTRPCPlugin,\n  FastifyTRPCPluginOptions,\n} from '@trpc/server/adapters/fastify';\nimport fastify from 'fastify';\nimport { createContext } from './context';\nimport { appRouter, type AppRouter } from './router';\n\nconst server = fastify({\n  maxParamLength: 5000,\n});\n\nserver.register(fastifyTRPCPlugin, {\n  prefix: '/trpc',\n  trpcOptions: {\n    router: appRouter,\n    createContext,\n    onError({ path, error }) {\n      // report to error monitoring\n      console.error(`Error in tRPC handler on path '${path}':`, error);\n    },\n  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],\n});\n\n(async () => {\n  try {\n    await server.listen({ port: 3000 });\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: tRPC Server Initialization\nDESCRIPTION: Initializes the tRPC backend and exports router and procedure helpers for route definitions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Throwing Errors in a tRPC Procedure - TypeScript\nDESCRIPTION: Demonstrates how to throw a TRPCError from within a tRPC procedure's resolver. Requires the @trpc/server package. Parameters include error code, message, and optionally the original cause error; these determine what is sent in the standardized error response. This pattern exposes errors to clients and captures stack traces for debugging. Intended for use inside routers defined with tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-handling.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\\n\\nconst appRouter = trpc.router().query('hello', {\\n  resolve: () => {\\n    throw new trpc.TRPCError({\\n      code: 'INTERNAL_SERVER_ERROR',\\n      message: 'An unexpected error occurred, please try again later.',\\n      // optional: pass the original error to retain stack trace\\n      cause: theError,\\n    });\\n  },\\n});\\n\\n// [...]\\n\n```\n\n----------------------------------------\n\nTITLE: Making tRPC API Requests with React Hooks\nDESCRIPTION: Example of using tRPC hooks in a Next.js page component to fetch data from a tRPC query procedure, including loading state handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const hello = trpc.hello.useQuery({ text: 'client' });\n  if (!hello.data) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <p>{hello.data.greeting}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Integration Testing with tRPC Server Caller\nDESCRIPTION: Shows how to use the caller in integration tests to verify router functionality. Demonstrates creating test context and making procedure calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inferProcedureInput } from '@trpc/server';\nimport { createContextInner } from '../context';\nimport { AppRouter, createCaller } from './_app';\n\ntest('add and get post', async () => {\n  const ctx = await createContextInner({});\n  const caller = createCaller(ctx);\n\n  const input: inferProcedureInput<AppRouter['post']['add']> = {\n    text: 'hello test',\n    title: 'hello test',\n  };\n\n  const post = await caller.post.add(input);\n  const byId = await caller.post.byId({ id: post.id });\n\n  expect(byId).toMatchObject(input);\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client with HTTP Batch Link\nDESCRIPTION: Creates and configures a tRPC client instance using createTRPCClient with httpBatchLink for API communication. Includes configuration for custom HTTP headers and authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n\n      // You can pass any HTTP headers you wish here\n      async headers() {\n        return {\n          authorization: getAuthCookie(),\n        };\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Route Handler for Next.js App Router\nDESCRIPTION: This snippet shows how to create a tRPC route handler for the Next.js App Router using the fetch adapter. It defines a handler function that uses fetchRequestHandler and exports it for both GET and POST methods.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/nextjs.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '~/server/api/router';\n\nfunction handler(req: Request) {\n  return fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({ ... })\n  });\n}\n\nexport { handler as GET, handler as POST };\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic tRPC API Handler in Next.js\nDESCRIPTION: Basic setup for creating a tRPC API handler in Next.js using createNextApiHandler. This code should be placed in pages/api/trpc/[trpc].ts to handle all tRPC routes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/nextjs.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC Authorization Using Middleware\nDESCRIPTION: Implementation of authorization using tRPC middleware, creating a reusable protected procedure that can be applied to multiple endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/authorization.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\n\nexport const t = initTRPC.context<Context>().create();\n\nexport const protectedProcedure = t.procedure.use(\n  async function isAuthed(opts) {\n    const { ctx } = opts;\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return opts.next({\n      ctx: {\n        user: ctx.user,\n      },\n    });\n  },\n);\n\nt.router({\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  admin: t.router({\n    secret: protectedProcedure.query((opts) => {\n      return {\n        secret: 'sauce',\n      };\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: TanStack React Query Basic Usage Examples\nDESCRIPTION: Shows comprehensive examples of using queries, mutations, and query keys with TanStack React Query and tRPC integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport default function Basics() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n\n  // Create QueryOptions which can be passed to query hooks\n  const myQueryOptions = trpc.path.to.query.queryOptions({ /** inputs */ })\n  const myQuery = useQuery(myQueryOptions)\n  // or:\n  // useSuspenseQuery(myQueryOptions)\n  // useInfiniteQuery(myQueryOptions)\n\n  // Create MutationOptions which can be passed to useMutation\n  const myMutationOptions = trpc.path.to.mutation.mutationOptions()\n  const myMutation = useMutation(myMutationOptions)\n\n  // Create a QueryKey which can be used to manipulated many methods\n  // on TanStack's QueryClient in a type-safe manner\n  const myQueryKey = trpc.path.to.query.queryKey()\n\n  const invalidateMyQueryKey = () => {\n    queryClient.invalidateQueries({ queryKey: myQueryKey })\n  }\n\n  return (\n    // Your app here\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Context Type Definition in tRPC\nDESCRIPTION: Shows how to define context types and initialize tRPC with proper type inference for procedures and middlewares.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { initTRPC } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n\nexport const createContext = async (opts: CreateNextContextOptions) => {\n  const session = await getSession({ req: opts.req });\n\n  return {\n    session,\n  };\n};\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\nconst t = initTRPC.context<Context>().create();\n\nt.procedure.use((opts) => {\n  opts.ctx;\n\n  return opts.next();\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up Next.js API Handler for tRPC\nDESCRIPTION: Configuration for the Next.js API handler that serves tRPC requests, using the createNextApiHandler to connect the router with the Next.js API routes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { appRouter } from '../../../server/routers/_app';\n\n// export API handler\n// @link https://trpc.io/docs/v11/server/adapters\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext: () => ({}),\n});\n```\n\n----------------------------------------\n\nTITLE: Authorizing Using Middleware in tRPC (TypeScript)\nDESCRIPTION: This snippet demonstrates how to implement authorization using middleware in tRPC. It creates a protected procedure that can be reused for multiple routes, ensuring user authentication before allowing access.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/authorization.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nexport const t = initTRPC.context<Context>().create();\n\n// you can reuse this for any procedure\nexport const protectedProcedure = t.procedure.use(\n  async function isAuthed(opts) {\n    const { ctx } = opts;\n    // `ctx.user` is nullable\n    if (!ctx.user) {\n      //     ^?\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return opts.next({\n      ctx: {\n        // ✅ user value is known to be non-null now\n        user: ctx.user,\n        // ^?\n      },\n    });\n  },\n);\n\nt.router({\n  // this is accessible for everyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  admin: t.router({\n    // this is accessible only to admins\n    secret: protectedProcedure.query((opts) => {\n      return {\n        secret: 'sauce',\n      };\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseQuery with tRPC\nDESCRIPTION: Demonstrates how to fetch data with the useSuspenseQuery hook that works with React Suspense. This returns a tuple with the post data as the first element and the query object as the second.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n\nfunction PostView() {\n  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });\n  //      ^?\n\n  return <>{/* ... */}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with tRPC in React\nDESCRIPTION: This snippet demonstrates how to use the tRPC React Query integration to call queries and mutations on your API. It shows examples of using useQuery for fetching data and useMutation for creating data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from \"react\";\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });\n  const userCreator = trpc.createUser.useMutation();\n\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Serving tRPC API with Standalone Adapter in TypeScript\nDESCRIPTION: This code snippet shows how to serve a tRPC API using the standalone adapter. It creates an HTTP server and listens on port 3000.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\n\nconst appRouter = router({\n  // ...\n});\n\nconst server = createHTTPServer({\n  router: appRouter,\n});\n\nserver.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC AppRouter with Query Procedure\nDESCRIPTION: Example of creating a tRPC app router with a 'hello' query procedure that accepts a text input and returns a greeting response.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\nimport { procedure, router } from '../trpc';\n\nexport const appRouter = router({\n  hello: procedure\n    .input(\n      z.object({\n        text: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input.text}`,\n      };\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Using tRPC React Query Hooks for Data Fetching\nDESCRIPTION: Demonstration of how to use tRPC React Query integration to call queries and mutations on the API within a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from \"react\";\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });\n  const userCreator = trpc.createUser.useMutation();\n\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: tRPC Server Initialization\nDESCRIPTION: Creates a tRPC server instance and exports router and procedure helpers for building the API.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// Avoid exporting the entire t-object\n// since it's not very descriptive.\n// For instance, the use of a t variable\n// is common in i18n libraries.\nconst t = initTRPC.create();\n\n// Base router and procedure helpers\nexport const router = t.router;\nexport const procedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Recommended tRPC Project File Structure\nDESCRIPTION: The recommended file structure for organizing a tRPC project with Next.js, showing the locations of key files like routers, context, and API handlers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n.\n├── prisma  # <-- if prisma is added\n│   └── [..]\n├── src\n│   ├── pages\n│   │   ├── _app.tsx  # <-- add `withTRPC()`-HOC here\n│   │   ├── api\n│   │   │   └── trpc\n│   │   │       └── [trpc].ts  # <-- tRPC HTTP handler\n│   │   └── [..]\n│   ├── server\n│   │   ├── routers\n│   │   │   ├── _app.ts  # <-- main app router\n│   │   │   ├── post.ts  # <-- sub routers\n│   │   │   └── [..]\n│   │   ├── context.ts   # <-- create app context\n│   │   └── trpc.ts      # <-- procedure helpers\n│   └── utils\n│       └── trpc.ts  # <-- your typesafe tRPC hooks\n└── [..]\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Query in Next.js Client Component\nDESCRIPTION: This snippet shows how to use a tRPC query in a Next.js client component using React Query's useQuery hook. It handles loading states and displays the fetched data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\n// <-- hooks can only be used in client components\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '~/trpc/client';\n\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const greeting = useQuery(trpc.hello.queryOptions({ text: 'world' }));\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook for Fetching Post by ID with Type Inference\nDESCRIPTION: Demonstrates how to build a custom hook for fetching a post by ID that uses inferred types for inputs and options. This ensures type safety when calling the API.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @filename: usePostById.ts\n// @noErrors\n// ---cut---\nimport { ReactQueryOptions, RouterInputs, trpc } from './trpc';\n\ntype PostByIdOptions = ReactQueryOptions['post']['byId'];\ntype PostByIdInput = RouterInputs['post']['byId'];\n\nfunction usePostById(input: PostByIdInput, options?: PostByIdOptions) {\n  return trpc.post.byId.useQuery(input, options);\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Context from Request Headers in tRPC (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a context function that extracts user information from request headers. It uses JWT token verification and sets up a type for the context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/authorization.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';\n\nexport async function createContext({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) {\n  // Create your context based on the request object\n  // Will be available as `ctx` in all your resolvers\n\n  // This is just an example of something you might want to do in your ctx fn\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      const user = await decodeAndVerifyJwtToken(\n        req.headers.authorization.split(' ')[1],\n      );\n      return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n\n  return {\n    user,\n  };\n}\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Custom Headers\nDESCRIPTION: Demonstrates setting up a tRPC client with custom headers using httpBatchLink. Includes functionality to dynamically set and use authentication tokens in requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/headers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Import the router type from your server file\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nlet token: string;\n\nexport function setToken(newToken: string) {\n  /**\n   * You can also save the token to cookies, and initialize from\n   * cookies above.\n   */\n  token = newToken;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/api/trpc',\n          /**\n           * Headers will be called on each request.\n           */\n          headers() {\n            return {\n              Authorization: token,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC client in Next.js\nDESCRIPTION: Configuring the tRPC client in a utils file. This creates a typesafe client using createTRPCNext and configures it with an HTTP batch link pointing to the tRPC API endpoint.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/next/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCNext, httpBatchLink } from '@trpc/next';\n// Import the router type from your server file\nimport type { AppRouter } from '../pages/api/[trpc].ts';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/trpc',\n        }),\n      ],\n    };\n  },\n  ssr: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Hook for Post Creation with Type Inference\nDESCRIPTION: Demonstrates how to build a custom hook for post creation that leverages inferred types. The hook extends the standard tRPC mutation with additional functionality while maintaining type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @filename: usePostCreate.ts\n// @noErrors\n// ---cut---\nimport {\n  trpc,\n  type ReactQueryOptions,\n  type RouterInputs,\n  type RouterOutputs,\n} from './trpc';\n\ntype PostCreateOptions = ReactQueryOptions['post']['create'];\n\nfunction usePostCreate(options?: PostCreateOptions) {\n  const utils = trpc.useUtils();\n\n  return trpc.post.create.useMutation({\n    ...options,\n    onSuccess(post) {\n      // invalidate all queries on the post router\n      // when a new post is created\n      utils.post.invalidate();\n      options?.onSuccess?.(post);\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Query with Yup Input Validation in TypeScript\nDESCRIPTION: This snippet demonstrates defining a tRPC query procedure ('hello') using Yup for input validation. It specifies an input schema requiring an object with a mandatory 'text' string property. The `resolve` function accesses the validated `input.text` to generate a greeting. It also exports the router's type (`AppRouter`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/router.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport * as yup from 'yup';\n\n// [...] \n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  input: yup.object({\n    text: yup.string().required(),\n  }),\n  resolve({ input }) {\n    return {\n      greeting: `hello ${input?.text ?? 'world'}`,\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Executing tRPC Queries and Mutations\nDESCRIPTION: Shows how to perform queries and mutations using the tRPC client with full type inference\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// Inferred types\nconst user = await trpc.userById.query('1');\n\nconst createdUser = await trpc.userCreate.mutate({ name: 'sachinraja' });\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Providers in React\nDESCRIPTION: This snippet shows how to set up tRPC providers in a React application. It includes creating a tRPC client, wrapping the application in tRPC Provider, and setting up React Query. It also demonstrates how to pass HTTP headers for authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport React, { useState } from 'react';\nimport { trpc } from './utils/trpc';\n\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/trpc',\n\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Basic Query and Mutation Procedures in TypeScript\nDESCRIPTION: This snippet demonstrates how to create basic query and mutation procedures using tRPC. It includes a 'hello' query that returns a message and a 'goodbye' mutation that interacts with the context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n\nconst appRouter = router({\n  // Queries are the best place to fetch data\n  hello: publicProcedure.query(() => {\n    return {\n      message: 'hello world',\n    };\n  }),\n\n  // Mutations are the best place to do things like updating a database\n  goodbye: publicProcedure.mutation(async (opts) => {\n    await opts.ctx.signGuestBook();\n\n    return {\n      message: 'goodbye!',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Wrapping Next.js App Component with tRPC\nDESCRIPTION: This snippet demonstrates how to wrap the Next.js App component with tRPC. This setup is necessary to enable tRPC functionality throughout the application, including SSR support.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\nimport type { AppProps } from 'next/app';\nimport React from 'react';\n\nconst MyApp: AppType = ({ Component, pageProps }: AppProps) => {\n  return <Component {...pageProps} />;\n};\n\nexport default trpc.withTRPC(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Protected Middleware with Context Example\nDESCRIPTION: Shows how to implement protected procedures using middleware that validates user context. Includes examples of both failed and successful authorization scenarios.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\ntype Context = {\n  user?: {\n    id: string;\n  };\n};\nconst t = initTRPC.context<Context>().create();\n\nconst protectedProcedure = t.procedure.use((opts) => {\n  const { ctx } = opts;\n  if (!ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You are not authorized',\n    });\n  }\n\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n\nconst router = t.router({\n  secret: protectedProcedure.query((opts) => opts.ctx.user),\n});\n\n{\n  const caller = router.createCaller({});\n\n  const result = await caller.secret();\n}\n\n{\n  const authorizedCaller = router.createCaller({\n    user: {\n      id: 'KATT',\n    },\n  });\n  const result = await authorizedCaller.secret();\n}\n```\n\n----------------------------------------\n\nTITLE: Basic tRPC useQueries Implementation in TypeScript React\nDESCRIPTION: Demonstrates the basic usage of useQueries hook to fetch multiple posts by their IDs. When used with httpBatchLink or wsLink, this results in a single HTTP call to the server.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = (props: { postIds: string[] }) => {\n  const postQueries = trpc.useQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n\n  return <>{/* [...] */}</>;\n};\n```\n\n----------------------------------------\n\nTITLE: Using useMutation() Hook in a React Component\nDESCRIPTION: This example shows how to use the useMutation() hook from tRPC in a React component. It creates a login form that triggers the 'login' mutation when a button is clicked.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useMutation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  // This can either be a tuple ['login'] or string 'login'\n  const mutation = trpc.login.useMutation();\n\n  const handleLogin = () => {\n    const name = 'John Doe';\n\n    mutation.mutate({ name });\n  };\n\n  return (\n    <div>\n      <h1>Login Form</h1>\n      <button onClick={handleLogin} disabled={mutation.isLoading}>\n        Login\n      </button>\n\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC App Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to implement a basic tRPC router with query and mutation procedures. It includes input validation using Zod and defines the router's type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Defining Flattened User Router in tRPC\nDESCRIPTION: This snippet demonstrates the definition of a user router with flattened procedure names for use with t.mergeRouters in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  userList: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Route Handler for Next.js App Router\nDESCRIPTION: Implementation of tRPC handler using the Next.js App Router's Route Handlers feature. Uses the fetch adapter to handle web standard Request and Response objects.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/nextjs.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { appRouter } from '~/server/api/router';\n\nconst handler = (req: Request) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: () => ({ ... })\n  });\n\nexport { handler as GET, handler as POST };\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for SSR in Next.js\nDESCRIPTION: This snippet demonstrates how to set up the tRPC client with SSR enabled. It includes configuration for both client-side and server-side requests, handling of headers, and proper URL setup for API calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport { ssrPrepass } from '@trpc/next/ssrPrepass';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  ssr: true,\n  ssrPrepass,\n  config(opts) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Client and Querying Server in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a tRPC client that connects to the server defined earlier. It sets up the client with an HTTP batch link and shows how to make a typed query to the 'greeting' procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/landing-intro/Step3.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @target: esnext\n// @include: server\n// @filename: client.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n\n// ---cut---\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n\nconst res = await trpc.greeting.query({ name: 'John' });\n//    ^?\n```\n\n----------------------------------------\n\nTITLE: Implementing Project Access Control Middleware in tRPC\nDESCRIPTION: Demonstrates creating a standalone middleware for project access control that checks if a user has access to specific projects. Shows type checking for context and input validation across different tRPC instances.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  experimental_standaloneMiddleware,\n  initTRPC,\n  TRPCError,\n} from '@trpc/server';\nimport * as z from 'zod';\n\nconst projectAccessMiddleware = experimental_standaloneMiddleware<{\n  ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined\n  input: { projectId: string }; // defaults to 'unknown' if not defined\n  // 'meta', not defined here, defaults to 'object | undefined'\n}>().create((opts) => {\n  if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Not allowed',\n    });\n  }\n\n  return opts.next();\n});\n\nconst t1 = initTRPC\n  .context<{\n    allowedProjects: string[];\n  }>()\n  .create();\n\n// ✅ `ctx.allowedProjects` satisfies \"string[]\" and `input.projectId` satisfies \"string\"\nconst accessControlledProcedure = t1.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n\n// @errors: 2345\n// ❌ `ctx.allowedProjects` satisfies \"string[]\" but `input.projectId` does not satisfy \"string\"\nconst accessControlledProcedure2 = t1.procedure\n  .input(z.object({ projectId: z.number() }))\n  .use(projectAccessMiddleware);\n\n// @errors: 2345\n// ❌ `ctx.allowedProjects` does not satisfy \"string[]\" even though `input.projectId` satisfies \"string\"\nconst t2 = initTRPC\n  .context<{\n    allowedProjects: number[];\n  }>()\n  .create();\n\nconst accessControlledProcedure3 = t2.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n```\n\n----------------------------------------\n\nTITLE: tRPC Runtime Configuration Interface\nDESCRIPTION: TypeScript interface defining the available runtime configuration options for tRPC, including transformer settings, error formatting, and environment controls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/routers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RuntimeConfig<TTypes extends RootConfigTypes> {\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/data-transformers\n   */\n  transformer: TTypes['transformer'];\n\n  /**\n   * Use custom error formatting\n   * @see https://trpc.io/docs/error-formatting\n   */\n  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;\n\n  /**\n   * Allow `@trpc/server` to run in non-server environments\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default false\n   */\n  allowOutsideOfServer: boolean;\n\n  /**\n   * Is this a server environment?\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'\n   */\n  isServer: boolean;\n\n  /**\n   * Is this development?\n   * Will be used to decide if the API should return stack traces\n   * @default process.env.NODE_ENV !== 'production'\n   */\n  isDev: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SSR in Next.js App with tRPC\nDESCRIPTION: Implementation of SSR configuration in Next.js _app.tsx file using tRPC. Includes setup for data transformation, URL configuration, header forwarding, and caching settings. Handles both client-side and server-side environments with special considerations for deployment platforms like Vercel.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/ssr.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { withTRPC } from '@trpc/next';\nimport { AppType } from 'next/dist/shared/lib/utils';\nimport React from 'react';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default withTRPC<AppRouter>({\n  config({ ctx }) {\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        transformer: superjson, // optional - adds superjson serialization\n        url: '/api/trpc',\n      };\n    }\n    // during SSR below\n\n    // optional: use SSG-caching for each rendered page (see caching section for more details)\n    const ONE_DAY_SECONDS = 60 * 60 * 24;\n    ctx?.res?.setHeader(\n      'Cache-Control',\n      `s-maxage=1, stale-while-revalidate=${ONE_DAY_SECONDS}`,\n    );\n\n    // The server needs to know your app's full url\n    // On render.com you can use `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}/api/trpc`\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      transformer: superjson, // optional - adds superjson serialization\n      url,\n      /**\n       * Set custom request headers on every request from tRPC\n       * @see http://localhost:3000/docs/v9/header\n       * @see http://localhost:3000/docs/v9/ssr\n       */\n      headers() {\n        if (ctx?.req) {\n          // To use SSR properly, you need to forward the client's headers to the server\n          // This is so you can pass through things like cookies when we're server-side rendering\n\n          // If you're using Node 18, omit the \"connection\" header\n          const {\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            connection: _connection,\n            ...headers\n          } = ctx.req.headers;\n          return {\n            ...headers,\n            // Optional: inform server that it's an SSR request\n            'x-ssr': '1',\n          };\n        }\n        return {};\n      },\n    };\n  },\n  ssr: true,\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Query Output Validation with Yup in TypeScript\nDESCRIPTION: This snippet illustrates using Yup to validate the output of a tRPC query named 'hello'. It enforces that the resolved value is an object with a required 'greeting' string property using `yup.object` and `yup.string().required()`. The `resolve` function provides the data, and the router type `AppRouter` is exported.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/output-validation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport * as yup from 'yup';\n\n// [...]\n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  output: yup.object({\n    greeting: yup.string().required(),\n  }),\n  resolve() {\n    return { greeting: 'hello!' };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic tRPC Server\nDESCRIPTION: Complete example of setting up a tRPC server with TypeScript, including context initialization, router creation with a greeting procedure, and HTTP server setup. Uses zod for input validation and standalone HTTP adapter.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/server/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport {\n  CreateHTTPContextOptions,\n  createHTTPServer,\n} from '@trpc/server/adapters/standalone';\nimport { z } from 'zod';\n\n// Initialize a context for the server\nfunction createContext(opts: CreateHTTPContextOptions) {\n  return {};\n}\n\n// Get the context type\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\n// Initialize tRPC\nconst t = initTRPC.context<Context>().create();\n\n// Create main router\nconst appRouter = t.router({\n  // Greeting procedure\n  greeting: t.procedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query(({ input }) => `Hello, ${input.name}!`),\n});\n\n// Export the app router type to be imported on the client side\nexport type AppRouter = typeof appRouter;\n\n// Create HTTP server\nconst { listen } = createHTTPServer({\n  router: appRouter,\n  createContext,\n});\n\n// Listen on port 2022\nlisten(2022);\n```\n\n----------------------------------------\n\nTITLE: Protected Procedures with Context\nDESCRIPTION: Demonstrates implementation of protected and public procedures using context for authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = await getSession({ req: opts.req });\n\n  return {\n    session,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\nexport const router = t.router;\n\nexport const publicProcedure = t.procedure;\n\nexport const protectedProcedure = t.procedure.use(function isAuthed(opts) {\n  if (!opts.ctx.session?.user?.email) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n    });\n  }\n  return opts.next({\n    ctx: {\n      session: opts.ctx.session,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Next.js API Route Handler for tRPC\nDESCRIPTION: Creates a Next.js API route handler using the fetch adapter for tRPC, which handles both GET and POST requests at the /api/trpc/* endpoint.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createTRPCContext } from '~/trpc/init';\nimport { appRouter } from '~/trpc/routers/_app';\n\nconst handler = (req: Request) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: createTRPCContext,\n  });\n\nexport { handler as GET, handler as POST };\n```\n\n----------------------------------------\n\nTITLE: Basic tRPC Input Validation with Zod\nDESCRIPTION: Demonstrates how to implement basic input validation using Zod in a tRPC procedure. Shows type inference and validation of a name parameter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/validators.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const name = opts.input.name;\n      return {\n        greeting: `Hello ${opts.input.name}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Caller for Server Components\nDESCRIPTION: Sets up a server-only tRPC caller with hydration helpers for React Server Components, ensuring stable query client management during requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\n\nimport { createHydrationHelpers } from '@trpc/react-query/rsc';\nimport { cache } from 'react';\nimport { createCallerFactory, createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\nconst caller = createCallerFactory(appRouter)(createTRPCContext);\n\nexport const { trpc, HydrateClient } = createHydrationHelpers<typeof appRouter>(\n  caller,\n  getQueryClient,\n);\n```\n\n----------------------------------------\n\nTITLE: Extending Context with a tRPC Middleware (TypeScript)\nDESCRIPTION: This example demonstrates context extension using a tRPC middleware. The `protectedProcedure` middleware checks for the existence of `ctx.user`. If the user exists, it proceeds using `opts.next`, explicitly passing the now non-nullable `ctx.user` in the extended context. This ensures that subsequent middlewares or the procedure resolver receive a context where `ctx.user` is guaranteed to be defined and correctly typed.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @target: esnext\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nconst t = initTRPC.context<Context>().create();\nconst publicProcedure = t.procedure;\nconst router = t.router;\n\n// ---cut---\n\ntype Context = {\n  // user is nullable\n  user?: {\n    id: string;\n  };\n};\n\nconst protectedProcedure = publicProcedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n    //     ^?\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return opts.next({\n    ctx: {\n      // ✅ user value is known to be non-null now\n      user: ctx.user,\n      // ^?\n    },\n  });\n});\n\nprotectedProcedure.query(({ ctx }) => ctx.user);\n//                                        ^?\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Different Transformers for Upload and Download in tRPC\nDESCRIPTION: TypeScript code to set up SuperJSON for upload and Devalue for download in tRPC transformer configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uneval } from 'devalue';\nimport superjson from 'superjson';\n\n// [...]\n\nexport const transformer = {\n  input: superjson,\n  output: {\n    serialize: (object) => uneval(object),\n    // This `eval` only ever happens on the **client**\n    deserialize: (object) => eval(`(${object})`),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using Batched Queries with Promise.all in tRPC\nDESCRIPTION: This code snippet shows how to use Promise.all to batch multiple tRPC queries into a single HTTP request. It demonstrates querying for multiple posts by their IDs in one batched operation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\n```\n\n----------------------------------------\n\nTITLE: Dehydrating tRPC State in Next.js Server-Side Props\nDESCRIPTION: This snippet shows how to dehydrate the tRPC state in the getServerSideProps function of a Next.js page. It's crucial for passing the prefetched data to the client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/server-side-helpers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nreturn {\n  props: {\n    // very important - use `trpcState` as the key\n    trpcState: helpers.dehydrate(),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Consuming tRPC Endpoints with Type-Safe Client\nDESCRIPTION: Shows how to create a tRPC client and make a type-safe query to the 'hello' endpoint. The client automatically inherits type information from the AppRouter without code generation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2021-05-05-hello-world.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AppRouter } from './server';\n\nasync function main() {\n  const client = createTRPCClient<AppRouter>({\n    url: `http://localhost:2022`,\n  });\n\n  const result = await client.query('hello', '@alexdotjs');\n  console.log(result); // --> { text: \"hello @alexdotjs\" }\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Basic tRPC Subscription Implementation\nDESCRIPTION: Demonstrates setting up a basic subscription procedure in tRPC using an EventEmitter to handle real-time post additions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nconst ee = new EventEmitter();\n\nexport const appRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    // listen for new events\n    for await (const [data] of on(ee, 'add', {\n      // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted\n      signal: opts.signal,\n    })) {\n      const post = data as Post;\n      yield post;\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Mutation Procedure in TypeScript\nDESCRIPTION: Demonstrates how to add a userCreate mutation procedure to a tRPC router with input validation using Zod schema and database integration\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst appRouter = router({\n  // ...\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) => {\n      const { input } = opts;\n      // Create a new user in the database\n      const user = await db.user.create(input);\n      return user;\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Providers in React Application\nDESCRIPTION: Example of how to set up tRPC providers in a React application, including creating a tRPC client and wrapping the application with necessary providers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport React, { useState } from 'react';\nimport { trpc } from './utils/trpc';\n\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/trpc',\n\n          // You can pass any HTTP headers you wish here\n          async headers() {\n            return {\n              authorization: getAuthCookie(),\n            };\n          },\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating and Consuming Async Generator Procedures in tRPC\nDESCRIPTION: Example showing how to create a server-side tRPC procedure that returns an async generator and how to consume it on the client side. The generator yields values over time which are streamed to the client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchStreamLink.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  examples: {\n    iterable: publicProcedure.query(async function* () {\n      for (let i = 0; i < 3; i++) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        yield i;\n      }\n    }),\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n\n\n// @filename: client.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nconst iterable = await trpc.examples.iterable.query();\n//      ^?\n\nfor await (const value of iterable) {\n  console.log('Iterable:', value);\n  //                         ^?\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client with HTTP Link in TypeScript\nDESCRIPTION: Example of setting up a tRPC client with the httpLink to connect to a tRPC server over HTTP. The code demonstrates importing the necessary functions and configuring the HTTP link with a URL.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      // transformer,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using Authorization Middleware in tRPC Router\nDESCRIPTION: This snippet shows how to use the previously defined adminProcedure in a tRPC router. It creates an adminRouter with a protected 'secretPlace' query and combines it with a public procedure in the main appRouter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { adminProcedure, publicProcedure, router } from './trpc';\n\nconst adminRouter = router({\n  secretPlace: adminProcedure.query(() => 'a key'),\n});\n\nexport const appRouter = router({\n  foo: publicProcedure.query(() => 'bar'),\n  admin: adminRouter,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client in TypeScript\nDESCRIPTION: Creates a tRPC client using createTRPCProxyClient and configures it with httpBatchLink. It sets up the client with a URL and custom headers for authorization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n\n      // You can pass any HTTP headers you wish here\n      async headers() {\n        return {\n          authorization: getAuthCookie(),\n        };\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Router with Greeting Procedure in TypeScript\nDESCRIPTION: This snippet shows how to create a tRPC router with a 'greeting' procedure. It uses Zod for input validation, accepting an object with a 'name' string property. The procedure returns a greeting message based on the input name.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/landing-intro/Step1.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport z from 'zod';\n\nconst t = initTRPC.create();\n\nconst router = t.router;\nconst publicProcedure = t.procedure;\n\nconst appRouter = router({\n  greeting: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => {\n      const { input } = opts;\n      //      ^?\n\n      return `Hello ${input.name}` as const;\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing API Response Caching in tRPC Server\nDESCRIPTION: Demonstrates server-side tRPC setup with response caching for public routes. Includes context creation, router configuration, and cache control implementation for query responses.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/caching.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nexport const t = initTRPC.context<Context>().create();\n\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // wait for 5s\n\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    const allOk = errors.length === 0;\n    const isQuery = type === 'query';\n\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: {\n          'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        },\n      };\n    }\n    return {};\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Data Fetching in Next.js getStaticProps\nDESCRIPTION: This code demonstrates how to fetch data using tRPC in Next.js Static Site Generation. It uses createServerSideHelpers to prefetch queries, dehydrate them, and pass the state to the page component. The example shows a complete implementation including getStaticPaths and the page component rendering.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssg.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { prisma } from '~/server/context';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport {\n  GetStaticPaths,\n  GetStaticPropsContext,\n  InferGetStaticPropsType,\n} from 'next';\nimport superjson from 'superjson';\n\nexport async function getStaticProps(\n  context: GetStaticPropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson, // optional - adds superjson serialization\n  });\n  const id = context.params?.id as string;\n\n  // prefetch `post.byId`\n  await helpers.post.byId.prefetch({ id });\n\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n    revalidate: 1,\n  };\n}\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const posts = await prisma.post.findMany({\n    select: {\n      id: true,\n    },\n  });\n\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        id: post.id,\n      },\n    })),\n    // https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking\n    fallback: 'blocking',\n  };\n};\n\nexport default function PostViewPage(\n  props: InferGetStaticPropsType<typeof getStaticProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n\n  if (postQuery.status !== 'success') {\n    // won't happen since we're using `fallback: \"blocking\"`\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>\n\n      <p>{data.text}</p>\n\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Fetching with tRPC\nDESCRIPTION: Example of using tRPC hooks to fetch data in a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const hello = trpc.useQuery(['hello', { text: 'client' }]);\n  if (!hello.data) return <div>Loading...</div>;\n  return (\n    <div>\n      <p>{hello.data.greeting}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC React Hooks\nDESCRIPTION: Setup code for creating strongly-typed React hooks from the AppRouter type signature.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createReactQueryHooks } from '@trpc/react';\nimport type { AppRouter } from '../path/to/router.ts';\n\nexport const trpc = createReactQueryHooks<AppRouter>();\n// => { useQuery: ..., useMutation: ...}\n```\n\n----------------------------------------\n\nTITLE: Initializing Server-Side Helpers with External Router in TypeScript\nDESCRIPTION: This code shows how to set up server-side helpers when you don't have direct access to your tRPC router, such as in a Next.js application with a separate API. It uses createTRPCProxyClient and createServerSideHelpers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/server-side-helpers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient } from '@trpc/client';\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport superjson from 'superjson';\n\nconst proxyClient = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n    }),\n  ],\n  transformer: superjson,\n});\n\nconst helpers = createServerSideHelpers({\n  client: proxyClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Router in TypeScript\nDESCRIPTION: Example of creating a basic tRPC router with two procedures: getUser and createUser. It demonstrates input validation using Zod and defines query and mutation handlers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/express.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Throwing TRPCError in a tRPC Procedure\nDESCRIPTION: This snippet illustrates how to throw a TRPCError within a tRPC procedure, specifying the error code, message, and optionally the original error for stack trace retention.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-handling.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  hello: t.procedure.query(() => {\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred, please try again later.',\n      // optional: pass the original error to retain stack trace\n      cause: theError,\n    });\n  }),\n});\n\n// [...]\n```\n\n----------------------------------------\n\nTITLE: Basic Server-Side Caller Implementation in TypeScript\nDESCRIPTION: Demonstrates creating and using a server-side caller with a router containing post management procedures. Shows how to create a caller factory, initialize with context, and make procedure calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\ntype Context = {\n  foo: string;\n};\n\nconst t = initTRPC.context<Context>().create();\n\nconst publicProcedure = t.procedure;\nconst { createCallerFactory, router } = t;\n\ninterface Post {\n  id: string;\n  title: string;\n}\nconst posts: Post[] = [\n  {\n    id: '1',\n    title: 'Hello world',\n  },\n];\nconst appRouter = router({\n  post: router({\n    add: publicProcedure\n      .input(\n        z.object({\n          title: z.string().min(2),\n        }),\n      )\n      .mutation((opts) => {\n        const post: Post = {\n          ...opts.input,\n          id: `${Math.random()}`,\n        };\n        posts.push(post);\n        return post;\n      }),\n    list: publicProcedure.query(() => posts),\n  }),\n});\n\nconst createCaller = createCallerFactory(appRouter);\n\nconst caller = createCaller({\n  foo: 'bar',\n});\n\nconst addedPost = await caller.post.add({\n  title: 'How to make server-side call in tRPC',\n});\n\nconst postList = await caller.post.list();\n```\n\n----------------------------------------\n\nTITLE: Querying User Data with tRPC Vanilla Client in TypeScript\nDESCRIPTION: Example of using the tRPC Vanilla client to query a user by ID. This demonstrates how to import the AppRouter type and make a query request that returns user data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/introduction.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '../path/to/server/trpc';\n\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Backend with Procedure Helpers\nDESCRIPTION: Setup code for initializing the tRPC backend with the initTRPC function and exporting router and procedure helpers for creating API endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// Avoid exporting the entire t-object\n// since it's not very descriptive.\n// For instance, the use of a t variable\n// is common in i18n libraries.\nconst t = initTRPC.create();\n\n// Base router and procedure helpers\nexport const router = t.router;\nexport const procedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Implementing a tRPC Client Provider for Client Components\nDESCRIPTION: Creates a client-side tRPC provider with React context for use in client components. Handles browser vs server QueryClient creation and includes utilities for determining API URLs based on environment.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\n\nexport const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();\n\nlet browserQueryClient: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: make a new query client if we don't already have one\n  // This is very important, so we don't re-make a new client if React\n  // suspends during the initial render. This may not be needed if we\n  // have a suspense boundary BELOW the creation of the query client\n  if (!browserQueryClient) browserQueryClient = makeQueryClient();\n  return browserQueryClient;\n}\n\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\n\nexport function TRPCReactProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {props.children}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: tRPC useQueries with Query Options\nDESCRIPTION: Shows how to provide individual query options like enabled and suspense to different queries within the useQueries hook. Also demonstrates handling query results and implementing refetch functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQueries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = () => {\n  const [post, greeting] = trpc.useQueries((t) => [\n    t.post.byId({ id: '1' }, { enabled: false }),\n    t.greeting({ text: 'world' }),\n  ]);\n\n  const onButtonClick = () => {\n    post.refetch();\n  };\n\n  return (\n    <div>\n      <h1>{post.data && post.data.title}</h1>\n      <p>{greeting.data.message}</p>\n      <button onClick={onButtonClick}>Click to fetch</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS for tRPC API Handler in Next.js\nDESCRIPTION: Extended implementation of the tRPC API handler with CORS configuration options. Includes both simple CORS setup and authenticated CORS setup with credentials support.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/nextjs.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n\n// create the API handler, but don't return it yet\nconst nextApiHandler = createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  // We can use the response object to enable CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Request-Method', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  res.setHeader('Access-Control-Allow-Headers', '*');\n\n  // If you need to make authenticated CORS calls then\n  // remove what is above and uncomment the below code\n\n  // Allow-Origin has to be set to the requesting domain that you want to send the credentials back to\n  // res.setHeader('Access-Control-Allow-Origin', 'http://example:6006');\n  // res.setHeader('Access-Control-Request-Method', '*');\n  // res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  // res.setHeader('Access-Control-Allow-Headers', 'content-type');\n  // res.setHeader('Referrer-Policy', 'no-referrer');\n  // res.setHeader('Access-Control-Allow-Credentials', 'true');\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    return res.end();\n  }\n\n  // finally pass the request on to the tRPC handler\n  return nextApiHandler(req, res);\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Subscription Procedure in tRPC Router (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to add a subscription procedure to a tRPC router. It uses an EventEmitter to handle real-time updates and includes a mutation procedure for adding new data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/subscriptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EventEmitter } from 'events';\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\nimport { z } from 'zod';\n\n// create a global event emitter (could be replaced by redis, etc)\nconst ee = new EventEmitter();\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  onAdd: t.procedure.subscription(() => {\n    // return an `observable` with a callback which is triggered immediately\n    return observable<Post>((emit) => {\n      const onAdd = (data: Post) => {\n        // emit data to client\n        emit.next(data);\n      };\n\n      // trigger `onAdd()` when `add` is triggered in our event emitter\n      ee.on('add', onAdd);\n\n      // unsubscribe function when client disconnects or stops subscribing\n      return () => {\n        ee.off('add', onAdd);\n      };\n    });\n  }),\n  add: t.procedure\n    .input(\n      z.object({\n        id: z.string().uuid().optional(),\n        text: z.string().min(1),\n      }),\n    )\n    .mutation(async (opts) => {\n      const post = { ...opts.input }; /* [..] add to db */\n\n      ee.emit('add', post);\n      return post;\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating tRPC with Express using Adapter\nDESCRIPTION: Demonstrates how to use the tRPC Express adapter to convert a tRPC router into an Express middleware. It includes setting up context, creating the Express app, and mounting the tRPC middleware.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/express.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport * as trpcExpress from '@trpc/server/adapters/express';\n\n// created for each request\nconst createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => ({}); // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nconst t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // [...]\n});\n\nconst app = express();\n\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  }),\n);\n\napp.listen(4000);\n```\n\n----------------------------------------\n\nTITLE: Error Handling with Caller Factory\nDESCRIPTION: Demonstrates error handling implementation using onError handler with createCaller. Shows how to handle and transform errors in procedure calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC\n  .context<{\n    foo?: 'bar';\n  }>()\n  .create();\n\nconst router = t.router({\n  greeting: t.procedure.input(z.object({ name: z.string() })).query((opts) => {\n    if (opts.input.name === 'invalid') {\n      throw new Error('Invalid name');\n    }\n\n    return `Hello ${opts.input.name}`;\n  }),\n});\n\nconst caller = router.createCaller(\n  {\n    /* context */\n  },\n  {\n    onError: (opts) => {\n      console.error('An error occurred:', opts.error);\n    },\n  },\n);\n\nawait caller.greeting({ name: 'invalid' });\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC with Links in Next.js\nDESCRIPTION: Example of configuring a tRPC client with multiple links (loggerLink and httpBatchLink) in a Next.js application. The links are executed in order for requests and in reverse for responses.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { httpBatchLink, loggerLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nexport default createTRPCNext<AppRouter>({\n  config() {\n    const url = `http://localhost:3000`;\n\n    return {\n      links: [\n        loggerLink(),\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Providers\nDESCRIPTION: Implementation of tRPC providers in the main App component, including query client setup and configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport React, { useState } from 'react';\nimport { QueryClient, QueryClientProvider } from 'react-query';\nimport { trpc } from './utils/trpc';\n\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      url: 'http://localhost:5000/trpc',\n\n      // optional\n      headers() {\n        return {\n          authorization: getAuthCookie(),\n        };\n      },\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Infinite Query Procedure with tRPC and Prisma in TypeScript\nDESCRIPTION: This snippet defines a tRPC router procedure implementing cursor-based pagination for posts using Prisma. It expects a z.object input with optional 'limit' and 'cursor', queries data with Prisma's findMany (using an extra result for detecting the next cursor), and returns both paginated results and nextCursor. Dependencies include @trpc/server, zod for input validation, and a Prisma client instance, with 'cursor' allowing for any type as required for infinite queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { Context } from './[trpc]';\nimport { z } from 'zod';\n\nexport const appRouter = trpc.router<Context>()\n  .query('infinitePosts', {\n    input: z.object({\n      limit: z.number().min(1).max(100).nullish(),\n      cursor: z.number().nullish(), // <-- \"cursor\" needs to exist, but can be any type\n    }),\n    async resolve({ input }) {\n      const limit = input.limit ?? 50;\n      const { cursor } = input;\n      const items = await prisma.post.findMany({\n        take: limit + 1, // get an extra item at the end which we'll use as next cursor\n        where: {\n          title: {\n            contains: 'Prisma' /* Optional filter */,\n          },\n        },\n        cursor: cursor ? { myCursor: cursor } : undefined,\n        orderBy: {\n          myCursor: 'asc',\n        },\n      })\n      let nextCursor: typeof cursor | undefined = undefined;\n      if (items.length > limit) {\n        const nextItem = items.pop()\n        nextCursor = nextItem!.myCursor;\n      }\n\n      return {\n        items,\n        nextCursor,\n      };\n    })\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperJSON in Next.js tRPC Setup\nDESCRIPTION: TypeScript code to add SuperJSON transformer to tRPC configuration in a Next.js project.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '~/server/routers/_app';\nimport superjson from 'superjson';\n\n// [...]\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config({ ctx }) {\n    return {\n      transformer: superjson, // <--\n    };\n  },\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Setting Up tRPC Context Provider in TypeScript\nDESCRIPTION: Creates a set of type-safe context providers and consumers from the AppRouter type signature. This is useful for server-side rendering scenarios to ensure each request has its own QueryClient.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCContext } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const { TRPCProvider, useTRPC, useTRPCClient } = createTRPCContext<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Split Link\nDESCRIPTION: Demonstrates how to set up a tRPC client using splitLink to conditionally choose between httpLink and httpBatchLink based on a context property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/splitLink.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst url = `http://localhost:3000`;\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // check for context property `skipBatch`\n        return Boolean(op.context.skipBatch);\n      },\n      // when condition is true, use normal request\n      true: httpLink({\n        url,\n      }),\n      // when condition is false, use batching\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using tRPC queries in React components\nDESCRIPTION: Example of a React component that uses a tRPC query hook to fetch data from the API. It demonstrates handling loading states, errors, and displaying the retrieved data.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/next/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\n\nexport function Hello() {\n  const { data, error, status } = trpc.greeting.useQuery({\n    name: 'tRPC',\n  });\n\n  if (error) {\n    return <p>{error.message}</p>;\n  }\n\n  if (status !== 'success') {\n    return <p>Loading...</p>;\n  }\n\n  return <div>{data && <p>{data.greeting}</p>}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Subscription Cleanup Pattern\nDESCRIPTION: Shows how to implement cleanup of side effects in tRPC subscriptions using try...finally pattern.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\n\nconst ee = new EventEmitter();\n\nexport const subRouter = router({\n  onPostAdd: publicProcedure.subscription(async function* (opts) {\n    let timeout;\n    try {\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        timeout = setTimeout(() => console.log('Pretend like this is useful'));\n        const post = data as Post;\n        yield post;\n      }\n    } finally {\n      if (timeout) clearTimeout(timeout);\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding SuperJSON Transformer to tRPC Client\nDESCRIPTION: TypeScript code to configure SuperJSON transformer in the tRPC client creation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport superjson from 'superjson';\n\nexport const client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n      // transformer: superjson\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Subscription Procedure in tRPC Router (TypeScript)\nDESCRIPTION: Demonstrates how to add a subscription procedure to a tRPC router using an EventEmitter. It includes both a subscription and a mutation that triggers the subscription.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/subscriptions.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { EventEmitter } from 'events';\nimport * as trpc from '@trpc/server';\n\n// create a global event emitter (could be replaced by redis, etc)\nconst ee = new EventEmitter();\n\nexport const appRouter = trpc\n  .router()\n  .subscription('onAdd', {\n    resolve({ ctx }) {\n      // `resolve()` is triggered for each client when they start subscribing `onAdd`\n\n      // return a `Subscription` with a callback which is triggered immediately\n      return new trpc.Subscription<Post>((emit) => {\n        const onAdd = (data: Post) => {\n          // emit data to client\n          emit.data(data);\n        };\n\n        // trigger `onAdd()` when `add` is triggered in our event emitter\n        ee.on('add', onAdd);\n\n        // unsubscribe function when client disconnects or stops subscribing\n        return () => {\n          ee.off('add', onAdd);\n        };\n      });\n    },\n  })\n  .mutation('add', {\n    input: z.object({\n      id: z.string().uuid().optional(),\n      text: z.string().min(1),\n    }),\n    async resolve({ ctx, input }) {\n      const post = { ...input }; /* [..] add to db */\n\n      ee.emit('add', post);\n      return post;\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Wrapping Next.js App Component with tRPC\nDESCRIPTION: This snippet demonstrates how to wrap the Next.js App component with tRPC's withTRPC higher-order component. This setup is necessary for tRPC to work properly with server-side rendering in a Next.js application.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/ssr.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\nimport type { AppProps } from 'next/app';\nimport React from 'react';\n\nconst MyApp: AppType = ({ Component, pageProps }: AppProps) => {\n  return <Component {...pageProps} />;\n};\n\nexport default trpc.withTRPC(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router with Procedures in TypeScript\nDESCRIPTION: This snippet demonstrates the creation of a tRPC router with multiple procedures for handling posts. It includes procedures for listing posts, fetching a post by ID, and creating a new post.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/infer-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query((opts) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation((opts) => {\n        // imaginary db call\n        return { id: 1, ...opts.input };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Creating Helper Functions for tRPC Prefetching and Hydration\nDESCRIPTION: This snippet defines helper functions for prefetching tRPC queries and hydrating the React Query client. It includes support for both regular and infinite queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nexport function HydrateClient(props: { children: React.ReactNode }) {\n  const queryClient = getQueryClient();\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      {props.children}\n    </HydrationBoundary>\n  );\n}\n\nexport function prefetch<T extends ReturnType<TRPCQueryOptions<any>>>(\n  queryOptions: T,\n) {\n  const queryClient = getQueryClient();\n  if (queryOptions.queryKey[1]?.type === 'infinite') {\n    void queryClient.prefetchInfiniteQuery(queryOptions as any);\n  } else {\n    void queryClient.prefetchQuery(queryOptions);\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Basic tRPC Router with Query Endpoint\nDESCRIPTION: Implementation of a basic tRPC router with a greeting query procedure. Shows how to create an API endpoint that can be exposed to the frontend through an adapter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/routers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  greeting: publicProcedure.query(() => 'hello tRPC v10!'),\n});\n\n// Export only the type of a router!\n// This prevents us from importing server code on the client.\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Router with Typed Metadata in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a tRPC router with typed metadata. It defines a Meta interface with an 'authRequired' boolean property and initializes the tRPC instance with this metadata type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/metadata.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  authRequired: boolean;\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const appRouter = t.router({\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router with Multiple Procedures (TypeScript)\nDESCRIPTION: Example of a tRPC router definition with 'postById' and 'relatedPosts' procedures. This router is exposed at '/api/trpc' and demonstrates input handling and database queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = t.router({\n  postById: t.procedure.input(String).query(async (opts) => {\n    const post = await opts.ctx.post.findUnique({\n      where: { id: opts.input },\n    });\n    return post;\n  }),\n  relatedPosts: t.procedure.input(String).query(async (opts) => {\n    const posts = await opts.ctx.findRelatedPostsById(opts.input);\n    return posts;\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Formatter in tRPC Server\nDESCRIPTION: Demonstrates how to create a custom error formatter in tRPC server configuration. This implementation adds special handling for Zod validation errors when they occur during bad requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-formatting.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Split Link\nDESCRIPTION: Shows how to set up a tRPC client using splitLink to conditionally choose between httpLink and httpBatchLink based on a context property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/splitLink.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCProxyClient,\n  httpBatchLink,\n  httpLink,\n  splitLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst url = `http://localhost:3000`;\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    splitLink({\n      condition(op) {\n        // check for context property `skipBatch`\n        return op.context.skipBatch === true;\n      },\n      // when condition is true, use normal request\n      true: httpLink({\n        url,\n      }),\n      // when condition is false, use batching\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with HTTP Batch Link\nDESCRIPTION: Demonstrates client-side setup of tRPC with HTTP batch link configuration for making API calls\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n\nconst trpc = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Handling tRPC Errors in React Components\nDESCRIPTION: Shows how to handle and display formatted errors in a React component using tRPC mutation hooks. Specifically demonstrates handling of Zod validation errors.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-formatting.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport function MyComponent() {\n  const mutation = trpc.addPost.useMutation();\n\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Streaming Responses in tRPC v11 with httpBatchStreamLink\nDESCRIPTION: This example shows how to implement streaming responses in tRPC v11 using the new httpBatchStreamLink. It demonstrates creating a server procedure that yields incremental values and a client that consumes the iterable stream.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2025-03-21-announcing-trpc-11.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  examples: {\n    iterable: publicProcedure.query(async function* () {\n      let i = 0;\n      while (true) {\n        await new Promise((resolve) => setTimeout(resolve, 500));\n        yield i++;\n      }\n    }),\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n\n\n// @filename: client.ts\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from './server';\n\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\nconst iterable = await trpc.examples.iterable.query();\n//      ^?\n\nfor await (const value of iterable) {\n  console.log('Iterable:', value);\n  //                         ^?\n}\n```\n\n----------------------------------------\n\nTITLE: Merging Child Routers in tRPC\nDESCRIPTION: Shows how to merge multiple router modules (user and post routers) into a main application router with namespaced routes. Includes complete setup with input validation using Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/merging-routers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router } from '../trpc';\nimport { z } from 'zod';\n\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n\nconst appRouter = router({\n  user: userRouter, // put procedures under \"user\" namespace\n  post: postRouter, // put procedures under \"post\" namespace\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Defining and Merging tRPC Routers in TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates how to structure a tRPC backend by creating separate routers for different concerns (posts, users) and then merging them into a single `appRouter`. It uses a helper `createRouter` function and the `.merge()` method to combine routers, optionally prefixing the procedures within each merged router (e.g., 'user.', 'post.'). The `posts` router includes a mutation ('create') with Zod validation and a query ('list'), while the `users` router has a simple query ('list').\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/merging-routers.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts title='server.ts'\nconst createRouter = () => {\n  return trpc.router<Context>();\n};\n\nconst posts = createRouter()\n  .mutation('create', {\n    input: z.object({\n      title: z.string(),\n    }),\n    resolve: ({ input }) => {\n      // ..\n      return {\n        id: 'xxxx',\n        ...input,\n      };\n    },\n  })\n  .query('list', {\n    resolve() {\n      // ..\n      return [];\n    },\n  });\n\nconst users = createRouter().query('list', {\n  resolve() {\n    // ..\n    return [];\n  },\n});\n\nconst appRouter = createRouter()\n  .merge('user.', users) // prefix user procedures with \"user.\"\n  .merge('post.', posts); // prefix post procedures with \"post.\"\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring Different Upload/Download Transformers in tRPC\nDESCRIPTION: TypeScript code to set up SuperJSON for uploading and Devalue for downloading data in tRPC, optimizing performance while maintaining security.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uneval } from 'devalue';\nimport superjson from 'superjson';\n\n// [...]\n\nexport const transformer = {\n  input: superjson,\n  output: {\n    serialize: (object) => uneval(object),\n    // This `eval` only ever happens on the **client**.\n    deserialize: (object) => (0, eval)(`(${object})`),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Authorized tRPC Procedures with Middleware in TypeScript\nDESCRIPTION: This snippet extends the base procedure pattern by defining an 'authorizedProcedure' that requires an input with a specific string value ('townName' == 'Pucklechurch'). It uses Zod for input validation and introduces custom logic via a middleware that throws a TRPCError for unauthorized users. The resulting procedures ('hello' and 'goodbye') can then only be accessed by authorized users. This demonstrates how to enforce business rules, reuse procedure constructs, and plug in authentication/authorization logic within tRPC routers. Dependencies include '@trpc/server', 'TRPCError', and 'zod'.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\n// @target: esnext\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();\n\nexport const publicProcedure = t.procedure;\n\n// ---cut---\n\nexport const authorizedProcedure = publicProcedure\n  .input(z.object({ townName: z.string() }))\n  .use((opts) => {\n    if (opts.input.townName !== 'Pucklechurch') {\n      throw new TRPCError({\n        code: 'FORBIDDEN',\n        message: \"We don't take kindly to out-of-town folk\",\n      });\n    }\n\n    return opts.next();\n  });\n\nexport const appRouter = t.router({\n  hello: authorizedProcedure.query(() => {\n    return {\n      message: 'hello world',\n    };\n  }),\n  goodbye: authorizedProcedure.mutation(async (opts) => {\n    await opts.ctx.signGuestBook();\n\n    return {\n      message: 'goodbye!',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC useQueries with Custom Context\nDESCRIPTION: Illustrates how to use useQueries with a custom React Query context to override the default context configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQueries.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst [post, greeting] = trpc.useQueries(\n  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],\n  myCustomContext,\n);\n```\n\n----------------------------------------\n\nTITLE: Component-level Prefetching with usePrefetchQuery\nDESCRIPTION: Demonstrates component-level prefetching using usePrefetchQuery to initiate data fetching before rendering a Suspense component. This helps avoid the waterfall effect in data loading.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.byId.usePrefetchQuery({ id: props.postId });\n\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum URL Length for httpBatchLink in tRPC\nDESCRIPTION: This example shows how to set a maximum URL length for batched requests using the maxURLLength option in httpBatchLink. This helps prevent HTTP errors related to excessively long URLs.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n      maxURLLength: 2083, // a suitable size\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Replacing Batch Link with HTTP Link in Client\nDESCRIPTION: Example of using httpLink instead of httpBatchLink to disable batching on the client side.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing httpBatchStreamLink in tRPC Client\nDESCRIPTION: Example showing how to import and configure httpBatchStreamLink in a tRPC client setup. This creates a client that batches requests and streams responses as they become available.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchStreamLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Transformers in tRPC Server Router\nDESCRIPTION: TypeScript code to add custom transformers to the tRPC server router initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { transformer } from '../../utils/trpc';\n\nexport const t = initTRPC.create({\n  transformer,\n});\n\nexport const appRouter = t.router({\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Using tRPC useQuery in React Component\nDESCRIPTION: Example React component demonstrating how to use the useQuery hook with and without arguments to fetch data from the tRPC backend.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  // input is optional, so we don't have to pass second argument\n  const helloNoArgs = trpc.hello.useQuery();\n  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });\n\n  return (\n    <div>\n      <h1>Hello World Example</h1>\n      <ul>\n        <li>\n          helloNoArgs ({helloNoArgs.status}):{' '}\n          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>\n        </li>\n        <li>\n          helloWithArgs ({helloWithArgs.status}):{' '}\n          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>\n        </li>\n      </ul>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Router with Query and Mutation using TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates creating a basic tRPC router using `@trpc/server`. It defines a `getUser` query procedure that accepts a string input and returns a user object. It also defines a `createUser` mutation procedure that uses Zod (`z.object`) to validate an input object containing a name (minimum 5 characters) and interacts with a hypothetical `UserModel` to persist the user. The router's type definition (`AppRouter`) is exported for potential client-side type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/express.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\nconst appRouter = trpc\n  .router()\n  .query('getUser', {\n    input: z.string(),\n    async resolve(req) {\n      req.input; // string\n      return { id: req.input, name: 'Bilbo' };\n    },\n  })\n  .mutation('createUser', {\n    // validate input with Zod\n    input: z.object({ name: z.string().min(5) }),\n    async resolve(req) {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: req.input,\n      });\n    },\n  });\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for Cross-Origin Requests with Cookies in TypeScript\nDESCRIPTION: This code snippet shows how to create a tRPC client that sends cookies in cross-origin requests. It modifies the fetch function used by the httpBatchLink to include credentials in the request options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/cors.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'YOUR_SERVER_URL',\n      fetch(url, options) {\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n        });\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Login Mutation Procedure in tRPC Server\nDESCRIPTION: This snippet demonstrates how to create a tRPC router with a 'login' mutation procedure. It uses Zod for input validation and returns a user object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useMutation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Create procedure at path 'login'\n  // The syntax is identical to creating queries\n  login: t.procedure\n    // using zod schema to validate and infer input values\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      // Here some login stuff would happen\n      return {\n        user: {\n          name: opts.input.name,\n          role: 'ADMIN',\n        },\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Refining Context Types using tRPC Middleware in TypeScript\nDESCRIPTION: This TypeScript snippet illustrates context swapping with a tRPC middleware. It first checks for user existence in the context (`ctx.user`), throwing an 'UNAUTHORIZED' `TRPCError` if null. If the user exists, it passes a refined context to `next()`, ensuring that downstream procedures like 'userId' receive a context where `ctx.user` is guaranteed to be non-nullable, improving type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/middlewares.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\ninterface Context {\n  // user is nullable\n  user?: {\n    id: string;\n  };\n}\n\ntrpc\n  .router<Context>()\n  .middleware(({ ctx, next }) => {\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return next({\n      ctx: {\n        ...ctx,\n        user: ctx.user, // user value is known to be non-null now\n      },\n    });\n  })\n  .query('userId', {\n    async resolve({ ctx }) {\n      return ctx.user.id;\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Implementing Typesafe Conditional Queries using skipToken in tRPC React\nDESCRIPTION: This example demonstrates how to conditionally execute a tRPC query based on the existence of a state variable. By using skipToken from React Query, the query is only executed when the name state variable has a value, maintaining type safety throughout.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/disabling-queries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { skipToken } from '@tanstack/react-query';\n\n\nexport function MyComponent() {\n\nconst [name, setName] = useState<string | undefined>();\n\nconst result = trpc.getUserByName.useQuery(name ? { name: name } : skipToken);\n\n  return (\n    ...\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Server with Greeting Procedure\nDESCRIPTION: Creates a tRPC server instance with a greeting procedure that accepts a name input and returns a greeting string. Uses Zod for input validation and type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/landing-intro/Step3.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport z from 'zod';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => {\n      const { input } = opts;\n      return `Hello ${input.name}` as const;\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC and React Query Providers in React\nDESCRIPTION: Sets up the tRPC client and wraps the application with TRPCProvider and QueryClientProvider. This configuration is necessary for server-side rendering and ensures proper client-side hydration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { useState } from 'react';\nimport { TRPCProvider, useTRPC } from './utils/trpc';\n\nfunction makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        // With SSR, we usually want to set some default staleTime\n        // above 0 to avoid refetching immediately on the client\n        staleTime: 60 * 1000,\n      },\n    },\n  });\n}\n\nlet browserQueryClient: QueryClient | undefined = undefined;\n\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  } else {\n    // Browser: make a new query client if we don't already have one\n    // This is very important, so we don't re-make a new client if React\n    // suspends during the initial render. This may not be needed if we\n    // have a suspense boundary BELOW the creation of the query client\n    if (!browserQueryClient) browserQueryClient = makeQueryClient();\n    return browserQueryClient;\n  }\n}\n\nexport function App() {\n  const queryClient = getQueryClient();\n  const [trpcClient] = useState(() =>\n    createTRPCClient<AppRouter>({\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:2022',\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>\n        {/* Your app here */}\n      </TRPCProvider>\n    </QueryClientProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Executing Batched Queries with Promise.all\nDESCRIPTION: Demonstrates how to batch multiple queries into a single HTTP request using Promise.all. This example fetches multiple posts by their IDs in one network request.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchStreamLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\n```\n\n----------------------------------------\n\nTITLE: Creating Basic tRPC Router\nDESCRIPTION: Implements a basic tRPC router with query and mutation procedures using Zod for input validation. Includes example endpoints for getting and creating users.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/express.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Creating Basic tRPC Router with Greeting Query\nDESCRIPTION: Sets up a tRPC router with a greeting procedure that accepts a name input and returns a typed greeting message. Uses Zod for input validation and demonstrates type inference with TypeScript.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/landing-intro/Step1.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport z from 'zod';\n\nconst t = initTRPC.create();\n\nconst router = t.router;\nconst publicProcedure = t.procedure;\n\nconst appRouter = router({\n  greeting: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => {\n      const { input } = opts;\n      //      ^?\n\n      return `Hello ${input.name}` as const;\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Server with API Response Caching\nDESCRIPTION: Demonstrates server-side implementation of tRPC with response caching. Includes context creation, router setup with a slow query example, and cache control configuration for public routes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/caching.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nexport const t = initTRPC.context<Context>().create();\n\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const appRouter = t.router({\n  public: t.router({\n    slowQueryCached: t.procedure.query(async (opts) => {\n      await waitFor(5000); // wait for 5s\n\n      return {\n        lastUpdated: new Date().toJSON(),\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta(opts) {\n    const { ctx, paths, errors, type } = opts;\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    const allOk = errors.length === 0;\n    const isQuery = type === 'query';\n\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: new Headers([\n          [\n            'cache-control',\n            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n          ],\n        ]),\n      };\n    }\n    return {};\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Merging with Child Routers in tRPC\nDESCRIPTION: This snippet demonstrates how to merge routers using child routers in tRPC. It shows the setup of a main app router that incorporates user and post routers as namespaces.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router } from '../trpc';\nimport { z } from 'zod';\n\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n\nconst appRouter = router({\n  user: userRouter, // put procedures under \"user\" namespace\n  post: postRouter, // put procedures under \"post\" namespace\n});\n\n// You can then access the merged route with\n// http://localhost:3000/trpc/<NAMESPACE>.<PROCEDURE>\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Cloudflare Worker tRPC Setup\nDESCRIPTION: Configuration for running tRPC server in Cloudflare Workers environment.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nexport default {\n  async fetch(request: Request): Promise<Response> {\n    return fetchRequestHandler({\n      endpoint: '/trpc',\n      req: request,\n      router: appRouter,\n      createContext,\n    });\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing Batch Queries with Promise.all\nDESCRIPTION: Example of using Promise.all to batch multiple queries into a single HTTP request, optimizing database queries and network requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseQueries for Multiple Concurrent Queries\nDESCRIPTION: Demonstrates how to use useSuspenseQueries to fetch multiple posts concurrently with React Suspense. This is the suspense equivalent of useQueries for fetching multiple resources.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = (props: { postIds: string[] }) => {\n  const [posts, postQueries] = trpc.useSuspenseQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n\n  return <>{/* [...] */}</>;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js _app.tsx with tRPC HOC\nDESCRIPTION: Next.js _app.tsx configuration that wraps the application with the tRPC withTRPC Higher-Order Component to enable tRPC functionality throughout the app.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppType } from 'next/app';\nimport { trpc } from '../utils/trpc';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default trpc.withTRPC(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Astro tRPC Integration\nDESCRIPTION: Implementation of tRPC endpoint handler for Astro framework using the fetch adapter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIRoute } from 'astro';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\n\nexport const all: APIRoute = (opts) => {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: opts.request,\n    router: appRouter,\n    createContext,\n  });\n};\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Router with Query and Mutation Procedures\nDESCRIPTION: A sample tRPC router implementation with three procedures: two query procedures for fetching posts and one mutation procedure for creating posts. This router serves as the example backend that our client will connect to.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype Post = { id: string; title: string };\nconst posts: Post[] = [];\n\nconst appRouter = router({\n  post: router({\n    byId: publicProcedure\n      .input(z.object({ id: z.string() }))\n      .query(({ input }) => {\n        const post = posts.find((p) => p.id === input.id);\n        if (!post) throw new TRPCError({ code: \"NOT_FOUND\" });\n        return post;\n      }),\n    byTitle: publicProcedure\n      .input(z.object({ title: z.string() }))\n      .query(({ input }) => {\n        const post = posts.find((p) => p.title === input.title);\n        if (!post) throw new TRPCError({ code: \"NOT_FOUND\" });\n        return post;\n      }),\n    create: publicProcedure\n      .input(z.object({ title: z.string() }))\n      .mutation(({ input }) => {\n        const post = { id: uuid(), ...input };\n        posts.push(post);\n        return post;\n      }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom tRPC Link\nDESCRIPTION: Demonstrates how to create a custom tRPC link that logs operations and their results. Implements the TRPCLink interface with full observability pattern.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TRPCLink } from '@trpc/client';\nimport { observable } from '@trpc/server/observable';\nimport type { AppRouter } from 'server/routers/_app';\n\nexport const customLink: TRPCLink<AppRouter> = () => {\n  // here we just got initialized in the app - this happens once per app\n  // useful for storing cache for instance\n  return ({ next, op }) => {\n    // this is when passing the result to the next link\n\n    // each link needs to return an observable which propagates results\n    return observable((observer) => {\n      console.log('performing operation:', op);\n      const unsubscribe = next(op).subscribe({\n        next(value) {\n          console.log('we received value', value);\n          observer.next(value);\n        },\n        error(err) {\n          console.log('we received error', err);\n          observer.error(err);\n        },\n        complete() {\n          observer.complete();\n        },\n      });\n\n      return unsubscribe;\n    });\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Creating Custom HTTP Server with tRPC Handler in TypeScript\nDESCRIPTION: This code demonstrates how to create a custom HTTP server using Node.js's built-in http module and integrate it with a tRPC handler. It allows for more flexibility in request handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\n\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext() {\n    return {};\n  },\n});\n\ncreateServer((req, res) => {\n  /**\n   * Handle the request however you like,\n   * just call the tRPC handler when you're ready\n   */\n\n  handler(req, res);\n}).listen(3001);\n```\n\n----------------------------------------\n\nTITLE: Logging Procedure Execution Time with tRPC Middleware in TypeScript\nDESCRIPTION: This TypeScript example shows how to add a logging middleware to a tRPC router. It records the start time, executes the next middleware or procedure using `await next()`, calculates the duration, and logs details like path, type, and duration using a mock logging function (`logMock`). The middleware applies to all subsequent procedures ('foo', 'abc') in the router chain.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/middlewares.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\ntrpc\n  .router<Context>()\n  .middleware(async ({ path, type, next }) => {\n    const start = Date.now();\n    const result = await next();\n    const durationMs = Date.now() - start;\n    result.ok\n      ? logMock('OK request timing:', { path, type, durationMs })\n      : logMock('Non-OK request timing', { path, type, durationMs });\n\n    return result;\n  })\n  .query('foo', {\n    resolve() {\n      return 'bar';\n    },\n  })\n  .query('abc', {\n    resolve() {\n      return 'def';\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Batching Multiple Queries in TypeScript with tRPC\nDESCRIPTION: Demonstrates how to batch multiple queries into a single HTTP request using tRPC's automatic request batching feature.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst somePosts = await Promise.all([\n  client.query('post.byId', 1),\n  client.query('post.byId', 2),\n  client.query('post.byId', 3),\n]);\n```\n\n----------------------------------------\n\nTITLE: Using useQuery Hook in React Component\nDESCRIPTION: This frontend code snippet shows how to use the useQuery hook in a React component. It demonstrates querying with and without arguments and rendering the results.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  // input is optional, so we don't have to pass second argument\n  const helloNoArgs = trpc.hello.useQuery();\n  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });\n\n  return (\n    <div>\n      <h1>Hello World Example</h1>\n      <ul>\n        <li>\n          helloNoArgs ({helloNoArgs.status}):{' '}\n          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>\n        </li>\n        <li>\n          helloWithArgs ({helloWithArgs.status}):{' '}\n          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>\n        </li>\n      </ul>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Batching Multiple tRPC Procedure Calls with Promise.all\nDESCRIPTION: Example demonstrating how to batch multiple tRPC procedure calls into a single HTTP request using Promise.all. This will execute exactly one HTTP request and one database query for all three operations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchStreamLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst somePosts = await Promise.all([\n  trpc.post.byId.query(1),\n  trpc.post.byId.query(2),\n  trpc.post.byId.query(3),\n]);\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging Middleware in tRPC\nDESCRIPTION: This snippet demonstrates how to create a logging middleware that automatically logs timings for queries. It uses the Date.now() function to calculate the duration of each procedure execution.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n\n\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n\ndeclare function logMock(...args: any[]): void;\n\nexport const loggedProcedure = publicProcedure.use(async (opts) => {\n  const start = Date.now();\n\n  const result = await opts.next();\n\n  const durationMs = Date.now() - start;\n  const meta = { path: opts.path, type: opts.type, durationMs };\n\n  result.ok\n    ? console.log('OK request timing:', meta)\n    : console.error('Non-OK request timing', meta);\n\n  return result;\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Context and Protected Procedures in tRPC\nDESCRIPTION: Provides a comprehensive example of implementing context, including creating context, initializing tRPC, and defining protected procedures. It demonstrates how to use session information for authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: context.ts\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n\n/**\n * Creates context for an incoming request\n * @see https://trpc.io/docs/context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = await getSession({ req: opts.req });\n\n  return {\n    session,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n\n// @filename: trpc.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { Context } from './context';\n\nconst t = initTRPC.context<Context>().create();\n\n\nexport const router = t.router;\n\n/**\n * Unprotected procedure\n */\nexport const publicProcedure = t.procedure;\n\n/**\n * Protected procedure\n */\nexport const protectedProcedure = t.procedure.use(function isAuthed(opts) {\n  if (!opts.ctx.session?.user?.email) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n    });\n  }\n  return opts.next({\n    ctx: {\n      // Infers the `session` as non-nullable\n      session: opts.ctx.session,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Route-level Prefetching for Suspense Queries\nDESCRIPTION: Shows how to implement route-level prefetching with tRPC to support the render-as-you-fetch pattern. This approach prefetches data during route transitions for better perceived performance.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nconst utils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n\n// tanstack router/ react router loader\nconst loader = async (params: { id: string }) =>\n  utils.post.byId.ensureQueryData({ id: params.id });\n```\n\n----------------------------------------\n\nTITLE: Basic Server-Side Caller Example in tRPC\nDESCRIPTION: Demonstrates creating a basic tRPC router with post management functionality and using createCallerFactory to make server-side calls. Shows how to add and list posts using the caller.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\ntype Context = {\n  foo: string;\n};\n\nconst t = initTRPC.context<Context>().create();\n\nconst publicProcedure = t.procedure;\nconst { createCallerFactory, router } = t;\n\ninterface Post {\n  id: string;\n  title: string;\n}\nconst posts: Post[] = [\n  {\n    id: '1',\n    title: 'Hello world',\n  },\n];\nconst appRouter = router({\n  post: router({\n    add: publicProcedure\n      .input(\n        z.object({\n          title: z.string().min(2),\n        }),\n      )\n      .mutation((opts) => {\n        const post: Post = {\n          ...opts.input,\n          id: `${Math.random()}`,\n        };\n        posts.push(post);\n        return post;\n      }),\n    list: publicProcedure.query(() => posts),\n  }),\n});\n\nconst createCaller = createCallerFactory(appRouter);\n\nconst caller = createCaller({\n  foo: 'bar',\n});\n\nconst addedPost = await caller.post.add({\n  title: 'How to make server-side call in tRPC',\n});\n\nconst postList = await caller.post.list();\n```\n\n----------------------------------------\n\nTITLE: Implementing Authorization Middleware in tRPC\nDESCRIPTION: This snippet demonstrates how to create an authorization middleware that ensures a user is an admin before executing a procedure. It uses the TRPCError to throw an UNAUTHORIZED error if the user is not an admin.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TRPCError, initTRPC } from '@trpc/server';\n\ninterface Context {\n  user?: {\n    id: string;\n    isAdmin: boolean;\n    // [..]\n  };\n}\n\nconst t = initTRPC.context<Context>().create();\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n\nexport const adminProcedure = publicProcedure.use(async (opts) => {\n  const { ctx } = opts;\n  if (!ctx.user?.isAdmin) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Server-Side Helpers with Internal Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to create server-side helpers using an internal tRPC router. It includes setting up the context and optional superjson transformer.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/server-side-helpers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from '~/server/context';\nimport superjson from 'superjson';\n\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n  transformer: superjson, // optional - adds superjson serialization\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Route-Specific Authentication with Metadata\nDESCRIPTION: Example showing how to implement authentication checks using metadata. Creates protected and public routes with different authentication requirements using custom procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/metadata.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  authRequired: boolean;\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const authedProcedure = t.procedure.use(async (opts) => {\n  const { meta, next, ctx } = opts;\n  // only check authorization if enabled\n  if (meta?.authRequired && !ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next();\n});\n\nexport const appRouter = t.router({\n  hello: authedProcedure.meta({ authRequired: false }).query(() => {\n    return {\n      greeting: 'hello world',\n    };\n  }),\n  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {\n    return {\n      greeting: 'hello-world',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Initialize tRPC Server Instance\nDESCRIPTION: Creates and exports the base tRPC router and procedure instances that will be used throughout the application.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Setting up API Routes with Fetch Adapter in Next.js\nDESCRIPTION: Implements Next.js route handlers that expose the tRPC API through GET and POST HTTP methods. Uses the fetchRequestHandler adapter to handle tRPC requests at the /api/trpc path.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createTRPCContext } from '~/trpc/init';\nimport { appRouter } from '~/trpc/routers/_app';\n\nconst handler = (req: Request) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req,\n    router: appRouter,\n    createContext: createTRPCContext,\n  });\n\nexport { handler as GET, handler as POST };\n```\n\n----------------------------------------\n\nTITLE: tRPC Authorization Using Resolver\nDESCRIPTION: Example of implementing authorization checks directly in tRPC procedure resolvers, showing both public and protected endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/authorization.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\n\nexport const t = initTRPC.context<Context>().create();\n\nconst appRouter = t.router({\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  secret: t.procedure.query((opts) => {\n    if (!opts.ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return {\n      secret: 'sauce',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating tRPC Router into Express.js using the Adapter\nDESCRIPTION: This TypeScript code demonstrates how to integrate a pre-defined tRPC `appRouter` into an Express.js application. It imports the necessary adapter from `@trpc/server/adapters/express`, defines a basic `createContext` function (which provides context to resolvers, here returning an empty object), initializes an Express app, and uses the `createExpressMiddleware` function to mount the tRPC router onto the Express app at the `/trpc` endpoint. Finally, it starts the Express server listening on port 4000.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/express.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpcExpress from '@trpc/server/adapters/express';\n\nconst appRouter = /* ... */;\n\nconst app = express();\n\n// created for each request\nconst createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => ({}) // no context\ntype Context = trpc.inferAsyncReturnType<typeof createContext>;\n\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  })\n);\n\napp.listen(4000);\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom tRPC Link\nDESCRIPTION: Implementation of a custom tRPC link that logs operations and their results. The example demonstrates the three-part structure of a link function and how to properly handle observable operations in the link chain.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/overview.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { TRPCLink } from '@trpc/client';\nimport { observable } from '@trpc/server/observable';\nimport type { AppRouter } from '~/server/routers/_app';\n\nexport const customLink: TRPCLink<AppRouter> = () => {\n  // here we just got initialized in the app - this happens once per app\n  // useful for storing cache for instance\n  return ({ next, op }) => {\n    // this is when passing the result to the next link\n\n    // each link needs to return an observable which propagates results\n    return observable((observer) => {\n      console.log('performing operation:', op);\n      const unsubscribe = next(op).subscribe({\n        next(value) {\n          console.log('we received value', value);\n          observer.next(value);\n        },\n        error(err) {\n          console.log('we received error', err);\n          observer.error(err);\n        },\n        complete() {\n          observer.complete();\n        },\n      });\n\n      return unsubscribe;\n    });\n  };\n};\n```\n\n----------------------------------------\n\nTITLE: Invoking tRPC Mutation in a React Component - TypeScript/React\nDESCRIPTION: Demonstrates usage of the tRPC useMutation hook inside a React functional component written in TypeScript/TSX. The hook is used to handle a 'login' mutation, with React state handling for loading and error conditions. The trpc object (imported from app utilities) is required for accessing typed hooks. When the login button is clicked, the handler mutates with a hardcoded name value. Inputs include the user's name, and the output is managed by mutation object properties (e.g., isLoading, error).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useMutation.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\\n\\nexport function MyComponent() {\\n  // This can either be a tuple ['login'] or string 'login'\\n  const mutation = trpc.useMutation(['login']);\\n\\n  const handleLogin = async () => {\\n    const name = 'John Doe';\\n\\n    mutation.mutate({ name });\\n  };\\n\\n  return (\\n    <div>\\n      <h1>Login Form</h1>\\n      <button onClick={handleLogin} disabled={mutation.isLoading}>\\n        Login\\n      </button>\\n\\n      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}\\n    </div>\\n  );\\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Query with Zod Input Validation in TypeScript\nDESCRIPTION: This snippet shows how to define a tRPC query procedure ('hello') that uses Zod for input validation. It defines an input schema allowing an optional object with an optional 'text' string property. The `resolve` function uses the validated `input` to construct a dynamic greeting, defaulting to 'world' if text is not provided. It also exports the router's type (`AppRouter`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/router.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\n// [...] \n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  input: z\n    .object({\n      text: z.string().nullish(),\n    })\n    .nullish(),\n  resolve({ input }) {\n    return {\n      greeting: `hello ${input?.text ?? 'world'}`,\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Creating Context for HTTP Requests in tRPC\nDESCRIPTION: Shows how to create context for HTTP requests using createHTTPHandler. The createContext function is passed to the handler that mounts the appRouter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nimport { createContext } from './context';\nimport { createCaller } from './router';\n\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Using Logging Middleware in tRPC Router\nDESCRIPTION: This snippet shows how to use the previously defined loggedProcedure in a tRPC router. It creates an appRouter with two queries that use the logging middleware.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { loggedProcedure, router } from './trpc';\n\nexport const appRouter = router({\n  foo: loggedProcedure.query(() => 'bar'),\n  abc: loggedProcedure.query(() => 'def'),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Query Options to Prevent Refetching\nDESCRIPTION: Example showing how to configure tRPC to disable automatic refetching on mount and window focus for queries. This is useful when working with SSG to avoid unnecessary API calls when data is already available from getStaticProps.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssg.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst data = trpc.example.useQuery(\n  // if your query takes no input, make sure that you don't\n  // accidentally pass the query options as the first argument\n  undefined,\n  { refetchOnMount: false, refetchOnWindowFocus: false },\n);\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC in Vercel Edge Runtime\nDESCRIPTION: Sets up tRPC request handling in a Vercel Edge Runtime environment using the fetch adapter. Adds an event listener for handling fetch events.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\naddEventListener('fetch', (event) => {\n  return event.respondWith(\n    fetchRequestHandler({\n      endpoint: '/trpc',\n      req: event.request,\n      router: appRouter,\n      createContext,\n    }),\n  );\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Nested tRPC Router with zod Input Validation (TSX)\nDESCRIPTION: Illustrates the construction of a hierarchical tRPC router using the router function and input validation via zod. This snippet demonstrates attaching middleware (publicProcedure), specifying input schemas, and implementing a query resolver. Key dependencies: tRPC core (router, publicProcedure) and zod for schema validation. The input parameter is an object with a numeric id; the output is a user object with matching id. Used as part of documenting query key shape changes with the proxy client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nexport const appRouter = router({\\n  user: router({\\n    byId: publicProcedure\\n      .input(z.object({ id: z.number() }))\\n      .query((opts) => ({ user: { id: opts.input.id } })),\\n  }),\\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Logging Middleware in tRPC (TypeScript)\nDESCRIPTION: This snippet defines a `loggedProcedure` middleware in tRPC. It wraps procedure execution, records the start time, awaits the result using `opts.next()`, calculates the duration, and logs metadata (path, type, duration). It differentiates logging based on whether the result was successful (`result.ok`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n```twoslash include trpclogger\nimport { initTRPC } from '@trpc/server';\nconst t = initTRPC.create();\n\n\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n\ndeclare function logMock(...args: any[]): void;\n// ---cut---\n\nexport const loggedProcedure = publicProcedure.use(async (opts) => {\n  const start = Date.now();\n\n  const result = await opts.next();\n\n  const durationMs = Date.now() - start;\n  const meta = { path: opts.path, type: opts.type, durationMs };\n\n  result.ok\n    ? console.log('OK request timing:', meta)\n    : console.error('Non-OK request timing', meta);\n\n  return result;\n});\n```\n```\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @include: trpclogger\n```\n```\n\n----------------------------------------\n\nTITLE: Next.js API Handler for tRPC\nDESCRIPTION: Creates a Next.js API handler that integrates with tRPC router for handling API requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { appRouter } from '../../../server/routers/_app';\n\n// export API handler\n// @link https://trpc.io/docs/server/adapters\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext: () => ({}),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Link for tRPC Client in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a tRPC client using wsLink and createWSClient. It sets up a WebSocket connection to a local server and creates a tRPC proxy client with the configured link.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/wsLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst wsClient = createWSClient({\n  url: 'ws://localhost:3000',\n});\n\nconst trpcClient = createTRPCProxyClient<AppRouter>({\n  links: [wsLink<AppRouter>({ client: wsClient })],\n});\n```\n\n----------------------------------------\n\nTITLE: Next.js API Endpoint with tRPC Caller\nDESCRIPTION: Shows how to use tRPC caller in a Next.js API endpoint with error handling for custom endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TRPCError } from '@trpc/server';\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\nimport { appRouter } from '~/server/routers/_app';\nimport type { NextApiRequest, NextApiResponse } from 'next';\n\ntype ResponseData = {\n  data?: {\n    postTitle: string;\n  };\n  error?: {\n    message: string;\n  };\n};\n\nexport default async (\n  req: NextApiRequest,\n  res: NextApiResponse<ResponseData>,\n) => {\n  const postId = `this-id-does-not-exist-${Math.random()}`;\n\n  const caller = appRouter.createCaller({});\n\n  try {\n    const postResult = await caller.post.byId({ id: postId });\n\n    res.status(200).json({ data: { postTitle: postResult.title } });\n  } catch (cause) {\n    if (cause instanceof TRPCError) {\n      const httpStatusCode = getHTTPStatusCodeFromError(cause);\n\n      res.status(httpStatusCode).json({ error: { message: cause.message } });\n      return;\n    }\n\n    res.status(500).json({\n      error: { message: `Error while accessing post with ID ${postId}` },\n    });\n  }\n};\n```\n\n----------------------------------------\n\nTITLE: Building Generic Components with Router Factory Types\nDESCRIPTION: Shows how to create generic, reusable components that accept router instances as props. This approach allows for component reuse across different parts of the application that use similar router patterns.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @noErrors\n// ---cut---\nimport type { MyRouterLike, MyRouterUtilsLike, trpc, useUtils } from './trpc';\n\ntype MyGenericComponentProps = {\n  route: MyRouterLike;\n  utils: MyRouterUtilsLike;\n};\n\nfunction MyGenericComponent(props: MyGenericComponentProps) {\n  const { route } = props;\n  const thing = route.listThings.useQuery({\n    filter: 'qwerty',\n  });\n\n  const mutation = route.doThing.useMutation({\n    onSuccess() {\n      props.utils.listThings.invalidate();\n    },\n  });\n\n  function handleClick() {\n    mutation.mutate({\n      name: 'Thing 1',\n    });\n  }\n\n  return; /* ui */\n}\n\nfunction MyPageComponent() {\n  const utils = useUtils();\n\n  return (\n    <MyGenericComponent\n      route={trpc.deep.route.things}\n      utils={utils.deep.route.things}\n    />\n  );\n}\n\nfunction MyOtherPageComponent() {\n  const utils = useUtils();\n\n  return (\n    <MyGenericComponent\n      route={trpc.different.things}\n      utils={utils.different.things}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC App Router\nDESCRIPTION: Defines the main tRPC router with a sample 'hello' procedure that accepts text input and returns a greeting.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\nimport { baseProcedure, createTRPCRouter } from '../init';\n\nexport const appRouter = createTRPCRouter({\n  hello: baseProcedure\n    .input(\n      z.object({\n        text: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input.text}`,\n      };\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Basic tRPC Router in TypeScript\nDESCRIPTION: Example of creating a basic tRPC router with user management functionality using Zod for input validation. Implements getUserById query and createUser mutation operations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './context';\n\ntype User = {\n  id: string;\n  name: string;\n  bio?: string;\n};\n\nconst users: Record<string, User> = {};\n\nexport const t = initTRPC.context<Context>().create();\n\nexport const appRouter = t.router({\n  getUserById: t.procedure.input(z.string()).query((opts) => {\n    return users[opts.input];\n  }),\n  createUser: t.procedure\n    .input(\n      z.object({\n        name: z.string().min(3),\n        bio: z.string().max(142).optional(),\n      }),\n    )\n    .mutation((opts) => {\n      const id = Date.now().toString();\n      const user: User = { id, ...opts.input };\n      users[user.id] = user;\n      return user;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Middleware-Based Authorization in tRPC\nDESCRIPTION: Demonstrates how to use tRPC middleware for authorization, protecting multiple procedures with a single middleware check for admin users.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/authorization.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { TRPCError } from '@trpc/server';\nimport { createRouter } from '../createRouter';\n\nexport const appRouter = createRouter()\n  .query('hello', {\n    input: z.string().nullish(),\n    resolve: ({ input, ctx }) => {\n      return `hello ${input ?? ctx.user?.name ?? 'world'}`;\n    },\n  })\n  .merge(\n    'admin.',\n    createRouter()\n      .middleware(async ({ ctx, next }) => {\n        if (!ctx.user?.isAdmin) {\n          throw new TRPCError({ code: 'UNAUTHORIZED' });\n        }\n        return next();\n      })\n      .query('secret', {\n        resolve: ({ ctx }) => {\n          return {\n            secret: 'sauce',\n          };\n        },\n      }),\n  );\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Suspense Query Hook in Next.js Client Component\nDESCRIPTION: This snippet demonstrates the usage of the useSuspenseQuery hook from tRPC in a Next.js client component. It shows how to fetch data with Suspense, allowing for simpler loading state management.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\nimport { trpc } from '~/trpc/client';\n\nexport function ClientGreeting() {\n  const [data] = trpc.hello.useSuspenseQuery();\n  return <div>{data.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js tRPC Client without Batching\nDESCRIPTION: Implementation example of creating a Next.js tRPC client without request batching using httpLink.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpLink({\n          url: '/api/trpc',\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Server-Side Helpers with External Router in TypeScript\nDESCRIPTION: This code shows how to set up server-side helpers using an external tRPC router. It creates a proxy client with an HTTP batch link to connect to the API.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/server-side-helpers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient } from '@trpc/client';\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport superjson from 'superjson';\n\nconst proxyClient = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/api/trpc',\n    }),\n  ],\n});\n\nconst helpers = createServerSideHelpers({\n  client: proxyClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Integration Testing with tRPC Caller\nDESCRIPTION: Shows how to use the caller in integration tests to verify post creation and retrieval functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inferProcedureInput } from '@trpc/server';\nimport { createContextInner } from '../context';\nimport { AppRouter, createCaller } from './_app';\n\ntest('add and get post', async () => {\n  const ctx = await createContextInner({});\n  const caller = createCaller(ctx);\n\n  const input: inferProcedureInput<AppRouter['post']['add']> = {\n    text: 'hello test',\n    title: 'hello test',\n  };\n\n  const post = await caller.post.add(input);\n  const byId = await caller.post.byId({ id: post.id });\n\n  expect(byId).toMatchObject(input);\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up Standalone tRPC Server in TypeScript\nDESCRIPTION: This code sets up a standalone tRPC server using the createHTTPServer function from @trpc/server/adapters/standalone. It creates an HTTP server that listens on port 2022 and uses the appRouter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/standalone.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './appRouter.ts';\n\ncreateHTTPServer({\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n}).listen(2022);\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Infinite Query Procedure\nDESCRIPTION: Server-side implementation of an infinite query procedure using tRPC and Prisma. The procedure handles cursor-based pagination with customizable limits and filtering.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './[trpc]';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  infinitePosts: t.procedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(100).nullish(),\n        cursor: z.number().nullish(), // <-- \"cursor\" needs to exist, but can be any type\n      }),\n    )\n    .query(async (opts) => {\n      const { input } = opts;\n      const limit = input.limit ?? 50;\n      const { cursor } = input;\n      const items = await prisma.post.findMany({\n        take: limit + 1, // get an extra item at the end which we'll use as next cursor\n        where: {\n          title: {\n            contains: 'Prisma' /* Optional filter */,\n          },\n        },\n        cursor: cursor ? { myCursor: cursor } : undefined,\n        orderBy: {\n          myCursor: 'asc',\n        },\n      });\n      let nextCursor: typeof cursor | undefined = undefined;\n      if (items.length > limit) {\n        const nextItem = items.pop();\n        nextCursor = nextItem!.myCursor;\n      }\n\n      return {\n        items,\n        nextCursor,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Leveraging Suspense with tRPC and React Query in Next.js\nDESCRIPTION: This snippet shows how to use Suspense and Error Boundaries with tRPC and React Query in a Next.js application. It demonstrates prefetching and handling loading and error states.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\n\nexport default async function Home() {\n  prefetch(trpc.hello.queryOptions());\n\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: WebSocket Link and Client Options Interface Definition\nDESCRIPTION: Details the TypeScript interfaces for configuring wsLink and createWSClient. These interfaces define all available configuration options including URL, connection parameters, retry logic, event handlers, lazy mode, and keepalive functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/wsLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WebSocketLinkOptions {\n  client: TRPCWebSocketClient;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n}\n\nfunction createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient\n\n\nexport interface WebSocketClientOptions {\n  /**\n   * The URL to connect to (can be a function that returns a URL)\n   */\n  url: string | (() => MaybePromise<string>);\n  /**\n   * Connection params that are available in `createContext()`\n   * These are sent as the first message\n   */\n  connectionParams: string | (() => MaybePromise<string>);\n  /**\n   * Ponyfill which WebSocket implementation to use\n   */\n  WebSocket?: typeof WebSocket;\n  /**\n   * The number of milliseconds before a reconnect is attempted.\n   * @default {@link exponentialBackoff}\n   */\n  retryDelayMs?: typeof exponentialBackoff;\n  /**\n   * Triggered when a WebSocket connection is established\n   */\n  onOpen?: () => void;\n  /**\n   * Triggered when a WebSocket connection encounters an error\n   */\n  onError?: (evt?: Event) => void;\n  /**\n   * Triggered when a WebSocket connection is closed\n   */\n  onClose?: (cause?: { code?: number }) => void;\n  /**\n   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)\n   */\n  lazy?: {\n    /**\n     * Enable lazy mode\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Close the WebSocket after this many milliseconds\n     * @default 0\n     */\n    closeMs: number;\n  };\n  /**\n   * Send ping messages to the server and kill the connection if no pong message is returned\n   */\n  keepAlive?: {\n    /**\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Send a ping message every this many milliseconds\n     * @default 5_000\n     */\n    intervalMs?: number;\n    /**\n     * Close the WebSocket after this many milliseconds if the server does not respond\n     * @default 1_000\n     */\n    pongTimeoutMs?: number;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Inferring TRPCClientError Type for Error Handling in TypeScript\nDESCRIPTION: This snippet demonstrates how to infer and use the TRPCClientError type for proper error handling in tRPC client code. It includes a type guard function and an example of using it in a try-catch block.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/infer-types.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: client.ts\nimport { TRPCClientError } from '@trpc/client';\nimport type { AppRouter } from './server';\nimport { trpc } from './trpc';\n\nexport function isTRPCClientError(\n  cause: unknown,\n): cause is TRPCClientError<AppRouter> {\n  return cause instanceof TRPCClientError;\n}\n\nasync function main() {\n  try {\n    await trpc.post.byId.query('1');\n  } catch (cause) {\n    if (isTRPCClientError(cause)) {\n      // `cause` is now typed as your router's `TRPCClientError`\n      console.log('data', cause.data);\n      //                        ^?\n    } else {\n      // [...]\n    }\n  }\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Defining a Mutation Procedure in tRPC Server\nDESCRIPTION: This snippet shows how to create a mutation procedure named 'login' using tRPC on the server side. It uses Zod for input validation and returns a user object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useMutation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Create procedure at path 'login'\n  // The syntax is identical to creating queries\n  login: t.procedure\n    // using zod schema to validate and infer input values\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      // Here some login stuff would happen\n      return {\n        user: {\n          name: opts.input.name,\n          role: 'ADMIN',\n        },\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Query Endpoint to tRPC Router\nDESCRIPTION: Demonstrates how to add a query endpoint to a tRPC router. This example includes input validation and a resolver function for a 'getUser' query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/quickstart.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\n\nconst appRouter = trpc.router().query('getUser', {\n  input: (val: unknown) => {\n    if (typeof val === 'string') return val;\n    throw new Error(`Invalid input: ${typeof val}`);\n  },\n  async resolve(req) {\n    req.input; // string\n    return { id: req.input, name: 'Bilbo' };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Query Key Helpers Function Signatures in tRPC\nDESCRIPTION: Type definitions for the getQueryKey helper function that can be used with procedures or routers to generate the correct query keys for React Query operations. Includes different query types for standard, infinite, or any queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/getQueryKey.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Queries\nfunction getQueryKey(\n  procedure: AnyQueryProcedure,\n  input?: DeepPartial<TInput>,\n  type?: QueryType; /** @default 'any' */\n): TRPCQueryKey;\n\n// Routers\nfunction getQueryKey(\n  router: AnyRouter,\n): TRPCQueryKey;\n\ntype QueryType = \"query\" | \"infinite\" | \"any\";\n// for useQuery ──┘         │            │\n// for useInfiniteQuery ────┘            │\n// will match all ───────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Custom Headers\nDESCRIPTION: Sets up a tRPC client configuration with custom headers support using httpBatchLink. Implements a token management system and configures dynamic header injection for authentication purposes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/headers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Import the router type from your server file\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nlet token: string;\n\nexport function setToken(newToken: string) {\n  /**\n   * You can also save the token to cookies, and initialize from\n   * cookies above.\n   */\n  token = newToken;\n}\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      links: [\n        httpBatchLink({\n          url: 'http://localhost:3000/api/trpc',\n          /**\n           * Headers will be called on each request.\n           */\n          headers() {\n            return {\n              Authorization: token,\n            };\n          },\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Router with Query and Mutation (TypeScript)\nDESCRIPTION: This TypeScript snippet defines a tRPC router with a 'getUserById' query and a 'createUser' mutation, using Zod for input validation and in-memory storage for users. The router is exported as appRouter alongside its type definition (AppRouter), and must be placed in a file typically named 'router.ts'. Parameters include input schema validation and async resolver functions, returning single user objects or creating new ones. The approach encourages expansion to modular subrouters if the root router grows large.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\ntype User = {\n  id: string;\n  name: string;\n  bio?: string;\n};\n\nconst users: Record<string, User> = {};\n\nexport const appRouter = trpc\n  .router()\n  .query('getUserById', {\n    input: z.string(),\n    async resolve({ input }) {\n      return users[input]; // input type is string\n    },\n  })\n  .mutation('createUser', {\n    // validate input with Zod\n    input: z.object({\n      name: z.string().min(3),\n      bio: z.string().max(142).optional(),\n    }),\n    async resolve({ input }) {\n      const id = Date.now().toString();\n      const user: User = { id, ...input };\n      users[user.id] = user;\n      return user;\n    },\n  });\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Setting Up tRPC React Integration with Type Inference\nDESCRIPTION: Creates a tRPC client for React with type inference helpers. Demonstrates how to infer React Query options, router inputs, and router outputs from the AppRouter type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @filename: trpc.ts\n// ---cut---\nimport {\n  createTRPCReact,\n  type inferReactQueryProcedureOptions,\n} from '@trpc/react-query';\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n\n// infer the types for your router\nexport type ReactQueryOptions = inferReactQueryProcedureOptions<AppRouter>;\nexport type RouterInputs = inferRouterInputs<AppRouter>;\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Query Output Validation with Zod in TypeScript\nDESCRIPTION: This snippet demonstrates defining a tRPC query named 'hello' using Zod for output validation. It specifies that the output must be an object containing a 'greeting' property of type string using `z.object`. The `resolve` function returns an object matching this structure, and the router type `AppRouter` is exported.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/output-validation.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\n// [...]\n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  output: z.object({\n    greeting: z.string(),\n  }),\n  // expects return type of { greeting: string }\n  resolve() {\n    return {\n      greeting: 'hello!',\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Handling tRPC Requests in Remix Route with Fetch Adapter\nDESCRIPTION: This code defines Remix loader and action functions within a route file (`app/routes/trpc/$trpc.ts`) to handle tRPC requests. Both `loader` and `action` functions utilize a common `handleRequest` function. This function employs `fetchRequestHandler` from `@trpc/server/adapters/fetch` to process the incoming Remix request (`args.request`) against the defined `appRouter` and `createContext`. Dependencies include `@remix-run/node`, `@trpc/server`, `~/server/context`, and `~/server/router`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title='app/routes/trpc/$trpc.ts'\nimport type { ActionArgs, LoaderArgs } from '@remix-run/node';\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from '~/server/context';\nimport { appRouter } from '~/server/router';\n\nexport const loader = async (args: LoaderArgs) => {\n  return handleRequest(args);\n};\nexport const action = async (args: ActionArgs) => {\n  return handleRequest(args);\n};\nfunction handleRequest(args: LoaderArgs | ActionArgs) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: args.request,\n    router: appRouter,\n    createContext,\n  });\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Server for tRPC (TypeScript)\nDESCRIPTION: Sets up a WebSocket server using the 'ws' package and applies the tRPC WebSocket handler. It also includes error handling and graceful shutdown.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/subscriptions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\n\nconst wss = new ws.Server({\n  port: 3001,\n});\nconst handler = applyWSSHandler({ wss, router: appRouter, createContext });\n\nwss.on('connection', (ws) => {\n  console.log(`➕➕ Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`➖➖ Connection (${wss.clients.size})`);\n  });\n});\nconsole.log('✅ WebSocket Server listening on ws://localhost:3001');\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Error Handler\nDESCRIPTION: Example of implementing an error handler using onError to process and handle different types of errors before they are sent to the client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-handling.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\n  // ...\n  onError(opts) {\n    const { error, type, path, input, ctx, req } = opts;\n    console.error('Error:', error);\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\n      // send to bug reporting\n    }\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Server with Standalone Adapter\nDESCRIPTION: Shows how to create and serve a tRPC HTTP server using the standalone adapter, listening on port 3000\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { router } from './trpc';\n\nconst appRouter = router({\n  // ...\n});\n\nconst server = createHTTPServer({\n  router: appRouter,\n});\n\nserver.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Server Action in a React Component\nDESCRIPTION: This snippet shows how to use the tRPC-defined server action in a React component. It demonstrates both progressive enhancement using the form action and client-side JavaScript handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n'use client';\n\nimport { createPost } from '~/_actions';\n\nexport function PostForm() {\n  return (\n    <form\n      // Use `action` to make form progressively enhanced\n      action={createPost}\n      // `Using `onSubmit` allows building rich interactive\n      // forms once JavaScript has loaded\n      onSubmit={async (e) => {\n        e.preventDefault();\n        const title = new FormData(e.target).get('title');\n        // Maybe show loading toast, etc etc. Endless possibilities\n        await createPost({ title });\n      }}\n    >\n      <input type=\"text\" name=\"title\" />\n      <button type=\"submit\">Create Post</button>\n    </form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Request Context with Next.js Adapter\nDESCRIPTION: Implementation of createContext function that handles request context creation for tRPC with Next.js integration. Includes user authentication from authorization headers and type inference for context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/context.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\n// The app's context - is generated for each incoming request\nexport async function createContext(opts?: trpcNext.CreateNextContextOptions) {\n  // Create your context based on the request object\n  // Will be available as `ctx` in all your resolvers\n\n  // This is just an example of something you'd might want to do in your ctx fn\n  async function getUserFromHeader() {\n    if (opts?.req.headers.authorization) {\n      // const user = await decodeJwtToken(req.headers.authorization.split(' ')[1])\n      // return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n\n  return {\n    user,\n  };\n}\ntype Context = trpc.inferAsyncReturnType<typeof createContext>;\n\n// Helper function to create a router with your app's context\nexport function createRouter() {\n  return trpc.router<Context>();\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseQuery Hook in React Component\nDESCRIPTION: This example demonstrates how to use the useSuspenseQuery hook from tRPC in a React component to fetch a post by ID. It shows the tuple returned by the hook, containing the data and query object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/suspense.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n\nfunction PostView() {\n  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });\n  //      ^?\n\n  return <>{/* ... */}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Composing Multiple Standalone Middlewares in tRPC\nDESCRIPTION: Shows how to create and combine multiple standalone middlewares that transform input values. Demonstrates middleware chaining and context modification with type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';\nimport * as z from 'zod';\n\nconst t = initTRPC.create();\nconst schemaA = z.object({ valueA: z.string() });\nconst schemaB = z.object({ valueB: z.string() });\n\nconst valueAUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaA>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },\n  });\n});\n\nconst valueBUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaB>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },\n  });\n});\n\nconst combinedInputThatSatisfiesBothMiddlewares = z.object({\n  valueA: z.string(),\n  valueB: z.string(),\n  extraProp: z.string(),\n});\n\nt.procedure\n  .input(combinedInputThatSatisfiesBothMiddlewares)\n  .use(valueAUppercaserMiddleware)\n  .use(valueBUppercaserMiddleware)\n  .query(\n    ({\n      input: { valueA, valueB, extraProp },\n      ctx: { valueAUppercase, valueBUppercase },\n    }) =>\n      `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,\n  );\n```\n\n----------------------------------------\n\nTITLE: Creating Basic React Component with useUtils\nDESCRIPTION: A React component that demonstrates how to access the useUtils hook from tRPC to get access to query helpers on the post router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n// @target: esnext\n// @include: server\n// @filename: MyComponent.tsx\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from './server';\n\nconst trpc = createTRPCReact<AppRouter>();\n\n// ---cut---\n// @noErrors\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  utils.post.all.f;\n  //              ^|\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing FormData Input Handler\nDESCRIPTION: Server-side implementation of a tRPC procedure that handles FormData input using Zod for validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/non-json-content-types.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure.input(z.instanceof(FormData)).query((opts) => {\n    const data = opts.input;\n    return {\n      greeting: `Hello ${data.get('name')}`,\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Invalidating a Single Query with useUtils\nDESCRIPTION: Example demonstrating how to invalidate specific queries based on the input passed to them, using the invalidate helper from useUtils to prevent unnecessary backend calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n\n  const mutation = trpc.post.edit.useMutation({\n    onSuccess(input) {\n      utils.post.all.invalidate();\n      utils.post.byId.invalidate({ id: input.id }); // Will not invalidate queries for other id's 👍\n    },\n  });\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Combining Multiple Standalone tRPC Middlewares (TypeScript)\nDESCRIPTION: This snippet demonstrates applying multiple `experimental_standaloneMiddleware` instances to a single procedure. It defines `valueAUppercaserMiddleware` (requires `input.valueA`, adds `ctx.valueAUppercase`) and `valueBUppercaserMiddleware` (requires `input.valueB`, adds `ctx.valueBUppercase`). A procedure then uses both, taking a combined input schema satisfying both middlewares and accessing the context properties added by each.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @target: esnext\nimport { experimental_standaloneMiddleware, initTRPC } from '@trpc/server';\nimport * as z from 'zod';\n\nconst t = initTRPC.create();\nconst schemaA = z.object({ valueA: z.string() });\nconst schemaB = z.object({ valueB: z.string() });\n\nconst valueAUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaA>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueAUppercase: opts.input.valueA.toUpperCase() },\n  });\n});\n\nconst valueBUppercaserMiddleware = experimental_standaloneMiddleware<{\n  input: z.infer<typeof schemaB>;\n}>().create((opts) => {\n  return opts.next({\n    ctx: { valueBUppercase: opts.input.valueB.toUpperCase() },\n  });\n});\n\nconst combinedInputThatSatisfiesBothMiddlewares = z.object({\n  valueA: z.string(),\n  valueB: z.string(),\n  extraProp: z.string(),\n});\n\nt.procedure\n  .input(combinedInputThatSatisfiesBothMiddlewares)\n  .use(valueAUppercaserMiddleware)\n  .use(valueBUppercaserMiddleware)\n  .query(\n    ({\n      input: { valueA, valueB, extraProp },\n      ctx: { valueAUppercase, valueBUppercase },\n    }) =>\n      `valueA: ${valueA}, valueB: ${valueB}, extraProp: ${extraProp}, valueAUppercase: ${valueAUppercase}, valueBUppercase: ${valueBUppercase}`,\n  );\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Infinite Query Procedure in tRPC Server\nDESCRIPTION: This snippet demonstrates how to set up a tRPC procedure for infinite queries using cursor-based pagination. It uses Prisma for database querying and includes input validation with Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useInfiniteQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './[trpc]';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  infinitePosts: t.procedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(100).nullish(),\n        cursor: z.number().nullish(), // <-- \"cursor\" needs to exist, but can be any type\n        direction: z.enum(['forward', 'backward']), // optional, useful for bi-directional query\n      }),\n    )\n    .query(async (opts) => {\n      const { input } = opts;\n      const limit = input.limit ?? 50;\n      const { cursor } = input;\n      const items = await prisma.post.findMany({\n        take: limit + 1, // get an extra item at the end which we'll use as next cursor\n        where: {\n          title: {\n            contains: 'Prisma' /* Optional filter */,\n          },\n        },\n        cursor: cursor ? { myCursor: cursor } : undefined,\n        orderBy: {\n          myCursor: 'asc',\n        },\n      });\n      let nextCursor: typeof cursor | undefined = undefined;\n      if (items.length > limit) {\n        const nextItem = items.pop();\n        nextCursor = nextItem!.myCursor;\n      }\n\n      return {\n        items,\n        nextCursor,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming Infinite Posts with tRPC.useInfiniteQuery in a React TypeScript Component\nDESCRIPTION: This React component demonstrates how to use tRPC's useInfiniteQuery hook with appropriate parameters to fetch paginated data from the server-side infinitePosts query. It specifies the query key and initial parameters, and defines getNextPageParam to inform React Query of the next cursor, facilitating client-side infinite scrolling and pagination. Dependencies include a tRPC client setup and React Query integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useInfiniteQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const myQuery = trpc.useInfiniteQuery(\n    [\n      'infinitePosts',\n      {\n        limit: 10,\n      },\n    ],\n    {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n    },\n  );\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Using Helper Functions for tRPC Prefetching and Hydration\nDESCRIPTION: This snippet demonstrates how to use the helper functions for prefetching tRPC queries and hydrating the React Query client in a Next.js component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_9\n\nLANGUAGE: tsx\nCODE:\n```\nimport { HydrateClient, prefetch, trpc } from '~/trpc/server';\n\nfunction Home() {\n  prefetch(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Single Query Invalidation Example\nDESCRIPTION: Shows how to invalidate specific queries based on procedure inputs.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n\n  const mutation = trpc.post.edit.useMutation({\n    onSuccess(input) {\n      utils.post.all.invalidate();\n      utils.post.byId.invalidate({ id: input.id });\n    },\n  });\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Context for Server-Side Helpers in tRPC\nDESCRIPTION: Shows how to create context for server-side helpers using createServerSideHelpers. The createContext function is awaited and passed as the ctx option.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Hook for Post Creation in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a custom hook for post creation using inferred types. It utilizes the trpc client and inferred types to provide type-safe mutation options and input handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  trpc,\n  type ReactQueryOptions,\n  type RouterInputs,\n  type RouterOutputs,\n} from './trpc';\n\ntype PostCreateOptions = ReactQueryOptions['post']['create'];\n\nfunction usePostCreate(options?: PostCreateOptions) {\n  const utils = trpc.useUtils();\n\n  return trpc.post.create.useMutation({\n    ...options,\n    onSuccess(post) {\n      // invalidate all queries on the post router\n      // when a new post is created\n      utils.post.invalidate();\n      options?.onSuccess?.(post);\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Extending Middlewares with unstable_pipe() in tRPC\nDESCRIPTION: This snippet demonstrates how to extend middlewares using the unstable_pipe() method. It shows how to create and pipe middlewares together, and how the order of piping affects the resulting context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst fooMiddleware = t.middleware((opts) => {\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n\nconst barMiddleware = fooMiddleware.unstable_pipe((opts) => {\n  const { ctx } = opts;\n  ctx.foo;\n  //   ^?\n  return opts.next({\n    ctx: {\n      bar: 'bar' as const,\n    },\n  });\n});\n\nconst barProcedure = publicProcedure.use(barMiddleware);\nbarProcedure.query(({ ctx }) => ctx.bar);\n//                              ^?\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Abort Behavior in tRPC Client\nDESCRIPTION: Demonstrates how to configure global abort behavior for all tRPC procedure calls by setting abortOnUnmount in the client configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/aborting-procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCReact } from '@trpc/react-query';\n\nexport const trpc = createTRPCReact<AppRouter>({\n  abortOnUnmount: true,\n});\n\ntrpc.createClient({\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Subscription Implementation Example\nDESCRIPTION: Demonstrates how to implement and use subscriptions with tRPC and TanStack React Query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nfunction SubscriptionExample() {\n  const trpc = useTRPC();\n  const subscription = useSubscription(\n    trpc.path.to.subscription.subscriptionOptions(\n      {\n        /** input */\n      },\n      {\n        enabled: true,\n        onStarted: () => {\n          // do something when the subscription is started\n        },\n        onData: (data) => {\n          // you can handle the data here\n        },\n        onError: (error) => {\n          // you can handle the error here\n        },\n        onConnectionStateChange: (state) => {\n          // you can handle the connection state here\n        },\n      },\n    ),\n  );\n\n  // Or you can handle the state here\n  subscription.data; // The lastly received data\n  subscription.error; // The lastly received error\n\n  /**\n   * The current status of the subscription.\n   * Will be one of: 'idle', 'connecting', 'pending', or 'error'.\n   *\n   * - 'idle': subscription is disabled or ended\n   * - 'connecting': trying to establish a connection\n   * - 'pending': connected to the server, receiving data\n   * - 'error': an error occurred and the subscription is stopped\n   */\n  subscription.status;\n\n  // Reset the subscription (if you have an error etc)\n  subscription.reset();\n\n  return <>{/* ... */}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Multiple tRPC Queries using Method Chaining in TypeScript\nDESCRIPTION: This snippet demonstrates how to define multiple procedures ('hello' and 'bye') on a single tRPC router by chaining the `.query()` method calls. Each procedure has its own `resolve` function returning a distinct text object. It also exports the combined router's type (`AppRouter`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/router.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\n\n// [...] \n\nexport const appRouter = trpc\n  .router<Context>()\n  .query('hello', {\n    resolve() {\n      return {\n        text: `hello world`,\n      };\n    },\n  })\n  .query('bye', {\n    resolve() {\n      return {\n        text: `goodbye`,\n      };\n    },\n  });\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Per-Request Abort Behavior in React Component\nDESCRIPTION: Shows how to implement abort behavior for individual tRPC procedure calls within a React component using the trpc.abortOnUnmount option.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/aborting-procedures.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction PostViewPage() {\n  const { query } = useRouter();\n  const postQuery = trpc.post.byId.useQuery(\n    { id: query.id },\n    { trpc: { abortOnUnmount: true } }\n  );\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Authorization Context from Request Headers in tRPC\nDESCRIPTION: Demonstrates how to create a context function that extracts and verifies JWT tokens from request headers to authenticate users. The context is then available in all resolvers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/authorization.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { inferAsyncReturnType } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';\n\nexport async function createContext({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) {\n  async function getUserFromHeader() {\n    if (req.headers.authorization) {\n      const user = await decodeAndVerifyJwtToken(\n        req.headers.authorization.split(' ')[1],\n      );\n      return user;\n    }\n    return null;\n  }\n  const user = await getUserFromHeader();\n\n  return {\n    user,\n  };\n}\ntype Context = inferAsyncReturnType<typeof createContext>;\n```\n\n----------------------------------------\n\nTITLE: Setting up Standalone tRPC Server in TypeScript\nDESCRIPTION: This code sets up a standalone tRPC server using the createHTTPServer function from @trpc/server/adapters/standalone. It configures the server with the appRouter and a simple context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './appRouter.ts';\n\ncreateHTTPServer({\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n  // basePath: '/trpc/', // optional, defaults to '/'\n}).listen(2022);\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Query Hook in Next.js Client Component\nDESCRIPTION: This snippet demonstrates how to use a tRPC query hook in a Next.js client component. It shows the usage of the useQuery hook to fetch data and handle loading states.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\n// <-- hooks can only be used in client components\nimport { trpc } from '~/trpc/client';\n\nexport function ClientGreeting() {\n  const greeting = trpc.hello.useQuery();\n  if (!greeting.data) return <div>Loading...</div>;\n  return <div>{greeting.data.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Input Query Implementation with Router Caller\nDESCRIPTION: Example of creating and using a router caller with input validation for a greeting procedure. Shows Zod schema validation and async procedure execution.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst router = t.router({\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => `Hello ${opts.input.name}`),\n});\n\nconst caller = router.createCaller({});\nconst result = await caller.greeting({ name: 'tRPC' });\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Caching\nDESCRIPTION: Sets up tRPC client configuration with SSR and response caching. Includes conditional URL configuration for Vercel deployment and local development, with cache control headers for day-long caching with per-second revalidation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    if (typeof window !== 'undefined') {\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      links: {\n        http: httpBatchLink({\n          url,\n        }),\n      },\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n\n    if (clientErrors.length) {\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: new Headers([\n        [\n          'cache-control',\n          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        ],\n      ]),\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Flattened Post Router in tRPC\nDESCRIPTION: This snippet shows the definition of a post router with flattened procedure names for use with t.mergeRouters in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  postCreate: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n      //        ^?\n      // [...]\n    }),\n  postList: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using tRPC React Query Integration\nDESCRIPTION: Demonstrates the integrated usage of tRPC with React Query, showing both query and mutation implementations in a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/introduction.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });\n  const goodbyeMutation = trpc.goodbye.useMutation();\n\n  return (\n    <div>\n      <p>{helloQuery.data?.greeting}</p>\n\n      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Query Input and Output Validation with Superstruct in TypeScript\nDESCRIPTION: This example demonstrates using Superstruct for both input and output validation in a tRPC query named 'hello'. It validates that the input is a string (`t.string()`) and the output is an object containing a 'greeting' string property (`t.object({ greeting: t.string() })`). The `resolve` function uses the validated input to construct the output. The router type `AppRouter` is exported.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/output-validation.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport * as t from 'superstruct';\n\n// [...]\n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  input: t.string(),\n  output: t.object({\n    greeting: t.string(),\n  }),\n  resolve({ input }) {\n    return { greeting: input };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Defining Client Usage for tRPC Router\nDESCRIPTION: Sample code demonstrating how the client will be used to call procedures defined in the tRPC router. Shows the expected pattern for queries and mutations with proper type inference.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst post1 = await client.post.byId.query({ id: '123' });\nconst post2 = await client.post.byTitle.query({ title: 'Hello world' });\nconst newPost = await client.post.create.mutate({ title: 'Foo' });\n```\n\n----------------------------------------\n\nTITLE: Type Inference Examples\nDESCRIPTION: Shows how to infer input and output types for tRPC procedures and routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport { AppRouter } from './path/to/server';\n\nexport type Inputs = inferRouterInputs<AppRouter>;\nexport type Outputs = inferRouterOutputs<AppRouter>;\n```\n\n----------------------------------------\n\nTITLE: Merging Routers with t.mergeRouters in tRPC\nDESCRIPTION: Demonstrates using t.mergeRouters to combine multiple routers into a flat namespace structure, as an alternative to nested namespaces.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/merging-routers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure, mergeRouters } from '../trpc';\nimport { z } from 'zod';\n\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n\nconst appRouter = mergeRouters(userRouter, postRouter)\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Custom Function Validator Implementation\nDESCRIPTION: Demonstrates how to create a custom validator function without third-party dependencies for both input and output validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/validators.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.create();\n\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Input is not a string');\n    })\n    .output((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Output is not a string');\n    })\n    .query((opts) => {\n      const { input } = opts;\n      return `hello ${input}`;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring the loggerLink in tRPC Client\nDESCRIPTION: This snippet demonstrates how to import and configure the loggerLink in a tRPC client setup. It shows conditional enabling of logging based on environment and error conditions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/loggerLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink, loggerLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    /**\n     * The function passed to enabled is an example in case you want to the link to\n     * log to your console in development and only log errors in production\n     */\n    loggerLink({\n      enabled: (opts) =>\n        (process.env.NODE_ENV === 'development' &&\n          typeof window !== 'undefined') ||\n        (opts.direction === 'down' && opts.result instanceof Error),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: onError Hook Parameter Structure - TypeScript\nDESCRIPTION: Specifies the type signature for the parameter object passed to the onError handler. Includes the original error, the request type, invoked procedure path, input, context, and request object. This information is critical for implementing structured and context-aware error handling logic in server-side hooks.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-handling.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n{\\n  error: TRPCError; // the original error\\n  type: 'query' | 'mutation' | 'subscription' | 'unknown';\\n  path: string | undefined; // path of the procedure that was triggered\\n  input: unknown;\\n  ctx: Context | undefined;\\n  req: BaseRequest; // request object\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Implementing httpBatchLink in tRPC Client\nDESCRIPTION: This snippet demonstrates how to import and add the httpBatchLink to the links array in a tRPC client configuration. It sets up the client to use batched HTTP requests for tRPC operations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Resolver-Based Authorization in tRPC\nDESCRIPTION: Shows how to implement authorization checks directly in tRPC resolvers, including both public and protected endpoints using the TRPCError for unauthorized access.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/authorization.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { TRPCError } from '@trpc/server';\nimport { createRouter } from '../createRouter';\n\nexport const appRouter = createRouter()\n  .query('hello', {\n    input: z.string().nullish(),\n    resolve: ({ input, ctx }) => {\n      return `hello ${input ?? ctx.user?.name ?? 'world'}`;\n    },\n  })\n  .query('secret', {\n    resolve: ({ ctx }) => {\n      if (!ctx.user) {\n        throw new TRPCError({ code: 'UNAUTHORIZED' });\n      }\n      return {\n        secret: 'sauce',\n      };\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Using useInfiniteQuery Hook in React Component\nDESCRIPTION: This example shows how to use the useInfiniteQuery hook from tRPC in a React component. It demonstrates setting up the query with a limit and defining how to get the next page parameter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useInfiniteQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const myQuery = trpc.infinitePosts.useInfiniteQuery(\n    {\n      limit: 10,\n    },\n    {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n      // initialCursor: 1, // <-- optional you can pass an initialCursor\n    },\n  );\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing tRPC Error Formatting in Server (TypeScript)\nDESCRIPTION: Defines a tRPC router and uses the `formatError` method to modify the default error shape. It checks if the error code is 'BAD_REQUEST' and the cause is a ZodError, adding the flattened ZodError details to the 'data.zodError' field. This allows structured validation errors to be passed to the client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-formatting.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\n```ts title='server.ts'\nconst router = trpc.router<Context>().formatError(({ shape, error }) => {\n  return {\n    ...shape,\n    data: {\n      ...shape.data,\n      zodError:\n        error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n          ? error.cause.flatten()\n          : null,\n    },\n  };\n});\n```\n```\n\n----------------------------------------\n\nTITLE: tRPC Runtime Configuration Interface in TypeScript\nDESCRIPTION: Defines the RootConfig interface for tRPC runtime configuration. It includes options for data transformation, error formatting, environment settings, and development mode.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/routers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface RootConfig<TTypes extends RootTypes> {\n  /**\n   * Use a data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   */\n  transformer: TTypes['transformer'];\n\n  /**\n   * Use custom error formatting\n   * @see https://trpc.io/docs/v11/error-formatting\n   */\n  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;\n\n  /**\n   * Allow `@trpc/server` to run in non-server environments\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default false\n   */\n  allowOutsideOfServer: boolean;\n\n  /**\n   * Is this a server environment?\n   * @warning **Use with caution**, this should likely mainly be used within testing.\n   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'\n   */\n  isServer: boolean;\n\n  /**\n   * Is this development?\n   * Will be used to decide if the API should return stack traces\n   * @default process.env.NODE_ENV !== 'production'\n   */\n  isDev: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC WebSocket Client with wsLink\nDESCRIPTION: Creates a tRPC client using the wsLink terminating link with a WebSocket connection. This snippet demonstrates how to establish a WebSocket connection to a tRPC server running locally on port 3000.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/wsLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst wsClient = createWSClient({\n  url: 'ws://localhost:3000',\n});\n\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [wsLink<AppRouter>({ client: wsClient })],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a tRPC Router in Next.js API\nDESCRIPTION: This TypeScript code creates a tRPC router in the Next.js API folder. It defines a 'hello' query with input validation using Zod and exports the router and API handler.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\nimport { z } from 'zod';\n\nexport const appRouter = trpc.router().query('hello', {\n  input: z\n    .object({\n      text: z.string().nullish(),\n    })\n    .nullish(),\n  resolve({ input }) {\n    return {\n      greeting: `hello ${input?.text ?? 'world'}`,\n    };\n  },\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n// export API handler\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext: () => null,\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Login with tRPC\nDESCRIPTION: Shows how to handle authentication tokens after successful login using tRPC mutation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/headers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMut = trpc.auth.login.useMutation({\n  onSuccess(opts) {\n    token = opts.accessToken;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC Router Implementation\nDESCRIPTION: Implements a basic tRPC router with a 'hello' query endpoint using Zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\nimport { procedure, router } from '../trpc';\n\nexport const appRouter = router({\n  hello: procedure\n    .input(\n      z.object({\n        text: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input.text}`,\n      };\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Handler in Remix\nDESCRIPTION: Sets up tRPC request handling in a Remix application using the fetch adapter. Handles both loader and action functions to process tRPC requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from '~/server/context';\nimport { appRouter } from '~/server/router';\n\nexport const loader = async (args: LoaderFunctionArgs) => {\n  return handleRequest(args);\n};\nexport const action = async (args: ActionFunctionArgs) => {\n  return handleRequest(args);\n};\nfunction handleRequest(args: LoaderFunctionArgs | ActionFunctionArgs) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: args.request,\n    router: appRouter,\n    createContext,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Server-Side Helpers Context Setup\nDESCRIPTION: Illustrates context setup with server-side helpers in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Data with tRPC and React Query in React Component\nDESCRIPTION: Demonstrates how to use the tRPC React Query integration to call queries and mutations on your API within a React component. This example shows both querying and mutating data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/setup.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useMutation, useQuery } from '@tanstack/react-query';\nimport { useTRPC } from '../utils/trpc';\n\nexport default function UserList() {\n  const trpc = useTRPC(); // use `import { trpc } from './utils/trpc'` if you're using the singleton pattern\n\n  const userQuery = useQuery(trpc.getUser.queryOptions({ id: 'id_bilbo' }));\n  const userCreator = useMutation(trpc.createUser.mutationOptions());\n\n  return (\n    <div>\n      <p>{userQuery.data?.name}</p>\n\n      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>\n        Create Frodo\n      </button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Transformers in tRPC Server Router\nDESCRIPTION: TypeScript code to add custom transformers to the tRPC server router initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { transformer } from '../../utils/trpc';\n\nexport const t = initTRPC.create({\n  transformer,\n});\n\nexport const appRouter = t.router({\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Cancellation with tRPC Client\nDESCRIPTION: Demonstrates how to set up request cancellation for tRPC procedure calls using AbortController. Shows creation of tRPC client, initialization of AbortController, and passing the signal to queries for cancellation support.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\n// @noErrors\nimport type { AppRouter } from './server.ts';\n\nconst proxy = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n    }),\n  ],\n});\n\n// 1. Create an AbortController instance - this is a standard javascript API\nconst ac = new AbortController();\n\n// 2. Pass the signal to a query or mutation\nconst query = proxy.userById.query('id_bilbo', { signal: ac.signal });\n\n// 3. Cancel the request if needed\nac.abort();\n```\n\n----------------------------------------\n\nTITLE: Defining useSubscription Hook Signature and Options in TypeScript\nDESCRIPTION: This snippet defines the signature of the useSubscription hook and its options interface. It includes parameters for input and options, and describes the available callbacks for subscription lifecycle events.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useSubscription.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction useSubscription<TOutput, TError>(\n  input: TInput | SkipToken,\n  opts?: UseTRPCSubscriptionOptions<TOutput, TError>,\n): TRPCSubscriptionResult<TOutput, TError>;\n\ninterface UseTRPCSubscriptionOptions<TOutput, TError> {\n  /**\n   * Callback invoked when the subscription starts.\n   */\n  onStarted?: () => void;\n  /**\n   * Callback invoked when new data is received from the subscription.\n   * @param data - The data received.\n   */\n  onData?: (data: TOutput) => void;\n  /**\n   * Callback invoked when an **unrecoverable error** occurs and the subscription is stopped.\n   */\n  onError?: (error: TError) => void;\n  /**\n   * Callback invoked when the subscription is completed.\n   */\n  onComplete?: () => void;\n  /**\n   * @deprecated Use a `skipToken` from `@tanstack/react-query` instead.\n   * This will be removed in a future version.\n   */\n  enabled?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Router Factory Types for Component Abstraction\nDESCRIPTION: Shows how to create abstract types from a router factory using RouterLike and UtilsLike types. This pattern enables building reusable components that can work with different instances of similar routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @noErrors\n// ---cut---\n\nimport { t, publicProcedure } from './trpc';\n\n// @trpc/react-query/shared exports several **Like types which can be used to generate abstract types\nimport { RouterLike, UtilsLike } from '@trpc/react-query/shared';\n\n// Factory function written by you, however you need,\n// so long as you can infer the resulting type of t.router() later\nexport function createMyRouter() {\n  return t.router({\n    createThing: publicProcedure\n      .input(ThingRequest)\n      .output(Thing)\n      .mutation(/* do work */),\n    listThings: publicProcedure\n      .input(ThingQuery)\n      .output(ThingArray)\n      .query(/* do work */),\n  })\n}\n\n// Infer the type of your router, and then generate the abstract types for use in the client\ntype MyRouterType = ReturnType<typeof createMyRouter>\nexport MyRouterLike = RouterLike<MyRouterType>\nexport MyRouterUtilsLike = UtilsLike<MyRouterType>\n```\n\n----------------------------------------\n\nTITLE: Configuring _app.tsx with withTRPC in Next.js\nDESCRIPTION: This TypeScript code configures the _app.tsx file in a Next.js project to use withTRPC. It sets up the tRPC client, handles SSR, and provides options for API URL and React Query configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { withTRPC } from '@trpc/next';\nimport { AppType } from 'next/dist/shared/lib/utils';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default withTRPC<AppRouter>({\n  config({ ctx }) {\n    /**\n     * If you want to use SSR, you need to use the server's full URL\n     * @see https://trpc.io/docs/ssr\n     */\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      url,\n      /**\n       * @see https://tanstack.com/query/v3/docs/react/reference/QueryClient\n       */\n      // queryClientConfig: { defaultOptions: { queries: { staleTime: 60 } } },\n    };\n  },\n  /**\n   * @see https://trpc.io/docs/ssr\n   */\n  ssr: true,\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Client Factory\nDESCRIPTION: Establishes a factory function that creates a QueryClient instance with configured defaults for dehydration and stale time, optimized for server-side rendering.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\n\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Accessing Infinite Query Cache with getInfiniteQueryData in tRPC React Context (TypeScript)\nDESCRIPTION: This snippet shows how to use tRPC's React utils to access currently cached data for an infinite query on the client. Within a mutation's onMutate callback, it demonstrates cancelling ongoing queries and retrieving cached infinite query data for optimistic UI updates. This requires a tRPC React context and is typically used in conjunction with React Query's cache manipulation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useInfiniteQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useContext();\n\n  const myMutation = trpc.useMutation('infinitePosts.add', {\n    onMutate({ post }) {\n      await utils.cancelQuery(['infinitePosts']);\n      const allPosts = utils.getInfiniteQueryData(['infinitePosts', { limit: 10 }]);\n      // [...]\n    }\n  })\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring App-Level Caching in tRPC with Next.js\nDESCRIPTION: Implementation of app-level caching using withTRPC configuration in Next.js. Sets up SSR with cache control headers and handles different environments (development/production) for API URL configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport default withTRPC({\n  config({ ctx }) {\n    if (typeof window !== 'undefined') {\n      return {\n        url: '/api/trpc',\n      };\n    }\n\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      url,\n    };\n  },\n  ssr: true,\n  responseMeta({ ctx, clientErrors }) {\n    if (clientErrors.length) {\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: {\n        'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n      },\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Displaying Error Response Structure in JSON\nDESCRIPTION: This snippet shows the structure of an error response in tRPC, including the error message, code, and additional data such as HTTP status and stack trace.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-handling.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"\\\"password\\\" must be at least 4 characters\",\n    \"code\": -32600,\n    \"data\": {\n      \"code\": \"BAD_REQUEST\",\n      \"httpStatus\": 400,\n      \"stack\": \"...\",\n      \"path\": \"user.changepassword\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Error Formatter in tRPC Server\nDESCRIPTION: Demonstrates how to set up a custom error formatter in tRPC server configuration that handles Zod validation errors. The formatter adds additional error data to the response shape.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-formatting.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.context<Context>().create({\n  errorFormatter(opts) {\n    const { shape, error } = opts;\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n            ? error.cause.flatten()\n            : null,\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router with Multiple Procedures\nDESCRIPTION: Example of a tRPC router implementation with multiple procedures (postById and relatedPosts) showing input handling and query definitions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/rpc.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = t.router({\n  postById: t.procedure.input(String).query(async (opts) => {\n    const post = await opts.ctx.post.findUnique({\n      where: { id: opts.input },\n    });\n    return post;\n  }),\n  relatedPosts: t.procedure.input(String).query(async (opts) => {\n    const posts = await opts.ctx.findRelatedPostsById(opts.input);\n    return posts;\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Authorizing Using Resolver in tRPC (TypeScript)\nDESCRIPTION: This snippet shows how to implement authorization using resolvers in tRPC. It includes an open route and a protected route that checks for user authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/authorization.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport type { Context } from '../context';\n\nexport const t = initTRPC.context<Context>().create();\n\nconst appRouter = t.router({\n  // open for anyone\n  hello: t.procedure\n    .input(z.string().nullish())\n    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),\n  // checked in resolver\n  secret: t.procedure.query((opts) => {\n    if (!opts.ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return {\n      secret: 'sauce',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Valibot with tRPC Router\nDESCRIPTION: Example of setting up a tRPC router with Valibot schema validation for input and output types. Creates a 'hello' procedure that validates input name and output greeting strings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport * as v from 'valibot';\n\nexport const t = initTRPC.create();\n\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(v.object({ name: v.string() }))\n    .output(v.object({ greeting: v.string() }))\n    .query(({ input }) => {\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Server with Sample Router\nDESCRIPTION: Defines a tRPC server with a router for posts that includes procedures for fetching all posts and getting posts by ID. This server setup is used as the foundation for the suspense examples.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst posts = [\n  { id: '1', title: 'everlong' },\n  { id: '2', title: 'After Dark' },\n];\n\nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure\n      .input(\n        z.object({\n          cursor: z.string().optional(),\n        })\n      )\n      .query(({ input }) => {\n        return {\n          posts,\n          nextCursor: '123' as string | undefined,\n        };\n      }),\n    byId: t.procedure\n      .input(\n        z.object({\n          id: z.string(),\n        })\n      )\n      .query(({ input }) => {\n        const post = posts.find(p => p.id === input.id);\n        if (!post) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n          })\n        }\n        return post;\n     }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Static Site Generation for Blog Posts with tRPC and Next.js\nDESCRIPTION: This code snippet demonstrates how to implement Static Site Generation for a blog post page using tRPC and Next.js. It includes the getStaticProps function to fetch data, getStaticPaths to generate static paths, and the React component to render the post. The example uses createSSGHelpers from @trpc/react/ssg for data fetching and hydration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/ssg.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createSSGHelpers } from '@trpc/react/ssg';\nimport {\n  GetStaticPaths,\n  GetStaticPropsContext,\n  InferGetStaticPropsType,\n} from 'next';\nimport { prisma } from 'server/context';\nimport { appRouter } from 'server/routers/_app';\nimport superjson from 'superjson';\nimport { trpc } from 'utils/trpc';\n\nexport async function getStaticProps(\n  context: GetStaticPropsContext<{ id: string }>,\n) {\n  const ssg = await createSSGHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson, // optional - adds superjson serialization\n  });\n  const id = context.params?.id as string;\n\n  // prefetch `post.byId`\n  await ssg.fetchQuery('post.byId', {\n    id,\n  });\n\n  return {\n    props: {\n      trpcState: ssg.dehydrate(),\n      id,\n    },\n    revalidate: 1,\n  };\n}\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const posts = await prisma.post.findMany({\n    select: {\n      id: true,\n    },\n  });\n\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        id: post.id,\n      },\n    })),\n    // https://nextjs.org/docs/basic-features/data-fetching#fallback-blocking\n    fallback: 'blocking',\n  };\n};\n\nexport default function PostViewPage(\n  props: InferGetStaticPropsType<typeof getStaticProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.useQuery(['post.byId', { id }]);\n\n  if (postQuery.status !== 'success') {\n    // won't happen since we're using `fallback: \"blocking\"`\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>\n\n      <p>{data.text}</p>\n\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Query Invalidation with Proxy Client\nDESCRIPTION: Demonstrates using the tRPC proxy client for handling API key creation in a form submission.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction MyComponent() {\n  const [apiKey, setApiKey] = useState();\n  const utils = trpc.useUtils();\n\n  return (\n    <Form\n      handleSubmit={async (event) => {\n        const apiKey = await utils.client.apiKey.create.mutate(event);\n        setApiKey(apiKey);\n      }}\n    >\n      ...\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Type Inference Helpers with AppRouter (TypeScript)\nDESCRIPTION: This snippet defines a set of TypeScript utility types that leverage tRPC's inference helpers to extract parameter and return types for queries, mutations, and subscriptions from a central AppRouter type. It imports the necessary types from '@trpc/server' and the AppRouter definition, then creates type aliases for key API paths and inferences for input/output of each procedure kind. Dependencies include '@trpc/server' (for inference helpers) and a project-defined AppRouter. Key parameters are generic route keys that refer to specific queries, mutations, or subscriptions by path. These helpers expect the AppRouter structure exported from the server and enable typesafe access across client code, but require the existence and proper structure of AppRouter and the referenced tRPC types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/infer-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// trpc-helper.ts\n// Import AppRouter from your main server router\nimport type {\n  inferProcedureInput,\n  inferProcedureOutput,\n  inferSubscriptionOutput,\n} from '@trpc/server';\nimport type { AppRouter } from 'api/src/routers/_app';\n\n/**\n * Enum containing all api query paths\n */\nexport type TQuery = keyof AppRouter['_def']['queries'];\n\n/**\n * Enum containing all api mutation paths\n */\nexport type TMutation = keyof AppRouter['_def']['mutations'];\n\n/**\n * Enum containing all api subscription paths\n */\nexport type TSubscription = keyof AppRouter['_def']['subscriptions'];\n\n/**\n * This is a helper method to infer the output of a query resolver\n * @example type HelloOutput = InferQueryOutput<'hello'>\n */\nexport type InferQueryOutput<TRouteKey extends TQuery> = inferProcedureOutput<\n  AppRouter['_def']['queries'][TRouteKey]\n>;\n\n/**\n * This is a helper method to infer the input of a query resolver\n * @example type HelloInput = InferQueryInput<'hello'>\n */\nexport type InferQueryInput<TRouteKey extends TQuery> = inferProcedureInput<\n  AppRouter['_def']['queries'][TRouteKey]\n>;\n\n/**\n * This is a helper method to infer the output of a mutation resolver\n * @example type HelloOutput = InferMutationOutput<'hello'>\n */\nexport type InferMutationOutput<TRouteKey extends TMutation> =\n  inferProcedureOutput<AppRouter['_def']['mutations'][TRouteKey]>;\n\n/**\n * This is a helper method to infer the input of a mutation resolver\n * @example type HelloInput = InferMutationInput<'hello'>\n */\nexport type InferMutationInput<TRouteKey extends TMutation> =\n  inferProcedureInput<AppRouter['_def']['mutations'][TRouteKey]>;\n\n/**\n * This is a helper method to infer the output of a subscription resolver\n * @example type HelloOutput = InferSubscriptionOutput<'hello'>\n */\nexport type InferSubscriptionOutput<TRouteKey extends TSubscription> =\n  inferProcedureOutput<AppRouter['_def']['subscriptions'][TRouteKey]>;\n\n/**\n * This is a helper method to infer the asynchronous output of a subscription resolver\n * @example type HelloAsyncOutput = InferAsyncSubscriptionOutput<'hello'>\n */\nexport type InferAsyncSubscriptionOutput<TRouteKey extends TSubscription> =\n  inferSubscriptionOutput<AppRouter, TRouteKey>;\n\n/**\n * This is a helper method to infer the input of a subscription resolver\n * @example type HelloInput = InferSubscriptionInput<'hello'>\n */\nexport type InferSubscriptionInput<TRouteKey extends TSubscription> =\n  inferProcedureInput<AppRouter['_def']['subscriptions'][TRouteKey]>;\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Client with HTTP Batch Link\nDESCRIPTION: Sets up a tRPC client that connects to the server using HTTP batch link. Creates a type-safe client instance that can query the greeting procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/landing-intro/Step3.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst trpc = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n\nconst res = await trpc.greeting.query({ name: 'John' });\n```\n\n----------------------------------------\n\nTITLE: Implementing Request Cancellation with tRPC and AbortController\nDESCRIPTION: Shows how to set up request cancellation in tRPC using AbortController. The code demonstrates creating a tRPC proxy client, initializing an AbortController, passing its signal to a query, and aborting the request when needed. Uses the httpBatchLink for API communication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server.ts\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\n// @noErrors\nimport type { AppRouter } from 'server.ts';\n\nconst proxy = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n    }),\n  ],\n});\n\n// 1. Create an AbortController instance - this is a standard javascript API\nconst ac = new AbortController();\n\n// 2. Pass the signal to a query or mutation\nconst query = proxy.userById.query('id_bilbo', { signal: ac.signal });\n\n// 3. Cancel the request if needed\nac.abort();\n```\n\n----------------------------------------\n\nTITLE: Creating a Query Client Factory for Server and Client Usage\nDESCRIPTION: Defines a factory function that creates a tanstack-query QueryClient with appropriate configuration for handling SSR dehydration/rehydration. Includes support for pending queries and optional superjson serialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  defaultShouldDehydrateQuery,\n  QueryClient,\n} from '@tanstack/react-query';\nimport superjson from 'superjson';\n\nexport function makeQueryClient() {\n  return new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 30 * 1000,\n      },\n      dehydrate: {\n        // serializeData: superjson.serialize,\n        shouldDehydrateQuery: (query) =>\n          defaultShouldDehydrateQuery(query) ||\n          query.state.status === 'pending',\n      },\n      hydrate: {\n        // deserializeData: superjson.deserialize,\n      },\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Backend Router with Query Procedure\nDESCRIPTION: Backend code showing how to create a tRPC router with a 'hello' query procedure that accepts optional text input and returns a greeting message. Uses Zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\nexport const appRouter = trpc\n  .router()\n  // Create procedure at path 'hello'\n  .query('hello', {\n    // using zod schema to validate and infer input values\n    input: z\n      .object({\n        text: z.string().nullish(),\n      })\n      .nullish(),\n    resolve({ input }) {\n      return {\n        greeting: `hello ${input?.text ?? 'world'}`,\n      };\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Setting Global Query Options in tRPC Next.js Client\nDESCRIPTION: Code for configuring global default query options in the tRPC Next.js client. This snippet shows how to set refetchOnMount and refetchOnWindowFocus to false for all queries in the application, which is useful for optimizing static sites.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssg.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      links: [\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n      // Change options globally\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            refetchOnMount: false,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic tRPC Query without Input Validation in TypeScript\nDESCRIPTION: This snippet demonstrates how to initialize a tRPC router and define a simple query procedure named 'hello' without any input validation. The `resolve` function accesses the context (`ctx`) and returns a static greeting object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/router.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\n\n// [...] \n\nexport const appRouter = trpc\n  .router<Context>()\n  // Create procedure at path 'hello'\n  .query('hello', {\n    resolve({ ctx }) {\n      return {\n        greeting: `hello world`,\n      };\n    },\n  });\n```\n```\n\n----------------------------------------\n\nTITLE: Using Shorthand Router Definitions in tRPC v11\nDESCRIPTION: This snippet shows the new shorthand syntax for defining routers in tRPC v11. It demonstrates how to create sub-routers using plain objects, which is equivalent to using the router function.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2025-03-21-announcing-trpc-11.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst appRouter = router({\n  // Shorthand plain object for creating a sub-router\n  nested1: {\n    proc: publicProcedure.query(() => '...'),\n  },\n  // Equivalent of:\n  nested2: router({\n    proc: publicProcedure.query(() => '...'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Server Configuration in TypeScript\nDESCRIPTION: Example of setting up the root tRPC configuration on the server side with context, transformer and error formatting.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\nimport { Context } from './context';\n\nconst t = initTRPC.context<Context>().create({\n  transformer: superjson,\n  errorFormatter(opts) {\n    return opts.shape;\n  },\n});\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\nexport const mergeRouters = t.mergeRouters;\n```\n\n----------------------------------------\n\nTITLE: Defining useQuery Hook Signature in tRPC\nDESCRIPTION: Type definition for the useQuery hook showing its parameters: pathAndInput tuple and optional configuration options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useQuery(\n  pathAndInput: [string, TInput?],\n  opts?: UseTRPCQueryOptions;\n)\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Request Abort on Unmount for tRPC in Next.js\nDESCRIPTION: This snippet shows how to override the global abort behavior for a specific tRPC procedure call. It uses the useQuery hook and sets the abortOnUnmount option to true in the trpc configuration object for that particular query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/aborting-procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: pages/posts/[id].tsx\n// @noErrors\nimport { trpc } from '~/utils/trpc';\n\nconst PostViewPage: NextPageWithLayout = () => {\n  const id = useRouter().query.id as string;\n  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });\n\n  return (...)\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Logger Link with HTTP Batch Link\nDESCRIPTION: Example of setting up a tRPC client with loggerLink and httpBatchLink. Shows how to conditionally enable logging based on environment and error conditions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/loggerLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink, loggerLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    /**\n     * The function passed to enabled is an example in case you want to the link to\n     * log to your console in development and only log errors in production\n     */\n    loggerLink({\n      enabled: (opts) =>\n        (process.env.NODE_ENV === 'development' &&\n          typeof window !== 'undefined') ||\n        (opts.direction === 'down' && opts.result instanceof Error),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Suspense with tRPC in Next.js Server Component\nDESCRIPTION: This snippet shows how to leverage Suspense and Error Boundaries with tRPC in a Next.js server component. It demonstrates prefetching the query and wrapping the client component with Suspense and ErrorBoundary.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '~/trpc/server';\nimport { Suspense } from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport { ClientGreeting } from './client-greeting';\n\nexport default async function Home() {\n  void trpc.hello.prefetch();\n\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ErrorBoundary fallback={<div>Something went wrong</div>}>\n        <Suspense fallback={<div>Loading...</div>}>\n          <ClientGreeting />\n        </Suspense>\n      </ErrorBoundary>\n    </HydrateClient>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: tRPC Server Implementation with HTTP Adapter\nDESCRIPTION: Implements the main tRPC router with userList, userById, and userCreate procedures, and sets up an HTTP server on port 3000.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from \"@trpc/server/adapters/standalone\";\nimport { z } from \"zod\";\nimport { db } from \"./db\";\nimport { publicProcedure, router } from \"./trpc\";\n\nconst appRouter = router({\n  userList: publicProcedure\n    .query(async () => {\n      const users = await db.user.findMany();\n      return users;\n    }),\n  userById: publicProcedure\n    .input(z.string())\n    .query(async (opts) => {\n      const { input } = opts;\n      const user = await db.user.findById(input);\n      return user;\n    }),\n  userCreate: publicProcedure\n    .input(z.object({ name: z.string() }))\n    .mutation(async (opts) => {\n      const { input } = opts;\n      const user = await db.user.create(input);\n      return user;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n\nconst server = createHTTPServer({\n  router: appRouter,\n});\n\nserver.listen(3000);\n```\n\n----------------------------------------\n\nTITLE: Updating Infinite Query Cache with setInfiniteQueryData in tRPC React Context (TypeScript)\nDESCRIPTION: This code leverages tRPC's setInfiniteQueryData React helper to modify cached data for infinite queries, typically after mutations such as delete. Inside a mutation's onMutate callback, it cancels existing queries, then updates or initializes cache pages, filtering items to retain only those with status 'published'. It requires tRPC React context utilities and is key for optimistically updating UI after data changes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useInfiniteQuery.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useContext();\n\n  const myMutation = trpc.useMutation('infinitePosts.delete', {\n    onMutate({ post }) {\n      await utils.cancelQuery(['infinitePosts']);\n\n      utils.setInfiniteQueryData(['infinitePosts', { limit: 10 }], (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: []\n          }\n        }\n\n        return {\n          ...data,\n          pages: data.pages.map((page) => {\n            ...page,\n            items: page.items.filter((item) => item.status === 'published')\n          })\n        }\n      });\n    }\n  });\n\n  // [...]\n}\n\n```\n\n----------------------------------------\n\nTITLE: Using zAsyncIterable in tRPC Router for Subscription Validation in TypeScript\nDESCRIPTION: This code demonstrates how to use the zAsyncIterable helper in a tRPC router to validate the output of a subscription procedure. It defines a 'mySubscription' procedure with input and output validation using Zod schemas.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicProcedure, router } from '../trpc';\nimport { zAsyncIterable } from './zAsyncIterable';\n\nexport const appRouter = router({\n  mySubscription: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.coerce.number().min(0).optional(),\n      }),\n    )\n    .output(\n      zAsyncIterable({\n        yield: z.object({\n          count: z.number(),\n        }),\n        tracked: true,\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (true) {\n        index++;\n        yield tracked(index, {\n          count: index,\n        });\n\n        await new Promise((resolve) => setTimeout(resolve, 1000));\n      }\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Short-hand Router Definitions\nDESCRIPTION: Example demonstrating the new short-hand syntax for creating tRPC routers and sub-routers with procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst appRouter = router({\n  // Shorthand plain object for creating a sub-router\n  nested1: {\n    proc: publicProcedure.query(() => '...'),\n  },\n  // Equivalent of:\n  nested2: router({\n    proc: publicProcedure.query(() => '...'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Chaining tRPC Middlewares with `.unstable_pipe()` (TypeScript)\nDESCRIPTION: This snippet illustrates how to chain tRPC middlewares using the `unstable_pipe()` method. It defines `fooMiddleware` which adds `foo: 'foo'` to the context. Then, `barMiddleware` is created by piping from `fooMiddleware`, accessing `ctx.foo` and adding `bar: 'bar'` to the context. A procedure `barProcedure` using `barMiddleware` can then access `ctx.bar`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @target: esnext\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nconst t = initTRPC.create();\nconst publicProcedure = t.procedure;\nconst router = t.router;\nconst middleware = t.middleware;\n\n// ---cut---\n\nconst fooMiddleware = t.middleware((opts) => {\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n\nconst barMiddleware = fooMiddleware.unstable_pipe((opts) => {\n  const { ctx } = opts;\n  ctx.foo;\n  //   ^?\n  return opts.next({\n    ctx: {\n      bar: 'bar' as const,\n    },\n  });\n});\n\nconst barProcedure = publicProcedure.use(barMiddleware);\nbarProcedure.query(({ ctx }) => ctx.bar);\n//                              ^?\n```\n```\n\n----------------------------------------\n\nTITLE: Migrating Classic tRPC Invalidation to New Client Invalidation\nDESCRIPTION: Example of migrating a classic tRPC query invalidation to the new client using TanStack Query's QueryClient. It shows how to replace tRPC's useUtils with direct QueryClient usage.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/migrating.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from './trpc';\n\nfunction Users() {\n  const utils = trpc.useUtils();\n\n  async function invalidateGreeting() {\n    await utils.greeting.invalidate({ name: 'Jerry' });\n  }\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useQuery, useQueryClient } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\n\nfunction Users() {\n  const trpc = useTRPC();\n  const queryClient = useQueryClient();\n\n  async function invalidateGreeting() {\n    await queryClient.invalidateQueries(\n      trpc.greeting.queryFilter({ name: 'Jerry' }),\n    );\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Server Caller in Next.js Server Component\nDESCRIPTION: This snippet demonstrates how to use the tRPC server caller directly in a Next.js server component to fetch data without using React Query or client-side hydration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { caller } from '~/trpc/server';\n\nexport default async function Home() {\n  const greeting = await caller.hello();\n  //    ^? { greeting: string }\n\n  return <div>{greeting.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Up tRPC Without React Context for SPAs\nDESCRIPTION: Demonstrates how to set up tRPC and React Query for single-page applications without using React context. This approach creates singleton instances of QueryClient and tRPC client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/setup.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const queryClient = new QueryClient();\n\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [httpBatchLink({ url: 'http://localhost:2022' })],\n});\n\nexport const trpc = createTRPCOptionsProxy<AppRouter>({\n  client: trpcClient,\n  queryClient,\n});\n```\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport React from 'react';\nimport { queryClient } from './utils/trpc';\n\nexport function App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {/* Your app here */}\n    </QueryClientProvider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using the new TanStack React Query integration with tRPC\nDESCRIPTION: Demonstrates how to use the new TanStack React Query integration with tRPC. The example shows a Greeting component that uses the useQuery hook from TanStack React Query along with the queryOptions factory from tRPC to fetch a greeting with a name parameter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2025-02-17-new-tanstack-react-query-integration.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\n\nexport function Greeting() {\n  const trpc = useTRPC();\n\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n\n  // greetingQuery.data === 'Hello Jerry'\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Event Tracking with tRPC Subscriptions\nDESCRIPTION: Shows how to implement tracked events in tRPC subscriptions for automatic reconnection handling and event ID management.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport EventEmitter, { on } from 'events';\nimport type { Post } from '@prisma/client';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\n\nconst ee = new EventEmitter();\n\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      const iterable = ee.toIterable('add', {\n        signal: opts.signal,\n      });\n\n      if (opts.input.lastEventId) {\n      }\n      for await (const [data] of on(ee, 'add', {\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        yield tracked(post.id, post);\n      }\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for WebSocket Communication (TypeScript)\nDESCRIPTION: This code configures the tRPC client to use WebSocket transport for communication with the server. It creates a persistent WebSocket connection and sets up the tRPC proxy client with the WebSocket link.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/subscriptions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n\n// create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n\n// configure TRPCClient to use WebSockets transport\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseInfiniteQuery Hook in React Component\nDESCRIPTION: This snippet shows how to use the useSuspenseInfiniteQuery hook from tRPC in a React component to fetch paginated posts. It includes options for handling next page parameters and destructuring the query object for pagination controls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/suspense.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n\nfunction PostView() {\n  const [pages, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(\n    {},\n    {\n      getNextPageParam(lastPage) {\n        return lastPage.nextCursor;\n      },\n    },\n  );\n\n  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =\n    allPostsQuery;\n\n  return <>{/* ... */}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Server Router\nDESCRIPTION: Sets up a basic tRPC server router with post-related queries and procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure.query(() => {\n      return {\n        posts: [\n          { id: 1, title: 'everlong' },\n          { id: 2, title: 'After Dark' },\n        ],\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Batch Link with Transformer\nDESCRIPTION: Example showing how to configure the HTTP batch link with a data transformer using superjson in tRPC client setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nhttpBatchLink({\n  url: '/api/trpc',\n  transformer: superjson, // <-- add this\n});\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Experimental Standalone tRPC Middleware (TypeScript)\nDESCRIPTION: This snippet introduces `experimental_standaloneMiddleware` to create reusable middlewares independent of a specific tRPC instance's context. It defines `projectAccessMiddleware` which explicitly requires `ctx.allowedProjects` (string array) and `input.projectId` (string). The example then shows how this middleware can be successfully used with a compatible tRPC instance (`t1`) and procedure input, but fails type checking when the context (`t2`) or input shape doesn't match the middleware's defined requirements.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @target: esnext\nimport {\n  experimental_standaloneMiddleware,\n  initTRPC,\n  TRPCError,\n} from '@trpc/server';\nimport * as z from 'zod';\n\nconst projectAccessMiddleware = experimental_standaloneMiddleware<{\n  ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined\n  input: { projectId: string }; // defaults to 'unknown' if not defined\n  // 'meta', not defined here, defaults to 'object | undefined'\n}>().create((opts) => {\n  if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {\n    throw new TRPCError({\n      code: 'FORBIDDEN',\n      message: 'Not allowed',\n    });\n  }\n\n  return opts.next();\n});\n\nconst t1 = initTRPC\n  .context<{\n    allowedProjects: string[];\n  }>()\n  .create();\n\n// ✅ `ctx.allowedProjects` satisfies \"string[]\" and `input.projectId` satisfies \"string\"\nconst accessControlledProcedure = t1.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n\n// @errors: 2345\n// ❌ `ctx.allowedProjects` satisfies \"string[]\" but `input.projectId` does not satisfy \"string\"\nconst accessControlledProcedure2 = t1.procedure\n  .input(z.object({ projectId: z.number() }))\n  .use(projectAccessMiddleware);\n\n// @errors: 2345\n// ❌ `ctx.allowedProjects` does not satisfy \"string[]\" even though `input.projectId` satisfies \"string\"\nconst t2 = initTRPC\n  .context<{\n    allowedProjects: number[];\n  }>()\n  .create();\n\nconst accessControlledProcedure3 = t2.procedure\n  .input(z.object({ projectId: z.string() }))\n  .use(projectAccessMiddleware);\n```\n```\n\n----------------------------------------\n\nTITLE: Initialize and Start tRPC HTTP Server - TypeScript\nDESCRIPTION: Creates an HTTP server instance using tRPC's createHTTPServer function and starts listening on port 3000. The server is configured with an appRouter to handle API requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/landing-intro/Step2.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst { listen } = createHTTPServer({\n  router: appRouter,\n});\n\n// The API will now be listening on port 3000!\nlisten(3000);\n```\n\n----------------------------------------\n\nTITLE: Creating a tRPC Router in TypeScript\nDESCRIPTION: Example of creating a basic tRPC router with a single procedure for getting user information. It demonstrates input validation using Zod and defines the router structure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/aws-lambda.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nconst appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Cloning Sign-In With Ethereum Authentication Example\nDESCRIPTION: Command to clone a repository demonstrating Sign-In With Ethereum (SIWE) authentication using tRPC and Express.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/example-apps.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:codingwithmanny/trpc-siwe-monorepo.git\n```\n\n----------------------------------------\n\nTITLE: Fetching and Hydrating tRPC Query in Next.js Server Component\nDESCRIPTION: This snippet shows how to fetch a tRPC query on the server and hydrate it to the client using React Query's fetchQuery method. It allows using the data both on the server and in client components.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_14\n\nLANGUAGE: tsx\nCODE:\n```\nimport { getQueryClient, HydrateClient, trpc } from '~/trpc/server';\n\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  const greeting = await queryClient.fetchQuery(trpc.hello.queryOptions());\n\n  // Do something with greeting on the server\n\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperJSON Transformer in tRPC Server\nDESCRIPTION: TypeScript code to add SuperJSON transformer to the tRPC server initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\n\nexport const t = initTRPC.create({\n  transformer: superjson,\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Inline Sub-Routers in tRPC\nDESCRIPTION: Demonstrates two equivalent ways to define inline sub-routers in tRPC using either plain objects or router function. Shows how nested1 and nested2 achieve the same functionality through different syntax.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/merging-routers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  // Shorthand plain object for creating a sub-router\n  nested1: {\n    proc: publicProcedure.query(() => '...'),\n  },\n  // Equivalent of:\n  nested2: router({\n    proc : publicProcedure.query(() => '...'),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Lazy Loading Routers in tRPC\nDESCRIPTION: Implements dynamic router loading using the lazy function to improve cold start performance. Shows two approaches: direct import for single exports and specified import for multiple exports.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/merging-routers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { lazy } from '@trpc/server';\nimport { router } from '../trpc';\n\nexport const appRouter = router({\n  // Option 1: Short-hand lazy load the greeting router if you have exactly 1 export and it is the router\n  greeting: lazy(() => import('./greeting.js')),\n  // Option 2: Alternative way to lazy load if you have more than 1 export\n  user: lazy(() => import('./user.js').then((m) => m.userRouter)),\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Subscription Control in TypeScript\nDESCRIPTION: Example showing how to stop subscriptions from the server side using a generator function. The subscription can be terminated by returning undefined.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst myRouter = router({\n  sub: publicProcedure.subscription(async function* (opts) {\n    for await (const data of on(ee, 'data', {\n      signal: opts.signal,\n    })) {\n      const num = data[0] as number | undefined;\n      if (num === undefined) {\n        // This will now stop the subscription on the client and trigger the `onComplete` callback\n        return;\n      }\n      yield num;\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authorization Middleware in tRPC with TypeScript\nDESCRIPTION: This TypeScript snippet demonstrates creating an authorization middleware within a tRPC router. The middleware checks if the user in the context (`ctx.user`) has admin privileges (`isAdmin`). If not, it throws a `TRPCError` with an 'UNAUTHORIZED' code; otherwise, it calls `next()` to proceed to the protected procedures like 'secretPlace'. The protected router is merged into the main router under the 'admin.' prefix.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/middlewares.md#2025-04-23_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\ntrpc\n  .router<Context>()\n  .query('foo', {\n    resolve() {\n      return 'bar';\n    },\n  })\n  .merge(\n    'admin.',\n    trpc\n      .router<Context>()\n      .middleware(async ({ ctx, next }) => {\n        if (!ctx.user?.isAdmin) {\n          throw new TRPCError({ code: 'UNAUTHORIZED' });\n        }\n        return next();\n      })\n      .query('secretPlace', {\n        resolve() {\n          return 'a key';\n        },\n      }),\n  );\n```\n\n----------------------------------------\n\nTITLE: Recursively Decorating a tRPC Router Structure\nDESCRIPTION: Defines a recursive type that traverses a tRPC router structure and applies the procedure decorator to each procedure, maintaining the structure of routers and sub-routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { TRPCRouterRecord } from \"@trpc/server\";\nimport type { AnyTRPCRouter } from \"@trpc/server\";\n\ntype DecorateRouterRecord<TRecord extends TRPCRouterRecord> = {\n  [TKey in keyof TRecord]: TRecord[TKey] extends infer $Value\n    ? $Value extends TRPCRouterRecord\n      ? DecorateRouterRecord<$Value>\n      : $Value extends AnyTRPCProcedure\n      ? DecorateProcedure<$Value>\n      : never\n    : never;\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing FormData and Binary Content Type Support in tRPC v11\nDESCRIPTION: This snippet demonstrates how to handle FormData and binary data types like Blob, File, and Uint8Array in tRPC v11. It shows the creation of procedures that accept FormData or binary input using the octetInputParser.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2025-03-21-announcing-trpc-11.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicProcedure, router } from './trpc';\nimport { octetInputParser } from '@trpc/server/http';\nimport { z } from 'zod';\n\nconst appRouter = router({\n  formData: publicProcedure\n    .input(z.instanceof(FormData))\n    .mutation(async ({ input }) => {\n      //                ^?\n    }),\n  file: publicProcedure\n    .input(octetInputParser)\n    .mutation(async ({ input }) => {\n      //                ^?\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC API Route in SolidStart with Fetch Adapter\nDESCRIPTION: This snippet sets up a tRPC API route handler for SolidStart (`src/routes/api/trpc/[trpc].ts`). It defines a `handler` function that takes a SolidStart `APIEvent` and uses `fetchRequestHandler` to process the request. The handler is configured with the API endpoint (`/api/trpc`), the request object from the event, the `appRouter`, and the `createContext` function. It's exported for both GET and POST HTTP methods. Dependencies include `@trpc/server/adapters/fetch`, `solid-start`, `../../server/context`, and `../../server/router`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title='src/routes/api/trpc/[trpc].ts'\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIEvent } from 'solid-start';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\n\nconst handler = (event: APIEvent) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req: event.request,\n    router: appRouter,\n    createContext,\n  });\nexport { handler as GET, handler as POST };\n```\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC React Client\nDESCRIPTION: Sets up the tRPC React client by creating a utility using createTRPCReact that's typed with the AppRouter. This client is used throughout the examples to make type-safe queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: utils/trpc.tsx\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication Login with tRPC\nDESCRIPTION: Shows how to implement an authentication login mutation that updates the token upon successful login. Demonstrates the integration with the custom headers setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/headers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMut = trpc.auth.login.useMutation({\n  onSuccess(opts) {\n    token = opts.accessToken;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing AWS Lambda Handler with tRPC Adapter\nDESCRIPTION: Example of using the tRPC AWS Lambda adapter to create a handler for API Gateway. It shows how to set up the context and use the awsLambdaRequestHandler to integrate tRPC with AWS Lambda.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/aws-lambda.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\n\nconst appRouter = /* ... */;\n\n// created for each request\nconst createContext = ({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n})\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Server Caller for Next.js\nDESCRIPTION: This snippet shows how to create a tRPC server caller for direct use in Next.js server components. It allows accessing tRPC procedures without going through the React Query cache.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_12\n\nLANGUAGE: tsx\nCODE:\n```\n// ...\nexport const caller = appRouter.createCaller(createTRPCContext);\n```\n\n----------------------------------------\n\nTITLE: Recommended File Structure for tRPC Next.js Project\nDESCRIPTION: Demonstrates the recommended directory structure for organizing a tRPC project within a Next.js application, showing key file locations and their purposes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n.\n├── prisma  # <-- if prisma is added\n│   └── [..]\n├── src\n│   ├── pages\n│   │   ├── _app.tsx  # <-- add `withTRPC()`-HOC here\n│   │   ├── api\n│   │   │   └── trpc\n│   │   │       └── [trpc].ts  # <-- tRPC HTTP handler\n│   │   └── [..]\n│   ├── server\n│   │   ├── routers\n│   │   │   ├── _app.ts  # <-- main app router\n│   │   │   ├── post.ts  # <-- sub routers\n│   │   │   └── [..]\n│   │   ├── context.ts   # <-- create app context\n│   │   └── trpc.ts      # <-- procedure helpers\n│   └── utils\n│       └── trpc.ts  # <-- your typesafe tRPC hooks\n└── [..]\n```\n\n----------------------------------------\n\nTITLE: Defining Nested Procedures in tRPC Router (TypeScript)\nDESCRIPTION: Example of defining nested procedures in a tRPC router. The 'post.byId' procedure is accessible via the path '/api/trpc/post.byId'.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = router({\n  post: router({\n    byId: publicProcedure.input(String).query(async (opts) => {\n      // [...]\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Per-Route Authentication with tRPC Metadata in TypeScript\nDESCRIPTION: This example illustrates a practical application of route metadata for controlling authentication. It defines a `Meta` interface with a `hasAuth` flag, creates a router using this metadata type, and implements a middleware that checks for user authentication (`ctx.user`) only if the accessed route's `meta.hasAuth` property is set to `true`. Two query routes (`hello` and `protected-hello`) show how to set this metadata differently for each route.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/metadata.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as trpc from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  hasAuth: boolean;\n}\n\nexport const appRouter = trpc\n  .router<Context, Meta>()\n  .middleware(async ({ meta, next, ctx }) => {\n    // only check authorization if enabled\n    if (meta?.hasAuth && !ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return next();\n  })\n  .query('hello', {\n    meta: {\n      hasAuth: false,\n    },\n    resolve({ ctx }) {\n      return {\n        greeting: `hello world`,\n      };\n    },\n  })\n  .query('protected-hello', {\n    meta: {\n      hasAuth: true,\n    },\n    resolve({ ctx }) {\n      return {\n        greeting: `hello world`,\n      };\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating a Type Decorator for tRPC Procedures\nDESCRIPTION: Defines a conditional type that decorates procedures differently based on their type. Query procedures get a 'query' method while mutation procedures get a 'mutate' method, each with correct input and output types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype DecorateProcedure<TProcedure> = TProcedure extends AnyTRPCQueryProcedure\n  ? {\n      query: Resolver<TProcedure>;\n    }\n  : TProcedure extends AnyTRPCMutationProcedure\n  ? {\n      mutate: Resolver<TProcedure>;\n    }\n  : never;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for WebSocket Communication\nDESCRIPTION: Sets up a tRPC client to use WebSocket transport for communication with the server. Creates a persistent WebSocket connection and configures the client to use it.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n\n// create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n\n// configure TRPCClient to use WebSockets transport\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing API Response Caching in tRPC Server\nDESCRIPTION: Server-side implementation of response caching using tRPC router and Next.js API handler. Includes context creation, router setup, and cache control configuration for public routes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/caching.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { inferAsyncReturnType } from '@trpc/server';\nimport * as trpcNext from '@trpc/server/adapters/next';\n\nexport const createContext = async ({\n  req,\n  res,\n}: trpcNext.CreateNextContextOptions) => {\n  return {\n    req,\n    res,\n    prisma,\n  };\n};\n\ntype Context = inferAsyncReturnType<typeof createContext>;\n\nexport function createRouter() {\n  return trpc.router<Context>();\n}\n\nconst waitFor = async (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n\nexport const appRouter = createRouter().query('public.slow-query-cached', {\n  async resolve({ ctx }) {\n    await waitFor(5000); // wait for 5s\n\n    return {\n      lastUpdated: new Date().toJSON(),\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n\nexport default trpcNext.createNextApiHandler({\n  router: appRouter,\n  createContext,\n  responseMeta({ ctx, paths, type, errors }) {\n    const allPublic = paths && paths.every((path) => path.includes('public'));\n    const allOk = errors.length === 0;\n    const isQuery = type === 'query';\n\n    if (ctx?.res && allPublic && allOk && isQuery) {\n      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n      return {\n        headers: {\n          'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n        },\n      };\n    }\n    return {};\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC useQueries with Individual Query Options\nDESCRIPTION: Shows how to provide individual query options like enabled and suspense to different queries within useQueries. Also demonstrates handling query results and implementing refetch functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQueries.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = () => {\n  const [post, greeting] = trpc.useQueries((t) => [\n    t.post.byId({ id: '1' }, { enabled: false }),\n    t.greeting({ text: 'world' }),\n  ]);\n\n  const onButtonClick = () => {\n    post.refetch();\n  };\n\n  return (\n    <div>\n      <h1>{post.data && post.data.title}</h1>\n      <p>{greeting.data.message}</p>\n      <button onClick={onButtonClick}>Click to fetch</button>\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Setting SuperJSON as Transformer in tRPC Server Router - TypeScript\nDESCRIPTION: Defines an appRouter in tRPC, attaching SuperJSON as the data transformer for all incoming and outgoing data. This ensures consistency with the client in parsing advanced data types. Requires @trpc/server and superjson as dependencies. Core functionality is invoking .transformer(superjson) on the router instance.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport superjson from 'superjson';\n\nexport const appRouter = trpc.router().transformer(superjson);\n// .query(...)\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Server with Fetch Adapter in Deno\nDESCRIPTION: This snippet demonstrates how to create a basic tRPC server using Deno. It imports `fetchRequestHandler` from `@trpc/server/adapters/fetch`, along with the application's router (`appRouter`) and context creation function (`createContext`). A `handler` function is defined to process incoming requests via `fetchRequestHandler`, which is then served using `Deno.serve`. Dependencies include `@trpc/server`, the Deno runtime, `./context.ts`, and `./router.ts`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title='server.ts'\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\n\nfunction handler(request) {\n  return fetchRequestHandler({\n    endpoint: '/trpc',\n    req: request,\n    router: appRouter,\n    createContext,\n  });\n}\n\nDeno.serve(handler);\n```\n```\n\n----------------------------------------\n\nTITLE: Encoding Input for Batched tRPC Queries\nDESCRIPTION: This snippet demonstrates how to encode input parameters for batched tRPC queries. It shows the structure of the input object and how it's serialized for HTTP transmission.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/rpc.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nencodeURIComponent(\n  JSON.stringify({\n    0: '1', // <-- input for `postById`\n    1: '1', // <-- input for `relatedPosts`\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Mutation Example with tRPC Caller\nDESCRIPTION: Shows how to implement and call a mutation procedure for adding posts to an array.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst posts = ['One', 'Two', 'Three'];\n\nconst t = initTRPC.create();\nconst router = t.router({\n  post: t.router({\n    add: t.procedure.input(z.string()).mutation((opts) => {\n      posts.push(opts.input);\n      return posts;\n    }),\n  }),\n});\n\nconst caller = router.createCaller({});\nconst result = await caller.post.add('Four');\n```\n\n----------------------------------------\n\nTITLE: Server-side Timeout Configuration\nDESCRIPTION: Shows how to configure server-side timeout settings for the tRPC initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.create({\n  sse: {\n    client: {\n      reconnectAfterInactivityMs: 3_000,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Per-Route Authentication in tRPC with TypeScript\nDESCRIPTION: This code snippet shows how to implement per-route authentication settings using tRPC metadata. It defines an 'authedProcedure' that checks for user authentication based on the 'authRequired' metadata property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/metadata.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  authRequired: boolean;\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const authedProcedure = t.procedure.use(async (opts) => {\n  const { meta, next, ctx } = opts;\n  // only check authorization if enabled\n  if (meta?.authRequired && !ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n  return next();\n});\n\nexport const appRouter = t.router({\n  hello: authedProcedure.meta({ authRequired: false }).query(() => {\n    return {\n      greeting: 'hello world',\n    };\n  }),\n  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {\n    return {\n      greeting: 'hello-world',\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Default Error Shape Interfaces (TypeScript)\nDESCRIPTION: Defines the TypeScript interfaces `DefaultErrorData` and `DefaultErrorShape` which represent the standard structure of an error object formatted by tRPC. This includes properties like `code`, `httpStatus`, `path`, `stack`, and `message`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-formatting.md#2025-04-23_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n```ts\ninterface DefaultErrorData {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  path?: string;\n  stack?: string;\n}\n\ninterface DefaultErrorShape\n  extends TRPCErrorShape<TRPC_ERROR_CODE_NUMBER, DefaultErrorData> {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Accessing and Validating Raw Input in tRPC Middleware with TypeScript\nDESCRIPTION: This TypeScript example shows how to access the `rawInput` (of type `unknown`) within a tRPC middleware before standard validation. It uses `zod` (`inputSchema.safeParse`) to preliminarily validate the raw input. If successful, it extracts data (`userId`), potentially performs checks, and modifies the context for downstream procedures via `next({ ctx: { ...ctx, userId } })`. The actual procedure ('userId') still defines its input schema for formal validation and uses the `userId` added to the context by the middleware.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/middlewares.md#2025-04-23_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst inputSchema = z.object({ userId: z.string() });\n\ntrpc\n  .router<Context>()\n  .middleware(async ({ next, rawInput, ctx }) => {\n    const result = inputSchema.safeParse(rawInput);\n    if (!result.success) throw new TRPCError({ code: 'BAD_REQUEST' });\n    const { userId } = result.data;\n    // Check user id auth\n    return next({ ctx: { ...ctx, userId } });\n  })\n  .query('userId', {\n    input: inputSchema,\n    resolve({ ctx }) {\n      return ctx.userId;\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Invalidating Queries Across Multiple Levels with useUtils\nDESCRIPTION: Example showing how to invalidate queries at different levels: across all routers, within a specific router, or for a single procedure with specific input parameters.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n\n  const invalidateAllQueriesAcrossAllRouters = () => {\n    // 1️⃣\n    // All queries on all routers will be invalidated 🔥\n    utils.invalidate();\n  };\n\n  const invalidateAllPostQueries = () => {\n    // 2️⃣\n    // All post queries will be invalidated 📭\n    utils.post.invalidate();\n  };\n\n  const invalidatePostById = () => {\n    // 3️⃣\n    // All queries in the post router with input {id:1} invalidated 📭\n    utils.post.byId.invalidate({ id: 1 });\n  };\n\n  // Example queries\n  trpc.user.all.useQuery(); // Would only be validated by 1️⃣ only.\n  trpc.post.all.useQuery(); // Would be invalidated by 1️⃣ & 2️⃣\n  trpc.post.byId.useQuery({ id: 1 }); // Would be invalidated by 1️⃣, 2️⃣ and 3️⃣\n  trpc.post.byId.useQuery({ id: 2 }); // would be invalidated by 1️⃣ and 2️⃣ but NOT 3️⃣!\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Queries in Components\nDESCRIPTION: Example of using tRPC query hooks in a React component to fetch data with full type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/react-query/README.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\n\nexport function Hello() {\n  const { data, error, status } = trpc.greeting.useQuery({ name: 'tRPC' });\n\n  if (error) {\n    return <p>{error.message}</p>;\n  }\n\n  if (status !== 'success') {\n    return <p>Loading...</p>;\n  }\n\n  return <div>{data && <p>{data.greeting}</p>}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using setInfiniteData Helper in tRPC React Component\nDESCRIPTION: This example shows how to use the setInfiniteData helper function to update a query's cached data in a tRPC React component, specifically for filtering items based on their status.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useInfiniteQuery.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n\n  const myMutation = trpc.infinitePosts.delete.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n\n      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            items: page.items.filter((item) => item.status === 'published'),\n          })),\n        };\n      });\n    },\n  });\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC React Query Utils\nDESCRIPTION: Setup for creating and exporting tRPC hooks and providers in a utils file.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/react-query/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from './server';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic tRPC Router in TypeScript\nDESCRIPTION: Example of implementing a simple tRPC router with a single procedure for getting user information. It demonstrates the use of input validation with Zod and exporting the router type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/aws-lambda.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nconst appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    opts.input; // string\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Output Validation Logic in a tRPC Query using TypeScript\nDESCRIPTION: This snippet shows how to implement custom output validation logic for a tRPC query ('hello') using a plain JavaScript function passed to the `output` property. The function checks if the resolved value is an object with a string property named 'greeting'; if the structure is valid, it returns the validated object, otherwise, it throws an error, causing a server error response. The router type `AppRouter` is exported.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/output-validation.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport * as t from 'superstruct';\n\n// [...]\n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  output: (value: any) => {\n    if (value && typeof value.greeting === 'string') {\n      return { greeting: value.greeting };\n    }\n    throw new Error('Greeting not found');\n  },\n  // expects return type of { greeting: string }\n  resolve() {\n    return { greeting: 'hello!' };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Basic tRPC useQueries Implementation\nDESCRIPTION: Demonstrates how to use the useQueries hook to fetch multiple posts by their IDs in a single hook call. This implementation is optimized when using httpBatchLink or wsLink, resulting in a single HTTP call.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst Component = (props: { postIds: string[] }) => {\n  const postQueries = trpc.useQueries((t) =>\n    props.postIds.map((id) => t.post.byId({ id })),\n  );\n\n  return <>{/* [...] */}</>;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Split Link for Mixed Content Types\nDESCRIPTION: Advanced tRPC client setup using splitLink to handle both JSON and non-JSON content types by routing them to appropriate links.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/non-json-content-types.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  httpBatchLink,\n  httpLink,\n  isNonJsonSerializable,\n  splitLink,\n} from '@trpc/client';\n\ntrpc.createClient({\n  links: [\n    splitLink({\n      condition: (op) => isNonJsonSerializable(op.input),\n      true: httpLink({\n        url,\n      }),\n      false: httpBatchLink({\n        url,\n      }),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Backend Router\nDESCRIPTION: Example of setting up a tRPC router on the backend with a 'hello' procedure that accepts optional text input and returns a greeting.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Create procedure at path 'hello'\n  hello: t.procedure\n    // using zod schema to validate and infer input values\n    .input(\n      z\n        .object({\n          text: z.string().nullish(),\n        })\n        .nullish(),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input?.text ?? 'world'}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Rate-Limited Action Middleware in TypeScript\nDESCRIPTION: This snippet shows how to create a rate-limited action middleware using Unkey. It sets up rate limiting parameters and throws an error if the limit is exceeded.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Ratelimit } from '@unkey/ratelimit';\n\nexport const rateLimitedAction = protectedAction.use(async (opts) => {\n  const unkey = new Ratelimit({\n    rootKey: process.env.UNKEY_ROOT_KEY!,\n    async: true,\n    duration: '10s',\n    limit: 5,\n    namespace: `trpc_${opts.path}`,\n  });\n\n  const ratelimit = await unkey.limit(opts.ctx.user.id);\n  if (!ratelimit.success) {\n    throw new TRPCError({\n      code: 'TOO_MANY_REQUESTS',\n      message: JSON.stringify(ratelimit),\n    });\n  }\n\n  return opts.next();\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing AWS Lambda Request Handler\nDESCRIPTION: Setup of the AWS Lambda request handler using tRPC's built-in adapter. Includes context creation and handler configuration for API Gateway integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/aws-lambda.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\n\nconst appRouter = /* ... */;\n\n// created for each request\nconst createContext = ({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions) => ({}) // no context\ntype Context = trpc.inferAsyncReturnType<typeof createContext>;\n\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n})\n```\n\n----------------------------------------\n\nTITLE: Input Merging with tRPC Middleware\nDESCRIPTION: Shows how to stack multiple input validators and combine them with middleware for more complex validation scenarios.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/validators.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst baseProcedure = t.procedure\n  .input(z.object({ townName: z.string() }))\n  .use((opts) => {\n    const input = opts.input;\n    console.log(`Handling request with user from: ${input.townName}`);\n    return opts.next();\n  });\n\nexport const appRouter = t.router({\n  hello: baseProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const input = opts.input;\n      return {\n        greeting: `Hello ${input.name}, my friend from ${input.townName}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Handler in Vercel Edge Runtime with Fetch Adapter\nDESCRIPTION: This code demonstrates setting up a tRPC handler within the Vercel Edge Runtime environment. It uses the standard `addEventListener` interface to listen for 'fetch' events. Inside the event listener, `event.respondWith` is called with the result of `fetchRequestHandler`, which processes the incoming request (`event.request`) using the application's `appRouter` and `createContext`. Dependencies include `@trpc/server/adapters/fetch`, `./context`, and `./router`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\n```ts title='server.ts'\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\naddEventListener('fetch', (event) => {\n  return event.respondWith(\n    fetchRequestHandler({\n      endpoint: '/trpc',\n      req: event.request,\n      router: appRouter,\n      createContext,\n    }),\n  );\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Inferring React Query Options in TypeScript\nDESCRIPTION: This code shows how to infer React Query options, router inputs, and router outputs from the AppRouter type. It uses the createTRPCReact function to create a tRPC client for React.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCReact,\n  type inferReactQueryProcedureOptions,\n} from '@trpc/react-query';\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n\n// infer the types for your router\nexport type ReactQueryOptions = inferReactQueryProcedureOptions<AppRouter>;\nexport type RouterInputs = inferRouterInputs<AppRouter>;\nexport type RouterOutputs = inferRouterOutputs<AppRouter>;\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Initializing HTTP Batch Link in TypeScript Client\nDESCRIPTION: Basic setup of httpBatchLink for a tRPC client. Shows how to create a client instance with httpBatchLink configuration pointing to a local server.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n    // transformer,\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using the tRPC Proxy Client from useUtils\nDESCRIPTION: Example showing how to access the tRPC proxy client through useUtils to directly call procedures with async/await in event handlers without creating an additional vanilla client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction MyComponent() {\n  const [apiKey, setApiKey] = useState();\n  const utils = trpc.useUtils();\n\n  return (\n    <Form\n      handleSubmit={async (event) => {\n        const apiKey = await utils.client.apiKey.create.mutate(event);\n        setApiKey(apiKey);\n      }}\n    >\n      ...\n    </Form>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Request-Specific Context for tRPC with Fastify (TypeScript)\nDESCRIPTION: This TypeScript code defines a function to create a request-specific context object for each tRPC procedure invocation. The context function uses Fastify's request and response objects, extracting the username from headers or defaulting to 'anonymous', and is typed with inferAsyncReturnType for safe downstream access. This context is critical for per-request authentication, permissions, or logging. Save as 'context.ts' and ensure it's imported wherever context is required.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inferAsyncReturnType } from '@trpc/server';\nimport { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';\n\nexport function createContext({ req, res }: CreateFastifyContextOptions) {\n  const user = { name: req.headers.username ?? 'anonymous' };\n\n  return { req, res, user };\n}\n\nexport type Context = inferAsyncReturnType<typeof createContext>;\n```\n\n----------------------------------------\n\nTITLE: Implementing Tracked Subscriptions in tRPC\nDESCRIPTION: Demonstrates how to implement tracked subscriptions in tRPC, allowing automatic reconnection and event tracking. Uses the 'tracked' helper to manage subscription state.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport EventEmitter, { on } from 'events';\nimport { tracked } from '@trpc/server';\nimport { z } from 'zod';\nimport { publicProcedure, router } from '../trpc';\n\nconst ee = new EventEmitter();\n\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z\n        .object({\n          // lastEventId is the last event id that the client has received\n          // On the first call, it will be whatever was passed in the initial setup\n          // If the client reconnects, it will be the last event id that the client received\n          lastEventId: z.string().nullish(),\n        })\n        .optional(),\n    )\n    .subscription(async function* (opts) {\n      if (opts.input.lastEventId) {\n        // [...] get the posts since the last event id and yield them\n      }\n      // listen for new events\n      for await (const [data] of on(ee, 'add', {\n        // Passing the AbortSignal from the request automatically cancels the event emitter when the subscription is aborted\n        signal: opts.signal,\n      })) {\n        const post = data as Post;\n        // tracking the post id ensures the client can reconnect at any time and get the latest events this id\n        yield tracked(post.id, post);\n      }\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Server Package\nDESCRIPTION: Commands for installing @trpc/server package using different package managers including npm, yarn, pnpm, and bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/server/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @trpc/server\n\n# Yarn\nyarn add @trpc/server\n\n# pnpm\npnpm add @trpc/server\n\n# Bun\nbun add @trpc/server\n```\n\n----------------------------------------\n\nTITLE: DataTransformer Interface Definition in TypeScript\nDESCRIPTION: TypeScript interface definitions for DataTransformer, InputDataTransformer, OutputDataTransformer, and CombinedDataTransformer used in tRPC for data transformation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface DataTransformer {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n}\n\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize(object: any): any;\n}\n\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize(object: any): any;\n}\n\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\n```\n\n----------------------------------------\n\nTITLE: Extract HTTP Status Code from tRPC Error\nDESCRIPTION: Demonstrates how to use the getHTTPStatusCodeFromError helper function to extract HTTP status codes from tRPC errors.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-handling.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\n\n// Example error you might get if your input validation fails\nconst error: TRPCError = {\n  name: 'TRPCError',\n  code: 'BAD_REQUEST',\n  message: '\\\"password\\\" must be at least 4 characters',\n};\n\nif (error instanceof TRPCError) {\n  const httpCode = getHTTPStatusCodeFromError(error);\n  console.log(httpCode); // 400\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client with Basic Query Example\nDESCRIPTION: Example showing how to initialize a tRPC client with httpBatchLink and perform a basic query. Demonstrates type importing from server and async query execution.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/client/README.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\n// Importing the router type from the server file\nimport type { AppRouter } from './server';\n\n// Initializing the tRPC client\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000/trpc',\n    }),\n  ],\n});\n\nasync function main() {\n  // Querying the greeting\n  const helloResponse = await trpc.greeting.query({\n    name: 'world',\n  });\n\n  console.log('helloResponse', helloResponse); // Hello world\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Context\nDESCRIPTION: Implementation of request context creation for tRPC server with user authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch';\n\nexport function createContext({\n  req,\n  resHeaders,\n}: FetchCreateContextFnOptions) {\n  const user = { name: req.headers.get('username') ?? 'anonymous' };\n  return { req, resHeaders, user };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Headers with Next.js\nDESCRIPTION: Demonstrates setting up custom headers in tRPC configuration using withTRPC HOC in Next.js. Shows how to implement dynamic header generation with authorization token.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/header.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '@/server/routers/app';\nimport { withTRPC } from '@trpc/next';\nimport { AppType } from 'next/dist/shared/lib/utils';\n\nexport let token: string;\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default withTRPC<AppRouter>({\n  config({ ctx }) {\n    return {\n      links: [\n        httpBatchLink({\n          /** headers are called on every request */\n          headers: () => {\n            return {\n              Authorization: token,\n            };\n          },\n        }),\n      ],\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Handling tRPC Errors in React Component\nDESCRIPTION: Shows how to handle formatted errors in a React component using tRPC's useMutation hook. Demonstrates error handling for Zod validation errors with type inference.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-formatting.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nexport function MyComponent() {\n  const mutation = trpc.addPost.useMutation();\n\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using Logging Middleware in a tRPC Router (TypeScript)\nDESCRIPTION: This snippet shows how to apply the `loggedProcedure` middleware to multiple query procedures (`foo` and `abc`) within a tRPC router (`appRouter`). Any calls to these procedures will automatically have their execution time logged as defined in the `loggedProcedure` middleware.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\n// @filename: trpc.ts\n// @include: trpclogger\n// @filename: _app.ts\n// ---cut---\nimport { loggedProcedure, router } from './trpc';\n\nexport const appRouter = router({\n  foo: loggedProcedure.query(() => 'bar'),\n  abc: loggedProcedure.query(() => 'def'),\n});\n```\n```\n\n----------------------------------------\n\nTITLE: Implementing Rate-Limited Server Action in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the rate-limited action middleware in a server-side mutation. It defines a 'commentOnPost' action with input validation using Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n'use server';\n\nimport { z } from 'zod';\nimport { rateLimitedAction } from '../server/trpc';\n\nexport const commentOnPost = rateLimitedAction\n  .input(\n    z.object({\n      postId: z.string(),\n      content: z.string(),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    console.log(\n      `${ctx.user.name} commented on ${input.postId} saying ${input.content}`,\n    );\n  });\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Hooks with React Query\nDESCRIPTION: Code snippet demonstrating how to create strongly-typed React hooks from the AppRouter type signature using createTRPCReact.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server/router';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Resulting Error Response from Thrown TRPCError - JSON\nDESCRIPTION: Sample JSON response emitted when a custom TRPCError is thrown inside a tRPC procedure. The error object contains message, RPC code, error type, HTTP status, stack trace, and the route path. This format is essential for debugging API errors and informs clients of failure conditions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-handling.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"id\": null,\\n  \"error\": {\\n    \"message\": \"An unexpected error occurred, please try again later.\",\\n    \"code\": -32603,\\n    \"data\": {\\n      \"code\": \"INTERNAL_SERVER_ERROR\",\\n      \"httpStatus\": 500,\\n      \"stack\": \"...\",\\n      \"path\": \"hello\"\\n    }\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Making tRPC API Requests in Next.js Component\nDESCRIPTION: This TypeScript code demonstrates how to make tRPC API requests in a Next.js component. It uses the trpc.useQuery hook to fetch data and renders the result.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const hello = trpc.useQuery(['hello', { text: 'client' }]);\n  if (!hello.data) {\n    return <div>Loading...</div>;\n  }\n  return (\n    <div>\n      <p>{hello.data.greeting}</p>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a tRPC App Router with Hello Procedure\nDESCRIPTION: Defines a tRPC router with a sample 'hello' query procedure that takes a text input and returns a greeting. This represents the main API definition that will be exposed to clients.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z } from 'zod';\nimport { baseProcedure, createTRPCRouter } from '../init';\n\nexport const appRouter = createTRPCRouter({\n  hello: baseProcedure\n    .input(\n      z.object({\n        text: z.string(),\n      }),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input.text}`,\n      };\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Links with Next.js\nDESCRIPTION: Example of configuring tRPC client with multiple links including logger and HTTP batch links. Shows basic setup for Next.js integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/overview.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink, loggerLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nexport default createTRPCNext<AppRouter>({\n  config() {\n    const url = `http://localhost:3000`;\n\n    return {\n      links: [\n        loggerLink(),\n        httpBatchLink({\n          url,\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing SSG with tRPC in Next.js Page Component\nDESCRIPTION: This code demonstrates how to implement Static Site Generation using tRPC in a Next.js page component. It includes getStaticProps for data fetching, getStaticPaths for dynamic routes, and the main component for rendering the fetched data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/ssg.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport {\n  GetStaticPaths,\n  GetStaticPropsContext,\n  InferGetStaticPropsType,\n} from 'next';\nimport { prisma } from 'server/context';\nimport { appRouter } from 'server/routers/_app';\nimport superjson from 'superjson';\nimport { trpc } from 'utils/trpc';\n\nexport async function getStaticProps(\n  context: GetStaticPropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson, // optional - adds superjson serialization\n  });\n  const id = context.params?.id as string;\n\n  // prefetch `post.byId`\n  await helpers.post.byId.prefetch({ id });\n\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n    revalidate: 1,\n  };\n}\n\nexport const getStaticPaths: GetStaticPaths = async () => {\n  const posts = await prisma.post.findMany({\n    select: {\n      id: true,\n    },\n  });\n\n  return {\n    paths: posts.map((post) => ({\n      params: {\n        id: post.id,\n      },\n    })),\n    // https://nextjs.org/docs/pages/api-reference/functions/get-static-paths#fallback-blocking\n    fallback: 'blocking',\n  };\n};\n\nexport default function PostViewPage(\n  props: InferGetStaticPropsType<typeof getStaticProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n\n  if (postQuery.status !== 'success') {\n    // won't happen since we're using `fallback: \"blocking\"`\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>\n\n      <p>{data.text}</p>\n\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC, Fastify, and Zod dependencies using Yarn (Bash)\nDESCRIPTION: This Bash snippet installs the @trpc/server, fastify, and zod packages via Yarn. While Zod is optional, it's used for input validation in the router example. Run this in your project directory to ensure all dependencies required for developing and running a tRPC-powered Fastify server in TypeScript are available.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server fastify zod\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Mutations in React Components\nDESCRIPTION: Demonstrates how to use tRPC mutations in a React component to add a new todo item. The example shows integrating a mutation with form input handling in a functional component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2021-05-05-hello-world.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nconst addTask = trpc.useMutation('todos.add');\n\nreturn (\n  <>\n    <input\n      placeholder=\"What needs to be done?\"\n      onKeyDown={(e) => {\n        const text = e.currentTarget.value.trim();\n        if (e.key === 'Enter' && text) {\n          addTask.mutate({ text });\n          e.currentTarget.value = '';\n        }\n      }}\n    />\n  </>\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing a Minimal tRPC Client in TypeScript\nDESCRIPTION: This code snippet demonstrates the creation of a minimal tRPC client using TypeScript. It includes handling of API requests, path construction, and error management. The function uses generics to accept any tRPC router type and returns a decorated router record.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const createTinyRPCClient = <TRouter extends AnyTRPCRouter>(\n  baseUrl: string,\n) =>\n  createRecursiveProxy(async (opts) => {\n    const path = [...opts.path]; // e.g. [\"post\", \"byId\", \"query\"]\n    const method = path.pop()! as 'query' | 'mutate';\n    const dotPath = path.join('.'); // \"post.byId\" - this is the path procedures have on the backend\n    let uri = `${baseUrl}/${dotPath}`;\n\n    const [input] = opts.args;\n    const stringifiedInput = input !== undefined && JSON.stringify(input);\n    let body: undefined | string = undefined;\n    if (stringifiedInput !== false) {\n      if (method === 'query') {\n        uri += `?input=${encodeURIComponent(stringifiedInput)}`;\n      } else {\n        body = stringifiedInput;\n      }\n    }\n\n    const json: TRPCResponse = await fetch(uri, {\n      method: method === 'query' ? 'GET' : 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body,\n    }).then((res) => res.json());\n\n    if ('error' in json) {\n      throw new Error(`Error: ${json.error.message}`);\n    }\n    // No error - all good. Return the data.\n    return json.result.data;\n  }, []) as DecorateRouterRecord<TRouter['_def']['record']>;\n```\n\n----------------------------------------\n\nTITLE: Creating a tRPC Server Caller for Server Components\nDESCRIPTION: Implements a server-side tRPC client using a proxy approach for prefetching queries from server components. Uses React's cache function to ensure the same query client is used throughout a request and enforces server-only imports.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport 'server-only'; // <-- ensure this file cannot be imported from the client\n\nimport { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';\nimport { cache } from 'react';\nimport { createTRPCContext } from './init';\nimport { makeQueryClient } from './query-client';\nimport { appRouter } from './routers/_app';\n\n// IMPORTANT: Create a stable getter for the query client that\n//            will return the same client during the same request.\nexport const getQueryClient = cache(makeQueryClient);\n\nexport const trpc = createTRPCOptionsProxy({\n  ctx: createTRPCContext,\n  router: appRouter,\n  queryClient: getQueryClient,\n});\n\n// If your router is on a separate server, pass a client:\ncreateTRPCOptionsProxy({\n  client: createTRPCClient({\n    links: [httpLink({ url: '...' })],\n  }),\n  queryClient: getQueryClient,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom tRPC Link\nDESCRIPTION: Demonstrates how to create a custom tRPC link for advanced request handling and error logging.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TRPCLink } from '@trpc/client';\nimport type { AppRouter } from 'pages/api/trpc/[trpc]';\n\nconst customLink: TRPCLink<AppRouter> = (runtime) => {\n  // here we just got initialized in the app - this happens once per app\n  // useful for storing cache for instance\n  return ({ prev, next, op }) => {\n    // this is when passing the result to the next link\n    next(op, (result) => {\n      // this is when we've gotten result from the server\n      if (result instanceof Error) {\n        // maybe send to bugsnag?\n      }\n      prev(result);\n    });\n  };\n};\n\nexport default withTRPC<AppRouter>({\n  config() {\n    return {\n      links: [\n        customLink,\n        // [..]\n        // ❗ Make sure to end with a `httpBatchLink` or `httpLink`\n      ],\n    };\n  },\n  // ssr: false\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Inferring TRPCClientError Types in TypeScript\nDESCRIPTION: This snippet shows how to infer and use the TRPCClientError type for error handling in a tRPC client. It includes a type guard function and an example of using the inferred error type in a try-catch block.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/infer-types.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { TRPCClientError } from '@trpc/client';\nimport type { AppRouter } from './server';\nimport { trpc } from './trpc';\n\nexport function isTRPCClientError(\n  cause: unknown,\n): cause is TRPCClientError<AppRouter> {\n  return cause instanceof TRPCClientError;\n}\n\nasync function main() {\n  try {\n    await trpc.post.byId.query('1');\n  } catch (cause) {\n    if (isTRPCClientError(cause)) {\n      // `cause` is now typed as your router's `TRPCClientError`\n      console.log('data', cause.data);\n      //                        ^?\n    } else {\n      // [...]\n    }\n  }\n}\n\nmain();\n```\n\n----------------------------------------\n\nTITLE: Implementing Server-Side Helpers in Next.js Page with TypeScript\nDESCRIPTION: This extensive example demonstrates the full implementation of server-side helpers in a Next.js page. It includes prefetching data in getServerSideProps and using the prefetched data in the React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/server-side-helpers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { appRouter } from '~/server/routers/_app';\nimport { trpc } from '~/utils/trpc';\nimport { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';\nimport superjson from 'superjson';\n\nexport async function getServerSideProps(\n  context: GetServerSidePropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson,\n  });\n  const id = context.params?.id as string;\n\n  /*\n   * Prefetching the `post.byId` query.\n   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.\n   */\n  await helpers.post.byId.prefetch({ id });\n\n  // Make sure to return { props: { trpcState: helpers.dehydrate() } }\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n  };\n}\n\nexport default function PostViewPage(\n  props: InferGetServerSidePropsType<typeof getServerSideProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since the query has been prefetched\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString()}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Extracting HTTP Status Code from TRPCError in TypeScript\nDESCRIPTION: This code demonstrates how to use the getHTTPStatusCodeFromError helper function to extract the HTTP status code from a TRPCError object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-handling.md#2025-04-23_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { getHTTPStatusCodeFromError } from '@trpc/server/http';\n\n// Example error you might get if your input validation fails\nconst error: TRPCError = {\n  name: 'TRPCError',\n  code: 'BAD_REQUEST',\n  message: '\"password\" must be at least 4 characters',\n};\n\nif (error instanceof TRPCError) {\n  const httpCode = getHTTPStatusCodeFromError(error);\n  console.log(httpCode); // 400\n}\n```\n\n----------------------------------------\n\nTITLE: Fetching tRPC Data Directly in Next.js Server Component\nDESCRIPTION: This snippet shows how to directly fetch data using tRPC in a Next.js server component. It demonstrates calling the tRPC procedure without using prefetch, which doesn't store the data in the client-side cache.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '~/trpc/server';\n\nexport default async function Home() {\n  // Use the caller directly without using `.prefetch()`\n  const greeting = await trpc.hello();\n  //    ^? { greeting: string }\n\n  return <div>{greeting.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC and Defining Base Server Action Procedure\nDESCRIPTION: This snippet initializes tRPC and defines a base server action procedure using the experimental_caller method and Next.js App Router adapter. It also sets up metadata for span tracking.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';\n\ninterface Meta {\n  span: string;\n}\n\nexport const t = initTRPC.meta<Meta>().create();\n\nconst serverActionProcedure = t.procedure.experimental_caller(\n  experimental_nextAppDirCaller({\n    pathExtractor: ({ meta }) => (meta as Meta).span,\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Backend with Context Creation\nDESCRIPTION: Sets up the core tRPC backend infrastructure by initializing tRPC, creating a context function, and exporting router creation utilities. The context function is wrapped in React's cache for performance optimization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { cache } from 'react';\n\nexport const createTRPCContext = cache(async () => {\n  /**\n   * @see: https://trpc.io/docs/server/context\n   */\n  return { userId: 'user_123' };\n});\n\n// Avoid exporting the entire t-object\n// since it's not very descriptive.\n// For instance, the use of a t variable\n// is common in i18n libraries.\nconst t = initTRPC.create({\n  /**\n   * @see https://trpc.io/docs/server/data-transformers\n   */\n  // transformer: superjson,\n});\n\n// Base router and procedure helpers\nexport const createTRPCRouter = t.router;\nexport const createCallerFactory = t.createCallerFactory;\nexport const baseProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router Configuration\nDESCRIPTION: Sets up a basic tRPC router with a post endpoint that includes a byId query procedure. Uses Zod for input validation and returns a post object with id and title.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/partials/_import-approuter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: server/router.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    byId: t.procedure\n      .input(z.object({ id: z.string() }))\n      .query(async ({input}) => {\n        return { id: input.id, title: 'Hello' };\n      }),\n  })\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperJSON with withTRPC in Next.js App - TypeScript\nDESCRIPTION: Configures SuperJSON in a Next.js application wrapped with withTRPC, ensuring that all tRPC calls use the SuperJSON transformer for data serialization. Requires superjson and withTRPC dependencies. The key parameter is the transformer property inside the config callback, enabling rich type transfer between server and client components.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport superjson from 'superjson';\n\n// [...]\n\nexport default withTRPC<AppRouter>({\n  config({ ctx }) {\n    return {\n      // [...]\n      transformer: superjson,\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC Client for React Client Components\nDESCRIPTION: Creates a tRPC client for Client Components with the TRPCProvider wrapper component, managing query client lifecycle and setting up the HTTP transport link.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\n// ^-- to make sure we can mount the Provider from a server component\nimport type { QueryClient } from '@tanstack/react-query';\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCReact } from '@trpc/react-query';\nimport { useState } from 'react';\nimport { makeQueryClient } from './query-client';\nimport type { AppRouter } from './routers/_app';\n\nexport const trpc = createTRPCReact<AppRouter>();\n\nlet clientQueryClientSingleton: QueryClient;\nfunction getQueryClient() {\n  if (typeof window === 'undefined') {\n    // Server: always make a new query client\n    return makeQueryClient();\n  }\n  // Browser: use singleton pattern to keep the same query client\n  return (clientQueryClientSingleton ??= makeQueryClient());\n}\n\nfunction getUrl() {\n  const base = (() => {\n    if (typeof window !== 'undefined') return '';\n    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;\n    return 'http://localhost:3000';\n  })();\n  return `${base}/api/trpc`;\n}\n\nexport function TRPCProvider(\n  props: Readonly<{\n    children: React.ReactNode;\n  }>,\n) {\n  // NOTE: Avoid useState when initializing the query client if you don't\n  //       have a suspense boundary between this and the code that may\n  //       suspend because React will throw away the client on the initial\n  //       render if it suspends and there is no boundary\n  const queryClient = getQueryClient();\n\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      links: [\n        httpBatchLink({\n          // transformer: superjson, <-- if you use a data transformer\n          url: getUrl(),\n        }),\n      ],\n    }),\n  );\n\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {props.children}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Queries in React Component (TypeScript/React)\nDESCRIPTION: Demonstration of using tRPC queries in a React component. This example shows how to fetch a post by ID and related posts, which will be batched into a single HTTP request.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function MyComponent() {\n  const post1 = trpc.postById.useQuery('1');\n  const relatedPosts = trpc.relatedPosts.useQuery('1');\n\n  return (\n    <pre>\n      {JSON.stringify(\n        {\n          post1: post1.data ?? null,\n          relatedPosts: relatedPosts.data ?? null,\n        },\n        null,\n        4,\n      )}\n    </pre>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC App Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a basic tRPC router with query and mutation procedures. It defines a getUser query and a createUser mutation, using Zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/standalone.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUser: t.procedure.input(z.string()).query((opts) => {\n    return { id: opts.input, name: 'Bilbo' };\n  }),\n  createUser: t.procedure\n    .input(z.object({ name: z.string().min(5) }))\n    .mutation(async (opts) => {\n      // use your ORM of choice\n      return await UserModel.create({\n        data: opts.input,\n      });\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Installing Server Dependencies for tRPC\nDESCRIPTION: Commands for installing required server-side tRPC dependencies including Zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server zod\n```\n\n----------------------------------------\n\nTITLE: DataTransformer and CombinedDataTransformer Type Definitions - TypeScript\nDESCRIPTION: Defines TypeScript types for a DataTransformer interface and a CombinedDataTransformer structure. The DataTransformer contract specifies serialize and deserialize methods for bidirectional data handling, while CombinedDataTransformer splits transformations for input and output, enabling advanced serialization strategies. There are no dependencies or runtime effects, as these are only type/interface definitions for use in tRPC configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\ntype DataTransformer = {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n};\n\ntype CombinedDataTransformer = {\n  input: DataTransformer;\n  output: DataTransformer;\n};\n```\n\n----------------------------------------\n\nTITLE: Encoding Batched Query Inputs (TypeScript)\nDESCRIPTION: Example of encoding inputs for batched queries in tRPC. This code demonstrates how multiple procedure inputs are combined into a single encoded string for the HTTP request.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nencodeURIComponent(\n  JSON.stringify({\n    0: '1', // <-- input for `postById`\n    1: '1', // <-- input for `relatedPosts`\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Configuring httpBatchStreamLink for Streaming Responses\nDESCRIPTION: Example of configuring httpBatchStreamLink in a tRPC client for streaming responses. This allows responses to be sent as soon as they are ready, which is useful for long-running requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchStreamLink.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Consuming Streaming Query in React Component\nDESCRIPTION: React component example showing how to consume a streaming query response and render the chunks as they arrive.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQuery.md#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '~/utils';\n\nexport function MyComponent() {\n  const result = trpc.iterable.useQuery();\n\n  return (\n    <div>\n      {result.data?.map((chunk, index) => (\n        <Fragment key={index}>{chunk}</Fragment>\n      ))}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing HTTP/REST and RPC API Calls in TypeScript\nDESCRIPTION: This snippet demonstrates the difference between making an API call using traditional HTTP/REST approach and using RPC (specifically tRPC). It shows how RPC simplifies the process by allowing direct function calls instead of URL-based requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/concepts.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// HTTP/REST\nconst res = await fetch('/api/users/1');\nconst user = await res.json();\n\n// RPC\nconst user = await api.users.getById({ id: 1 });\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable API Procedure with Context Checks in tRPC\nDESCRIPTION: Shows how to create a reusable API procedure that checks for the presence of req and res in the context. This is useful when working with inner and outer contexts to ensure required context properties are available.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const apiProcedure = publicProcedure.use((opts) => {\n  if (!opts.ctx.req || !opts.ctx.res) {\n    throw new Error('You are missing `req` or `res` in your call.');\n  }\n  return opts.next({\n    ctx: {\n      // We overwrite the context with the truthy `req` & `res`, which will also overwrite the types used in your procedure.\n      req: opts.ctx.req,\n      res: opts.ctx.res,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Prefetching tRPC Query in Next.js Server Component\nDESCRIPTION: This snippet shows how to prefetch a tRPC query in a Next.js server component. It demonstrates the 'render as you fetch' pattern, where the request is initiated early without suspending the component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\n\nexport default async function Home() {\n  void trpc.hello.prefetch();\n\n  return (\n    <HydrateClient>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrateClient>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Adding SuperJSON to tRPC Client Configuration\nDESCRIPTION: TypeScript code to configure SuperJSON transformer in tRPC client creation using createTRPCProxyClient.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\nimport superjson from 'superjson';\n\nexport const client = createTRPCProxyClient<AppRouter>({\n  transformer: superjson, // <--\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC HTTP Handler with Method Override (TypeScript)\nDESCRIPTION: Example of configuring the tRPC HTTP handler on the server to allow HTTP method override. This enables clients to use a different HTTP method than the default for queries and mutations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst handler = createHTTPHandler({\n  router: router,\n  allowMethodOverride: true,\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Context to tRPC Server Action Procedure\nDESCRIPTION: This snippet adds context to the tRPC server action procedure by using a middleware to inject the current user into the context. It demonstrates how to handle authentication in server actions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';\nimport { currentUser } from './auth';\n\ninterface Meta {\n  span: string;\n}\n\nexport const t = initTRPC.meta<Meta>().create();\n\nexport const serverActionProcedure = t.procedure\n  .experimental_caller(\n    experimental_nextAppDirCaller({\n      pathExtractor: ({ meta }) => (meta as Meta).span,\n    }),\n  )\n  .use(async (opts) => {\n    // Inject user into context\n    const user = await currentUser();\n    return opts.next({ ctx: { user } });\n  });\n```\n\n----------------------------------------\n\nTITLE: Updating tRPC React Query Hooks Imports in TypeScript (Diff)\nDESCRIPTION: Demonstrates the required migration of import statements from the deprecated '@trpc/react' package to the new '@trpc/react-query' package. Ensures all usages of createReactQueryHooks reference the correct package name in both code and dependencies. This is critical to align with the package renaming for React Query v4 compatibility. Only the import path changes; underlying hook usage remains unaffected.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_7\n\nLANGUAGE: diff\nCODE:\n```\n- import { createReactQueryHooks } from '@trpc/react';\\n+ import { createReactQueryHooks } from '@trpc/react-query';\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for Cross-Origin Requests with Cookies in TypeScript\nDESCRIPTION: This code snippet shows how to create a tRPC client that includes credentials in its fetch requests, allowing for cross-origin requests with cookies. It modifies the fetch function used by tRPC to add the 'credentials: \"include\"' option.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/cors.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient } from '@trpc/client';\n\nconst client = createTRPCClient<AppRouter>({\n  url: 'YOUR_SERVER_URL',\n  fetch(url, options) {\n    return fetch(url, {\n      ...options,\n      credentials: 'include',\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with WebSocket Authentication\nDESCRIPTION: Sets up a tRPC client to use WebSocket transport with authentication. Provides connection parameters including a token for server-side authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, createWSClient, wsLink } from '@trpc/client';\nimport type { AppRouter } from '~/server/routers/_app';\n\nconst wsClient = createWSClient({\n  url: `ws://localhost:3000`,\n\n  connectionParams: async () => {\n    return {\n      token: 'supersecret',\n    };\n  },\n});\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [wsLink({ client: wsClient, transformer: superjson })],\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Query with Superstruct Input Validation in TypeScript\nDESCRIPTION: This snippet illustrates defining a tRPC query procedure ('hello') using Superstruct for input validation. It defines an input schema for an object with a 'text' string property, which defaults to 'world' if not provided. The `resolve` function uses the validated `input.text` (guaranteed to have a value due to the default) to create the greeting. It also exports the router's type (`AppRouter`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/router.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport * as trpc from '@trpc/server';\nimport * as t from 'superstruct';\n\n// [...] \n\nexport const appRouter = trpc.router<Context>().query('hello', {\n  input: t.object({\n    /**\n     * Also supports inline doc strings when referencing the type.\n     */\n    text: t.defaulted(t.string(), 'world'),\n  }),\n  resolve({ input }) {\n    return {\n      greeting: `hello ${input.text}`,\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring retryLink with a tRPC Client in TypeScript\nDESCRIPTION: Example of how to import and configure the retryLink with custom retry logic and delay settings in a tRPC client. The example shows how to conditionally retry based on error type, operation type, and attempt count, with an exponential backoff strategy.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/retryLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, retryLink } from '@trpc/client';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    retryLink({\n      retry(opts) {\n        if (\n          opts.error.data &&\n          opts.error.data.code !== 'INTERNAL_SERVER_ERROR'\n        ) {\n          // Don't retry on non-500s\n          return false;\n        }\n        if (opts.op.type !== 'query') {\n          // Only retry queries\n          return false;\n        }\n\n        // Retry up to 3 times\n        return opts.attempts <= 3;\n      },\n      // Double every attempt, with max of 30 seconds (starting at 1 second)\n      retryDelayMs: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n    }),\n    httpBatchLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Next.js Prisma Starter with create-next-app\nDESCRIPTION: Command to create a new Next.js project with tRPC and Prisma integration, including E2E testing and ESLint configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/starter-projects.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: ErrorFormatter Function Parameters Interface\nDESCRIPTION: Defines the structure of parameters passed to the errorFormatter function in tRPC, following JSON-RPC 2.0 specification.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-formatting.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: undefined | TContext;\n  shape: DefaultErrorShape; // the default error shape\n}\n```\n\n----------------------------------------\n\nTITLE: tRPC Error Codes Mapping to JSON-RPC 2.0 Error Codes\nDESCRIPTION: This snippet defines the mapping between tRPC error codes and JSON-RPC 2.0 error codes. It ensures compatibility with the JSON-RPC 2.0 specification while providing tRPC-specific error handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/rpc.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const TRPC_ERROR_CODES_BY_KEY = {\n  PARSE_ERROR: -32700,\n  BAD_REQUEST: -32600, // 400\n  INTERNAL_SERVER_ERROR: -32603,\n  // Implementation specific errors\n  UNAUTHORIZED: -32001, // 401\n  FORBIDDEN: -32003, // 403\n  NOT_FOUND: -32004, // 404\n  METHOD_NOT_SUPPORTED: -32005, // 405\n  TIMEOUT: -32008, // 408\n  CONFLICT: -32009, // 409\n  PRECONDITION_FAILED: -32012, // 412\n  PAYLOAD_TOO_LARGE: -32013, // 413\n  CLIENT_CLOSED_REQUEST: -32099, // 499\n} as const;\n```\n\n----------------------------------------\n\nTITLE: Updating tRPC-Specific Options Namespace in React Query Usage (TSX)\nDESCRIPTION: Shows how to migrate tRPC-specific options within React Query's useQuery to the standardized 'trpc' namespace, preventing key collisions and clarifying intent. Illustrates both traditional and proxy-style usages. Input parameters include procedure keys and options objects. Expected output is improved namespacing and safer type inference in TSX applications. No external dependencies beyond tRPC and React Query. Limitations: all custom tRPC options must now be nested under 'trpc'.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_8\n\nLANGUAGE: tsx\nCODE:\n```\n// Before\\nuseQuery(['post.byId', '1'], {\\n  context: {\\n    batching: false,\\n  },\\n});\\n\\n// After:\\nuseQuery(['post.byId', '1'], {\\n  trpc: {\\n    context: {\\n      batching: false,\\n    },\\n  },\\n});\\n// or:\\ntrpc.post.byId.useQuery('1', {\\n  trpc: {\\n    batching: false,\\n  },\\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client with HTTP Batch Stream Link\nDESCRIPTION: Sets up a tRPC client using httpBatchStreamLink for handling batched requests with streaming responses. Requires a URL endpoint for the tRPC server.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchStreamLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchStreamLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Throwing Custom tRPC Errors\nDESCRIPTION: Shows how to throw custom tRPC errors within a procedure including error code, message, and optional cause for stack trace retention.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-handling.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  hello: t.procedure.query(() => {\n    throw new TRPCError({\n      code: 'INTERNAL_SERVER_ERROR',\n      message: 'An unexpected error occurred, please try again later.',\n      // optional: pass the original error to retain stack trace\n      cause: theError,\n    });\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Using useSubscription Hook in a React Component\nDESCRIPTION: This example demonstrates how to use the useSubscription hook in a React component. It subscribes to a 'onNumber' procedure, updates state with received data, and renders the subscription status, data, and previous numbers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useSubscription.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const [numbers, setNumbers] = React.useState<number[]>([]);\n\n  const result = trpc.onNumber.useSubscription(undefined, {\n    onData: (num) => {\n      setNumbers((prev) => [...prev, num]);\n    },\n  });\n\n  return (\n    <div>\n      <h1>Subscription Example</h1>\n      <p>\n        {result.status}: <pre>{JSON.stringify(result.data, null, 2)}</pre>\n      </p>\n      <h2>Previous numbers:</h2>\n      <ul>\n        {numbers.map((num, i) => (\n          <li key={i}>{num}</li>\n        ))}\n      </ul>\n\n      {result.status === 'error' && (\n        <button onClick={() => result.reset()}>\n          Something went wrong - restart the subscription\n        </button>\n      )}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Mutation Key Helper Function Signature in tRPC\nDESCRIPTION: Type definition for the getMutationKey helper function that generates the correct mutation key for tRPC mutation procedures when working with React Query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/getQueryKey.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nfunction getMutationKey(procedure: AnyMutationProcedure): TRPCMutationKey;\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies for Next.js\nDESCRIPTION: This bash command installs the necessary tRPC dependencies for a Next.js project, including client, server, react, next, zod, and react-query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/client @trpc/server @trpc/react @trpc/next zod react-query@3\n```\n\n----------------------------------------\n\nTITLE: HTTPLinkOptions Interface Definition in TypeScript\nDESCRIPTION: Type definition for the httpLink configuration options. This interface specifies all possible parameters that can be passed to the httpLink function, including URL, fetch ponyfill, transformer, headers, and method override settings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/v11/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/v10/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n  /**\n   * Send all requests as POSTS requests regardless of the procedure type\n   * The server must separately allow overriding the method. See:\n   * @see https://trpc.io/docs/rpc\n   */\n  methodOverride?: 'POST';\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with WebSockets using npm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, ESLint, next-auth, WebSockets, and subscriptions using npm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/example-apps.mdx#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS for Standalone tRPC Server in TypeScript\nDESCRIPTION: This snippet shows how to configure CORS for a standalone tRPC server using the cors package. It demonstrates setting up the server with CORS middleware for development purposes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport cors from 'cors';\n\ncreateHTTPServer({\n  middleware: cors(),\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n}).listen(3333);\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Router in TypeScript\nDESCRIPTION: Example of creating a tRPC router with query and mutation procedures. It defines a user type, initializes tRPC, and sets up procedures for getting and creating users.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\ntype User = {\n  id: string;\n  name: string;\n  bio?: string;\n};\n\nconst users: Record<string, User> = {};\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUserById: t.procedure.input(z.string()).query((opts) => {\n    return users[opts.input]; // input type is string\n  }),\n  createUser: t.procedure\n    .input(\n      z.object({\n        name: z.string().min(3),\n        bio: z.string().max(142).optional(),\n      }),\n    )\n    .mutation((opts) => {\n      const id = Date.now().toString();\n      const user: User = { id, ...opts.input };\n      users[user.id] = user;\n      return user;\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Defining a tRPC Mutation Endpoint with Zod Validation - TypeScript\nDESCRIPTION: Defines a tRPC router with a 'login' mutation using Zod for input validation in a backend TypeScript file. The mutation expects an object with a 'name' string and returns a user object with 'name' and a fixed 'role'. This setup requires '@trpc/server' and 'zod' as dependencies. Input is validated, and the response contains the user data; further authentication or error handling can be built atop this structure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useMutation.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\\nimport { z } from 'zod';\\n\\nexport const appRouter = trpc.router()\\n  // Create procedure at path 'login'\\n  // The syntax is identical to creating queries\\n  .mutation('login', {\\n    // using zod schema to validate and infer input values\\n    input: z\\n      .object({\\n        name: z.string(),\\n      })\\n    async resolve({ input }) {\\n      // Here some login stuff would happen\\n\\n      return {\\n        user: {\\n          name: input.name,\\n          role: 'ADMIN'\\n        },\\n      };\\n    },\\n  })\n```\n\n----------------------------------------\n\nTITLE: Configuring Conditional SSR for tRPC in Next.js\nDESCRIPTION: This snippet shows how to set up conditional SSR for tRPC based on the user agent. It demonstrates configuring the tRPC client to only perform SSR for requests coming from bots, which can be useful for optimizing performance and SEO.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    return {\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr(opts) {\n    // only SSR if the request is coming from a bot\n    return opts.ctx?.req?.headers['user-agent']?.includes('bot');\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Handling Error Responses - JSON\nDESCRIPTION: Shows the format of an error response from tRPC when a bad request occurs. Useful for client-side error handling, it includes fields for message, code, HTTP status, stack, and the invocation path. No special dependencies are required, and output is a typical JSON error object as returned from tRPC endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-handling.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\\n  \"id\": null,\\n  \"error\": {\\n    \"message\": \"\\\\\\\"password\\\\\\\" must be at least 4 characters\",\\n    \"code\": -32600,\\n    \"data\": {\\n      \"code\": \"BAD_REQUEST\",\\n      \"httpStatus\": 400,\\n      \"stack\": \"...\",\\n      \"path\": \"user.changepassword\"\\n    }\\n  }\\n}\\n\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router with Query Methods in TypeScript\nDESCRIPTION: This snippet demonstrates how to define a tRPC router with query methods for fetching posts and related posts. It shows the structure of resolver functions and input types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/rpc.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = trpc\n  .router<Context>()\n  .query('postById', {\n    input: String,\n    async resolve({ input, ctx }) {\n      const post = await ctx.post.findUnique({\n        where: { id: input },\n      });\n      return post;\n    },\n  })\n  .query('relatedPosts', {\n    input: String,\n    async resolve({ ctx, input }) {\n      const posts = await ctx.findRelatedPostsById(input);\n      return posts;\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with WebSockets using npm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, WebSockets, and subscriptions using npm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Router with Typed Metadata\nDESCRIPTION: Basic setup for creating a tRPC router with typed metadata interface. Demonstrates how to define a metadata interface and initialize tRPC with context and metadata types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/metadata.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  authRequired: boolean;\n}\n\nexport const t = initTRPC.context<Context>().meta<Meta>().create();\n\nexport const appRouter = t.router({\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Protected Server Action Procedure\nDESCRIPTION: This snippet defines a protected server action procedure that checks for user authentication. It throws an error for unauthenticated users and ensures type safety for the user object in the context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';\nimport { currentUser } from './auth';\n\ninterface Meta {\n  span: string;\n}\n\nexport const t = initTRPC.meta<Meta>().create();\n\nexport const serverActionProcedure = t.procedure\n  .experimental_caller(\n    experimental_nextAppDirCaller({\n      pathExtractor: ({ meta }) => (meta as Meta).span,\n    }),\n  )\n  .use(async (opts) => {\n    // Inject user into context\n    const user = await currentUser();\n    return opts.next({ ctx: { user } });\n  });\n\nexport const protectedAction = serverActionProcedure.use((opts) => {\n  if (!opts.ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n    });\n  }\n\n  return opts.next({\n    ctx: {\n      ...opts.ctx,\n      user: opts.ctx.user, // <-- ensures type is non-nullable\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Authentication with tRPC\nDESCRIPTION: Shows how to handle authentication token updates using tRPC mutation. Demonstrates storing the access token after successful login.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/header.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMut = trpc.useMutation(['auth.login'], {\n  onSuccess({ accessToken }) {\n    token = accessToken;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Protected Procedure with Middleware Example\nDESCRIPTION: Demonstrates using middleware to protect procedures and handling authentication context in server-side calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\ntype Context = {\n  user?: {\n    id: string;\n  };\n};\nconst t = initTRPC.context<Context>().create();\n\nconst protectedProcedure = t.procedure.use((opts) => {\n  const { ctx } = opts;\n  if (!ctx.user) {\n    throw new TRPCError({\n      code: 'UNAUTHORIZED',\n      message: 'You are not authorized',\n    });\n  }\n\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n\nconst router = t.router({\n  secret: protectedProcedure.query((opts) => opts.ctx.user),\n});\n\n{\n  const caller = router.createCaller({});\n\n  const result = await caller.secret();\n}\n\n{\n  const authorizedCaller = router.createCaller({\n    user: {\n      id: 'KATT',\n    },\n  });\n  const result = await authorizedCaller.secret();\n}\n```\n\n----------------------------------------\n\nTITLE: Prefetching tRPC Query in Next.js Server Component\nDESCRIPTION: This snippet demonstrates how to prefetch a tRPC query in a Next.js server component using React Query. It shows the setup for hydration and client-side rendering of the fetched data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_6\n\nLANGUAGE: tsx\nCODE:\n```\nimport { dehydrate, HydrationBoundary } from '@tanstack/react-query';\nimport { getQueryClient, trpc } from '~/trpc/server';\nimport { ClientGreeting } from './client-greeting';\n\nexport default async function Home() {\n  const queryClient = getQueryClient();\n  void queryClient.prefetchQuery(\n    trpc.hello.queryOptions({\n      /** input */\n    }),\n  );\n\n  return (\n    <HydrationBoundary state={dehydrate(queryClient)}>\n      <div>...</div>\n      {/** ... */}\n      <ClientGreeting />\n    </HydrationBoundary>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Conditional SSR with tRPC in Next.js\nDESCRIPTION: This snippet shows how to implement conditional server-side rendering with tRPC in a Next.js application. It demonstrates using a callback function to determine whether to perform SSR based on the user agent of the request.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/ssr.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    const { ctx } = opts;\n    if (typeof window !== 'undefined') {\n      // during client requests\n      return {\n        transformer: superjson, // optional - adds superjson serialization\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    return {\n      transformer: superjson, // optional - adds superjson serialization\n      links: [\n        httpBatchLink({\n          // The server needs to know your app's full url\n          url: `${getBaseUrl()}/api/trpc`,\n          /**\n           * Set custom request headers on every request from tRPC\n           * @see https://trpc.io/docs/v10/header\n           */\n          headers() {\n            if (!ctx?.req?.headers) {\n              return {};\n            }\n            // To use SSR properly, you need to forward client headers to the server\n            // This is so you can pass through things like cookies when we're server-side rendering\n            return {\n              cookie: ctx.req.headers.cookie,\n            };\n          },\n        }),\n      ],\n    };\n  },\n  ssr(opts) {\n    // only SSR if the request is coming from a bot\n    return opts.ctx?.req?.headers['user-agent']?.includes('bot');\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: tRPC Error Codes Mapping to HTTP Status Codes\nDESCRIPTION: This code defines the mapping between tRPC error codes and corresponding HTTP status codes. It's crucial for translating internal errors to appropriate HTTP responses.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/rpc.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nPARSE_ERROR: 400,\nBAD_REQUEST: 400,\nNOT_FOUND: 404,\nINTERNAL_SERVER_ERROR: 500,\nUNAUTHORIZED: 401,\nFORBIDDEN: 403,\nTIMEOUT: 408,\nCONFLICT: 409,\nCLIENT_CLOSED_REQUEST: 499,\nPRECONDITION_FAILED: 412,\nPAYLOAD_TOO_LARGE: 413,\nMETHOD_NOT_SUPPORTED: 405,\n```\n\n----------------------------------------\n\nTITLE: Running tRPC Upgrade CLI\nDESCRIPTION: Command to run the tRPC upgrade CLI for automated migration assistance. This tool helps transform hooks to the new API and migrate context provider setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/migrating.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\nnpx @trpc/upgrade\n```\n\n----------------------------------------\n\nTITLE: Replacing httpBatchLink with httpLink in tRPC Client\nDESCRIPTION: This snippet demonstrates how to replace httpBatchLink with httpLink in the tRPC client configuration when disabling request batching. It shows the setup for a standalone tRPC client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js TodoMVC Example with create-next-app\nDESCRIPTION: Command to create a new Next.js TodoMVC project with tRPC and Prisma integration, featuring SSG capabilities.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/starter-projects.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Advanced tRPC Configuration Example\nDESCRIPTION: Example of customizing tRPC initialization using method chaining for context and metadata configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/routers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst t = initTRPC.context<Context>().meta<Meta>().create({\n  /* [...] */\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating Classic tRPC Mutation to New Client Mutation\nDESCRIPTION: Example of migrating a classic tRPC mutation to the new client using TanStack Query. It demonstrates the changes in import statements and mutation syntax.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/migrating.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from './trpc';\n\nfunction Users() {\n  const createUserMutation = trpc.createUser.useMutation();\n\n  createUserMutation.mutate({ name: 'Jerry' });\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useMutation } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\n\nfunction Users() {\n  const trpc = useTRPC();\n\n  const createUserMutation = useMutation(trpc.createUser.mutationOptions());\n\n  createUserMutation.mutate({ name: 'Jerry' });\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Streaming Query with Async Generator\nDESCRIPTION: Backend implementation showing how to create a streaming query using async generators in tRPC that yields values over time.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQuery.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { publicProcedure, router } from './trpc';\n\nconst appRouter = router({\n  iterable: publicProcedure.query(async function* () {\n    for (let i = 0; i < 3; i++) {\n      await new Promise((resolve) => setTimeout(resolve, 500));\n      yield i;\n    }\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Optimized tRPC Router Type Implementation\nDESCRIPTION: Demonstrates the improved implementation that separates v9 and v10 procedures into distinct fields, with v9 procedures stored in a dedicated 'legacy' field to improve type-checking performance.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-14-typescript-performance-lessons.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport type V10Router<TProcedureRecord> = {\n  record: TProcedureRecord;\n  // by default, no legacy procedures\n  legacy: {};\n};\n\nexport type MigrateV9Router<TV9Router extends V9Router> = {\n  // v9 routers inject their procedures into a `legacy` field\n  legacy: {\n    // v9 clients require that we filter queries, mutations, subscriptions at the top-level\n    queries: MigrateProcedureRecord<TV9Router['queries']>;\n    mutations: MigrateProcedureRecord<TV9Router['mutations']>;\n    subscriptions: MigrateProcedureRecord<TV9Router['subscriptions']>;\n  };\n} & V10Router</* empty object, v9 routers have no v10 procedures to pass */ {}>;\n```\n\n----------------------------------------\n\nTITLE: LoggerLink Options Type Definition\nDESCRIPTION: This snippet shows the TypeScript interface for LoggerLinkOptions, defining the available configuration options for the loggerLink including logger function, enabling conditions, console implementation, and color mode settings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/loggerLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype LoggerLinkOptions<TRouter extends AnyRouter> = {\n  logger?: LogFn<TRouter>;\n  /**\n   * It is a function that returns a condition that determines whether to enable the logger.\n   * It is true by default.\n   */\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode used in the default logger.\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: 'ansi' | 'css';\n};\n```\n\n----------------------------------------\n\nTITLE: Defining Properties Available in tRPC formatError Callback (TypeScript)\nDESCRIPTION: Illustrates the structure of the object passed as an argument to the `formatError` function in tRPC. It includes details like the original error (`error`), procedure type (`type`), path, input, context (`ctx`), and the default error shape (`shape`).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-formatting.md#2025-04-23_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n```ts\n{\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: undefined | TContext;\n  shape: DefaultErrorShape; // the default error shape\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Server Dependencies with Yarn\nDESCRIPTION: Command to install the required tRPC server dependencies using Yarn package manager.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/aws-lambda.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Abort on Unmount for tRPC in Next.js\nDESCRIPTION: This snippet demonstrates how to configure tRPC to abort all procedure calls on component unmount globally. It uses the createTRPCNext function and sets the abortOnUnmount option to true in the configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: utils.ts\n// @noErrors\nimport { createTRPCNext } from '@trpc/next';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      // ...\n      abortOnUnmount: true,\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring HTTP Link in tRPC Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import and configure the httpLink in a tRPC client. It shows the basic setup for creating a tRPC proxy client with an HTTP link pointing to a local server.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating TypeBox with tRPC Router\nDESCRIPTION: Implementation of a tRPC router using TypeBox for schema validation. Shows how to use TypeBox's Type system with typeschema wrapper for input and output validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Type } from '@sinclair/typebox';\nimport { initTRPC } from '@trpc/server';\nimport { wrap } from '@typeschema/typebox';\n\nexport const t = initTRPC.create();\n\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(wrap(Type.Object({ name: Type.String() })))\n    .output(wrap(Type.Object({ greeting: Type.String() })))\n    .query(({ input }) => {\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Demonstrating tRPC Client Usage with Sample Router\nDESCRIPTION: This snippet showcases how to use the created tRPC client with a sample router. It demonstrates the creation of a client instance, autocompletion features, and type-safe procedure calls.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nconst url = 'http://localhost:3000/api/trpc';\nconst client = createTinyRPCClient<AppRouter>(url);\n\n// 🧙‍♀️ magic autocompletion\n// @noErrors\nclient.post.b;\n//           ^|\n//\n\n// 👀 fully typesafe\nconst post = await client.post.byId.query({ id: '123' });\n//    ^?\n```\n\n----------------------------------------\n\nTITLE: Defining HTTP Subscription Link Options for tRPC\nDESCRIPTION: This type definition outlines the options available for configuring the HTTP subscription link in tRPC. It includes options for specifying a custom EventSource implementation and configuring EventSource options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ntype HTTPSubscriptionLinkOptions<\n  TRoot extends AnyClientTypes,\n  TEventSource extends EventSourceLike.AnyConstructor = typeof EventSource,\n> = {\n  /**\n   * EventSource ponyfill\n   */\n  EventSource?: TEventSource;\n  /**\n   * EventSource options or a callback that returns them\n   */\n  eventSourceOptions?:\n    | EventSourceLike.InitDictOf<TEventSource>\n    | ((opts: {\n        op: Operation;\n      }) =>\n        | EventSourceLike.InitDictOf<TEventSource>\n        | Promise<EventSourceLike.InitDictOf<TEventSource>>);\n};\n```\n\n----------------------------------------\n\nTITLE: Cross-domain Authentication Configuration\nDESCRIPTION: Shows how to configure cross-domain authentication using withCredentials option in httpSubscriptionLink.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nhttpSubscriptionLink({\n  url: 'https://example.com/api/trpc',\n  eventSourceOptions() {\n    return {\n      withCredentials: true,\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining WebSocket Link Options Interface in TypeScript\nDESCRIPTION: This code snippet defines the interfaces for WebSocketLinkOptions, WebSocketClientOptions, and the createWSClient function. It specifies the required and optional parameters for configuring the WebSocket link and client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/wsLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface WebSocketLinkOptions {\n  client: TRPCWebSocketClient;\n}\n\nfunction createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient\n\nexport interface WebSocketClientOptions {\n  url: string;\n  WebSocket?: typeof WebSocket;\n  retryDelayMs?: typeof retryDelay;\n  onOpen?: () => void;\n  onClose?: (cause?: { code?: number }) => void;\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning zART Stack Example Repository\nDESCRIPTION: Command to clone the zART-stack (zero-API, React, TypeScript) monorepo example with React Native, Next.js, and Prisma setup\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/starter-projects.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:KATT/zart.git\n```\n\n----------------------------------------\n\nTITLE: Handling Binary Type Inputs\nDESCRIPTION: Server-side implementation for handling binary data types like Blob, Uint8Array, and File using octetInputParser.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/non-json-content-types.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { octetInputParser } from '@trpc/server/http';\n\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  upload: publicProcedure.input(octetInputParser).query((opts) => {\n    const data = opts.input;\n    return {\n      valid: true,\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Next.js Page with tRPC Server-Side Helpers\nDESCRIPTION: This is a complete example of a Next.js page using tRPC server-side helpers. It demonstrates prefetching a post query in getServerSideProps and using the prefetched data in the component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/server-side-helpers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';\nimport { appRouter } from 'server/routers/_app';\nimport superjson from 'superjson';\nimport { trpc } from 'utils/trpc';\n\nexport async function getServerSideProps(\n  context: GetServerSidePropsContext<{ id: string }>,\n) {\n  const helpers = createServerSideHelpers({\n    router: appRouter,\n    ctx: {},\n    transformer: superjson,\n  });\n  const id = context.params?.id as string;\n\n  /*\n   * Prefetching the `post.byId` query.\n   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.\n   */\n  await helpers.post.byId.prefetch({ id });\n\n  // Make sure to return { props: { trpcState: helpers.dehydrate() } }\n  return {\n    props: {\n      trpcState: helpers.dehydrate(),\n      id,\n    },\n  };\n}\n\nexport default function PostViewPage(\n  props: InferGetServerSidePropsType<typeof getServerSideProps>,\n) {\n  const { id } = props;\n  const postQuery = trpc.post.byId.useQuery({ id });\n  if (postQuery.status !== 'success') {\n    // won't happen since the query has been prefetched\n    return <>Loading...</>;\n  }\n  const { data } = postQuery;\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString()}</em>\n      <p>{data.text}</p>\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Metadata and Chaining\nDESCRIPTION: Demonstrates how to set default metadata values and chain metadata configurations. Shows the implementation of role-based access control with metadata inheritance.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/metadata.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin'\n}\n\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    // Set a default value\n    defaultMeta: { authRequired: false }\n  });\n\nconst publicProcedure = t.procedure\n// ^ Default Meta: { authRequired: false }\n\nconst authProcedure = publicProcedure\n  .use(authMiddleware)\n  .meta({\n    authRequired: true;\n    role: 'user'\n  });\n// ^ Meta: { authRequired: true, role: 'user' }\n\nconst adminProcedure = authProcedure\n  .meta({\n    role: 'admin'\n  });\n// ^ Meta: { authRequired: true, role: 'admin' }\n```\n\n----------------------------------------\n\nTITLE: Implementing createTRPCQueryUtils with React Router in TypeScript\nDESCRIPTION: Demonstrates how to use createTRPCQueryUtils with react-router's loader pattern. This example shows setting up the client, fetching data in a loader function, and using that data as initialData in a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/createTRPCQueryUtils.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { QueryClient } from '@tanstack/react-query';\nimport { createTRPCQueryUtils, createTRPCReact } from '@trpc/react-query';\nimport { useLoaderData } from 'react-router-dom';\nimport type { AppRouter } from './server';\n\nconst trpc = createTRPCReact<AppRouter>();\nconst trpcClient = trpc.createClient({ links: [] });\n\nconst queryClient = new QueryClient();\n\nconst clientUtils = createTRPCQueryUtils({ queryClient, client: trpcClient });\n\n// This is a react-router loader\nexport async function loader() {\n  const allPostsData = await clientUtils.post.all.ensureData(); // Fetches data if it doesn't exist in the cache\n\n  return {\n    allPostsData,\n  };\n}\n\n// This is a react component\nexport function Component() {\n  const loaderData = useLoaderData() as Awaited<ReturnType<typeof loader>>;\n\n  const allPostQuery = trpc.post.all.useQuery({\n    initialData: loaderData.allPostsData, // Uses the data from the loader\n  });\n\n  return (\n    <div>\n      {allPostQuery.data.posts.map((post) => (\n        <div key={post.id}>{post.title}</div>\n      ))}\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring SSE Stream Producer Options for tRPC Server\nDESCRIPTION: This interface defines the options for configuring the Server-Sent Events (SSE) stream producer on the server side. It includes settings for ping intervals, maximum duration, immediate ending, and client-specific options like reconnection timing.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface SSEStreamProducerOptions<TValue = unknown> {\n  ping?: {\n    /**\n     * Enable ping comments sent from the server\n     * @default false\n     */\n    enabled: boolean;\n    /**\n     * Interval in milliseconds\n     * @default 1000\n     */\n    intervalMs?: number;\n  };\n  /**\n   * Maximum duration in milliseconds for the request before ending the stream\n   * @default undefined\n   */\n  maxDurationMs?: number;\n  /**\n   * End the request immediately after data is sent\n   * Only useful for serverless runtimes that do not support streaming responses\n   * @default false\n   */\n  emitAndEndImmediately?: boolean;\n  /**\n   * Client-specific options - these will be sent to the client as part of the first message\n   * @default {}\n   */\n  client?: {\n    /**\n     * Timeout and reconnect after inactivity in milliseconds\n     * @default undefined\n     */\n    reconnectAfterInactivityMs?: number;\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Edge Runtime with tRPC Template\nDESCRIPTION: Commands to create a new Next.js project using the tRPC edge runtime template and install dependencies.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-edge-runtime/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-edge-runtime trpc-next-edge-runtime\ncd trpc-next-edge-runtime\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Abort Behavior in tRPC React Client\nDESCRIPTION: This snippet demonstrates how to globally enable request abortion on component unmount in the tRPC React client configuration. It sets the 'abortOnUnmount' option to true when creating the tRPC React client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: utils.ts\n// @noErrors\nimport { createTRPCReact } from '@trpc/react-query';\n\nexport const trpc = createTRPCReact<AppRouter>({\n  abortOnUnmount: true,\n});\n\ntrpc.createClient({\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Using Vanilla tRPC Client with React Query\nDESCRIPTION: Example of manually using tRPC client with React Query hooks, showing how to implement queries without the integration package.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/introduction.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction PostList() {\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: () => trpc.post.list.query(),\n  });\n  data; // Post[]\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing SSG Helpers in Next.js with tRPC\nDESCRIPTION: This example shows how to use SSG Helpers in a Next.js page component. It demonstrates server-side props generation with data prefetching and client-side rendering of the prefetched data using tRPC hooks.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/ssg-helpers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSSGHelpers } from '@trpc/react/ssg';\nimport { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';\nimport { createContext, prisma } from 'server/context';\nimport { appRouter } from 'server/routers/_app';\nimport superjson from 'superjson';\nimport { trpc } from 'utils/trpc';\n\nexport async function getServerSideProps(\n  context: GetServerSidePropsContext<{ id: string }>,\n) {\n  const ssg = createSSGHelpers({\n    router: appRouter,\n    ctx: await createContext(),\n    transformer: superjson,\n  });\n  const id = context.params?.id as string;\n\n  /*\n   * Prefetching the `post.byId` query here.\n   * `prefetchQuery` does not return the result - if you need that, use `fetchQuery` instead.\n   */\n  await ssg.prefetchQuery('post.byId', {\n    id,\n  });\n\n  // Make sure to return { props: { trpcState: ssg.dehydrate() } }\n  return {\n    props: {\n      trpcState: ssg.dehydrate(),\n      id,\n    },\n  };\n}\n\nexport default function PostViewPage(\n  props: InferGetServerSidePropsType<typeof getServerSideProps>,\n) {\n  const { id } = props;\n\n  // This query will be immediately available as it's prefetched.\n  const postQuery = trpc.useQuery(['post.byId', { id }]);\n\n  const { data } = postQuery;\n\n  return (\n    <>\n      <h1>{data.title}</h1>\n      <em>Created {data.createdAt.toLocaleDateString()}</em>\n\n      <p>{data.text}</p>\n\n      <h2>Raw data:</h2>\n      <pre>{JSON.stringify(data, null, 4)}</pre>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating Classic tRPC Query to New Client Query\nDESCRIPTION: Example of migrating a classic tRPC query to the new client using TanStack Query. It demonstrates the changes in import statements and query syntax.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/migrating.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from './trpc';\n\nfunction Users() {\n  const greetingQuery = trpc.greeting.useQuery({ name: 'Jerry' });\n\n  // greetingQuery.data === 'Hello Jerry'\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\n\nfunction Users() {\n  const trpc = useTRPC();\n\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n\n  // greetingQuery.data === 'Hello Jerry'\n}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Query with Custom Context to Skip Batching\nDESCRIPTION: Shows how to use a tRPC query with a custom context to skip batching for specific requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport function MyComponent() {\n  const postsQuery = trpc.useQuery(['posts'], {\n    context: {\n      skipBatch: true,\n    },\n  });\n  return (\n    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Query Refetching Behavior\nDESCRIPTION: This code snippet shows how to configure tRPC query refetching behavior globally in a Next.js application. It sets refetchOnMount and refetchOnWindowFocus to false for all queries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/ssg.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport superjson from 'superjson';\nimport type { AppRouter } from './api/trpc/[trpc]';\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    return {\n      transformer: superjson,\n      links: [\n        httpBatchLink({\n          url: `${getBaseUrl()}/api/trpc`,\n        }),\n      ],\n      // Change options globally\n      queryClientConfig: {\n        defaultOptions: {\n          queries: {\n            refetchOnMount: false,\n            refetchOnWindowFocus: false,\n          },\n        },\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing and Running tRPC Development Environment\nDESCRIPTION: Commands for installing dependencies and starting the development server for a minimal React tRPC example. Requires Node 18 for global fetch support.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/minimal-react/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Practical Example of Using getQueryKey with React Query\nDESCRIPTION: Example showing how to use getQueryKey in a React component with various React Query hooks. Demonstrates checking if a query is fetching and setting query defaults for an entire router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/getQueryKey.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useIsFetching, useQueryClient } from '@tanstack/react-query';\nimport { getQueryKey } from '@trpc/react-query';\nimport { trpc } from '~/utils/trpc';\n\nfunction MyComponent() {\n  const queryClient = useQueryClient();\n\n  const posts = trpc.post.list.useQuery();\n\n  // See if a query is fetching\n  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');\n  const isFetching = useIsFetching(postListKey);\n\n  // Set some query defaults for an entire router\n  const postKey = getQueryKey(trpc.post);\n  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC React Client in TypeScript\nDESCRIPTION: This snippet shows how to create a tRPC React client using createTRPCReact and the AppRouter type. This client is used to make type-safe API calls in React components.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/suspense.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCReact } from '@trpc/react-query';\nimport type { AppRouter } from '../server';\n\nexport const trpc = createTRPCReact<AppRouter>();\n```\n\n----------------------------------------\n\nTITLE: Defining Typed Metadata for tRPC Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to define a TypeScript interface (`Meta`) to structure the route metadata and then use this interface when creating a tRPC router instance (`trpc.router<Context, Meta>`). This enforces type safety for the `meta` property associated with routes within this router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/metadata.md#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport * as trpc from '@trpc/server';\n\n// [...]\n\ninterface Meta {\n  hasAuth: boolean\n}\n\nexport const appRouter = trpc.router<Context, Meta>();\n```\n\n----------------------------------------\n\nTITLE: Using useInfiniteQuery in React Component\nDESCRIPTION: Client-side React component implementation showing how to use the useInfiniteQuery hook with tRPC for infinite scrolling functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useInfiniteQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const myQuery = trpc.infinitePosts.useInfiniteQuery(\n    {\n      limit: 10,\n    },\n    {\n      getNextPageParam: (lastPage) => lastPage.nextCursor,\n      // initialCursor: 1, // <-- optional you can pass an initialCursor\n    },\n  );\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with Prisma using bun\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, and ESLint using bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\nbunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Development Server with tRPC\nDESCRIPTION: Commands to install dependencies and start the development server for a tRPC React project. Requires Node.js version 18 or higher for global fetch support.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/minimal-content-types/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Basic HTTP Subscription Link Setup with Split Link\nDESCRIPTION: Demonstrates the basic setup of httpSubscriptionLink with splitLink to handle subscription operations separately from regular HTTP requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { TRPCLink } from '@trpc/client';\nimport {\n  httpBatchLink,\n  httpSubscriptionLink,\n  loggerLink,\n  splitLink,\n} from '@trpc/client';\n\nconst trpcClient = createTRPCClient<AppRouter>({\n  links: [\n    loggerLink(),\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: `/api/trpc`,\n      }),\n      false: httpBatchLink({\n        url: `/api/trpc`,\n      }),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Using Split Link in React Component\nDESCRIPTION: Shows how to use splitLink configuration within a React component using the useQuery hook with disabled batching.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/splitLink.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nexport function MyComponent() {\n  const postsQuery = proxy.posts.useQuery(undefined, {\n    trpc: {\n      context: {\n        skipBatch: true,\n      },\n    }\n  });\n  return (\n    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Database Type Definitions and Mock Implementation\nDESCRIPTION: Defines User type and implements a mock database with CRUD operations for users including findMany, findById, and create methods.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/quickstart.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype User = { id: string; name: string };\n\n// Imaginary database\nconst users: User[] = [];\nexport const db = {\n  user: {\n    findMany: async () => users,\n    findById: async (id: string) => users.find((user) => user.id === id),\n    create: async (data: { name: string }) => {\n      const user = { id: String(users.length + 1), ...data };\n      users.push(user);\n      return user;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Request Abortion in tRPC Next.js Component\nDESCRIPTION: Shows how to implement request-specific abort-on-unmount behavior in a Next.js component using tRPC. This example demonstrates setting the abortion configuration for a specific query in a post details page.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/aborting-procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\n\nconst PostViewPage: NextPageWithLayout = () => {\n  const id = useRouter().query.id as string;\n  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });\n\n  return (...)\n}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Query in React with useQuery Hook\nDESCRIPTION: Demonstrates how to use tRPC's React integration to fetch data from the server. This example uses the 'useQuery' hook to request data from the 'hello' endpoint in a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2021-05-05-hello-world.mdx#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst { data } = trpc.useQuery(['hello', '@alexdotjs']);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Hook for Fetching Post by ID in TypeScript\nDESCRIPTION: This code shows how to create a custom hook for fetching a post by ID using inferred types. It uses the trpc client and inferred types to provide type-safe query options and input handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { ReactQueryOptions, RouterInputs, trpc } from './trpc';\n\ntype PostByIdOptions = ReactQueryOptions['post']['byId'];\ntype PostByIdInput = RouterInputs['post']['byId'];\n\nfunction usePostById(input: PostByIdInput, options?: PostByIdOptions) {\n  return trpc.post.byId.useQuery(input, options);\n}\n```\n\n----------------------------------------\n\nTITLE: Building and Starting tRPC Production Server\nDESCRIPTION: Commands for building the project and starting the production server for a tRPC example project.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/lazy-load/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Error Formatter Function Parameters Interface\nDESCRIPTION: Defines the structure of parameters passed to the errorFormatter function in tRPC, including error object, procedure type, path, input, and context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-formatting.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n{\n  error: TRPCError;\n  type: ProcedureType | 'unknown';\n  path: string | undefined;\n  input: unknown;\n  ctx: undefined | TContext;\n  shape: DefaultErrorShape; // the default error shape\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Query with TanStack React Query and tRPC\nDESCRIPTION: Demonstrates a simple query implementation using TanStack React Query with tRPC to fetch a greeting message.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery } from '@tanstack/react-query';\nimport { useTRPC } from './trpc';\n\nfunction Users() {\n  const trpc = useTRPC();\n\n  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));\n\n  // greetingQuery.data === 'Hello Jerry'\n}\n```\n\n----------------------------------------\n\nTITLE: Server-side Subscription Termination\nDESCRIPTION: Demonstrates how to implement server-side subscription termination logic using a counter example.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { publicProcedure, router } from '../trpc';\n\nexport const subRouter = router({\n  onPostAdd: publicProcedure\n    .input(\n      z.object({\n        lastEventId: z.string().coerce.number().min(0).optional(),\n      }),\n    )\n    .subscription(async function* (opts) {\n      let index = opts.input.lastEventId ?? 0;\n      while (true) {\n        const idx = index++;\n        if (idx > 100) {\n          return;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Post Router in tRPC\nDESCRIPTION: This snippet shows the definition of a post router in tRPC. It includes procedures for creating and listing posts, demonstrating input validation with Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const postRouter = router({\n  create: publicProcedure\n    .input(\n      z.object({\n        title: z.string(),\n      }),\n    )\n    .mutation((opts) => {\n      const { input } = opts;\n      //        ^?\n      // [...]\n    }),\n  list: publicProcedure.query(() => {\n    // ...\n    return [];\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with WebSockets using bun\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, WebSockets, and subscriptions using bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nbunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Defining getQueryKey Function Signatures in TypeScript\nDESCRIPTION: TypeScript type definitions showing the three overloads of getQueryKey function for queries, routers, and mutations. Includes QueryType definition for specifying the type of query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/getQueryKey.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n// Queries\nfunction getQueryKey(\n  procedure: AnyQueryProcedure,\n  input?: DeepPartial<TInput>,\n  type?: QueryType; /** @default 'any' */\n): TRPCQueryKey;\n\n// Routers\nfunction getQueryKey(\n  router: AnyRouter,\n): TRPCQueryKey;\n\n// Mutations\nfunction getQueryKey(\n  procedure: AnyMutationProcedure,\n): TRPCQueryKey;\n\ntype QueryType = \"query\" | \"infinite\" | \"any\";\n// for useQuery ──┘         │            │\n// for useInfiniteQuery ────┘            │\n// will match all ───────────────────────┘\n```\n\n----------------------------------------\n\nTITLE: Using httpLink to Disable Batching in tRPC Client\nDESCRIPTION: Shows how to use httpLink instead of httpBatchLink to disable request batching on the client side in a Next.js application.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpLink } from '@trpc/client/links/httpLink';\nimport { withTRPC } from '@trpc/next';\nimport { AppType } from 'next/dist/shared/lib/utils';\nimport type { AppRouter } from 'pages/api/trpc/[trpc]';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default withTRPC<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpLink({\n          url: '/api/trpc',\n        }),\n      ],\n    };\n  },\n  // ssr: false,\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Client in TypeScript\nDESCRIPTION: Demonstrates how to create a typesafe tRPC client using createTRPCClient from @trpc/client. The AppRouter type is passed as a type argument to ensure type safety.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/vanilla.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// pages/index.tsx\nimport { createTRPCClient } from '@trpc/client';\nimport type { AppRouter } from '../path/to/server/trpc';\n\nconst client = createTRPCClient<AppRouter>({\n  url: 'http://localhost:5000/trpc',\n});\n```\n\n----------------------------------------\n\nTITLE: Using tRPC useQuery in React Component\nDESCRIPTION: Frontend React component demonstrating how to use the useQuery hook with and without arguments, displaying the query results and status.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/useQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  // input is optional, so we don't have to pass second argument\n  const helloNoArgs = trpc.useQuery(['hello']);\n  const helloWithArgs = trpc.useQuery(['hello', { text: 'client' }]);\n\n  return (\n    <div>\n      <h1>Hello World Example</h1>\n      <ul>\n        <li>\n          helloNoArgs ({helloNoArgs.status}):{' '}\n          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>\n        </li>\n        <li>\n          helloWithArgs ({helloWithArgs.status}):{' '}\n          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>\n        </li>\n      </ul>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: tRPC useQueries with Custom Context\nDESCRIPTION: Example showing how to pass a custom React Query context to the useQueries hook to override default behavior.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQueries.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nconst [post, greeting] = trpc.useQueries(\n  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],\n  myCustomContext,\n);\n```\n\n----------------------------------------\n\nTITLE: Importing AppRouter Type in TypeScript\nDESCRIPTION: Shows how to import the AppRouter type from the server into the client using 'import type'. This allows for type-safe API calls without importing server-side code.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/vanilla.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '../path/to/server/trpc';\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON and devalue via Yarn - Bash\nDESCRIPTION: Installs both SuperJSON and devalue libraries using Yarn. Devalue is used as a fast serializer for downloading data, while SuperJSON is used for uploading in tRPC. Execute this command to ensure both libraries are included as project dependencies.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson devalue\n```\n\n----------------------------------------\n\nTITLE: Migrating HTTP Options from TRPCClient to HTTP Link (TypeScript)\nDESCRIPTION: Provides before-and-after TypeScript code for moving HTTP-specific configuration (headers, fetch, AbortController) from the top-level createTRPCClient call to the httpBatchLink within links. This structural change enforces that HTTP details are explicitly bound to HTTP links, supporting alternate transports. Required: '@trpc/client' and a ponyfilled fetch/AbortController. Key parameters: url, fetch, AbortController, and headers function. Output is a proxy client configured with the provided HTTP settings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\n// Before:\\nimport { createTRPCClient } from '@trpc/client';\\n\\nconst client = createTRPCClient({\\n  url: '...',\\n  fetch: myFetchPonyfill,\\n  AbortController: myAbortControllerPonyfill,\\n  headers() {\\n    return {\\n      'x-foo': 'bar',\\n    };\\n  },\\n});\\n\\n// After:\\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\\n\\nconst client = createTRPCProxyClient({\\n  links: [\\n    httpBatchLink({\\n      url: '...',\\n      fetch: myFetchPonyfill,\\n      AbortController: myAbortControllerPonyfill,\\n      headers() {\\n        return {\\n          'x-foo': 'bar',\\n        };\\n      },\\n    })\\n  ]\\n});\n```\n\n----------------------------------------\n\nTITLE: Starting Local Development Server for tRPC Website (Console)\nDESCRIPTION: This command starts a local development server for the tRPC website. It disables TypeDoc generation and opens a browser window. Changes are reflected live without restarting the server. It also initiates open graph image generation on port 3001.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/README.md#2025-04-23_snippet_1\n\nLANGUAGE: console\nCODE:\n```\nTYPEDOC=0 pnpm dev\n```\n\n----------------------------------------\n\nTITLE: Context Integration with HTTP Handler\nDESCRIPTION: Demonstrates how to integrate context with an HTTP handler in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext,\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Per-Request Abort Behavior in tRPC React Query\nDESCRIPTION: This snippet shows how to override the global abort behavior for individual queries. It sets the 'abortOnUnmount' option to true in the 'trpc' configuration object of a specific query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/aborting-procedures.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nfunction PostViewPage() {\n  const { query } = useRouter();\n  const postQuery = trpc.post.byId.useQuery(\n    { id: query.id },\n    { trpc: { abortOnUnmount: true } }\n  );\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing a Recursive Proxy for tRPC Client\nDESCRIPTION: Creates a recursive JavaScript Proxy that builds paths for procedure calls and allows for arbitrary nesting of properties, enabling the structure mimicking of the server router on the client side.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ProxyCallbackOptions {\n  path: readonly string[];\n  args: readonly unknown[];\n}\n\ntype ProxyCallback = (opts: ProxyCallbackOptions) => unknown;\n\nfunction createRecursiveProxy(callback: ProxyCallback, path: readonly string[]) {\n  const proxy: unknown = new Proxy(\n    () => {\n      // dummy no-op function since we don't have any\n      // client-side target we want to remap to\n    },\n    {\n      get(_obj, key) {\n        if (typeof key !== 'string') return undefined;\n\n        // Recursively compose the full path until a function is invoked\n        return createRecursiveProxy(callback, [...path, key]);\n      },\n      apply(_1, _2, args) {\n        // Call the callback function with the entire path we\n        // recursively created and forward the arguments\n        return callback({\n          path,\n          args,\n        });\n      },\n    },\n  );\n\n  return proxy;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getQueryKey with React Query Hooks\nDESCRIPTION: Example demonstrating practical usage of getQueryKey with React Query hooks including useIsFetching and queryClient methods. Shows how to generate keys for specific queries and entire routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/getQueryKey.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useIsFetching, useQueryClient } from '@tanstack/react-query';\nimport { getQueryKey } from '@trpc/react-query';\nimport { trpc } from '~/utils/trpc';\n\nfunction MyComponent() {\n  const queryClient = useQueryClient();\n\n  const posts = trpc.post.list.useQuery();\n\n  // See if a query is fetching\n  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');\n  const isFetching = useIsFetching(postListKey);\n\n  // Set some query defaults for an entire router\n  const postKey = getQueryKey(trpc.post);\n  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Setting up Next.js tRPC FormData Example Project\nDESCRIPTION: Commands to create a new Next.js project with tRPC FormData integration, install dependencies, and start the development server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-formdata/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-formdata trpc-formdata\ncd trpc-formdata\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Disabling Request Batching in tRPC Server (Next.js)\nDESCRIPTION: This example shows how to disable request batching on the server side when using tRPC with Next.js. It sets the batching.enabled option to false in the Next.js API handler configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\n  // [...]\n  // 👇 disable batching\n  batching: {\n    enabled: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Request Batching on tRPC Server\nDESCRIPTION: Demonstrates how to disable request batching on the tRPC server side in a Next.js API route.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\n  // [...]\n  // 👇 disable batching\n  batching: {\n    enabled: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Making Strongly Typed API Calls with tRPC Client in TypeScript\nDESCRIPTION: Shows examples of making strongly typed API calls using the initialized tRPC client. Demonstrates both query and mutation operations with type inference.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/vanilla.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst bilbo = await client.query('getUser', 'id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\n\nconst frodo = await client.mutation('createUser', { name: 'Frodo' });\n// => { id: 'id_frodo', name: 'Frodo' };\n```\n\n----------------------------------------\n\nTITLE: Using setInfiniteData Helper\nDESCRIPTION: Example of using the setInfiniteData helper to update cached infinite query data during mutations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useInfiniteQuery.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n\n  const myMutation = trpc.infinitePosts.delete.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n\n      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {\n        if (!data) {\n          return {\n            pages: [],\n            pageParams: [],\n          };\n        }\n\n        return {\n          ...data,\n          pages: data.pages.map((page) => ({\n            ...page,\n            items: page.items.filter((item) => item.status === 'published'),\n          })),\n        };\n      });\n    },\n  });\n\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Todo MVC example using npm\nDESCRIPTION: Command to create a new Next.js Todo MVC application with tRPC, SSG, and Prisma using npm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/example-apps.mdx#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic tRPC Router in TypeScript\nDESCRIPTION: Defines a basic tRPC router instance in TypeScript. This snippet demonstrates how to create and export a router type for client-side use.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/quickstart.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\n\nconst appRouter = trpc.router();\n\n// only export *type signature* of router!\n// to avoid accidentally importing your API\n// into client-side code\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in TypeScript Configuration\nDESCRIPTION: This JSON snippet shows how to enable strict mode in the tsconfig.json file, which is recommended for using Zod with tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Aborting tRPC Procedures Using AbortController (TSX)\nDESCRIPTION: Demonstrates how to abort asynchronous tRPC client queries by passing an AbortSignal from AbortController and triggering abortion via abort(). This modernizes cancellation following Web API conventions, replacing deprecated .cancel() usage. Prerequisites: tRPC client and browser-like AbortController support. Inputs: procedure name, parameters, and abort signal. Output: aborted query if abort() is called. Suitable for scenarios where long-running queries may need user-driven interruption.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_10\n\nLANGUAGE: tsx\nCODE:\n```\nconst ac = new AbortController();\\nconst helloQuery = client.greeting.query('KATT', { signal: ac.signal });\\n\\n// Aborting\\nac.abort();\n```\n\n----------------------------------------\n\nTITLE: Running tRPC Linting with Auto-fix\nDESCRIPTION: Command to run the linter with automatic fixes for code style issues.\nSOURCE: https://github.com/trpc/trpc/blob/main/CONTRIBUTING.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\npnpm lint-fix\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum Batch Size in tRPC with Next.js\nDESCRIPTION: Shows how to set a maximum batch size for tRPC requests in a Next.js application to prevent HTTP 413 errors.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client/links/httpBatchLink';\nimport { withTRPC } from '@trpc/next';\nimport { AppType } from 'next/dist/shared/lib/utils';\nimport type { AppRouter } from 'pages/api/trpc/[trpc]';\n\nconst MyApp: AppType = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default withTRPC<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpBatchLink({\n          url: '/api/trpc',\n          maxBatchSize: 10, // a reasonable size\n        }),\n      ],\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Configuring WebSocket Server for tRPC\nDESCRIPTION: Sets up a WebSocket server using the 'ws' package and applies tRPC handlers. Includes connection logging and graceful shutdown handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\n\nconst wss = new ws.Server({\n  port: 3001,\n});\nconst handler = applyWSSHandler({\n  wss,\n  router: appRouter,\n  createContext,\n  // Enable heartbeat messages to keep connection open (disabled by default)\n  keepAlive: {\n    enabled: true,\n    // server ping message interval in milliseconds\n    pingMs: 30000,\n    // connection is terminated if pong message is not received in this many milliseconds\n    pongWaitMs: 5000,\n  },\n});\n\nwss.on('connection', (ws) => {\n  console.log(`➕➕ Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`➖➖ Connection (${wss.clients.size})`);\n  });\n});\nconsole.log('✅ WebSocket Server listening on ws://localhost:3001');\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating @robolex/sure with tRPC Router\nDESCRIPTION: Example of using @robolex/sure for schema validation in a tRPC router. Demonstrates input and output validation with custom error handling for a 'hello' procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { err, object, string } from '@robolex/sure';\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.create();\n\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      err(\n        object({\n          name: string,\n        }),\n      ),\n    )\n    .output(\n      err(\n        object({\n          greeting: string,\n        }),\n      ),\n    )\n    .query(({ input }) => {\n      return {\n        greeting: `hello ${input.name}`,\n      };\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Configuring Default Metadata and Chaining in tRPC with TypeScript\nDESCRIPTION: This snippet illustrates how to set default values for metadata, chain metadata on procedures, and perform shallow merging. It defines a Meta interface with 'authRequired' and optional 'role' properties, and demonstrates how to create procedures with different metadata configurations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/metadata.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\ninterface Meta {\n  authRequired: boolean;\n  role?: 'user' | 'admin'\n}\n\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    // Set a default value\n    defaultMeta: { authRequired: false }\n  });\n\nconst publicProcedure = t.procedure\n// ^ Default Meta: { authRequired: false }\n\nconst authProcedure = publicProcedure\n  .use(authMiddleware)\n  .meta({\n    authRequired: true;\n    role: 'user'\n  });\n// ^ Meta: { authRequired: true, role: 'user' }\n\nconst adminProcedure = authProcedure\n  .meta({\n    role: 'admin'\n  });\n// ^ Meta: { authRequired: true, role: 'admin' }\n```\n\n----------------------------------------\n\nTITLE: tRPC Middleware Implementation\nDESCRIPTION: Comparison of middleware implementation between v9 and v10, showing reusable and chainable middleware patterns.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// v9\nconst appRouter = trpc\n  .router()\n  .middleware((opts) => {\n    const { ctx } = opts;\n    if (!ctx.user) {\n      throw new TRPCError({ code: 'UNAUTHORIZED' });\n    }\n\n    return opts.next({\n      ctx: {\n        ...ctx,\n        user: ctx.user,\n      },\n    });\n  })\n  .query('greeting', {\n    resolve(opts) {\n      return `hello ${opts.ctx.user.name}!`;\n    },\n  });\n\n// v10\nconst protectedProcedure = t.procedure.use((opts) => {\n  const { ctx } = opts;\n  if (!ctx.user) {\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return opts.next({\n    ctx: {\n      user: ctx.user,\n    },\n  });\n});\n\nconst appRouter = t.router({\n  greeting: protectedProcedure.query((opts) => {\n    return `Hello ${opts.ctx.user.name}!`\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Disabling Request Batching in tRPC Server (Standalone)\nDESCRIPTION: This code snippet demonstrates how to disable request batching on the server side when using a standalone tRPC HTTP server. It sets the batching.enabled option to false in the server configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\n\ncreateHTTPServer({\n  // [...]\n  // 👇 disable batching\n  batching: {\n    enabled: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Custom onError Hook for tRPC API Handler - TypeScript\nDESCRIPTION: Outlines how to implement the onError hook in a Next.js API route using trpcNext.createNextApiHandler. This allows server-side logging or further handling for all errors, with access to error details and context. Requires trpcNext from tRPC and is typically used inside pages/api/trpc/[trpc].ts for advanced error monitoring or reporting.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-handling.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\\n  // ...\\n  onError({ error, type, path, input, ctx, req }) {\\n    console.error('Error:', error);\\n    if (error.code === 'INTERNAL_SERVER_ERROR') {\\n      // send to bug reporting\\n    }\\n  },\\n});\\n\n```\n\n----------------------------------------\n\nTITLE: Using invalidateQueries after tRPC Mutation in TypeScript\nDESCRIPTION: This example demonstrates obtaining tRPC utility functions using `trpc.useUtils()` within a React component. It shows how to call `utils.invalidateQueries` inside the `onSuccess` callback of a `trpc.useMutation` hook to invalidate specific query keys (`['post.all']` and `['post.byId', input.id]`) after a successful 'post.edit' mutation. This ensures related data is refetched. Dependencies include `trpc` client setup and React Query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/invalidateQueries.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx\nimport { trpc } from '../utils/trpc';\n\n// In component:\nconst utils = trpc.useUtils();\n\nconst mutation = trpc.useMutation('post.edit', {\n  onSuccess(input) {\n    utils.invalidateQueries(['post.all']);\n    utils.invalidateQueries(['post.byId', input.id]);\n  },\n});\n```\n```\n\n----------------------------------------\n\nTITLE: LoggerLink Options Type Definition\nDESCRIPTION: TypeScript interface definition for LoggerLinkOptions, showing available configuration options including logger function, enable conditions, console implementation, and color mode settings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/loggerLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype LoggerLinkOptions<TRouter extends AnyRouter> = {\n  logger?: LogFn<TRouter>;\n  /**\n   * It is a function that returns a condition that determines whether to enable the logger.\n   * It is true by default.\n   */\n  enabled?: EnabledFn<TRouter>;\n  /**\n   * Used in the built-in defaultLogger\n   */\n  console?: ConsoleEsque;\n  /**\n   * Color mode used in the default logger.\n   * @default typeof window === 'undefined' ? 'ansi' : 'css'\n   */\n  colorMode?: 'ansi' | 'css';\n};\n```\n\n----------------------------------------\n\nTITLE: Cloning zART Stack Repository\nDESCRIPTION: Command to clone the zART stack example repository, which demonstrates a monorepo setup with React Native, Next.js, and Prisma integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/starter-projects.md#2025-04-23_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\ngit clone git@github.com:KATT/zart.git\n```\n\n----------------------------------------\n\nTITLE: Implementing Full Cache Invalidation on Mutation Success in tRPC React\nDESCRIPTION: This snippet demonstrates how to configure tRPC React to invalidate the full cache after every successful mutation. It overrides the useMutation hook to call the original onSuccess function and then invalidate all queries in the react-query cache.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const trpc = createTRPCReact<AppRouter, SSRContext>({\n  overrides: {\n    useMutation: {\n      /**\n       * This function is called whenever a `.useMutation` succeeds\n       **/\n      async onSuccess(opts) {\n        /**\n         * @note that order here matters:\n         * The order here allows route changes in `onSuccess` without\n         * having a flash of content change whilst redirecting.\n         **/\n\n        // Calls the `onSuccess` defined in the `useQuery()`-options:\n        await opts.originalFn();\n\n        // Invalidate all queries in the react-query cache:\n        await opts.queryClient.invalidateQueries();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuration Update Handler with Retry Link\nDESCRIPTION: Shows implementation of retryLink with httpSubscriptionLink to handle configuration updates and connection retries.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  retryLink,\n  splitLink,\n} from '@trpc/client';\nimport {\n  EventSourcePolyfill,\n  EventSourcePolyfillInit,\n} from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n      true: [\n        retryLink({\n          retry: (opts) => {\n            const code = opts.error.data?.code;\n            if (!code) {\n              console.error('No error code found, retrying', opts);\n              return true;\n            }\n            if (code === 'UNAUTHORIZED' || code === 'FORBIDDEN') {\n              console.log('Retrying due to 401/403 error');\n              return true;\n            }\n            return false;\n          },\n        }),\n        httpSubscriptionLink({\n          url: async () => {\n            return getAuthenticatedUri();\n          },\n          EventSource: EventSourcePolyfill,\n          eventSourceOptions: async () => {\n            const token = await auth.getOrRenewToken();\n            return {\n              headers: {\n                authorization: `Bearer ${token}`,\n              },\n            };\n          },\n        }),\n      ],\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Server-Side Helpers with Internal Router in TypeScript\nDESCRIPTION: This snippet demonstrates how to create server-side helpers when you have direct access to your tRPC router, such as in a monolithic Next.js application. It uses createServerSideHelpers from @trpc/react-query/server and includes superjson for serialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/server-side-helpers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServerSideHelpers } from '@trpc/react-query/server';\nimport { createContext } from '~/server/context';\nimport superjson from 'superjson';\n\nconst helpers = createServerSideHelpers({\n  router: appRouter,\n  ctx: await createContext(),\n  transformer: superjson, // optional - adds superjson serialization\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Type-Safe Resolver for tRPC Procedures\nDESCRIPTION: Defines a generic Resolver type that represents the function signature for calling procedures. It uses tRPC's built-in inference helpers to extract the input and output types of procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-17-tinyrpc-client.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport type {\n  AnyTRPCProcedure,\n  inferProcedureInput,\n  inferProcedureOutput,\n  AnyTRPCQueryProcedure,\n  AnyTRPCMutationProcedure\n} from '@trpc/server';\n\n\n\ntype Resolver<TProcedure extends AnyTRPCProcedure> = (\n  input: inferProcedureInput<TProcedure>,\n) => Promise<inferProcedureOutput<TProcedure>>;\n```\n\n----------------------------------------\n\nTITLE: Importing tRPC Router Types\nDESCRIPTION: Demonstrates the type-only import of AppRouter type from the server router file into a client utility file. Uses TypeScript's type-only import to prevent including server code in the client bundle.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/partials/_import-approuter.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '../server/router';\n```\n\n----------------------------------------\n\nTITLE: Building and Starting tRPC Production Server\nDESCRIPTION: Commands to build the tRPC React project for production and start the production server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/minimal-content-types/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Context for Fastify\nDESCRIPTION: Example of creating a context for tRPC with Fastify. It defines a function that creates a context object for each request, including user information from headers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';\n\nexport function createContext({ req, res }: CreateFastifyContextOptions) {\n  const user = { name: req.headers.username ?? 'anonymous' };\n\n  return { req, res, user };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Configuring a Fastify Server with tRPC Plugin in TypeScript\nDESCRIPTION: This server configuration in TypeScript creates a Fastify instance with an extended maxParamLength, and applies the fastifyTRPCPlugin to expose tRPC endpoints using a router and context defined earlier. The server listens on port 3000, providing error logging and proper shutdown on failure. Place in 'server.ts' and ensure imports for all routing and context dependencies. The '/trpc' prefix is used for generated endpoints per convention.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fastifyTRPCPlugin } from '@trpc/server/adapters/fastify';\nimport fastify from 'fastify';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nconst server = fastify({\n  maxParamLength: 5000,\n});\n\nserver.register(fastifyTRPCPlugin, {\n  prefix: '/trpc',\n  trpcOptions: { router: appRouter, createContext },\n});\n\n(async () => {\n  try {\n    await server.listen({ port: 3000 });\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Inferring Procedure Builder Resolver Options in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the 'inferProcedureBuilderResolverOptions' type helper to infer the options type of a specific procedure builder. It shows how to create a helper function that works with multiple procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/procedures.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nasync function getMembersOfOrganization(\n  opts: inferProcedureBuilderResolverOptions<typeof organizationProcedure>,\n) {\n  // input and ctx are now correctly typed!\n  const { ctx, input } = opts;\n\n  return await prisma.user.findMany({\n    where: {\n      membership: {\n        organizationId: ctx.Organization.id,\n      },\n    },\n  });\n}\nexport const appRouter = t.router({\n  listMembers: organizationProcedure.query(async (opts) => {\n    // use helper function!\n    const members = await getMembersOfOrganization(opts);\n\n    return members;\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Prisma Starter with Next.js\nDESCRIPTION: Command to create a new Next.js application using the tRPC Prisma starter template, navigate to the project directory, and install dependencies.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-starter/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\ncd trpc-prisma-starter\npnpm\npnpm dx\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON via Yarn - Bash\nDESCRIPTION: Installs the SuperJSON library using the yarn package manager. SuperJSON is a serialization library that extends JSON stringify/parse to support richer JavaScript data types like Date, Map, and Set. Run this command in your terminal before using SuperJSON in your project.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson\n```\n\n----------------------------------------\n\nTITLE: Defining Advanced tRPC Router for Invalidation Examples\nDESCRIPTION: Backend code that defines a more complex tRPC router with post and user routers, each containing multiple procedures for demonstrating query invalidation across routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // sub Post router\n  post: t.router({\n    all: t.procedure.query(() => {\n      return {\n        posts: [\n          { id: 1, title: 'everlong' },\n          { id: 2, title: 'After Dark' },\n        ],\n      };\n    }),\n    byId: t.procedure\n      .input(\n        z.object({\n          id: z.string(),\n        }),\n      )\n      .query(({ input }) => {\n        return {\n          post: { id: input?.id, title: 'Look me up!' },\n        };\n      }),\n    edit: t.procedure\n      .input(z.object({ id: z.number(), title: z.string() }))\n      .mutation(({ input }) => {\n        return { post: { id: input.id, title: input.title } };\n      }),\n  }),\n  // separate user router\n  user: t.router({\n    all: t.procedure.query(() => {\n      return { users: [{ name: 'Dave Grohl' }, { name: 'Haruki Murakami' }] };\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Combined Transformer with SuperJSON and devalue - TypeScript\nDESCRIPTION: Shows how to create a custom transformer object that uses SuperJSON for input (upload) serialization and devalue/uneval for output (download) serialization. This object is suitable for tRPC transformer usage and assumes both superjson and devalue are installed. It exposes serialize and deserialize methods for both directions. The output deserialization uses eval for reconstructing objects from string, which may have security implications.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { uneval } from 'devalue';\nimport superjson from 'superjson';\n\n// [...]\n\nexport const transformer = {\n  input: superjson,\n  output: {\n    serialize: (object) => uneval(object),\n    deserialize: (object) => eval(`(${object})`),\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Creating WebSocket Server for tRPC (TypeScript)\nDESCRIPTION: This snippet shows how to set up a WebSocket server for tRPC using the 'ws' package. It applies the tRPC WebSocket handler and sets up event listeners for connections and server shutdown.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/subscriptions.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyWSSHandler } from '@trpc/server/adapters/ws';\nimport ws from 'ws';\nimport { appRouter } from './routers/app';\nimport { createContext } from './trpc';\n\nconst wss = new ws.Server({\n  port: 3001,\n});\nconst handler = applyWSSHandler({ wss, router: appRouter, createContext });\n\nwss.on('connection', (ws) => {\n  console.log(`➕➕ Connection (${wss.clients.size})`);\n  ws.once('close', () => {\n    console.log(`➖➖ Connection (${wss.clients.size})`);\n  });\n});\nconsole.log('✅ WebSocket Server listening on ws://localhost:3001');\n\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM');\n  handler.broadcastReconnectNotification();\n  wss.close();\n});\n```\n\n----------------------------------------\n\nTITLE: Adding a Subscription Procedure to tRPC Router for Real-Time Data (TypeScript)\nDESCRIPTION: This TypeScript snippet adds a subscription called 'randomNumber' to the tRPC router, emitting a new random number every second using setInterval. It demonstrates how to define a subscription resolver and use a custom Subscription helper to stream values to clients connected via WebSocket. Insert this into 'router.ts' after defining other queries and mutations. Ensure all imported dependencies are available and the server is configured to support WebSockets.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = trpc\n  .router()\n  // .query(...)\n  // .mutation(...)\n  .subscription('randomNumber', {\n    resolve() {\n      return new Subscription<{ randomNumber: number }>((emit) => {\n        const timer = setInterval(() => {\n          emit.data({ randomNumber: Math.random() });\n        }, 1000);\n        return () => {\n          clearInterval(timer);\n        };\n      });\n    },\n  });\n```\n\n----------------------------------------\n\nTITLE: Configuring Maximum URL Length in HTTP Batch Link\nDESCRIPTION: Implementation example showing how to set maximum URL length to prevent HTTP errors like 413, 414, and 404.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCClient, httpBatchLink } from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'http://localhost:3000',\n      maxURLLength: 2083, // a suitable size\n      // alternatively, you can make all RPC-calls to be called with POST\n      // methodOverride: 'POST',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Basic Function Validator Implementation in tRPC\nDESCRIPTION: Demonstrates how to create a basic validator using pure functions without external libraries. The example includes both input and output validation for string types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Input is not a string');\n    })\n    .output((value): string => {\n      if (typeof value === 'string') {\n        return value;\n      }\n      throw new Error('Output is not a string');\n    })\n    .query((opts) => {\n      const { input } = opts;\n      return `hello ${input}`;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: React Component with tRPC Query Hooks\nDESCRIPTION: React component implementation showing how to use tRPC query hooks to fetch data from multiple procedures simultaneously.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/rpc.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nexport function MyComponent() {\n  const post1 = trpc.postById.useQuery('1');\n  const relatedPosts = trpc.relatedPosts.useQuery('1');\n\n  return (\n    <pre>\n      {JSON.stringify(\n        {\n          post1: post1.data ?? null,\n          relatedPosts: relatedPosts.data ?? null,\n        },\n        null,\n        4,\n      )}\n    </pre>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Handler in Cloudflare Worker\nDESCRIPTION: Example of implementing a tRPC server in a Cloudflare Worker environment using the fetch adapter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport { createContext } from './context';\nimport { appRouter } from './router';\n\nexport default {\n  async fetch(request: Request): Promise<Response> {\n    return fetchRequestHandler({\n      endpoint: '/trpc',\n      req: request,\n      router: appRouter,\n      createContext,\n    });\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Subscriptions in tRPC\nDESCRIPTION: Adding WebSocket subscription support to tRPC router for real-time updates with random number generation example.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fastify.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  randomNumber: t.procedure.subscription(async function* () {\n    while (true) {\n      yield { randomNumber: Math.random() };\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Next.js dependencies\nDESCRIPTION: Command line instructions for installing tRPC dependencies using different package managers. This includes the core packages needed for Next.js integration with tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/next/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @trpc/next @trpc/react-query @tanstack/react-query\n\n# Yarn\nyarn add @trpc/next @trpc/react-query @tanstack/react-query\n\n# pnpm\npnpm add @trpc/next @trpc/react-query @tanstack/react-query\n\n# Bun\nbun add @trpc/next @trpc/react-query @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Setting up tRPC SSE Chat Example Project\nDESCRIPTION: Commands to clone the repository, install dependencies, set up environment variables, and start the development server for the tRPC SSE chat example project.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-sse-chat/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ngit clone git@github.com:trpc/examples-next-sse-chat.git\npnpm i\ncp .env.example .env\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Error Code Mappings in tRPC\nDESCRIPTION: Definition of error code mappings between HTTP status codes and JSON-RPC 2.0 error codes used in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/rpc.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nPARSE_ERROR: 400,\nBAD_REQUEST: 400,\nUNAUTHORIZED: 401,\nNOT_FOUND: 404,\nFORBIDDEN: 403,\nMETHOD_NOT_SUPPORTED: 405,\nTIMEOUT: 408,\nCONFLICT: 409,\nPRECONDITION_FAILED: 412,\nPAYLOAD_TOO_LARGE: 413,\nUNPROCESSABLE_CONTENT: 422,\nTOO_MANY_REQUESTS: 429,\nCLIENT_CLOSED_REQUEST: 499,\nINTERNAL_SERVER_ERROR: 500,\nNOT_IMPLEMENTED: 501,\n```\n\n----------------------------------------\n\nTITLE: Implementing WebSocket Authentication in tRPC Server\nDESCRIPTION: Demonstrates how to set up authentication for WebSocket connections in a tRPC server context. Extracts a token from connection parameters for authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CreateWSSContextFnOptions } from '@trpc/server/adapters/ws';\n\nexport const createContext = async (opts: CreateWSSContextFnOptions) => {\n  const token = opts.info.connectionParams?.token;\n  //    ^?\n\n  // [... authenticate]\n\n  return {};\n};\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: HTTPLinkOptions Interface Definition (TypeScript)\nDESCRIPTION: This code snippet defines the HTTPLinkOptions interface used for configuring the httpLink. It includes options for specifying the URL, custom fetch and AbortController implementations, and headers for outgoing requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/v10/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Subscription to tRPC Router\nDESCRIPTION: Example of adding a subscription procedure to the tRPC router. This subscription emits a random number every second, demonstrating real-time capabilities.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { observable } from '@trpc/server/observable';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  randomNumber: t.procedure.subscription(() => {\n    return observable<{ randomNumber: number }>((emit) => {\n      const timer = setInterval(() => {\n        emit.next({ randomNumber: Math.random() });\n      }, 1000);\n      return () => {\n        clearInterval(timer);\n      };\n    });\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing edge-runtime Globally using bun\nDESCRIPTION: This command installs the `edge-runtime` package globally using the Bun package manager. The `add -g` command installs the package system-wide, enabling the use of the `edge-runtime` CLI for local simulation and testing of Vercel Edge Functions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\n```sh\nbun add -g edge-runtime\n```\n```\n\n----------------------------------------\n\nTITLE: Initializing Vanilla tRPC Client in TypeScript\nDESCRIPTION: Example of creating a vanilla tRPC client without using the React Query integration. This demonstrates how to manually manage query keys and use the client directly with React Query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [httpBatchLink({ url: 'YOUR_API_URL' })],\n});\n```\n\nLANGUAGE: tsx\nCODE:\n```\nfunction PostList() {\n  const { data } = useQuery({\n    queryKey: ['posts'],\n    queryFn: () => trpc.post.list.query(),\n  });\n  data; // Post[]\n\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Comparing HTTP/REST and RPC API Calls in TypeScript\nDESCRIPTION: This snippet demonstrates the difference between making an API call using traditional HTTP/REST approach versus using RPC (specifically tRPC). It shows how RPC simplifies the API call to a direct function invocation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/concepts.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// HTTP/REST\nconst res = await fetch('/api/users/1');\nconst user = await res.json();\n\n// RPC\nconst user = await api.users.getById({ id: 1 });\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC with Oak Framework in Deno\nDESCRIPTION: Integration of tRPC with the Oak framework in Deno environment, showing request handling and response management.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Application, Router } from 'https://deno.land/x/oak/mod.ts';\nimport { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';\nimport { createContext } from './context.ts';\nimport { appRouter } from './router.ts';\n\nconst app = new Application();\nconst router = new Router();\n\nrouter.all('/trpc/(.*)', async (ctx) => {\n  const res = await fetchRequestHandler({\n    endpoint: '/trpc',\n    req: new Request(ctx.request.url, {\n      headers: ctx.request.headers,\n      body:\n        ctx.request.method !== 'GET' && ctx.request.method !== 'HEAD'\n          ? ctx.request.body({ type: 'stream' }).value\n          : void 0,\n      method: ctx.request.method,\n    }),\n    router: appRouter,\n    createContext,\n  });\n\n  ctx.response.status = res.status;\n  ctx.response.headers = res.headers;\n  ctx.response.body = res.body;\n});\n\napp.use(router.routes());\napp.use(router.allowedMethods());\n\nawait app.listen({ port: 3000 });\n```\n\n----------------------------------------\n\nTITLE: Defining AppRouter Type in tRPC Server (TypeScript)\nDESCRIPTION: This snippet shows the server-side definition of an AppRouter using tRPC. It creates a router with a nested 'post' router containing a 'byId' procedure that accepts an id input and returns a post object.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/partials/_import-approuter.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    byId: t.procedure\n      .input(z.object({ id: z.string() }))\n      .query(async ({input}) => {\n        return { id: input.id, title: 'Hello' };\n      }),\n  })\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: VSCode TypeScript Configuration\nDESCRIPTION: JSON configuration for VSCode to use the correct TypeScript version from node_modules.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  \"typescript.enablePromptUseWorkspaceTsdk\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Cloning and Setting Up tRPC Repository\nDESCRIPTION: Commands to clone the tRPC repository, navigate to the project directory, install dependencies, and start the development server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/fastify-server/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:trpc/trpc.git\ncd ./trpc\nyarn\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Inferring Input and Output Types from tRPC AppRouter in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the inferRouterInputs and inferRouterOutputs helper types to infer the types of the post.create procedure from the AppRouter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/infer-types.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n\ntype RouterInput = inferRouterInputs<AppRouter>;\ntype RouterOutput = inferRouterOutputs<AppRouter>;\n\ntype PostCreateInput = RouterInput['post']['create'];\n//   ^?\ntype PostCreateOutput = RouterOutput['post']['create'];\n//   ^?\n```\n\n----------------------------------------\n\nTITLE: Configuring strictNullChecks in tsconfig.json for tRPC\nDESCRIPTION: Alternative configuration for tsconfig.json that enables strictNullChecks when full strict mode is too restrictive but type safety is still needed for tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_2\n\nLANGUAGE: diff\nCODE:\n```\n\"compilerOptions\": {\n+   \"strictNullChecks\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing tRPC Initialization with Context and Metadata in TypeScript\nDESCRIPTION: Demonstrates how to customize tRPC initialization using method chaining. This example shows setting up context and metadata during initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/routers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst t = initTRPC.context<Context>().meta<Meta>().create({\n  /* [...] */\n});\n```\n\n----------------------------------------\n\nTITLE: Custom Headers Implementation with EventSource Polyfill\nDESCRIPTION: Demonstrates how to implement custom headers using EventSource polyfill for non-web environments with authentication.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCClient,\n  httpBatchLink,\n  httpSubscriptionLink,\n  splitLink,\n} from '@trpc/client';\nimport { EventSourcePolyfill } from 'event-source-polyfill';\nimport type { AppRouter } from '../server/index.js';\n\nconst trpc = createTRPCClient<AppRouter>({\n  links: [\n    splitLink({\n      condition: (op) => op.type === 'subscription',\n      true: httpSubscriptionLink({\n        url: 'http://localhost:3000',\n        EventSource: EventSourcePolyfill,\n        eventSourceOptions: async ({ op }) => {\n          const signature = await getSignature(op);\n          return {\n            headers: {\n              authorization: 'Bearer supersecret',\n              'x-signature': signature,\n            },\n          };\n        },\n      }),\n      false: httpBatchLink({\n        url: 'http://localhost:3000',\n      }),\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating tRPC with Next.js _app component\nDESCRIPTION: Wrapping the Next.js App component with tRPC's withTRPC higher-order component. This enables tRPC functionality throughout the application.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/next/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { trpc } from '~/utils/trpc';\n\nconst App = ({ Component, pageProps }) => {\n  return <Component {...pageProps} />;\n};\n\nexport default trpc.withTRPC(App);\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Next Client with Transformer\nDESCRIPTION: Configuration example for creating a tRPC Next.js client with superjson transformer.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ncreateTRPCNext<AppRouter>({\n  // [..]\n  transformer: superjson, // <-- add this\n});\n```\n\n----------------------------------------\n\nTITLE: Input Query Example with tRPC Caller\nDESCRIPTION: Demonstrates creating a simple greeting procedure with input validation and calling it server-side.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/server-side-calls.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst router = t.router({\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => `Hello ${opts.input.name}`),\n});\n\nconst caller = router.createCaller({});\nconst result = await caller.greeting({ name: 'tRPC' });\n```\n\n----------------------------------------\n\nTITLE: Configuring Fastify Server with tRPC\nDESCRIPTION: Setting up a Fastify server with tRPC plugin integration, including error handling and server configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fastify.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  fastifyTRPCPlugin,\n  FastifyTRPCPluginOptions,\n} from '@trpc/server/adapters/fastify';\nimport fastify from 'fastify';\nimport { createContext } from './context';\nimport { appRouter, type AppRouter } from './router';\n\nconst server = fastify({\n  maxParamLength: 5000,\n});\n\nserver.register(fastifyTRPCPlugin, {\n  prefix: '/trpc',\n  trpcOptions: {\n    router: appRouter,\n    createContext,\n    onError({ path, error }) {\n      // report to error monitoring\n      console.error(`Error in tRPC handler on path '${path}':`, error);\n    },\n  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],\n});\n\n(async () => {\n  try {\n    await server.listen({ port: 3000 });\n  } catch (err) {\n    server.log.error(err);\n    process.exit(1);\n  }\n})();\n```\n\n----------------------------------------\n\nTITLE: Global Cache Invalidation Configuration\nDESCRIPTION: Configuration example for invalidating the full cache on every mutation success.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const trpc = createTRPCReact<AppRouter, SSRContext>({\n  overrides: {\n    useMutation: {\n      async onSuccess(opts) {\n        await opts.originalFn();\n        await opts.queryClient.invalidateQueries();\n      },\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing WebSocket Support for Fastify (Bash)\nDESCRIPTION: This Bash command installs the @fastify/websocket plugin using Yarn, which is required for enabling real-time subscriptions in Fastify with tRPC. Run this command before setting up WebSocket-based routes or subscription features. Works best with Fastify version 3.11.0 or newer.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @fastify/websocket\n```\n\n----------------------------------------\n\nTITLE: Using Tanstack React Query useQueryClient in a React Component (TSX)\nDESCRIPTION: Shows how to access the queryClient from Tanstack React Query directly inside React components via useQueryClient, following tRPC's removal of queryClient from its context API. Allows continued use of imperative cache operations as needed. Dependencies: @tanstack/react-query and React. Output: instantiates queryClient within a React functional component. Limitations: queryClient must be managed externally and not assumed to be available in trpc.useContext().\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_13\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQueryClient } from '@tanstack/react-query';\\n\\nconst MyComponent = () => {\\n  const queryClient = useQueryClient();\\n  // ...\\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring tsconfig.json for strict mode in tRPC\nDESCRIPTION: Configuration changes needed in tsconfig.json to enable strict mode for better type safety when using Zod for input validation with tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: diff\nCODE:\n```\n\"compilerOptions\": {\n+   \"strict\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Using useSuspenseInfiniteQuery with tRPC\nDESCRIPTION: Shows how to implement infinite scrolling with React Suspense using the useSuspenseInfiniteQuery hook. This provides pagination functionality with automatic data fetching.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\n// @filename: pages/index.tsx\nimport React from 'react';\nimport { trpc } from '../utils/trpc';\n\nfunction PostView() {\n  const [{ pages }, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(\n    {},\n    {\n      getNextPageParam(lastPage) {\n        return lastPage.nextCursor;\n      },\n    },\n  );\n\n  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =\n    allPostsQuery;\n\n  return <>{/* ... */}</>;\n}\n```\n\n----------------------------------------\n\nTITLE: Using getInfiniteData Helper in tRPC React Component\nDESCRIPTION: This snippet demonstrates how to use the getInfiniteData helper function to retrieve cached data from an existing infinite query in a tRPC React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useInfiniteQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n\n  const myMutation = trpc.infinitePosts.add.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      const allPosts = utils.infinitePosts.getInfiniteData({ limit: 10 });\n      // [...]\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Defining User Router in tRPC\nDESCRIPTION: This snippet demonstrates the definition of a user router in tRPC. It includes a procedure for listing users.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure } from '../trpc';\nimport { z } from 'zod';\nexport const userRouter = router({\n  list: publicProcedure.query(() => {\n    // [..]\n    return [];\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC and React Query Dependencies\nDESCRIPTION: Commands for installing the necessary dependencies for tRPC and React Query using different package managers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4\n```\n\n----------------------------------------\n\nTITLE: Setting up a tRPC Next.js Starter Project\nDESCRIPTION: Command line instructions for creating a new tRPC project using the next-prisma-starter template. Shows how to initialize the project using different package managers including yarn, npm, pnpm, bun, and deno.\nSOURCE: https://github.com/trpc/trpc/blob/main/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# yarn\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n\n# npm\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n\n# pnpm\npnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n\n# bun\nbunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n\n# deno\ndeno init --npm next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: React Component with Non-Batched Query\nDESCRIPTION: Example of using tRPC query in a React component with batching disabled through context configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/splitLink.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport function MyComponent() {\n  const postsQuery = proxy.posts.useQuery(undefined, {\n    trpc: {\n      context: {\n        skipBatch: true,\n      },\n    }\n  });\n  return (\n    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>\n  )\n})\n```\n\n----------------------------------------\n\nTITLE: Updating createContext Function Return Value (Diff)\nDESCRIPTION: Instructs on changing the createContext factory to always return an object (even if empty), forbidding null/undefined. This enforces stronger typing and removes ambiguity in context access. Used only for codebases that did not specify a custom context and previously relied on a nullable context. Prerequisite: code using the createContext lifecycle hook in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_12\n\nLANGUAGE: diff\nCODE:\n```\n- createContext: () => null,\\n+ createContext: () => ({}),\n```\n\n----------------------------------------\n\nTITLE: Enabling strictNullChecks in TypeScript Configuration\nDESCRIPTION: This JSON snippet demonstrates how to enable strictNullChecks in the tsconfig.json file as a minimum requirement if full strict mode is not desired.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  // ...\n  \"compilerOptions\": {\n    // ...\n    \"strictNullChecks\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Displaying Contributor Grid using HTML Tables in Markdown\nDESCRIPTION: HTML table structure used to display contributor avatars and profile links in a grid format. Each cell contains an avatar image, profile link and contributor name with consistent formatting.\nSOURCE: https://github.com/trpc/trpc/blob/main/README.md#2025-04-23_snippet_1\n\nLANGUAGE: HTML\nCODE:\n```\n<table>\n  <tr>\n   <td align=\"center\"><a href=\"https://backyard.ai/?ref=trpc&utm_source=github&utm_medium=referral&utm_campaign=trpc\"><img src=\"https://avatars.githubusercontent.com/u/95662801?v=4&s=100\" width=\"100\" alt=\"Ahoy%20Labs\"/><br />Ahoy Labs</a></td>\n   <!-- Additional contributors -->\n  </tr>\n</table>\n```\n\n----------------------------------------\n\nTITLE: Using Split Link in Direct Query\nDESCRIPTION: Demonstrates how to make a query request with batching disabled using the skipBatch context property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/splitLink.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst postResult = proxy.posts.query(null, {\n  context: {\n    skipBatch: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Strict Null Checks\nDESCRIPTION: Alternative TypeScript configuration enabling just strict null checks if full strict mode is too restrictive.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strictNullChecks\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Defining TRPCSubscriptionResult Type in TypeScript\nDESCRIPTION: This snippet defines the TRPCSubscriptionResult type, which represents the return type of the useSubscription hook. It includes properties for subscription status, received data, errors, and a reset function.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useSubscription.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ntype TRPCSubscriptionResult<TOutput, TError> = {\n  /**\n   * The current status of the subscription.\n   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.\n   *\n   * - `idle`: subscription is disabled or ended\n   * - `connecting`: trying to establish a connection\n   * - `pending`: connected to the server, receiving data\n   * - `error`: an error occurred and the subscription is stopped\n   */\n  status: 'idle' | 'connecting' | 'pending' | 'error';\n  /**\n   * The last data received from the subscription.\n   */\n  data: TOutput | undefined;\n  /**\n   * The last error received - will be `null` whenever the status is `'pending'` or `'idle'`\n   * - has a value only when the status is `'error'`\n   * - *may* have a value when the status is `'connecting'`\n   */\n  error: TRPCClientError | null;\n  /**\n   * Function to reset the subscription.\n   */\n  reset: () => void;\n};\n```\n\n----------------------------------------\n\nTITLE: Configuring Keep-Alive Ping Options for tRPC Streaming\nDESCRIPTION: Example showing how to configure a ping option in the tRPC server initialization to keep streaming connections alive. This is useful for long-running connections to prevent timeouts.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchStreamLink.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create({\n  jsonl: {\n    pingMs: 1000,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Component-level Prefetching with usePrefetchInfiniteQuery\nDESCRIPTION: Shows how to prefetch data for infinite queries using usePrefetchInfiniteQuery. This approach helps improve performance for paginated data when using Suspense.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/suspense.md#2025-04-23_snippet_7\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\n// will have to be passed to the child PostView `useSuspenseInfiniteQuery`\nexport const getNextPageParam = (lastPage) => lastPage.nextCursor;\n\nfunction PostViewPage(props: { postId: string }) {\n  trpc.post.all.usePrefetchInfiniteQuery({}, { getNextPageParam });\n\n  return (\n    <Suspense>\n      <PostView postId={props.postId} />\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Importing AppRouter Type in tRPC Client (TypeScript)\nDESCRIPTION: This snippet demonstrates how to import the AppRouter type from the server-side router file into a client-side utility file. It uses a type-only import to ensure the reference is stripped at compile-time.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/partials/_import-approuter.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '../server/router';\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Transformers to tRPC Client Configuration\nDESCRIPTION: TypeScript code to configure custom transformers in tRPC client creation using createTRPCProxyClient.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient } from '@trpc/client';\nimport { transformer } from '../utils/trpc';\n\nexport const client = createTRPCProxyClient<AppRouter>({\n  transformer, // <--\n  // [...]\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring responseMeta in withTRPC for Next.js\nDESCRIPTION: This TypeScript code shows how to configure the responseMeta callback in withTRPC for a Next.js application. It handles client errors and sets cache control headers for server-side rendering.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexport default withTRPC<AppRouter>({\n  config({ ctx }) {\n    /* [...] */\n  },\n  ssr: true,\n  responseMeta({ clientErrors, ctx }) {\n    if (clientErrors.length) {\n      // propagate first http error from API calls\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n    // cache full page for 1 day + revalidate once every second\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      'Cache-Control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Implementing AWS Lambda Request Handler for tRPC\nDESCRIPTION: Example of using the AWS Lambda adapter for tRPC. It shows how to create a context for each request and set up the Lambda handler with the tRPC router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/aws-lambda.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';\n\nconst appRouter = /* ... */;\n\n// created for each request\nconst createContext = ({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nexport const handler = awsLambdaRequestHandler({\n  router: appRouter,\n  createContext,\n})\n```\n\n----------------------------------------\n\nTITLE: Type Inference in tRPC v10\nDESCRIPTION: Simplified type inference helpers shipped with tRPC v10.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n\ntype RouterInput = inferRouterInputs<AppRouter>;\ntype RouterOutput = inferRouterOutputs<AppRouter>;\n\ntype PostCreateInput = RouterInput['post']['create'];\ntype PostCreateOutput = RouterOutput['post']['create'];\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js Prisma Starter with tRPC\nDESCRIPTION: Command to create a new Next.js application with tRPC and Prisma integration using create-next-app\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/example-apps.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Server Ping Configuration Setup\nDESCRIPTION: Demonstrates how to configure server-side ping settings to maintain connection alive.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\nexport const t = initTRPC.create({\n  sse: {\n    ping: {\n      enabled: true,\n      intervalMs: 2_000,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON and Devalue for Different Upload/Download Transformers\nDESCRIPTION: Command to install SuperJSON and Devalue packages for implementing different transformers for upload and download.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson devalue\n```\n\n----------------------------------------\n\nTITLE: Query Options Configuration\nDESCRIPTION: Examples of configuring query options with input parameters and TanStack React Query options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst queryOptions = trpc.path.to.query.queryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    stateTime: 1000,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Default Error Shape Interface Definition\nDESCRIPTION: Defines the default error shape interfaces used in tRPC error handling, including error data structure and shape extension.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-formatting.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface DefaultErrorData {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  path?: string;\n  stack?: string;\n}\n\ninterface DefaultErrorShape\n  extends TRPCErrorShape<TRPC_ERROR_CODE_NUMBER, DefaultErrorData> {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Context for HTTP/2 tRPC Server in TypeScript\nDESCRIPTION: This snippet shows how to create a context function for an HTTP/2 tRPC server. It demonstrates type inference for request, response, and additional information objects.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateHTTP2ContextOptions } from '@trpc/server/adapters/standalone';\n\nexport async function createContext(opts: CreateHTTP2ContextOptions) {\n  opts.req;\n  //    ^?\n  opts.res;\n  //    ^?\n\n  opts.info;\n  //    ^?\n  return {};\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: YouTube Video Component Usage\nDESCRIPTION: Examples of embedding YouTube videos using the YouTubeEmbed component with video IDs and titles as props.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/videos-and-community-resources.mdx#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<YouTubeEmbed\n  videoId=\"S6rcrkbsDI0\"\n  title=\"Matt Pocock: Learn tRPC in 5 minutes\"\n/>\n```\n\n----------------------------------------\n\nTITLE: Defining Error Handling in @robolex/sure\nDESCRIPTION: Implementation of error handling utility function for @robolex/sure validation library. The function wraps schema validation and throws an error for invalid inputs.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nexport const err = (schema) => (input) => {\n  const [good, result] = schema(input);\n  if (good) return result;\n  throw result;\n};\n```\n\n----------------------------------------\n\nTITLE: Accessing Custom tRPC Errors in React Component (TSX)\nDESCRIPTION: Demonstrates a React component using the `trpc.useMutation` hook. It triggers a mutation on mount and checks if the mutation result contains an error with the custom `data.zodError` field (defined in the server's `formatError`). If present, it displays the formatted Zod validation error.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/error-formatting.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\n```tsx title='components/MyComponent.tsx'\nexport function MyComponent() {\n  const mutation = trpc.useMutation('addPost');\n\n  useEffect(() => {\n    mutation.mutate({ title: 'example' });\n  }, []);\n\n  if (mutation.error?.data?.zodError) {\n    // zodError will be inferred\n    return (\n      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>\n    );\n  }\n  return <>[...]</>;\n}\n```\n```\n\n----------------------------------------\n\nTITLE: Defining ProxyTRPCContextProps Interface for tRPC React\nDESCRIPTION: This snippet defines the ProxyTRPCContextProps interface, which includes properties returned by the useUtils object in tRPC React. It specifies the client, SSR context, SSR state, and abort on unmount options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON for tRPC Data Transformation\nDESCRIPTION: Command to install SuperJSON package using yarn package manager.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC AppRouter in TypeScript\nDESCRIPTION: This snippet defines a tRPC AppRouter with procedures for listing, retrieving, and creating posts. It uses Zod for input validation and demonstrates query and mutation handlers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/infer-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query((opts) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation((opts) => {\n        // imaginary db call\n        return { id: 1, ...opts.input };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Routers and Procedures\nDESCRIPTION: Comparison of router and procedure definitions between v9 and v10 syntax.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// v9:\nconst appRouter = trpc.router()\n  .query('greeting', {\n    input: z.string(),\n    resolve(opts) {\n      return `hello ${opts.input}!`;\n    },\n  });\n\n// v10:\nconst appRouter = router({\n  greeting: publicProcedure\n    .input(z.string())\n    .query((opts) => `hello ${opts.input}!`),\n});\n```\n\n----------------------------------------\n\nTITLE: API Procedure with Context Validation\nDESCRIPTION: Demonstrates how to create a reusable procedure that validates the presence of request and response objects in the context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const apiProcedure = publicProcedure.use((opts) => {\n  if (!opts.ctx.req || !opts.ctx.res) {\n    throw new Error('You are missing `req` or `res` in your call.');\n  }\n  return opts.next({\n    ctx: {\n      req: opts.ctx.req,\n      res: opts.ctx.res,\n    },\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Input Encoding for Batch Requests\nDESCRIPTION: Shows how input parameters are encoded for batch requests in tRPC HTTP transport.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/rpc.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nencodeURIComponent(\n  JSON.stringify({\n    0: '1', // <-- input for `postById`\n    1: '1', // <-- input for `relatedPosts`\n  }),\n);\n```\n\n----------------------------------------\n\nTITLE: Initializing Streaming Mode with unstable_httpBatchStreamLink\nDESCRIPTION: Sets up a tRPC client using the unstable_httpBatchStreamLink for streaming responses. This configuration enables immediate response streaming as data becomes available.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchStreamLink.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport {\n  createTRPCProxyClient,\n  unstable_httpBatchStreamLink,\n} from '@trpc/client';\nimport type { AppRouter } from '../server';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    unstable_httpBatchStreamLink({\n      url: 'http://localhost:3000',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON for tRPC Data Transformation\nDESCRIPTION: Command to install SuperJSON package using yarn package manager.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperJSON in tRPC Server Initialization\nDESCRIPTION: TypeScript code to add SuperJSON transformer to the tRPC server initialization.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\n\nexport const t = initTRPC.create({\n  transformer: superjson,\n});\n```\n\n----------------------------------------\n\nTITLE: Development Commands for tRPC Prisma Project\nDESCRIPTION: A list of command-line commands for building, resetting the database, running the development server, testing, and more in the tRPC Prisma starter project.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-starter/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm build      # runs `prisma generate` + `prisma migrate` + `next build`\npnpm db-reset   # resets local db\npnpm dev        # starts next.js\npnpm dx         # starts postgres db + runs migrations + seeds + starts next.js\npnpm test-dev   # runs e2e tests on dev\npnpm test-start # runs e2e + unit tests\npnpm test-unit  # runs normal Vitest unit tests\npnpm test-e2e   # runs e2e tests\n```\n\n----------------------------------------\n\nTITLE: Defining ProxyTRPCContextProps Interface in TypeScript\nDESCRIPTION: TypeScript interface definition for tRPC context properties including client instance, SSR context, SSR state, and abort behavior settings. This interface is used to configure the tRPC client context and SSR behavior.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ProxyTRPCContextProps<TRouter extends AnyRouter, TSSRContext> {\n  /**\n   * The `TRPCClient`\n   */\n  client: TRPCClient<TRouter>;\n  /**\n   * The SSR context when server-side rendering\n   * @default null\n   */\n  ssrContext?: TSSRContext | null;\n  /**\n   * State of SSR hydration.\n   * - `false` if not using SSR.\n   * - `prepass` when doing a prepass to fetch queries' data\n   * - `mounting` before TRPCProvider has been rendered on the client\n   * - `mounted` when the TRPCProvider has been rendered on the client\n   * @default false\n   */\n  ssrState?: SSRState;\n  /**\n   * Abort loading query calls when unmounting a component - usually when navigating to a new page\n   * @default false\n   */\n  abortOnUnmount?: boolean;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js TodoMVC with Prisma\nDESCRIPTION: Command to create a new Next.js TodoMVC application with tRPC and Prisma integration using create-next-app\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/example-apps.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Implementing zAsyncIterable Zod Schema Helper for tRPC in TypeScript\nDESCRIPTION: This code defines a Zod schema helper called zAsyncIterable for validating async iterables. It ensures the value is an async iterable, validates each yielded item, and optionally validates the return value. It also supports tracked envelopes for subscriptions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/subscriptions.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { TrackedEnvelope } from '@trpc/server';\nimport { isTrackedEnvelope, tracked } from '@trpc/server';\nimport { z } from 'zod';\n\nfunction isAsyncIterable<TValue, TReturn = unknown>(\n  value: unknown,\n): value is AsyncIterable<TValue, TReturn> {\n  return !!value && typeof value === 'object' && Symbol.asyncIterator in value;\n}\nconst trackedEnvelopeSchema =\n  z.custom<TrackedEnvelope<unknown>>(isTrackedEnvelope);\n\n/**\n * A Zod schema helper designed specifically for validating async iterables. This schema ensures that:\n * 1. The value being validated is an async iterable.\n * 2. Each item yielded by the async iterable conforms to a specified type.\n * 3. The return value of the async iterable, if any, also conforms to a specified type.\n */\nexport function zAsyncIterable<\n  TYieldIn,\n  TYieldOut,\n  TReturnIn = void,\n  TReturnOut = void,\n  Tracked extends boolean = false,\n>(opts: {\n  /**\n   * Validate the value yielded by the async generator\n   */\n  yield: z.ZodType<TYieldIn, any, TYieldOut>;\n  /**\n   * Validate the return value of the async generator\n   * @remark not applicable for subscriptions\n   */\n  return?: z.ZodType<TReturnIn, any, TReturnOut>;\n  /**\n   * Whether if the yielded values are tracked\n   * @remark only applicable for subscriptions\n   */\n  tracked?: Tracked;\n}) {\n  return z\n    .custom<\n      AsyncIterable<\n        Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n        TReturnIn\n      >\n    >((val) => isAsyncIterable(val))\n    .transform(async function* (iter) {\n      const iterator = iter[Symbol.asyncIterator]();\n\n      try {\n        let next;\n        while ((next = await iterator.next()) && !next.done) {\n          if (opts.tracked) {\n            const [id, data] = trackedEnvelopeSchema.parse(next.value);\n            yield tracked(id, await opts.yield.parseAsync(data));\n            continue;\n          }\n          yield opts.yield.parseAsync(next.value);\n        }\n        if (opts.return) {\n          return await opts.return.parseAsync(next.value);\n        }\n        return;\n      } finally {\n        await iterator.return?.();\n      }\n    }) as z.ZodType<\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,\n      TReturnIn,\n      unknown\n    >,\n    any,\n    AsyncIterable<\n      Tracked extends true ? TrackedEnvelope<TYieldOut> : TYieldOut,\n      TReturnOut,\n      unknown\n    >\n  >;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a tRPC Mutation for a Todo Application\nDESCRIPTION: Shows how to implement a tRPC mutation endpoint for updating a todo item in a database. This example defines an input schema with Zod validation and uses Prisma for database access.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2021-05-05-hello-world.mdx#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nconst todoRouter = createRouter().mutation('add', {\n  input: z.object({\n    id: z.string().uuid(),\n    data: z.object({\n      completed: z.boolean().optional(),\n      text: z.string().min(1).optional(),\n    }),\n  }),\n  async resolve({ ctx, input }) {\n    const { id, data } = input;\n    const todo = await ctx.task.update({\n      where: { id },\n      data,\n    });\n    return todo;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using getInfiniteData Helper\nDESCRIPTION: Example of using the getInfiniteData helper to access cached data from an infinite query during mutations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useInfiniteQuery.md#2025-04-23_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport function MyComponent() {\n  const utils = trpc.useUtils();\n\n  const myMutation = trpc.infinitePosts.add.useMutation({\n    async onMutate(opts) {\n      await utils.infinitePosts.cancel();\n      const allPosts = utils.infinitePosts.getInfiniteData({ limit: 10 });\n      // [...]\n    },\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Contributing Documentation from Unversioned File in JSX\nDESCRIPTION: This code imports content from an unversioned Markdown/MDX file containing tRPC contributing guidelines and renders it in the current page.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/community/contributing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport Content from '@site/unversioned/_contributing.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Provider Setup\nDESCRIPTION: Configuration of tRPC provider with React Query client setup for API connectivity.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/react-query/README.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { trpc } from '~/utils/trpc';\nimport React, { useState } from 'react';\n\nexport function App() {\n  const [queryClient] = useState(() => new QueryClient());\n  const [trpcClient] = useState(() =>\n    trpc.createClient({\n      url: 'http://localhost:5000/trpc',\n    }),\n  );\n  return (\n    <trpc.Provider client={trpcClient} queryClient={queryClient}>\n      <QueryClientProvider client={queryClient}>\n        {/* Your app here */}\n      </QueryClientProvider>\n    </trpc.Provider>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC TanStack React Query Dependencies\nDESCRIPTION: Commands for installing @trpc/tanstack-react-query and @tanstack/react-query packages using different package managers. Requires @tanstack/react-query v5.62.8 or higher.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/tanstack-react-query/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @trpc/tanstack-react-query @tanstack/react-query\n\n# Yarn\nyarn add @trpc/tanstack-react-query @tanstack/react-query\n\n# pnpm\npnpm add @trpc/tanstack-react-query @tanstack/react-query\n\n# Bun\nbun add @trpc/tanstack-react-query @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Transformer in tRPC Client - TypeScript\nDESCRIPTION: Demonstrates how to import and use a custom transformer (combining SuperJSON and devalue) in the tRPC client configuration. It references the previously defined transformer from the utils/trpc.ts module, ensuring the client matches the server's data serialization approach. Results in a tRPC client instance ready for bi-directional custom transformation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { transformer } from '../utils/trpc';\n\n// [...]\n\nexport const client = createTRPCClient<AppRouter>({\n  // [...]\n  transformer: transformer,\n});\n```\n\n----------------------------------------\n\nTITLE: Running various commands for build, development, and testing\nDESCRIPTION: A list of commands for building the project, resetting the database, starting development servers, and running different types of tests.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-websockets-starter/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm build      # runs `prisma generate` + `prisma migrate` + `next build`\npnpm db-nuke    # resets local db\npnpm dev        # starts next.js + WebSocket server\npnpm dx         # starts postgres db + runs migrations + seeds + starts next.js\npnpm test-dev   # runs e2e tests on dev\npnpm test-start # runs e2e tests on `next start` - build required before\npnpm test:unit  # runs normal Vitest unit tests\npnpm test:e2e   # runs e2e tests\n```\n\n----------------------------------------\n\nTITLE: Defining Markdown Frontmatter for Awesome tRPC Collection Page\nDESCRIPTION: This code snippet defines the frontmatter for the Awesome tRPC Collection page, including the page ID, title, sidebar label, and URL slug.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/community/awesome-trpc.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: awesome-trpc\ntitle: Awesome tRPC Collection\nsidebar_label: Awesome tRPC Collection\nslug: /community/awesome-trpc\n---\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies for Express\nDESCRIPTION: Command to install necessary dependencies for using tRPC with Express. It includes @trpc/server for the core functionality and zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/express.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server zod\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with Prisma using npm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, and ESLint using npm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Using useUtils Hook in React Component\nDESCRIPTION: Example showing how to use the useUtils hook to access query helpers in a React component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useUtils.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nfunction MyComponent() {\n  const utils = trpc.useUtils();\n  utils.post.all.f;\n  //              ^|\n  // [...]\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Vanilla tRPC Client in TypeScript\nDESCRIPTION: Example of creating a basic tRPC client without using the React Query integration, demonstrating the manual setup process.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/introduction.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const trpc = createTRPCClient<AppRouter>({\n  links: [httpBatchLink({ url: 'YOUR_API_URL' })],\n});\n```\n\n----------------------------------------\n\nTITLE: Exporting Router Types for Client Use in TypeScript\nDESCRIPTION: This code exports the AppRouter type and the abstract MyRouterLike and MyRouterUtilsLike types for use in the client. It allows for type-safe usage of the router in client-side code.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport type AppRouter = typeof appRouter;\n\nexport type { MyRouterLike, MyRouterUtilsLike } from './factory';\n```\n\n----------------------------------------\n\nTITLE: tRPC Procedure Calls Comparison\nDESCRIPTION: Examples showing how to call tRPC procedures in v9 vs v10.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n// v9\nclient.query('greeting', 'KATT');\ntrpc.useQuery(['greeting', 'KATT']);\n\n// v10\nclient.greeting.query('KATT');\ntrpc.greeting.useQuery('KATT');\n```\n\n----------------------------------------\n\nTITLE: RetryLink Interface Definitions in TypeScript\nDESCRIPTION: TypeScript interface definitions for RetryLinkOptions and RetryFnOptions, showing the structure and available configuration options for the retryLink functionality including retry logic and delay settings.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/retryLink.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\ninterface RetryLinkOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The retry function\n   */\n  retry: (opts: RetryFnOptions<TInferrable>) => boolean;\n  /**\n   * The delay between retries in ms (defaults to 0)\n   */\n  retryDelayMs?: (attempt: number) => number;\n}\n\ninterface RetryFnOptions<TInferrable extends InferrableClientTypes> {\n  /**\n   * The operation that failed\n   */\n  op: Operation;\n  /**\n   * The error that occurred\n   */\n  error: TRPCClientError<TInferrable>;\n  /**\n   * The number of attempts that have been made (including the first call)\n   */\n  attempts: number;\n}\n```\n\n----------------------------------------\n\nTITLE: Using the Custom Transformer in tRPC Server Router - TypeScript\nDESCRIPTION: Imports the mixed-direction transformer from a utilities module and applies it to the tRPC server router, aligning upload and download serialization strategies. Requires @trpc/server and the custom transformer from utils. The transformer is applied via .transformer(transformer).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { transformer } from '../../utils/trpc';\n\nexport const appRouter = trpc.router().transformer(transformer);\n// .query(...)\n```\n\n----------------------------------------\n\nTITLE: Handling CORS in tRPC Next.js API Handler\nDESCRIPTION: This code snippet shows how to modify the tRPC API handler to enable CORS and handle OPTIONS requests. It demonstrates setting various headers and conditionally responding to OPTIONS requests before passing the request to the tRPC handler.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/nextjs.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createNextApiHandler } from '@trpc/server/adapters/next';\nimport { createContext } from '../../../server/trpc/context';\nimport { appRouter } from '../../../server/trpc/router/_app';\n\n// create the API handler, but don't return it yet\nconst nextApiHandler = createNextApiHandler({\n  router: appRouter,\n  createContext,\n});\n\n// @link https://nextjs.org/docs/api-routes/introduction\nexport default async function handler(\n  req: NextApiRequest,\n  res: NextApiResponse,\n) {\n  // We can use the response object to enable CORS\n  res.setHeader('Access-Control-Allow-Origin', '*');\n  res.setHeader('Access-Control-Request-Method', '*');\n  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  res.setHeader('Access-Control-Allow-Headers', '*');\n\n  // If you need to make authenticated CORS calls then\n  // remove what is above and uncomment the below code\n\n  // Allow-Origin has to be set to the requesting domain that you want to send the credentials back to\n  // res.setHeader('Access-Control-Allow-Origin', 'http://example:6006');\n  // res.setHeader('Access-Control-Request-Method', '*');\n  // res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');\n  // res.setHeader('Access-Control-Allow-Headers', 'content-type');\n  // res.setHeader('Referrer-Policy', 'no-referrer');\n  // res.setHeader('Access-Control-Allow-Credentials', 'true');\n\n  if (req.method === 'OPTIONS') {\n    res.writeHead(200);\n    return res.end();\n  }\n\n  // finally pass the request on to the tRPC handler\n  return nextApiHandler(req, res);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with WebSockets using pnpm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, WebSockets, and subscriptions using pnpm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\npnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC and Fastify Dependencies\nDESCRIPTION: Command to install the necessary dependencies for using tRPC with Fastify, including the server, Fastify, and Zod for input validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server fastify zod\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js TodoMVC Example with create-next-app\nDESCRIPTION: Command to create a new Next.js TodoMVC project with tRPC, featuring SSG and Prisma integration\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/starter-projects.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Context Overlap Constraints in tRPC Middleware Piping (TypeScript)\nDESCRIPTION: This example demonstrates the importance of context compatibility when using `unstable_pipe()`. `fooMiddleware` expects `ctx.a` as an object but modifies it to a string. `barMiddleware` also expects `ctx.a` as an object. Piping `fooMiddleware.unstable_pipe(barMiddleware)` fails because the context modified by `fooMiddleware` is incompatible with `barMiddleware`'s expectation. Conversely, `barMiddleware.unstable_pipe(fooMiddleware)` works because `barMiddleware` doesn't modify `ctx.a`, preserving compatibility for `fooMiddleware`.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/middlewares.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n```ts twoslash\nimport { initTRPC } from '@trpc/server';\n\nconst t = initTRPC\n  .context<{\n    a: {\n      b: 'a';\n    };\n  }>()\n  .create();\n\nconst fooMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // 👈 fooMiddleware expects `ctx.a` to be an object\n  //  ^?\n  return opts.next({\n    ctx: {\n      a: 'a' as const, // 👈 `ctx.a` is no longer an object\n    },\n  });\n});\n\nconst barMiddleware = t.middleware((opts) => {\n  const { ctx } = opts;\n  ctx.a; // 👈 barMiddleware expects `ctx.a` to be an object\n  //  ^?\n  return opts.next({\n    ctx: {\n      foo: 'foo' as const,\n    },\n  });\n});\n\n// @errors: 2345\n// ❌ `ctx.a` does not overlap from `fooMiddleware` to `barMiddleware`\nfooMiddleware.unstable_pipe(barMiddleware);\n\n// ✅ `ctx.a` overlaps from `barMiddleware` and `fooMiddleware`\nbarMiddleware.unstable_pipe(fooMiddleware);\n```\n```\n\n----------------------------------------\n\nTITLE: Configuring SuperJSON as Transformer in tRPC Client - TypeScript\nDESCRIPTION: This snippet shows how to import SuperJSON and configure it as the transformer in the tRPC client via createTRPCClient. SuperJSON enables serialization/deserialization of advanced JavaScript types over the wire. Ensure superjson is installed as a dependency, and pass it into the transformer field during client initialization. Input is the AppRouter type; output is a tRPC client instance configured for SuperJSON.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/data-transformers.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport superjson from 'superjson';\n\n// [...]\n\nexport const client = createTRPCClient<AppRouter>({\n  // [...]\n  transformer: superjson,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Router Configuration\nDESCRIPTION: Implementation of a basic tRPC router with a sample query endpoint that accepts a string input and returns user data. Demonstrates type definition exports and basic resolver setup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/aws-lambda.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { z } from 'zod';\n\nconst appRouter = trpc.router().query('getUser', {\n  input: z.string(),\n  async resolve(req) {\n    req.input; // string\n    return { id: req.input, name: 'Bilbo' };\n  },\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Rendering Custom React Components for tRPC Documentation\nDESCRIPTION: This code snippet imports and renders custom React components used in the tRPC documentation page. It includes a Button component and a GithubSponsorButton component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/unversioned/_contributing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { Button } from '@site/src/components/Button';\nimport { GithubSponsorButton } from '@site/src/components/GithubSponsorButton';\n\n<GithubSponsorButton />\n```\n\n----------------------------------------\n\nTITLE: Setting up Next.js project with tRPC using create-next-app\nDESCRIPTION: This command creates a new Next.js project with tRPC integration using a minimal starter template. It clones the example from the tRPC GitHub repository and sets up the project directory.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-minimal-starter/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-minimal-starter trpc-minimal-starter\ncd trpc-minimal-starter\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Split Link Type Definition\nDESCRIPTION: Type definition for the splitLink function showing its options interface including condition function and branch links.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/splitLink.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}) => TRPCLink<TRouter>\n```\n\n----------------------------------------\n\nTITLE: Registering @fastify/websocket Plugin with Fastify Server (TypeScript)\nDESCRIPTION: Imports the @fastify/websocket package and registers it as a plugin on the Fastify instance. This step is mandatory before enabling WebSocket endpoints or subscriptions using Fastify and tRPC. Place this logic in your Fastify server setup prior to registering any WebSocket-related routes or plugins.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport ws from '@fastify/websocket';\n\nserver.register(ws);\n```\n\n----------------------------------------\n\nTITLE: Cloning zART Stack Example Repository\nDESCRIPTION: Command to clone the zART stack example repository which demonstrates a monorepo setup with React Native, Next.js, and Prisma integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/starter-projects.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:KATT/zart.git\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Router with Hello Procedure in TypeScript\nDESCRIPTION: This backend code snippet demonstrates how to create a tRPC router with a 'hello' procedure. It uses Zod for input validation and defines a query that returns a greeting.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQuery.md#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  // Create procedure at path 'hello'\n  hello: t.procedure\n    // using zod schema to validate and infer input values\n    .input(\n      z\n        .object({\n          text: z.string().nullish(),\n        })\n        .nullish(),\n    )\n    .query((opts) => {\n      return {\n        greeting: `hello ${opts.input?.text ?? 'world'}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies with yarn\nDESCRIPTION: Commands to install tRPC and related packages using yarn. This includes server, client, React, and Next.js integrations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/quickstart.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server @trpc/client @trpc/react react-query@3 @trpc/next\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Hooks in React Component\nDESCRIPTION: Demonstrates how to use tRPC's React Query integration within a React component. It shows the usage of useQuery for fetching data and useMutation for performing mutations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/introduction.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { trpc } from '../utils/trpc';\n\nexport default function IndexPage() {\n  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });\n  const goodbyeMutation = trpc.goodbye.useMutation();\n\n  return (\n    <div>\n      <p>{helloQuery.data?.greeting}</p>\n\n      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing SSG Helpers for tRPC in TypeScript\nDESCRIPTION: This snippet demonstrates how to import and use createSSGHelpers to set up server-side generation helper functions for tRPC. It includes options for the router, context, and an optional transformer.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/ssg-helpers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createSSGHelpers } from '@trpc/react/ssg';\n\nconst {\n  prefetchQuery,\n  prefetchInfiniteQuery,\n  fetchQuery,\n  fetchInfiniteQuery,\n  dehydrate,\n  queryClient,\n} = await createSSGHelpers({\n  router: appRouter,\n  ctx: createContext,\n  transformer: superjson, // optional - adds superjson serialization\n});\n```\n\n----------------------------------------\n\nTITLE: Example tRPC Error Response Structure\nDESCRIPTION: Shows the standard JSON structure of an error response from tRPC when a bad request input is received. Includes error message, code, and debug information.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/error-handling.md#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"id\": null,\n  \"error\": {\n    \"message\": \"\\\"password\\\" must be at least 4 characters\",\n    \"code\": -32600,\n    \"data\": {\n      \"code\": \"BAD_REQUEST\",\n      \"httpStatus\": 400,\n      \"stack\": \"...\",\n      \"path\": \"user.changepassword\"\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies and Starting Local Development Environment for tRPC\nDESCRIPTION: A series of commands to install dependencies, build the project, start the local server using serverless-offline, and run the client. This setup allows for local development and testing of a tRPC project configured for AWS Lambda deployment.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/lambda-api-gateway/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n$ yarn install\n$ yarn build\n$ yarn start-server\n$ yarn start-client\n```\n\n----------------------------------------\n\nTITLE: Creating Router Factory and Abstract Types in TypeScript\nDESCRIPTION: This snippet demonstrates how to create a router factory and generate abstract types for use in the client. It uses RouterLike and UtilsLike types from @trpc/react-query/shared to create abstract types for the router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { t, publicProcedure } from './trpc';\n\nimport { RouterLike, UtilsLike } from '@trpc/react-query/shared';\n\nexport function createMyRouter() {\n  return t.router({\n    createThing: publicProcedure\n      .input(ThingRequest)\n      .output(Thing)\n      .mutation(/* do work */),\n    listThings: publicProcedure\n      .input(ThingQuery)\n      .output(ThingArray)\n      .query(/* do work */),\n  })\n}\n\ntype MyRouterType = ReturnType<typeof createMyRouter>\nexport MyRouterLike = RouterLike<MyRouterType>\nexport MyRouterUtilsLike = UtilsLike<MyRouterType>\n```\n\n----------------------------------------\n\nTITLE: Enabling WebSocket Support in Fastify tRPC Plugin Registration (TypeScript)\nDESCRIPTION: In the server setup, this TypeScript snippet activates WebSocket support for the tRPC Fastify plugin by setting the 'useWSS' property to true during plugin registration. This is required to handle WebSocket requests in addition to HTTP, supporting real-time subscriptions defined on the router. Insert this during Fastify server configuration prior to startup.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/fastify.md#2025-04-23_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nserver.register(fastifyTRPCPlugin, {\n  useWSS: true,\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Standalone tRPC Server with CORS in TypeScript\nDESCRIPTION: This snippet shows how to configure the standalone tRPC server with CORS support using the cors package. It sets up an HTTP server that listens on port 3333 and applies CORS middleware to all requests.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/standalone.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\nimport cors from 'cors';\n\ncreateHTTPServer({\n  middleware: cors(),\n  router: appRouter,\n  createContext() {\n    console.log('context 3');\n    return {};\n  },\n}).listen(3333);\n```\n\n----------------------------------------\n\nTITLE: Installing and Running tRPC Development Server\nDESCRIPTION: Commands for installing dependencies and starting the development server for a tRPC example project.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/lazy-load/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm i\nnpm run dev\n```\n\n----------------------------------------\n\nTITLE: Defining useQuery Hook Signature in TypeScript\nDESCRIPTION: Core type definitions for the useQuery hook, showing function signature and options interface that extends TanStack Query's UseQueryOptions with tRPC-specific configurations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useQuery(\n  input: TInput | SkipToken,\n  opts?: UseTRPCQueryOptions;\n)\n\ninterface UseTRPCQueryOptions\n  extends UseQueryOptions {\n  trpc: {\n    ssr?: boolean;\n    abortOnUnmount?: boolean;\n    context?: Record<string, unknown>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Client Libraries with Package Managers\nDESCRIPTION: Commands for installing @trpc/client and @trpc/server using different package managers (npm, yarn, pnpm, bun).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/setup.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @trpc/client @trpc/server\n```\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/client @trpc/server\n```\n\nLANGUAGE: bash\nCODE:\n```\npnpm add @trpc/client @trpc/server\n```\n\nLANGUAGE: bash\nCODE:\n```\nbun add @trpc/client @trpc/server\n```\n\n----------------------------------------\n\nTITLE: Defining DataTransformer Interface in TypeScript\nDESCRIPTION: TypeScript interface definitions for DataTransformer, InputDataTransformer, OutputDataTransformer, and CombinedDataTransformer used in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/data-transformers.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface DataTransformer {\n  serialize(object: any): any;\n  deserialize(object: any): any;\n}\n\ninterface InputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the client** before sending the data to the server.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **on the server** to transform the data before it is passed to the resolver\n   */\n  deserialize(object: any): any;\n}\n\ninterface OutputDataTransformer extends DataTransformer {\n  /**\n   * This function runs **on the server** before sending the data to the client.\n   */\n  serialize(object: any): any;\n  /**\n   * This function runs **only on the client** to transform the data sent from the server.\n   */\n  deserialize(object: any): any;\n}\n\nexport interface CombinedDataTransformer {\n  /**\n   * Specify how the data sent from the client to the server should be transformed.\n   */\n  input: InputDataTransformer;\n  /**\n   * Specify how the data sent from the server to the client should be transformed.\n   */\n  output: OutputDataTransformer;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC React Query Dependencies\nDESCRIPTION: Commands for installing required packages (@trpc/react-query and @tanstack/react-query) using different package managers.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/react-query/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @trpc/react-query @tanstack/react-query\n\n# Yarn\nyarn add @trpc/react-query @tanstack/react-query\n\n# pnpm\npnpm add @trpc/react-query @tanstack/react-query\n\n# Bun\nbun add @trpc/react-query @tanstack/react-query\n```\n\n----------------------------------------\n\nTITLE: Database Type Definitions and Mock Implementation\nDESCRIPTION: Defines User type and implements mock database operations for user management including findMany, findById, and create functions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/quickstart.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntype User = { id: string; name: string };\n\n// Imaginary database\nconst users: User[] = [];\nexport const db = {\n  user: {\n    findMany: async () => users,\n    findById: async (id: string) => users.find((user) => user.id === id),\n    create: async (data: { name: string }) => {\n      const user = { id: String(users.length + 1), ...data };\n      users.push(user);\n      return user;\n    },\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using GithubSponsorButton Component in JSX\nDESCRIPTION: Renders the GithubSponsorButton component at the end of the blog post to encourage GitHub sponsorship of the tRPC project.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2022-11-21-announcing-trpc-10.mdx#2025-04-23_snippet_1\n\nLANGUAGE: jsx\nCODE:\n```\n<GithubSponsorButton />\n```\n\n----------------------------------------\n\nTITLE: Installing and Running the Fastify Example in Development Mode\nDESCRIPTION: Commands to navigate to the Fastify example directory, install its dependencies, and run it in development mode.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/fastify-server/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ncd ./examples/fastify-server\nyarn\nyarn dev\n```\n\n----------------------------------------\n\nTITLE: Cloning and Running the tRPC v10 Next.js Big Router Example\nDESCRIPTION: Commands to clone the tRPC v10 Next.js big router example repository, install dependencies, and start the development server. The example includes a postinstall script that generates 700 procedures to demonstrate the developer experience with large routers.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-big-router/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:trpc/examples-v10-next-big-router.git\ncd examples-v10-next-big-router\nyarn && code . && yarn dev\n```\n\n----------------------------------------\n\nTITLE: Implementing Nested Router Procedures in tRPC\nDESCRIPTION: Demonstrates how to create nested router procedures in tRPC using the router() method. Shows implementation of a nested 'post.byId' procedure that accepts a String input.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/rpc.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nexport const appRouter = router({\n  post: router({\n    byId: publicProcedure.input(String).query(async (opts) => {\n      // [...]\n    }),\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing edge-runtime Globally using npm\nDESCRIPTION: This command installs the `edge-runtime` package globally using the Node Package Manager (npm). The `-g` flag signifies a global installation, making the `edge-runtime` command available system-wide. This runtime is used for locally testing Vercel Edge Functions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n```sh\nnpm install -g edge-runtime\n```\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Sponsors Content in MDX\nDESCRIPTION: A markdown/MDX file that imports a sponsors content component and renders it. Uses frontmatter for page metadata and imports an unversioned sponsors component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/community/sponsors.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: sponsors\ntitle: Sponsors\nsidebar_label: Sponsors\nslug: /community/sponsors\n---\n\nimport Content from '@site/unversioned/_sponsors.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Server Dependencies\nDESCRIPTION: Command to install the required tRPC server package using yarn.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/aws-lambda.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server\n```\n\n----------------------------------------\n\nTITLE: Installing WebSocket Package (Bash)\nDESCRIPTION: This command installs the 'ws' package, which is required for creating a WebSocket server in Node.js.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/further/subscriptions.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add ws\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with WebSockets using yarn\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, WebSockets, and subscriptions using yarn.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Configuring Next.js API Handler without Batching\nDESCRIPTION: Example of disabling request batching in a Next.js API route handler.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nexport default trpcNext.createNextApiHandler({\n  // [...]\n  // 👇 disable batching\n  allowBatching: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies\nDESCRIPTION: Package installation commands for different package managers to set up tRPC with required dependencies.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @trpc/server zod\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @trpc/server zod\n```\n\nLANGUAGE: sh\nCODE:\n```\npnpm add @trpc/server zod\n```\n\nLANGUAGE: sh\nCODE:\n```\nbun add @trpc/server zod\n```\n\n----------------------------------------\n\nTITLE: Running TRPCClient Server in Deno\nDESCRIPTION: Command to start the server for a TRPCClient example in Deno. This should be run in a terminal after installing Deno.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/deno-deploy/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\ndeno task server\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Router Configuration\nDESCRIPTION: Basic tRPC router setup with user management functionality including query and mutation endpoints.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\nimport { Context } from './context';\n\ntype User = {\n  id: string;\n  name: string;\n  bio?: string;\n};\n\nconst users: Record<string, User> = {};\n\nexport const t = initTRPC.context<Context>().create();\n\nexport const appRouter = t.router({\n  getUserById: t.procedure.input(z.string()).query((opts) => {\n    return users[opts.input];\n  }),\n  createUser: t.procedure\n    .input(\n      z.object({\n        name: z.string().min(3),\n        bio: z.string().max(142).optional(),\n      }),\n    )\n    .mutation((opts) => {\n      const id = Date.now().toString();\n      const user: User = { id, ...opts.input };\n      users[user.id] = user;\n      return user;\n    }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Context with Fetch Adapter\nDESCRIPTION: Implementation of a context creator function for tRPC using the Fetch adapter. Handles request headers and user authentication context.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch';\n\nexport function createContext({\n  req,\n  resHeaders,\n}: FetchCreateContextFnOptions) {\n  const user = { name: req.headers.get('username') ?? 'anonymous' };\n  return { req, resHeaders, user };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Installing Dependencies for tRPC Website (Console)\nDESCRIPTION: This command installs the necessary dependencies for the tRPC website project using pnpm package manager.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/README.md#2025-04-23_snippet_0\n\nLANGUAGE: console\nCODE:\n```\npnpm install\n```\n\n----------------------------------------\n\nTITLE: Sample tRPC React Component with Performance Issue\nDESCRIPTION: Example React component demonstrating the TypeScript performance bottleneck with tRPC's useContext hook.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-14-typescript-performance-lessons.mdx#2025-04-23_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport type { AppRouter } from '~/server/trpc';\n\nconst trpc = createTRPCReact<AppRouter>();\nconst Home: NextPage = () => {\n  const { data } = trpc.r0.greeting.useQuery({ who: 'from tRPC' });\n\n  const utils = trpc.useContext();\n\n  utils.r49.greeting.invalidate();\n};\n\nexport default Home;\n```\n\n----------------------------------------\n\nTITLE: Building and Starting tRPC Production Environment\nDESCRIPTION: Commands for building the tRPC application and starting it in production mode after the build process is complete.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/minimal-react/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run build\nnpm run start\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with Prisma using pnpm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, and ESLint using pnpm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\npnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Setting up the tRPC Development Environment\nDESCRIPTION: Commands for cloning the tRPC repository, installing dependencies with pnpm, and building the project for development.\nSOURCE: https://github.com/trpc/trpc/blob/main/CONTRIBUTING.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:trpc/trpc.git\ncd trpc\npnpm install\npnpm build\n```\n\n----------------------------------------\n\nTITLE: Recommended File Structure for tRPC with Next.js\nDESCRIPTION: This snippet illustrates the recommended file structure for a Next.js project using tRPC. It shows the organization of prisma, pages, server, and utils directories.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_0\n\nLANGUAGE: graphql\nCODE:\n```\n.\n├── prisma # <-- if prisma is added\n│   └── [..]\n├── src\n│   ├── pages\n│   │   ├── _app.tsx # <-- add `withTRPC()`-HOC here\n│   │   ├── api\n│   │   │   └── trpc\n│   │   │       └── [trpc].ts # <-- tRPC HTTP handler\n│   │   └── [..]\n│   ├── server\n│   │   ├── routers\n│   │   │   ├── app.ts   # <-- main app router\n│   │   │   ├── post.ts  # <-- sub routers\n│   │   │   └── [..]\n│   │   ├── context.ts      # <-- create app context\n│   │   └── createRouter.ts # <-- router helper\n│   └── utils\n│       └── trpc.ts  # <-- your typesafe tRPC hooks\n└── [..]\n```\n\n----------------------------------------\n\nTITLE: Initializing Next.js TodoMVC Example with create-next-app\nDESCRIPTION: Command to create a new Next.js TodoMVC project with tRPC and Prisma integration, featuring SSG (Static Site Generation) capabilities.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/nextjs/starter-projects.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Todo MVC example using npm\nDESCRIPTION: Command to create a new Next.js Todo MVC application with tRPC, SSG, and Prisma using npm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Starting Next.js Development Server\nDESCRIPTION: Command to start the Next.js development server for local development.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-edge-runtime/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev        # starts next.js\n```\n\n----------------------------------------\n\nTITLE: Cloning create-t3-turbo repository\nDESCRIPTION: Command to clone the create-t3-turbo repository, which is a T3 Stack project with Expo and Turborepo integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/example-apps.mdx#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:t3-oss/create-t3-turbo.git\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies with npm\nDESCRIPTION: Commands to install tRPC and related packages using npm. This includes server, client, React, and Next.js integrations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/quickstart.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install @trpc/server @trpc/client @trpc/react react-query@3 @trpc/next\n```\n\n----------------------------------------\n\nTITLE: Starting the tRPC Express Example\nDESCRIPTION: Command to run the server and client components of the tRPC Express minimal example. This launches both the Express server and the Node.js client that communicates with it.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/express-minimal/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with Prisma using yarn\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, and ESLint using yarn.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Starting the Next.js development server\nDESCRIPTION: This command starts the Next.js development server for the tRPC-integrated project. It allows developers to run and test the application locally during development.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-minimal-starter/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nnpm run dev        # starts next.js\n```\n\n----------------------------------------\n\nTITLE: Configuring splitLink for Conditional Batching in tRPC\nDESCRIPTION: Demonstrates how to use splitLink to conditionally enable or disable request batching based on a context property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/client/links.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client/links/httpBatchLink';\nimport { httpLink } from '@trpc/client/links/httpLink';\nimport { splitLink } from '@trpc/client/links/splitLink';\nimport { withTRPC } from '@trpc/next';\n\n// [..]\nexport default withTRPC<AppRouter>({\n  config() {\n    const url = `http://localhost:3000`;\n\n    return {\n      links: [\n        splitLink({\n          condition(op) {\n            // check for context property `skipBatch`\n            return op.context.skipBatch === true;\n          },\n          // when condition is true, use normal request\n          true: httpLink({\n            url,\n          }),\n          // when condition is false, use batching\n          false: httpBatchLink({\n            url,\n          }),\n        }),\n      ],\n    };\n  },\n})(MyApp);\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic tRPC Server with Router and Procedures\nDESCRIPTION: Sets up a tRPC server with a router containing procedures for listing posts, getting posts by ID, and creating posts. This is the foundation for the type inference examples that follow.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    list: t.procedure\n      .query(() => {\n        // imaginary db call\n        return [{ id: 1, title: 'tRPC is the best!' }];\n    }),\n    byId: t.procedure\n      .input(z.string())\n      .query(({ input }) => {\n        // imaginary db call\n        return { id: 1, title: 'tRPC is the best!' };\n    }),\n    create: t.procedure\n      .input(z.object({ title: z.string(), text: z.string(), }))\n      .mutation(({ input }) => {\n        // imaginary db call\n        return { id: 1, ...input };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Cloning create-t3-turbo repository\nDESCRIPTION: Command to clone the create-t3-turbo repository, which includes T3 Stack with Expo and Turborepo.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:t3-oss/create-t3-turbo.git\n```\n\n----------------------------------------\n\nTITLE: Running tRPC Client with Bun\nDESCRIPTION: Command to run the tRPC client using Bun. This should be executed in a separate terminal after starting the server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/bun/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nbun dev:client\n```\n\n----------------------------------------\n\nTITLE: Setting up Prisma + tRPC + WebSockets project with Next.js\nDESCRIPTION: Commands to create a new Next.js project using the tRPC example template, install dependencies, and start the development environment.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-websockets-starter/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\ncd trpc-prisma-websockets-starter\npnpm i\npnpm dx\n```\n\n----------------------------------------\n\nTITLE: Installing WebSocket Dependencies for tRPC\nDESCRIPTION: Command to install the 'ws' package for WebSocket functionality in a tRPC project.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/websockets.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add ws\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Todo MVC example using pnpm\nDESCRIPTION: Command to create a new Next.js Todo MVC application with tRPC, SSG, and Prisma using pnpm.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\npnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Running tRPC Locally from Source\nDESCRIPTION: Commands for running tRPC locally using source files with tsx. Includes example command for running the upgrade tool in a minimal React client project with specific flags.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/upgrade/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nDEV=1 pnpx tsx path/to/bin/index.ts\n\n# example\ncd examples/minimal-react/client && DEV=1 pnpx tsx ../../../packages/upgrade/src/bin/index.ts --force --skipTanstackQuery --verbose\n```\n\n----------------------------------------\n\nTITLE: Embedding YouTube Video Component Import\nDESCRIPTION: Import statement for a custom YouTube video embedding component used throughout the documentation page.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/videos-and-community-resources.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { YouTubeEmbed } from '@site/src/components/YouTubeEmbed';\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Client Package\nDESCRIPTION: Multiple package manager commands for installing the @trpc/client package using npm, yarn, pnpm, or bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/client/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# npm\nnpm install @trpc/client\n\n# Yarn\nyarn add @trpc/client\n\n# pnpm\npnpm add @trpc/client\n\n# Bun\nbun add @trpc/client\n```\n\n----------------------------------------\n\nTITLE: Running TypeScript Performance Trace\nDESCRIPTION: Command to generate a TypeScript performance trace file for analysis with tools like Perfetto.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-14-typescript-performance-lessons.mdx#2025-04-23_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ntsc --generateTrace ./trace --incremental false\n```\n\n----------------------------------------\n\nTITLE: Installing Client Dependencies for tRPC\nDESCRIPTION: Commands for installing required client-side tRPC dependencies including React Query.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/client @trpc/server @trpc/react react-query@3\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Prisma Starter with create-next-app\nDESCRIPTION: Command to create a new Next.js project with tRPC and Prisma integration, including E2E testing and ESLint configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/starter-projects.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Installing and Running Compiled tRPC\nDESCRIPTION: Steps to build, link, and run the compiled version of tRPC upgrade tool. Shows how to link the package locally and run it in another application.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/upgrade/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ncd packages/upgrade\npnpm build && pnpm link .\n\n# in an app somewhere\npnpm link @trpc/upgrade && pnpm trpc-upgrade\n```\n\n----------------------------------------\n\nTITLE: Starting tRPC Server with Bun\nDESCRIPTION: Command to start the tRPC server using Bun. This should be run in a terminal after installing Bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/bun/README.md#2025-04-23_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\nbun dev:server\n```\n\n----------------------------------------\n\nTITLE: Configuring VSCode Settings for tRPC TypeScript Integration\nDESCRIPTION: VSCode workspace settings configuration to ensure proper TypeScript version usage between the editor and project dependencies. These settings help maintain consistency in TypeScript versioning across the development environment.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/faq.mdx#2025-04-23_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  \"typescript.enablePromptUseWorkspaceTsdk\": true\n}\n```\n\n----------------------------------------\n\nTITLE: Running tRPC Tests in Watch Mode\nDESCRIPTION: Commands for running the test suite in watch mode with options for targeting specific test files or regression tests.\nSOURCE: https://github.com/trpc/trpc/blob/main/CONTRIBUTING.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npnpm test-watch\n\n# example if you want to test a specific test file:\npnpm test-watch react\n\n# run only a regression test while fixing a bug\npnpm test-watch 3085\n```\n\n----------------------------------------\n\nTITLE: Setting up HTTP/2 Support for tRPC Server in TypeScript\nDESCRIPTION: This code demonstrates how to set up an HTTP/2 server with tRPC using the standalone adapter. It includes configuration for secure server creation and request handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport http2 from 'http2';\nimport { createHTTP2Handler } from '@trpc/server/adapters/standalone';\nimport { appRouter } from './_app.ts';\nimport { createContext } from './context.ts';\n\nconst handler = createHTTP2Handler({\n  router: appRouter,\n  createContext,\n  // basePath: '/trpc/', // optional, defaults to '/'\n});\n\nconst server = http2.createSecureServer(\n  {\n    key: '...',\n    cert: '...',\n  },\n  (req, res) => {\n    /**\n     * Handle the request however you like,\n     * just call the tRPC handler when you're ready\n     */\n    handler(req, res);\n  },\n);\n\nserver.listen(3001);\n```\n\n----------------------------------------\n\nTITLE: Original tRPC Router Type Implementation\nDESCRIPTION: Shows the initial implementation of V10Router and MigrateV9Router types that caused performance issues due to combining v9 and v10 procedures in a single record field.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-14-typescript-performance-lessons.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type V10Router<TProcedureRecord> = {\n  record: TProcedureRecord;\n};\n\n// convert a v9 interop router to a v10 router\nexport type MigrateV9Router<TV9Router extends V9Router> = V10Router<{\n  [TKey in keyof TV9Router['procedures']]: MigrateProcedure<\n    TV9Router['procedures'][TKey]\n  > &\n    LegacyV9ProcedureTag;\n}>;\n```\n\n----------------------------------------\n\nTITLE: HTML Markdown Structure for tRPC Documentation\nDESCRIPTION: The main documentation structure combining HTML and Markdown to display the tRPC logo, badges, video embed, and core documentation content.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/introduction.mdx#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<div align=\"center\">\n  <img src=\"/img/logo-text-white.svg\" alt=\"tRPC\" style={{height: '150px'}} />\n  <p>End-to-end typesafe APIs made easy</p>\n  <p>\n    <a href=\"https://codecov.io/gh/trpc/trpc\">\n      <img src=\"https://codecov.io/gh/trpc/trpc/branch/main/graph/badge.svg?token=KPPS918B0G\" alt=\"codecov\" className=\"inline-block\" />\n    </a> <a href=\"https://github.com/trpc/trpc\">\n      <img src=\"https://img.shields.io/github/license/trpc/trpc.svg?label=license&style=flat\" alt=\"GitHub License\" className=\"inline-block\"/>\n    </a> <a href=\"https://github.com/trpc/trpc\">\n      <img src=\"https://img.shields.io/github/stars/trpc/trpc.svg?label=🌟%20stars&style=flat\" alt=\"GitHub Stars\" className=\"inline-block\"/>\n    </a>\n  </p>\n\n  <h2>Watch Video</h2>\n  <figure>\n    <iframe loading=\"lazy\" src=\"https://www.youtube.com/embed/-_GZJ3xwYOw\" title=\"YouTube video player\" frameBorder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowFullScreen style={{maxWidth: '100%', width: '560px', height: '315px'}}></iframe>\n    <figcaption style={{ fontSize: '0.7rem' }} className=\"pt-2\"><a href=\"https://twitter.com/alexdotjs\">Alex / KATT</a> and Prisma's Mahmoud Abdelwahab doing a deep dive into tRPC.</figcaption>\n  </figure>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Starting tRPC Development Watch Mode\nDESCRIPTION: Command to run the development watcher that automatically rebuilds packages on file changes.\nSOURCE: https://github.com/trpc/trpc/blob/main/CONTRIBUTING.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# in project root directory\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Complex Type Definitions Causing Performance Issues\nDESCRIPTION: The original type definitions that caused slow type-checking due to eager evaluation of all procedures in the router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2023-01-14-typescript-performance-lessons.mdx#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype DecorateProcedure<\n  TRouter extends AnyRouter,\n  TProcedure extends Procedure<any>,\n  TProcedure extends AnyQueryProcedure,\n> = {\n  /**\n   * @see https://tanstack.com/query/v4/docs/framework/react/guides/query-invalidation\n   */\n  invalidate(\n    input?: inferProcedureInput<TProcedure>,\n    filters?: InvalidateQueryFilters,\n    options?: InvalidateOptions,\n  ): Promise<void>;\n  // ... and so on for all the other React Query utilities\n};\n\nexport type DecoratedProcedureUtilsRecord<TRouter extends AnyRouter> =\n  OmitNeverKeys<{\n    [TKey in keyof TRouter['_def']['record']]: TRouter['_def']['record'][TKey] extends LegacyV9ProcedureTag\n      ? never\n      : TRouter['_def']['record'][TKey] extends AnyRouter\n        ? DecoratedProcedureUtilsRecord<TRouter['_def']['record'][TKey]>\n        : TRouter['_def']['record'][TKey] extends AnyQueryProcedure\n          ? DecorateProcedure<TRouter, TRouter['_def']['record'][TKey]>\n          : never;\n  }>;\n```\n\n----------------------------------------\n\nTITLE: Running the Development Server for Vercel OG + Next.js Project\nDESCRIPTION: This command runs the development server for the Vercel OG + Next.js project. It uses pnpm as the package manager to execute the dev script twice, which might be a typo or a specific project requirement.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/og-image/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev dev\n```\n\n----------------------------------------\n\nTITLE: Creating Express Server with tRPC Shield\nDESCRIPTION: Command to create a new Express server with tRPC Shield and Prisma integration using create-trpc-appx\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/example-apps.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-trpc-appx --example https://github.com/omar-dulaimi/trpc-shield/tree/master/example\n```\n\n----------------------------------------\n\nTITLE: Building and Running the Fastify Example in Production Mode\nDESCRIPTION: Commands to build the Fastify example and start it from the fresh build, suitable for production use.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/fastify-server/README.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn build\nyarn start\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic tRPC Query Procedure\nDESCRIPTION: Demonstrates how to create a simple tRPC router with a 'hello' query endpoint that takes an optional string input and returns a greeting object. This shows the server-side definition of a tRPC procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2021-05-05-hello-world.mdx#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nconst appRouter = trpc.router().query('hello', {\n  input: z.string().optional(),\n  resolve: ({ input }) => {\n    return {\n      text: `hello ${input ?? 'world'}`,\n    };\n  },\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Running TRPCClient Client in Deno\nDESCRIPTION: Command to start the client for a TRPCClient example in Deno. This should be run in a separate terminal after starting the server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/deno-deploy/README.md#2025-04-23_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\ndeno task client\n```\n\n----------------------------------------\n\nTITLE: Importing and Rendering Sponsors MDX Component\nDESCRIPTION: MDX configuration for importing and displaying sponsor content. Uses a content component from an unversioned directory to render the sponsor information.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/community/sponsors.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\n---\nid: sponsors\ntitle: Sponsors\nsidebar_label: Sponsors\nslug: /community/sponsors\n---\n\nimport Content from '@site/unversioned/_sponsors.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Installing WebSocket Dependencies for Fastify\nDESCRIPTION: Command to install the @fastify/websocket package, which is required for enabling WebSocket support in Fastify for tRPC subscriptions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fastify.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @fastify/websocket\n```\n\n----------------------------------------\n\nTITLE: SVG Logo Definition in HTML\nDESCRIPTION: SVG markup defining the tRPC logo with styling and path definitions. The SVG includes clip paths and styling for light/dark mode compatibility.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/introduction.mdx#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<svg width=\"429\" height=\"100\" viewBox=\"0 0 429 128\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" className=\"max-w-full\">\n    <g clip-path=\"url(#clip0_3_2)\">\n      <path d=\"M90.5 0H37.5C16.7893 0 0 16.7893 0 37.5V90.5C0 111.211 16.7893 128 37.5 128H90.5C111.211 128 128 111.211 128 90.5V37.5C128 16.7893 111.211 0 90.5 0Z\" fill=\"#398CCB\"/>\n      <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M63.8615 18.75L81.6307 29.002V34.639L103.138 47.0595V68.306L108.908 71.6365V92.152L91.15 102.404L83.2662 97.8445L64.098 108.912L45.0445 97.9085L37.2713 102.404L19.5135 92.1345V71.6365L25.0578 68.4358V47.0595L46.1038 34.9095L46.1155 34.909V29.002L63.8615 18.75ZM81.6307 39.9698V49.5058L63.873 59.7578L46.1155 49.5058V40.234L46.1038 40.2345L29.673 49.725V65.771L37.2713 61.3845L55.0288 71.6365V92.1345L49.6565 95.2413L64.098 103.581L78.6545 95.178L73.3922 92.1345V71.6365L91.15 61.3845L98.523 65.6413V49.725L81.6307 39.9698ZM78.0077 89.4923V76.9788L88.8422 83.2328V95.7463L78.0077 89.4923ZM104.292 76.9615L93.4577 83.2155V95.7463L104.292 89.475V76.9615ZM24.1289 89.475V76.9615L34.9635 83.2155V95.7288L24.1289 89.475ZM50.4135 76.9615L39.5788 83.2155V95.7288L50.4135 89.475V76.9615ZM80.3155 72.9808L91.15 66.727L101.984 72.9808L91.15 79.2405L80.3155 72.9808ZM37.2713 66.7095L26.4365 72.9808L37.2713 79.223L48.1058 72.9808L37.2713 66.7095ZM50.7308 46.8405V34.327L61.5537 40.5865V53.0943L50.7308 46.8405ZM77.0038 34.327L66.1807 40.5865V53.0885L77.0038 46.8405V34.327ZM53.0385 30.3345L63.8615 24.0808L74.6962 30.3345L63.8615 36.5885L53.0385 30.3345Z\" fill=\"white\"/>\n    </g>\n    <path class=\"fill-black dark:fill-white\" fill=\"currentFill\" d=\"M186.695 107.848C191.031 107.848 194.137 107.496 196.422 107.086V92.3203C195.25 92.4961 194.195 92.6133 192.555 92.6133C187.457 92.6133 184.996 90.5625 184.996 85.0547V57.9258H196.422V42.6914H184.996V27.9844H164.195V42.6914H155.523V57.9258H164.195V87.8672C164.195 102.281 171.227 107.848 186.695 107.848ZM201.641 106.5H223.145V77.3789H234.102L248.634 106.5H272.774L255.841 74.1562C264.63 70.3477 270.255 60.9727 270.255 50.1328V50.0156C270.255 32.0859 258.712 21.9492 238.263 21.9492H201.641V106.5ZM223.145 61.793V38.1797H235.743C243.302 38.1797 248.341 42.8672 248.341 49.957V50.0742C248.341 57.2227 243.477 61.793 235.86 61.793H223.145ZM276.295 106.5H297.798V81.7148H312.33C331.197 81.7148 343.384 70.1133 343.384 52.0078V51.8906C343.384 33.7852 331.197 21.9492 312.33 21.9492H276.295V106.5ZM307.173 38.4141C316.255 38.4141 321.646 43.1016 321.646 51.8906V52.0078C321.646 60.7969 316.255 65.543 307.173 65.543H297.798V38.4141H307.173ZM386.924 108.023C408.897 108.023 424.366 93.9023 425.127 74.9766L425.186 74.332H404.502L404.385 74.9766C402.92 84.4102 396.299 90.2109 386.983 90.2109C375.205 90.2109 367.705 80.4844 367.705 64.1367V64.0781C367.705 47.9062 375.147 38.2383 386.924 38.2383C396.768 38.2383 402.92 44.4492 404.268 53.2383L404.385 54.1172H425.069V53.5312C424.307 34.6055 409.014 20.4258 386.924 20.4258C361.67 20.4258 345.791 36.5391 345.791 64.1367V64.1953C345.791 91.793 361.553 108.023 386.924 108.023Z\" fill=\"white\"/>\n    <defs>\n      <clipPath id=\"clip0_3_2\">\n        <rect width=\"128\" height=\"128\" fill=\"white\"/>\n      </clipPath>\n    </defs>\n  </svg>\n```\n\n----------------------------------------\n\nTITLE: Installing edge-runtime Globally using yarn\nDESCRIPTION: This command installs the `edge-runtime` package globally using the Yarn package manager. The `global add` command ensures the package is installed system-wide, allowing the `edge-runtime` CLI to be used for local development and testing of Vercel Edge Functions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n```sh\nyarn global add edge-runtime\n```\n```\n\n----------------------------------------\n\nTITLE: Importing Contributing MDX Content in Documentation\nDESCRIPTION: MDX documentation page that defines metadata like ID, title and slug, then imports and renders a contributing guide content component.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/contributing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\n---\nid: contributing\ntitle: Contributing\nsidebar_label: Contributing\nslug: /contributing\n---\n\nimport Content from '@site/unversioned/_contributing.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Todo MVC example using bun\nDESCRIPTION: Command to create a new Next.js Todo MVC application with tRPC, SSG, and Prisma using bun.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\nbunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client for WebSocket Usage (TypeScript)\nDESCRIPTION: Demonstrates how to set up the tRPC client to use WebSocket transport for all operations. It creates a persistent WebSocket connection and configures the client with a WebSocket link.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/subscriptions.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client/links/httpBatchLink';\nimport { createWSClient, wsLink } from '@trpc/client/links/wsLink';\n\n// create persistent WebSocket connection\nconst wsClient = createWSClient({\n  url: `ws://localhost:3001`,\n});\n\n// configure TRPCClient to use WebSockets transport\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    wsLink({\n      client: wsClient,\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Importing GithubSponsorButton Component in JSX\nDESCRIPTION: Imports the GithubSponsorButton component from the site components directory to be used in the blog post for encouraging GitHub sponsorship.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2022-11-21-announcing-trpc-10.mdx#2025-04-23_snippet_0\n\nLANGUAGE: jsx\nCODE:\n```\nimport { GithubSponsorButton } from '@site/src/components/GithubSponsorButton';\n```\n\n----------------------------------------\n\nTITLE: Cloning Sign-In With Ethereum Authentication Example\nDESCRIPTION: Command to clone the repository containing a Sign-In With Ethereum Authentication example using tRPC and Express.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:codingwithmanny/trpc-siwe-monorepo.git\n```\n\n----------------------------------------\n\nTITLE: Importing Contributing Guidelines in MDX\nDESCRIPTION: MDX code that imports and renders contribution guidelines content from an unversioned file located at '@site/unversioned/_contributing.mdx'.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/community/contributing.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\nimport Content from '@site/unversioned/_contributing.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Cloning zART Stack Example\nDESCRIPTION: Command to clone the zART stack example repository featuring React Native, Next.js, and Prisma in a monorepo setup\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/example-apps.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ngit clone git@github.com:KATT/zart.git\n```\n\n----------------------------------------\n\nTITLE: Displaying Version Support Status Table in Markdown\nDESCRIPTION: A markdown table showing which tRPC versions are currently supported from a security perspective. Versions above 9.x.x are supported while versions below 9.0 are not supported.\nSOURCE: https://github.com/trpc/trpc/blob/main/SECURITY.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n| Version | Supported          |\n| ------- | ------------------ |\n| > 9.x.x | :white_check_mark: |\n| < 9.0   | :x:                |\n```\n\n----------------------------------------\n\nTITLE: Importing MDX Content for TRPC Testimonials Page\nDESCRIPTION: MDX configuration for testimonials page that imports content from an unversioned source file and sets up page metadata including ID, title, sidebar label and URL slug.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/community/love.mdx#2025-04-23_snippet_0\n\nLANGUAGE: mdx\nCODE:\n```\n---\nid: love\ntitle: Testimonials / Love\nsidebar_label: Testimonials\nslug: /community/love\n---\n\nimport Content from '@site/unversioned/_love.mdx';\n\n<Content />\n```\n\n----------------------------------------\n\nTITLE: Markdown Table of tRPC Projects\nDESCRIPTION: A markdown table listing various open-source projects that use tRPC, including project descriptions and GitHub repository links.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/community/awesome-trpc.mdx#2025-04-23_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n| Description                                                                                                                                  | Link                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------- |\n| [Cal.com](https://cal.com) - Scheduling infrastructure                                                                                       | https://github.com/calcom/cal.com                   |\n| [Skill Recordings](https://github.com/skillrecordings/products) - Hosting courses by Matt Pocock, Kent C Dodds, Dan Abramov, and many others | https://github.com/skillrecordings/products         |\n| [SST](https://sst.dev) - A framework that makes it easy to build serverless apps.                                                            | https://github.com/serverless-stack/sst             |\n| [Beam](https://planetscale.com/blog/introducing-beam) - A simple message board for your organization or project.                             | https://github.com/planetscale/beam                 |\n| [Rallly](https://rallly.co) - Self-hostable doodle poll alternative.                                                                         | https://github.com/lukevella/rallly                 |\n| [Hilde](http://hilde.gg) - Match-making app for games like foosball, air hockey and similar                                                  | https://github.com/nehalist/hilde                   |\n| [Answer Overflow](https://www.answeroverflow.com/) - Discord bot that indexes help channel content into Google                               | https://github.com/AnswerOverflow/AnswerOverflow    |\n| [Prisma Editor](https://prisma-editor.vercel.app/) - Powerful tool to visualize and edit Prisma Schema                                       | https://github.com/mohammed-bahumaish/prisma-editor |\n| [Saleor Apps](https://saleor.io/) - Official apps/integrations for Saleor Commerce                                                           | https://github.com/saleor/apps                      |\n| [Rao Pics App](https://github.com/rao-pics/rao-pics) - Visit Photo on any device. Supported MacOS/Windows                                    | https://github.com/rao-pics/rao-pics                |\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Protected Router Helper in tRPC with TypeScript\nDESCRIPTION: This TypeScript code defines a helper function `createProtectedRouter` intended for a file like 'server/createRouter.ts'. It creates a tRPC router instance pre-configured with an authorization middleware that checks for `ctx.user`. If the user exists, it refines the context type for downstream procedures by explicitly passing the non-nullable user; otherwise, it throws an 'UNAUTHORIZED' `TRPCError`. This promotes reusability for securing parts of an API.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/middlewares.md#2025-04-23_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { Context } from './context';\n\nexport function createProtectedRouter() {\n  return trpc.router<Context>().middleware(({ ctx, next }) => {\n    if (!ctx.user) {\n      throw new trpc.TRPCError({ code: 'UNAUTHORIZED' });\n    }\n    return next({\n      ctx: {\n        ...ctx,\n        // infers that `user` is non-nullable to downstream procedures\n        user: ctx.user,\n      },\n    });\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Custom Base Path for tRPC Requests in TypeScript\nDESCRIPTION: This snippet shows how to set up a custom base path for tRPC requests using the standalone adapter. It demonstrates handling requests under a specific path prefix.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/standalone.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\n\nconst handler = createHTTPHandler({\n  router: appRouter,\n  basePath: '/trpc/',\n});\n\ncreateServer((req, res) => {\n  if (req.url?.startsWith('/trpc/')) {\n    return handler(req, res);\n  }\n  // [... insert your custom logic here ...]\n\n  res.statusCode = 404;\n  res.end('Not Found');\n}).listen(3001);\n```\n\n----------------------------------------\n\nTITLE: Type Inference in tRPC v9\nDESCRIPTION: Example of complex type inference helpers in tRPC v9.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nexport type TQuery = keyof AppRouter['_def']['queries'];\nexport type InferQueryInput<TRouteKey extends TQuery> = inferProcedureInput<\n  AppRouter['_def']['queries'][TRouteKey]\n>;\ntype GreetingInput = InferQueryInput<'greeting'>;\n```\n\n----------------------------------------\n\nTITLE: Referencing tRPC Package Names\nDESCRIPTION: Code block showing the main tRPC package name and its related sub-packages that are covered by the test suite.\nSOURCE: https://github.com/trpc/trpc/blob/main/packages/tests/README.md#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n# @trpc/tests\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Handler in SolidStart\nDESCRIPTION: Configures tRPC request handling in a SolidStart application using the fetch adapter. Exports handler for both GET and POST methods.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { fetchRequestHandler } from '@trpc/server/adapters/fetch';\nimport type { APIEvent } from 'solid-start';\nimport { createContext } from '../../server/context';\nimport { appRouter } from '../../server/router';\n\nconst handler = (event: APIEvent) =>\n  fetchRequestHandler({\n    endpoint: '/api/trpc',\n    req: event.request,\n    router: appRouter,\n    createContext,\n  });\nexport { handler as GET, handler as POST };\n```\n\n----------------------------------------\n\nTITLE: Implementing Inner and Outer Context in tRPC\nDESCRIPTION: Demonstrates how to implement inner and outer context in tRPC. Inner context is used for database connections and testing, while outer context is used for request-dependent data like user sessions.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSessionFromCookie, type Session } from './auth';\n\n/**\n * Defines your inner context shape.\n * Add fields here that the inner context brings.\n */\ninterface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {\n  session: Session | null;\n}\n\n/**\n * Inner context. Will always be available in your procedures, in contrast to the outer context.\n *\n * Also useful for:\n * - testing, so you don't have to mock Next.js' `req`/`res`\n * - tRPC's `createServerSideHelpers` where we don't have `req`/`res`\n *\n * @see https://trpc.io/docs/context#inner-and-outer-context\n */\nexport async function createContextInner(opts?: CreateInnerContextOptions) {\n  return {\n    prisma,\n    session: opts.session,\n  };\n}\n\n/**\n * Outer context. Used in the routers and will e.g. bring `req` & `res` to the context as \"not `undefined`\".\n *\n * @see https://trpc.io/docs/context#inner-and-outer-context\n */\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = getSessionFromCookie(opts.req);\n\n  const contextInner = await createContextInner({ session });\n\n  return {\n    ...contextInner,\n    req: opts.req,\n    res: opts.res,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContextInner>>;\n\n// The usage in your router is the same as the example above.\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Queries in React Component\nDESCRIPTION: This code snippet shows how to use tRPC queries within a React component. It demonstrates fetching a post by ID and related posts, then rendering the results.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/rpc.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nexport function MyComponent() {\n  const post1 = trpc.useQuery(['postById', '1']);\n  const relatedPosts = trpc.useQuery(['relatedPosts', '1']);\n\n  return (\n    <pre>\n      {JSON.stringify(\n        {\n          post1: post1.data ?? null,\n          relatedPosts: relatedPosts.data ?? null,\n        },\n        null,\n        4,\n      )}\n    </pre>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Component with Abstract Router Types in TypeScript\nDESCRIPTION: This snippet shows how to create a generic component that uses abstract router types. It demonstrates type-safe usage of router procedures and utils in a reusable component that can work with different router instances.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/infer-types.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { MyRouterLike, MyRouterUtilsLike, trpc, useUtils } from './trpc';\n\ntype MyGenericComponentProps = {\n  route: MyRouterLike;\n  utils: MyRouterUtilsLike;\n};\n\nfunction MyGenericComponent(props: MyGenericComponentProps) {\n  const { route } = props;\n  const thing = route.listThings.useQuery({\n    filter: 'qwerty',\n  });\n\n  const mutation = route.doThing.useMutation({\n    onSuccess() {\n      props.utils.listThings.invalidate();\n    },\n  });\n\n  function handleClick() {\n    mutation.mutate({\n      name: 'Thing 1',\n    });\n  }\n\n  return; /* ui */\n}\n\nfunction MyPageComponent() {\n  const utils = useUtils();\n\n  return (\n    <MyGenericComponent\n      route={trpc.deep.route.things}\n      utils={utils.deep.route.things}\n    />\n  );\n}\n\nfunction MyOtherPageComponent() {\n  const utils = useUtils();\n\n  return (\n    <MyGenericComponent\n      route={trpc.different.things}\n      utils={utils.different.things}\n    />\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with HTTP Method Override (TypeScript)\nDESCRIPTION: Example of configuring the tRPC client to use a specific HTTP method for all queries and mutations. This overrides the default HTTP method mapping in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/further/rpc.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst client = createTRPCClient<AppRouter>({\n  links: [\n    httpLink({\n      url: `http://localhost:3000`,\n      methodOverride: 'POST', // all queries and mutations will be sent to the tRPC Server as POST requests.\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Reusable Middlewares with .concat() in tRPC\nDESCRIPTION: This snippet shows how to create a reusable plugin using the .concat() method. It demonstrates creating a plugin with its own context and meta types, and then using it in an application router.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\n\nexport function createMyPlugin() {\n  const t = initTRPC\n    .context<{\n      // the procedure using the plugin will need to extend this context\n    }>()\n    .meta<{\n      // the base `initTRPC`-object of the application using this needs to extend this meta\n    }>()\n    .create();\n\n  return {\n    pluginProc: t.procedure.use((opts) => {\n      return opts.next({\n        ctx: {\n          fromPlugin: 'hello from myPlugin' as const,\n        },\n      });\n    }),\n  };\n}\n\nconst t = initTRPC\n  .context<{\n    // ...\n  }>()\n  .create();\n\n\nexport const publicProcedure = t.procedure;\nexport const router = t.router;\n\nconst plugin = createMyPlugin();\n\nconst procedureWithPlugin = publicProcedure\n  .concat(\n    plugin.pluginProc,\n  )\n  .use(opts => {\n    const { ctx } = opts;\n    //      ^?\n    return opts.next()\n  })\n\n\nexport const appRouter = router({\n  hello: procedureWithPlugin.query(opts => {\n    return opts.ctx.fromPlugin;\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring tRPC Client with Caching for Next.js\nDESCRIPTION: Sets up tRPC client configuration with SSR and response caching for Next.js applications. Includes environment-aware URL configuration and cache control headers with stale-while-revalidate strategy.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/caching.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpBatchLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\nimport type { AppRouter } from '../server/routers/_app';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config(opts) {\n    if (typeof window !== 'undefined') {\n      return {\n        links: [\n          httpBatchLink({\n            url: '/api/trpc',\n          }),\n        ],\n      };\n    }\n\n    const url = process.env.VERCEL_URL\n      ? `https://${process.env.VERCEL_URL}/api/trpc`\n      : 'http://localhost:3000/api/trpc';\n\n    return {\n      links: {\n        http: httpBatchLink({\n          url,\n        }),\n      },\n    };\n  },\n  ssr: true,\n  responseMeta(opts) {\n    const { clientErrors } = opts;\n\n    if (clientErrors.length) {\n      return {\n        status: clientErrors[0].data?.httpStatus ?? 500,\n      };\n    }\n\n    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;\n    return {\n      headers: {\n        'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,\n      },\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Inner and Outer Context Implementation\nDESCRIPTION: Shows how to implement separated inner and outer context for different usage scenarios including testing and server-side operations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSessionFromCookie, type Session } from './auth';\n\ninterface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {\n  session: Session | null;\n}\n\nexport async function createContextInner(opts?: CreateInnerContextOptions) {\n  return {\n    prisma,\n    session: opts.session,\n  };\n}\n\nexport async function createContext(opts: CreateNextContextOptions) {\n  const session = getSessionFromCookie(opts.req);\n\n  const contextInner = await createContextInner({ session });\n\n  return {\n    ...contextInner,\n    req: opts.req,\n    res: opts.res,\n  };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContextInner>>;\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Router and Procedures in TypeScript\nDESCRIPTION: This snippet demonstrates how to set up a tRPC router with procedures for querying posts. It includes error handling and input validation using Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/suspense.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC, TRPCError } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst posts = [\n  { id: '1', title: 'everlong' },\n  { id: '2', title: 'After Dark' },\n];\n\nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure\n      .input(\n        z.object({\n          cursor: z.string().optional(),\n        })\n      )\n      .query(({ input }) => {\n        return {\n          posts,\n          nextCursor: '123' as string | undefined,\n        };\n      }),\n    byId: t.procedure\n      .input(\n        z.object({\n          id: z.string(),\n        })\n      )\n      .query(({ input }) => {\n        const post = posts.find(p => p.id === input.id);\n        if (!post) {\n          throw new TRPCError({\n            code: 'NOT_FOUND',\n          })\n        }\n        return post;\n     }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Server-Side Context Creation\nDESCRIPTION: Shows how to create context for server-side calls in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/context.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createContext } from './context';\nimport { createCaller } from './router';\n\nconst caller = createCaller(await createContext());\n```\n\n----------------------------------------\n\nTITLE: Creating Custom HTTP Server with tRPC Handler in TypeScript\nDESCRIPTION: This example demonstrates how to create a custom HTTP server using Node.js createServer function and integrate it with tRPC's createHTTPHandler. It allows for more flexibility in handling requests before passing them to the tRPC handler.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/standalone.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createServer } from 'http';\nimport { initTRPC } from '@trpc/server';\nimport { createHTTPHandler } from '@trpc/server/adapters/standalone';\n\nconst handler = createHTTPHandler({\n  router: appRouter,\n  createContext() {\n    return {};\n  },\n});\n\ncreateServer((req, res) => {\n  /**\n   * Handle the request however you like,\n   * just call the tRPC handler when you're ready\n   */\n\n  handler(req, res);\n}).listen(3333);\n```\n\n----------------------------------------\n\nTITLE: Creating Context for AWS Lambda with API Gateway Event\nDESCRIPTION: Example of creating a context function for AWS Lambda, demonstrating how to handle different API Gateway event versions (v1 and v2).\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/aws-lambda.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createContext({\n  event,\n  context,\n}: CreateAWSLambdaContextOptions<APIGatewayProxyEvent>) {\n  ...\n}\n\n// CreateAWSLambdaContextOptions<APIGatewayProxyEvent> or CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>\n```\n\n----------------------------------------\n\nTITLE: HTTP Batch Link Interface Definitions\nDESCRIPTION: TypeScript interface definitions for HTTPBatchLinkOptions and HTTPLinkOptions, detailing all available configuration options for the httpBatchLink.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nexport interface HTTPBatchLinkOptions extends HTTPLinkOptions {\n  /**\n   * Maximum length of HTTP URL allowed before operations are split into multiple requests\n   * @default Infinity\n   */\n  maxURLLength?: number;\n  /**\n   * Maximum number of operations allowed in a single batch request\n   * @default Infinity\n   */\n  maxItems?: number;\n}\n\nexport interface HTTPLinkOptions {\n  url: string;\n  /**\n   * Add ponyfill for fetch\n   */\n  fetch?: typeof fetch;\n  /**\n   * Add ponyfill for AbortController\n   */\n  AbortController?: typeof AbortController | null;\n  /**\n   * Data transformer\n   * @see https://trpc.io/docs/data-transformers\n   **/\n  transformer?: DataTransformerOptions;\n  /**\n   * Headers to be set on outgoing requests or a callback that of said headers\n   * @see http://trpc.io/docs/header\n   */\n  headers?:\n    | HTTPHeaders\n    | ((opts: { opList: Operation[] }) => HTTPHeaders | Promise<HTTPHeaders>);\n}\n```\n\n----------------------------------------\n\nTITLE: Input Merging with Middleware in tRPC\nDESCRIPTION: Shows how to stack multiple input validators and merge them using middleware. The example combines a base procedure with town name validation and adds additional name validation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst baseProcedure = t.procedure\n  .input(z.object({ townName: z.string() }))\n  .use((opts) => {\n    const input = opts.input;\n    console.log(`Handling request with user from: ${input.townName}`);\n    return opts.next();\n  });\n\nexport const appRouter = t.router({\n  hello: baseProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const input = opts.input;\n      return {\n        greeting: `Hello ${input.name}, my friend from ${input.townName}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Server with Greeting Procedure in TypeScript\nDESCRIPTION: This snippet sets up a tRPC server with a single 'greeting' procedure. It uses Zod for input validation and demonstrates how to create a typed router that can be exported for client use.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/landing-intro/Step3.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @target: esnext\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport z from 'zod';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  greeting: t.procedure\n    .input(z.object({ name: z.string() }))\n    .query((opts) => {\n      const { input } = opts;\n      return `Hello ${input.name}` as const;\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Inferring Input and Output Types from tRPC Router in TypeScript\nDESCRIPTION: This snippet shows how to use tRPC's utility types to infer input and output types from the AppRouter. It specifically demonstrates inferring types for the post.create procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/infer-types.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// @filename: client.ts\nimport type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';\nimport type { AppRouter } from './server';\n\ntype RouterInput = inferRouterInputs<AppRouter>;\ntype RouterOutput = inferRouterOutputs<AppRouter>;\n\ntype PostCreateInput = RouterInput['post']['create'];\n//   ^?\ntype PostCreateOutput = RouterOutput['post']['create'];\n//   ^?\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Backend\nDESCRIPTION: Sets up the tRPC backend with a cached context creation function and exports helper functions for router and procedure creation.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/server-components.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { cache } from 'react';\n\nexport const createTRPCContext = cache(async () => {\n  /**\n   * @see: https://trpc.io/docs/server/context\n   */\n  return { userId: 'user_123' };\n});\n\n// Avoid exporting the entire t-object\n// since it's not very descriptive.\n// For instance, the use of a t variable\n// is common in i18n libraries.\nconst t = initTRPC.create({\n  /**\n   * @see https://trpc.io/docs/server/data-transformers\n   */\n  // transformer: superjson,\n});\n\n// Base router and procedure helpers\nexport const createTRPCRouter = t.router;\nexport const createCallerFactory = t.createCallerFactory;\nexport const baseProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Using Suspense Query with tRPC in Next.js Client Component\nDESCRIPTION: This snippet demonstrates how to use the useSuspenseQuery hook from React Query with tRPC in a Next.js client component. It shows how to fetch and display data without manual loading state handling.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/server-components.mdx#2025-04-23_snippet_11\n\nLANGUAGE: tsx\nCODE:\n```\n'use client';\n\nimport { useSuspenseQuery } from '@tanstack/react-query';\nimport { trpc } from '~/trpc/client';\n\nexport function ClientGreeting() {\n  const trpc = useTRPC();\n  const [data] = useSuspenseQuery(trpc.hello.queryOptions());\n  return <div>{data.greeting}</div>;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Express Adapter\nDESCRIPTION: Sets up the Express adapter with tRPC router integration, including context creation and middleware configuration. Demonstrates how to expose tRPC endpoints through Express HTTP server.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/express.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport * as trpcExpress from '@trpc/server/adapters/express';\nimport express from 'express';\n\n// created for each request\nconst createContext = ({\n  req,\n  res,\n}: trpcExpress.CreateExpressContextOptions) => ({}); // no context\ntype Context = Awaited<ReturnType<typeof createContext>>;\n\nconst t = initTRPC.context<Context>().create();\nconst appRouter = t.router({\n  // [...]\n});\n\nconst app = express();\n\napp.use(\n  '/trpc',\n  trpcExpress.createExpressMiddleware({\n    router: appRouter,\n    createContext,\n  }),\n);\n\napp.listen(4000);\n```\n\n----------------------------------------\n\nTITLE: Basic Input Validation with Zod in tRPC\nDESCRIPTION: Demonstrates how to implement basic input validation for a tRPC procedure using Zod schema validation. The example shows validation for a 'hello' query that requires a name parameter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/validators.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// Our examples use Zod by default, but usage with other libraries is identical\nimport { z } from 'zod';\n\nexport const t = initTRPC.create();\nconst publicProcedure = t.procedure;\n\nexport const appRouter = t.router({\n  hello: publicProcedure\n    .input(\n      z.object({\n        name: z.string(),\n      }),\n    )\n    .query((opts) => {\n      const name = opts.input.name;\n      return {\n        greeting: `Hello ${opts.input.name}`,\n      };\n    }),\n});\n```\n\n----------------------------------------\n\nTITLE: Implementing Context Extension Middleware in tRPC\nDESCRIPTION: This snippet demonstrates how to use context extension in a middleware to add typesafe properties to the context. It creates a protectedProcedure that ensures the user is authenticated before proceeding.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/middlewares.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype Context = {\n  // user is nullable\n  user?: {\n    id: string;\n  };\n};\n\nconst protectedProcedure = publicProcedure.use(async function isAuthed(opts) {\n  const { ctx } = opts;\n  // `ctx.user` is nullable\n  if (!ctx.user) {\n    //     ^?\n    throw new TRPCError({ code: 'UNAUTHORIZED' });\n  }\n\n  return opts.next({\n    ctx: {\n      // ✅ user value is known to be non-null now\n      user: ctx.user,\n      // ^?\n    },\n  });\n});\n\nprotectedProcedure.query(({ ctx }) => ctx.user);\n//                                        ^?\n```\n\n----------------------------------------\n\nTITLE: Defining tRPC Server Router with Post Queries\nDESCRIPTION: Server-side code that defines a tRPC router with post procedures for fetching all posts and serving as the foundation for the examples.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/useUtils.mdx#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// @include: server\n// @target: esnext\n\n// @filename: server.ts\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    all: t.procedure.query(() => {\n      return {\n        posts: [\n          { id: 1, title: 'everlong' },\n          { id: 2, title: 'After Dark' },\n        ],\n      };\n    }),\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Implementing tRPC Router with TypeScript\nDESCRIPTION: Implementation of a basic tRPC router with user management functionality including queries and mutations.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fastify.md#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\ntype User = {\n  id: string;\n  name: string;\n  bio?: string;\n};\n\nconst users: Record<string, User> = {};\n\nexport const t = initTRPC.create();\n\nexport const appRouter = t.router({\n  getUserById: t.procedure.input(z.string()).query((opts) => {\n    return users[opts.input]; // input type is string\n  }),\n  createUser: t.procedure\n    .input(\n      z.object({\n        name: z.string().min(3),\n        bio: z.string().max(142).optional(),\n      }),\n    )\n    .mutation((opts) => {\n      const id = Date.now().toString();\n      const user: User = { id, ...opts.input };\n      users[user.id] = user;\n      return user;\n    }),\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Creating Context for Server-Side Calls in tRPC\nDESCRIPTION: Demonstrates how to create context for server-side calls in tRPC. The createContext function is awaited and passed to createCaller.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createContext } from './context';\nimport { createCaller } from './router';\n\nconst caller = createCaller(await createContext());\n```\n\n----------------------------------------\n\nTITLE: Installing Polyfills for tRPC HTTP Subscription Link in React Native\nDESCRIPTION: This snippet shows how to add the necessary polyfills to a React Native project for using tRPC's HTTP subscription link. It imports and sets up polyfills for AsyncIterator, EventSource, and Web Streams.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpSubscriptionLink.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport '@azure/core-asynciterator-polyfill';\nimport { RNEventSource } from 'rn-eventsource-reborn';\nimport { ReadableStream, TransformStream } from 'web-streams-polyfill';\n\nglobalThis.ReadableStream = globalThis.ReadableStream || ReadableStream;\nglobalThis.TransformStream = globalThis.TransformStream || TransformStream;\n```\n\n----------------------------------------\n\nTITLE: Configuring httpLink in tRPC Client for Next.js\nDESCRIPTION: This code example shows how to configure the tRPC client with httpLink instead of httpBatchLink when using tRPC with Next.js. It demonstrates the setup within a Next.js-specific tRPC configuration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/links/httpBatchLink.md#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '@/server/routers/app';\nimport { httpLink } from '@trpc/client';\nimport { createTRPCNext } from '@trpc/next';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      links: [\n        httpLink({\n          url: '/api/trpc',\n        }),\n      ],\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Global Request Abortion in tRPC Next.js Client\nDESCRIPTION: Demonstrates how to configure global abort-on-unmount behavior for all tRPC requests in a Next.js application. This is done through the createTRPCNext configuration object by setting abortOnUnmount to true.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/nextjs/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCNext } from '@trpc/next';\n\nexport const trpc = createTRPCNext<AppRouter>({\n  config() {\n    return {\n      // ...\n      abortOnUnmount: true,\n    };\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining a Protected Server Action with Input Validation\nDESCRIPTION: This snippet demonstrates how to create a protected server action using tRPC. It includes input validation using Zod and utilizes the previously defined protectedAction procedure.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/blog/2024-05-23-trpc-actions.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n'use server';\n\nimport { z } from 'zod';\nimport { protectedAction } from '../server/trpc';\n\nexport const createPost = protectedAction\n  .input(\n    z.object({\n      title: z.string(),\n    }),\n  )\n  .mutation(async ({ ctx, input }) => {\n    // Do something with the input\n  });\n\n// Since we're using the `experimental_caller`,\n// our procedure is now just an ordinary function:\ncreatePost;\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Context with Fastify\nDESCRIPTION: Implementation of request context creation for tRPC with Fastify, handling user authentication from headers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fastify.md#2025-04-23_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';\n\nexport function createContext({ req, res }: CreateFastifyContextOptions) {\n  const user = { name: req.headers.username ?? 'anonymous' };\n\n  return { req, res, user };\n}\n\nexport type Context = Awaited<ReturnType<typeof createContext>>;\n```\n\n----------------------------------------\n\nTITLE: Installing edge-runtime Globally using pnpm\nDESCRIPTION: This command installs the `edge-runtime` package globally using the pnpm package manager. The `add -g` command performs a global installation, making the `edge-runtime` executable available in the system's PATH for running Vercel Edge Functions locally.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/adapters/fetch.mdx#2025-04-23_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\n```sh\npnpm add -g edge-runtime\n```\n```\n\n----------------------------------------\n\nTITLE: Complete tRPC Server Setup\nDESCRIPTION: Full example of tRPC server setup with data transformer, OpenAPI metadata, and error formatter.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/migration/migrate-from-v9-to-v10.mdx#2025-04-23_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport superjson from 'superjson';\n\ninterface Context {\n  user?: {\n    id: string;\n    name: string;\n  };\n}\n\ninterface Meta {\n  openapi: {\n    enabled: boolean;\n    method: string;\n    path: string;\n  };\n}\n\nexport const t = initTRPC\n  .context<Context>()\n  .meta<Meta>()\n  .create({\n    errorFormatter({ shape, error }) {\n      return {\n        ...shape,\n        data: {\n          ...shape.data,\n          zodError:\n            error.code === 'BAD_REQUEST' && error.cause instanceof ZodError\n              ? error.cause.flatten()\n              : null,\n        },\n      };\n    },\n    transformer: superjson,\n  });\n```\n\n----------------------------------------\n\nTITLE: Querying User Data with tRPC Vanilla Client in TypeScript\nDESCRIPTION: This snippet demonstrates how to use the tRPC Vanilla client to query user data from an API. It imports the AppRouter type and uses the client to call the 'getUser' procedure with a user ID, returning user information.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/vanilla/introduction.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { AppRouter } from '../path/to/server/trpc';\n\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\n```\n\n----------------------------------------\n\nTITLE: Default Error Shape Type Definition\nDESCRIPTION: Defines the default error shape types used in tRPC error handling, including error data structure with code, HTTP status, path, and stack trace information.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/error-formatting.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype DefaultErrorData = {\n  code: TRPC_ERROR_CODE_KEY;\n  httpStatus: number;\n  /**\n   * Path to the procedure that threw the error\n   */\n  path?: string;\n  /**\n   * Stack trace of the error (only in development)\n   */\n  stack?: string;\n};\n\ninterface DefaultErrorShape {\n  message: string;\n  code: TRPC_ERROR_CODE_NUMBER;\n  data: DefaultErrorData;\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring CORS and Cookies in tRPC Client\nDESCRIPTION: Demonstrates how to set up a tRPC client proxy with CORS and cookie support using httpBatchLink. The configuration enables cross-origin requests with credential inclusion for cookie transmission.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/cors.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createTRPCProxyClient, httpBatchLink } from '@trpc/client';\n\nconst client = createTRPCProxyClient<AppRouter>({\n  links: [\n    httpBatchLink({\n      url: 'YOUR_SERVER_URL',\n      fetch(url, options) {\n        return fetch(url, {\n          ...options,\n          credentials: 'include',\n        });\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Mutation Example with Router Caller\nDESCRIPTION: Demonstrates implementing a mutation procedure with router caller. Shows how to modify server-side state and return updated data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/server-side-calls.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from 'zod';\n\nconst posts = ['One', 'Two', 'Three'];\n\nconst t = initTRPC.create();\nconst router = t.router({\n  post: t.router({\n    add: t.procedure.input(z.string()).mutation((opts) => {\n      posts.push(opts.input);\n      return posts;\n    }),\n  }),\n});\n\nconst caller = router.createCaller({});\nconst result = await caller.post.add('Four');\n```\n\n----------------------------------------\n\nTITLE: Creating tRPC Hooks in Next.js\nDESCRIPTION: This TypeScript code creates strongly-typed hooks for tRPC in a Next.js project. It imports the AppRouter type and uses createReactQueryHooks to generate the hooks.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/introduction.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createReactQueryHooks } from '@trpc/react';\nimport type { AppRouter } from '../pages/api/trpc/[trpc]';\n\nexport const trpc = createReactQueryHooks<AppRouter>();\n// => { useQuery: ..., useMutation: ...}\n```\n\n----------------------------------------\n\nTITLE: Using tRPC Client for API Calls\nDESCRIPTION: Demonstrates how to use the configured tRPC client to make type-safe API calls, including both queries and mutations with proper typing.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/vanilla/setup.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst bilbo = await client.getUser.query('id_bilbo');\n// => { id: 'id_bilbo', name: 'Bilbo' };\n\nconst frodo = await client.createUser.mutate({ name: 'Frodo' });\n// => { id: 'id_frodo', name: 'Frodo' };\n```\n\n----------------------------------------\n\nTITLE: Exporting Router Types to Server\nDESCRIPTION: Demonstrates how to export router types from the server to make them available for client-side usage. This ensures type consistency between server and client.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/infer-types.md#2025-04-23_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// @module: esnext\n// @include: server\n// @noErrors\n// ---cut---\n\nexport type AppRouter = typeof appRouter;\n\n// Export your MyRouter types to the client\nexport type { MyRouterLike, MyRouterUtilsLike } from './factory';\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC Router with Post Query Endpoint\nDESCRIPTION: Sets up a basic tRPC router with a post query endpoint that accepts an ID parameter and returns post data.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/react/aborting-procedures.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\nimport { z } from \"zod\";\nconst t = initTRPC.create();\n\nconst appRouter = t.router({\n  post: t.router({\n    byId: t.procedure\n      .input(z.object({ id: z.string() }))\n      .query(async ({input}) => {\n        return { id: input.id, title: 'Hello' };\n      }),\n  })\n});\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Initializing TRPC HTTP Server in TypeScript\nDESCRIPTION: Creates an HTTP server instance using TRPC's createHTTPServer utility and starts it listening on port 3000. The server is configured with an appRouter that defines the API endpoints and their handlers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/landing-intro/Step2.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst { listen } = createHTTPServer({\n  router: appRouter,\n});\n\n// The API will now be listening on port 3000!\nlisten(3000);\n```\n\n----------------------------------------\n\nTITLE: Nested Promise Data Example in TypeScript\nDESCRIPTION: Demonstrates how to embed promises in nested data when using httpBatchStreamLink, allowing for mixed synchronous and asynchronous data returns.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/migration/migrate-from-v10-to-v11.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst router = router({\n  embedPromise: publicProcedure.query(() => {\n    async function slowThing() {\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      return 'slow';\n    }\n    return {\n      instant: 'instant',\n      slow: slowThing(),\n    };\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js starter with Prisma using npm\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, E2E testing, and ESLint using npm. This is the recommended starter for tRPC projects.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/main/example-apps.mdx#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Split Link Type Definition\nDESCRIPTION: Type definition for the splitLink function showing its parameters and return type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/splitLink.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {\n  condition: (op: Operation) => boolean;\n  /**\n   * The link to execute next if the test function returns `true`.\n   */\n  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n  /**\n   * The link to execute next if the test function returns `false`.\n   */\n  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];\n}) => TRPCLink<TRouter>\n```\n\n----------------------------------------\n\nTITLE: Initializing tRPC in TypeScript\nDESCRIPTION: Demonstrates how to initialize tRPC and export the router and publicProcedure. This should be done once per application to avoid issues with multiple instances.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/routers.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { initTRPC } from '@trpc/server';\n\n// You can use any variable name you like.\n// We use t to keep things simple.\nconst t = initTRPC.create();\n\nexport const router = t.router;\nexport const publicProcedure = t.procedure;\n```\n\n----------------------------------------\n\nTITLE: Defining useQuery Hook Signature in TypeScript\nDESCRIPTION: This snippet shows the TypeScript definition of the useQuery hook and its options interface. It extends the UseQueryOptions from react-query and adds tRPC-specific options.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/client/react/useQuery.md#2025-04-23_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nfunction useQuery(\n  input: TInput,\n  opts?: UseTRPCQueryOptions;\n)\n\ninterface UseTRPCQueryOptions\n  extends UseQueryOptions {\n  trpc: {\n    ssr?: boolean;\n    abortOnUnmount?: boolean;\n    context?: Record<string, unknown>;\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Next.js Prisma WebSockets Starter\nDESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, and WebSockets support using create-next-app\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/main/example-apps.md#2025-04-23_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter\n```\n\n----------------------------------------\n\nTITLE: Adding Canonical Link for SEO in HTML Head\nDESCRIPTION: This HTML snippet adds a canonical link to the page's head section, pointing to the official tRPC.io awesome page for search engine optimization purposes.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/community/awesome-trpc.mdx#2025-04-23_snippet_1\n\nLANGUAGE: html\nCODE:\n```\n<head>\n  <link rel=\"canonical\" href=\"https://trpc.io/awesome\" />\n</head>\n```\n\n----------------------------------------\n\nTITLE: Installing and Setting Up TodoMVC with tRPC\nDESCRIPTION: Commands to create a new Next.js project with tRPC TodoMVC example, install dependencies, and start the development server.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-todomvc/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\ncd trpc-todo\npnpm\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Installing SuperJSON and Devalue for Different Upload/Download Transformers\nDESCRIPTION: Command to install SuperJSON and Devalue packages for implementing different transformers for upload and download in tRPC.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/data-transformers.md#2025-04-23_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\nyarn add superjson devalue\n```\n\n----------------------------------------\n\nTITLE: Configuring Basic HTTP Link in tRPC Client\nDESCRIPTION: Basic setup for tRPC client using httpLink that natively supports non-JSON content types.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/non-json-content-types.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpLink } from '@trpc/client';\n\ntrpc.createClient({\n  links: [\n    httpLink({\n      url: 'http://localhost:2022',\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Todo MVC example using yarn\nDESCRIPTION: Command to create a new Next.js Todo MVC application with tRPC, SSG, and Prisma using yarn.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/main/example-apps.mdx#2025-04-23_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo\n```\n\n----------------------------------------\n\nTITLE: Installing Next.js Prisma Starter with create-next-app\nDESCRIPTION: Command to create a new Next.js project with tRPC and Prisma integration, including E2E testing and ESLint configuration\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/nextjs/starter-projects.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter\n```\n\n----------------------------------------\n\nTITLE: Infinite Query Options Setup\nDESCRIPTION: Shows how to configure infinite query options for cursor-based pagination.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/tanstack-react-query/usage.mdx#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst infiniteQueryOptions = trpc.path.to.query.infiniteQueryOptions(\n  {\n    /** input */\n  },\n  {\n    // Any Tanstack React Query options\n    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,\n  },\n);\n```\n\n----------------------------------------\n\nTITLE: Running Development Tools for TodoMVC\nDESCRIPTION: Command to run Prisma Studio and Next.js development server simultaneously for the TodoMVC project.\nSOURCE: https://github.com/trpc/trpc/blob/main/examples/next-prisma-todomvc/README.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npnpm dx # runs prisma studio + next\n```\n\n----------------------------------------\n\nTITLE: Disabling Server-Side Request Batching\nDESCRIPTION: Configuration for disabling request batching on the server side using createHTTPServer.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/httpBatchLink.md#2025-04-23_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHTTPServer } from '@trpc/server/adapters/standalone';\n\ncreateHTTPServer({\n  // [...]\n  // 👇 disable batching\n  allowBatching: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC and Zod Dependencies using Yarn\nDESCRIPTION: This command uses the Yarn package manager to install the core tRPC server library (`@trpc/server`) and the Zod library (`zod`) for schema validation. These are necessary dependencies for setting up a tRPC server and defining input validation for procedures.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/express.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server zod\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Server Dependencies\nDESCRIPTION: Command to install the required tRPC server package using yarn package manager.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/server/aws-lambda.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Fastify Dependencies\nDESCRIPTION: Commands for installing the required dependencies for tRPC with Fastify integration.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fastify.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server fastify zod\n```\n\n----------------------------------------\n\nTITLE: Installing tRPC Dependencies\nDESCRIPTION: Commands for installing required tRPC packages and Zod for type validation\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/express.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nyarn add @trpc/server zod\n```\n\n----------------------------------------\n\nTITLE: Markdown Documentation Structure for tRPC Resources\nDESCRIPTION: A structured markdown document that organizes tRPC resources into categories including extensions, frontend frameworks, bootstrappers, library adapters, and example projects. Each entry includes a description and corresponding link.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/community/awesome-trpc.mdx#2025-04-23_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n---\nid: awesome-trpc\ntitle: Awesome tRPC Collection\nsidebar_label: Awesome tRPC Collection\nslug: /community/awesome-trpc\n---\n\nA collection of resources on tRPC.\n\n**Please** edit this page and add your own links! 🙏\n\n## 🧩 Extensions & community add-ons\n\n### Extensions\n\n| Description                                                                    | Link                                                 |\n| ------------------------------------------------------------------------------ | ---------------------------------------------------- |\n| tRPC panel automatically generates a UI for manually testing your tRPC backend | https://github.com/iway1/trpc-panel                  |\n| tRPC-OpenAPI - OpenAPI & REST support for your tRPC routers                    | https://github.com/jlalmes/trpc-openapi              |\n[...truncated for brevity...]\n```\n\n----------------------------------------\n\nTITLE: Installing Edge Runtime Dependencies\nDESCRIPTION: Commands for installing the Vercel Edge Runtime globally using different package managers.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/server/adapters/fetch.mdx#2025-04-23_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\nnpm install -g edge-runtime\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn global add edge-runtime\n```\n\nLANGUAGE: shell\nCODE:\n```\npnpm add -g edge-runtime\n```\n\nLANGUAGE: shell\nCODE:\n```\nbun add -g edge-runtime\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeScript Strict Mode\nDESCRIPTION: TypeScript configuration to enable strict mode for better type safety when using Zod.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/reactjs/introduction.md#2025-04-23_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"strict\": true\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Installing WebSocket Dependencies (Bash)\nDESCRIPTION: Command to install the 'ws' package for WebSocket functionality.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-9.x/further/subscriptions.md#2025-04-23_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nyarn add ws\n```\n\n----------------------------------------\n\nTITLE: Merging Routers with t.mergeRouters in tRPC\nDESCRIPTION: This snippet shows how to merge routers using t.mergeRouters in tRPC. It demonstrates flattening all procedures into a single namespace.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/merging-routers.md#2025-04-23_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { router, publicProcedure, mergeRouters } from '../trpc';\nimport { z } from 'zod';\n\nimport { userRouter } from './user';\nimport { postRouter } from './post';\n\nconst appRouter = mergeRouters(userRouter, postRouter)\n\nexport type AppRouter = typeof appRouter;\n```\n\n----------------------------------------\n\nTITLE: Executing Non-Batched Query\nDESCRIPTION: Shows how to perform a tRPC query with batching disabled by setting the skipBatch context property.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/docs/client/links/splitLink.mdx#2025-04-23_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst postResult = proxy.posts.query(null, {\n  context: {\n    skipBatch: true,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Starting the Development Server for Vercel OG + Next.js Project\nDESCRIPTION: This command starts the development server for the Vercel OG + Next.js project. It uses pnpm as the package manager to run the dev script defined in the project's package.json file.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/og-image/README.md#2025-04-23_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npnpm dev\n```\n\n----------------------------------------\n\nTITLE: Defining Context Types in tRPC\nDESCRIPTION: Demonstrates how to define context types when initializing tRPC using initTRPC. It shows two methods: inferring the type from a function's return type and explicitly defining the type.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/versioned_docs/version-10.x/server/context.md#2025-04-23_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as trpc from '@trpc/server';\nimport { initTRPC } from '@trpc/server';\nimport type { CreateNextContextOptions } from '@trpc/server/adapters/next';\nimport { getSession } from 'next-auth/react';\n\nexport const createContext = async (opts: CreateNextContextOptions) => {\n  const session = await getSession({ req: opts.req });\n\n  return {\n    session,\n  };\n};\n\nconst t1 = initTRPC.context<typeof createContext>().create();\nt1.procedure.use(({ ctx }) => { ... });\n\ntype Context = Awaited<ReturnType<typeof createContext>>;\nconst t2 = initTRPC.context<Context>().create();\nt2.procedure.use(({ ctx }) => { ... });\n```\n\n----------------------------------------\n\nTITLE: Setting Canonical URL in HTML Head\nDESCRIPTION: This HTML snippet sets the canonical URL for the sponsors page, ensuring search engines understand the preferred version of the page.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/unversioned/_sponsors.mdx#2025-04-23_snippet_0\n\nLANGUAGE: html\nCODE:\n```\n<head>\n  <link rel=\"canonical\" href=\"https://trpc.io/docs/sponsors\" />\n</head>\n```\n\n----------------------------------------\n\nTITLE: Importing GithubSponsorButton Component in React\nDESCRIPTION: This JavaScript import statement brings in a custom React component for displaying a GitHub Sponsor button, likely used to encourage sponsorship.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/unversioned/_sponsors.mdx#2025-04-23_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { GithubSponsorButton } from '@site/src/components/GithubSponsorButton';\n```\n\n----------------------------------------\n\nTITLE: Rendering GithubSponsorButton Component in JSX\nDESCRIPTION: This JSX code renders the imported GithubSponsorButton component, which likely displays a button for sponsoring the project on GitHub.\nSOURCE: https://github.com/trpc/trpc/blob/main/www/unversioned/_sponsors.mdx#2025-04-23_snippet_2\n\nLANGUAGE: jsx\nCODE:\n```\n<GithubSponsorButton />\n```"
  }
]