[
  {
    "owner": "pydantic",
    "repo": "pydantic",
    "content": "TITLE: Generating JSON Schema from a BaseModel\nDESCRIPTION: Example demonstrating how to generate JSON schema from a Pydantic BaseModel with various field types including enums, unions, and field customizations. The example shows the structure of the generated schema and how to convert it to a JSON string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom enum import Enum\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.config import ConfigDict\n\n\nclass FooBar(BaseModel):\n    count: int\n    size: Union[float, None] = None\n\n\nclass Gender(str, Enum):\n    male = 'male'\n    female = 'female'\n    other = 'other'\n    not_given = 'not_given'\n\n\nclass MainModel(BaseModel):\n    \"\"\"\n    This is the description of the main model\n    \"\"\"\n\n    model_config = ConfigDict(title='Main')\n\n    foo_bar: FooBar\n    gender: Annotated[Union[Gender, None], Field(alias='Gender')] = None\n    snap: int = Field(\n        default=42,\n        title='The Snap',\n        description='this is the value of snap',\n        gt=30,\n        lt=50,\n    )\n\n\nmain_model_schema = MainModel.model_json_schema()  # (1)!\nprint(json.dumps(main_model_schema, indent=2))  # (2)!\n\"\"\"\n{\n  \"$defs\": {\n    \"FooBar\": {\n      \"properties\": {\n        \"count\": {\n          \"title\": \"Count\",\n          \"type\": \"integer\"\n        },\n        \"size\": {\n          \"anyOf\": [\n            {\n              \"type\": \"number\"\n            },\n            {\n              \"type\": \"null\"\n            }\n          ],\n          \"default\": null,\n          \"title\": \"Size\"\n        }\n      },\n      \"required\": [\n        \"count\"\n      ],\n      \"title\": \"FooBar\",\n      \"type\": \"object\"\n    },\n    \"Gender\": {\n      \"enum\": [\n        \"male\",\n        \"female\",\n        \"other\",\n        \"not_given\"\n      ],\n      \"title\": \"Gender\",\n      \"type\": \"string\"\n    }\n  },\n  \"description\": \"This is the description of the main model\",\n  \"properties\": {\n    \"foo_bar\": {\n      \"$ref\": \"#/$defs/FooBar\"\n    },\n    \"Gender\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/Gender\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ],\n      \"default\": null\n    },\n    \"snap\": {\n      \"default\": 42,\n      \"description\": \"this is the value of snap\",\n      \"exclusiveMaximum\": 50,\n      \"exclusiveMinimum\": 30,\n      \"title\": \"The Snap\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"foo_bar\"\n  ],\n  \"title\": \"Main\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Types with Annotated Pattern in Python\nDESCRIPTION: Demonstrates how to create a reusable custom data type (PositiveInt) using the annotated pattern with Pydantic. The example validates that integers are greater than zero.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, TypeAdapter, ValidationError\n\nPositiveInt = Annotated[int, Field(gt=0)]  # (1)!\n\nta = TypeAdapter(PositiveInt)\n\nprint(ta.validate_python(1))\n#> 1\n\ntry:\n    ta.validate_python(-1)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for constrained-int\n      Input should be greater than 0 [type=greater_than, input_value=-1, input_type=int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Annotated pattern to add constraints to nested types\nDESCRIPTION: Shows how to add validation constraints to elements of a collection type using the Annotated pattern.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    int_list: list[Annotated[int, Field(gt=0)]]\n    # Valid: [1, 3]\n    # Invalid: [-1, 2]\n```\n\n----------------------------------------\n\nTITLE: Accessing Validated Data in Field Validators with Python\nDESCRIPTION: Demonstrates how to access already validated data in field validators using the ValidationInfo.data property. This example shows a password confirmation validator that checks if password_repeat matches the password field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass UserModel(BaseModel):\n    password: str\n    password_repeat: str\n    username: str\n\n    @field_validator('password_repeat', mode='after')\n    @classmethod\n    def check_passwords_match(cls, value: str, info: ValidationInfo) -> str:\n        if value != info.data['password']:\n            raise ValueError('Passwords do not match')\n        return value\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of validate_call Decorator in Python\nDESCRIPTION: Demonstrates how to use the validate_call decorator to parse and validate function arguments using type annotations, including type coercion and validation error handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat('x', '4', separator=b' ')\nprint(b)\n#> b'x x x x'\n\ntry:\n    c = repeat('hello', 'wrong')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for repeat\n    1\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating a Reusable Type with Validators Using the Annotated Pattern in Python\nDESCRIPTION: This code snippet demonstrates creating a reusable custom type with validators using Pydantic's Annotated pattern. It defines an EvenNumber type that validates input values are even integers, then uses it in multiple model classes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value\n\n\nEvenNumber = Annotated[int, AfterValidator(is_even)]\n\n\nclass Model1(BaseModel):\n    my_number: EvenNumber\n\n\nclass Model2(BaseModel):\n    other_number: Annotated[EvenNumber, AfterValidator(lambda v: v + 2)]\n\n\nclass Model3(BaseModel):\n    list_of_even_numbers: list[EvenNumber]  # (1)!\n```\n\n----------------------------------------\n\nTITLE: Validating Data with Pydantic Model Methods in Python\nDESCRIPTION: Demonstrates the three main validation methods in Pydantic: model_validate() for dictionary data, model_validate_json() for JSON strings, and model_validate_strings() for string value dictionaries. The example shows successful validation as well as handling validation errors for each method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nm = User.model_validate({'id': 123, 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    User.model_validate(['not', 'a', 'dict'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]\n    \"\"\"\n\nm = User.model_validate_json('{\"id\": 123, \"name\": \"James\"}')\nprint(m)\n#> id=123 name='James' signup_ts=None\n\ntry:\n    m = User.model_validate_json('{\"id\": 123, \"name\": 123}')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Input should be a valid string [type=string_type, input_value=123, input_type=int]\n    \"\"\"\n\ntry:\n    m = User.model_validate_json('invalid JSON')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]\n    \"\"\"\n\nm = User.model_validate_strings({'id': '123', 'name': 'James'})\nprint(m)\n#> id=123 name='James' signup_ts=None\n\nm = User.model_validate_strings(\n    {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01T12:00:00'}\n)\nprint(m)\n#> id=123 name='James' signup_ts=datetime.datetime(2024, 4, 1, 12, 0)\n\ntry:\n    m = User.model_validate_strings(\n        {'id': '123', 'name': 'James', 'signup_ts': '2024-04-01'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    signup_ts\n      Input should be a valid datetime, invalid datetime separator, expected `T`, `t`, `_` or space [type=datetime_parsing, input_value='2024-04-01', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting default values for model fields\nDESCRIPTION: Demonstrates two ways to provide default values for model fields: direct assignment and using the default parameter in Field().\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    # Both fields aren't required:\n    name: str = 'John Doe'\n    age: int = Field(default=20)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Generic Models with Python 3.9+ Syntax\nDESCRIPTION: Example of creating a reusable HTTP response payload wrapper using generic models in Pydantic with the traditional syntax. Shows how to declare type variables, create a generic model class, and use it with different type parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel, ValidationError\n\nDataT = TypeVar('DataT')  # (1)!\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response(BaseModel, Generic[DataT]):  # (2)!\n    data: DataT  # (3)!\n\n\nprint(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Password Matching Validation with Model After Validator in Python\nDESCRIPTION: This code snippet demonstrates using a model-level 'after' validator in Pydantic to check if two password fields match after individual field validation. It ensures password consistency before the model is considered valid.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n    password: str\n    password_repeat: str\n\n    @model_validator(mode='after')\n    def check_passwords_match(self) -> Self:\n        if self.password != self.password_repeat:\n            raise ValueError('Passwords do not match')\n        return self\n```\n\n----------------------------------------\n\nTITLE: Defining a Basic Pydantic Model in Python\nDESCRIPTION: This snippet demonstrates how to create a basic Pydantic model with required and optional fields, as well as model configuration.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'Jane Doe'\n\n    model_config = ConfigDict(str_max_length=10)  # (1)!\n```\n\n----------------------------------------\n\nTITLE: Using default_factory for dynamic default values\nDESCRIPTION: Shows how to use the default_factory parameter to generate default values dynamically, such as generating a unique ID.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: str = Field(default_factory=lambda: uuid4().hex)\n```\n\n----------------------------------------\n\nTITLE: Overriding Strict Mode for Individual Fields\nDESCRIPTION: Shows how to override the global strict mode configuration for individual fields using Field(strict=False), allowing specific fields to perform type coercion even in a model with strict mode enabled.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int = Field(strict=False)\n```\n\n----------------------------------------\n\nTITLE: Creating and Using Generic Models with Python 3.12+ Syntax (PEP 695)\nDESCRIPTION: Example showing how to create and use generic models in Pydantic using the new type parameter syntax introduced in Python 3.12 via PEP 695. Demonstrates creating the same HTTP response wrapper with the simplified syntax.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass DataModel(BaseModel):\n    number: int\n\n\nclass Response[DataT](BaseModel):  # (1)!\n    data: DataT  # (2)!\n\n\nprint(Response[int](data=1))\n#> data=1\nprint(Response[str](data='value'))\n#> data='value'\nprint(Response[str](data='value').model_dump())\n#> {'data': 'value'}\n\ndata = DataModel(number=1)\nprint(Response[DataModel](data=data).model_dump())\n#> {'data': {'number': 1}}\ntry:\n    Response[int](data='value')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Response[int]\n    data\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Serialization Context in Pydantic\nDESCRIPTION: Demonstrates how to use context objects in serialization to dynamically control serialization behavior. This example shows filtering text by stopwords that are passed through the context parameter.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SerializationInfo, field_serializer\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_serializer('text')\n    def remove_stopwords(self, v: str, info: SerializationInfo):\n        context = info.context\n        if context:\n            stopwords = context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\nmodel = Model.model_construct(**{'text': 'This is an example document'})\nprint(model.model_dump())  # no context\n#> {'text': 'This is an example document'}\nprint(model.model_dump(context={'stopwords': ['this', 'is', 'an']}))\n#> {'text': 'example document'}\nprint(model.model_dump(context={'stopwords': ['document']}))\n#> {'text': 'This is an example'}\n```\n\n----------------------------------------\n\nTITLE: Implementing Faux Immutability with Frozen Config\nDESCRIPTION: Shows how to make Pydantic models immutable using model_config['frozen'] = True. Demonstrates that direct attribute changes raise errors while nested mutable objects can still be modified.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass FooBarModel(BaseModel):\n    model_config = ConfigDict(frozen=True)\n\n    a: str\n    b: dict\n\n\nfoobar = FooBarModel(a='hello', b={'apple': 'pear'})\n\ntry:\n    foobar.a = 'different'\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for FooBarModel\n    a\n      Instance is frozen [type=frozen_instance, input_value='different', input_type=str]\n    \"\"\"\n\nprint(foobar.a)\n#> hello\nprint(foobar.b)\n#> {'apple': 'pear'}\nfoobar.b['apple'] = 'grape'\nprint(foobar.b)\n#> {'apple': 'grape'}\n```\n\n----------------------------------------\n\nTITLE: Basic Pydantic Model Validation Example\nDESCRIPTION: Shows how to create a User model with various field types including integers, strings, datetime, and nested dictionaries. Demonstrates successful validation and data coercion.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, PositiveInt\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {\n    'id': 123,\n    'signup_ts': '2019-06-01 12:22',\n    'tastes': {\n        'wine': 9,\n        b'cheese': 7,\n        'cabbage': '1',\n    },\n}\n\nuser = User(**external_data)\n\nprint(user.id)\n#> 123\nprint(user.model_dump())\n```\n\n----------------------------------------\n\nTITLE: Type Coercion with validate_call in Python\nDESCRIPTION: Shows how the validate_call decorator coerces parameter types based on function annotations, automatically converting a string date to a date object before function execution.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import validate_call\n\n\n@validate_call\ndef greater_than(d1: date, d2: date, *, include_equal=False) -> date:  # (1)!\n    if include_equal:\n        return d1 >= d2\n    else:\n        return d1 > d2\n\n\nd1 = '2000-01-01'  # (2)!\nd2 = date(2001, 1, 1)\ngreater_than(d1, d2, include_equal=True)\n```\n\n----------------------------------------\n\nTITLE: Creating Dynamic Models at Runtime\nDESCRIPTION: Demonstrates how to create Pydantic models dynamically using the create_model function. Shows basic field definition, equivalent static models, and how to use advanced features like Field, alias, and annotations.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, create_model\n\nDynamicFoobarModel = create_model('DynamicFoobarModel', foo=str, bar=(int, 123))\n\n# Equivalent to:\n\n\nclass StaticFoobarModel(BaseModel):\n    foo: str\n    bar: int = 123\n```\n\n----------------------------------------\n\nTITLE: Using Annotated pattern with Field() for metadata\nDESCRIPTION: Demonstrates the Annotated pattern to attach Field() and other metadata to a model field without implying default values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, WithJsonSchema\n\n\nclass Model(BaseModel):\n    name: Annotated[str, Field(strict=True), WithJsonSchema({'extra': 'data'})]\n```\n\n----------------------------------------\n\nTITLE: Handling Third-Party Types in Pydantic\nDESCRIPTION: Demonstrates how to integrate third-party types with Pydantic. It creates a custom annotation class with __get_pydantic_core_schema__ and __get_pydantic_json_schema__ methods to handle validation, serialization, and schema generation for a third-party type that wasn't designed for Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import (\n    BaseModel,\n    GetCoreSchemaHandler,\n    GetJsonSchemaHandler,\n    ValidationError,\n)\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass ThirdPartyType:\n    \"\"\"\n    This is meant to represent a type from a third-party library that wasn't designed with Pydantic\n    integration in mind, and so doesn't have a `pydantic_core.CoreSchema` or anything.\n    \"\"\"\n\n    x: int\n\n    def __init__(self):\n        self.x = 0\n\n\nclass _ThirdPartyTypePydanticAnnotation:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        \"\"\"\n        We return a pydantic_core.CoreSchema that behaves in the following ways:\n\n        * ints will be parsed as `ThirdPartyType` instances with the int as the x attribute\n        * `ThirdPartyType` instances will be parsed as `ThirdPartyType` instances without any changes\n        * Nothing else will pass validation\n        * Serialization will always return just an int\n        \"\"\"\n\n        def validate_from_int(value: int) -> ThirdPartyType:\n            result = ThirdPartyType()\n            result.x = value\n            return result\n\n        from_int_schema = core_schema.chain_schema(\n            [\n                core_schema.int_schema(),\n                core_schema.no_info_plain_validator_function(validate_from_int),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=from_int_schema,\n            python_schema=core_schema.union_schema(\n                [\n                    # check if it's an instance first before doing any further work\n                    core_schema.is_instance_schema(ThirdPartyType),\n                    from_int_schema,\n                ]\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                lambda instance: instance.x\n            ),\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        # Use the same schema that would be used for `int`\n        return handler(core_schema.int_schema())\n\n\n# We now create an `Annotated` wrapper that we'll use as the annotation for fields on `BaseModel`s, etc.\nPydanticThirdPartyType = Annotated[\n    ThirdPartyType, _ThirdPartyTypePydanticAnnotation\n]\n\n\n# Create a model class that uses this annotation as a field\nclass Model(BaseModel):\n    third_party_type: PydanticThirdPartyType\n\n\n# Demonstrate that this field is handled correctly, that ints are parsed into `ThirdPartyType`, and that\n# these instances are also \"dumped\" directly into ints as expected.\nm_int = Model(third_party_type=1)\nassert isinstance(m_int.third_party_type, ThirdPartyType)\nassert m_int.third_party_type.x == 1\nassert m_int.model_dump() == {'third_party_type': 1}\n\n# Do the same thing where an instance of ThirdPartyType is passed in\ninstance = ThirdPartyType()\nassert instance.x == 0\ninstance.x = 10\n\nm_instance = Model(third_party_type=instance)\nassert isinstance(m_instance.third_party_type, ThirdPartyType)\nassert m_instance.third_party_type.x == 10\nassert m_instance.model_dump() == {'third_party_type': 10}\n\n# Demonstrate that validation errors are raised as expected for invalid inputs\ntry:\n    Model(third_party_type='a')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    third_party_type.is-instance[ThirdPartyType]\n      Input should be an instance of ThirdPartyType [type=is_instance_of, input_value='a', input_type=str]\n    third_party_type.chain[int,function-plain[validate_from_int()]]\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n\n\nassert Model.model_json_schema() == {\n    'properties': {\n        'third_party_type': {'title': 'Third Party Type', 'type': 'integer'}\n    },\n    'required': ['third_party_type'],\n    'title': 'Model',\n    'type': 'object',\n}\n```\n\n----------------------------------------\n\nTITLE: Serializing with Duck-Typing Using serialize_as_any Flag in Python\nDESCRIPTION: Demonstrates the use of the serialize_as_any flag to control duck-typing serialization behavior at runtime.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user1: User\n    user2: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nouter_model = OuterModel(user1=user, user2=user)\nprint(outer_model.model_dump(serialize_as_any=True))  # (1)!\n\"\"\"\n{\n    'user1': {'name': 'pydantic', 'password': 'password'},\n    'user2': {'name': 'pydantic', 'password': 'password'},\n}\n\"\"\"\n\nprint(outer_model.model_dump(serialize_as_any=False))  # (2)!\n#> {'user1': {'name': 'pydantic'}, 'user2': {'name': 'pydantic'}}\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n    friends: list['User']\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user: User\n\n\nuser = UserLogin(\n    name='samuel',\n    password='pydantic-pw',\n    friends=[UserLogin(name='sebastian', password='fastapi-pw', friends=[])],\n)\n\nprint(OuterModel(user=user).model_dump(serialize_as_any=True))  # (1)!\n\"\"\"\n{\n    'user': {\n        'name': 'samuel',\n        'friends': [\n            {'name': 'sebastian', 'friends': [], 'password': 'fastapi-pw'}\n        ],\n        'password': 'pydantic-pw',\n    }\n}\n\"\"\"\n\nprint(OuterModel(user=user).model_dump(serialize_as_any=False))  # (2)!\n\"\"\"\n{'user': {'name': 'samuel', 'friends': [{'name': 'sebastian', 'friends': []}]}}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode in BaseModel with ConfigDict\nDESCRIPTION: Demonstrates how to enable strict mode for all fields in a Pydantic BaseModel using ConfigDict(strict=True), which prevents automatic type coercion and raises validation errors for incorrect input types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass User(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    name: str\n    age: int\n    is_active: bool\n\n\ntry:\n    User(name='David', age='33', is_active='yes')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for User\n    age\n      Input should be a valid integer [type=int_type, input_value='33', input_type=str]\n    is_active\n      Input should be a valid boolean [type=bool_type, input_value='yes', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Callable Discriminator with Dict and Model Input Handling\nDESCRIPTION: This example demonstrates how to create a callable discriminator that can handle both `dict` and `BaseModel` instances as input, covering both validation and serialization scenarios. It defines a `Discriminator` that uses a function `get_discriminator_value` to extract the discriminator value based on the input type. The `ThanksgivingDinner` model uses this discriminator to validate the `dessert` field, which can be either `ApplePie` or `PumpkinPie`.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag\n\n\nclass Pie(BaseModel):\n    time_to_cook: int\n    num_ingredients: int\n\n\nclass ApplePie(Pie):\n    fruit: Literal['apple'] = 'apple'\n\n\nclass PumpkinPie(Pie):\n    filling: Literal['pumpkin'] = 'pumpkin'\n\n\ndef get_discriminator_value(v: Any) -> str:\n    if isinstance(v, dict):\n        return v.get('fruit', v.get('filling'))\n    return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n\nclass ThanksgivingDinner(BaseModel):\n    dessert: Annotated[\n        Union[\n            Annotated[ApplePie, Tag('apple')],\n            Annotated[PumpkinPie, Tag('pumpkin')],\n        ],\n        Discriminator(get_discriminator_value),\n    ]\n\n\napple_variation = ThanksgivingDinner.model_validate(\n    {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n)\nprint(repr(apple_variation))\n\"\"\"\nThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n\"\"\"\n\npumpkin_variation = ThanksgivingDinner.model_validate(\n    {\n        'dessert': {\n            'filling': 'pumpkin',\n            'time_to_cook': 40,\n            'num_ingredients': 6,\n        }\n    }\n)\nprint(repr(pumpkin_variation))\n\"\"\"\nThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Smart Mode Union Validation in Pydantic\nDESCRIPTION: This snippet demonstrates the default 'smart' mode for Union validation in Pydantic. It defines a `User` model with an `id` field that can be an integer, string, or UUID. Pydantic attempts to select the best match for the input based on exactness and the number of valid fields. This example showcases how the same field can accept different data types, and the validator successfully infers the correct type. This code requires Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\nfrom uuid import UUID\n\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    id: Union[int, str, UUID]\n    name: str\n\n\nuser_01 = User(id=123, name='John Doe')\nprint(user_01)\n#> id=123 name='John Doe'\nprint(user_01.id)\n#> 123\nuser_02 = User(id='1234', name='John Doe')\nprint(user_02)\n#> id='1234' name='John Doe'\nprint(user_02.id)\n#> 1234\nuser_03_uuid = UUID('cf57432e-809e-4353-adbd-9d5c0d733868')\nuser_03 = User(id=user_03_uuid, name='John Doe')\nprint(user_03)\n#> id=UUID('cf57432e-809e-4353-adbd-9d5c0d733868') name='John Doe'\nprint(user_03.id)\n#> cf57432e-809e-4353-adbd-9d5c0d733868\nprint(user_03_uuid.int)\n#> 275603287559914445491632874575877060712\n```\n\n----------------------------------------\n\nTITLE: Custom Datetime Validator with Timezone Constraints in Python\nDESCRIPTION: Implements a custom validator for datetime objects that ensures they adhere to a specific timezone constraint. The validator uses __get_pydantic_core_schema__ to customize schema validation and a wrap validator to perform operations before and after default Pydantic validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/custom_validators.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable, Optional\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import (\n    GetCoreSchemaHandler,\n    PydanticUserError,\n    TypeAdapter,\n    ValidationError,\n)\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    tz_constraint: Optional[str] = None\n\n    def tz_constraint_validator(\n        self,\n        value: dt.datetime,\n        handler: Callable,  # (1)!\n    ):\n        \"\"\"Validate tz_constraint and tz_info.\"\"\"\n        # handle naive datetimes\n        if self.tz_constraint is None:\n            assert (\n                value.tzinfo is None\n            ), 'tz_constraint is None, but provided value is tz-aware.'\n            return handler(value)\n\n        # validate tz_constraint and tz-aware tzinfo\n        if self.tz_constraint not in pytz.all_timezones:\n            raise PydanticUserError(\n                f'Invalid tz_constraint: {self.tz_constraint}',\n                code='unevaluable-type-annotation',\n            )\n        result = handler(value)  # (2)!\n        assert self.tz_constraint == str(\n            result.tzinfo\n        ), f'Invalid tzinfo: {str(result.tzinfo)}, expected: {self.tz_constraint}'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.tz_constraint_validator,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(LA)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    ta.validate_python(\n        dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n    )\nexcept ValidationError as ve:\n    pprint(ve.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Invalid tzinfo: Europe/London, expected: America/Los_Angeles')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Invalid tzinfo: Europe/London, expected: America/Los_Angeles',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Validating Single User Data with Pydantic and HTTPX in Python\nDESCRIPTION: This snippet demonstrates how to use Pydantic and HTTPX to fetch a single user's data from an API and validate it using a Pydantic model. It uses the User model to ensure the received data matches the expected structure.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/requests.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/1'\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nuser = User.model_validate(response.json())\nprint(repr(user))\n#> User(id=1, name='Leanne Graham', email='Sincere@april.biz')\n```\n\n----------------------------------------\n\nTITLE: Using AliasChoices for Field Validation in Python with Pydantic\nDESCRIPTION: Shows how to use AliasChoices to specify multiple possible aliases for a field in a Pydantic model. This allows for flexible data validation using different field names.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', 'fname'))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', 'lname'))\n\nuser = User.model_validate({'fname': 'John', 'lname': 'Doe'})  # (1)!\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'first_name': 'John', 'lname': 'Doe'})  # (2)!\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Sequence Type Validation in Pydantic\nDESCRIPTION: Example of using typing.Sequence with Pydantic models to validate lists and tuples while preserving the original container type when possible.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Sequence\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    sequence_of_ints: Sequence[int] = None\n\n\nprint(Model(sequence_of_ints=[1, 2, 3, 4]).sequence_of_ints)\n#> [1, 2, 3, 4]\nprint(Model(sequence_of_ints=(1, 2, 3, 4)).sequence_of_ints)\n#> (1, 2, 3, 4)\n```\n\n----------------------------------------\n\nTITLE: Validating Data using Type Hints with Pydantic in Python\nDESCRIPTION: This example demonstrates how Pydantic uses Python type hints to define validation schemas. It shows validation of simple string fields, Literal types for constrained values, Annotated types with constraints, and complex nested data structures.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Literal\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\n\nclass Fruit(BaseModel):\n    name: str  # (1)!\n    color: Literal['red', 'green']  # (2)!\n    weight: Annotated[float, Gt(0)]  # (3)!\n    bazam: dict[str, list[tuple[int, bool, float]]]  # (4)!\n\n\nprint(\n    Fruit(\n        name='Apple',\n        color='red',\n        weight=4.2,\n        bazam={'foobar': [(1, True, 0.1)]},\n    )\n)\n#> name='Apple' color='red' weight=4.2 bazam={'foobar': [(1, True, 0.1)]}\n```\n\n----------------------------------------\n\nTITLE: Using Field Validator Decorator for Multiple Fields in Python\nDESCRIPTION: This code snippet demonstrates using the field_validator decorator in Pydantic to apply the same validation function to multiple fields simultaneously. It capitalizes two string fields using a single validator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    f1: str\n    f2: str\n\n    @field_validator('f1', 'f2', mode='before')\n    @classmethod\n    def capitalize(cls, value: str) -> str:\n        return value.capitalize()\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with Annotated and TypedDict\nDESCRIPTION: This example demonstrates how to use Field(strict=True) as an annotation with TypedDict, enabling strict mode validation for specific fields in a dictionary-like structure.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom typing_extensions import TypedDict\n\nfrom pydantic import Field, TypeAdapter, ValidationError\n\nclass MyDict(TypedDict):\n    x: Annotated[int, Field(strict=True)]\n\ntry:\n    TypeAdapter(MyDict).validate_python({'x': '1'})\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyDict\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Generating top-level JSON schema with models_json_schema in Python\nDESCRIPTION: This example shows how to generate a top-level JSON schema that includes multiple models and their related sub-models in the $defs section. The models_json_schema function is used to generate a combined schema with a custom title.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import models_json_schema\n\n\nclass Foo(BaseModel):\n    a: str = None\n\n\nclass Model(BaseModel):\n    b: Foo\n\n\nclass Bar(BaseModel):\n    c: int\n\n\n_, top_level_schema = models_json_schema(\n    [(Model, 'validation'), (Bar, 'validation')], title='My Schema'\n)\nprint(json.dumps(top_level_schema, indent=2))\n\"\"\"\n{\n  \"$defs\": {\n    \"Bar\": {\n      \"properties\": {\n        \"c\": {\n          \"title\": \"C\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"c\"\n      ],\n      \"title\": \"Bar\",\n      \"type\": \"object\"\n    },\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"default\": null,\n          \"title\": \"A\",\n          \"type\": \"string\"\n        }\n      },\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    },\n    \"Model\": {\n      \"properties\": {\n        \"b\": {\n          \"$ref\": \"#/$defs/Foo\"\n        }\n      },\n      \"required\": [\n        \"b\"\n      ],\n      \"title\": \"Model\",\n      \"type\": \"object\"\n    }\n  },\n  \"title\": \"My Schema\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Validating JSON Data with Pydantic\nDESCRIPTION: Demonstrates how to validate JSON data against a Pydantic model. The example reads a JSON file containing person information and validates it using a Person model with specific field types including EmailStr and PositiveInt.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"name\": \"John Doe\",\n    \"age\": 30,\n    \"email\": \"john@example.com\"\n}\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\nperson = Person.model_validate_json(json_string)\nprint(repr(person))\n#> Person(name='John Doe', age=30, email='john@example.com')\n```\n\n----------------------------------------\n\nTITLE: Applying Dataclass Constraints in Pydantic\nDESCRIPTION: Shows how to use init, init_var, and kw_only constraints on fields in a Pydantic dataclass.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Foo:\n    bar: str\n    baz: str = Field(init_var=True)\n    qux: str = Field(kw_only=True)\n\n\nclass Model(BaseModel):\n    foo: Foo\n\n\nmodel = Model(foo=Foo('bar', baz='baz', qux='qux'))\nprint(model.model_dump())  # (1)!\n#> {'foo': {'bar': 'bar', 'qux': 'qux'}}\n```\n\n----------------------------------------\n\nTITLE: Parsing API Data with TypeAdapter in Python\nDESCRIPTION: Shows how to use TypeAdapter to parse data into a list of BaseModel objects, particularly useful for handling API responses or external data sources.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Item(BaseModel):\n    id: int\n    name: str\n\n\n# `item_data` could come from an API call, eg., via something like:\n# item_data = requests.get('https://my-api.com/items').json()\nitem_data = [{'id': 1, 'name': 'My Item'}]\n\nitems = TypeAdapter(list[Item]).validate_python(item_data)\nprint(items)\n#> [Item(id=1, name='My Item')]\n```\n\n----------------------------------------\n\nTITLE: Using Custom Types with Dataclasses in Pydantic\nDESCRIPTION: Shows how to use custom types with dataclasses in Pydantic models by enabling arbitrary_types_allowed in the model configuration. This allows validating dataclasses with non-standard types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic.errors import PydanticSchemaGenerationError\n\n\nclass ArbitraryType:\n    def __init__(self, value):\n        self.value = value\n\n    def __repr__(self):\n        return f'ArbitraryType(value={self.value!r})'\n\n\n@dataclasses.dataclass\nclass DC:\n    a: ArbitraryType\n    b: str\n\n\n# valid as it is a stdlib dataclass without validation:\nmy_dc = DC(a=ArbitraryType(value=3), b='qwe')\n\ntry:\n\n    class Model(BaseModel):\n        dc: DC\n        other: str\n\n    # invalid as dc is now validated with pydantic, and ArbitraryType is not a known type\n    Model(dc=my_dc, other='other')\n\nexcept PydanticSchemaGenerationError as e:\n    print(e.message)\n    \"\"\"\n    Unable to generate pydantic-core schema for <class '__main__.ArbitraryType'>. Set `arbitrary_types_allowed=True` in the model_config to ignore this error or implement `__get_pydantic_core_schema__` on your type to fully support it.\n\n    If you got this error by calling handler(<some type>) within `__get_pydantic_core_schema__` then you likely need to call `handler.generate_schema(<some type>)` since we do not call `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.\n    \"\"\"\n\n\n# valid as we set arbitrary_types_allowed=True, and that config pushes down to the nested vanilla dataclass\nclass Model(BaseModel):\n    model_config = ConfigDict(arbitrary_types_allowed=True)\n\n    dc: DC\n    other: str\n\n\nm = Model(dc=my_dc, other='other')\nprint(repr(m))\n#> Model(dc=DC(a=ArbitraryType(value=3), b='qwe'), other='other')\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Schema from Pydantic Models\nDESCRIPTION: This example demonstrates how Pydantic can automatically generate JSON Schema documentation from model definitions. It shows how nested models are properly referenced and how default values and field types are represented in the schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    city: str\n    zipcode: str\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: Address\n    why: str = 'No idea'\n\n\nprint(Meeting.model_json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Address': {\n            'properties': {\n                'street': {'title': 'Street', 'type': 'string'},\n                'city': {'title': 'City', 'type': 'string'},\n                'zipcode': {'title': 'Zipcode', 'type': 'string'},\n            },\n            'required': ['street', 'city', 'zipcode'],\n            'title': 'Address',\n            'type': 'object',\n        }\n    },\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'$ref': '#/$defs/Address'},\n        'why': {'default': 'No idea', 'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Instantiating and Using a Pydantic Model in Python\nDESCRIPTION: This snippet shows how to create an instance of a Pydantic model, access its fields, and perform basic operations like serialization and field modification.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nuser = User(id='123')\n\nassert user.name == 'Jane Doe'  # (1)!\nassert user.id == 123  # (2)!\nassert isinstance(user.id, int)\n\nassert user.model_dump() == {'id': 123, 'name': 'Jane Doe'}\n\nuser.id = 321\nassert user.id == 321\n```\n\n----------------------------------------\n\nTITLE: Configuring TypeAdapter in Python\nDESCRIPTION: Shows how to configure a TypeAdapter using the config parameter. This example sets the coerce_numbers_to_str option to True.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter(list[str], config=ConfigDict(coerce_numbers_to_str=True))\n\nprint(ta.validate_python([1, 2]))\n#> ['1', '2']\n```\n\n----------------------------------------\n\nTITLE: Using Field() to customize model fields in Pydantic\nDESCRIPTION: Demonstrates how to use the Field() function to customize a model field with constraints.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    name: str = Field(frozen=True)\n```\n\n----------------------------------------\n\nTITLE: Overriding Return Type for model_dump() in Python\nDESCRIPTION: Demonstrates how to use @model_serializer to override the return type of model_dump() and ensure proper type-checking.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, model_serializer\n\n\nclass Model(BaseModel):\n    x: str\n\n    @model_serializer\n    def ser_model(self) -> str:\n        return self.x\n\n\nprint(Model(x='not a dict').model_dump())\n#> not a dict\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Literal\n\nfrom pydantic import BaseModel, model_serializer\n\n\nclass Model(BaseModel):\n    x: str\n\n    @model_serializer\n    def ser_model(self) -> str:\n        return self.x\n\n    if TYPE_CHECKING:\n        # Ensure type checkers see the correct return type\n        def model_dump(\n            self,\n            *,\n            mode: Literal['json', 'python'] | str = 'python',\n            include: Any = None,\n            exclude: Any = None,\n            by_alias: bool | None = False,\n            exclude_unset: bool = False,\n            exclude_defaults: bool = False,\n            exclude_none: bool = False,\n            round_trip: bool = False,\n            warnings: bool = True,\n        ) -> str: ...\n```\n\n----------------------------------------\n\nTITLE: Handling Nested Attributes with from_attributes\nDESCRIPTION: Demonstrates how Pydantic handles nested attributes when parsing models from arbitrary class instances. Both top-level and nested attributes are properly converted to model instances.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass PetCls:\n    def __init__(self, *, name: str, species: str):\n        self.name = name\n        self.species = species\n\n\nclass PersonCls:\n    def __init__(self, *, name: str, age: float = None, pets: list[PetCls]):\n        self.name = name\n        self.age = age\n        self.pets = pets\n\n\nclass Pet(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    species: str\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    name: str\n    age: float = None\n    pets: list[Pet]\n\n\nbones = PetCls(name='Bones', species='dog')\norion = PetCls(name='Orion', species='cat')\nanna = PersonCls(name='Anna', age=20, pets=[bones, orion])\nanna_model = Person.model_validate(anna)\nprint(anna_model)\n\"\"\"\nname='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: String Constraints in Pydantic Models\nDESCRIPTION: Shows how to apply string constraints including minimum length, maximum length, and regex pattern matching using Field parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    short: str = Field(min_length=3)\n    long: str = Field(max_length=10)\n    regex: str = Field(pattern=r'^\\d*$')\n\nfoo = Foo(short='foo', long='foobarbaz', regex='123')\nprint(foo)\n#> short='foo' long='foobarbaz' regex='123'\n```\n\n----------------------------------------\n\nTITLE: Integrating Pydantic with SQLAlchemy for ORM in Python\nDESCRIPTION: This code snippet demonstrates how to use Pydantic with SQLAlchemy for object-relational mapping. It defines a Pydantic model and a SQLAlchemy model, showing how to use aliases to avoid conflicts with reserved SQLAlchemy fields. The example also illustrates how to validate and dump model data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/orms.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sqlalchemy as sa\nfrom sqlalchemy.orm import declarative_base\n\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    metadata: dict[str, str] = Field(alias='metadata_')\n\n\nBase = declarative_base()\n\n\nclass MyTableModel(Base):\n    __tablename__ = 'my_table'\n    id = sa.Column('id', sa.Integer, primary_key=True)\n    # 'metadata' is reserved by SQLAlchemy, hence the '_'\n    metadata_ = sa.Column('metadata', sa.JSON)\n\n\nsql_model = MyTableModel(metadata_={'key': 'val'}, id=1)\npydantic_model = MyModel.model_validate(sql_model)\n\nprint(pydantic_model.model_dump())\n#> {'metadata': {'key': 'val'}}\nprint(pydantic_model.model_dump(by_alias=True))\n#> {'metadata_': {'key': 'val'}}\n```\n\n----------------------------------------\n\nTITLE: Field Name Access in Custom Types\nDESCRIPTION: Demonstrates how to access field names in custom types using Pydantic V2.4+. Shows implementation of a custom type that stores its field name and validation info.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nclass CustomType:\n    def __init__(self, value: int, field_name: str):\n        self.value = value\n        self.field_name = field_name\n\n    def __repr__(self):\n        return f'CustomType<{self.value} {self.field_name!r}>'\n\n    @classmethod\n    def validate(cls, value: int, info: ValidationInfo):\n        return cls(value, info.field_name)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate, handler(int)\n        )\n```\n\n----------------------------------------\n\nTITLE: Implementing Input Data Validation with Model Before Validator in Python\nDESCRIPTION: This code snippet demonstrates using a model-level 'before' validator in Pydantic to check raw input data before model instantiation. It prevents creation of a user model if sensitive card_number data is included in the input.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='before')\n    @classmethod\n    def check_card_number_not_present(cls, data: Any) -> Any:  # (1)!\n        if isinstance(data, dict):  # (2)!\n            if 'card_number' in data:\n                raise ValueError(\"'card_number' should not be included\")\n        return data\n```\n\n----------------------------------------\n\nTITLE: Semantic Version Type Definition\nDESCRIPTION: Defines a SemanticVersion type for Pydantic that handles semantic version strings with validation using the semver package.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_semantic_version.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic_extra_types.semantic_version\n```\n\n----------------------------------------\n\nTITLE: Creating Nested Pydantic Models\nDESCRIPTION: Shows how to define complex hierarchical data structures using nested Pydantic models, where one model contains fields that are instances of other models or collections of models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    count: int\n    size: Optional[float] = None\n\n\nclass Bar(BaseModel):\n    apple: str = 'x'\n    banana: str = 'y'\n\n\nclass Spam(BaseModel):\n    foo: Foo\n    bars: list[Bar]\n\n\nm = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])\nprint(m)\n\"\"\"\nfoo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'), Bar(apple='x2', banana='y')]\n\"\"\"\nprint(m.model_dump())\n\"\"\"\n{\n    'foo': {'count': 4, 'size': None},\n    'bars': [{'apple': 'x1', 'banana': 'y'}, {'apple': 'x2', 'banana': 'y'}],\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Custom validator to preserve input types in Pydantic V2\nDESCRIPTION: Example demonstrating how to implement a custom validator with WrapValidator and Annotated to preserve input types for collections in Pydantic V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any, Mapping, TypeVar\n\nfrom pydantic import (\n    TypeAdapter,\n    ValidationInfo,\n    ValidatorFunctionWrapHandler,\n    WrapValidator,\n)\n\n\ndef restore_input_type(\n    value: Any, handler: ValidatorFunctionWrapHandler, _info: ValidationInfo\n) -> Any:\n    return type(value)(handler(value))\n\n\nT = TypeVar('T')\nPreserveType = Annotated[T, WrapValidator(restore_input_type)]\n\n\nta = TypeAdapter(PreserveType[Mapping[str, int]])\n\n\nclass MyDict(dict):\n    pass\n\n\nv = ta.validate_python(MyDict())\nassert type(v) is MyDict\n```\n\n----------------------------------------\n\nTITLE: Using Forward Annotations with Pydantic BaseModel in Python\nDESCRIPTION: This snippet demonstrates how to use forward annotations in a Pydantic BaseModel, either with a future import or by wrapping the annotation in quotes. It shows how MyInt is used as a type annotation for the 'a' field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\nMyInt = int\n\n\nclass Model(BaseModel):\n    a: MyInt\n    # Without the future import, equivalent to:\n    # a: 'MyInt'\n\n\nprint(Model(a='1'))\n#> a=1\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Model Using Class Arguments in Python\nDESCRIPTION: Shows how to configure a Pydantic model using class arguments. This method allows static type checkers to recognize the configuration options.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel, frozen=True):\n    a: str  # (1)!\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Schema with TypeAdapter\nDESCRIPTION: Example showing how to generate JSON schema for a simple list of integers using TypeAdapter. TypeAdapter allows schema generation for arbitrary types, serving as a replacement for schema_of in Pydantic V1.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\n----------------------------------------\n\nTITLE: Using Validation Context in Pydantic Models\nDESCRIPTION: Shows how to pass a context object to validation methods and access it inside validator functions. This example filters stopwords from text based on a context dictionary provided during validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    text: str\n\n    @field_validator('text', mode='after')\n    @classmethod\n    def remove_stopwords(cls, v: str, info: ValidationInfo) -> str:\n        if isinstance(info.context, dict):\n            stopwords = info.context.get('stopwords', set())\n            v = ' '.join(w for w in v.split() if w.lower() not in stopwords)\n        return v\n\n\ndata = {'text': 'This is an example document'}\nprint(Model.model_validate(data))  # no context\n#> text='This is an example document'\nprint(Model.model_validate(data, context={'stopwords': ['this', 'is', 'an']}))\n#> text='example document'\n```\n\n----------------------------------------\n\nTITLE: Handling Validation Errors in Pydantic\nDESCRIPTION: Shows how Pydantic handles validation errors when the JSON data doesn't meet the model requirements. The example demonstrates validation errors for missing fields, negative numbers, and invalid email formats.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"age\": -30,\n    \"email\": \"not-an-email-address\"\n}\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, ValidationError\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_string = pathlib.Path('person.json').read_text()\ntry:\n    person = Person.model_validate_json(json_string)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    3 validation errors for Person\n    name\n    Field required [type=missing, input_value={'age': -30, 'email': 'not-an-email-address'}, input_type=dict]\n        For further information visit https://errors.pydantic.dev/2.10/v/missing\n    age\n    Input should be greater than 0 [type=greater_than, input_value=-30, input_type=int]\n        For further information visit https://errors.pydantic.dev/2.10/v/greater_than\n    email\n    value is not a valid email address: An email address must have an @-sign. [type=value_error, input_value='not-an-email-address', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Advanced TypedDict Configuration in Pydantic\nDESCRIPTION: Shows how to use custom configuration with TypedDict, including total=False for optional fields and extra=forbid to prevent additional fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\n\n# `total=False` means keys are non-required\nclass UserIdentity(TypedDict, total=False):\n    name: Optional[str]\n    surname: str\n\n\nclass User(TypedDict):\n    __pydantic_config__ = ConfigDict(extra='forbid')\n\n    identity: UserIdentity\n    age: int\n\n\nta = TypeAdapter(User)\n\nprint(\n    ta.validate_python(\n        {'identity': {'name': 'Smith', 'surname': 'John'}, 'age': 37}\n    )\n)\n#> {'identity': {'name': 'Smith', 'surname': 'John'}, 'age': 37}\n\nprint(\n    ta.validate_python(\n        {'identity': {'name': None, 'surname': 'John'}, 'age': 37}\n    )\n)\n#> {'identity': {'name': None, 'surname': 'John'}, 'age': 37}\n\nprint(ta.validate_python({'identity': {}, 'age': 37}))\n#> {'identity': {}, 'age': 37}\n\n\ntry:\n    ta.validate_python(\n        {'identity': {'name': ['Smith'], 'surname': 'John'}, 'age': 24}\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    identity.name\n      Input should be a valid string [type=string_type, input_value=['Smith'], input_type=list]\n    \"\"\"\n\ntry:\n    ta.validate_python(\n        {\n            'identity': {'name': 'Smith', 'surname': 'John'},\n            'age': '37',\n            'email': 'john.smith@me.com',\n        }\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    email\n      Extra inputs are not permitted [type=extra_forbidden, input_value='john.smith@me.com', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Complex Field Exclusion in Nested Lists and Tuples\nDESCRIPTION: Demonstrates how to exclude fields from nested collections when serializing. Shows how to exclude fields from specific list/tuple elements by index, and how to exclude fields from all members using the '__all__' key.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport datetime\n\nfrom pydantic import BaseModel, SecretStr\n\n\nclass Country(BaseModel):\n    name: str\n    phone_code: int\n\n\nclass Address(BaseModel):\n    post_code: int\n    country: Country\n\n\nclass CardDetails(BaseModel):\n    number: SecretStr\n    expires: datetime.date\n\n\nclass Hobby(BaseModel):\n    name: str\n    info: str\n\n\nclass User(BaseModel):\n    first_name: str\n    second_name: str\n    address: Address\n    card_details: CardDetails\n    hobbies: list[Hobby]\n\n\nuser = User(\n    first_name='John',\n    second_name='Doe',\n    address=Address(\n        post_code=123456, country=Country(name='USA', phone_code=1)\n    ),\n    card_details=CardDetails(\n        number='4212934504460000', expires=datetime.date(2020, 5, 1)\n    ),\n    hobbies=[\n        Hobby(name='Programming', info='Writing code and stuff'),\n        Hobby(name='Gaming', info='Hell Yeah!!!'),\n    ],\n)\n\nexclude_keys = {\n    'second_name': True,\n    'address': {'post_code': True, 'country': {'phone_code'}},\n    'card_details': True,\n    # You can exclude fields from specific members of a tuple/list by index:\n    'hobbies': {-1: {'info'}},\n}\n\ninclude_keys = {\n    'first_name': True,\n    'address': {'country': {'name'}},\n    'hobbies': {0: True, -1: {'name'}},\n}\n\n# would be the same as user.model_dump(exclude=exclude_keys) in this case:\nprint(user.model_dump(include=include_keys))\n\"\"\"\n{\n    'first_name': 'John',\n    'address': {'country': {'name': 'USA'}},\n    'hobbies': [\n        {'name': 'Programming', 'info': 'Writing code and stuff'},\n        {'name': 'Gaming'},\n    ],\n}\n\"\"\"\n\n# To exclude a field from all members of a nested list or tuple, use \"__all__\":\nprint(user.model_dump(exclude={'hobbies': {'__all__': {'info'}}}))\n\"\"\"\n{\n    'first_name': 'John',\n    'second_name': 'Doe',\n    'address': {\n        'post_code': 123456,\n        'country': {'name': 'USA', 'phone_code': 1},\n    },\n    'card_details': {\n        'number': SecretStr('**********'),\n        'expires': datetime.date(2020, 5, 1),\n    },\n    'hobbies': [{'name': 'Programming'}, {'name': 'Gaming'}],\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Customizing $ref format in JSON Schema with ref_template in Python\nDESCRIPTION: This example shows how to customize the format of $ref references in the generated JSON schema by using the ref_template parameter. The example demonstrates changing the references to match OpenAPI component schema structure while still storing definitions under $defs.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel\nfrom pydantic.type_adapter import TypeAdapter\n\n\nclass Foo(BaseModel):\n    a: int\n\n\nclass Model(BaseModel):\n    a: Foo\n\n\nadapter = TypeAdapter(Model)\n\nprint(\n    json.dumps(\n        adapter.json_schema(ref_template='#/components/schemas/{model}'),\n        indent=2,\n    )\n)\n\"\"\"\n{\n  \"$defs\": {\n    \"Foo\": {\n      \"properties\": {\n        \"a\": {\n          \"title\": \"A\",\n          \"type\": \"integer\"\n        }\n      },\n      \"required\": [\n        \"a\"\n      ],\n      \"title\": \"Foo\",\n      \"type\": \"object\"\n    }\n  },\n  \"properties\": {\n    \"a\": {\n      \"$ref\": \"#/components/schemas/Foo\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Data Validation and Serialization with Pydantic for Redis Queue in Python\nDESCRIPTION: This code snippet demonstrates how to use Pydantic to serialize data for pushing to a Redis queue and deserialize/validate data when popping from the queue. It defines a User model with id, name, and email fields, and includes functions for queue operations.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/queues.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport redis\n\nfrom pydantic import BaseModel, EmailStr\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nr = redis.Redis(host='localhost', port=6379, db=0)\nQUEUE_NAME = 'user_queue'\n\n\ndef push_to_queue(user_data: User) -> None:\n    serialized_data = user_data.model_dump_json()\n    r.rpush(QUEUE_NAME, user_data.model_dump_json())\n    print(f'Added to queue: {serialized_data}')\n\n\nuser1 = User(id=1, name='John Doe', email='john@example.com')\nuser2 = User(id=2, name='Jane Doe', email='jane@example.com')\n\npush_to_queue(user1)\n#> Added to queue: {\"id\":1,\"name\":\"John Doe\",\"email\":\"john@example.com\"}\n\npush_to_queue(user2)\n#> Added to queue: {\"id\":2,\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}\n\n\ndef pop_from_queue() -> None:\n    data = r.lpop(QUEUE_NAME)\n\n    if data:\n        user = User.model_validate_json(data)\n        print(f'Validated user: {repr(user)}')\n    else:\n        print('Queue is empty')\n\n\npop_from_queue()\n#> Validated user: User(id=1, name='John Doe', email='john@example.com')\n\npop_from_queue()\n#> Validated user: User(id=2, name='Jane Doe', email='jane@example.com')\n\npop_from_queue()\n#> Queue is empty\n```\n\n----------------------------------------\n\nTITLE: Serializing with Duck-Typing Using SerializeAsAny in Python\nDESCRIPTION: Shows how to use SerializeAsAny annotation to enable duck-typing serialization behavior for specific fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    as_any: SerializeAsAny[User]\n    as_user: User\n\n\nuser = UserLogin(name='pydantic', password='password')\n\nprint(OuterModel(as_any=user, as_user=user).model_dump())\n\"\"\"\n{\n    'as_any': {'name': 'pydantic', 'password': 'password'},\n    'as_user': {'name': 'pydantic'},\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Validating Pydantic Model by Alias in Python\nDESCRIPTION: Shows how to validate a Pydantic model using an alias. The model_validate() method is used with by_alias=True and by_name=False to ensure that the alias 'my_alias' is used for validation instead of the attribute name.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\nm = Model.model_validate(\n    {'my_alias': 'foo'},  # (1)!\n    by_alias=True,\n    by_name=False,\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Creating Pydantic Models from ORM Instances\nDESCRIPTION: Shows how to create Pydantic models from arbitrary class instances like ORM objects by enabling the from_attributes config option. This example uses SQLAlchemy but the approach works with any ORM.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom sqlalchemy import ARRAY, String\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nfrom pydantic import BaseModel, ConfigDict, StringConstraints\n\n\nclass Base(DeclarativeBase):\n    pass\n\n\nclass CompanyOrm(Base):\n    __tablename__ = 'companies'\n\n    id: Mapped[int] = mapped_column(primary_key=True, nullable=False)\n    public_key: Mapped[str] = mapped_column(\n        String(20), index=True, nullable=False, unique=True\n    )\n    domains: Mapped[list[str]] = mapped_column(ARRAY(String(255)))\n\n\nclass CompanyModel(BaseModel):\n    model_config = ConfigDict(from_attributes=True)\n\n    id: int\n    public_key: Annotated[str, StringConstraints(max_length=20)]\n    domains: list[Annotated[str, StringConstraints(max_length=255)]]\n\n\nco_orm = CompanyOrm(\n    id=123,\n    public_key='foobar',\n    domains=['example.com', 'foobar.com'],\n)\nprint(co_orm)\n#> <__main__.CompanyOrm object at 0x0123456789ab>\nco_model = CompanyModel.model_validate(co_orm)\nprint(co_model)\n#> id=123 public_key='foobar' domains=['example.com', 'foobar.com']\n```\n\n----------------------------------------\n\nTITLE: Overriding Default Serialization Behavior in Pydantic Models\nDESCRIPTION: Creates a custom BaseModel subclass that overrides the default serialize_as_any parameter to enable duck-typing serialization by default. This enables nested models to be serialized with their specific implementations rather than as dictionaries.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, SecretStr\n\n\nclass MyBaseModel(BaseModel):\n    def model_dump(self, **kwargs) -> dict[str, Any]:\n        return super().model_dump(serialize_as_any=True, **kwargs)\n\n    def model_dump_json(self, **kwargs) -> str:\n        return super().model_dump_json(serialize_as_any=True, **kwargs)\n\n\nclass User(MyBaseModel):\n    name: str\n\n\nclass UserInfo(User):\n    password: SecretStr\n\n\nclass OuterModel(MyBaseModel):\n    user: User\n\n\nu = OuterModel(user=UserInfo(name='John', password='secret_pw'))\nprint(u.model_dump_json())  # (1)!\n#> {\"user\":{\"name\":\"John\",\"password\":\"**********\"}}\n```\n\n----------------------------------------\n\nTITLE: Datetime Handling in Pydantic Models\nDESCRIPTION: Shows how Pydantic handles datetime objects with various input formats including timestamps and ISO format strings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Event(BaseModel):\n    dt: datetime = None\n\n\nevent = Event(dt='2032-04-23T10:20:30.400+02:30')\n\nprint(event.model_dump())\n\"\"\"\n{'dt': datetime.datetime(2032, 4, 23, 10, 20, 30, 400000, tzinfo=TzInfo(+02:30))}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Schema with Field Parameters in Python Pydantic\nDESCRIPTION: Demonstrates using the Field function to provide extra information about fields and customize the JSON Schema output with parameters like title, description, and examples.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, EmailStr, Field, SecretStr\n\n\nclass User(BaseModel):\n    age: int = Field(description='Age of the user')\n    email: EmailStr = Field(examples=['marcelo@mail.com'])\n    name: str = Field(title='Username')\n    password: SecretStr = Field(\n        json_schema_extra={\n            'title': 'Password',\n            'description': 'Password of the user',\n            'examples': ['123456'],\n        }\n    )\n\n\nprint(json.dumps(User.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"age\": {\n      \"description\": \"Age of the user\",\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    },\n    \"email\": {\n      \"examples\": [\n        \"marcelo@mail.com\"\n      ],\n      \"format\": \"email\",\n      \"title\": \"Email\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"title\": \"Username\",\n      \"type\": \"string\"\n    },\n    \"password\": {\n      \"description\": \"Password of the user\",\n      \"examples\": [\n        \"123456\"\n      ],\n      \"format\": \"password\",\n      \"title\": \"Password\",\n      \"type\": \"string\",\n      \"writeOnly\": true\n    }\n  },\n  \"required\": [\n    \"age\",\n    \"email\",\n    \"name\",\n    \"password\"\n  ],\n  \"title\": \"User\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Private Attributes with PrivateAttr in Pydantic Models\nDESCRIPTION: This example shows how to use PrivateAttr to create non-validated private attributes in Pydantic models, with custom initialization in model_post_init.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom random import randint\nfrom typing import Any\n\nfrom pydantic import BaseModel, PrivateAttr\n\n\nclass TimeAwareModel(BaseModel):\n    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)\n    _secret_value: str\n\n    def model_post_init(self, context: Any) -> None:\n        # this could also be done with `default_factory`:\n        self._secret_value = randint(1, 5)\n\n\nm = TimeAwareModel()\nprint(m._processed_at)\n#> 2032-01-02 03:04:05.000006\nprint(m._secret_value)\n#> 3\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Dataclass in Python\nDESCRIPTION: Demonstrates how to configure a Pydantic dataclass using the config parameter. This example sets a maximum string length and enables validation on assignment.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config=ConfigDict(str_max_length=10, validate_assignment=True))\nclass User:\n    name: str\n\n\nuser = User(name='John Doe')\ntry:\n    user.name = 'x' * 20\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      String should have at most 10 characters [type=string_too_long, input_value='xxxxxxxxxxxxxxxxxxxx', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using validate_call with Async Functions in Python\nDESCRIPTION: Shows how validate_call can be used with asynchronous functions, including validation of parameters and handling validation errors.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nclass Connection:\n    async def execute(self, sql, *args):\n        return 'testing@example.com'\n\n\nconn = Connection()\n# ignore-above\nimport asyncio\n\nfrom pydantic import PositiveInt, ValidationError, validate_call\n\n\n@validate_call\nasync def get_user_email(user_id: PositiveInt):\n    # `conn` is some fictional connection to a database\n    email = await conn.execute('select email from users where id=$1', user_id)\n    if email is None:\n        raise RuntimeError('user not found')\n    else:\n        return email\n\n\nasync def main():\n    email = await get_user_email(123)\n    print(email)\n    #> testing@example.com\n    try:\n        await get_user_email(-4)\n    except ValidationError as exc:\n        print(exc.errors())\n        \"\"\"\n        [\n            {\n                'type': 'greater_than',\n                'loc': (0,),\n                'msg': 'Input should be greater than 0',\n                'input': -4,\n                'ctx': {'gt': 0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        \"\"\"\n\n\nasyncio.run(main())\n# requires: `conn.execute()` that will return `'testing@example.com'`\n```\n\n----------------------------------------\n\nTITLE: Timedelta Validation in Pydantic\nDESCRIPTION: Demonstrates timedelta field validation with support for various duration formats including ISO 8601.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    td: timedelta = None\n\n\nm = Model(td='P3DT12H30M5S')\n\nprint(m.model_dump())\n#> {'td': datetime.timedelta(days=3, seconds=45005)}\n```\n\n----------------------------------------\n\nTITLE: Defining and Validating Data Models with Pydantic in Python\nDESCRIPTION: This example demonstrates creating a User model with Pydantic, defining fields with types, default values, and optional parameters. It shows how Pydantic automatically validates and converts external data to match the defined types, including type coercion for integers, datetime parsing, and list element conversion.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\nfrom pydantic import BaseModel\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n    friends: list[int] = []\n\nexternal_data = {'id': '123', 'signup_ts': '2017-06-01 12:22', 'friends': [1, '2', b'3']}\nuser = User(**external_data)\nprint(user)\n#> User id=123 name='John Doe' signup_ts=datetime.datetime(2017, 6, 1, 12, 22) friends=[1, 2, 3]\nprint(user.id)\n#> 123\n```\n\n----------------------------------------\n\nTITLE: Implementing TimeZoneName Custom Type in Python for Pydantic\nDESCRIPTION: This code defines a TimeZoneName class that inherits from str and acts as a Pydantic validator for timezone names. It validates strings against the zoneinfo database and provides customization options for allowed zones and validation behavior.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_timezone_name.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nimport re\nfrom typing import Annotated, Any, ClassVar, FrozenSet, Optional, Union, cast, final\n\nfrom typing_extensions import deprecated\n\nfrom pydantic_core import PydanticCustomError, core_schema\n\n__all__ = ('TimeZoneName',)\n\n\n@final\nclass TimeZoneName(str):\n    \"\"\"\n    A string that must be a valid timezone name, from the IANA Time Zone Database.\n\n    Example:\n        ```python\n        from pydantic import BaseModel\n        from pydantic_extra_types.timezone_name import TimeZoneName\n\n        class Model(BaseModel):\n            tz: TimeZoneName\n\n        print(Model(tz='Europe/London').tz)\n        #> Europe/London\n        ```\n    \"\"\"\n\n    @deprecated('Use the non-static function `all_timezones` instead')\n    @classmethod\n    def __get_all_timezones(cls) -> FrozenSet[str]:\n        return cls.all_timezones()\n\n    @staticmethod\n    def all_timezones() -> FrozenSet[str]:\n        \"\"\"\n        Returns a frozen set of all valid timezone names.\n        \"\"\"\n        try:\n            from zoneinfo import available_timezones\n\n            return cast(FrozenSet[str], available_timezones())\n        except ImportError:\n            import pytz\n\n            return frozenset(cast(Any, pytz).all_timezones)\n\n    @staticmethod\n    def is_valid_timezone(value: str) -> bool:\n        \"\"\"\n        Check whether a string is a valid timezone name, from the IANA Time Zone Database.\n\n        Args:\n            value: The string to check.\n\n        Returns:\n            bool: True if the string is a valid timezone name, False otherwise.\n        \"\"\"\n        # Pytz considers these invalid, but zoneinfo does not.\n        # I am considering these invalid for consistency reasons.\n        if value in {'Factory', 'localtime'}:\n            return False\n\n        # Backward-compatibility links in the Time Zone database.\n        # https://data.iana.org/time-zones/tzdb/backward\n        # These are links to canonical zone names.\n        # \"Backward\" from the perspective of Pydantic.\n\n        # Many other things in the backward file are also valid for pytz, but not for zoneinfo,\n        # so this kind of forward-inclusion isn't ideal. This might be removed in a future version.\n        if value in {\n            'US/Pacific',\n            'US/Mountain',\n            'US/Central',\n            'US/Eastern',\n            'Canada/Pacific',\n            'Canada/Mountain',\n            'Canada/Central',\n            'Canada/Eastern',\n        }:\n            return True\n\n        # Note: Just checking for a tzdata module is not enough, as it's frequently vendored in weird ways.\n        # e.g. python-tzdata, tzdata, pytz_deprecation_shim. Seems most reliable to try to import\n        # available_timezones and use it if possible.\n        try:\n            from zoneinfo import available_timezones\n\n            return value in available_timezones()\n        except ImportError:\n            import pytz\n\n            return value in cast(Any, pytz).all_timezones\n\n    @staticmethod\n    def __parse_timezone_regex(regex: Union[str, re.Pattern]) -> re.Pattern:\n        if isinstance(regex, str):\n            return re.compile(regex)\n        return regex\n\n    @classmethod\n    def __get_validators__(cls) -> classmethod:  # pragma: no cover\n        # This function exists only for backwards compatibility.\n        from pydantic.v1.typing import CallableGenerator\n\n        def get_validators() -> 'CallableGenerator':\n            yield cls.validate\n\n        return cast(classmethod, get_validators)\n\n    @classmethod\n    def validate(cls, __input_value: Any, *args: Any, **kwargs: Any) -> TimeZoneName:  # pragma: no cover\n        # This function exists only for backwards compatibility.\n        if not isinstance(__input_value, str):\n            raise TypeError('string required')\n\n        if not cls.is_valid_timezone(__input_value):\n            raise ValueError('invalid timezone format')\n\n        return cls(__input_value)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source_type: Any,\n        _handler: Any,\n    ) -> core_schema.CoreSchema:\n        return core_schema.union_schema(\n            [\n                core_schema.is_instance_schema(cls),\n                core_schema.chain_schema(\n                    [\n                        core_schema.string_schema(),\n                        core_schema.no_info_plain_validator_function(cls._validate),\n                    ]\n                ),\n            ],\n            serialization=core_schema.to_string_serializer(),\n        )\n\n    @classmethod\n    def _validate(cls, __input_value: str, **kwargs: Any) -> TimeZoneName:\n        if not cls.is_valid_timezone(__input_value):\n            raise PydanticCustomError('timezone', 'Invalid timezone')\n        return cls(__input_value)\n\n\nAnyTimeZoneName = Annotated[Union[str, TimeZoneName], ...]\n```\n\n----------------------------------------\n\nTITLE: Enum Validation in Pydantic Models\nDESCRIPTION: Demonstrates enum field validation with both string and integer enums in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum, IntEnum\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass FruitEnum(str, Enum):\n    pear = 'pear'\n    banana = 'banana'\n\n\nclass ToolEnum(IntEnum):\n    spanner = 1\n    wrench = 2\n\n\nclass CookingModel(BaseModel):\n    fruit: FruitEnum = FruitEnum.pear\n    tool: ToolEnum = ToolEnum.spanner\n\n\nprint(CookingModel())\n#> fruit=<FruitEnum.pear: 'pear'> tool=<ToolEnum.spanner: 1>\nprint(CookingModel(tool=2, fruit='banana'))\n#> fruit=<FruitEnum.banana: 'banana'> tool=<ToolEnum.wrench: 2>\ntry:\n    CookingModel(fruit='other')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for CookingModel\n    fruit\n      Input should be 'pear' or 'banana' [type=enum, input_value='other', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using field_validator with ValidationInfo to access config and field metadata\nDESCRIPTION: Example showing how to replace the deprecated validator with field_validator and access configuration and field metadata using the ValidationInfo parameter in Pydantic V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int, info: ValidationInfo) -> int:\n        assert info.config is not None\n        print(info.config.get('title'))\n        #> Model\n        print(cls.model_fields[info.field_name].is_required())\n        #> True\n        return v\n\n\nModel(x=1)\n```\n\n----------------------------------------\n\nTITLE: Excluding Fields in Pydantic Model Export\nDESCRIPTION: Shows how to use the exclude parameter to control which fields are excluded when exporting a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str\n    age: int = Field(exclude=True)\n\n\nuser = User(name='John', age=42)\nprint(user.model_dump())  # (1)!\n#> {'name': 'John'}\n```\n\n----------------------------------------\n\nTITLE: Creating Self-Referencing Models with Pydantic in Python\nDESCRIPTION: This example shows how to create a self-referencing model in Pydantic using string-wrapped annotations. The Foo class has a 'sibling' field that references itself, demonstrating recursive model structure.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: int = 123\n    sibling: 'Optional[Foo]' = None\n\n\nprint(Foo())\n#> a=123 sibling=None\nprint(Foo(sibling={'a': '321'}))\n#> a=123 sibling=Foo(a=321, sibling=None)\n```\n\n----------------------------------------\n\nTITLE: Discriminated Unions in Pydantic\nDESCRIPTION: This example demonstrates discriminated unions in Pydantic, enabling efficient validation by selecting the appropriate union member based on a discriminator field (`pet_type`). The `Model` class contains a `pet` field, which is a Union of `Cat`, `Dog`, and `Lizard`.  The `discriminator='pet_type'` argument allows Pydantic to determine which model should be used based on the value of the `pet_type` field.  This approach avoids trying to validate against all union members, leading to improved performance and cleaner error reporting.  This requires the `Literal` type from the `typing` module and the `BaseModel`, `Field`, and `ValidationError` classes from the Pydantic library.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    meows: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    barks: float\n\n\nclass Lizard(BaseModel):\n    pet_type: Literal['reptile', 'lizard']\n    scales: bool\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog, Lizard] = Field(discriminator='pet_type')\n    n: int\n\n\nprint(Model(pet={'pet_type': 'dog', 'barks': 3.14}, n=1))\n#> pet=Dog(pet_type='dog', barks=3.14) n=1\ntry:\n    Model(pet={'pet_type': 'dog'}, n=1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.dog.barks\n      Field required [type=missing, input_value={'pet_type': 'dog'}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Field Validation with Pydantic Dataclasses\nDESCRIPTION: A basic example of using field_validator to validate and transform a product_id field in a Pydantic dataclass. The validator converts integer inputs to zero-padded five-digit strings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import field_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass DemoDataclass:\n    product_id: str  # should be a five-digit string, may have leading zeros\n\n    @field_validator('product_id', mode='before')\n    @classmethod\n    def convert_int_serial(cls, v):\n        if isinstance(v, int):\n            v = str(v).zfill(5)\n        return v\n\n\nprint(DemoDataclass(product_id='01234'))\n#> DemoDataclass(product_id='01234')\nprint(DemoDataclass(product_id=2468))\n#> DemoDataclass(product_id='02468')\n```\n\n----------------------------------------\n\nTITLE: Required and Optional Fields in Pydantic V2\nDESCRIPTION: Demonstrates the new behavior for required, optional, and nullable fields in Pydantic V2, which now matches more closely with dataclasses.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo(BaseModel):\n    f1: str  # required, cannot be None\n    f2: Optional[str]  # required, can be None - same as str | None\n    f3: Optional[str] = None  # not required, can be None\n    f4: str = 'Foobar'  # not required, but cannot be None\n\n\ntry:\n    Foo(f1=None, f2=None, f4='b')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    f1\n      Input should be a valid string [type=string_type, input_value=None, input_type=NoneType]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Custom Types with Pydantic\nDESCRIPTION: Demonstrates how to use TypeVars within Annotated types to create generic custom types. This example creates a ShortList type that limits list length and a PositiveList type that ensures all elements are positive.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Gt, Len\n\nfrom pydantic import TypeAdapter, ValidationError\n\nT = TypeVar('T')\n\n\nShortList = Annotated[list[T], Len(max_length=4)]\n\n\nta = TypeAdapter(ShortList[int])\n\nv = ta.validate_python([1, 2, 3, 4])\nassert v == [1, 2, 3, 4]\n\ntry:\n    ta.validate_python([1, 2, 3, 4, 5])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[int]\n      List should have at most 4 items after validation, not 5 [type=too_long, input_value=[1, 2, 3, 4, 5], input_type=list]\n    \"\"\"\n\n\nPositiveList = list[Annotated[T, Gt(0)]]\n\nta = TypeAdapter(PositiveList[float])\n\nv = ta.validate_python([1.0])\nassert type(v[0]) is float\n\n\ntry:\n    ta.validate_python([-1.0])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[constrained-float]\n    0\n      Input should be greater than 0 [type=greater_than, input_value=-1.0, input_type=float]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Tagged Union Pattern in Pydantic\nDESCRIPTION: Shows how to create a discriminated union with Pydantic models by using a field that indicates which type the object is. This pattern improves validation performance and provides better type safety.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Literal\n\nfrom pydantic import BaseModel, Field\n\n\nclass DivModel(BaseModel):\n    el_type: Literal['div'] = 'div'\n    class_name: str | None = None\n    children: list[Any] | None = None\n\n\nclass SpanModel(BaseModel):\n    el_type: Literal['span'] = 'span'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass ButtonModel(BaseModel):\n    el_type: Literal['button'] = 'button'\n    class_name: str | None = None\n    contents: str | None = None\n\n\nclass InputModel(BaseModel):\n    el_type: Literal['input'] = 'input'\n    class_name: str | None = None\n    value: str | None = None\n\n\nclass Html(BaseModel):\n    contents: DivModel | SpanModel | ButtonModel | InputModel = Field(\n        discriminator='el_type'\n    )\n```\n\n----------------------------------------\n\nTITLE: Using PydanticUseDefault with BeforeValidator\nDESCRIPTION: Shows how to use PydanticUseDefault to notify Pydantic that the default value should be used when a certain condition is met, such as when the input value is None.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import PydanticUseDefault\n\nfrom pydantic import BaseModel, BeforeValidator\n\n\ndef default_if_none(value: Any) -> Any:\n    if value is None:\n        raise PydanticUseDefault()\n    return value\n\n\nclass Model(BaseModel):\n    name: Annotated[str, BeforeValidator(default_if_none)] = 'default_name'\n\n\nprint(Model(name=None))\n#> name='default_name'\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Argument Validation with Schema Generation (Python)\nDESCRIPTION: This code demonstrates how to validate arguments of a callable using `generate_arguments_schema`. It creates a core schema that can be used with `SchemaValidator` to validate arguments from JSON data. Dependencies: `pydantic_core`, `pydantic.experimental.arguments_schema`.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\narguments_schema = generate_arguments_schema(func=func)\n\nval = SchemaValidator(arguments_schema, config={'coerce_numbers_to_str': True})\n\nargs, kwargs = val.validate_json(\n    '{\"p\": true, \"args\": [\"arg1\", 1], \"kwargs\": {\"extra\": 1}}'\n)\nprint(args, kwargs)  # (1)!\n#> (True, 'arg1', '1') {'extra': 1}\n```\n\n----------------------------------------\n\nTITLE: Handling Cyclic References in Pydantic Validation\nDESCRIPTION: This snippet demonstrates how Pydantic handles cyclic references during validation. It shows the creation of two models with circular dependencies and how Pydantic raises a ValidationError instead of a RecursionError when encountering cyclic data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass ModelA(BaseModel):\n    b: 'Optional[ModelB]' = None\n\n\nclass ModelB(BaseModel):\n    a: Optional[ModelA] = None\n\n\ncyclic_data = {}\ncyclic_data['a'] = {'b': cyclic_data}\nprint(cyclic_data)\n#> {'a': {'b': {...}}}\n\ntry:\n    ModelB.model_validate(cyclic_data)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for ModelB\n    a.b\n      Recursion error - cyclic reference detected [type=recursion_loop, input_value={'a': {'b': {...}}}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Custom Error Types in Pydantic Validators in Python\nDESCRIPTION: This code snippet demonstrates raising custom validation errors using PydanticCustomError in a field validator. It creates a specialized error type with a custom error code and formatted message including dynamic data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import PydanticCustomError\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x', mode='after')\n    @classmethod\n    def validate_x(cls, v: int) -> int:\n        if v % 42 == 0:\n            raise PydanticCustomError(\n                'the_answer_error',\n                '{number} is the answer!',\n                {'number': v},\n            )\n        return v\n\n\ntry:\n    Model(x=42 * 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      84 is the answer! [type=the_answer_error, input_value=84, input_type=int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Constraining Decimal Fields in Pydantic Models\nDESCRIPTION: Demonstrates how to use max_digits and decimal_places constraints on Decimal fields in a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    precise: Decimal = Field(max_digits=5, decimal_places=2)\n\n\nfoo = Foo(precise=Decimal('123.45'))\nprint(foo)\n#> precise=Decimal('123.45')\n```\n\n----------------------------------------\n\nTITLE: Error Handling in Pydantic Validation\nDESCRIPTION: Shows how Pydantic handles validation errors by raising a ValidationError exception that contains information about all errors found during validation, even when multiple errors occur.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    list_of_ints: list[int]\n    a_float: float\n\n\ndata = dict(\n    list_of_ints=['1', 2, 'bad'],\n    a_float='not a float',\n)\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Model\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Adding Validators to Dynamically Created Models\nDESCRIPTION: Demonstrates how to add validator functions to dynamically created models using the __validators__ argument. Shows how to create a validator for a username field that checks if the value is alphanumeric.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, create_model, field_validator\n\n\ndef alphanum(cls, v):\n    assert v.isalnum(), 'must be alphanumeric'\n    return v\n\n\nvalidators = {\n    'username_validator': field_validator('username')(alphanum)  # (1)!\n}\n\nUserModel = create_model(\n    'UserModel', username=(str, ...), __validators__=validators\n)\n\nuser = UserModel(username='scolvin')\nprint(user)\n#> username='scolvin'\n\ntry:\n    UserModel(username='scolvi%n')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for UserModel\n    username\n      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Numeric Constraints in Pydantic Models\nDESCRIPTION: Demonstrates various numeric constraints including greater than, less than, multiple of, and infinity handling using Field parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Foo(BaseModel):\n    positive: int = Field(gt=0)\n    non_negative: int = Field(ge=0)\n    negative: int = Field(lt=0)\n    non_positive: int = Field(le=0)\n    even: int = Field(multiple_of=2)\n    love_for_pydantic: float = Field(allow_inf_nan=True)\n\nfoo = Foo(\n    positive=1,\n    non_negative=0,\n    negative=-1,\n    non_positive=0,\n    even=2,\n    love_for_pydantic=float('inf'),\n)\nprint(foo)\n```\n\n----------------------------------------\n\nTITLE: Implementing MacAddress Type Class in Python\nDESCRIPTION: Defines a MacAddress class that extends str, with validation for different MAC address formats. It includes validation functions, formatting methods, and supports conversion between various representations of MAC addresses including EUI-48 and EUI-64 standards.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_mac_address.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nimport re\nfrom functools import lru_cache\nfrom typing import Any, Callable, ClassVar, Dict, Literal, Pattern, Union, cast\n\nfrom typing_extensions import Self\n\nfrom pydantic_core import PydanticCustomError, core_schema\n\n\nclass MacAddress(str):\n    \"\"\"Validate and standardize IEEE 802 MAC (layer 2) addresses.\n\n    Supports both EUI-48 (\"MAC-48\") and EUI-64 addresses, and the following formats:\n    - with or without separators\n    - with the following separators: colon, dash, dot (and dot with 4-character long parts)\n\n    EUI-48 addresses are also known as MAC-48 (which is actually not a standard), see IEEE 802-2001.\n\n    Usage:\n        >>> addr = MacAddress('00:00:5e:00:53:01')\n        >>> str(addr)\n        '00:00:5e:00:53:01'\n        >>> addr.format('dash')\n        '00-00-5e-00-53-01'\n        >>> addr.format('none')\n        '00005e005301'\n    \"\"\"\n\n    __slots__ = ()\n\n    # Regular expressions for different MAC address formats\n    # Re-using pre-compiled regexp patterns is (usually) more efficient\n\n    # EUI-48 / MAC-48 addresses\n    _formats_48: ClassVar[Dict[str, Pattern[str]]] = {\n        # 00:00:5e:00:53:01\n        'colon': re.compile(r'^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$'),\n        # 00-00-5e-00-53-01\n        'dash': re.compile(r'^([0-9a-fA-F]{2}-){5}[0-9a-fA-F]{2}$'),\n        # 0000.5e00.5301\n        'dot': re.compile(r'^([0-9a-fA-F]{4}\\.){2}[0-9a-fA-F]{4}$'),\n        # 00005e005301\n        'none': re.compile(r'^[0-9a-fA-F]{12}$'),\n    }\n\n    # EUI-64 addresses\n    _formats_64: ClassVar[Dict[str, Pattern[str]]] = {\n        # 00:00:5e:00:53:01:00:00\n        'colon': re.compile(r'^([0-9a-fA-F]{2}:){7}[0-9a-fA-F]{2}$'),\n        # 00-00-5e-00-53-01-00-00\n        'dash': re.compile(r'^([0-9a-fA-F]{2}-){7}[0-9a-fA-F]{2}$'),\n        # 0000.5e00.5301.0000\n        'dot': re.compile(r'^([0-9a-fA-F]{4}\\.){3}[0-9a-fA-F]{4}$'),\n        # 00005e0053010000\n        'none': re.compile(r'^[0-9a-fA-F]{16}$'),\n    }\n\n    # These string formats are used to convert a numeric representation to string\n    _default_formats_48 = {\n        'colon': ':'.join(['%02x'] * 6),\n        'dash': '-'.join(['%02x'] * 6),\n        'dot': '.'.join(['%04x%04x', '%04x%04x', '%04x%04x']),\n        'none': '%02x' * 6,\n    }\n\n    _default_formats_64 = {\n        'colon': ':'.join(['%02x'] * 8),\n        'dash': '-'.join(['%02x'] * 8),\n        'dot': '.'.join(['%04x%04x', '%04x%04x', '%04x%04x', '%04x%04x']),\n        'none': '%02x' * 8,\n    }\n\n    _numeric_format = ''.join(['%02x'] * 6)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, _source_type: Any, _handler: Callable[[Any], core_schema.CoreSchema]\n    ) -> core_schema.CoreSchema:\n        return core_schema.union_schema(\n            [\n                core_schema.is_instance_schema(cls),\n                core_schema.chain_schema(\n                    [\n                        core_schema.string_schema(),\n                        core_schema.no_info_plain_validator_function(cls.validate),\n                    ]\n                ),\n            ],\n            serialization=core_schema.to_string_serializer(),\n        )\n\n    @classmethod\n    def validate(cls, __input_value: str) -> Self:\n        value = str(__input_value).strip().lower()\n\n        # Length-based detection of the address type\n        eui48 = True\n\n        if not value:\n            raise PydanticCustomError('mac_address', 'MAC address cannot be empty')\n\n        for sep, pattern in cls._formats_48.items():\n            if pattern.match(value):\n                break\n        else:\n            eui48 = False\n            for sep, pattern in cls._formats_64.items():\n                if pattern.match(value):\n                    break\n            else:\n                raise PydanticCustomError('mac_address', 'Value is not a valid MAC address')\n\n        # In most cases, users expect the \"canonical format\" of MAC addresses,\n        # which uses colons as separators.\n        if sep != 'colon':\n            if sep == 'none':\n                if eui48:\n                    # 00005e005301 -> 00:00:5e:00:53:01\n                    value = ':'.join(value[i : i + 2] for i in range(0, 12, 2))\n                else:\n                    # 00005e0053010000 -> 00:00:5e:00:53:01:00:00\n                    value = ':'.join(value[i : i + 2] for i in range(0, 16, 2))\n            elif sep == 'dash':\n                # 00-00-5e-00-53-01 -> 00:00:5e:00:53:01\n                value = value.replace('-', ':')\n            elif sep == 'dot':\n                # 0000.5e00.5301 -> 00:00:5e:00:53:01\n                if eui48:\n                    x = value.split('.')\n                    value = ':'.join(\n                        [\n                            x[0][0:2],\n                            x[0][2:4],\n                            x[1][0:2],\n                            x[1][2:4],\n                            x[2][0:2],\n                            x[2][2:4],\n                        ]\n                    )\n                else:\n                    x = value.split('.')\n                    value = ':'.join(\n                        [\n                            x[0][0:2],\n                            x[0][2:4],\n                            x[1][0:2],\n                            x[1][2:4],\n                            x[2][0:2],\n                            x[2][2:4],\n                            x[3][0:2],\n                            x[3][2:4],\n                        ]\n                    )\n\n        return cast(Self, cls(value))\n\n    def format(self, fmt: Union[Literal['colon', 'dash', 'dot', 'none'], str] = 'colon') -> str:\n        \"\"\"Format the MAC address.\n\n        Args:\n            fmt: Format to use. Default: 'colon'.\n                - colon: 00:00:5e:00:53:01 (canonical format)\n                - dash: 00-00-5e-00-53-01\n                - dot: 0000.5e00.5301\n                - none: 00005e005301\n\n        Returns:\n            str: Formatted MAC address.\n        \"\"\"\n        addr_str = self.lower()\n        # Canonical format is 00:00:5e:00:53:01\n        if fmt == 'colon':\n            return addr_str\n\n        is_eui48 = True if addr_str.count(':') == 5 else False\n\n        # Convert to byte array without separators first\n        addr_bytes = bytearray.fromhex(addr_str.replace(':', ''))\n\n        # Get the right format\n        if is_eui48:\n            format_template = self._default_formats_48.get(fmt, self._default_formats_48['colon'])\n            num_bytes = 6\n        else:\n            format_template = self._default_formats_64.get(fmt, self._default_formats_64['colon'])\n            num_bytes = 8\n\n        return format_template % tuple(addr_bytes[0:num_bytes])\n\n    @property\n    @lru_cache()\n    def is_eui48(self) -> bool:\n        \"\"\"Check if the MAC address is EUI-48 (MAC-48).\n\n        Returns:\n            bool: True if EUI-48, False otherwise.\n        \"\"\"\n        return self.count(':') == 5\n\n    @property\n    @lru_cache()\n    def is_eui64(self) -> bool:\n        \"\"\"Check if the MAC address is EUI-64.\n\n        Returns:\n            bool: True if EUI-64, False otherwise.\n        \"\"\"\n        return self.count(':') == 7\n```\n\n----------------------------------------\n\nTITLE: Pickling Pydantic Models\nDESCRIPTION: Demonstrates how to serialize and deserialize Pydantic models using Python's pickle module. Pydantic models support efficient pickling and unpickling for storage or transmission.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport pickle\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel):\n    a: str\n    b: int\n\n\nm = FooBarModel(a='hello', b=123)\nprint(m)\n#> a='hello' b=123\ndata = pickle.dumps(m)\nprint(data[:20])\n#> b'\\x80\\x04\\x95\\x95\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main_'\nm2 = pickle.loads(data)\nprint(m2)\n#> a='hello' b=123\n```\n\n----------------------------------------\n\nTITLE: Demonstrating changes in JSON serialization between V1 and V2\nDESCRIPTION: Example showing the difference in JSON serialization of None keys in dictionaries between Pydantic V1 and V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: dict[Optional[str], int]\n\n\nclass V2Model(V2BaseModel):\n    a: dict[Optional[str], int]\n\n\nv1_model = V1Model(a={None: 123})\nv2_model = V2Model(a={None: 123})\n\n# V1\nprint(v1_model.json())\n#> {\"a\": {\"null\": 123}}\n```\n\n----------------------------------------\n\nTITLE: Complete Mypy Configuration with Pydantic Plugin in pyproject.toml\nDESCRIPTION: Comprehensive mypy configuration with the Pydantic plugin enabled and all strictness flags set to true, specified in pyproject.toml format, including Pydantic-specific configuration options.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#2025-04-22_snippet_4\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = [\"pydantic.mypy\"]\n\nfollow_imports = \"silent\"\nwarn_redundant_casts = true\nwarn_unused_ignores = true\ndisallow_any_generics = true\nno_implicit_reexport = true\ndisallow_untyped_defs = true\n\n[tool.pydantic-mypy]\ninit_forbid_extra = true\ninit_typed = true\nwarn_required_dynamic_aliases = true\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Models with Validation Context in Python\nDESCRIPTION: Shows an alternative approach to validate nested model fields using validation context. This method passes the forbidden passwords from the parent model to the nested User model via context, allowing field-level validation on the nested model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/custom_validators.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError, ValidationInfo, field_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n    @field_validator('password', mode='after')\n    @classmethod\n    def validate_user_passwords(\n        cls, password: str, info: ValidationInfo\n    ) -> str:\n        \"\"\"Check that user password is not in forbidden list.\"\"\"\n        forbidden_passwords = (\n            info.context.get('forbidden_passwords', []) if info.context else []\n        )\n        if password in forbidden_passwords:\n            raise ValueError(f'Password {password} is forbidden.')\n        return password\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @field_validator('forbidden_passwords', mode='after')\n    @classmethod\n    def add_context(cls, v: list[str], info: ValidationInfo) -> list[str]:\n        if info.context is not None:\n            info.context.update({'forbidden_passwords': v})\n        return v\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\n\ntry:\n    org = Organization.model_validate(data, context={})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n    users.0.password\n      Value error, Password 123 is forbidden. [type=value_error, input_value='123', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Validating Arguments Before Function Call in Python using Pydantic\nDESCRIPTION: This example demonstrates how to separate validation of a function's arguments from the function call itself using Pydantic's validate_call decorator. This pattern is useful when the actual function execution is costly or time-consuming.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef validate_foo(a: int, b: int):\n    def foo():\n        return a + b\n\n    return foo\n\n\nfoo = validate_foo(a=1, b=2)\nprint(foo())\n#> 3\n```\n\n----------------------------------------\n\nTITLE: Dictionary Validation in Pydantic Models\nDESCRIPTION: Shows how Pydantic validates dictionary types with specific key and value types, raising validation errors for non-compliant inputs.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: dict[str, int]\n\n\nm = Model(x={'foo': 1})\nprint(m.model_dump())\n#> {'x': {'foo': 1}}\n\ntry:\n    Model(x={'foo': '1'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid dictionary [type=dict_type, input_value='test', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Custom Configuration with validate_call in Python\nDESCRIPTION: Demonstrates how to specify a custom configuration for the validate_call decorator, similar to Pydantic models, allowing for arbitrary types and custom validation behavior.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\nclass Foobar:\n    def __init__(self, v: str):\n        self.v = v\n\n    def __add__(self, other: 'Foobar') -> str:\n        return f'{self} + {other}'\n\n    def __str__(self) -> str:\n        return f'Foobar({self.v})'\n\n\n@validate_call(config=ConfigDict(arbitrary_types_allowed=True))\ndef add_foobars(a: Foobar, b: Foobar):\n    return a + b\n\n\nc = add_foobars(Foobar('a'), Foobar('b'))\nprint(c)\n#> Foobar(a) + Foobar(b)\n\ntry:\n    add_foobars(1, 2)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for add_foobars\n    0\n      Input should be an instance of Foobar [type=is_instance_of, input_value=1, input_type=int]\n    1\n      Input should be an instance of Foobar [type=is_instance_of, input_value=2, input_type=int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Error Messages in Pydantic\nDESCRIPTION: Demonstrates how to create a custom error handler that replaces default Pydantic validation error messages with custom messages. The example includes handling of both simple messages and messages with format parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import ErrorDetails\n\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nCUSTOM_MESSAGES = {\n    'int_parsing': 'This is not an integer! 🤦',\n    'url_scheme': 'Hey, use the right URL scheme! I wanted {expected_schemes}.',\n}\n\n\ndef convert_errors(\n    e: ValidationError, custom_messages: dict[str, str]\n) -> list[ErrorDetails]:\n    new_errors: list[ErrorDetails] = []\n    for error in e.errors():\n        custom_message = custom_messages.get(error['type'])\n        if custom_message:\n            ctx = error.get('ctx')\n            error['msg'] = (\n                custom_message.format(**ctx) if ctx else custom_message\n            )\n        new_errors.append(error)\n    return new_errors\n\n\nclass Model(BaseModel):\n    a: int\n    b: HttpUrl\n\n\ntry:\n    Model(a='wrong', b='ftp://example.com')\nexcept ValidationError as e:\n    errors = convert_errors(e, CUSTOM_MESSAGES)\n    print(errors)\n```\n\n----------------------------------------\n\nTITLE: Merging Configurations in Pydantic Subclasses in Python\nDESCRIPTION: Shows how configurations are merged when a subclass provides its own configuration. The subclass configuration overrides the parent configuration for overlapping options.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow', str_to_lower=False)\n\n\nclass Model(Parent):\n    model_config = ConfigDict(str_to_lower=True)\n\n    x: str\n\n\nm = Model(x='FOO', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\nprint(Model.model_config)\n#> {'extra': 'allow', 'str_to_lower': True}\n```\n\n----------------------------------------\n\nTITLE: Validating default values in Pydantic\nDESCRIPTION: Shows how to enable validation for default values using the validate_default parameter, which is disabled by default.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    age: int = Field(default='twelve', validate_default=True)\n\n\ntry:\n    user = User()\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    age\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='twelve', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using model_title_generator to customize model titles in Python with Pydantic\nDESCRIPTION: This example demonstrates how to use the model_title_generator parameter in Pydantic's ConfigDict to customize the title of a model in the generated JSON schema. The function takes the model class as input and returns a custom title string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\ndef make_title(model: type) -> str:\n    return f'Title-{model.__name__}'\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(model_title_generator=make_title)\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"Name\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"Age\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Title-Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using json_schema_extra with a Dict in Pydantic Models\nDESCRIPTION: Demonstrates adding extra information to the JSON schema at the model level by passing a dictionary to json_schema_extra in model_config.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    a: str\n\n    model_config = ConfigDict(json_schema_extra={'examples': [{'a': 'Foo'}]})\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"examples\": [\n    {\n      \"a\": \"Foo\"\n    }\n  ],\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"string\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Concrete Collection Types in Pydantic Models\nDESCRIPTION: Demonstrates how Pydantic automatically converts compatible collection types, such as converting a tuple to a list when a field is typed as list[int]. This behavior makes it unnecessary to use abstract container types in most cases.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    items: list[int]  # (1)!\n\n\nprint(Model(items=(1, 2, 3)))\n#> items=[1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Set Validation in Pydantic Models\nDESCRIPTION: Shows how to validate both simple sets and typed sets in Pydantic, demonstrating automatic conversion from lists and type validation of items.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional, Set\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_set: Optional[set] = None\n    set_of_ints: Optional[Set[int]] = None\n\n\nprint(Model(simple_set={'1', '2', '3'}).simple_set)\n#> {'1', '2', '3'}\nprint(Model(simple_set=['1', '2', '3']).simple_set)\n#> {'1', '2', '3'}\nprint(Model(set_of_ints=['1', '2', '3']).set_of_ints)\n#> {1, 2, 3}\n```\n\n----------------------------------------\n\nTITLE: Comparing Strict and Lax Mode Validation in Python\nDESCRIPTION: This snippet demonstrates the difference between strict and lax mode validation in Pydantic, showing how lax mode allows type coercion while strict mode raises a ValidationError for mismatched types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\nclass MyModel(BaseModel):\n    x: int\n\nprint(MyModel.model_validate({'x': '123'}))  # lax mode\n#> x=123\n\ntry:\n    MyModel.model_validate({'x': '123'}, strict=True)  # strict mode\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyModel\n    x\n      Input should be a valid integer [type=int_type, input_value='123', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Specifying JSON Schema Input Types in Field Validators\nDESCRIPTION: Shows how to explicitly specify the expected JSON schema input type for a field with a validator. This example declares that a string field can also accept integers as input.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator(\n        'value', mode='before', json_schema_input_type=Union[int, str]\n    )\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model.model_json_schema()['properties']['value'])\n#> {'anyOf': [{'type': 'integer'}, {'type': 'string'}], 'title': 'Value'}\n```\n\n----------------------------------------\n\nTITLE: Basic Usage of validate_call Decorator in Python\nDESCRIPTION: Demonstrates how to use the validate_call decorator to validate function arguments. In this example, it validates that x is an integer and s is a string, raising an error for invalid inputs.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/validate_call.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n@validate_call\ndef foo(x: int, s: str) -> str:\n    return s * x\n```\n\n----------------------------------------\n\nTITLE: Partial Validation with TypeAdapter Python\nDESCRIPTION: This code shows how to use `TypeAdapter` with the `experimental_allow_partial` flag to validate JSON and Python objects. It demonstrates various scenarios including missing optional fields, truncated strings, and how the validator handles invalid data in the last element.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict):  # (1)!\n    a: int\n    b: NotRequired[float]\n    c: NotRequired[Annotated[str, MinLen(5)]]\n\nta = TypeAdapter(list[Foobar])\n\nv = ta.validate_json('[{\"a\": 1, \"b\"', experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcd', experimental_allow_partial=True  # (3)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"b\": 1.0, \"c\": \"abcde\"', experimental_allow_partial=True  # (4)!\n)\nprint(v)\n#> []\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcde\"},{\"a\": ', experimental_allow_partial=True\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcde'}]\n\nv = ta.validate_python([{'a': 1}], experimental_allow_partial=True)  # (5)!\nprint(v)\n#> [{'a': 1}]\n\nv = ta.validate_python(\n    [{'a': 1, 'b': 1.0, 'c': 'abcd'}], experimental_allow_partial=True  # (6)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0}]\n\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": 1.0, \"c\": \"abcdefg', \n    experimental_allow_partial='trailing-strings',  # (7)!\n)\nprint(v)\n#> [{'a': 1, 'b': 1.0, 'c': 'abcdefg'}]\n```\n\n----------------------------------------\n\nTITLE: Field-Level Exclude vs Exclude Parameters\nDESCRIPTION: Demonstrates how Field exclude settings interact with exclude_none, exclude_unset, and exclude_default parameters. These parameters take precedence over Field-level exclude settings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\n\n\nclass Person(BaseModel):\n    name: str\n    age: Optional[int] = Field(None, exclude=False)\n\n\nperson = Person(name='Jeremy')\n\nprint(person.model_dump())\n#> {'name': 'Jeremy', 'age': None}\nprint(person.model_dump(exclude_none=True))  # (1)!\n#> {'name': 'Jeremy'}\nprint(person.model_dump(exclude_unset=True))  # (2)!\n#> {'name': 'Jeremy'}\nprint(person.model_dump(exclude_defaults=True))  # (3)!\n#> {'name': 'Jeremy'}\n```\n\n----------------------------------------\n\nTITLE: Using AliasPath for Field Validation in Python with Pydantic\nDESCRIPTION: Demonstrates the use of AliasPath to specify a path to a field using aliases in a Pydantic model. It shows how to access nested data using indices.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasPath\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasPath('names', 0))\n    last_name: str = Field(validation_alias=AliasPath('names', 1))\n\nuser = User.model_validate({'names': ['John', 'Doe']})  # (1)!\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Decimal Type Handling with Custom Serialization\nDESCRIPTION: Shows Decimal type validation and custom serialization options in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, PlainSerializer\n\n\nclass Model(BaseModel):\n    x: Decimal\n    y: Annotated[\n        Decimal,\n        PlainSerializer(\n            lambda x: float(x), return_type=float, when_used='json'\n        ),\n    ]\n\n\nmy_model = Model(x=Decimal('1.1'), y=Decimal('2.1'))\n\nprint(my_model.model_dump())\n#> {'x': Decimal('1.1'), 'y': Decimal('2.1')}\nprint(my_model.model_dump(mode='json'))\n#> {'x': '1.1', 'y': 2.1}\nprint(my_model.model_dump_json())\n#> {\"x\":\"1.1\",\"y\":2.1}\n```\n\n----------------------------------------\n\nTITLE: Copying Pydantic Models with model_copy\nDESCRIPTION: Demonstrates how to create copies of Pydantic models with optional updates. Shows the difference between regular and deep copying, particularly with respect to nested model references.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass BarModel(BaseModel):\n    whatever: int\n\n\nclass FooBarModel(BaseModel):\n    banana: float\n    foo: str\n    bar: BarModel\n\n\nm = FooBarModel(banana=3.14, foo='hello', bar={'whatever': 123})\n\nprint(m.model_copy(update={'banana': 0}))\n#> banana=0 foo='hello' bar=BarModel(whatever=123)\nprint(id(m.bar) == id(m.model_copy().bar))\n#> True\n# normal copy gives the same object reference for bar\nprint(id(m.bar) == id(m.model_copy(deep=True).bar))\n#> False\n# deep copy gives a new object reference for `bar`\n```\n\n----------------------------------------\n\nTITLE: Validating Nested Models with Parent Model Data using Model Validator in Python\nDESCRIPTION: Demonstrates how to validate fields of nested models using data from the parent model. This example validates that user passwords are not in a list of forbidden passwords specified by the organization model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/custom_validators.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ValidationError, model_validator\n\n\nclass User(BaseModel):\n    username: str\n    password: str\n\n\nclass Organization(BaseModel):\n    forbidden_passwords: list[str]\n    users: list[User]\n\n    @model_validator(mode='after')\n    def validate_user_passwords(self) -> Self:\n        \"\"\"Check that user password is not in forbidden list. Raise a validation error if a forbidden password is encountered.\"\"\"\n        for user in self.users:\n            current_pw = user.password\n            if current_pw in self.forbidden_passwords:\n                raise ValueError(\n                    f'Password {current_pw} is forbidden. Please choose another password for user {user.username}.'\n                )\n        return self\n\n\ndata = {\n    'forbidden_passwords': ['123'],\n    'users': [\n        {'username': 'Spartacat', 'password': '123'},\n        {'username': 'Iceburgh', 'password': '87'},\n    ],\n}\ntry:\n    org = Organization(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Organization\n      Value error, Password 123 is forbidden. Please choose another password for user Spartacat. [type=value_error, input_value={'forbidden_passwords': [...gh', 'password': '87'}]}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Basic Pydantic Dataclass Usage with Validation\nDESCRIPTION: Demonstrates how to create a simple Pydantic dataclass with automatic type validation. The example shows how string values are converted to their appropriate types (int, datetime) during initialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    signup_ts: Optional[datetime] = None\n\n\nuser = User(id='42', signup_ts='2032-06-21T12:00')\nprint(user)\n\"\"\"\nUser(id=42, name='John Doe', signup_ts=datetime.datetime(2032, 6, 21, 12, 0))\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Subclass Instances of BaseModel in Python\nDESCRIPTION: Demonstrates how Pydantic serializes subclass instances of BaseModel, including only fields from the annotated type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass UserLogin(User):\n    password: str\n\n\nclass OuterModel(BaseModel):\n    user: User\n\n\nuser = UserLogin(name='pydantic', password='hunter2')\n\nm = OuterModel(user=user)\nprint(m)\n#> user=UserLogin(name='pydantic', password='hunter2')\nprint(m.model_dump())  # note: the password field is not included\n#> {'user': {'name': 'pydantic'}}\n```\n\n----------------------------------------\n\nTITLE: Using SerializeAsAny with Generic Type Variables\nDESCRIPTION: Shows how to use SerializeAsAny to change serialization behavior when using TypeVar with default values or constraints. Compares standard serialization (which uses the default's serializer) with SerializeAsAny serialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic\n\nfrom typing_extensions import TypeVar\n\nfrom pydantic import BaseModel, SerializeAsAny\n\n\nclass ErrorDetails(BaseModel):\n    foo: str\n\n\nErrorDataT = TypeVar('ErrorDataT', default=ErrorDetails)\n\n\nclass Error(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: ErrorDataT\n\n\nclass MyErrorDetails(ErrorDetails):\n    bar: str\n\n\n# serialized using the default's serializer\nerror = Error(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='var2'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n# If `ErrorDataT` was using an upper bound, `bar` would be present in `details`.\n\n\nclass SerializeAsAnyError(BaseModel, Generic[ErrorDataT]):\n    message: str\n    details: SerializeAsAny[ErrorDataT]\n\n\n# serialized as Any\nerror = SerializeAsAnyError(\n    message='We just had an error',\n    details=MyErrorDetails(foo='var', bar='baz'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n        'bar': 'baz',\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Using default_factory with validated data\nDESCRIPTION: Demonstrates how default_factory can access already validated data to generate a default value based on other fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, EmailStr, Field\n\n\nclass User(BaseModel):\n    email: EmailStr\n    username: str = Field(default_factory=lambda data: data['email'])\n\n\nuser = User(email='user@example.com')\nprint(user.username)\n#> user@example.com\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Type Aliases with TypeAliasType (Python 3.9+)\nDESCRIPTION: Defines a recursive JSON type that can represent nested JSON structures, using forward reference with string annotation to handle the recursion.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import TypeAdapter\n\nJson = TypeAliasType(\n    'Json',\n    'Union[dict[str, Json], list[Json], str, int, float, bool, None]',  # (1)!\n)\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: TypedDict Validation with Pydantic\nDESCRIPTION: Demonstrates how Pydantic validates TypedDict objects, ensuring all required fields are present with correct types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nta = TypeAdapter(User)\n\nprint(ta.validate_python({'name': 'foo', 'id': 1}))\n#> {'name': 'foo', 'id': 1}\n\ntry:\n    ta.validate_python({'name': 'foo'})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    id\n      Field required [type=missing, input_value={'name': 'foo'}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using json_schema_extra with a Callable in Pydantic Fields\nDESCRIPTION: Shows how to use a callable function with json_schema_extra to dynamically modify the JSON schema, in this case removing the default value from the schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, Field\n\n\ndef pop_default(s):\n    s.pop('default')\n\n\nclass Model(BaseModel):\n    a: int = Field(default=1, json_schema_extra=pop_default)\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"a\": {\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON with Strict Mode in Pydantic\nDESCRIPTION: Demonstrates JSON parsing using Pydantic's model_validate_json method with strict mode enabled. Shows how Pydantic handles JSON input differently from dict input when strict mode is on.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Event(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    when: date\n    where: tuple[int, int]\n\n\njson_data = '{\"when\": \"1987-01-28\", \"where\": [51, -1]}'\nprint(Event.model_validate_json(json_data))  # (1)!\n#> when=datetime.date(1987, 1, 28) where=(51, -1)\n\ntry:\n    Event.model_validate({'when': '1987-01-28', 'where': [51, -1]})  # (2)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Event\n    when\n      Input should be a valid date [type=date_type, input_value='1987-01-28', input_type=str]\n    where\n      Input should be a valid tuple [type=tuple_type, input_value=[51, -1], input_type=list]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Serializing Pydantic Model with Alias in Python\nDESCRIPTION: Demonstrates how to enable serialization by alias in a Pydantic model using ConfigDict. The example shows that when serialize_by_alias is set to True, the model_dump() method uses the specified alias for serialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\n    model_config = ConfigDict(serialize_by_alias=True)\n\nm = Model(my_field='foo')\nprint(m.model_dump())  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n----------------------------------------\n\nTITLE: Proper Implementation of Class Extensions in Pydantic\nDESCRIPTION: Demonstrates the recommended approach of using Pydantic models instead of subclassing primitive types, which provides better type checking and validation capabilities.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass CompletedStr(str):\n    def __init__(self, s: str):\n        self.s = s\n        self.done = False\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass CompletedModel(BaseModel):\n    s: str\n    done: bool = False\n```\n\n----------------------------------------\n\nTITLE: Implementing Strict Mode in Pydantic Fields\nDESCRIPTION: Shows how to use the strict parameter to enforce strict validation on specific fields in a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(strict=True)\n    age: int = Field(strict=False)  # (1)!\n\n\nuser = User(name='John', age='42')  # (2)!\nprint(user)\n#> name='John' age=42\n```\n\n----------------------------------------\n\nTITLE: Using Structural Pattern Matching with Pydantic Models\nDESCRIPTION: This example shows how to use Python 3.10+ structural pattern matching with Pydantic models, allowing for elegant attribute matching and extraction.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Pet(BaseModel):\n    name: str\n    species: str\n\n\na = Pet(name='Bones', species='dog')\n\nmatch a:\n    # match `species` to 'dog', declare and initialize `dog_name`\n    case Pet(species='dog', name=dog_name):\n        print(f'{dog_name} is a dog')\n#> Bones is a dog\n    # default case\n    case _:\n        print('No dog matched')\n```\n\n----------------------------------------\n\nTITLE: Using TypeAdapter for Non-BaseModel Validation in Pydantic V2\nDESCRIPTION: Demonstrates the new TypeAdapter class which provides a cleaner way to validate, serialize, and produce JSON schemas for arbitrary types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\nassert adapter.validate_python(['1', '2', '3']) == [1, 2, 3]\nprint(adapter.json_schema())\n#> {'items': {'type': 'integer'}, 'type': 'array'}\n```\n\n----------------------------------------\n\nTITLE: Importing validate_call Decorator in Python\nDESCRIPTION: Shows how to import the validate_call decorator from Pydantic. This decorator is used to validate function arguments against their type annotations at runtime.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/validate_call.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n```\n\n----------------------------------------\n\nTITLE: Configuring BaseModel Documentation Options in YAML\nDESCRIPTION: YAML configuration block specifying documentation options for the BaseModel class, including member ordering, display settings, and included methods.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/base_model.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\noptions:\n    show_root_heading: true\n    merge_init_into_class: false\n    group_by_category: false\n    # explicit members list so we can set order and include `__init__` easily\n    members:\n      - __init__\n      - model_config\n      - model_fields\n      - model_computed_fields\n      - __pydantic_core_schema__\n      - model_extra\n      - model_fields_set\n      - model_construct\n      - model_copy\n      - model_dump\n      - model_dump_json\n      - model_json_schema\n      - model_parametrized_name\n      - model_post_init\n      - model_rebuild\n      - model_validate\n      - model_validate_json\n      - model_validate_strings\n```\n\n----------------------------------------\n\nTITLE: Implementing a String Truncation Validator with Annotated Pattern in Python\nDESCRIPTION: This code snippet demonstrates implementing a wrap validator with the Annotated pattern in Pydantic. It creates a custom validator function that truncates strings exceeding maximum length rather than raising an error.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, WrapValidator\n\n\ndef truncate(value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n    try:\n        return handler(value)\n    except ValidationError as err:\n        if err.errors()[0]['type'] == 'string_too_long':\n            return handler(value[:5])\n        else:\n            raise\n\n\nclass Model(BaseModel):\n    my_string: Annotated[str, Field(max_length=5), WrapValidator(truncate)]\n\n\nprint(Model(my_string='abcde'))\n#> my_string='abcde'\nprint(Model(my_string='abcdef'))\n#> my_string='abcde'\n```\n\n----------------------------------------\n\nTITLE: Boolean Validation in Pydantic Models\nDESCRIPTION: Demonstrates boolean field validation in Pydantic models, showing various input types that can be converted to booleans and validation error handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass BooleanModel(BaseModel):\n    bool_value: bool\n\n\nprint(BooleanModel(bool_value=False))\n#> bool_value=False\nprint(BooleanModel(bool_value='False'))\n#> bool_value=False\nprint(BooleanModel(bool_value=1))\n#> bool_value=True\ntry:\n    BooleanModel(bool_value=[])\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for BooleanModel\n    bool_value\n      Input should be a valid boolean [type=bool_type, input_value=[], input_type=list]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Checking Python Version Compatibility in Lambda\nDESCRIPTION: Python code to verify that the Lambda's Python version is compatible with the installed compiled library version. This helps ensure that the correct native code is installed for the Lambda's target platform.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport sysconfig\nprint(sysconfig.get_config_var(\"EXT_SUFFIX\"))\n#> '.cpython-312-x86_64-linux-gnu.so'\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with UUID from JSON and Python\nDESCRIPTION: This example shows how strict mode validation behaves differently when validating UUID fields from JSON and Python inputs, demonstrating that string inputs are accepted from JSON but not from Python in strict mode.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyModel(BaseModel):\n    guid: UUID\n\ndata = {'guid': '12345678-1234-1234-1234-123456789012'}\n\nprint(MyModel.model_validate(data))  # OK: lax\n#> guid=UUID('12345678-1234-1234-1234-123456789012')\n\nprint(\n    MyModel.model_validate_json(json.dumps(data), strict=True)\n)  # OK: strict, but from json\n#> guid=UUID('12345678-1234-1234-1234-123456789012')\n\ntry:\n    MyModel.model_validate(data, strict=True)  # Not OK: strict, from python\nexcept ValidationError as exc:\n    print(exc.errors(include_url=False))\n    \"\"\"\n    [\n        {\n            'type': 'is_instance_of',\n            'loc': ('guid',),\n            'msg': 'Input should be an instance of UUID',\n            'input': '12345678-1234-1234-1234-123456789012',\n            'ctx': {'class': 'UUID'},\n        }\n    ]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Advanced Dynamic Model Creation with Annotations\nDESCRIPTION: Shows more advanced usage of create_model including Field with alias, Annotated fields with descriptions, and private attributes. Compares with equivalent static model definition.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, PrivateAttr, create_model\n\nDynamicModel = create_model(\n    'DynamicModel',\n    foo=(str, Field(alias='FOO')),\n    bar=Annotated[str, Field(description='Bar field')],\n    _private=(int, PrivateAttr(default=1)),\n)\n\n\nclass StaticModel(BaseModel):\n    foo: str = Field(alias='FOO')\n    bar: Annotated[str, Field(description='Bar field')]\n    _private: int = PrivateAttr(default=1)\n```\n\n----------------------------------------\n\nTITLE: Handling datetime_type Error in Pydantic\nDESCRIPTION: Shows validation error when an invalid type is provided for a datetime field\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_type'\n```\n\n----------------------------------------\n\nTITLE: Using Discriminator with Field Name in Pydantic Union\nDESCRIPTION: Shows how to use the discriminator parameter with a field name to distinguish between different models in a Union.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    age: int\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n\n\nprint(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}}))  # (1)!\n#> pet=Cat(pet_type='cat', age=12)\n```\n\n----------------------------------------\n\nTITLE: Defining CurrencyCode Enum in Python using ISO 4217 codes\nDESCRIPTION: This code snippet defines a CurrencyCode enum class using the Enum class from the enum module. It includes a comprehensive list of currency codes along with their names and symbols, following the ISO 4217 standard.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_currency_code.md#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom enum import Enum\n\nclass CurrencyCode(str, Enum):\n    \"\"\"Currency codes defined by ISO 4217\"\"\"\n\n    AED = \"AED\", \"United Arab Emirates dirham\", \"د.إ\"\n    AFN = \"AFN\", \"Afghan afghani\", \"؋\"\n    ALL = \"ALL\", \"Albanian lek\", \"L\"\n    AMD = \"AMD\", \"Armenian dram\", \"֏\"\n    ANG = \"ANG\", \"Netherlands Antillean guilder\", \"ƒ\"\n    AOA = \"AOA\", \"Angolan kwanza\", \"Kz\"\n    ARS = \"ARS\", \"Argentine peso\", \"$\"\n    AUD = \"AUD\", \"Australian dollar\", \"$\"\n    AWG = \"AWG\", \"Aruban florin\", \"ƒ\"\n    AZN = \"AZN\", \"Azerbaijani manat\", \"₼\"\n    BAM = \"BAM\", \"Bosnia and Herzegovina convertible mark\", \"KM\"\n    BBD = \"BBD\", \"Barbados dollar\", \"$\"\n    BDT = \"BDT\", \"Bangladeshi taka\", \"৳\"\n    BGN = \"BGN\", \"Bulgarian lev\", \"лв\"\n    BHD = \"BHD\", \"Bahraini dinar\", \".د.ب\"\n    BIF = \"BIF\", \"Burundian franc\", \"Fr\"\n    BMD = \"BMD\", \"Bermudian dollar\", \"$\"\n    BND = \"BND\", \"Brunei dollar\", \"$\"\n    BOB = \"BOB\", \"Boliviano\", \"Bs.\"\n    BRL = \"BRL\", \"Brazilian real\", \"R$\"\n    BSD = \"BSD\", \"Bahamian dollar\", \"$\"\n    BTN = \"BTN\", \"Bhutanese ngultrum\", \"Nu.\"\n    BWP = \"BWP\", \"Botswana pula\", \"P\"\n    BYN = \"BYN\", \"Belarusian ruble\", \"Br\"\n    BZD = \"BZD\", \"Belize dollar\", \"$\"\n    CAD = \"CAD\", \"Canadian dollar\", \"$\"\n    CDF = \"CDF\", \"Congolese franc\", \"Fr\"\n    CHF = \"CHF\", \"Swiss franc\", \"Fr\"\n    CLP = \"CLP\", \"Chilean peso\", \"$\"\n    CNY = \"CNY\", \"Renminbi\", \"¥\"\n    COP = \"COP\", \"Colombian peso\", \"$\"\n    CRC = \"CRC\", \"Costa Rican colon\", \"₡\"\n    CUC = \"CUC\", \"Cuban convertible peso\", \"$\"\n    CUP = \"CUP\", \"Cuban peso\", \"$\"\n    CVE = \"CVE\", \"Cape Verdean escudo\", \"$\"\n    CZK = \"CZK\", \"Czech koruna\", \"Kč\"\n    DJF = \"DJF\", \"Djiboutian franc\", \"Fr\"\n    DKK = \"DKK\", \"Danish krone\", \"kr\"\n    DOP = \"DOP\", \"Dominican peso\", \"$\"\n    DZD = \"DZD\", \"Algerian dinar\", \"د.ج\"\n    EGP = \"EGP\", \"Egyptian pound\", \"£\"\n    ERN = \"ERN\", \"Eritrean nakfa\", \"Nfk\"\n    ETB = \"ETB\", \"Ethiopian birr\", \"Br\"\n    EUR = \"EUR\", \"Euro\", \"€\"\n    FJD = \"FJD\", \"Fiji dollar\", \"$\"\n    FKP = \"FKP\", \"Falkland Islands pound\", \"£\"\n    GBP = \"GBP\", \"Pound sterling\", \"£\"\n    GEL = \"GEL\", \"Georgian lari\", \"₾\"\n    GHS = \"GHS\", \"Ghanaian cedi\", \"₵\"\n    GIP = \"GIP\", \"Gibraltar pound\", \"£\"\n    GMD = \"GMD\", \"Gambian dalasi\", \"D\"\n    GNF = \"GNF\", \"Guinean franc\", \"Fr\"\n    GTQ = \"GTQ\", \"Guatemalan quetzal\", \"Q\"\n    GYD = \"GYD\", \"Guyanese dollar\", \"$\"\n    HKD = \"HKD\", \"Hong Kong dollar\", \"$\"\n    HNL = \"HNL\", \"Honduran lempira\", \"L\"\n    HRK = \"HRK\", \"Croatian kuna\", \"kn\"\n    HTG = \"HTG\", \"Haitian gourde\", \"G\"\n    HUF = \"HUF\", \"Hungarian forint\", \"Ft\"\n    IDR = \"IDR\", \"Indonesian rupiah\", \"Rp\"\n    ILS = \"ILS\", \"Israeli new shekel\", \"₪\"\n    INR = \"INR\", \"Indian rupee\", \"₹\"\n    IQD = \"IQD\", \"Iraqi dinar\", \"ع.د\"\n    IRR = \"IRR\", \"Iranian rial\", \"﷼\"\n    ISK = \"ISK\", \"Icelandic króna\", \"kr\"\n    JMD = \"JMD\", \"Jamaican dollar\", \"$\"\n    JOD = \"JOD\", \"Jordanian dinar\", \"د.ا\"\n    JPY = \"JPY\", \"Japanese yen\", \"¥\"\n    KES = \"KES\", \"Kenyan shilling\", \"Sh\"\n    KGS = \"KGS\", \"Kyrgyzstani som\", \"с\"\n    KHR = \"KHR\", \"Cambodian riel\", \"៛\"\n    KMF = \"KMF\", \"Comoro franc\", \"Fr\"\n    KPW = \"KPW\", \"North Korean won\", \"₩\"\n    KRW = \"KRW\", \"South Korean won\", \"₩\"\n    KWD = \"KWD\", \"Kuwaiti dinar\", \"د.ك\"\n    KYD = \"KYD\", \"Cayman Islands dollar\", \"$\"\n    KZT = \"KZT\", \"Kazakhstani tenge\", \"₸\"\n    LAK = \"LAK\", \"Lao kip\", \"₭\"\n    LBP = \"LBP\", \"Lebanese pound\", \"ل.ل\"\n    LKR = \"LKR\", \"Sri Lankan rupee\", \"Rs\"\n    LRD = \"LRD\", \"Liberian dollar\", \"$\"\n    LSL = \"LSL\", \"Lesotho loti\", \"L\"\n    LYD = \"LYD\", \"Libyan dinar\", \"ل.د\"\n    MAD = \"MAD\", \"Moroccan dirham\", \"د.م.\"\n    MDL = \"MDL\", \"Moldovan leu\", \"L\"\n    MGA = \"MGA\", \"Malagasy ariary\", \"Ar\"\n    MKD = \"MKD\", \"Macedonian denar\", \"ден\"\n    MMK = \"MMK\", \"Myanmar kyat\", \"Ks\"\n    MNT = \"MNT\", \"Mongolian tögrög\", \"₮\"\n    MOP = \"MOP\", \"Macanese pataca\", \"P\"\n    MRU = \"MRU\", \"Mauritanian ouguiya\", \"UM\"\n    MUR = \"MUR\", \"Mauritian rupee\", \"₨\"\n    MVR = \"MVR\", \"Maldivian rufiyaa\", \".ރ\"\n    MWK = \"MWK\", \"Malawian kwacha\", \"MK\"\n    MXN = \"MXN\", \"Mexican peso\", \"$\"\n    MYR = \"MYR\", \"Malaysian ringgit\", \"RM\"\n    MZN = \"MZN\", \"Mozambican metical\", \"MT\"\n    NAD = \"NAD\", \"Namibian dollar\", \"$\"\n    NGN = \"NGN\", \"Nigerian naira\", \"₦\"\n    NIO = \"NIO\", \"Nicaraguan córdoba\", \"C$\"\n    NOK = \"NOK\", \"Norwegian krone\", \"kr\"\n    NPR = \"NPR\", \"Nepalese rupee\", \"₨\"\n    NZD = \"NZD\", \"New Zealand dollar\", \"$\"\n    OMR = \"OMR\", \"Omani rial\", \"ر.ع.\"\n    PAB = \"PAB\", \"Panamanian balboa\", \"B/.\"\n    PEN = \"PEN\", \"Peruvian sol\", \"S/\"\n    PGK = \"PGK\", \"Papua New Guinean kina\", \"K\"\n    PHP = \"PHP\", \"Philippine peso\", \"₱\"\n    PKR = \"PKR\", \"Pakistani rupee\", \"₨\"\n    PLN = \"PLN\", \"Polish złoty\", \"zł\"\n    PYG = \"PYG\", \"Paraguayan guaraní\", \"₲\"\n    QAR = \"QAR\", \"Qatari riyal\", \"ر.ق\"\n    RON = \"RON\", \"Romanian leu\", \"lei\"\n    RSD = \"RSD\", \"Serbian dinar\", \"дин.\"\n    RUB = \"RUB\", \"Russian ruble\", \"₽\"\n    RWF = \"RWF\", \"Rwandan franc\", \"Fr\"\n    SAR = \"SAR\", \"Saudi riyal\", \"ر.س\"\n    SBD = \"SBD\", \"Solomon Islands dollar\", \"$\"\n    SCR = \"SCR\", \"Seychelles rupee\", \"₨\"\n    SDG = \"SDG\", \"Sudanese pound\", \"ج.س.\"\n    SEK = \"SEK\", \"Swedish krona\", \"kr\"\n    SGD = \"SGD\", \"Singapore dollar\", \"$\"\n    SHP = \"SHP\", \"Saint Helena pound\", \"£\"\n    SLL = \"SLL\", \"Sierra Leonean leone\", \"Le\"\n    SOS = \"SOS\", \"Somali shilling\", \"Sh\"\n    SRD = \"SRD\", \"Surinamese dollar\", \"$\"\n    SSP = \"SSP\", \"South Sudanese pound\", \"£\"\n    STN = \"STN\", \"São Tomé and Príncipe dobra\", \"Db\"\n    SVC = \"SVC\", \"Salvadoran colón\", \"₡\"\n    SYP = \"SYP\", \"Syrian pound\", \"£\"\n    SZL = \"SZL\", \"Swazi lilangeni\", \"L\"\n    THB = \"THB\", \"Thai baht\", \"฿\"\n    TJS = \"TJS\", \"Tajikistani somoni\", \"ЅМ\"\n    TMT = \"TMT\", \"Turkmenistan manat\", \"m\"\n    TND = \"TND\", \"Tunisian dinar\", \"د.ت\"\n    TOP = \"TOP\", \"Tongan paʻanga\", \"T$\"\n    TRY = \"TRY\", \"Turkish lira\", \"₺\"\n    TTD = \"TTD\", \"Trinidad and Tobago dollar\", \"$\"\n    TWD = \"TWD\", \"New Taiwan dollar\", \"$\"\n    TZS = \"TZS\", \"Tanzanian shilling\", \"Sh\"\n    UAH = \"UAH\", \"Ukrainian hryvnia\", \"₴\"\n    UGX = \"UGX\", \"Ugandan shilling\", \"Sh\"\n    USD = \"USD\", \"United States dollar\", \"$\"\n    UYU = \"UYU\", \"Uruguayan peso\", \"$\"\n    UZS = \"UZS\", \"Uzbekistan som\", \"so'm\"\n    VES = \"VES\", \"Venezuelan bolívar soberano\", \"Bs.S\"\n    VND = \"VND\", \"Vietnamese đồng\", \"₫\"\n    VUV = \"VUV\", \"Vanuatu vatu\", \"Vt\"\n    WST = \"WST\", \"Samoan tala\", \"T\"\n    XAF = \"XAF\", \"CFA franc BEAC\", \"Fr\"\n    XCD = \"XCD\", \"East Caribbean dollar\", \"$\"\n    XOF = \"XOF\", \"CFA franc BCEAO\", \"Fr\"\n    XPF = \"XPF\", \"CFP franc\", \"Fr\"\n    YER = \"YER\", \"Yemeni rial\", \"﷼\"\n    ZAR = \"ZAR\", \"South African rand\", \"R\"\n    ZMW = \"ZMW\", \"Zambian kwacha\", \"ZK\"\n    ZWL = \"ZWL\", \"Zimbabwean dollar\", \"$\"\n\n    def __new__(cls, code: str, name: str, symbol: str):\n        obj = str.__new__(cls, code)\n        obj._value_ = code\n        obj.name = name\n        obj.symbol = symbol\n        return obj\n```\n\n----------------------------------------\n\nTITLE: Validating Multiple Users with Pydantic TypeAdapter and HTTPX in Python\nDESCRIPTION: This snippet shows how to use Pydantic's TypeAdapter with HTTPX to fetch and validate a list of users from an API. It demonstrates handling multiple records and using TypeAdapter for list validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/requests.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pprint import pprint\n\nimport httpx\n\nfrom pydantic import BaseModel, EmailStr, TypeAdapter\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    email: EmailStr\n\n\nurl = 'https://jsonplaceholder.typicode.com/users/'  # (1)!\n\nresponse = httpx.get(url)\nresponse.raise_for_status()\n\nusers_list_adapter = TypeAdapter(list[User])\n\nusers = users_list_adapter.validate_python(response.json())\npprint([u.name for u in users])\n\"\"\"\n['Leanne Graham',\n 'Ervin Howell',\n 'Clementine Bauch',\n 'Patricia Lebsack',\n 'Chelsey Dietrich',\n 'Mrs. Dennis Schulist',\n 'Kurtis Weissnat',\n 'Nicholas Runolfsdottir V',\n 'Glenna Reichert',\n 'Clementina DuBuque']\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Union with left to right mode in Pydantic\nDESCRIPTION: This code snippet demonstrates how to use the 'left_to_right' union mode in Pydantic. It defines a `User` model with an `id` field that can be either a string or an integer. The `union_mode='left_to_right'` setting ensures that Pydantic attempts to validate the input against each type in the order they are defined in the Union.  If validation fails for all members, the errors from each member are included in the ValidationError.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    id: Union[str, int] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))\n#> id=123\nprint(User(id='hello'))\n#> id='hello'\n\ntry:\n    User(id=[])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for User\n    id.str\n      Input should be a valid string [type=string_type, input_value=[], input_type=list]\n    id.int\n      Input should be a valid integer [type=int_type, input_value=[], input_type=list]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Any Type to Skip Validation in Pydantic\nDESCRIPTION: Shows how to use the Any type annotation to bypass validation for fields where validation isn't necessary, which improves performance by skipping the validation process completely.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Any\n\n\nmodel = Model(a=1)\n```\n\n----------------------------------------\n\nTITLE: Custom Handling of Cyclic References in Pydantic Validation\nDESCRIPTION: This complex example shows how to create a custom validator to handle cyclic references in a tree-like structure. It demonstrates suppressing recursion validation errors and cleaning cyclic references from the input data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom contextlib import contextmanager\nfrom dataclasses import field\nfrom typing import Iterator\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\ndef is_recursion_validation_error(exc: ValidationError) -> bool:\n    errors = exc.errors()\n    return len(errors) == 1 and errors[0]['type'] == 'recursion_loop'\n\n\n@contextmanager\ndef suppress_recursion_validation_error() -> Iterator[None]:\n    try:\n        yield\n    except ValidationError as exc:\n        if not is_recursion_validation_error(exc):\n            raise exc\n\n\nclass Node(BaseModel):\n    id: int\n    children: list['Node'] = field(default_factory=list)\n\n    @field_validator('children', mode='wrap')\n    @classmethod\n    def drop_cyclic_references(cls, children, h):\n        try:\n            return h(children)\n        except ValidationError as exc:\n            if not (\n                is_recursion_validation_error(exc)\n                and isinstance(children, list)\n            ):\n                raise exc\n\n            value_without_cyclic_refs = []\n            for child in children:\n                with suppress_recursion_validation_error():\n                    value_without_cyclic_refs.extend(h([child]))\n            return h(value_without_cyclic_refs)\n\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\nprint(Node.model_validate(node_data))\n#> id=1 children=[Node(id=2, children=[Node(id=3, children=[])])]\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Dataclasses\nDESCRIPTION: Shows two methods for configuring Pydantic dataclasses: using the config parameter in the decorator or defining the __pydantic_config__ attribute in the class with ConfigDict.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict\nfrom pydantic.dataclasses import dataclass\n\n\n# Option 1 -- using the decorator argument:\n@dataclass(config=ConfigDict(validate_assignment=True))  # (1)!\nclass MyDataclass1:\n    a: int\n\n\n# Option 2 -- using an attribute:\n@dataclass\nclass MyDataclass2:\n    a: int\n\n    __pydantic_config__ = ConfigDict(validate_assignment=True)\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Data Conversion in Pydantic Models\nDESCRIPTION: Shows how Pydantic converts input data to match the defined field types, potentially causing loss of information. The example demonstrates conversion of a float to an integer, a string to a float, and binary data to a string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n    b: float\n    c: str\n\n\nprint(Model(a=3.000, b='2.72', c=b'binary data').model_dump())\n#> {'a': 3, 'b': 2.72, 'c': 'binary data'}\n```\n\n----------------------------------------\n\nTITLE: Using WithJsonSchema Annotation in Pydantic for Schema Overrides\nDESCRIPTION: Shows how to use the WithJsonSchema annotation to override the generated JSON schema for a given type without implementing custom schema generation methods, providing a simpler approach for schema customization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, WithJsonSchema\n\nMyInt = Annotated[\n    int,\n    WithJsonSchema({'type': 'integer', 'examples': [1, 0, -1]}),\n]\n\n\nclass Model(BaseModel):\n    a: MyInt\n\n\nprint(json.dumps(Model.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"a\": {\n      \"examples\": [\n        1,\n        0,\n        -1\n      ],\n      \"title\": \"A\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"a\"\n  ],\n  \"title\": \"Model\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Mode with @validate_call Decorator\nDESCRIPTION: Shows how to use strict mode with the @validate_call decorator by passing a ConfigDict with strict=True, enforcing strict type checking for function parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError, validate_call\n\n\n@validate_call(config=ConfigDict(strict=True))\ndef foo(x: int) -> int:\n    return x\n\n\ntry:\n    foo('1')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for foo\n    0\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types in Pydantic Models\nDESCRIPTION: Demonstrates the use of Literal types in Pydantic models for specifying fields that can only accept specific literal values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Pie(BaseModel):\n    flavor: Literal['apple', 'pumpkin']\n\n\nPie(flavor='apple')\nPie(flavor='pumpkin')\ntry:\n    Pie(flavor='cherry')\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    1 validation error for Pie\n    flavor\n      Input should be 'apple' or 'pumpkin' [type=literal_error, input_value='cherry', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types for Union Discrimination in Pydantic\nDESCRIPTION: Shows how to use Literal types to discriminate between different models in a Union type, allowing for precise type checking and validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar, Literal, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Cake(BaseModel):\n    kind: Literal['cake']\n    required_utensils: ClassVar[list[str]] = ['fork', 'knife']\n\n\nclass IceCream(BaseModel):\n    kind: Literal['icecream']\n    required_utensils: ClassVar[list[str]] = ['spoon']\n\n\nclass Meal(BaseModel):\n    dessert: Union[Cake, IceCream]\n\n\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#> Cake\nprint(type(Meal(dessert={'kind': 'icecream'}).dessert).__name__)\n#> IceCream\ntry:\n    Meal(dessert={'kind': 'pie'})\nexcept ValidationError as e:\n    print(str(e))\n    \"\"\"\n    2 validation errors for Meal\n    dessert.Cake.kind\n      Input should be 'cake' [type=literal_error, input_value='pie', input_type=str]\n    dessert.IceCream.kind\n      Input should be 'icecream' [type=literal_error, input_value='pie', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Nested Discriminated Unions with Field Discriminators\nDESCRIPTION: This example demonstrates how to implement nested discriminated unions using the `Annotated` type and the `Field` discriminator. Two levels of discrimination are applied: first by `pet_type` to distinguish between `Cat` and `Dog`, and then within `Cat` by `color` to distinguish between `BlackCat` and `WhiteCat`. The `Model` class uses the nested `Pet` type to validate the `pet` field.  It demonstrates error handling when the discriminator value is invalid or when a required field is missing.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['black']\n    black_name: str\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['cat']\n    color: Literal['white']\n    white_name: str\n\n\nCat = Annotated[Union[BlackCat, WhiteCat], Field(discriminator='color')]\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    name: str\n\n\nPet = Annotated[Union[Cat, Dog], Field(discriminator='pet_type')]\n\n\nclass Model(BaseModel):\n    pet: Pet\n    n: int\n\n\nm = Model(pet={'pet_type': 'cat', 'color': 'black', 'black_name': 'felix'}, n=1)\nprint(m)\n#> pet=BlackCat(pet_type='cat', color='black', black_name='felix') n=1\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'red'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat\n      Input tag 'red' found using 'color' does not match any of the expected tags: 'black', 'white' [type=union_tag_invalid, input_value={'pet_type': 'cat', 'color': 'red'}, input_type=dict]\n    \"\"\"\ntry:\n    Model(pet={'pet_type': 'cat', 'color': 'black'}, n='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    pet.cat.black.black_name\n      Field required [type=missing, input_value={'pet_type': 'cat', 'color': 'black'}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Comparing Performance between Pydantic and Dedicated Python Code\nDESCRIPTION: This benchmark compares Pydantic's validation performance against dedicated Python code when parsing JSON and validating URLs. It demonstrates how Pydantic's Rust-based validation can be significantly faster (>300%) than purpose-built Python code.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport json\nimport timeit\nfrom urllib.parse import urlparse\n\nimport requests\n\nfrom pydantic import HttpUrl, TypeAdapter\n\nreps = 7\nnumber = 100\nr = requests.get('https://api.github.com/emojis')\nr.raise_for_status()\nemojis_json = r.content\n\n\ndef emojis_pure_python(raw_data):\n    data = json.loads(raw_data)\n    output = {}\n    for key, value in data.items():\n        assert isinstance(key, str)\n        url = urlparse(value)\n        assert url.scheme in ('https', 'http')\n        output[key] = url\n\n\nemojis_pure_python_times = timeit.repeat(\n    'emojis_pure_python(emojis_json)',\n    globals={\n        'emojis_pure_python': emojis_pure_python,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pure python: {min(emojis_pure_python_times) / number * 1000:0.2f}ms')\n#> pure python: 5.32ms\n\ntype_adapter = TypeAdapter(dict[str, HttpUrl])\nemojis_pydantic_times = timeit.repeat(\n    'type_adapter.validate_json(emojis_json)',\n    globals={\n        'type_adapter': type_adapter,\n        'HttpUrl': HttpUrl,\n        'emojis_json': emojis_json,\n    },\n    repeat=reps,\n    number=number,\n)\nprint(f'pydantic: {min(emojis_pydantic_times) / number * 1000:0.2f}ms')\n#> pydantic: 1.54ms\n\nprint(\n    f'Pydantic {min(emojis_pure_python_times) / min(emojis_pydantic_times):0.2f}x faster'\n)\n#> Pydantic 3.45x faster\n```\n\n----------------------------------------\n\nTITLE: Using Literal Types for Hierarchical Model Parsing in Pydantic\nDESCRIPTION: Demonstrates how to use Literal types in combination with Union to parse types of decreasing specificity, allowing for hierarchical model structures.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Optional, Union\n\nfrom pydantic import BaseModel\n\n\nclass Dessert(BaseModel):\n    kind: str\n\n\nclass Pie(Dessert):\n    kind: Literal['pie']\n    flavor: Optional[str]\n\n\nclass ApplePie(Pie):\n    flavor: Literal['apple']\n\n\nclass PumpkinPie(Pie):\n    flavor: Literal['pumpkin']\n\n\nclass Meal(BaseModel):\n    dessert: Union[ApplePie, PumpkinPie, Pie, Dessert]\n\n\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'apple'}).dessert).__name__)\n#> ApplePie\nprint(type(Meal(dessert={'kind': 'pie', 'flavor': 'pumpkin'}).dessert).__name__)\n#> PumpkinPie\nprint(type(Meal(dessert={'kind': 'pie'}).dessert).__name__)\n#> Dessert\nprint(type(Meal(dessert={'kind': 'cake'}).dessert).__name__)\n#> Dessert\n```\n\n----------------------------------------\n\nTITLE: Alternative UserIn and UserOut Pattern - Python\nDESCRIPTION: This example provides an alternative pattern to the pipeline API using separate `UserIn` and `UserOut` models with plain Python code for transformation. It shows how to handle different input types for a field and convert them to a desired output type using standard Python operations, focusing on readability and maintainability.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass UserIn(BaseModel):\n    favorite_number: int | str\n\n\nclass UserOut(BaseModel):\n    favorite_number: int\n\n\ndef my_api(user: UserIn) -> UserOut:\n    favorite_number = user.favorite_number\n    if isinstance(favorite_number, str):\n        favorite_number = int(user.favorite_number.strip())\n\n    return UserOut(favorite_number=favorite_number)\n\n\nassert my_api(UserIn(favorite_number=' 1 ')).favorite_number == 1\n```\n\n----------------------------------------\n\nTITLE: NamedTuple Validation in Pydantic\nDESCRIPTION: Shows validation of NamedTuple fields in Pydantic models with type checking and error handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Point(NamedTuple):\n    x: int\n    y: int\n\n\nclass Model(BaseModel):\n    p: Point\n\n\ntry:\n    Model(p=('1.3', '2'))\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    p.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='1.3', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using field_validator with JSON Schema Input Type\nDESCRIPTION: Demonstrates how to specify the correct JSON schema input type for fields with validators. In this example, a field with str type annotation can also accept integers due to a before validator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    value: str\n\n    @field_validator('value', mode='before')\n    @classmethod\n    def cast_ints(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return str(value)\n        else:\n            return value\n\n\nprint(Model(value='a'))\n#> value='a'\nprint(Model(value=1))\n#> value='1'\n```\n\n----------------------------------------\n\nTITLE: Handling Discriminator Field Errors in Pydantic Union Types\nDESCRIPTION: Illustrates various errors related to discriminator fields in Union types, including missing fields, non-string aliases, non-Literal types, and different aliases on discriminator fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, PydanticUserError\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    c: str\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n    d: str\n\n\ntry:\n\n    class Model(BaseModel):\n        pet: Union[Cat, Dog] = Field(discriminator='pet_type')\n        number: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'discriminator-no-field'\n```\n\n----------------------------------------\n\nTITLE: Custom Serialization of Cyclic References in Pydantic\nDESCRIPTION: This advanced example demonstrates how to create a custom serializer to handle cyclic references during serialization. It shows how to detect and handle circular references in a tree-like structure, allowing for successful serialization of cyclic data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import field\nfrom typing import Any\n\nfrom pydantic import (\n    SerializerFunctionWrapHandler,\n    TypeAdapter,\n    field_serializer,\n)\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass NodeReference:\n    id: int\n\n\n@dataclass\nclass Node(NodeReference):\n    children: list['Node'] = field(default_factory=list)\n\n    @field_serializer('children', mode='wrap')\n    def serialize(\n        self, children: list['Node'], handler: SerializerFunctionWrapHandler\n    ) -> Any:\n        \"\"\"\n        Serialize a list of nodes, handling circular references by excluding the children.\n        \"\"\"\n        try:\n            return handler(children)\n        except ValueError as exc:\n            if not str(exc).startswith('Circular reference'):\n                raise exc\n\n            result = []\n            for node in children:\n                try:\n                    serialized = handler([node])\n                except ValueError as exc:\n                    if not str(exc).startswith('Circular reference'):\n                        raise exc\n                    result.append({'id': node.id})\n                else:\n                    result.append(serialized)\n            return result\n\n\n# Create a cyclic graph:\nnodes = [Node(id=1), Node(id=2), Node(id=3)]\nnodes[0].children.append(nodes[1])\nnodes[1].children.append(nodes[2])\nnodes[2].children.append(nodes[0])\n\nprint(nodes[0])\n#> Node(id=1, children=[Node(id=2, children=[Node(id=3, children=[...])])])\n\n# Serialize the cyclic graph:\nprint(TypeAdapter(Node).dump_python(nodes[0]))\n\"\"\"\n{\n    'id': 1,\n    'children': [{'id': 2, 'children': [{'id': 3, 'children': [{'id': 1}]}]}],\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Field Aliases in Pydantic Models\nDESCRIPTION: Shows how to use the alias parameter with Pydantic fields for both validation and serialization. Demonstrates creating a User model with an aliased name field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(alias='username')\n\nuser = User(username='johndoe')  \nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  \n#> {'username': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Implementing Plain Validator using Decorator in Python\nDESCRIPTION: This snippet shows how to implement a Plain validator using the field_validator decorator in Pydantic. The validator doubles integer inputs and passes through non-integer inputs without further validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='plain')\n    @classmethod\n    def val_number(cls, value: Any) -> Any:\n        if isinstance(value, int):\n            return value * 2\n        else:\n            return value\n\n\nprint(Model(number=4))\n#> number=8\nprint(Model(number='invalid'))  # (1)!\n#> number='invalid'\n```\n\n----------------------------------------\n\nTITLE: Serializing Pydantic Model with Alias Flag in Python\nDESCRIPTION: Demonstrates how to serialize a Pydantic model using an alias. The model_dump() method is called with by_alias=True to use the specified serialization alias instead of the attribute name.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    my_field: str = Field(serialization_alias='my_alias')\n\nm = Model(my_field='foo')\nprint(m.model_dump(by_alias=True))  # (1)!\n#> {'my_alias': 'foo'}\n```\n\n----------------------------------------\n\nTITLE: Using Discriminator with Discriminator Instance in Pydantic\nDESCRIPTION: Demonstrates how to use the discriminator parameter with a Discriminator instance for more complex discrimination logic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Literal, Union\n\nfrom pydantic import BaseModel, Discriminator, Field, Tag\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n    age: int\n\n\nclass Dog(BaseModel):\n    pet_kind: Literal['dog']\n    age: int\n\n\ndef pet_discriminator(v):\n    if isinstance(v, dict):\n        return v.get('pet_type', v.get('pet_kind'))\n    return getattr(v, 'pet_type', getattr(v, 'pet_kind', None))\n\n\nclass Model(BaseModel):\n    pet: Union[Annotated[Cat, Tag('cat')], Annotated[Dog, Tag('dog')]] = Field(\n        discriminator=Discriminator(pet_discriminator)\n    )\n\n\nprint(repr(Model.model_validate({'pet': {'pet_type': 'cat', 'age': 12}})))\n#> Model(pet=Cat(pet_type='cat', age=12))\n\nprint(repr(Model.model_validate({'pet': {'pet_kind': 'dog', 'age': 12}})))\n#> Model(pet=Dog(pet_kind='dog', age=12))\n```\n\n----------------------------------------\n\nTITLE: Mapping to BeforeValidator, AfterValidator, WrapValidator - Python\nDESCRIPTION: This snippet demonstrates how the `validate_as` method in the Pydantic experimental pipeline API relates to `BeforeValidator`, `AfterValidator`, and `WrapValidator`.  It showcases examples for stripping whitespace before parsing to an integer, multiplying an integer by 2 after parsing, and combining stripping, validation, and multiplication.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic.experimental.pipeline import transform, validate_as\n\n# BeforeValidator\nAnnotated[int, validate_as(str).str_strip().validate_as(...)]  # (1)!\n# AfterValidator\nAnnotated[int, transform(lambda x: x * 2)]  # (2)!\n# WrapValidator\nAnnotated[\n    int,\n    validate_as(str)\n    .str_strip()\n    .validate_as(...)\n    .transform(lambda x: x * 2),  # (3)!\n]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Union Type Behavior in Pydantic V2\nDESCRIPTION: Shows how Pydantic V2 preserves the type of input in union types, which is different from V1's behavior of converting to the first valid type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: Union[int, str]\n\n\nprint(Model(x='1'))\n#> x='1'\n```\n\n----------------------------------------\n\nTITLE: Using TypeVar in Pydantic Models\nDESCRIPTION: Illustrates the use of TypeVar in Pydantic models, showing how unconstrained, bound, and constrained TypeVars are handled.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypeVar\n\nfrom pydantic import BaseModel\n\nFoobar = TypeVar('Foobar')\nBoundFloat = TypeVar('BoundFloat', bound=float)\nIntStr = TypeVar('IntStr', int, str)\n\n\nclass Model(BaseModel):\n    a: Foobar  # equivalent of \": Any\"\n    b: BoundFloat  # equivalent of \": float\"\n    c: IntStr  # equivalent of \": Union[int, str]\"\n\n\nprint(Model(a=[1], b=4.2, c='x'))\n#> a=[1] b=4.2 c='x'\n\n# a may be None\nprint(Model(a=None, b=1, c=1))\n#> a=None b=1.0 c=1\n```\n\n----------------------------------------\n\nTITLE: Implementing Immutability in Pydantic Fields\nDESCRIPTION: Demonstrates how to use the frozen parameter to make specific fields immutable in a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass User(BaseModel):\n    name: str = Field(frozen=True)\n    age: int\n\n\nuser = User(name='John', age=42)\n\ntry:\n    user.name = 'Jane'  # (1)!\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for User\n    name\n      Field is frozen [type=frozen_field, input_value='Jane', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Extending RootModel with Custom Methods\nDESCRIPTION: Shows how to extend RootModel to add custom methods for accessing items directly or iterating over items in the root field. Implements __iter__ and __getitem__ for direct access to list items.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel):\n    root: list[str]\n\n    def __iter__(self):\n        return iter(self.root)\n\n    def __getitem__(self, item):\n        return self.root[item]\n\n\npets = Pets.model_validate(['dog', 'cat'])\nprint(pets[0])\n#> dog\nprint([pet for pet in pets])\n#> ['dog', 'cat']\n```\n\n----------------------------------------\n\nTITLE: Advanced Include and Exclude Patterns in Pydantic Model Serialization\nDESCRIPTION: Shows how to selectively include or exclude fields when serializing Pydantic models using sets or dictionaries. Demonstrates nested selection of fields to export and how to handle complex model hierarchies.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr\n\n\nclass Transaction(BaseModel):\n    id: str\n    user: User\n    value: int\n\n\nt = Transaction(\n    id='1234567890',\n    user=User(id=42, username='JohnDoe', password='hashedpassword'),\n    value=9876543210,\n)\n\n# using a set:\nprint(t.model_dump(exclude={'user', 'value'}))\n#> {'id': '1234567890'}\n\n# using a dict:\nprint(t.model_dump(exclude={'user': {'username', 'password'}, 'value': True}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n\nprint(t.model_dump(include={'id': True, 'user': {'id'}}))\n#> {'id': '1234567890', 'user': {'id': 42}}\n```\n\n----------------------------------------\n\nTITLE: Validating TOML Files with Pydantic\nDESCRIPTION: Shows how to validate data from a TOML configuration file using Python's tomllib module with Pydantic. The example reads the TOML data and validates it against the Person model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_5\n\nLANGUAGE: toml\nCODE:\n```\nname = \"John Doe\"\nage = 30\nemail = \"john@example.com\"\n```\n\nLANGUAGE: python\nCODE:\n```\nimport tomllib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('person.toml', 'rb') as f:\n    data = tomllib.load(f)\n\nperson = Person.model_validate(data)\nprint(repr(person))\n#> Person(name='John Doe', age=30, email='john@example.com')\n```\n\n----------------------------------------\n\nTITLE: Partial JSON Parsing in Pydantic\nDESCRIPTION: Shows how to use Pydantic's partial JSON parsing feature with pydantic_core.from_json. Demonstrates parsing incomplete JSON data and handling of partial parsing errors.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\n\npartial_json_data = '[\"aa\", \"bb\", \"c'  # (1)!\n\ntry:\n    result = from_json(partial_json_data, allow_partial=False)\nexcept ValueError as e:\n    print(e)  # (2)!\n    #> EOF while parsing a string at line 1 column 15\n\nresult = from_json(partial_json_data, allow_partial=True)\nprint(result)  # (3)!\n#> ['aa', 'bb']\n```\n\n----------------------------------------\n\nTITLE: Using Strict Mode with TypeAdapter\nDESCRIPTION: Demonstrates applying strict mode to a TypeAdapter instance using its config parameter, enforcing strict validation for primitive types like boolean.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\nadapter = TypeAdapter(bool, config=ConfigDict(strict=True))\n\ntry:\n    adapter.validate_python('yes')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for bool\n      Input should be a valid boolean [type=bool_type, input_value='yes', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Field with Annotated for JSON Schema Modifications in Pydantic\nDESCRIPTION: Demonstrates how to specify JSON schema modifications via the Field constructor combined with typing.Annotated to customize field properties and defaults.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Annotated\nfrom uuid import uuid4\n\nfrom pydantic import BaseModel, Field\n\n\nclass Foo(BaseModel):\n    id: Annotated[str, Field(default_factory=lambda: uuid4().hex)]\n    name: Annotated[str, Field(max_length=256)] = Field(\n        'Bar', title='CustomName'\n    )\n\n\nprint(json.dumps(Foo.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"id\": {\n      \"title\": \"Id\",\n      \"type\": \"string\"\n    },\n    \"name\": {\n      \"default\": \"Bar\",\n      \"maxLength\": 256,\n      \"title\": \"CustomName\",\n      \"type\": \"string\"\n    }\n  },\n  \"title\": \"Foo\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Date Type Validation in Pydantic\nDESCRIPTION: Demonstrates date field validation in Pydantic models with support for Unix timestamps and ISO format dates.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nfrom pydantic import BaseModel\n\n\nclass Birthday(BaseModel):\n    d: date = None\n\n\nmy_birthday = Birthday(d=1679616000.0)\n\nprint(my_birthday.model_dump())\n#> {'d': datetime.date(2023, 3, 24)}\n```\n\n----------------------------------------\n\nTITLE: Validating Subclass Types in Pydantic\nDESCRIPTION: Demonstrates how to use type[T] to specify that a field may only accept classes that are subclasses of T. It shows validation for both strict subclass checking and lenient class checking.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n\n\nclass Other:\n    pass\n\n\nclass SimpleModel(BaseModel):\n    just_subclasses: type[Foo]\n\n\nSimpleModel(just_subclasses=Foo)\nSimpleModel(just_subclasses=Bar)\ntry:\n    SimpleModel(just_subclasses=Other)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for SimpleModel\n    just_subclasses\n      Input should be a subclass of Foo [type=is_subclass_of, input_value=<class '__main__.Other'>, input_type=type]\n    \"\"\"\n\nclass LenientSimpleModel(BaseModel):\n    any_class_goes: type\n\n\nLenientSimpleModel(any_class_goes=int)\nLenientSimpleModel(any_class_goes=Foo)\ntry:\n    LenientSimpleModel(any_class_goes=Foo())\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for LenientSimpleModel\n    any_class_goes\n      Input should be a type [type=is_type, input_value=<__main__.Foo object at 0x0123456789ab>, input_type=Foo]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using AnyUrl Type in Pydantic V2\nDESCRIPTION: Demonstrates the behavior of AnyUrl validation in Pydantic V2, showing how slashes are automatically appended to URLs with no path component.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AnyUrl\n\nassert str(AnyUrl(url='https://google.com')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/')) == 'https://google.com/'\nassert str(AnyUrl(url='https://google.com/api')) == 'https://google.com/api'\nassert str(AnyUrl(url='https://google.com/api/')) == 'https://google.com/api/'\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Configuration Error in Pydantic Model\nDESCRIPTION: Shows the error raised when both validate_by_alias and validate_by_name are set to False in the model configuration. This is not allowed as it would make it impossible to populate attributes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a: int = Field(alias='A')\n\n        model_config = ConfigDict(\n            validate_by_alias=False, validate_by_name=False\n        )\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-by-alias-and-name-false'\n```\n\n----------------------------------------\n\nTITLE: Partial JSON Parsing with Dictionaries in Pydantic\nDESCRIPTION: Demonstrates partial JSON parsing for dictionaries using pydantic_core.from_json. Shows how to handle incomplete JSON object data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog_dict = from_json(partial_dog_json, allow_partial=True)\nprint(dog_dict)\n#> {'breed': 'lab', 'name': 'fluffy', 'friends': ['buddy', 'spot', 'rufus']}\n```\n\n----------------------------------------\n\nTITLE: Extending Base Models with Dynamic Model Creation\nDESCRIPTION: Shows how to extend a base model with extra fields using the __base__ special keyword argument in create_model. This allows for dynamic inheritance and combining of model properties.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, create_model\n\n\nclass FooModel(BaseModel):\n    foo: str\n    bar: int = 123\n\n\nBarModel = create_model(\n    'BarModel',\n    apple=(str, 'russet'),\n    banana=(str, 'yellow'),\n    __base__=FooModel,\n)\nprint(BarModel)\n#> <class '__main__.BarModel'>\nprint(BarModel.model_fields.keys())\n#> dict_keys(['foo', 'bar', 'apple', 'banana'])\n```\n\n----------------------------------------\n\nTITLE: Generating JSON Schema for Union Types with TypeAdapter\nDESCRIPTION: Example demonstrating how to generate JSON schema for union types combining multiple BaseModels. This shows how complex type combinations are represented in the schema with references to model definitions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Union\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass Cat(BaseModel):\n    name: str\n    color: str\n\n\nclass Dog(BaseModel):\n    name: str\n    breed: str\n\n\nta = TypeAdapter(Union[Cat, Dog])\nta_schema = ta.json_schema()\nprint(json.dumps(ta_schema, indent=2))\n\"\"\"\n{\n  \"$defs\": {\n    \"Cat\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"color\": {\n          \"title\": \"Color\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"color\"\n      ],\n      \"title\": \"Cat\",\n      \"type\": \"object\"\n    },\n    \"Dog\": {\n      \"properties\": {\n        \"name\": {\n          \"title\": \"Name\",\n          \"type\": \"string\"\n        },\n        \"breed\": {\n          \"title\": \"Breed\",\n          \"type\": \"string\"\n        }\n      },\n      \"required\": [\n        \"name\",\n        \"breed\"\n      ],\n      \"title\": \"Dog\",\n      \"type\": \"object\"\n    }\n  },\n  \"anyOf\": [\n    {\n      \"$ref\": \"#/$defs/Cat\"\n    },\n    {\n      \"$ref\": \"#/$defs/Dog\"\n    }\n  ]\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Extra Data Behavior in Pydantic Models\nDESCRIPTION: Demonstrates how to configure a Pydantic model to allow extra data using the 'extra' configuration option, which stores extra fields in the __pydantic_extra__ attribute.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\nm = Model(x=1, y='a')  # (1)!\nassert m.model_dump() == {'x': 1, 'y': 'a'}\nassert m.__pydantic_extra__ == {'y': 'a'}\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Generic Models while Preserving Generics\nDESCRIPTION: Example showing how to inherit from a generic model while preserving its generic behavior. The subclass must also inherit from Generic with the same type variables to maintain the generic nature.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\n\n\nclass BaseClass(BaseModel, Generic[TypeX]):\n    X: TypeX\n\n\nclass ChildClass(BaseClass[TypeX], Generic[TypeX]):\n    pass\n\n\n# Parametrize `TypeX` with `int`:\nprint(ChildClass[int](X=1))\n#> X=1\n```\n\n----------------------------------------\n\nTITLE: Callable Validation in Pydantic Models\nDESCRIPTION: Demonstrates basic validation of callable fields in Pydantic models, which only checks if the input is callable without validating arguments or return types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    callback: Callable[[int], int]\n\n\nm = Foo(callback=lambda x: x)\nprint(m)\n#> callback=<function <lambda> at 0x0123456789ab>\n```\n\n----------------------------------------\n\nTITLE: Lazy Validation of Iterator Items in Pydantic\nDESCRIPTION: Demonstrates how Pydantic validates values from an iterator at the time they are yielded, raising ValidationError when invalid items are encountered.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    int_iterator: Iterable[int]\n\n\ndef my_iterator():\n    yield 13\n    yield '27'\n    yield 'a'\n\n\nm = Model(int_iterator=my_iterator())\nprint(next(m.int_iterator))\n#> 13\nprint(next(m.int_iterator))\n#> 27\ntry:\n    next(m.int_iterator)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for ValidatorIterator\n    2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Logging for Validation Errors with Model Wrap Validator in Python\nDESCRIPTION: This code snippet demonstrates using a model-level 'wrap' validator in Pydantic to add logging functionality around the validation process. It logs errors when model validation fails while still allowing the original validation error to be raised.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nimport logging\nfrom typing import Any\n\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, ModelWrapValidatorHandler, ValidationError, model_validator\n\n\nclass UserModel(BaseModel):\n    username: str\n\n    @model_validator(mode='wrap')\n    @classmethod\n    def log_failed_validation(cls, data: Any, handler: ModelWrapValidatorHandler[Self]) -> Self:\n        try:\n            return handler(data)\n        except ValidationError:\n            logging.error('Model %s failed to validate with data %s', cls, data)\n            raise\n```\n\n----------------------------------------\n\nTITLE: Documenting Pydantic Pipeline API in Markdown\nDESCRIPTION: Markdown directive to include documentation for the _Pipeline class from pydantic.experimental.pipeline module.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/experimental.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: pydantic.experimental.pipeline\n    options:\n        members:\n            - _Pipeline\n```\n\n----------------------------------------\n\nTITLE: Combining Partial JSON Parsing with Pydantic Models\nDESCRIPTION: Shows how to use pydantic_core.from_json with Pydantic models for partial JSON parsing. Demonstrates parsing incomplete JSON data into a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import from_json\n\nfrom pydantic import BaseModel\n\n\nclass Dog(BaseModel):\n    breed: str\n    name: str\n    friends: list\n\n\npartial_dog_json = '{\"breed\": \"lab\", \"name\": \"fluffy\", \"friends\": [\"buddy\", \"spot\", \"rufus\"], \"age'\ndog = Dog.model_validate(from_json(partial_dog_json, allow_partial=True))\nprint(repr(dog))\n#> Dog(breed='lab', name='fluffy', friends=['buddy', 'spot', 'rufus'])\n```\n\n----------------------------------------\n\nTITLE: Custom Datetime Validator with UTC Offset Bounds in Python\nDESCRIPTION: Implements a custom validator for datetime objects that ensures their UTC offset falls within specified lower and upper bounds. The validator enforces that the datetime has a UTC offset and that it's within the specified range.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/custom_validators.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport datetime as dt\nfrom dataclasses import dataclass\nfrom pprint import pprint\nfrom typing import Annotated, Any, Callable\n\nimport pytz\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter, ValidationError\n\n\n@dataclass(frozen=True)\nclass MyDatetimeValidator:\n    lower_bound: int\n    upper_bound: int\n\n    def validate_tz_bounds(self, value: dt.datetime, handler: Callable):\n        \"\"\"Validate and test bounds\"\"\"\n        assert value.utcoffset() is not None, 'UTC offset must exist'\n        assert self.lower_bound <= self.upper_bound, 'Invalid bounds'\n\n        result = handler(value)\n\n        hours_offset = value.utcoffset().total_seconds() / 3600\n        assert (\n            self.lower_bound <= hours_offset <= self.upper_bound\n        ), 'Value out of bounds'\n\n        return result\n\n    def __get_pydantic_core_schema__(\n        self,\n        source_type: Any,\n        handler: GetCoreSchemaHandler,\n    ) -> CoreSchema:\n        return core_schema.no_info_wrap_validator_function(\n            self.validate_tz_bounds,\n            handler(source_type),\n        )\n\n\nLA = 'America/Los_Angeles'  # UTC-7 or UTC-8\nta = TypeAdapter(Annotated[dt.datetime, MyDatetimeValidator(-10, -5)])\nprint(\n    ta.validate_python(dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LA)))\n)\n#> 2023-01-01 00:00:00-07:53\n\nLONDON = 'Europe/London'\ntry:\n    print(\n        ta.validate_python(\n            dt.datetime(2023, 1, 1, 0, 0, tzinfo=pytz.timezone(LONDON))\n        )\n    )\nexcept ValidationError as e:\n    pprint(e.errors(), width=100)\n    \"\"\"\n    [{'ctx': {'error': AssertionError('Value out of bounds')},\n    'input': datetime.datetime(2023, 1, 1, 0, 0, tzinfo=<DstTzInfo 'Europe/London' LMT-1 day, 23:59:00 STD>),\n    'loc': (),\n    'msg': 'Assertion failed, Value out of bounds',\n    'type': 'assertion_error',\n    'url': 'https://errors.pydantic.dev/2.8/v/assertion_error'}]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Resolving Circular References in Pydantic Models\nDESCRIPTION: Shows how to handle circular references between Pydantic models by defining the types and then calling .model_rebuild() on the referencing class.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    a: Optional['Bar'] = None\n\n\nclass Bar(BaseModel):\n    b: 'Foo'\n\n\nFoo.model_rebuild()\n\nfoo = Foo(a={'b': {'a': None}})\n```\n\n----------------------------------------\n\nTITLE: Valid Model Serializer Signature Examples\nDESCRIPTION: This code snippet demonstrates the various valid signatures for model serializers in Pydantic. It shows both 'plain' and 'wrap' modes with optional SerializationInfo parameter.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import SerializerFunctionWrapHandler, SerializationInfo, model_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@model_serializer  # or model_serializer(mode='plain')\ndef mod_ser(self, info: SerializationInfo): ...\n\n# an instance method with `mode='wrap'`\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler, info: SerializationInfo):\n\n# For all of these, you can also choose to omit the `info` argument, for example:\n@model_serializer(mode='plain')\ndef mod_ser(self): ...\n\n@model_serializer(mode='wrap')\ndef mod_ser(self, handler: SerializerFunctionWrapHandler): ...\n```\n\n----------------------------------------\n\nTITLE: Using computed_field with JSON Schema generation in Pydantic\nDESCRIPTION: Example demonstrating how to use the `computed_field` decorator with a property to include a computed volume field in a Box model. The example shows the resulting JSON schema in serialization mode which includes the computed field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property  # (1)!\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nprint(Box.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {\n        'width': {'title': 'Width', 'type': 'number'},\n        'height': {'title': 'Height', 'type': 'number'},\n        'depth': {'title': 'Depth', 'type': 'number'},\n        'volume': {'readOnly': True, 'title': 'Volume', 'type': 'number'},\n    },\n    'required': ['width', 'height', 'depth', 'volume'],\n    'title': 'Box',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Validating TypedDict Lists with TypeAdapter in Python\nDESCRIPTION: Demonstrates using TypeAdapter to validate and serialize a list of TypedDict objects, including error handling and JSON dumping. Shows validation of User objects with type conversion and error handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter, ValidationError\n\n\nclass User(TypedDict):\n    name: str\n    id: int\n\n\nuser_list_adapter = TypeAdapter(list[User])\nuser_list = user_list_adapter.validate_python([{'name': 'Fred', 'id': '3'}])\nprint(repr(user_list))\n#> [{'name': 'Fred', 'id': 3}]\n\ntry:\n    user_list_adapter.validate_python(\n        [{'name': 'Fred', 'id': 'wrong', 'other': 'no'}]\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for list[User]\n    0.id\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='wrong', input_type=str]\n    \"\"\"\n\nprint(repr(user_list_adapter.dump_json(user_list)))\n#> b'[{\"name\":\"Fred\",\"id\":3}]'\n```\n\n----------------------------------------\n\nTITLE: Validating Pydantic Model by Name in Python\nDESCRIPTION: Demonstrates validation of a Pydantic model using the attribute name instead of the alias. The model_validate() method is called with by_alias=False and by_name=True to use the attribute name 'my_field' for validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=False, by_name=True  # (1)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Using Default Values with Partial JSON Parsing in Pydantic\nDESCRIPTION: Demonstrates advanced usage of partial JSON parsing with default values and custom error handling. Shows how to handle missing fields in partial JSON data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any, Optional\n\nimport pydantic_core\n\nfrom pydantic import BaseModel, ValidationError, WrapValidator\n\n\ndef default_on_error(v, handler) -> Any:\n    \"\"\"\n    Raise a PydanticUseDefault exception if the value is missing.\n\n    This is useful for avoiding errors from partial\n    JSON preventing successful validation.\n    \"\"\"\n    try:\n        return handler(v)\n    except ValidationError as exc:\n        # there might be other types of errors resulting from partial JSON parsing\n        # that you allow here, feel free to customize as needed\n        if all(e['type'] == 'missing' for e in exc.errors()):\n            raise pydantic_core.PydanticUseDefault()\n        else:\n            raise\n\n\nclass NestedModel(BaseModel):\n    x: int\n    y: str\n\n\nclass MyModel(BaseModel):\n    foo: Optional[str] = None\n    bar: Annotated[\n        Optional[tuple[str, int]], WrapValidator(default_on_error)\n    ] = None\n    nested: Annotated[\n        Optional[NestedModel], WrapValidator(default_on_error)\n    ] = None\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json('{\"foo\": \"x\", \"bar\": [\"world\",', allow_partial=True)\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=None, nested=None)\n\n\nm = MyModel.model_validate(\n    pydantic_core.from_json(\n        '{\"foo\": \"x\", \"bar\": [\"world\", 1], \"nested\": {\"x\":', allow_partial=True\n    )\n)\nprint(repr(m))\n#> MyModel(foo='x', bar=('world', 1), nested=None)\n```\n\n----------------------------------------\n\nTITLE: Custom Validation with __get_pydantic_core_schema__ Method\nDESCRIPTION: Implements a custom string subclass with __get_pydantic_core_schema__ to control validation behavior, enabling the type to be properly handled by Pydantic's validation system.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass Username(str):\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(cls, handler(str))\n\n\nta = TypeAdapter(Username)\nres = ta.validate_python('abc')\nassert isinstance(res, Username)\nassert res == 'abc'\n```\n\n----------------------------------------\n\nTITLE: Validating JSON Lines Files with Pydantic\nDESCRIPTION: Shows how to validate data from a JSON Lines (.jsonl) file, which contains JSON objects separated by newlines. Each line is individually validated against the Person model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\"name\": \"John Doe\", \"age\": 30, \"email\": \"john@example.com\"}\n{\"name\": \"Jane Doe\", \"age\": 25, \"email\": \"jane@example.com\"}\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\njson_lines = pathlib.Path('people.jsonl').read_text().splitlines()\npeople = [Person.model_validate_json(line) for line in json_lines]\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```\n\n----------------------------------------\n\nTITLE: Implementing Named Type Aliases with TypeAliasType in Python 3.9+\nDESCRIPTION: Creates a named type alias for a list of positive integers using TypeAliasType, which enables JSON Schema definition generation and prevents duplication in the schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import Gt\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel\n\nPositiveIntList = TypeAliasType('PositiveIntList', list[Annotated[int, Gt(0)]])\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Automatic Pydantic Validation Instrumentation with Logfire in Python\nDESCRIPTION: This snippet shows how to automatically instrument Pydantic models to log validation information. It uses the instrument_pydantic() function to track all model validations, capturing both successful validations and validation errors without manual logging.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/logfire.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nUser(name='Anne', country_code='USA', dob='2000-01-01')\nUser(name='David', country_code='GBR', dob='invalid-dob')\n```\n\n----------------------------------------\n\nTITLE: Tuple Type Validation in Pydantic\nDESCRIPTION: Demonstrates tuple field validation with different type annotations in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_tuple: Optional[tuple] = None\n    tuple_of_different_types: Optional[tuple[int, float, bool]] = None\n\n\nprint(Model(simple_tuple=[1, 2, 3, 4]).simple_tuple)\n#> (1, 2, 3, 4)\nprint(Model(tuple_of_different_types=[3, 2, 1]).tuple_of_different_types)\n#> (3, 2.0, True)\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of validate_call with Class Methods in Python\nDESCRIPTION: Shows the correct way to use validate_call with class methods, static methods, and properties. The validate_call decorator must be placed before these method decorators to work properly.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    class A:\n        @validate_call\n        @classmethod\n        def f1(cls): ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\n@classmethod\n@validate_call\ndef f2(cls): ...\n```\n\n----------------------------------------\n\nTITLE: Implementing Deque Validation with Pydantic\nDESCRIPTION: Demonstrates how to use the deque collection type with Pydantic models, showing optional typing with generic parameters for item validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Deque, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    deque: Optional[Deque[int]] = None\n\n\nprint(Model(deque=[1, 2, 3]).deque)\n#> deque([1, 2, 3])\n```\n\n----------------------------------------\n\nTITLE: Sample JSON Schema Definition\nDESCRIPTION: Example JSON Schema file that defines a Person object with properties like name, age, and pets. Includes property descriptions, type constraints, and a nested Pet definition.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"$id\": \"person.json\",\n  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n  \"title\": \"Person\",\n  \"type\": \"object\",\n  \"properties\": {\n    \"first_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's first name.\"\n    },\n    \"last_name\": {\n      \"type\": \"string\",\n      \"description\": \"The person's last name.\"\n    },\n    \"age\": {\n      \"description\": \"Age in years.\",\n      \"type\": \"integer\",\n      \"minimum\": 0\n    },\n    \"pets\": {\n      \"type\": \"array\",\n      \"items\": [\n        {\n          \"$ref\": \"#/definitions/Pet\"\n        }\n      ]\n    },\n    \"comment\": {\n      \"type\": \"null\"\n    }\n  },\n  \"required\": [\n      \"first_name\",\n      \"last_name\"\n  ],\n  \"definitions\": {\n    \"Pet\": {\n      \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"age\": {\n          \"type\": \"integer\"\n        }\n      }\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Basic Pydantic Logging with Logfire in Python\nDESCRIPTION: This snippet demonstrates how to set up basic logging of Pydantic models using Logfire. It creates a User model with validation, instantiates it, and logs the object using Logfire's info method, which has built-in support for Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/logfire.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()  # (1)!\n\n\nclass User(BaseModel):\n    name: str\n    country_code: str\n    dob: date\n\n\nuser = User(name='Anne', country_code='USA', dob='2000-01-01')\nlogfire.info('user processed: {user!r}', user=user)  # (2)!\n```\n\n----------------------------------------\n\nTITLE: Union Validation Errors with Recursive Models\nDESCRIPTION: This example demonstrates how discriminated unions can simplify error messages when dealing with recursive models and unions. Without a discriminator, validation errors are verbose. The code shows the validation errors that occur when using a simple recursive model with a Union of a string and the Model itself. This highlights the complexity and verbosity of the error messages without a discriminator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\n# Errors are quite verbose with a normal Union:\nclass Model(BaseModel):\n    x: Union[str, 'Model']\n\n\ntry:\n    Model.model_validate({'x': {'x': {'x': 1}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': 1}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': 1}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value=1, input_type=int]\n    x.Model.x.Model.x.Model\n      Input should be a valid dictionary or instance of Model [type=model_type, input_value=1, input_type=int]\n    \"\"\"\n\ntry:\n    Model.model_validate({'x': {'x': {'x': {}}}})\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    4 validation errors for Model\n    x.str\n      Input should be a valid string [type=string_type, input_value={'x': {'x': {}}}, input_type=dict]\n    x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={'x': {}}, input_type=dict]\n    x.Model.x.Model.x.str\n      Input should be a valid string [type=string_type, input_value={}, input_type=dict]\n    x.Model.x.Model.x.Model.x\n      Field required [type=missing, input_value={}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Running datamodel-code-generator with JSON Schema\nDESCRIPTION: Command to generate pydantic models from a JSON Schema file, specifying the input file, input type, and output file.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\ndatamodel-codegen  --input person.json --input-file-type jsonschema --output model.py\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Validator using Annotated Pattern in Python\nDESCRIPTION: This snippet demonstrates how to implement a Before validator using the Annotated pattern in Pydantic. The validator ensures that the input is a list, converting single values to a list if necessary.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, BeforeValidator, ValidationError\n\n\ndef ensure_list(value: Any) -> Any:  # (1)!\n    if not isinstance(value, list):  # (2)!\n        return [value]\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    numbers: Annotated[list[int], BeforeValidator(ensure_list)]\n\n\nprint(Model(numbers=2))\n#> numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)!\n    \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing a String Truncation Validator with Decorator Pattern in Python\nDESCRIPTION: This code snippet demonstrates implementing a field validator using the decorator pattern in Pydantic. It creates a validator that automatically truncates strings that exceed the maximum length specification.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field, ValidationError, ValidatorFunctionWrapHandler, field_validator\n\n\nclass Model(BaseModel):\n    my_string: Annotated[str, Field(max_length=5)]\n\n    @field_validator('my_string', mode='wrap')\n    @classmethod\n    def truncate(cls, value: Any, handler: ValidatorFunctionWrapHandler) -> str:\n        try:\n            return handler(value)\n        except ValidationError as err:\n            if err.errors()[0]['type'] == 'string_too_long':\n                return handler(value[:5])\n            else:\n                raise\n\n\nprint(Model(my_string='abcde'))\n#> my_string='abcde'\nprint(Model(my_string='abcdef'))\n#> my_string='abcde'\n```\n\n----------------------------------------\n\nTITLE: Validating Infinite Generators with Pydantic\nDESCRIPTION: Shows how to use typing.Iterable for lazy validation of generator values, demonstrating validation that occurs only when items are yielded from the generator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Iterable\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    infinite: Iterable[int]\n\n\ndef infinite_ints():\n    i = 0\n    while True:\n        yield i\n        i += 1\n\n\nm = Model(infinite=infinite_ints())\nprint(m)\n\"\"\"\ninfinite=ValidatorIterator(index=0, schema=Some(Int(IntValidator { strict: false })))\n\"\"\"\n\nfor i in m.infinite:\n    print(i)\n    #> 0\n    #> 1\n    #> 2\n    #> 3\n    #> 4\n    #> 5\n    #> 6\n    #> 7\n    #> 8\n    #> 9\n    #> 10\n    if i == 10:\n        break\n```\n\n----------------------------------------\n\nTITLE: Implementing Recursive Type Aliases with PEP 695 (Python 3.12+)\nDESCRIPTION: Defines a recursive JSON type that can represent nested JSON structures using the new type statement syntax, which lazily evaluates the type definition.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\ntype Json = dict[str, Json] | list[Json] | str | int | float | bool | None  # (1)!\n\nta = TypeAdapter(Json)\nprint(ta.json_schema())\n\"\"\"\n{\n    '$defs': {\n        'Json': {\n            'anyOf': [\n                {\n                    'additionalProperties': {'$ref': '#/$defs/Json'},\n                    'type': 'object',\n                },\n                {'items': {'$ref': '#/$defs/Json'}, 'type': 'array'},\n                {'type': 'string'},\n                {'type': 'integer'},\n                {'type': 'number'},\n                {'type': 'boolean'},\n                {'type': 'null'},\n            ]\n        }\n    },\n    '$ref': '#/$defs/Json',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Time Type Handling in Pydantic\nDESCRIPTION: Shows validation of time fields in Pydantic models with support for time objects and string formats.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    t: time = None\n\n\nm = Meeting(t=time(4, 8, 16))\n\nprint(m.model_dump())\n#> {'t': datetime.time(4, 8, 16)}\n```\n\n----------------------------------------\n\nTITLE: Using Root Model with Complex Types in Pydantic\nDESCRIPTION: This example shows how to use a root model with a more complex type, specifically a list of integers. It demonstrates validation, serialization, and accessing the root value.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/root_model.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\nclass ListModel(RootModel[list[int]]):\n    pass\n\nmodel = ListModel([1, 2, 3])\nprint(model.model_dump())\n# > [1, 2, 3]\nprint(model.root)\n# > [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Changing Pydantic Behavior Globally in Python\nDESCRIPTION: Demonstrates how to change Pydantic behavior globally by creating a custom parent class with a specific configuration. This example allows extra fields in all subclasses.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Parent(BaseModel):\n    model_config = ConfigDict(extra='allow')\n\n\nclass Model(Parent):\n    x: str\n\n\nm = Model(x='foo', y='bar')\nprint(m.model_dump())\n#> {'x': 'foo', 'y': 'bar'}\n```\n\n----------------------------------------\n\nTITLE: Using computed_field with model_dump for serialization\nDESCRIPTION: Example showing how to use the `computed_field` decorator with a property to include a computed volume field when serializing a Box model using the model_dump method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n\n\nb = Box(width=1, height=2, depth=3)\nprint(b.model_dump())\n#> {'width': 1.0, 'height': 2.0, 'depth': 3.0, 'volume': 6.0}\n```\n\n----------------------------------------\n\nTITLE: Customizing JSON Schema generation with a custom GenerateJsonSchema class in Python\nDESCRIPTION: This example demonstrates how to customize the JSON schema generation process by subclassing GenerateJsonSchema and overriding the generate method. The custom implementation adds a custom title and $schema property to the generated schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def generate(self, schema, mode='validation'):\n        json_schema = super().generate(schema, mode=mode)\n        json_schema['title'] = 'Customize title'\n        json_schema['$schema'] = self.schema_dialect\n        return json_schema\n\n\nclass MyModel(BaseModel):\n    x: int\n\n\nprint(MyModel.model_json_schema(schema_generator=MyGenerateJsonSchema))\n\"\"\"\n{\n    'properties': {'x': {'title': 'X', 'type': 'integer'}},\n    'required': ['x'],\n    'title': 'Customize title',\n    'type': 'object',\n    '$schema': 'https://json-schema.org/draft/2020-12/schema',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing Before Validator using Decorator in Python\nDESCRIPTION: This snippet shows how to implement a Before validator using the field_validator decorator in Pydantic. The validator ensures that the input is a list, converting single values to a list if necessary.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    numbers: list[int]\n\n    @field_validator('numbers', mode='before')\n    @classmethod\n    def ensure_list(cls, value: Any) -> Any:  # (1)!\n        if not isinstance(value, list):  # (2)!\n            return [value]\n        else:\n            return value\n\n\nprint(Model(numbers=2))\n#> numbers=[2]\ntry:\n    Model(numbers='str')\nexcept ValidationError as err:\n    print(err)  # (3)!\n    \"\"\"\n    1 validation error for Model\n    numbers.0\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='str', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Programmatic Field Title Generation in Pydantic\nDESCRIPTION: Shows how to use the field_title_generator parameter to programmatically generate field titles based on field name and information, allowing for custom title formatting.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.fields import FieldInfo\n\n\ndef make_title(field_name: str, field_info: FieldInfo) -> str:\n    return field_name.upper()\n\n\nclass Person(BaseModel):\n    name: str = Field(field_title_generator=make_title)\n    age: int = Field(field_title_generator=make_title)\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Modifying Existing Schema with SmallString Annotation in Python\nDESCRIPTION: This snippet demonstrates how to modify an existing schema by implementing __get_pydantic_core_schema__ for a SmallString annotation. It adds a maximum length constraint to the string schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass SmallString:\n    def __get_pydantic_core_schema__(\n        self,\n        source: type[Any],\n        handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        schema = handler(source)\n        assert schema['type'] == 'str'\n        schema['max_length'] = 10  # modify in place\n        return schema\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, SmallString()]\n\n\ntry:\n    MyModel(value='too long!!!!!')\nexcept ValidationError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Using FailFast Annotation for Early Validation Termination\nDESCRIPTION: Demonstrates how to use the FailFast annotation with sequence types to terminate validation as soon as an invalid item is encountered, which improves performance at the cost of comprehensive error reporting.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import FailFast, TypeAdapter, ValidationError\n\nta = TypeAdapter(Annotated[list[bool], FailFast()])\ntry:\n    ta.validate_python([True, 'invalid', False, 'also invalid'])\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for list[bool]\n    1\n      Input should be a valid boolean, unable to interpret input [type=bool_parsing, input_value='invalid', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Providing Context When Directly Instantiating a Pydantic Model\nDESCRIPTION: Demonstrates a workaround for providing context when directly instantiating a model using ContextVar and a custom __init__ method. This example allows multiplying a numeric field by a context-provided multiplier.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom typing import Any, Generator\n\nfrom pydantic import BaseModel, ValidationInfo, field_validator\n\n_init_context_var = ContextVar('_init_context_var', default=None)\n\n\n@contextmanager\ndef init_context(value: dict[str, Any]) -> Generator[None]:\n    token = _init_context_var.set(value)\n    try:\n        yield\n    finally:\n        _init_context_var.reset(token)\n\n\nclass Model(BaseModel):\n    my_number: int\n\n    def __init__(self, /, **data: Any) -> None:\n        self.__pydantic_validator__.validate_python(\n            data,\n            self_instance=self,\n            context=_init_context_var.get(),\n        )\n\n    @field_validator('my_number')\n    @classmethod\n    def multiply_with_context(cls, value: int, info: ValidationInfo) -> int:\n        if isinstance(info.context, dict):\n            multiplier = info.context.get('multiplier', 1)\n            value = value * multiplier\n        return value\n\n\nprint(Model(my_number=2))\n#> my_number=2\n\nwith init_context({'multiplier': 3}):\n    print(Model(my_number=2))\n    #> my_number=6\n\nprint(Model(my_number=2))\n#> my_number=2\n```\n\n----------------------------------------\n\nTITLE: Demonstrating url_scheme Error in Pydantic HttpUrl Validation\nDESCRIPTION: This example demonstrates how the 'url_scheme' error is raised when a URL with an invalid scheme is provided. It attempts to use an FTP URL for an HttpUrl field, which requires HTTP or HTTPS schemes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='ftp://example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_scheme'\n```\n\n----------------------------------------\n\nTITLE: Configuring Standard Library Dataclass Using __pydantic_config__ in Python\nDESCRIPTION: Demonstrates how to configure a standard library dataclass using the __pydantic_config__ class attribute. This example sets the strict option to True.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import ConfigDict\n\n\n@dataclass\nclass User:\n    __pydantic_config__ = ConfigDict(strict=True)\n\n    id: int\n    name: str = 'John Doe'\n```\n\n----------------------------------------\n\nTITLE: Using Pydantic Models with Abstract Base Classes\nDESCRIPTION: Shows how to use Pydantic models together with Python's Abstract Base Classes (ABCs). Creates a model that inherits from both BaseModel and abc.ABC with an abstract method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nimport abc\n\nfrom pydantic import BaseModel\n\n\nclass FooBarModel(BaseModel, abc.ABC):\n    a: str\n    b: int\n\n    @abc.abstractmethod\n    def my_abstract_method(self):\n        pass\n```\n\n----------------------------------------\n\nTITLE: List Type Validation in Pydantic\nDESCRIPTION: Shows list field validation with optional typing and type conversion in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_list: Optional[list] = None\n    list_of_ints: Optional[list[int]] = None\n\n\nprint(Model(simple_list=['1', '2', '3']).simple_list)\n#> ['1', '2', '3']\nprint(Model(list_of_ints=['1', '2', '3']).list_of_ints)\n#> [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Importing ISBN Module in Python\nDESCRIPTION: Shows how to import the ISBN module from pydantic_extra_types package. This module provides functionality for validating and processing ISBN (International Standard Book Number) strings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_isbn.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_extra_types.isbn import ISBN\n```\n\n----------------------------------------\n\nTITLE: Migrating from ConstrainedInt to Annotated with Field\nDESCRIPTION: Shows how to replace the deprecated ConstrainedInt class with Annotated and Field constructs in Pydantic V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConstrainedInt\n\n\nclass MyInt(ConstrainedInt):\n    ge = 0\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\n----------------------------------------\n\nTITLE: Validator Ordering Example with Annotated Pattern in Pydantic\nDESCRIPTION: Illustrates the order in which validators are applied when using the annotated pattern. Before and wrap validators run from right to left, while after validators run from left to right.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AfterValidator, BaseModel, BeforeValidator, WrapValidator\n\n\nclass Model(BaseModel):\n    name: Annotated[\n        str,\n        AfterValidator(runs_3rd),\n        AfterValidator(runs_4th),\n        BeforeValidator(runs_2nd),\n        WrapValidator(runs_1st),\n    ]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating union_tag_invalid Error in Pydantic with Discriminated Unions\nDESCRIPTION: This example shows how the 'union_tag_invalid' error is raised when the discriminator value in a Union field doesn't match any of the expected values. It creates a Union of two cat models with a discriminator field but passes an invalid pet_type value.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'pet_type': 'dog'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_invalid'\n```\n\n----------------------------------------\n\nTITLE: Serialization Alias in Pydantic Models\nDESCRIPTION: Shows how to use serialization_alias parameter to specify an alias only for serialization while using the original field name for validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(serialization_alias='username')\n\nuser = User(name='johndoe')  \nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  \n#> {'username': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Function Signatures with validate_call in Python\nDESCRIPTION: Demonstrates how validate_call supports all possible parameter configurations including positional, keyword, positional-only, keyword-only, and variable arguments.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef pos_or_kw(a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(pos_or_kw(1, b=3))\n#> a=1 b=3\n\n\n@validate_call\ndef kw_only(*, a: int, b: int = 2) -> str:\n    return f'a={a} b={b}'\n\n\nprint(kw_only(a=1))\n#> a=1 b=2\nprint(kw_only(a=1, b=3))\n#> a=1 b=3\n\n\n@validate_call\ndef pos_only(a: int, b: int = 2, /) -> str:\n    return f'a={a} b={b}'\n\n\nprint(pos_only(1))\n#> a=1 b=2\n\n\n@validate_call\ndef var_args(*args: int) -> str:\n    return str(args)\n\n\nprint(var_args(1))\n#> (1,)\nprint(var_args(1, 2, 3))\n#> (1, 2, 3)\n\n\n@validate_call\ndef var_kwargs(**kwargs: int) -> str:\n    return str(kwargs)\n\n\nprint(var_kwargs(a=1))\n#> {'a': 1}\nprint(var_kwargs(a=1, b=2))\n#> {'a': 1, 'b': 2}\n\n\n@validate_call\ndef armageddon(\n    a: int,\n    /,\n    b: int,\n    *c: int,\n    d: int,\n    e: int = None,\n    **f: int,\n) -> str:\n    return f'a={a} b={b} c={c} d={d} e={e} f={f}'\n\n\nprint(armageddon(1, 2, d=3))\n#> a=1 b=2 c=() d=3 e=None f={}\nprint(armageddon(1, 2, 3, 4, 5, 6, d=8, e=9, f=10, spam=11))\n#> a=1 b=2 c=(3, 4, 5, 6) d=8 e=9 f={'f': 10, 'spam': 11}\n```\n\n----------------------------------------\n\nTITLE: Using field_title_generator to programmatically generate field titles in Python with Pydantic\nDESCRIPTION: This example demonstrates how to use the field_title_generator parameter in Pydantic's ConfigDict to programmatically generate titles for model fields. The function receives field name and field info as parameters and returns the uppercase version of the field name.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Person(BaseModel):\n    model_config = ConfigDict(\n        field_title_generator=lambda field_name, field_info: field_name.upper()\n    )\n    name: str\n    age: int\n\n\nprint(json.dumps(Person.model_json_schema(), indent=2))\n\"\"\"\n{\n  \"properties\": {\n    \"name\": {\n      \"title\": \"NAME\",\n      \"type\": \"string\"\n    },\n    \"age\": {\n      \"title\": \"AGE\",\n      \"type\": \"integer\"\n    }\n  },\n  \"required\": [\n    \"name\",\n    \"age\"\n  ],\n  \"title\": \"Person\",\n  \"type\": \"object\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_too_short Error with min_length Constraint\nDESCRIPTION: This example shows how a string_too_short error is raised when a string's length is less than the min_length constraint of a field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(min_length=3)\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_short'\n```\n\n----------------------------------------\n\nTITLE: Implementing After Validator using Decorator in Python\nDESCRIPTION: This snippet shows how to implement an After validator using the field_validator decorator in Pydantic. The validator checks if a number is even and raises a ValueError if it's not.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    number: int\n\n    @field_validator('number', mode='after')  # (1)!\n    @classmethod\n    def is_even(cls, value: int) -> int:\n        if value % 2 == 1:\n            raise ValueError(f'{value} is not an even number')\n        return value  # (2)!\n\n\ntry:\n    Model(number=1)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    number\n      Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Updating Custom JSON Schema in Pydantic V2\nDESCRIPTION: Illustrates the new method __get_pydantic_json_schema__ for customizing JSON schema in Pydantic V2, replacing the deprecated __modify_schema__ method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import BaseModel, GetJsonSchemaHandler\n\n\nclass Model(BaseModel):\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n    ) -> dict[str, Any]:\n        json_schema = super().__get_pydantic_json_schema__(core_schema, handler)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema.update(examples=['example'])\n        return json_schema\n\n\nprint(Model.model_json_schema())\n\"\"\"\n{'examples': ['example'], 'properties': {}, 'title': 'Model', 'type': 'object'}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting Pydantic Model Configuration with Inner Class\nDESCRIPTION: Shows how to configure a Pydantic model using the model_config dictionary approach to set model behaviors like freezing attributes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    model_config = dict(frozen=True)\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\n----------------------------------------\n\nTITLE: Input type preservation for collections in Pydantic V2\nDESCRIPTION: Example showing that input types for generic collections are not preserved in Pydantic V2. This demonstrates how a custom dictionary subclass is converted to a standard dict during validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Mapping\n\nfrom pydantic import TypeAdapter\n\n\nclass MyDict(dict):\n    pass\n\n\nta = TypeAdapter(Mapping[str, int])\nv = ta.validate_python(MyDict())\nprint(type(v))\n#> <class 'dict'>\n```\n\n----------------------------------------\n\nTITLE: Creating Pydantic Models with Nested Objects in Python\nDESCRIPTION: Example demonstrating how to create Pydantic models with nested objects, showing how Pydantic can convert dictionary data into model instances.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nclass Quest(BaseModel):\n    title: str\n    knight: Knight\n\n\nquest = Quest(\n    title='To seek the Holy Grail', knight={'title': 'Sir Lancelot', 'age': 23}\n)\n```\n\n----------------------------------------\n\nTITLE: Using Annotated with Field for Constraints in Pydantic V2\nDESCRIPTION: Demonstrates the recommended approach for defining constrained types in Pydantic V2 using Annotated with Field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\nMyInt = Annotated[int, Field(ge=0)]\n\n\nclass Model(BaseModel):\n    x: MyInt\n```\n\n----------------------------------------\n\nTITLE: Customizing Datetime Validation with Pydantic Wrap Validators\nDESCRIPTION: Shows how to use Pydantic's wrap validators to customize the validation of datetime fields. It handles a special 'now' input and adds timezone information to naive datetimes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timezone\nfrom typing import Any\n\nfrom pydantic_core.core_schema import ValidatorFunctionWrapHandler\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Meeting(BaseModel):\n    when: datetime\n\n    @field_validator('when', mode='wrap')\n    def when_now(\n        cls, input_value: Any, handler: ValidatorFunctionWrapHandler\n    ) -> datetime:\n        if input_value == 'now':\n            return datetime.now()\n        when = handler(input_value)\n        # in this specific application we know tz naive datetimes are in UTC\n        if when.tzinfo is None:\n            when = when.replace(tzinfo=timezone.utc)\n        return when\n\n\nprint(Meeting(when='2020-01-01T12:00+01:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=TzInfo(+01:00))\nprint(Meeting(when='now'))\n#> when=datetime.datetime(2032, 1, 2, 3, 4, 5, 6)\nprint(Meeting(when='2020-01-01T12:00'))\n#> when=datetime.datetime(2020, 1, 1, 12, 0, tzinfo=datetime.timezone.utc)\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with TypeAdapter\nDESCRIPTION: This snippet demonstrates how to use strict mode validation with TypeAdapter for both simple types like bool and complex types like dataclasses.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter, ValidationError\n\nprint(TypeAdapter(bool).validate_python('yes'))  # OK: lax\n#> True\n\ntry:\n    TypeAdapter(bool).validate_python('yes', strict=True)  # Not OK: strict\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for bool\n      Input should be a valid boolean [type=bool_type, input_value='yes', input_type=str]\n    \"\"\"\n\nfrom dataclasses import dataclass\n\n@dataclass\nclass MyDataclass:\n    x: int\n\ntry:\n    TypeAdapter(MyDataclass).validate_python({'x': '123'}, strict=True)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for MyDataclass\n      Input should be an instance of MyDataclass [type=dataclass_exact_type, input_value={'x': '123'}, input_type=dict]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Using Type Variables in Named Type Aliases with PEP 695 (Python 3.12+)\nDESCRIPTION: Creates a generic named type alias for a short list with a maximum length constraint, using PEP 695 syntax with inline type parameter declaration.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Len\n\ntype ShortList[T] = Annotated[list[T], Len(max_length=4)]\n```\n\n----------------------------------------\n\nTITLE: Accessing the Original Function with validate_call in Python\nDESCRIPTION: Demonstrates how to access the original undecorated function using the raw_function attribute of a function decorated with validate_call.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import validate_call\n\n\n@validate_call\ndef repeat(s: str, count: int, *, separator: bytes = b'') -> bytes:\n    b = s.encode()\n    return separator.join(b for _ in range(count))\n\n\na = repeat('hello', 3)\nprint(a)\n#> b'hellohellohello'\n\nb = repeat.raw_function('good bye', 2, separator=b', ')\nprint(b)\n#> b'good bye, good bye'\n```\n\n----------------------------------------\n\nTITLE: Implementing Credit Card Number Validation and Security in Python with Pydantic\nDESCRIPTION: This module defines a CreditCardNumber class that extends Pydantic's types to provide validation for payment card numbers. It includes regex patterns for card number validation, secure string representation to hide card details, and sanitization methods to handle input formatting.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_payment.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport re\nfrom typing import ClassVar, List, Optional, Pattern, Union\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler\nfrom pydantic.json_schema import JsonSchemaValue\nfrom pydantic_core import PydanticCustomError, core_schema\n\n__all__ = ['CreditCardNumber']\n\n\nclass CreditCardNumber(str):\n    \"\"\"Validates credit card numbers.\n\n    Algorithm: https://en.wikipedia.org/wiki/Luhn_algorithm\n\n    This validator strips any hyphens or spaces, so the following are equivalent:\n    * \"1234-5678-1234-5678\"\n    * \"1234 5678 1234 5678\"\n    * \"12345678 1234 5678\"\n    * etc.\n\n    Example of accepted patterns: https://gist.github.com/michaelkeevildown/9096cd3aac9029c4e6e05588448a8841\n    \"\"\"\n\n    strip_whitespace: ClassVar[bool] = True\n    min_length: ClassVar[int] = 13\n    max_length: ClassVar[int] = 19\n\n    # Based on https://en.wikipedia.org/wiki/Payment_card_number\n    # and https://www.regular-expressions.info/creditcard.html\n    amex_pattern: ClassVar[Pattern[str]] = re.compile(r'^3[47][0-9]{13}$')\n    mastercard_pattern: ClassVar[Pattern[str]] = re.compile(\n        r'''^(?:5[1-5][0-9]{2}|222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$'''\n    )\n    visa_pattern: ClassVar[Pattern[str]] = re.compile(r'^4[0-9]{12}(?:[0-9]{3})?$')\n    discover_pattern: ClassVar[Pattern[str]] = re.compile(\n        r'''^(?:6011|65[0-9]{2}|64[4-9][0-9])[0-9]{12}|(62[24-68][0-9])[0-9]{13}$'''\n    )\n    diners_pattern: ClassVar[Pattern[str]] = re.compile(r'^3(?:0[0-5]|[68][0-9])[0-9]{11}$')\n    jcb_pattern: ClassVar[Pattern[str]] = re.compile(r'^(?:35[0-9]{3})[0-9]{11}$')\n    cup_pattern: ClassVar[Pattern[str]] = re.compile(r'^(?:62[0-9]{14,17})$')\n\n    @classmethod\n    def __get_validators__(cls) -> List[classmethod]:\n        # one or more validators may be yielded which will be called in the\n        # order to validate the input, each validator will receive as an input\n        # the value returned from the previous validator\n        return [cls.validate]\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, _source_type: type, _handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        return core_schema.general_after_validator_function(\n            cls.validate,\n            core_schema.str_schema(),\n            metadata={\n                'frozen': True,\n            },\n        )\n\n    @classmethod\n    def validate(cls, value: Union[str, 'CreditCardNumber']) -> 'CreditCardNumber':\n        if not isinstance(value, str):\n            raise PydanticCustomError('credit_card_number_type', 'value is not a valid string')\n\n        if isinstance(value, cls):\n            return value\n\n        value = cls.sanitize(value)\n\n        # Check the length\n        if not cls.min_length <= len(value) <= cls.max_length:\n            raise PydanticCustomError(\n                'credit_card_number_format',\n                'card number has invalid length',\n            )\n\n        # Validate that all characters are digits\n        if not value.isdigit():\n            raise PydanticCustomError(\n                'credit_card_number_format',\n                'card number has non-digit characters',\n            )\n\n        # Validate the checksum using the Luhn algorithm\n        if not cls.validate_luhn_check_sum(value):\n            raise PydanticCustomError(\n                'credit_card_number_format',\n                'card number has an invalid checksum',\n            )\n\n        return cls(value)\n\n    @classmethod\n    def sanitize(cls, v: str) -> str:\n        \"\"\"Removes any '-' and space characters and removes leading/trailing whitespace.\"\"\"\n        v = re.sub(r'[-\\s]', '', v)\n        if cls.strip_whitespace:\n            v = v.strip()\n        return v\n\n    @classmethod\n    def validate_luhn_check_sum(cls, value: str) -> bool:\n        \"\"\"Validates the checksum over the passed value.\"\"\"\n        sum_ = int(value[-1])\n        length = len(value)\n        parity = length % 2\n        for i in range(length - 1):\n            digit = int(value[i])\n            if i % 2 == parity:\n                digit *= 2\n            if digit > 9:\n                digit -= 9\n            sum_ += digit\n        return sum_ % 10 == 0\n\n    def is_visa(self) -> bool:\n        return bool(self.visa_pattern.match(self))\n\n    def is_mastercard(self) -> bool:\n        return bool(self.mastercard_pattern.match(self))\n\n    def is_amex(self) -> bool:\n        return bool(self.amex_pattern.match(self))\n\n    def is_discover(self) -> bool:\n        return bool(self.discover_pattern.match(self))\n\n    def is_diners(self) -> bool:\n        return bool(self.diners_pattern.match(self))\n\n    def is_jcb(self) -> bool:\n        return bool(self.jcb_pattern.match(self))\n\n    def is_cup(self) -> bool:\n        return bool(self.cup_pattern.match(self))\n\n    @property\n    def masked(self) -> str:\n        \"\"\"Masks all but the first 6 and last 4 digits.\"\"\"\n        if len(self) <= 10:\n            return '*' * len(self)\n        return f'{self[:6]}{\"*\" * (len(self) - 10)}{self[-4:]}'  # pragma: no cover\n\n    @property\n    def bin(self) -> str:\n        \"\"\"Returns the BIN - the first 6 digits - of the card.\"\"\"\n        return self[:6]\n\n    @property\n    def last4(self) -> str:\n        \"\"\"Returns the last 4 digits of the card.\"\"\"\n        return self[-4:]\n\n    def __repr__(self) -> str:\n        return f\"CreditCardNumber('{self.masked}')\"\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, _core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        return handler.resolve_ref_schema({\n            'type': 'string',\n            'format': 'credit-card-number',\n            'description': 'Credit card number',\n        })\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of validate_call with Callable Instances in Python\nDESCRIPTION: Shows how to use validate_call with callable instances. Instead of applying it to the instance, it should be applied to the __call__ method of the class.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    class A1:\n        def __call__(self): ...\n\n    validate_call(A1())\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\nclass A2:\n    @validate_call\n    def __call__(self): ...\n```\n\n----------------------------------------\n\nTITLE: Handling Callable Discriminator with Missing Tags in Pydantic\nDESCRIPTION: Demonstrates the error raised when a Union using a callable Discriminator doesn't have Tag annotations for all cases, and how to properly annotate the Union choices.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Union\n\nfrom pydantic import BaseModel, Discriminator, PydanticUserError, Tag\n\n\ndef model_x_discriminator(v):\n    if isinstance(v, str):\n        return 'str'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n\n\n# tag missing for both union choices\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `'DiscriminatedModel'` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[Annotated[str, Tag('str')], 'DiscriminatedModel'],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n\n# tag missing for `str` union choice\ntry:\n\n    class DiscriminatedModel(BaseModel):\n        x: Annotated[\n            Union[str, Annotated['DiscriminatedModel', Tag('model')]],\n            Discriminator(model_x_discriminator),\n        ]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'callable-discriminator-no-tag'\n```\n\n----------------------------------------\n\nTITLE: Debugging Pydantic Models with Python-Devtools\nDESCRIPTION: Example showing how to use python-devtools' debug() function with Pydantic models. The code creates nested Pydantic models (Address and User) and demonstrates the difference between debug() and print() output formatting. The example includes type annotations and data conversion capabilities of Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/devtools.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom devtools import debug\n\nfrom pydantic import BaseModel\n\n\nclass Address(BaseModel):\n    street: str\n    country: str\n    lat: float\n    lng: float\n\n\nclass User(BaseModel):\n    id: int\n    name: str\n    signup_ts: datetime\n    friends: list[int]\n    address: Address\n\n\nuser = User(\n    id='123',\n    name='John Doe',\n    signup_ts='2019-06-01 12:22',\n    friends=[1234, 4567, 7890],\n    address=dict(street='Testing', country='uk', lat=51.5, lng=0),\n)\ndebug(user)\nprint('\\nshould be much easier read than:\\n')\nprint('user:', user)\n```\n\n----------------------------------------\n\nTITLE: Validation Alias in Pydantic Models\nDESCRIPTION: Demonstrates using validation_alias parameter to specify an alias only for validation purposes while maintaining the original field name for serialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass User(BaseModel):\n    name: str = Field(validation_alias='username')\n\nuser = User(username='johndoe')  \nprint(user)\n#> name='johndoe'\nprint(user.model_dump(by_alias=True))  \n#> {'name': 'johndoe'}\n```\n\n----------------------------------------\n\nTITLE: Using Pydantic's Strict Mode and Data Coercion\nDESCRIPTION: This example demonstrates Pydantic's flexible validation modes: the default mode that coerces data types, strict mode that requires exact type matching, and JSON validation that intelligently parses strings into appropriate Python types like datetime and bytes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n\n\nm = Meeting.model_validate({'when': '2020-01-01T12:00', 'where': 'home'})\nprint(m)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\ntry:\n    m = Meeting.model_validate(\n        {'when': '2020-01-01T12:00', 'where': 'home'}, strict=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    2 validation errors for Meeting\n    when\n      Input should be a valid datetime [type=datetime_type, input_value='2020-01-01T12:00', input_type=str]\n    where\n      Input should be a valid bytes [type=bytes_type, input_value='home', input_type=str]\n    \"\"\"\n\nm_json = Meeting.model_validate_json(\n    '{\"when\": \"2020-01-01T12:00\", \"where\": \"home\"}'\n)\nprint(m_json)\n#> when=datetime.datetime(2020, 1, 1, 12, 0) where=b'home'\n```\n\n----------------------------------------\n\nTITLE: Using typing.cast to Override Type Checking Inline with Pydantic\nDESCRIPTION: Demonstrates how to use typing.cast to override type checking inline when creating Pydantic model instances with type-converted values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, cast\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age=cast(Any, '23'))\n```\n\n----------------------------------------\n\nTITLE: Creating Generic Subclasses with Modified Type Parameters\nDESCRIPTION: Example demonstrating how to create a generic subclass that partially or fully replaces the type variables from the parent class. Shows how a child class can use some of the parent's type variables while adding new ones.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTypeX = TypeVar('TypeX')\nTypeY = TypeVar('TypeY')\nTypeZ = TypeVar('TypeZ')\n\n\nclass BaseClass(BaseModel, Generic[TypeX, TypeY]):\n    x: TypeX\n    y: TypeY\n\n\nclass ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):\n    z: TypeZ\n```\n\n----------------------------------------\n\nTITLE: Implementing Attribute Aliases in Pydantic\nDESCRIPTION: This code snippet defines the core functionality for handling attribute aliases in Pydantic. It includes the AliasGenerator class, which is used to generate aliases, and the AliasPath class, which represents a path of aliases.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/aliases.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom typing import Any, Callable, Dict, Iterable, List, Union\n\nfrom .typing import AnyCallable\n\nAliasType = Union[str, AliasGenerator, AliasPath]\n\n\nclass AliasGenerator:\n    __slots__ = ()\n\n    def __call__(self, field: Any) -> str:\n        raise NotImplementedError()\n\n\nclass AliasPath:\n    __slots__ = ('path',)\n\n    def __init__(self, path: Union[str, Iterable[str]]) -> None:\n        if isinstance(path, str):\n            self.path: List[str] = [path]\n        else:\n            self.path = list(path)\n\n    def __getitem__(self, item: Any) -> AliasPath:\n        if isinstance(item, (int, slice)):\n            return AliasPath(self.path[item])\n        else:\n            return AliasPath([*self.path, str(item)])\n\n    def __repr__(self) -> str:\n        return f'AliasPath({self.path!r})'\n\n\ndef to_pascal(string: str) -> str:\n    \"\"\"Converts a string to PascalCase.\"\"\"\n    return ''.join(word.capitalize() for word in string.replace('-', '_').split('_'))\n\n\ndef to_camel(string: str) -> str:\n    \"\"\"Converts a string to camelCase.\"\"\"\n    pascal = to_pascal(string)\n    return pascal[0].lower() + pascal[1:]\n\n\nclass AliasChoiceGenerator(AliasGenerator):\n    def __init__(self, *choices: Union[str, Callable[[Any], str]]) -> None:\n        self.choices = choices\n\n    def __call__(self, field: Any) -> str:\n        from .fields import FieldInfo\n\n        assert isinstance(field, FieldInfo)\n        for choice in self.choices:\n            if callable(choice):\n                name = choice(field)\n            else:\n                name = choice.format(field=field)\n            if name is not None:\n                return name\n        return field.name\n\n\ndef resolve_aliases(\n    raw_alias: AnyCallable | AliasChoiceGenerator | AliasType | None,\n    alias_generator: AnyCallable | None,\n    use_alias_generator: bool,\n) -> Dict[str, str]:\n    if raw_alias is None:\n        alias: AliasType | None = alias_generator(field) if alias_generator and use_alias_generator else None\n    elif isinstance(raw_alias, AliasChoiceGenerator):\n        alias = raw_alias(field)\n    elif callable(raw_alias):\n        alias = raw_alias(field)\n    else:\n        alias = raw_alias\n\n    if isinstance(alias, str):\n        return {alias: field.name}\n    elif isinstance(alias, AliasPath):\n        return {str(alias.path[-1]): field.name}\n    elif alias is None:\n        return {}\n    else:\n        raise TypeError(f'Invalid alias type: {type(alias)}')\n\n```\n\n----------------------------------------\n\nTITLE: Marking Fields as Deprecated in Pydantic\nDESCRIPTION: Demonstrates how to use the deprecated parameter to mark fields as deprecated in a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    deprecated_field: Annotated[int, Field(deprecated='This is deprecated')]\n\n\nprint(Model.model_json_schema()['properties']['deprecated_field'])\n#> {'deprecated': True, 'title': 'Deprecated Field', 'type': 'integer'}\n```\n\n----------------------------------------\n\nTITLE: Adding the New Test Case to Mypy Test Suite\nDESCRIPTION: Illustrates how to add a new file to the list of test cases within the `test_mypy.py` file. This step associates the newly created module with a specific configuration file.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ncases: list[ParameterSet | tuple[str, str]] = [\n    ...\n    # One-off cases\n    *[\n         ('mypy-plugin.ini', 'custom_constructor.py'),\n         ('mypy-plugin.ini', 'config_conditional_extra.py'),\n         ...,\n         ('mypy-plugin.ini', 'new_test.py'),  # <-- new test added.\n     ]\n]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pydantic's Serialization Capabilities\nDESCRIPTION: This example shows Pydantic's three serialization methods: to Python dictionaries with native types, to dictionaries with JSON-compatible types, and directly to JSON strings. It also demonstrates customization options like excluding specific fields or default values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import BaseModel\n\n\nclass Meeting(BaseModel):\n    when: datetime\n    where: bytes\n    why: str = 'No idea'\n\n\nm = Meeting(when='2020-01-01T12:00', where='home')\nprint(m.model_dump(exclude_unset=True))\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nprint(m.model_dump(exclude={'where'}, mode='json'))\n#> {'when': '2020-01-01T12:00:00', 'why': 'No idea'}\nprint(m.model_dump_json(exclude_defaults=True))\n#> {\"when\":\"2020-01-01T12:00:00\",\"where\":\"home\"}\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Behavior with Nested Models\nDESCRIPTION: Illustrates that strict mode is not automatically propagated to nested model fields, showing how a parent model's strict mode doesn't affect validation of a child model's fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Inner(BaseModel):\n    y: int\n\n\nclass Outer(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n    x: int\n    inner: Inner\n\n\nprint(Outer(x=1, inner=Inner(y='2')))\n#> x=1 inner=Inner(y=2)\n\ntry:\n    Outer(x='1', inner=Inner(y='2'))\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Outer\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Defining a Root Model in Pydantic\nDESCRIPTION: This snippet demonstrates how to define a root model in Pydantic using the RootModel class. The model wraps a single value of type int, which becomes the root value of the model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/root_model.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\nclass MyModel(RootModel[int]):\n    pass\n\nprint(MyModel(1).model_dump())\n# > 1\nprint(MyModel.model_validate(1).root)\n# > 1\n```\n\n----------------------------------------\n\nTITLE: Implementing ABA Routing Number Validation in Python with Pydantic\nDESCRIPTION: This class implements validation and normalization for ABA routing numbers (RTNs). It extends Pydantic's model system to ensure routing numbers pass the standard checksum verification and can be formatted in different styles (with or without dashes).\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_routing_numbers.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nimport re\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass RoutingNumber(BaseModel):\n    \"\"\"Model for ABA Routing Transit Number (RTN).\n\n    A routing transit number is a nine-digit number used to identify a bank or financial institution\n    when clearing funds for electronic transfers or processing checks in the United States.\n\n    The checksum verification works as follows:\n    1. Multiply each digit by the corresponding weight value\n    2. Sum the resulting values\n    3. Check if the sum modulo 10 equals 0\n\n    Each digit position of the routing number is assigned a specific weight:\n    - Positions 1, 4, 7: Weight 3\n    - Positions 2, 5, 8: Weight 7\n    - Positions 3, 6, 9: Weight 1\n\n    Example:\n        For routing number 111000025:\n        (1 × 3) + (1 × 7) + (1 × 1) + (0 × 3) + (0 × 7) + (0 × 1) + (0 × 3) + (2 × 7) + (5 × 1) = 3 + 7 + 1 + 0 + 0 + 0 + 0 + 14 + 5 = 30\n        30 mod 10 = 0, so the routing number is valid.\n    \"\"\"\n\n    __slots__ = ('value',)\n\n    value: str\n\n    # ABA routing number with dashes\n    _re_dash: ClassVar[re.Pattern] = re.compile(r'^(?P<first>\\d{3})-(?P<second>\\d{3})-(?P<third>\\d{3})$')\n    # ABA routing number without dashes\n    _re_no_dash: ClassVar[re.Pattern] = re.compile(r'^(?P<first>\\d{3})(?P<second>\\d{3})(?P<third>\\d{3})$')\n\n    def __init__(self, value: str | RoutingNumber) -> None:\n        if isinstance(value, RoutingNumber):\n            value = value.value\n\n        if dash_match := self._re_dash.match(value):\n            # Format is XXX-XXX-XXX\n            rtn = f\"{dash_match['first']}{dash_match['second']}{dash_match['third']}\"\n        elif no_dash_match := self._re_no_dash.match(value):\n            # Format is XXXXXXXXX\n            rtn = value\n        else:\n            raise ValueError('Invalid routing number format')\n\n        # Validate the routing number using the checksum\n        if not self._is_valid(rtn):\n            raise ValueError('Invalid routing number (checksum validation failed)')\n\n        super().__init__(value=rtn)\n\n    @classmethod\n    def _is_valid(cls, rtn: str) -> bool:\n        # Check if the routing number is valid based on the checksum\n        # Each digit has a specific weight: 3, 7, 1, 3, 7, 1, 3, 7, 1\n        weights = [3, 7, 1, 3, 7, 1, 3, 7, 1]\n        return sum(int(digit) * weight for digit, weight in zip(rtn, weights)) % 10 == 0\n\n    def format(self, with_dashes: bool = False) -> str:\n        \"\"\"Format the routing number with or without dashes.\n\n        Args:\n            with_dashes: Whether to include dashes in the formatting (XXX-XXX-XXX).\n\n        Returns:\n            The formatted routing number string.\n        \"\"\"\n        if with_dashes:\n            return f\"{self.value[:3]}-{self.value[3:6]}-{self.value[6:]}\"\n        return self.value\n\n    def __str__(self) -> str:\n        return self.value\n\n```\n\n----------------------------------------\n\nTITLE: Importing Pydantic Fields Components\nDESCRIPTION: This code snippet demonstrates how to import key components from the pydantic.fields module. These components are essential for defining and manipulating fields in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/fields.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.fields import Field, FieldInfo, PrivateAttr, ModelPrivateAttr, computed_field, ComputedFieldInfo\n```\n\n----------------------------------------\n\nTITLE: Enabling Pydantic Mypy Plugin with mypy.ini\nDESCRIPTION: Configuration example showing how to enable the Pydantic mypy plugin in a mypy.ini configuration file, which allows mypy to perform enhanced type checking on Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy\n```\n\n----------------------------------------\n\nTITLE: Using SkipValidation Special Type in Pydantic\nDESCRIPTION: Demonstrates how to use the SkipValidation utility to skip validation on a field. This allows values of incorrect types to be assigned to a field, which may emit warnings during serialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, SkipValidation\n\n\nclass Model(BaseModel):\n    names: list[SkipValidation[str]]\n\n\nm = Model(names=['foo', 'bar'])\nprint(m)\n#> names=['foo', 'bar']\n\nm = Model(names=['foo', 123])  # (1)!\nprint(m)\n#> names=['foo', 123]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating time_delta_parsing Error with Invalid Timedelta String\nDESCRIPTION: This example shows how a time_delta_parsing error is raised when a string value cannot be parsed for a timedelta field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x='t')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_parsing'\n```\n\n----------------------------------------\n\nTITLE: Validating Lists of Objects with TypeAdapter\nDESCRIPTION: Demonstrates how to validate a list of JSON objects using Pydantic's TypeAdapter. This approach is useful when dealing with collections of data that need to be validated against the same model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n[\n    {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"email\": \"john@example.com\"\n    },\n    {\n        \"name\": \"Jane Doe\",\n        \"age\": 25,\n        \"email\": \"jane@example.com\"\n    }\n]\n```\n\nLANGUAGE: python\nCODE:\n```\nimport pathlib\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt, TypeAdapter\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nperson_list_adapter = TypeAdapter(list[Person])  # (1)!\n\njson_string = pathlib.Path('people.json').read_text()\npeople = person_list_adapter.validate_json(json_string)\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```\n\n----------------------------------------\n\nTITLE: Using AliasGenerator for Validation and Serialization in Python with Pydantic\nDESCRIPTION: Demonstrates the use of AliasGenerator to specify different alias generators for validation and serialization in a Pydantic model. This allows for different naming conventions when loading and saving data.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AliasGenerator, BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=AliasGenerator(\n            validation_alias=lambda field_name: field_name.upper(),\n            serialization_alias=lambda field_name: field_name.title(),\n        )\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'Age': 12, 'Height': 1.2, 'Kind': 'oak'}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating revalidate_instances='never' Configuration in Pydantic\nDESCRIPTION: Shows how setting revalidate_instances to 'never' (the default) allows invalid models to pass validation when an existing model instance is passed to model_validate(). This example demonstrates how model validation can be bypassed.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\n# doesn't raise a validation error even though m is invalid\nm2 = Model.model_validate(m)\n```\n\n----------------------------------------\n\nTITLE: Documenting Pydantic Arguments Schema API in Markdown\nDESCRIPTION: Markdown directive to include documentation for the generate_arguments_schema function from pydantic.experimental.arguments_schema module.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/experimental.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n::: pydantic.experimental.arguments_schema\n    options:\n        members:\n            - generate_arguments_schema\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Type References in Pydantic Models\nDESCRIPTION: Demonstrates how Pydantic raises a PydanticUserError when a type referenced in an annotation is not defined. This can occur with forward references or when types are defined after usage.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ForwardRef\n\nfrom pydantic import BaseModel, PydanticUserError\n\nUndefinedType = ForwardRef('UndefinedType')\n\n\nclass Foobar(BaseModel):\n    a: UndefinedType\n\n\ntry:\n    Foobar(a=1)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'class-not-fully-defined'\n```\n\n----------------------------------------\n\nTITLE: Disabling JSON schema sorting in Pydantic\nDESCRIPTION: This example demonstrates how to disable the automatic sorting of JSON schema fields by overriding the sort method in a custom GenerateJsonSchema subclass. The example shows how field and json_schema_extra property order is preserved when sorting is disabled.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Optional\n\nfrom pydantic import BaseModel, Field\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def sort(\n        self, value: JsonSchemaValue, parent_key: Optional[str] = None\n    ) -> JsonSchemaValue:\n        \"\"\"No-op, we don't want to sort schema values at all.\"\"\"\n        return value\n\n\nclass Bar(BaseModel):\n    c: str\n    b: str\n    a: str = Field(json_schema_extra={'c': 'hi', 'b': 'hello', 'a': 'world'})\n\n\njson_schema = Bar.model_json_schema(schema_generator=MyGenerateJsonSchema)\nprint(json.dumps(json_schema, indent=2))\n\"\"\"\n{\n  \"type\": \"object\",\n  \"properties\": {\n    \"c\": {\n      \"type\": \"string\",\n      \"title\": \"C\"\n    },\n    \"b\": {\n      \"type\": \"string\",\n      \"title\": \"B\"\n    },\n    \"a\": {\n      \"type\": \"string\",\n      \"c\": \"hi\",\n      \"b\": \"hello\",\n      \"a\": \"world\",\n      \"title\": \"A\"\n    }\n  },\n  \"required\": [\n    \"c\",\n    \"b\",\n    \"a\"\n  ],\n  \"title\": \"Bar\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Model Using model_config in Python\nDESCRIPTION: Demonstrates how to use the model_config class attribute to set configuration options for a Pydantic model. In this example, it sets a maximum string length of 5 characters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    model_config = ConfigDict(str_max_length=5)  # (1)!\n\n    v: str\n\n\ntry:\n    m = Model(v='abcdef')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    v\n      String should have at most 5 characters [type=string_too_long, input_value='abcdef', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Importing lenient_isinstance from Pydantic V1\nDESCRIPTION: Example of importing a function that has been removed from Pydantic V2, using the v1 namespace.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1.utils import lenient_isinstance\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unexpected_positional_argument Error with Keyword-Only Arguments\nDESCRIPTION: This example shows how an unexpected_positional_argument error is raised when providing a positional argument for a keyword-only parameter in a function decorated with validate_call.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(*, a: int):\n    return a\n\n\ntry:\n    foo(2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_positional_argument'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_sub_type Error with Strict String Fields\nDESCRIPTION: This example shows how a string_sub_type error is raised when a string subtype (like Enum) is provided to a strict string field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom enum import Enum\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass MyEnum(str, Enum):\n    foo = 'foo'\n\n\nclass Model(BaseModel):\n    x: str = Field(strict=True)\n\n\ntry:\n    Model(x=MyEnum.foo)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_sub_type'\n```\n\n----------------------------------------\n\nTITLE: Dictionary Key Type Validation\nDESCRIPTION: Demonstrates invalid_key error when a dictionary contains non-string keys.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n    model_config = ConfigDict(extra='allow')\n\n\ntry:\n    Model.model_validate({'x': 1, b'y': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'invalid_key'\n```\n\n----------------------------------------\n\nTITLE: Handling datetime_parsing Error in Pydantic\nDESCRIPTION: Shows validation error when attempting to parse an invalid string as datetime\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom datetime import datetime\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: datetime = Field(strict=True)\n\n\ntry:\n    Model.model_validate_json(json.dumps({'x': 'not a datetime'}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_parsing'\n```\n\n----------------------------------------\n\nTITLE: Correct Usage of validate_call with Class Constructors in Python\nDESCRIPTION: Demonstrates how to correctly use validate_call with class constructors. Instead of applying it to the class itself, it should be applied to the __init__ or __new__ methods.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, validate_call\n\n# error\ntry:\n\n    @validate_call\n    class A1: ...\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n\n\n# correct\nclass A2:\n    @validate_call\n    def __init__(self): ...\n\n    @validate_call\n    def __new__(cls): ...\n```\n\n----------------------------------------\n\nTITLE: Importing ModelField from Pydantic V1 (>=1.10.17,<3)\nDESCRIPTION: Example of importing ModelField from Pydantic V1 using the .v1 namespace in versions 1.10.17 and later.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1.fields import ModelField\n```\n\n----------------------------------------\n\nTITLE: Demonstrating set_type Error with Invalid Set Value\nDESCRIPTION: This example shows how a set_type error is raised when the input value type is not valid for a set field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Set\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: Set[int]\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_type'\n```\n\n----------------------------------------\n\nTITLE: Configuring TypedDict Using with_config Decorator in Python\nDESCRIPTION: Shows how to configure a TypedDict using the with_config decorator. This method avoids static type checking errors. The example sets the str_to_lower option to True.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, with_config\n\n\n@with_config(ConfigDict(str_to_lower=True))\nclass Model(TypedDict):\n    x: str\n```\n\n----------------------------------------\n\nTITLE: Demonstrating uuid_type Error in Pydantic UUID Validation\nDESCRIPTION: This example shows how the 'uuid_type' error is raised when the input value's type is not valid for a UUID field. It attempts to use an integer instead of a string, bytes, or UUID instance.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u=1234567812412341234567812345678)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_type'\n```\n\n----------------------------------------\n\nTITLE: Validating CSV Files with Pydantic\nDESCRIPTION: Demonstrates how to validate data from a CSV file using Python's csv module in combination with Pydantic. The example reads the CSV data as dictionaries and validates each row against the Person model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/examples/files.md#2025-04-22_snippet_4\n\nLANGUAGE: csv\nCODE:\n```\nname,age,email\nJohn Doe,30,john@example.com\nJane Doe,25,jane@example.com\n```\n\nLANGUAGE: python\nCODE:\n```\nimport csv\n\nfrom pydantic import BaseModel, EmailStr, PositiveInt\n\n\nclass Person(BaseModel):\n    name: str\n    age: PositiveInt\n    email: EmailStr\n\n\nwith open('people.csv') as f:\n    reader = csv.DictReader(f)\n    people = [Person.model_validate(row) for row in reader]\n\nprint(people)\n#> [Person(name='John Doe', age=30, email='john@example.com'), Person(name='Jane Doe', age=25, email='jane@example.com')]\n```\n\n----------------------------------------\n\nTITLE: Configuring mkdocstrings for Pydantic Documentation References\nDESCRIPTION: This YAML configuration shows how to set up mkdocstrings in MkDocs to import Pydantic's object inventory. This allows for cross-referencing Pydantic's API documentation in MkDocs projects.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/documentation.md#2025-04-22_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\nplugins:\n- mkdocstrings:\n    handlers:\n      python:\n        import:\n        - https://docs.pydantic.dev/latest/objects.inv  # (1)!\n```\n\n----------------------------------------\n\nTITLE: FrozenSet Validation in Pydantic Models\nDESCRIPTION: Demonstrates how Pydantic validates and converts data to frozenset types, showing both simple and typed frozensets with automatic type conversion.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import FrozenSet, Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    simple_frozenset: Optional[frozenset] = None\n    frozenset_of_ints: Optional[FrozenSet[int]] = None\n\n\nm1 = Model(simple_frozenset=['1', '2', '3'])\nprint(type(m1.simple_frozenset))\n#> <class 'frozenset'>\nprint(sorted(m1.simple_frozenset))\n#> ['1', '2', '3']\n\nm2 = Model(frozenset_of_ints=['1', '2', '3'])\nprint(type(m2.frozenset_of_ints))\n#> <class 'frozenset'>\nprint(sorted(m2.frozenset_of_ints))\n#> [1, 2, 3]\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Discriminator Validator in Pydantic\nDESCRIPTION: Shows how to work around the restriction on using before, wrap, or plain validators on discriminator fields by using a standard Union without a discriminator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, field_validator\n\n\nclass Cat(BaseModel):\n    pet_type: Literal['cat']\n\n    @field_validator('pet_type', mode='before')\n    @classmethod\n    def validate_pet_type(cls, v):\n        if v == 'kitten':\n            return 'cat'\n        return v\n\n\nclass Dog(BaseModel):\n    pet_type: Literal['dog']\n\n\nclass Model(BaseModel):\n    pet: Union[Cat, Dog]\n\n\nassert Model(pet={'pet_type': 'kitten'}).pet.pet_type == 'cat'\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Validator Fields Error in Python with Pydantic\nDESCRIPTION: Shows how Pydantic raises a PydanticUserError when a validator is used with non-string fields. It also demonstrates the correct way to specify multiple fields for a validator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n        b: str\n\n        @field_validator(['a', 'b'])\n        def check_fields(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-invalid-fields'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n    b: str\n\n    @field_validator('a', 'b')\n    def check_fields(cls, v):\n        return v\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Signature Error with validate_call in Python\nDESCRIPTION: Demonstrates the error raised when trying to use validate_call on a method without at least one argument. This is typically an issue with instance methods that don't have a 'self' parameter.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    class A:\n        def f(): ...\n\n    validate_call(A().f)\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validate-call-type'\n```\n\n----------------------------------------\n\nTITLE: Handling datetime_past Error in Pydantic\nDESCRIPTION: Demonstrates validation error when a future datetime is provided for a PastDatetime field\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timedelta\n\nfrom pydantic import BaseModel, PastDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: PastDatetime\n\n\ntry:\n    Model(x=datetime.now() + timedelta(100))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_past'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating url_parsing Error in Pydantic URL Validation\nDESCRIPTION: This example shows how the 'url_parsing' error is raised when a value cannot be parsed as a valid URL. It attempts to validate a simple string 'test' as an AnyUrl type, which fails URL parsing.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_35\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import AnyUrl, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AnyUrl\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_parsing'\n```\n\n----------------------------------------\n\nTITLE: Using ellipsis in Field() for required fields\nDESCRIPTION: Shows how to use ellipsis to emphasize a field is required, though the usage is discouraged for compatibility with static type checkers.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nclass Model(BaseModel):\n    name: str = Field(..., frozen=True)\n```\n\n----------------------------------------\n\nTITLE: Importing Color Module from Pydantic Extra Types in Python\nDESCRIPTION: Shows how to import the color module from pydantic_extra_types package. This module provides color types and functionality for working with colors in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_color.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_extra_types.color import Color\n```\n\n----------------------------------------\n\nTITLE: Importing Pydantic Alias Generator Module Documentation\nDESCRIPTION: MkDocs directive to import and display the pydantic.alias_generators module documentation. Configures display options to show the root heading in the generated documentation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/config.md#2025-04-22_snippet_1\n\nLANGUAGE: markdown\nCODE:\n```\n::: pydantic.alias_generators\n    options:\n      show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Demonstrating tuple_type Error with Invalid Tuple Value\nDESCRIPTION: This example shows how a tuple_type error is raised when the input value's type is not valid for a tuple field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: tuple[int]\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'tuple_type'\n```\n\n----------------------------------------\n\nTITLE: Callable Discriminator with Model and Primitive Types\nDESCRIPTION: This snippet illustrates how to use a callable discriminator to validate a union of a model and a primitive type (int). The `model_x_discriminator` function determines the type based on the input value and returns a tag. The `DiscriminatedModel` uses this discriminator to validate the `value` field, allowing it to be either an integer or a `SpecialValue` model. A `ValidationError` is raised if the input is neither an integer nor a model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any, Union\n\nfrom pydantic import BaseModel, Discriminator, Tag, ValidationError\n\n\ndef model_x_discriminator(v: Any) -> str:\n    if isinstance(v, int):\n        return 'int'\n    if isinstance(v, (dict, BaseModel)):\n        return 'model'\n    else:\n        # return None if the discriminator value isn't found\n        return None\n\n\nclass SpecialValue(BaseModel):\n    value: int\n\n\nclass DiscriminatedModel(BaseModel):\n    value: Annotated[\n        Union[\n            Annotated[int, Tag('int')],\n            Annotated['SpecialValue', Tag('model')],\n        ],\n        Discriminator(model_x_discriminator),\n    ]\n\n\nmodel_data = {'value': {'value': 1}}\nm = DiscriminatedModel.model_validate(model_data)\nprint(m)\n#> value=SpecialValue(value=1)\n\nint_data = {'value': 123}\nm = DiscriminatedModel.model_validate(int_data)\nprint(m)\n#> value=123\n\ntry:\n    DiscriminatedModel.model_validate({'value': 'not an int or a model'})\nexcept ValidationError as e:\n    print(e)  # (1)!\n    \"\"\"\n    1 validation error for DiscriminatedModel\n    value\n      Unable to extract tag using discriminator model_x_discriminator() [type=union_tag_not_found, input_value='not an int or a model', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with Annotated and Strict Class\nDESCRIPTION: This snippet shows how to use the Strict class with Annotated to enable strict mode validation for specific fields in a Pydantic model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Strict, ValidationError\n\nclass User(BaseModel):\n    name: str\n    age: int\n    is_active: Annotated[bool, Strict()]\n\nUser(name='David', age=33, is_active=True)\ntry:\n    User(name='David', age=33, is_active='True')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for User\n    is_active\n      Input should be a valid boolean [type=bool_type, input_value='True', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Handling Pydantic V1 Validator Signature Error\nDESCRIPTION: This example demonstrates how Pydantic raises a PydanticUserError when using an unsupported signature for V1-style validator. The error occurs because the validator function has an unexpected third parameter 'foo'.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import BaseModel, PydanticUserError, validator\n\nwarnings.filterwarnings('ignore', category=DeprecationWarning)\n\ntry:\n\n    class Model(BaseModel):\n        a: int\n\n        @validator('a')\n        def check_a(cls, value, foo):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-v1-signature'\n```\n\n----------------------------------------\n\nTITLE: Controlling Field Representation in Pydantic Models\nDESCRIPTION: Demonstrates how to use the repr parameter to control field inclusion in the string representation of a model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    name: str = Field(repr=True)  # (1)!\n    age: int = Field(repr=False)\n\n\nuser = User(name='John', age=42)\nprint(user)\n#> name='John'\n```\n\n----------------------------------------\n\nTITLE: Validating and Serializing TypedDict with Pydantic TypeAdapter\nDESCRIPTION: Demonstrates how to use Pydantic's TypeAdapter to validate and serialize a TypedDict. It shows validation of Python data, serialization with exclusion, and JSON schema generation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/why.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom typing_extensions import NotRequired, TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Meeting(TypedDict):\n    when: datetime\n    where: bytes\n    why: NotRequired[str]\n\n\nmeeting_adapter = TypeAdapter(Meeting)\nm = meeting_adapter.validate_python(  # (1)!\n    {'when': '2020-01-01T12:00', 'where': 'home'}\n)\nprint(m)\n#> {'when': datetime.datetime(2020, 1, 1, 12, 0), 'where': b'home'}\nmeeting_adapter.dump_python(m, exclude={'where'})  # (2)!\n\nprint(meeting_adapter.json_schema())  # (3)!\n\"\"\"\n{\n    'properties': {\n        'when': {'format': 'date-time', 'title': 'When', 'type': 'string'},\n        'where': {'format': 'binary', 'title': 'Where', 'type': 'string'},\n        'why': {'title': 'Why', 'type': 'string'},\n    },\n    'required': ['when', 'where'],\n    'title': 'Meeting',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_type Error with Invalid String Value\nDESCRIPTION: This example shows how a string_type error is raised when a non-string value is provided for a string field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_type'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclass Validation Lifecycle with __post_init__\nDESCRIPTION: An example demonstrating the complete validation lifecycle of a Pydantic dataclass, showing how before validators, __post_init__, and after validators work together. The example uses nested dataclasses and illustrates the execution order of all validation steps.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic_core import ArgsKwargs\nfrom typing_extensions import Self\n\nfrom pydantic import model_validator\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass Birth:\n    year: int\n    month: int\n    day: int\n\n\n@dataclass\nclass User:\n    birth: Birth\n\n    @model_validator(mode='before')\n    @classmethod\n    def before(cls, values: ArgsKwargs) -> ArgsKwargs:\n        print(f'First: {values}')  # (1)!\n        \"\"\"\n        First: ArgsKwargs((), {'birth': {'year': 1995, 'month': 3, 'day': 2}})\n        \"\"\"\n        return values\n\n    @model_validator(mode='after')\n    def after(self) -> Self:\n        print(f'Third: {self}')\n        #> Third: User(birth=Birth(year=1995, month=3, day=2))\n        return self\n\n    def __post_init__(self):\n        print(f'Second: {self.birth}')\n        #> Second: Birth(year=1995, month=3, day=2)\n\n\nuser = User(**{'birth': {'year': 1995, 'month': 3, 'day': 2}})\n```\n\n----------------------------------------\n\nTITLE: Using Stdlib Dataclasses with Pydantic Models\nDESCRIPTION: Shows how standard library dataclasses are validated when used within Pydantic models. This example demonstrates validation of nested dataclasses and handling of frozen instances.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\n@dataclasses.dataclass(frozen=True)\nclass User:\n    name: str\n\n\nclass Foo(BaseModel):\n    # Required so that pydantic revalidates the model attributes:\n    model_config = ConfigDict(revalidate_instances='always')\n\n    user: Optional[User] = None\n\n\n# nothing is validated as expected:\nuser = User(name=['not', 'a', 'string'])\nprint(user)\n#> User(name=['not', 'a', 'string'])\n\n\ntry:\n    Foo(user=user)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Foo\n    user.name\n      Input should be a valid string [type=string_type, input_value=['not', 'a', 'string'], input_type=list]\n    \"\"\"\n\nfoo = Foo(user=User(name='pika'))\ntry:\n    foo.user.name = 'bulbi'\nexcept dataclasses.FrozenInstanceError as e:\n    print(e)\n    #> cannot assign to field 'name'\n```\n\n----------------------------------------\n\nTITLE: Importing Annotated Handlers in Pydantic (Python)\nDESCRIPTION: This code snippet demonstrates how to import the annotated_handlers module from Pydantic. It provides access to various handlers and utilities for working with annotated types in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/annotated_handlers.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import annotated_handlers\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Field Definitions in create_model() with Python and Pydantic\nDESCRIPTION: Demonstrates how Pydantic raises a PydanticUserError when invalid field definitions are provided to the create_model() function.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, create_model\n\ntry:\n    create_model('FooModel', foo=(str, 'default value', 'more'))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'create-model-field-definitions'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating uuid_parsing Error in Pydantic UUID Validation\nDESCRIPTION: This example demonstrates how the 'uuid_parsing' error is raised when a string cannot be parsed as a valid UUID. It attempts to validate a malformed UUID string that doesn't follow the correct format.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID\n\n\ntry:\n    Model(u='12345678-124-1234-1234-567812345678')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_parsing'\n```\n\n----------------------------------------\n\nTITLE: Handling RootModel Extra Config Error\nDESCRIPTION: This example demonstrates how Pydantic raises an error when trying to specify 'extra' in model_config with RootModel. The error occurs because RootModel cannot store or accept extra fields during initialization.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import PydanticUserError, RootModel\n\ntry:\n\n    class MyRootModel(RootModel):\n        model_config = {'extra': 'allow'}\n        root: int\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'root-model-extra'\n```\n\n----------------------------------------\n\nTITLE: Importing ModelField with version compatibility\nDESCRIPTION: Example of importing ModelField that works across different Pydantic versions, including V1 and V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\ntry:\n    from pydantic.v1.fields import ModelField\nexcept ImportError:\n    from pydantic.fields import ModelField\n```\n\n----------------------------------------\n\nTITLE: Demonstrating url_type Error in Pydantic URL Validation\nDESCRIPTION: This example shows how the 'url_type' error is raised when the input value is not a valid type for a URL field. It attempts to use None for an HttpUrl field, which requires a string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_type'\n```\n\n----------------------------------------\n\nTITLE: Handling Unrecognized Field Validator Signature Error\nDESCRIPTION: This example shows how Pydantic raises a PydanticUserError when a field_validator function has an incorrect signature. The error occurs because the validator function doesn't accept any parameters, whereas it should at least accept the value being validated.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def check_a(cls):\n            return 'a'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-signature'\n```\n\n----------------------------------------\n\nTITLE: Using Field with validate_call for Parameter Validation in Python\nDESCRIPTION: Demonstrates how to use the Field function with validate_call to provide extra validation rules for function parameters, including validation errors and aliases.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, ValidationError, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10)]):\n    return num\n\n\ntry:\n    how_many(1)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for how_many\n    0\n      Input should be greater than 10 [type=greater_than, input_value=1, input_type=int]\n    \"\"\"\n\n\n@validate_call\ndef return_value(value: str = Field(default='default value')):\n    return value\n\n\nprint(return_value())\n#> default value\n```\n\n----------------------------------------\n\nTITLE: Pydantic Dataclasses Module Reference\nDESCRIPTION: Module reference marker for Pydantic's dataclasses module documentation using documentation syntax.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/dataclasses.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: pydantic.dataclasses\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_pattern_mismatch Error with Regex Pattern\nDESCRIPTION: This example shows how a string_pattern_mismatch error is raised when a string value doesn't match the field's pattern constraint.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(pattern='test')\n\n\ntry:\n    Model(x='1')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_pattern_mismatch'\n```\n\n----------------------------------------\n\nTITLE: Handling datetime_object_invalid Error in Pydantic\nDESCRIPTION: Demonstrates validation error when a datetime object is invalid due to incomplete timezone implementation\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, tzinfo\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass CustomTz(tzinfo):\n    # utcoffset is not implemented!\n\n    def tzname(self, _dt):\n        return 'CustomTZ'\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime(2023, 1, 1, tzinfo=CustomTz()))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'datetime_object_invalid'\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic from GitHub repository using uv\nDESCRIPTION: Installs Pydantic directly from the main branch of the GitHub repository using uv, with optional extras.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_6\n\nLANGUAGE: bash\nCODE:\n```\nuv add 'git+https://github.com/pydantic/pydantic@main'\n# or with `email` and `timezone` extras:\nuv add 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Custom Types with Validation and Serialization in Pydantic\nDESCRIPTION: Shows how to create a custom TruncatedFloat type with advanced features like custom validation, serialization, and JSON schema definition. This example rounds floats to one decimal place and formats them in scientific notation when serialized.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import (\n    AfterValidator,\n    PlainSerializer,\n    TypeAdapter,\n    WithJsonSchema,\n)\n\nTruncatedFloat = Annotated[\n    float,\n    AfterValidator(lambda x: round(x, 1)),\n    PlainSerializer(lambda x: f'{x:.1e}', return_type=str),\n    WithJsonSchema({'type': 'string'}, mode='serialization'),\n]\n\n\nta = TypeAdapter(TruncatedFloat)\n\ninput = 1.02345\nassert input != 1.0\n\nassert ta.validate_python(input) == 1.0\n\nassert ta.dump_json(input) == b'\"1.0e+00\"'\n\nassert ta.json_schema(mode='validation') == {'type': 'number'}\nassert ta.json_schema(mode='serialization') == {'type': 'string'}\n```\n\n----------------------------------------\n\nTITLE: Handling Validator on Instance Method Error in Python with Pydantic\nDESCRIPTION: Demonstrates how Pydantic raises a PydanticUserError when a validator is applied to an instance method instead of a class method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a')\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-instance-method'\n```\n\n----------------------------------------\n\nTITLE: Enabling Pydantic Mypy Plugin with pyproject.toml\nDESCRIPTION: Configuration example showing how to enable the Pydantic mypy plugin in a pyproject.toml configuration file, which allows mypy to perform enhanced type checking on Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#2025-04-22_snippet_2\n\nLANGUAGE: toml\nCODE:\n```\n[tool.mypy]\nplugins = ['pydantic.mypy']\n```\n\n----------------------------------------\n\nTITLE: Demonstrating url_too_long Error in Pydantic URL Validation\nDESCRIPTION: This example demonstrates how the 'url_too_long' error is raised when a URL exceeds the maximum allowed length of 2083 characters. It attempts to validate a URL with 2084 'x' characters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_38\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl\n\n\ntry:\n    Model(x='x' * 2084)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_too_long'\n```\n\n----------------------------------------\n\nTITLE: Importing Pydantic Configuration Module Documentation\nDESCRIPTION: MkDocs directive to import and display the pydantic.config module documentation. Configures display options to hide category grouping and specifically include the ConfigDict, with_config, ExtraValues, and BaseConfig members.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/config.md#2025-04-22_snippet_0\n\nLANGUAGE: markdown\nCODE:\n```\n::: pydantic.config\n    options:\n      group_by_category: false\n      members:\n        - ConfigDict\n        - with_config\n        - ExtraValues\n        - BaseConfig\n```\n\n----------------------------------------\n\nTITLE: Handling TypeAdapter Config Unused Error\nDESCRIPTION: This example demonstrates how Pydantic raises an error when you try to pass a config to TypeAdapter for a type that has its own config (like TypedDict). The config cannot be overridden for these types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_29\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, PydanticUserError, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n\ntry:\n    TypeAdapter(MyTypedDict, config=ConfigDict(strict=True))\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'type-adapter-config-unused'\n```\n\n----------------------------------------\n\nTITLE: Handling Model Config Invalid Field Name Error\nDESCRIPTION: This example shows how Pydantic raises an error when 'model_config' is used as a field name. The error occurs because 'model_config' is a reserved name used for model configuration.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_32\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-config-invalid-field-name'\n```\n\n----------------------------------------\n\nTITLE: Pipeline API Example - Python\nDESCRIPTION: This example showcases the Pydantic experimental \"pipeline\" API. It defines a `User` model with fields annotated using `validate_as` for various validation, transformation, and constraint operations. The operations include lowercasing strings, ensuring integers are greater than zero, matching regex patterns, and performing transformations on datetime values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom datetime import datetime\nfrom typing import Annotated\n\nfrom pydantic import BaseModel\nfrom pydantic.experimental.pipeline import validate_as\n\n\nclass User(BaseModel):\n    name: Annotated[str, validate_as(str).str_lower()]  # (1)!\n    age: Annotated[int, validate_as(int).gt(0)]  # (2)!\n    username: Annotated[str, validate_as(str).str_pattern(r'[a-z]+')]  # (3)!\n    password: Annotated[\n        str,\n        validate_as(str)\n        .transform(str.lower)\n        .predicate(lambda x: x != 'password'),  # (4)!\n    ]\n    favorite_number: Annotated[  # (5)!\n        int,\n        (validate_as(int) | validate_as(str).str_strip().validate_as(int)).gt(\n            0\n        ),\n    ]\n    friends: Annotated[list[User], validate_as(...).len(0, 100)]  # (6)!\n    bio: Annotated[\n        datetime,\n        validate_as(int)\n        .transform(lambda x: x / 1_000_000)\n        .validate_as(...),  # (8)!\n    ]\n```\n\n----------------------------------------\n\nTITLE: Integer Parsing Size Validation in Python\nDESCRIPTION: Demonstrates the int_parsing_size error that occurs when parsing strings that exceed Python's maximum integer parsing size limit.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\n# from Python\nassert Model(x='1' * 4_300).x == int('1' * 4_300)  # OK\n\ntoo_long = '1' * 4_301\ntry:\n    Model(x=too_long)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n\n# from JSON\ntry:\n    Model.model_validate_json(json.dumps({'x': too_long}))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_parsing_size'\n```\n\n----------------------------------------\n\nTITLE: Using assert_type with TypeAdapter in Pydantic Type Testing\nDESCRIPTION: Demonstrates how to use assert_type from typing_extensions to verify the type correctness of a TypeAdapter instance. This pattern is used throughout the test suite to ensure type hints work as expected.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/typechecking/README.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import assert_type\n\nfrom pydantic import TypeAdapter\n\nta1 = TypeAdapter(int)\nassert_type(ta1, TypeAdapter[int])\n```\n\n----------------------------------------\n\nTITLE: Handling Multiple Field Serializers Error\nDESCRIPTION: This example demonstrates how Pydantic raises an error when multiple serializers are defined for the same field. The error occurs because 'x' has two different serializer functions defined.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        x: int\n        y: int\n\n        @field_serializer('x', 'y')\n        def serializer1(v):\n            return f'{v:,}'\n\n        @field_serializer('x')\n        def serializer2(v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'multiple-field-serializers'\n```\n\n----------------------------------------\n\nTITLE: Embedding Pydantic Version Badges in reStructuredText\nDESCRIPTION: This snippet shows how to embed Pydantic version badges using reStructuredText syntax. It includes image directives for both version 1 and 2 badges, linking to the Pydantic website and specifying alt text.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_5\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n\n.. image:: https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\n    :target: https://pydantic.dev\n    :alt: Pydantic\n```\n\n----------------------------------------\n\nTITLE: Customizing Core Schema with __get_pydantic_core_schema__\nDESCRIPTION: Example of implementing __get_pydantic_core_schema__ method to customize the core schema generation for custom types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import CoreSchema\n\nfrom pydantic import GetCoreSchemaHandler, TypeAdapter\n\n\nclass MyStrict:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (1)!\n        schema['strict'] = True\n        return schema\n\n\nclass MyGt:\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        schema = handler(source)  # (2)!\n        schema['gt'] = 1\n        return schema\n\n\nta = TypeAdapter(Annotated[int, MyStrict(), MyGt()])\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Annotated Type Error\nDESCRIPTION: This example shows how Pydantic raises an error when an annotation cannot be applied to a type. The error occurs because FutureDate validator cannot be used to annotate a string type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, FutureDate, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        foo: Annotated[str, FutureDate()]\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-annotated-type'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating time_parsing Error with Invalid Time String\nDESCRIPTION: This example shows how a time_parsing error is raised when a string value cannot be parsed for a time field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x='25:20:30.400')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_parsing'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_unicode Error with Invalid Unicode Data\nDESCRIPTION: This example shows how a string_unicode error is raised when a value cannot be parsed as a Unicode string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: str\n\n\ntry:\n    Model(x=b'\\x81')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_unicode'\n```\n\n----------------------------------------\n\nTITLE: Pydantic Security Fix Implementation\nDESCRIPTION: Security patch for date and datetime parsing to prevent infinite loops when handling infinity values. Addresses CVE-2021-29510.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Security fix for date/datetime parsing\n# Prevents infinite loops with 'infinity' or float('inf')\n\nclass Model(BaseModel):\n    date_field: date\n    datetime_field: datetime\n\n```\n\n----------------------------------------\n\nTITLE: Handling Cyclic References in Pydantic Serialization\nDESCRIPTION: This snippet shows how Pydantic handles cyclic references during serialization. It demonstrates that a ValueError is raised when attempting to serialize data with circular references.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/forward_annotations.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\n# Create data with cyclic references representing the graph 1 -> 2 -> 3 -> 1\nnode_data = {'id': 1, 'children': [{'id': 2, 'children': [{'id': 3}]}]}\nnode_data['children'][0]['children'][0]['children'] = [node_data]\n\ntry:\n    # Try serializing the circular reference as JSON\n    TypeAdapter(dict).dump_json(node_data)\nexcept ValueError as exc:\n    print(exc)\n    \"\"\"\n    Error serializing to JSON: ValueError: Circular reference detected (id repeated)\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Handling Dataclass on BaseModel Subclass Error in Python\nDESCRIPTION: Demonstrates the error raised when using the Pydantic dataclass decorator on a class that is already a Pydantic model. This is not allowed and will raise a PydanticUserError with code 'dataclass-on-model'.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\nfrom pydantic.dataclasses import dataclass\n\ntry:\n\n    @dataclass\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'dataclass-on-model'\n```\n\n----------------------------------------\n\nTITLE: Alias Precedence in Python with Pydantic\nDESCRIPTION: Illustrates how explicitly specified aliases take precedence over generated aliases in a Pydantic model. This example uses a custom to_camel function as an alias generator.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\ndef to_camel(string: str) -> str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\nclass Voice(BaseModel):\n    model_config = ConfigDict(alias_generator=to_camel)\n\n    name: str\n    language_code: str = Field(alias='lang')\n\n\nvoice = Voice(Name='Filiz', lang='tr-TR')\nprint(voice.language_code)\n#> tr-TR\nprint(voice.model_dump(by_alias=True))\n#> {'Name': 'Filiz', 'lang': 'tr-TR'}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating set_item_not_hashable Error with Sets\nDESCRIPTION: This example shows how set_item_not_hashable errors are raised when trying to put unhashable objects into a set field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: set[object]\n\n\nclass Unhashable:\n    __hash__ = None\n\n\ntry:\n    Model(x=[{'a': 'b'}, Unhashable()])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'set_item_not_hashable'\n    print(repr(exc.errors()[1]['type']))\n    #> 'set_item_not_hashable'\n```\n\n----------------------------------------\n\nTITLE: Importing Pydantic Core Schema Module in Python\nDESCRIPTION: This code snippet demonstrates how to import the core_schema module from pydantic_core. It uses the relative import syntax, indicating that this is likely part of the internal Pydantic codebase.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_core_schema.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic_core.core_schema\n```\n\n----------------------------------------\n\nTITLE: Demonstrating time_delta_type Error with Invalid Timedelta Value\nDESCRIPTION: This example shows how a time_delta_type error is raised when the input value's type is not valid for a timedelta field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import timedelta\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: timedelta\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_delta_type'\n```\n\n----------------------------------------\n\nTITLE: Type Conversion from Floats to Integers in Pydantic V2\nDESCRIPTION: Shows how Pydantic V2 only allows conversion from floats to integers if the decimal part is zero, preventing potential data loss.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\nprint(Model(x=10.0))\n#> x=10\ntry:\n    Model(x=10.2)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer, got a number with a fractional part [type=int_from_float, input_value=10.2, input_type=float]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Extended Port Validation for AnyUrl\nDESCRIPTION: Adds port number validation to AnyUrl class to ensure port numbers don't exceed 65536 (16-bit unsigned integer limit) per RFC793 specification.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n0 <= port <= 2**16-1\n```\n\n----------------------------------------\n\nTITLE: Demonstrating revalidate_instances='always' Configuration in Pydantic\nDESCRIPTION: Shows how setting revalidate_instances to 'always' ensures that model instances are properly validated when passed to model_validate(). This example demonstrates how validation errors are caught for invalid model instances.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n\n    model_config = ConfigDict(revalidate_instances='always')\n\n\nm = Model(a=0)\n# note: setting `validate_assignment` to `True` in the config can prevent this kind of misbehavior.\nm.a = 'not an int'\n\ntry:\n    m2 = Model.model_validate(m)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    a\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='not an int', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic Model Definition with Type Error\nDESCRIPTION: Defines a Pydantic model with a type annotation and then creates an instance of the model, intentionally passing an unexpected keyword argument that will cause a type error detected by Mypy.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nmodel = Model(a=1, b=2)\n```\n\n----------------------------------------\n\nTITLE: Customizing Error Location Format in Pydantic\nDESCRIPTION: Shows how to modify the error location representation in Pydantic validation errors by converting tuple-based locations to dot-separated string format. Includes handling of nested models and list indices.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any, Union\n\nfrom pydantic import BaseModel, ValidationError\n\n\ndef loc_to_dot_sep(loc: tuple[Union[str, int], ...]) -> str:\n    path = ''\n    for i, x in enumerate(loc):\n        if isinstance(x, str):\n            if i > 0:\n                path += '.'\n            path += x\n        elif isinstance(x, int):\n            path += f'[{x}]'\n        else:\n            raise TypeError('Unexpected type')\n    return path\n\n\ndef convert_errors(e: ValidationError) -> list[dict[str, Any]]:\n    new_errors: list[dict[str, Any]] = e.errors()\n    for error in new_errors:\n        error['loc'] = loc_to_dot_sep(error['loc'])\n    return new_errors\n\n\nclass TestNestedModel(BaseModel):\n    key: str\n    value: str\n\n\nclass TestModel(BaseModel):\n    items: list[TestNestedModel]\n\n\ndata = {'items': [{'key': 'foo', 'value': 'bar'}, {'key': 'baz'}]}\n\ntry:\n    TestModel.model_validate(data)\nexcept ValidationError as e:\n    print(e.errors())\n    pretty_errors = convert_errors(e)\n    print(pretty_errors)\n```\n\n----------------------------------------\n\nTITLE: Handling Model Field Missing Annotation Error in Python with Pydantic\nDESCRIPTION: Shows how Pydantic raises a PydanticUserError when a field is defined without an annotation. It also provides solutions using ClassVar and ignored_types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        a = Field('foobar')\n        b = None\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-missing-annotation'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: ClassVar[str]\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass IgnoredType:\n    pass\n\n\nclass MyModel(BaseModel):\n    model_config = ConfigDict(ignored_types=(IgnoredType,))\n\n    _a = IgnoredType()\n    _b: int = IgnoredType()\n    _c: IgnoredType\n    _d: IgnoredType = IgnoredType()\n```\n\n----------------------------------------\n\nTITLE: Handling Model Parent Field Override Error in Python with Pydantic\nDESCRIPTION: Demonstrates how Pydantic raises a PydanticUserError when a field defined on a base class is overridden by a non-annotated attribute in a child class.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    a: float\n\n\ntry:\n\n    class Bar(Foo):\n        x: float = 12.3\n        a = 123.0\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-field-overridden'\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Core Schema for CompressedString Type in Python\nDESCRIPTION: This snippet demonstrates how to implement a custom __get_pydantic_core_schema__ method for a CompressedString type. It overrides the default schema generation to provide custom validation and serialization logic for compressed string representation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass\nclass CompressedString:\n    dictionary: dict[int, str]\n    text: list[int]\n\n    def build(self) -> str:\n        return ' '.join([self.dictionary[key] for key in self.text])\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        assert source is CompressedString\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.str_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                cls._serialize,\n                info_arg=False,\n                return_schema=core_schema.str_schema(),\n            ),\n        )\n\n    @staticmethod\n    def _validate(value: str) -> 'CompressedString':\n        inverse_dictionary: dict[str, int] = {}\n        text: list[int] = []\n        for word in value.split(' '):\n            if word not in inverse_dictionary:\n                inverse_dictionary[word] = len(inverse_dictionary)\n            text.append(inverse_dictionary[word])\n        return CompressedString(\n            {v: k for k, v in inverse_dictionary.items()}, text\n        )\n\n    @staticmethod\n    def _serialize(value: 'CompressedString') -> str:\n        return value.build()\n\n\nclass MyModel(BaseModel):\n    value: CompressedString\n\n\nprint(MyModel.model_json_schema())\nprint(MyModel(value='fox fox fox dog fox'))\nprint(MyModel(value='fox fox fox dog fox').model_dump(mode='json'))\n```\n\n----------------------------------------\n\nTITLE: Using Field Functions with Pydantic Dataclasses\nDESCRIPTION: Shows how to use both Pydantic's Field() and stdlib's field() functions with Pydantic dataclasses. Demonstrates field metadata, validation constraints, and JSON schema generation with TypeAdapter.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\nfrom typing import Optional\n\nfrom pydantic import Field, TypeAdapter\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass\nclass User:\n    id: int\n    name: str = 'John Doe'\n    friends: list[int] = dataclasses.field(default_factory=lambda: [0])\n    age: Optional[int] = dataclasses.field(\n        default=None,\n        metadata={'title': 'The age of the user', 'description': 'do not lie!'},\n    )\n    height: Optional[int] = Field(None, title='The height in cm', ge=50, le=300)\n\n\nuser = User(id='42')\nprint(TypeAdapter(User).json_schema())\n\"\"\"\n{\n    'properties': {\n        'id': {'title': 'Id', 'type': 'integer'},\n        'name': {'default': 'John Doe', 'title': 'Name', 'type': 'string'},\n        'friends': {\n            'items': {'type': 'integer'},\n            'title': 'Friends',\n            'type': 'array',\n        },\n        'age': {\n            'anyOf': [{'type': 'integer'}, {'type': 'null'}],\n            'default': None,\n            'description': 'do not lie!',\n            'title': 'The age of the user',\n        },\n        'height': {\n            'anyOf': [\n                {'maximum': 300, 'minimum': 50, 'type': 'integer'},\n                {'type': 'null'},\n            ],\n            'default': None,\n            'title': 'The height in cm',\n        },\n    },\n    'required': ['id'],\n    'title': 'User',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Runtime Type Annotation Error in Python\nDESCRIPTION: Example showing how circular type references cause runtime errors because Node is referenced before it's defined in the current scope.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass Node:\n    \"\"\"Binary tree node.\"\"\"\n\n    # NameError: name 'Node' is not defined:\n    def __init__(self, l: Node, r: Node) -> None:\n        self.left = l\n        self.right = r\n```\n\n----------------------------------------\n\nTITLE: Example Git Issue References in Markdown\nDESCRIPTION: References to GitHub issues and pull requests in changelog format using Markdown syntax.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_8\n\nLANGUAGE: markdown\nCODE:\n```\n[#361](https://github.com/pydantic/pydantic/pull/361)\n[#315](https://github.com/pydantic/pydantic/pull/315)\n[#358](https://github.com/pydantic/pydantic/pull/358)\n```\n\n----------------------------------------\n\nTITLE: Initializing TypeAdapter in Python\nDESCRIPTION: This snippet shows the class definition and initialization of the TypeAdapter class. It takes a type parameter and optional configuration settings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/type_adapter.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass TypeAdapter(Generic[T]):\n    __slots__ = (\n        'type',\n        'validator',\n        'serializer',\n        'core_schema',\n        'core_config',\n        'validation_error',\n    )\n\n    def __init__(\n        self,\n        type_: Any,\n        *,\n        config: ConfigDict | None = None,\n        # TODO revert the annotation and signature change in 3.0\n        _parent_config: ConfigDict | None = None,\n    ) -> None:\n        self.type = type_\n        parsed_type, infer_config = parse_type(type_)\n        core_config = {}  # type: Dict[str, Any]\n        if _parent_config is not None:\n            core_config.update(_parent_config)\n        if config is not None:\n            core_config.update(config)\n        core_config.update(infer_config)\n        self.core_config = core_config\n        self.core_schema = TypeAdapter.create_core_schema(parsed_type, self.core_config)\n        self.validator = SchemaValidator(self.core_schema, self.core_config)\n        self.serializer = SchemaSerializer(self.core_schema, self.core_config)\n        self.validation_error = create_validation_error(self.core_schema, self.core_config)\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Pydantic Model After Type Definition\nDESCRIPTION: Demonstrates how to properly rebuild a Pydantic model after defining the previously forward-referenced type, showing the successful generation of the core schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\ntype MyType = int\n\nFoo.model_rebuild()\nFoo.__pydantic_core_schema__\n#> {'type': 'model', 'schema': {...}, ...}\n```\n\n----------------------------------------\n\nTITLE: Implementing Plain Validator using Annotated Pattern in Python\nDESCRIPTION: This snippet demonstrates how to implement a Plain validator using the Annotated pattern in Pydantic. The validator doubles integer inputs and passes through non-integer inputs without further validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic import BaseModel, PlainValidator\n\n\ndef val_number(value: Any) -> Any:\n    if isinstance(value, int):\n        return value * 2\n    else:\n        return value\n\n\nclass Model(BaseModel):\n    number: Annotated[int, PlainValidator(val_number)]\n\n\nprint(Model(number=4))\n#> number=8\nprint(Model(number='invalid'))  # (1)!\n#> number='invalid'\n```\n\n----------------------------------------\n\nTITLE: Excluding invalid JSON schema fields using PydanticOmit in Python\nDESCRIPTION: This example shows how to exclude fields that don't have valid JSON schemas by overriding the handle_invalid_for_json_schema method in a custom GenerateJsonSchema subclass. It uses PydanticOmit to skip fields that can't be properly represented in JSON schema.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_21\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Callable\n\nfrom pydantic_core import PydanticOmit, core_schema\n\nfrom pydantic import BaseModel\nfrom pydantic.json_schema import GenerateJsonSchema, JsonSchemaValue\n\n\nclass MyGenerateJsonSchema(GenerateJsonSchema):\n    def handle_invalid_for_json_schema(\n        self, schema: core_schema.CoreSchema, error_info: str\n    ) -> JsonSchemaValue:\n        raise PydanticOmit\n\n\ndef example_callable():\n    return 1\n\n\nclass Example(BaseModel):\n    name: str = 'example'\n    function: Callable = example_callable\n\n\ninstance_example = Example()\n\nvalidation_schema = instance_example.model_json_schema(\n    schema_generator=MyGenerateJsonSchema, mode='validation'\n)\nprint(validation_schema)\n\"\"\"\n{\n    'properties': {\n        'name': {'default': 'example', 'title': 'Name', 'type': 'string'}\n    },\n    'title': 'Example',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Self Type Usage in BaseModel Method in Python\nDESCRIPTION: Demonstrates an error case where using Self type annotation in a BaseModel method with validate_call is not currently supported, even though it's correct from a type-checking perspective.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nfrom pydantic import BaseModel, PydanticUserError, validate_call\n\ntry:\n\n    class A(BaseModel):\n        @validate_call\n        def func(self, arg: Self):\n            pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating timezone_aware Error with Naive Datetime\nDESCRIPTION: This example shows how a timezone_aware error is raised when a naive datetime value is provided for a timezone-aware datetime field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nfrom pydantic import AwareDatetime, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: AwareDatetime\n\n\ntry:\n    Model(x=datetime.now())\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_aware'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Failed Forward Reference in Pydantic Model\nDESCRIPTION: Shows how Pydantic handles an unresolved forward reference by silently failing and stopping core schema generation, resulting in a MockCoreSchema object.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: 'MyType'\n\n\nFoo.__pydantic_core_schema__\n#> <pydantic._internal._mock_val_ser.MockCoreSchema object at 0x73cd0d9e6d00>\n```\n\n----------------------------------------\n\nTITLE: Example of Cross-Module Annotation Resolution\nDESCRIPTION: Multi-module example showing how Pydantic resolves annotations across different modules with conflicting type definitions and nested scopes. Used to demonstrate namespace resolution strategy.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# module1.py:\ntype MyType = int\n\nclass Base:\n    f1: 'MyType'\n\n# module2.py:\nfrom pydantic import BaseModel\n\nfrom module1 import Base\n\ntype MyType = str\n\n\ndef inner() -> None:\n    type InnerType = bool\n\n    class Model(BaseModel, Base):\n        type LocalType = bytes\n\n        f2: 'MyType'\n        f3: 'InnerType'\n        f4: 'LocalType'\n        f5: 'UnknownType'\n\n    type InnerType2 = complex\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Field Usage with Default Values in Pydantic Models (Python)\nDESCRIPTION: This code snippet shows how to use Pydantic's Field with default values in a BaseModel. It highlights the difference between keyword and positional arguments for default values, which affects type inference in Pylance/pyright.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Knight(BaseModel):\n    title: str = Field(default='Sir Lancelot')  # this is okay\n    age: int = Field(\n        23\n    )  # this works fine at runtime but will case an error for pyright\n\n\nlance = Knight()  # error: Argument missing for parameter \"age\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Argument Validation with Signature Binding (Python)\nDESCRIPTION: This code demonstrates how to bind validated arguments to a function's signature to create a dictionary of arguments. This requires the `inspect` module to access the function's signature. This snippet is marked to be skipped during testing and linting.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom inspect import signature\n\nsignature(func).bind(*args, **kwargs).arguments\n#> {'p': True, 'args': ('arg1', '1'), 'kwargs': {'extra': 1}}\n```\n\n----------------------------------------\n\nTITLE: Handling json_schema_input_type Usage Error in Python with Pydantic\nDESCRIPTION: Illustrates how Pydantic raises a PydanticUserError when json_schema_input_type is used with an incompatible validator mode.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: int = 1\n\n        @field_validator('a', mode='after', json_schema_input_type=int)\n        @classmethod\n        def check_a(self, value):\n            return value\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-input-type'\n```\n\n----------------------------------------\n\nTITLE: Handling Unpack Usage Error with Non-TypedDict in Python\nDESCRIPTION: Shows the error raised when Unpack is used with something other than a TypedDict class object to type hint variadic keyword parameters. This is not allowed and will raise a PydanticUserError.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_39\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(**kwargs: Unpack[int]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'unpack-typed-dict'\n```\n\n----------------------------------------\n\nTITLE: Handling With Config on Model Error\nDESCRIPTION: This example demonstrates how Pydantic raises an error when the with_config decorator is used on a class that's already a Pydantic model. The error occurs because BaseModel subclasses should use the model_config attribute instead.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, with_config\n\ntry:\n\n    @with_config({'allow_inf_nan': True})\n    class Model(BaseModel):\n        bar: str\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'with-config-on-model'\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Types Documentation in YAML\nDESCRIPTION: Configuration options for documenting the pydantic.types module. Specifies documentation display preferences including showing root heading and not merging init into class definitions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/types.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\n::: pydantic.types\n    options:\n        show_root_heading: true\n        merge_init_into_class: false\n```\n\n----------------------------------------\n\nTITLE: Creating deprecated computed fields in Pydantic\nDESCRIPTION: Example demonstrating how to mark a computed field as deprecated using the `typing_extensions.deprecated` decorator along with the `computed_field` decorator in Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import deprecated\n\nfrom pydantic import BaseModel, computed_field\n\n\nclass Box(BaseModel):\n    width: float\n    height: float\n    depth: float\n\n    @computed_field\n    @property\n    @deprecated(\"'volume' is deprecated\")\n    def volume(self) -> float:\n        return self.width * self.height * self.depth\n```\n\n----------------------------------------\n\nTITLE: Using RootModel for Custom Root Types\nDESCRIPTION: Demonstrates how to use RootModel to create models with custom root types. Shows examples with lists and dictionaries as root types, including how to access and validate the root value.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\nPets = RootModel[list[str]]\nPetsByName = RootModel[dict[str, str]]\n\n\nprint(Pets(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets(['dog', 'cat']).model_dump_json())\n#> [\"dog\",\"cat\"]\nprint(Pets.model_validate(['dog', 'cat']))\n#> root=['dog', 'cat']\nprint(Pets.model_json_schema())\n\"\"\"\n{'items': {'type': 'string'}, 'title': 'RootModel[list[str]]', 'type': 'array'}\n\"\"\"\n\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\nprint(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())\n#> {\"Otis\":\"dog\",\"Milo\":\"cat\"}\nprint(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))\n#> root={'Otis': 'dog', 'Milo': 'cat'}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Pydantic Model Type Checking with Mypy\nDESCRIPTION: Example showing a Pydantic model with field type annotations that mypy will check differently with and without the plugin. It demonstrates common type-checking scenarios including untyped fields, optional fields, and validation issues.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom typing import Optional\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    age: int\n    first_name = 'John'\n    last_name: Optional[str] = None\n    signup_ts: Optional[datetime] = None\n    list_of_ints: list[int]\n\n\nm = Model(age=42, list_of_ints=[1, '2', b'3'])\nprint(m.middle_name)  # not a model field!\nModel()  # will raise a validation error for age and list_of_ints\n```\n\n----------------------------------------\n\nTITLE: Combining AliasChoices and AliasPath in Python with Pydantic\nDESCRIPTION: Demonstrates how to combine AliasChoices and AliasPath for complex field validation scenarios in a Pydantic model. This allows for flexible nested data access and multiple alias options.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, AliasPath, AliasChoices\n\n\nclass User(BaseModel):\n    first_name: str = Field(validation_alias=AliasChoices('first_name', AliasPath('names', 0)))\n    last_name: str = Field(validation_alias=AliasChoices('last_name', AliasPath('names', 1)))\n\n\nuser = User.model_validate({'first_name': 'John', 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John', 'Doe']})\nprint(user)\n#> first_name='John' last_name='Doe'\nuser = User.model_validate({'names': ['John'], 'last_name': 'Doe'})\nprint(user)\n#> first_name='John' last_name='Doe'\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic with optional dependencies using pip\nDESCRIPTION: Installs Pydantic with optional 'email' and 'timezone' extras using pip.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# with the `email` extra:\npip install 'pydantic[email]'\n# or with `email` and `timezone` extras:\npip install 'pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization - Field Name Signature\nDESCRIPTION: 37% speed improvement in _field_name_for_signature function in _internal/_signature.py\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n_field_name_for_signature\n```\n\n----------------------------------------\n\nTITLE: New Pydantic Features and Configurations\nDESCRIPTION: Various Pydantic feature additions including smart_union configuration, new type support for Counter, improved URL handling, and new model configurations.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Example of new features:\n\nclass Config:\n    smart_union = True  # Prevents coercion in Union if possible\n\nclass Model(BaseModel):\n    counter_field: typing.Counter\n    file_url: FileUrl\n    frozen_set: confrozenset()\n    hidden_field: str = Field(repr=False)\n\n```\n\n----------------------------------------\n\nTITLE: Handling Circular References in Pydantic Models\nDESCRIPTION: Example demonstrating backwards compatibility behavior for circular references between class definitions, where one class refers to another that is not yet fully defined.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    a: 'Bar | None' = None\n\n\nclass Bar(BaseModel):\n    b: Foo\n```\n\n----------------------------------------\n\nTITLE: Comparing JSON Dumps in Pydantic V1 vs V2\nDESCRIPTION: Demonstrates the differences in JSON dumping between Pydantic V1 and V2 models, including how to align outputs using custom JSON separators.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nimport json\n\nfrom pydantic import BaseModel as V2BaseModel\nfrom pydantic.v1 import BaseModel as V1BaseModel\n\n\nclass V1Model(V1BaseModel):\n    a: list[str]\n\n\nclass V2Model(V2BaseModel):\n    a: list[str]\n\n\nv1_model = V1Model(a=['fancy', 'sushi'])\nv2_model = V2Model(a=['fancy', 'sushi'])\n\n# V1\nprint(v1_model.json())\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# V2\nprint(v2_model.model_dump_json())\n#> {\"a\":[\"fancy\",\"sushi\"]}\n\n# Plain json.dumps\nprint(json.dumps(v2_model.model_dump()))\n#> {\"a\": [\"fancy\", \"sushi\"]}\n\n# Modified json.dumps\nprint(json.dumps(v2_model.model_dump(), separators=(',', ':')))\n#> {\"a\":[\"fancy\",\"sushi\"]}\n```\n\n----------------------------------------\n\nTITLE: Documenting a Python Function with Args and Return\nDESCRIPTION: Example of how to document a Python function with arguments and return value using Google-style docstrings. It demonstrates the format for documenting function arguments and return values.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\ndef bar(self, baz: int) -> str:\n    \"\"\"A function docstring.\n\n    Args:\n        baz: A description of `baz`.\n\n    Returns:\n        A description of the return value.\n    \"\"\"\n\n    return 'bar'\n```\n\n----------------------------------------\n\nTITLE: Using ClassVar for Class Variables in Pydantic Models\nDESCRIPTION: This example demonstrates how attributes annotated with ClassVar are treated as class variables in Pydantic models and don't become instance fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import ClassVar\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: ClassVar[int] = 1\n\n    y: int = 2\n\n\nm = Model()\nprint(m)\n#> y=2\nprint(Model.x)\n#> 1\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic with optional dependencies using uv\nDESCRIPTION: Installs Pydantic with optional 'email' and 'timezone' extras using uv.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n# with the `email` extra:\nuv add 'pydantic[email]'\n# or with `email` and `timezone` extras:\nuv add 'pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Handling bool_parsing Error in Pydantic\nDESCRIPTION: Demonstrates validation error when attempting to parse an invalid string as a boolean value\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: bool\n\n\nModel(x='true')  # OK\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'bool_parsing'\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization - Model Private Attribute\nDESCRIPTION: Speed improvement of 18% for ModelPrivateAttr.__set_name() method in fields.py\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\nModelPrivateAttr.__set_name__()\n```\n\n----------------------------------------\n\nTITLE: Type preservation for BaseModel subclasses and dataclasses in Pydantic V2\nDESCRIPTION: Example showing that Pydantic V2 does preserve input types for subclasses of BaseModel and for pydantic dataclasses, unlike for other collection types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nimport pydantic.dataclasses\nfrom pydantic import BaseModel\n\n\nclass InnerModel(BaseModel):\n    x: int\n\n\nclass OuterModel(BaseModel):\n    inner: InnerModel\n\n\nclass SubInnerModel(InnerModel):\n    y: int\n\n\nm = OuterModel(inner=SubInnerModel(x=1, y=2))\nprint(m)\n#> inner=SubInnerModel(x=1, y=2)\n\n\n@pydantic.dataclasses.dataclass\nclass InnerDataclass:\n    x: int\n\n\n@pydantic.dataclasses.dataclass\nclass SubInnerDataclass(InnerDataclass):\n    y: int\n\n\n@pydantic.dataclasses.dataclass\nclass OuterDataclass:\n    inner: InnerDataclass\n\n\nd = OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\nprint(d)\n#> OuterDataclass(inner=SubInnerDataclass(x=1, y=2))\n```\n\n----------------------------------------\n\nTITLE: Documenting a Python Class with Attributes\nDESCRIPTION: Example of how to document a Python class with attributes using Google-style docstrings. It shows the proper format for documenting class attributes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclass Foo:\n    \"\"\"A class docstring.\n\n    Attributes:\n        bar: A description of bar. Defaults to \"bar\".\n    \"\"\"\n\n    bar: str = 'bar'\n```\n\n----------------------------------------\n\nTITLE: Custom __init__ with Pydantic Model Signatures\nDESCRIPTION: This example shows how Pydantic respects custom __init__ functions when generating model signatures, incorporating both custom parameters and model fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nfrom pydantic import BaseModel\n\n\nclass MyModel(BaseModel):\n    id: int\n    info: str = 'Foo'\n\n    def __init__(self, id: int = 1, *, bar: str, **data) -> None:\n        \"\"\"My custom init!\"\"\"\n        super().__init__(id=id, bar=bar, **data)\n\n\nprint(inspect.signature(MyModel))\n#> (id: int = 1, *, bar: str, info: str = 'Foo') -> None\n```\n\n----------------------------------------\n\nTITLE: Using typing.Any to Override Type Checking with Pydantic\nDESCRIPTION: Shows how to use typing.Any to explicitly override the type of a variable when working with Pydantic's type conversion features to avoid editor type errors.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nage_str: Any = '23'\nlancelot = Knight(title='Sir Lancelot', age=age_str)\n```\n\n----------------------------------------\n\nTITLE: Partial JSON Validation with Trailing Strings Python\nDESCRIPTION: Demonstrates partial JSON validation using the `'trailing-strings'` mode. It validates an incomplete JSON string against the `Model` TypedDict, showing that the incomplete string is included in the output. The validated output will contain the value of `b` as the incomplete string 'wor'.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n{'a': 'hello', 'b': 'wor'}\n```\n\n----------------------------------------\n\nTITLE: Pydantic Version Module Documentation\nDESCRIPTION: Documentation references for Pydantic's version-related components, specifically __version__ and version_info attributes from the version module.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/version.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic.__version__\n    options:\n        show_root_heading: true\n\n::: pydantic.version.version_info\n    options:\n        show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Importing Phone Number Types in Pydantic\nDESCRIPTION: Documentation reference for the phone_numbers module in pydantic_extra_types. The module appears to be referenced but no actual code implementation is shown in the content.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_phone_numbers.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic_extra_types.phone_numbers\n```\n\n----------------------------------------\n\nTITLE: Demonstrating time_type Error with Invalid Time Value\nDESCRIPTION: This example shows how a time_type error is raised when the input value's type is not valid for a time field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import time\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: time\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'time_type'\n```\n\n----------------------------------------\n\nTITLE: ULID Serialization Module in Pydantic\nDESCRIPTION: Reference to the pydantic_extra_types.ulid module that implements ULID data type functionality. This module provides functionality for handling and validating ULID values in Pydantic models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_ulid.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic_extra_types.ulid\n```\n\n----------------------------------------\n\nTITLE: Mypy Output Example with Error Annotation\nDESCRIPTION: Illustrates how the Mypy output is merged with the source code, showing the original Pydantic model definition and instantiation along with a comment indicating the Mypy error message.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nmodel = Model(a=1, b=2)\n# MYPY: error: Unexpected keyword argument \"b\" for \"Model\"  [call-arg]\n```\n\n----------------------------------------\n\nTITLE: Ignoring Type Errors with Comment Annotations in Python\nDESCRIPTION: Demonstrates how to disable type checking for specific lines of code using comment annotations when working with Pydantic's flexible type conversion.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel):\n    title: str\n    age: int\n    color: str = 'blue'\n\n\nlancelot = Knight(title='Sir Lancelot', age='23')  # pyright: ignore\n```\n\n----------------------------------------\n\nTITLE: Union with left to right - unexpected results in Pydantic\nDESCRIPTION: This example illustrates a potential issue with the `left_to_right` union mode where the order of the types in the `Union` can lead to unexpected results.  When a numeric string is passed, the int validator succeeds, preventing the str validator from being used.  This example requires Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/unions.md#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Union\n\nfrom pydantic import BaseModel, Field\n\n\nclass User(BaseModel):\n    id: Union[int, str] = Field(union_mode='left_to_right')\n\n\nprint(User(id=123))  # (1)\n#> id=123\nprint(User(id='456'))  # (2)\n#> id=456\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization - Dataclass Creation\nDESCRIPTION: 7% performance improvement in the dataclass() function implementation in dataclasses.py\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndataclass()\n```\n\n----------------------------------------\n\nTITLE: Importing Script Code Type from Pydantic Extra Types\nDESCRIPTION: Shows the import statement for accessing the script_code module from pydantic_extra_types package. Used to extend Pydantic's type system with script code validation capabilities.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_script_code.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n::: pydantic_extra_types.script_code\n```\n\n----------------------------------------\n\nTITLE: Handling Sequences of Strings and Bytes in Pydantic\nDESCRIPTION: Shows how Pydantic handles Sequence[str] and Sequence[bytes] types, including validation to prevent single strings or bytes objects from being treated as sequences.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/standard_library_types.md#2025-04-22_snippet_22\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Optional, Sequence\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    sequence_of_strs: Optional[Sequence[str]] = None\n    sequence_of_bytes: Optional[Sequence[bytes]] = None\n\n\nprint(Model(sequence_of_strs=['a', 'bc']).sequence_of_strs)\n#> ['a', 'bc']\nprint(Model(sequence_of_strs=('a', 'bc')).sequence_of_strs)\n#> ('a', 'bc')\nprint(Model(sequence_of_bytes=[b'a', b'bc']).sequence_of_bytes)\n#> [b'a', b'bc']\nprint(Model(sequence_of_bytes=(b'a', b'bc')).sequence_of_bytes)\n#> (b'a', b'bc')\n\n\ntry:\n    Model(sequence_of_strs='abc')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    sequence_of_strs\n      'str' instances are not allowed as a Sequence value [type=sequence_str, input_value='abc', input_type=str]\n    \"\"\"\ntry:\n    Model(sequence_of_bytes=b'abc')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Model\n    sequence_of_bytes\n      'bytes' instances are not allowed as a Sequence value [type=sequence_str, input_value=b'abc', input_type=bytes]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Handling mutable default values in Pydantic\nDESCRIPTION: Demonstrates how Pydantic automatically handles mutable default values by creating deep copies, preventing shared state between instances.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/fields.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    item_counts: list[dict[str, int]] = [{}]\n\n\nm1 = Model()\nm1.item_counts[0]['a'] = 1\nprint(m1.item_counts)\n#> [{'a': 1}]\n\nm2 = Model()\nprint(m2.item_counts)\n#> [{}]\n```\n\n----------------------------------------\n\nTITLE: Defining Boolean Schema in Python\nDESCRIPTION: Definition of a TypedDict representing the core schema for a boolean field in Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nclass BoolSchema(TypedDict, total=False):\n    type: Required[Literal['bool']]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n```\n\n----------------------------------------\n\nTITLE: Optimizing TypeAdapter Instantiation in Python\nDESCRIPTION: Demonstrates the proper way to instantiate TypeAdapter once outside a function rather than recreating it on each function call, which improves performance by avoiding unnecessary validator and serializer construction.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/performance.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\n\ndef my_func():\n    adapter = TypeAdapter(list[int])\n    # do something with adapter\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter(list[int])\n\ndef my_func():\n    ...\n    # do something with adapter\n```\n\n----------------------------------------\n\nTITLE: Importing BaseModel from Pydantic V1\nDESCRIPTION: Example of importing the BaseModel class from Pydantic V1 in a Pydantic V2 environment.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.v1 import BaseModel\n```\n\n----------------------------------------\n\nTITLE: Explicitly Specifying TypeAdapter Generic Parameter\nDESCRIPTION: Shows how to explicitly specify the generic parameter when using TypeAdapter to ensure proper typing in certain scenarios.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter\n\nadapter = TypeAdapter[str | int](str | int)\n...\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic with pip\nDESCRIPTION: Installs the Pydantic package using pip, the Python package installer.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install pydantic\n```\n\n----------------------------------------\n\nTITLE: Embedding Pydantic Version Badges in Markdown\nDESCRIPTION: This snippet demonstrates how to embed Pydantic version 1 and 2 badges using Markdown syntax. The badges link to the Pydantic website and display version information fetched from JSON endpoints.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_4\n\nLANGUAGE: markdown\nCODE:\n```\n[![Pydantic v1](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json)](https://pydantic.dev)\n\n[![Pydantic v2](https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json)](https://pydantic.dev)\n```\n\n----------------------------------------\n\nTITLE: Performance Optimization - Multiple Of Validator\nDESCRIPTION: Code optimization that improved the multiple_of_validator() performance by 31% in the _internal/_validators.py file\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nmultiple_of_validator()\n```\n\n----------------------------------------\n\nTITLE: Monitoring Pydantic Validations with Logfire Integration\nDESCRIPTION: Demonstrates how to integrate Logfire monitoring with Pydantic validations. Shows successful validation of a Delivery model with timestamp and dimensions fields, and includes error handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\n\nimport logfire\n\nfrom pydantic import BaseModel\n\nlogfire.configure()\nlogfire.instrument_pydantic()\n\n\nclass Delivery(BaseModel):\n    timestamp: datetime\n    dimensions: tuple[int, int]\n\n\n# this will record details of a successful validation to logfire\nm = Delivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10', '20'])\nprint(repr(m.timestamp))\n#> datetime.datetime(2020, 1, 2, 3, 4, 5, tzinfo=TzInfo(UTC))\nprint(m.dimensions)\n#> (10, 20)\n\nDelivery(timestamp='2020-01-02T03:04:05Z', dimensions=['10'])\n```\n\n----------------------------------------\n\nTITLE: Model Rebuild Memory Leak Prevention Example\nDESCRIPTION: Example showing how weak references to function locals can cause resolution issues when models are rebuilt outside their original scope, as A becomes undefined after the function returns.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ndef func():\n    A = int\n\n    class Model(BaseModel):\n        f: 'A | Forward'\n\n    return Model\n\n\nModel = func()\n\nModel.model_rebuild(_types_namespace={'Forward': str})\n# pydantic.errors.PydanticUndefinedAnnotation: name 'A' is not defined\n```\n\n----------------------------------------\n\nTITLE: Demonstrating no_such_attribute Error in Pydantic Dataclasses\nDESCRIPTION: This example shows how a no_such_attribute error is raised when validate_assignment=True and attempting to assign a value to a non-existent field in a dataclass.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, ValidationError, dataclasses\n\n\n@dataclasses.dataclass(config=ConfigDict(validate_assignment=True))\nclass MyDataclass:\n    x: int\n\n\nm = MyDataclass(x=1)\ntry:\n    m.y = 10\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'no_such_attribute'\n```\n\n----------------------------------------\n\nTITLE: Configuring create_model Documentation Options in YAML\nDESCRIPTION: YAML configuration block for documenting the create_model function with basic display settings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/base_model.md#2025-04-22_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\noptions:\n    show_root_heading: true\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unexpected_keyword_argument Error with Position-Only Arguments\nDESCRIPTION: This example shows how an unexpected_keyword_argument error is raised when providing a keyword argument for a positional-only parameter in a function decorated with validate_call.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ValidationError, validate_call\n\n\n@validate_call\ndef foo(a: int, /):\n    return a\n\n\ntry:\n    foo(a=2)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[1]['type']))\n    #> 'unexpected_keyword_argument'\n```\n\n----------------------------------------\n\nTITLE: Displaying Pydantic Version Information in Bash\nDESCRIPTION: Command to print Pydantic version information for issue reporting. It uses Python to import and print the version info.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npython -c \"import pydantic.version; print(pydantic.version.version_info())\"\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with JSON and Complex Types\nDESCRIPTION: This example shows how to use strict mode validation with JSON inputs and complex types like lists and custom models, highlighting the differences in validation between JSON and Python inputs.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom uuid import UUID\n\nfrom pydantic import BaseModel, TypeAdapter, ValidationError\n\ntry:\n    TypeAdapter(list[int]).validate_json('[\"1\", 2, \"3\"]', strict=True)\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    2 validation errors for list[int]\n    0\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    2\n      Input should be a valid integer [type=int_type, input_value='3', input_type=str]\n    \"\"\"\n\n\nclass Model(BaseModel):\n    x: int\n    y: UUID\n\ndata = {'x': '1', 'y': '12345678-1234-1234-1234-123456789012'}\ntry:\n    Model.model_validate(data, strict=True)\nexcept ValidationError as exc:\n    # Neither x nor y are valid in strict mode from python:\n    print(exc)\n    \"\"\"\n    2 validation errors for Model\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    y\n      Input should be an instance of UUID [type=is_instance_of, input_value='12345678-1234-1234-1234-123456789012', input_type=str]\n    \"\"\"\n\njson_data = json.dumps(data)\ntry:\n    Model.model_validate_json(json_data, strict=True)\nexcept ValidationError as exc:\n    # From JSON, x is still not valid in strict mode, but y is:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic with uv\nDESCRIPTION: Installs the Pydantic package using uv, an alternative Python package installer.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nuv add pydantic\n```\n\n----------------------------------------\n\nTITLE: Merging json_schema_extra Dictionaries from Annotated Types in Pydantic\nDESCRIPTION: Demonstrates how Pydantic merges json_schema_extra dictionaries from annotated types, allowing for an additive approach to JSON schema customization across multiple type definitions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAlias\n\nfrom pydantic import Field, TypeAdapter\n\nExternalType: TypeAlias = Annotated[\n    int, Field(json_schema_extra={'key1': 'value1'})\n]\n\nta = TypeAdapter(\n    Annotated[ExternalType, Field(json_schema_extra={'key2': 'value2'})]\n)\nprint(json.dumps(ta.json_schema(), indent=2))\n\"\"\"\n{\n  \"key1\": \"value1\",\n  \"key2\": \"value2\",\n  \"type\": \"integer\"\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating union_tag_not_found Error in Pydantic with Discriminated Unions\nDESCRIPTION: This example demonstrates how the 'union_tag_not_found' error is raised when the discriminator field is missing from the input data. It attempts to validate a Union without providing the required 'pet_type' discriminator field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_34\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Literal, Union\n\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass BlackCat(BaseModel):\n    pet_type: Literal['blackcat']\n\n\nclass WhiteCat(BaseModel):\n    pet_type: Literal['whitecat']\n\n\nclass Model(BaseModel):\n    cat: Union[BlackCat, WhiteCat] = Field(discriminator='pet_type')\n\n\ntry:\n    Model(cat={'name': 'blackcat'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'union_tag_not_found'\n```\n\n----------------------------------------\n\nTITLE: Handling Overlapping Unpacked TypedDict Fields Error in Python\nDESCRIPTION: Demonstrates the error raised when a TypedDict used to type hint variadic keyword parameters has field names that overlap with other parameters. This is not allowed unless the overlapping parameters are positional-only.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_40\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict, Unpack\n\nfrom pydantic import PydanticUserError, validate_call\n\n\nclass TD(TypedDict):\n    a: int\n\n\ntry:\n\n    @validate_call\n    def func(a: int, **kwargs: Unpack[TD]):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'overlapping-unpack-typed-dict'\n```\n\n----------------------------------------\n\nTITLE: Using Future Annotations for Postponed Evaluation\nDESCRIPTION: Demonstrates how the __future__ annotations import automatically stringifies type annotations, which helps with forward references. Shows how MyType can be used before being defined.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom pydantic import BaseModel\n\n\nclass Foo(BaseModel):\n    f: MyType\n    # Given the future import above, this is equivalent to:\n    # f: 'MyType'\n\n\ntype MyType = int\n\nprint(Foo.__annotations__)\n#> {'f': 'MyType'}\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic from GitHub repository using pip\nDESCRIPTION: Installs Pydantic directly from the main branch of the GitHub repository using pip, with optional extras.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\npip install 'git+https://github.com/pydantic/pydantic@main'\n# or with `email` and `timezone` extras:\npip install 'git+https://github.com/pydantic/pydantic@main#egg=pydantic[email,timezone]'\n```\n\n----------------------------------------\n\nTITLE: Setting Config for TypedDict Correctly\nDESCRIPTION: This example shows the correct way to set configuration options for a TypedDict in Pydantic. Instead of passing config to TypeAdapter, you should set the __pydantic_config__ attribute on the TypedDict class.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter\n\n\nclass MyTypedDict(TypedDict):\n    x: int\n\n    # or `model_config = ...` for BaseModel\n    __pydantic_config__ = ConfigDict(strict=True)\n\n\nTypeAdapter(MyTypedDict)  # ok\n```\n\n----------------------------------------\n\nTITLE: Defining Country Type Class in Python for Pydantic\nDESCRIPTION: Implementation of a Country class that extends Pydantic's functionality for country validation. It leverages the pycountry library to validate and serialize country data based on ISO standards, supporting various input formats including country names, ISO codes, and official names.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_extra_types_country.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom __future__ import annotations\n\nfrom typing import Any, ClassVar, Dict, Optional, Type, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, core_schema\n\ntry:\n    import pycountry\nexcept ImportError:\n    pycountry = None  # type: ignore\n\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Country:\n    \"\"\"Represents a country, validated by pycountry.\n\n    Accepts inputs in the following forms:\n    - A pycountry Country object\n    - A two character country code, e.g. \"US\"\n    - A three character country code, e.g. \"USA\"\n    - A country name, e.g. \"United States\"\n    - A country official name, e.g. \"United States of America\"\n    \"\"\"\n\n    # Keep a cache since pycountry lookup can be slow.\n    _cache: ClassVar[Dict[str, object]] = {}\n\n    _country_object: object\n\n    def __init__(self, country_object: object) -> None:\n        self._country_object = country_object\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, str):\n            try:\n                other_country = self.__class__(other)\n            except ValueError:\n                return False\n            return self._country_object == other_country._country_object\n        if isinstance(other, Country):\n            return self._country_object == other._country_object\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        if isinstance(other, type(pycountry.countries.get(alpha_2='US'))):\n            return self._country_object == other\n        return NotImplemented\n\n    def __hash__(self) -> int:\n        return hash(self._country_object)\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}({self.name!r})'\n\n    def __str__(self) -> str:\n        return self.name\n\n    @property\n    def name(self) -> str:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        return cast(str, getattr(self._country_object, 'name'))\n\n    @property\n    def alpha2(self) -> str:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        return cast(str, getattr(self._country_object, 'alpha_2'))\n\n    @property\n    def alpha3(self) -> str:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        return cast(str, getattr(self._country_object, 'alpha_3'))\n\n    @property\n    def numeric(self) -> str:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        return cast(str, getattr(self._country_object, 'numeric'))\n\n    @property\n    def official_name(self) -> Optional[str]:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        try:\n            return cast(str, getattr(self._country_object, 'official_name'))\n        except AttributeError:\n            return None\n\n    @classmethod\n    def _get_country_object(cls, value: str) -> object:\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n\n        cache_key = value\n        if cache_key in cls._cache:\n            return cls._cache[cache_key]\n\n        try:\n            if len(value) == 2:\n                country = pycountry.countries.get(alpha_2=value)\n            elif len(value) == 3:\n                country = pycountry.countries.get(alpha_3=value)\n            else:\n                country = pycountry.countries.get(name=value)\n                if country is None:\n                    country = pycountry.countries.get(official_name=value)\n        except (KeyError, AttributeError):\n            country = None\n\n        if country is None:\n            # Not always exactly what failed, but good enough.\n            raise PydanticCustomError('country_not_found', 'Invalid country code or name')\n        cls._cache[cache_key] = country\n        return country\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, _source_type: Type[Any], _handler: Any\n    ) -> CoreSchema:\n        return core_schema.no_info_plain_validator_function(\n            function=cls._validate, serialization=core_schema.to_string_serializer()\n        )\n\n    @classmethod\n    def _validate(cls, value: Any) -> Country:\n        if isinstance(value, cls):\n            return value\n        if not pycountry:\n            raise ImportError('pycountry is not installed')\n        if isinstance(value, type(pycountry.countries.get(alpha_2='US'))):\n            return cls(value)\n        if isinstance(value, str):\n            return cls(cls._get_country_object(value))\n        raise PydanticCustomError('country_type', 'Value must be a string, Country, or pycountry.CountryType')\n\n    @classmethod\n    def __get_pydantic_json_schema__(cls, _core_schema: CoreSchema, field_schema: JsonSchemaValue) -> None:\n        field_schema.update(type='string', format='country')\n```\n\n----------------------------------------\n\nTITLE: Installing Flake8 Pydantic Plugin using pip\nDESCRIPTION: This command installs the Flake8 plugin for Pydantic using pip. The plugin provides additional lint checks specific to Pydantic usage.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/linting.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install flake8-pydantic\n```\n\n----------------------------------------\n\nTITLE: Using Type Variables in Named Type Aliases with TypeAliasType (Python 3.9+)\nDESCRIPTION: Creates a generic named type alias for a short list with a maximum length constraint, using a TypeVar to enable type flexibility.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, TypeVar\n\nfrom annotated_types import Len\nfrom typing_extensions import TypeAliasType\n\nT = TypeVar('T')\n\nShortList = TypeAliasType(\n    'ShortList', Annotated[list[T], Len(max_length=4)], type_params=(T,)\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Owner Class with Pydantic Core Schema\nDESCRIPTION: Creates a generic Owner class that can hold different item types with custom validation schema. Demonstrates how to implement __get_pydantic_core_schema__ for generic type handling.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\n@dataclass\nclass Owner(Generic[ItemType]):\n    name: str\n    item: ItemType\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        origin = get_origin(source_type)\n        if origin is None:  # used as `x: Owner` without params\n            origin = source_type\n            item_tp = Any\n        else:\n            item_tp = get_args(source_type)[0]\n        item_schema = handler.generate_schema(item_tp)\n\n        def val_item(\n            v: Owner[Any], handler: ValidatorFunctionWrapHandler\n        ) -> Owner[Any]:\n            v.item = handler(v.item)\n            return v\n\n        python_schema = core_schema.chain_schema(\n            [\n                core_schema.is_instance_schema(cls),\n                core_schema.no_info_wrap_validator_function(\n                    val_item, item_schema\n                ),\n            ]\n        )\n\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.chain_schema(\n                [\n                    core_schema.typed_dict_schema(\n                        {\n                            'name': core_schema.typed_dict_field(\n                                core_schema.str_schema()\n                            ),\n                            'item': core_schema.typed_dict_field(item_schema),\n                        }\n                    ),\n                    core_schema.no_info_before_validator_function(\n                        lambda data: Owner(\n                            name=data['name'], item=data['item']\n                        ),\n                        python_schema,\n                    ),\n                ]\n            ),\n            python_schema=python_schema,\n        )\n```\n\n----------------------------------------\n\nTITLE: Unsupported Usage of Field-Specific Metadata in Named Type Aliases (Python 3.9+)\nDESCRIPTION: Demonstrates an unsupported usage pattern where field-specific metadata like default values cannot be used inside named type aliases with TypeAliasType.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom typing_extensions import TypeAliasType\n\nfrom pydantic import BaseModel, Field\n\nMyAlias = TypeAliasType('MyAlias', Annotated[int, Field(default=1)])\n\n\nclass Model(BaseModel):\n    x: MyAlias  # This is not allowed\n```\n\n----------------------------------------\n\nTITLE: Strict Mode Validation with Field Configuration\nDESCRIPTION: This snippet shows how to enable strict mode validation for individual fields using Field(strict=True), demonstrating that only the specified fields are affected by strict mode.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\nclass User(BaseModel):\n    name: str\n    age: int\n    n_pets: int\n\nuser = User(name='John', age='42', n_pets='1')\nprint(user)\n#> name='John' age=42 n_pets=1\n\nclass AnotherUser(BaseModel):\n    name: str\n    age: int = Field(strict=True)\n    n_pets: int\n\ntry:\n    anotheruser = AnotherUser(name='John', age='42', n_pets='1')\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for AnotherUser\n    age\n      Input should be a valid integer [type=int_type, input_value='42', input_type=str]\n    \"\"\"\n\nclass Model(BaseModel):\n    x: int = Field(strict=True)\n    y: int = Field(strict=False)\n\ntry:\n    Model(x='1', y='2')\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Model\n    x\n      Input should be a valid integer [type=int_type, input_value='1', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Validators with Annotations in Pydantic\nDESCRIPTION: Demonstrates how to implement a custom validator using Annotated. The example creates MyAfterValidator which applies a function to values after validation, similar to pydantic.AfterValidator. It shows how to implement the __get_pydantic_core_schema__ method for custom validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Callable\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\n@dataclass(frozen=True)  # (1)!\nclass MyAfterValidator:\n    func: Callable[[Any], Any]\n\n    def __get_pydantic_core_schema__(\n        self, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            self.func, handler(source_type)\n        )\n\n\nUsername = Annotated[str, MyAfterValidator(str.lower)]\n\n\nclass Model(BaseModel):\n    name: Username\n\n\nassert Model(name='ABC').name == 'abc'  # (2)!\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom JSON Schema for Person Class in Python\nDESCRIPTION: This snippet demonstrates how to implement both __get_pydantic_core_schema__ and __get_pydantic_json_schema__ for a Person class. It creates a custom core schema and modifies the JSON schema to include examples and a custom title.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nimport json\nfrom typing import Any\n\nfrom pydantic_core import core_schema as cs\n\nfrom pydantic import GetCoreSchemaHandler, GetJsonSchemaHandler, TypeAdapter\nfrom pydantic.json_schema import JsonSchemaValue\n\n\nclass Person:\n    name: str\n    age: int\n\n    def __init__(self, name: str, age: int):\n        self.name = name\n        self.age = age\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source_type: Any, handler: GetCoreSchemaHandler\n    ) -> cs.CoreSchema:\n        return cs.typed_dict_schema(\n            {\n                'name': cs.typed_dict_field(cs.str_schema()),\n                'age': cs.typed_dict_field(cs.int_schema()),\n            },\n        )\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: cs.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        json_schema = handler(core_schema)\n        json_schema = handler.resolve_ref_schema(json_schema)\n        json_schema['examples'] = [\n            {\n                'name': 'John Doe',\n                'age': 25,\n            }\n        ]\n        json_schema['title'] = 'Person'\n        return json_schema\n\n\nprint(json.dumps(TypeAdapter(Person).json_schema(), indent=2))\n```\n\n----------------------------------------\n\nTITLE: Handling Unenforced Field Constraints in Pydantic\nDESCRIPTION: Shows how Pydantic handles field constraints that are not being enforced, demonstrating the correct way to apply multiple constraints to fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PositiveInt\n\ntry:\n    # this won't work since `PositiveInt` takes precedence over the\n    # constraints defined in `Field`, meaning they're ignored\n    class Model(BaseModel):\n        foo: PositiveInt = Field(lt=10)\n\nexcept ValueError as e:\n    print(e)\n\n\n# if you find yourself needing this, an alternative is to declare\n# the constraints in `Field` (or you could use `conint()`)\n# here both constraints will be enforced:\nclass ModelB(BaseModel):\n    # Here both constraints will be applied and the schema\n    # will be generated correctly\n    foo: int = Field(gt=0, lt=10)\n\n\nprint(ModelB.model_json_schema())\n\"\"\"\n{\n    'properties': {\n        'foo': {\n            'exclusiveMaximum': 10,\n            'exclusiveMinimum': 0,\n            'title': 'Foo',\n            'type': 'integer',\n        }\n    },\n    'required': ['foo'],\n    'title': 'ModelB',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Implementing After Validator using Annotated Pattern in Python\nDESCRIPTION: This snippet demonstrates how to implement an After validator using the Annotated pattern in Pydantic. The validator checks if a number is even and raises a ValueError if it's not.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import AfterValidator, BaseModel, ValidationError\n\n\ndef is_even(value: int) -> int:\n    if value % 2 == 1:\n        raise ValueError(f'{value} is not an even number')\n    return value  # (1)!\n\n\nclass Model(BaseModel):\n    number: Annotated[int, AfterValidator(is_even)]\n\n\ntry:\n    Model(number=1)\nexcept ValidationError as err:\n    print(err)\n    \"\"\"\n    1 validation error for Model\n    number\n      Value error, 1 is not an even number [type=value_error, input_value=1, input_type=int]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Overriding Schema Generation with AllowAnySubclass in Python\nDESCRIPTION: This example shows how to completely override schema generation by implementing __get_pydantic_core_schema__ for an AllowAnySubclass annotation. It creates a custom validation function to allow any subclass of a specified type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_15\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated, Any\n\nfrom pydantic_core import ValidationError, core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass AllowAnySubclass:\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        # we can't call handler since it will fail for arbitrary types\n        def validate(value: Any) -> Any:\n            if not isinstance(value, source):\n                raise ValueError(\n                    f'Expected an instance of {source}, got an instance of {type(value)}'\n                )\n\n        return core_schema.no_info_plain_validator_function(validate)\n\n\nclass Foo:\n    pass\n\n\nclass Model(BaseModel):\n    f: Annotated[Foo, AllowAnySubclass()]\n\n\nprint(Model(f=Foo()))\n\n\nclass NotFoo:\n    pass\n\n\ntry:\n    Model(f=NotFoo())\nexcept ValidationError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Field-Level Exclusion Settings in Pydantic Models\nDESCRIPTION: Shows how to set exclusion at the field level using the Field constructor with exclude=True. This takes priority over include/exclude parameters passed to model_dump methods, but not over exclude_none, exclude_unset, or exclude_default parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, SecretStr\n\n\nclass User(BaseModel):\n    id: int\n    username: str\n    password: SecretStr = Field(exclude=True)\n\n\nclass Transaction(BaseModel):\n    id: str\n    value: int = Field(exclude=True)\n\n\nt = Transaction(\n    id='1234567890',\n    value=9876543210,\n)\n\nprint(t.model_dump())\n#> {'id': '1234567890'}\nprint(t.model_dump(include={'id': True, 'value': True}))  # (1)!\n#> {'id': '1234567890'}\n```\n\n----------------------------------------\n\nTITLE: Displaying Pydantic Version Information for Pre-v2.0 in Bash\nDESCRIPTION: Command to print Pydantic version information for versions prior to 2.0. It uses Python to import and print the version info from pydantic.utils.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npython -c \"import pydantic.utils; print(pydantic.utils.version_info())\"\n```\n\n----------------------------------------\n\nTITLE: Using Field Aliases with validate_call in Python\nDESCRIPTION: Shows how to use field aliases with the validate_call decorator to allow alternative parameter names in function calls.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import Field, validate_call\n\n\n@validate_call\ndef how_many(num: Annotated[int, Field(gt=10, alias='number')]):\n    return num\n\n\nhow_many(number=42)\n```\n\n----------------------------------------\n\nTITLE: Validating Pydantic Model by Both Alias and Name in Python\nDESCRIPTION: Shows how to validate a Pydantic model using both alias and attribute name. The model_validate() method is called with both by_alias=True and by_name=True, allowing validation using either the alias or the attribute name.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\nm = Model.model_validate(\n    {'my_alias': 'foo'}, by_alias=True, by_name=True  # (1)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n\nm = Model.model_validate(\n    {'my_field': 'foo'}, by_alias=True, by_name=True  # (2)!\n)\nprint(repr(m))\n#> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Configuring Pydantic Core Documentation Members in YAML\nDESCRIPTION: YAML configuration that specifies which pydantic_core members should be included in documentation. Disables source code inspection while listing essential validators, serializers, error handling classes, and utility components.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/pydantic_core.md#2025-04-22_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\npydantic_core:\n    options:\n        allow_inspection: false\n        show_source: false\n        members:\n        - SchemaValidator\n        - SchemaSerializer\n        - ValidationError\n        - ErrorDetails\n        - InitErrorDetails\n        - SchemaError\n        - PydanticCustomError\n        - PydanticKnownError\n        - PydanticOmit\n        - PydanticUseDefault\n        - PydanticSerializationError\n        - PydanticSerializationUnexpectedValue\n        - Url\n        - MultiHostUrl\n        - MultiHostHost\n        - ArgsKwargs\n        - Some\n        - TzInfo\n        - to_json\n        - from_json\n        - to_jsonable_python\n        - list_all_errors\n        - ErrorTypeInfo\n        - __version__\n```\n\n----------------------------------------\n\nTITLE: Creating Subclasses of Parametrized RootModel\nDESCRIPTION: Demonstrates how to create subclasses of parametrized RootModel to add custom methods. Shows how to add a describe method to a RootModel with a list of strings as the root type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import RootModel\n\n\nclass Pets(RootModel[list[str]]):\n    def describe(self) -> str:\n        return f'Pets: {\", \".join(self.root)}'\n\n\nmy_pets = Pets.model_validate(['dog', 'cat'])\n\nprint(my_pets.describe())\n#> Pets: dog, cat\n```\n\n----------------------------------------\n\nTITLE: Rebuilding Model Schema with Forward References\nDESCRIPTION: Demonstrates how to use model_rebuild() to handle forward references in model definitions. This is necessary when a model references a class that is defined later in the code.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\n\nclass Foo(BaseModel):\n    x: 'Bar'  # (1)!\n\n\ntry:\n    Foo.model_json_schema()\nexcept PydanticUserError as e:\n    print(e)\n    \"\"\"\n    `Foo` is not fully defined; you should define `Bar`, then call `Foo.model_rebuild()`.\n\n    For further information visit https://errors.pydantic.dev/2/u/class-not-fully-defined\n    \"\"\"\n\n\nclass Bar(BaseModel):\n    pass\n\n\nFoo.model_rebuild()\nprint(Foo.model_json_schema())\n\"\"\"\n{\n    '$defs': {'Bar': {'properties': {}, 'title': 'Bar', 'type': 'object'}},\n    'properties': {'x': {'$ref': '#/$defs/Bar'}},\n    'required': ['x'],\n    'title': 'Foo',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting Pydantic Model Configuration with Class Arguments\nDESCRIPTION: Demonstrates how to configure a Pydantic model using class arguments syntax to set behaviors like freezing attributes, which enables editor validation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/visual_studio_code.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Knight(BaseModel, frozen=True):\n    title: str\n    age: int\n    color: str = 'blue'\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Core Schema for RestrictCharacters Annotation in Python\nDESCRIPTION: This example shows how to implement __get_pydantic_core_schema__ for an Annotated type RestrictCharacters. It demonstrates wrapping the existing schema with additional validation logic to restrict characters in a string.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\nfrom typing import Annotated, Any, Sequence\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler, ValidationError\n\n\n@dataclass\nclass RestrictCharacters:\n    alphabet: Sequence[str]\n\n    def __get_pydantic_core_schema__(\n        self, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        if not self.alphabet:\n            raise ValueError('Alphabet may not be empty')\n        schema = handler(\n            source\n        )  # get the CoreSchema from the type / inner constraints\n        if schema['type'] != 'str':\n            raise TypeError('RestrictCharacters can only be applied to strings')\n        return core_schema.no_info_after_validator_function(\n            self.validate,\n            schema,\n        )\n\n    def validate(self, value: str) -> str:\n        if any(c not in self.alphabet for c in value):\n            raise ValueError(\n                f'{value!r} is not restricted to {self.alphabet!r}'\n            )\n        return value\n\n\nclass MyModel(BaseModel):\n    value: Annotated[str, RestrictCharacters('ABC')]\n\n\nprint(MyModel.model_json_schema())\nprint(MyModel(value='CBA'))\n\ntry:\n    MyModel(value='XYZ')\nexcept ValidationError as e:\n    print(e)\n```\n\n----------------------------------------\n\nTITLE: Inheriting from Stdlib Dataclasses with Pydantic Validation\nDESCRIPTION: Demonstrates how Pydantic dataclasses can inherit from standard library dataclasses, automatically validating all inherited fields. Shows validation error handling for invalid inputs.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass Z:\n    z: int\n\n\n@dataclasses.dataclass\nclass Y(Z):\n    y: int = 0\n\n\n@pydantic.dataclasses.dataclass\nclass X(Y):\n    x: int = 0\n\n\nfoo = X(x=b'1', y='2', z='3')\nprint(foo)\n#> X(z=3, y=2, x=1)\n\ntry:\n    X(z='pika')\nexcept pydantic.ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for X\n    z\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='pika', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Argument Validation with Parameter Skipping (Python)\nDESCRIPTION: This code shows how to skip specific parameters during argument validation using a callback function. The `parameters_callback` argument in `generate_arguments_schema` allows defining a function that determines whether a parameter should be skipped. Dependencies: `typing`, `pydantic_core`, `pydantic.experimental.arguments_schema`.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic_core import SchemaValidator\n\nfrom pydantic.experimental.arguments_schema import generate_arguments_schema\n\n\ndef func(p: bool, *args: str, **kwargs: int) -> None: ...\n\n\ndef skip_first_parameter(index: int, name: str, annotation: Any) -> Any:\n    if index == 0:\n        return 'skip'\n\n\narguments_schema = generate_arguments_schema(\n    func=func,\n    parameters_callback=skip_first_parameter,\n)\n\nval = SchemaValidator(arguments_schema)\n\nargs, kwargs = val.validate_json('{\"args\": [\"arg1\"], \"kwargs\": {\"extra\": 1}}')\nprint(args, kwargs)\n#> ('arg1',) {'extra': 1}\n```\n\n----------------------------------------\n\nTITLE: Generated Pydantic Model\nDESCRIPTION: Python code automatically generated by datamodel-code-generator from the JSON Schema. It includes two Pydantic models (Person and Pet) with appropriate types, field constraints, and descriptions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# generated by datamodel-codegen:\n#   filename:  person.json\n#   timestamp: 2020-05-19T15:07:31+00:00\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom pydantic import BaseModel, Field, conint\n\n\nclass Pet(BaseModel):\n    name: str | None = None\n    age: int | None = None\n\n\nclass Person(BaseModel):\n    first_name: str = Field(description=\"The person's first name.\")\n    last_name: str = Field(description=\"The person's last name.\")\n    age: conint(ge=0) | None = Field(None, description='Age in years.')\n    pets: list[Pet] | None = None\n    comment: Any | None = None\n```\n\n----------------------------------------\n\nTITLE: Using GetPydanticSchema to Reduce Boilerplate in Pydantic\nDESCRIPTION: Shows how to use the GetPydanticSchema helper to simplify custom schema creation. This approach reduces the boilerplate code required when creating custom validators by allowing inline schema definition with a lambda function.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetPydanticSchema\n\n\nclass Model(BaseModel):\n    y: Annotated[\n        str,\n        GetPydanticSchema(\n            lambda tp, handler: core_schema.no_info_after_validator_function(\n                lambda x: x * 2, handler(tp)\n            )\n        ),\n    ]\n\n\nassert Model(y='ab').y == 'abab'\n```\n\n----------------------------------------\n\nTITLE: Implementing Generic Sequence Container with Pydantic\nDESCRIPTION: Creates a custom generic sequence container type with validation support. Shows how to implement __get_pydantic_core_schema__ for sequence types with proper type checking.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nclass MySequence(Sequence[T]):\n    def __init__(self, v: Sequence[T]):\n        self.v = v\n\n    def __getitem__(self, i):\n        return self.v[i]\n\n    def __len__(self):\n        return len(self.v)\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Any, handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        instance_schema = core_schema.is_instance_schema(cls)\n\n        args = get_args(source)\n        if args:\n            sequence_t_schema = handler.generate_schema(Sequence[args[0]])\n        else:\n            sequence_t_schema = handler.generate_schema(Sequence)\n\n        non_instance_schema = core_schema.no_info_after_validator_function(\n            MySequence, sequence_t_schema\n        )\n        return core_schema.union_schema([instance_schema, non_instance_schema])\n```\n\n----------------------------------------\n\nTITLE: Configuring Strict Mode for TypedDict\nDESCRIPTION: Shows how to add strict mode configuration to TypedDict classes by setting the __pydantic_config__ attribute, allowing control of validation behavior for third-party types.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict\n\nfrom pydantic import ConfigDict, TypeAdapter, ValidationError\n\n\nclass Inner(TypedDict):\n    y: int\n\n\nInner.__pydantic_config__ = ConfigDict(strict=True)\n\n\nclass Outer(TypedDict):\n    x: int\n    inner: Inner\n\n\nadapter = TypeAdapter(Outer)\nprint(adapter.validate_python({'x': '1', 'inner': {'y': 2}}))\n#> {'x': 1, 'inner': {'y': 2}}\n\n\ntry:\n    adapter.validate_python({'x': '1', 'inner': {'y': '2'}})\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Outer\n    inner.y\n      Input should be a valid integer [type=int_type, input_value='2', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Handling Generic Type Variables in Pydantic Models\nDESCRIPTION: Demonstrates error handling with generic type variables in Pydantic models. Shows how default type or constraints are used for validation and serialization when a type variable is not parametrized and how SerializeAsAny can override this behavior.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\n# note that `'bar': 'var2'` is missing\nerror = Error[ErrorDetails](\n    message='We just had an error',\n    details=ErrorDetails(foo='var'),\n)\nassert error.model_dump() == {\n    'message': 'We just had an error',\n    'details': {\n        'foo': 'var',\n    },\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Validation Errors in Pydantic Models\nDESCRIPTION: Demonstrates comprehensive validation error handling in Pydantic using nested models, field validators, and various data type validations. Shows how ValidationError captures multiple types of validation failures and different ways to access error information.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/errors.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError, field_validator\n\n\nclass Location(BaseModel):\n    lat: float = 0.1\n    lng: float = 10.1\n\n\nclass Model(BaseModel):\n    is_required: float\n    gt_int: int = Field(gt=42)\n    list_of_ints: list[int]\n    a_float: float\n    recursive_model: Location\n\n    @field_validator('a_float', mode='after')\n    @classmethod\n    def validate_float(cls, value: float) -> float:\n        if value > 2.0:\n            raise ValueError('Invalid float value')\n        return value\n\n\ndata = {\n    'list_of_ints': ['1', 2, 'bad'],\n    'a_float': 3.0,\n    'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n    'gt_int': 21,\n}\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    5 validation errors for Model\n    is_required\n      Field required [type=missing, input_value={'list_of_ints': ['1', 2,...ew York'}, 'gt_int': 21}, input_type=dict]\n    gt_int\n      Input should be greater than 42 [type=greater_than, input_value=21, input_type=int]\n    list_of_ints.2\n      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]\n    a_float\n      Value error, Invalid float value [type=value_error, input_value=3.0, input_type=float]\n    recursive_model.lng\n      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='New York', input_type=str]\n    \"\"\"\n\ntry:\n    Model(**data)\nexcept ValidationError as e:\n    print(e.errors())\n    \"\"\"\n    [\n        {\n            'type': 'missing',\n            'loc': ('is_required',),\n            'msg': 'Field required',\n            'input': {\n                'list_of_ints': ['1', 2, 'bad'],\n                'a_float': 3.0,\n                'recursive_model': {'lat': 4.2, 'lng': 'New York'},\n                'gt_int': 21,\n            },\n            'url': 'https://errors.pydantic.dev/2/v/missing',\n        },\n        {\n            'type': 'greater_than',\n            'loc': ('gt_int',),\n            'msg': 'Input should be greater than 42',\n            'input': 21,\n            'ctx': {'gt': 42},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        },\n        {\n            'type': 'int_parsing',\n            'loc': ('list_of_ints', 2),\n            'msg': 'Input should be a valid integer, unable to parse string as an integer',\n            'input': 'bad',\n            'url': 'https://errors.pydantic.dev/2/v/int_parsing',\n        },\n        {\n            'type': 'value_error',\n            'loc': ('a_float',),\n            'msg': 'Value error, Invalid float value',\n            'input': 3.0,\n            'ctx': {'error': ValueError('Invalid float value')},\n            'url': 'https://errors.pydantic.dev/2/v/value_error',\n        },\n        {\n            'type': 'float_parsing',\n            'loc': ('recursive_model', 'lng'),\n            'msg': 'Input should be a valid number, unable to parse string as a number',\n            'input': 'New York',\n            'url': 'https://errors.pydantic.dev/2/v/float_parsing',\n        },\n    ]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating too_long Error with max_length Constraint\nDESCRIPTION: This example shows how a too_long error is raised when a list's length exceeds the max_length constraint of a field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_27\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(max_length=3)\n\n\ntry:\n    Model(x=[1, 2, 3, 4])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_long'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating none_required Error in Pydantic Models\nDESCRIPTION: This example demonstrates how a none_required error is raised when a field explicitly typed as None receives a non-None value.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: None\n\n\ntry:\n    Model(x=1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'none_required'\n```\n\n----------------------------------------\n\nTITLE: Implementing Named Type Aliases with PEP 695 in Python 3.12+\nDESCRIPTION: Creates a named type alias for a list of positive integers using the new type statement syntax from PEP 695, enabling proper JSON Schema generation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import Gt\n\nfrom pydantic import BaseModel\n\ntype PositiveIntList = list[Annotated[int, Gt(0)]]\n\n\nclass Model(BaseModel):\n    x: PositiveIntList\n    y: PositiveIntList\n\n\nprint(Model.model_json_schema())  # (1)!\n\"\"\"\n{\n    '$defs': {\n        'PositiveIntList': {\n            'items': {'exclusiveMinimum': 0, 'type': 'integer'},\n            'type': 'array',\n        }\n    },\n    'properties': {\n        'x': {'$ref': '#/$defs/PositiveIntList'},\n        'y': {'$ref': '#/$defs/PositiveIntList'},\n    },\n    'required': ['x', 'y'],\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating too_short Error with min_length Constraint\nDESCRIPTION: This example shows how a too_short error is raised when a list's length is less than the min_length constraint of a field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_28\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: list[int] = Field(min_length=3)\n\n\ntry:\n    Model(x=[1, 2])\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'too_short'\n```\n\n----------------------------------------\n\nTITLE: Suppressing Pydantic Experimental Warnings - Python\nDESCRIPTION: This code snippet demonstrates how to suppress the warning message that appears when importing experimental features from the `experimental` module in Pydantic. It imports the `warnings` module and uses `warnings.filterwarnings` to ignore warnings of the `PydanticExperimentalWarning` category.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import PydanticExperimentalWarning\n\nwarnings.filterwarnings('ignore', category=PydanticExperimentalWarning)\n```\n\n----------------------------------------\n\nTITLE: Enabling Strict Mode for Nested Models with Base Class\nDESCRIPTION: Demonstrates using a shared base class with strict mode configuration to enforce strict validation across all nested models, ensuring consistent validation behavior.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/strict_mode.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, ValidationError\n\n\nclass MyBaseModel(BaseModel):\n    model_config = ConfigDict(strict=True)\n\n\nclass Inner(MyBaseModel):\n    y: int\n\n\nclass Outer(MyBaseModel):\n    x: int\n    inner: Inner\n\n\ntry:\n    Outer.model_validate({'x': 1, 'inner': {'y': '2'}})\nexcept ValidationError as exc:\n    print(exc)\n    \"\"\"\n    1 validation error for Outer\n    inner.y\n      Input should be a valid integer [type=int_type, input_value='2', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating value_error in Pydantic with Custom Validator\nDESCRIPTION: This example shows how a general 'value_error' is raised when a ValueError is raised during custom validation. It defines a field validator that always raises a ValueError, causing validation to fail.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_43\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: str\n\n    @field_validator('x')\n    @classmethod\n    def repeat_b(cls, v):\n        raise ValueError()\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'value_error'\n```\n\n----------------------------------------\n\nTITLE: Configuring JsonSchemaMode for Different Schema Types\nDESCRIPTION: Example showing how to configure the JSON schema mode to generate either validation or serialization schemas. This affects how types are represented in the schema, as demonstrated with the Decimal type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/json_schema.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom decimal import Decimal\n\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: Decimal = Decimal('12.34')\n\n\nprint(Model.model_json_schema(mode='validation'))\n\"\"\"\n{\n    'properties': {\n        'a': {\n            'anyOf': [{'type': 'number'}, {'type': 'string'}],\n            'default': '12.34',\n            'title': 'A',\n        }\n    },\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n\nprint(Model.model_json_schema(mode='serialization'))\n\"\"\"\n{\n    'properties': {'a': {'default': '12.34', 'title': 'A', 'type': 'string'}},\n    'title': 'Model',\n    'type': 'object',\n}\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Field Ordering in Pydantic Models\nDESCRIPTION: This example shows how field order is preserved in Pydantic models across different operations including JSON Schema, validation errors, and serialization methods like model_dump().\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_30\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    a: int\n    b: int = 2\n    c: int = 1\n    d: int = 0\n    e: float\n\n\nprint(Model.model_fields.keys())\n#> dict_keys(['a', 'b', 'c', 'd', 'e'])\nm = Model(e=2, a=1)\nprint(m.model_dump())\n#> {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}\ntry:\n    Model(a='x', b='x', c='x', d='x', e='x')\nexcept ValidationError as err:\n    error_locations = [e['loc'] for e in err.errors()]\n\nprint(error_locations)\n#> [('a',), ('b',), ('c',), ('d',), ('e',)]\n```\n\n----------------------------------------\n\nTITLE: Examining Model Signatures in Pydantic\nDESCRIPTION: This code demonstrates how Pydantic automatically generates signatures for models based on their fields, including support for aliases and custom __init__ methods.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_33\n\nLANGUAGE: python\nCODE:\n```\nimport inspect\n\nfrom pydantic import BaseModel, Field\n\n\nclass FooModel(BaseModel):\n    id: int\n    name: str = None\n    description: str = 'Foo'\n    apple: int = Field(alias='pear')\n\n\nprint(inspect.signature(FooModel))\n#> (*, id: int, name: str = None, description: str = 'Foo', pear: int) -> None\n```\n\n----------------------------------------\n\nTITLE: Demonstrating Configuration Boundaries in Pydantic Models in Python\nDESCRIPTION: Illustrates that configuration is not propagated when using types that support configuration as field annotations on other types. Each model maintains its own configuration boundary.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/config.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass User(BaseModel):\n    name: str\n\n\nclass Parent(BaseModel):\n    user: User\n\n    model_config = ConfigDict(str_max_length=2)\n\n\nprint(Parent(user={'name': 'John Doe'}))\n#> user=User(name='John Doe')\n```\n\n----------------------------------------\n\nTITLE: Testing Invalid Type Cases with Type Ignore Comments\nDESCRIPTION: Shows how to test invalid type cases by adding type ignore comments for both Mypy and Pyright. This example demonstrates testing a BaseModel instantiation without required arguments.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/typechecking/README.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    a: int\n\n\nModel()  # type: ignore[call-arg]  # pyright: ignore[reportCallIssue]\n```\n\n----------------------------------------\n\nTITLE: Configuring Alias Validation in Python with Pydantic\nDESCRIPTION: Shows how to configure alias validation behavior using ConfigDict in a Pydantic model. This example demonstrates different combinations of validate_by_alias and validate_by_name settings.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=False)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#> Model(my_field='foo')\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=False, validate_by_name=True)\n\n\nprint(repr(Model(my_field='foo')))  # (1)!\n#> Model(my_field='foo')\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, Field\n\n\nclass Model(BaseModel):\n    my_field: str = Field(validation_alias='my_alias')\n\n    model_config = ConfigDict(validate_by_alias=True, validate_by_name=True)\n\n\nprint(repr(Model(my_alias='foo')))  # (1)!\n#> Model(my_field='foo')\n\nprint(repr(Model(my_field='foo')))  # (2)!\n#> Model(my_field='foo')\n```\n\n----------------------------------------\n\nTITLE: Handling assertion_error in Pydantic Validation\nDESCRIPTION: Shows how assertion errors are raised during field validation when using custom validators\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError, field_validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    @classmethod\n    def force_x_positive(cls, v):\n        assert v > 0\n        return v\n\n\ntry:\n    Model(x=-1)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'assertion_error'\n```\n\n----------------------------------------\n\nTITLE: Handling Extra Data in Pydantic Models (Default Behavior)\nDESCRIPTION: Shows the default behavior of Pydantic models when provided with extra data - extra fields are ignored and not included in the model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    x: int\n\n\nm = Model(x=1, y='a')\nassert m.model_dump() == {'x': 1}\n```\n\n----------------------------------------\n\nTITLE: Demonstrating unexpected_keyword_argument Error with Forbidden Extra Fields\nDESCRIPTION: This example shows how an unexpected_keyword_argument error is raised when providing extra fields to a dataclass configured with extra=forbid.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_31\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import TypeAdapter, ValidationError\nfrom pydantic.dataclasses import dataclass\n\n\n@dataclass(config={'extra': 'forbid'})\nclass Foo:\n    bar: int\n\n\ntry:\n    TypeAdapter(Foo).validate_python({'bar': 1, 'foobar': 2})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'unexpected_keyword_argument'\n```\n\n----------------------------------------\n\nTITLE: Rebuilding TypeAdapter Schema with Forward References in Python\nDESCRIPTION: Demonstrates how to use deferred schema building and manual rebuilding of TypeAdapter schemas, useful for handling forward references and expensive schema builds.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/type_adapter.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import ConfigDict, TypeAdapter\n\nta = TypeAdapter('MyInt', config=ConfigDict(defer_build=True))\n\n# some time later, the forward reference is defined\nMyInt = int\n\nta.rebuild()\nassert ta.validate_python(1) == 1\n```\n\n----------------------------------------\n\nTITLE: Identifying Pydantic Dataclasses\nDESCRIPTION: Shows how to distinguish between standard library dataclasses and Pydantic dataclasses using dataclasses.is_dataclass and pydantic.dataclasses.is_pydantic_dataclass functions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/dataclasses.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport dataclasses\n\nimport pydantic\n\n\n@dataclasses.dataclass\nclass StdLibDataclass:\n    id: int\n\n\nPydanticDataclass = pydantic.dataclasses.dataclass(StdLibDataclass)\n\nprint(dataclasses.is_dataclass(StdLibDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(StdLibDataclass))\n#> False\n\nprint(dataclasses.is_dataclass(PydanticDataclass))\n#> True\nprint(pydantic.dataclasses.is_pydantic_dataclass(PydanticDataclass))\n#> True\n```\n\n----------------------------------------\n\nTITLE: Handling model_serializer Instance Method Error in Python with Pydantic\nDESCRIPTION: Shows how Pydantic raises a PydanticUserError when model_serializer is applied to a method without 'self' parameter or to a class method.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_20\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(slf, x, y, z):\n            return slf\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        @classmethod\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-instance-method'\n```\n\n----------------------------------------\n\nTITLE: Handling Decorator on Missing Field Error in Pydantic\nDESCRIPTION: Demonstrates how to use check_fields=False when inheriting from a model to avoid the decorator-missing-field error when a field is not present in the current model but might be in a derived model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Any\n\nfrom pydantic import BaseModel, create_model, field_validator\n\n\nclass Model(BaseModel):\n    @field_validator('a', check_fields=False)\n    def check_a(cls, v: Any):\n        return v\n\n\nmodel = create_model('FooModel', a=(str, 'cake'), __base__=Model)\n```\n\n----------------------------------------\n\nTITLE: Installing bump-pydantic migration tool\nDESCRIPTION: Command to install the bump-pydantic tool from PyPI, which assists in migrating code from Pydantic V1 to V2.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\npip install bump-pydantic\n```\n\n----------------------------------------\n\nTITLE: Handling Removed Keyword Arguments Error in Python with Pydantic V2\nDESCRIPTION: Demonstrates how Pydantic V2 raises a PydanticUserError when using keyword arguments that are no longer available, such as 'regex'.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: str = Field(regex='test')\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'removed-kwargs'\n```\n\n----------------------------------------\n\nTITLE: Using Alias Generator with Callable in Python with Pydantic\nDESCRIPTION: Shows how to use the alias_generator parameter of ConfigDict to specify a callable that generates aliases for all fields in a Pydantic model. This example uses a lambda function to generate uppercase aliases.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/alias.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict\n\n\nclass Tree(BaseModel):\n    model_config = ConfigDict(\n        alias_generator=lambda field_name: field_name.upper()\n    )\n\n    age: int\n    height: float\n    kind: str\n\n\nt = Tree.model_validate({'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'})\nprint(t.model_dump(by_alias=True))\n#> {'AGE': 12, 'HEIGHT': 1.2, 'KIND': 'oak'}\n```\n\n----------------------------------------\n\nTITLE: Debugging Pydantic Core Installation in Python\nDESCRIPTION: Python code to check the contents of the installed pydantic-core package, verifying the presence of compiled library and type stubs. This helps diagnose issues related to incorrect Pydantic installation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom importlib.metadata import files\nprint([file for file in files('pydantic-core') if file.name.startswith('_pydantic_core')])\n\"\"\"\n[PackagePath('pydantic_core/_pydantic_core.pyi'), PackagePath('pydantic_core/_pydantic_core.cpython-312-x86_64-linux-gnu.so')]\n\"\"\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Flake8 to Ignore Specific Pydantic Lint Errors\nDESCRIPTION: This configuration snippet for Flake8 demonstrates how to ignore specific Pydantic lint errors. It extends the ignore list to include PYD001 and PYD002 rules.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/linting.md#2025-04-22_snippet_1\n\nLANGUAGE: ini\nCODE:\n```\n[flake8]\nextend-ignore = PYD001,PYD002\n```\n\n----------------------------------------\n\nTITLE: Using Unpack for Keyword Parameters with validate_call in Python\nDESCRIPTION: Shows how to use Unpack and TypedDict to annotate variable keyword parameters of a function with validate_call.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validation_decorator.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import TypedDict, Unpack\n\nfrom pydantic import validate_call\n\n\nclass Point(TypedDict):\n    x: int\n    y: int\n\n\n@validate_call\ndef add_coords(**kwargs: Unpack[Point]) -> int:\n    return kwargs['x'] + kwargs['y']\n\n\nadd_coords(x=1, y=2)\n```\n\n----------------------------------------\n\nTITLE: Generic Type Parameters with Bound and Unbound Type Variables\nDESCRIPTION: Demonstrates how bound specification and generic type parametrization work in Pydantic models. Shows different ways to create models with type variables that are bound to BaseModel or have no bounds.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_19\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Generic, TypeVar\n\nfrom pydantic import BaseModel\n\nTBound = TypeVar('TBound', bound=BaseModel)\nTNoBound = TypeVar('TNoBound')\n\n\nclass IntValue(BaseModel):\n    value: int\n\n\nclass ItemBound(BaseModel, Generic[TBound]):\n    item: TBound\n\n\nclass ItemNoBound(BaseModel, Generic[TNoBound]):\n    item: TNoBound\n\n\nitem_bound_inferred = ItemBound(item=IntValue(value=3))\nitem_bound_explicit = ItemBound[IntValue](item=IntValue(value=3))\nitem_no_bound_inferred = ItemNoBound(item=IntValue(value=3))\nitem_no_bound_explicit = ItemNoBound[IntValue](item=IntValue(value=3))\n\n# calling `print(x.model_dump())` on any of the above instances results in the following:\n#> {'item': {'value': 3}}\n```\n\n----------------------------------------\n\nTITLE: Calling a validate_call Decorated Function in Python\nDESCRIPTION: Shows how to call a function decorated with validate_call. The decorator validates inputs according to the type annotations before the function executes.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/api/validate_call.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nprint(foo(2, 'hello'))\n```\n\n----------------------------------------\n\nTITLE: Integer Type Validation in Pydantic\nDESCRIPTION: Shows how int_type error is raised when an invalid type is provided for an integer field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: int\n\n\ntry:\n    Model(x=None)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'int_type'\n```\n\n----------------------------------------\n\nTITLE: Suppressing Experimental Feature Warnings in Pydantic\nDESCRIPTION: Code showing how to disable warning messages that appear when importing experimental features. Uses the warnings module to filter out PydanticExperimentalWarning messages.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/version-policy.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport warnings\n\nfrom pydantic import PydanticExperimentalWarning\n\nwarnings.filterwarnings('ignore', category=PydanticExperimentalWarning)\n```\n\n----------------------------------------\n\nTITLE: Partial Validation with Nested Models Python\nDESCRIPTION: Illustrates a case where partial validation might not work as expected with nested models. The `allow_partial` instruction is not passed down to the nested list validator in `MyModel`, causing validation errors in the nested structure to be raised instead of being ignored.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter, ValidationError\n\n\nclass MyModel(BaseModel):\n    a: int = 1\n    b: list[Annotated[str, MinLen(5)]] = []  # (1)!\n\nta = TypeAdapter(MyModel)\ntry:\n    v = ta.validate_json(\n        '{\"a\": 1, \"b\": [\"12345\", \"12', experimental_allow_partial=True\n    )\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for MyModel\n    b.1\n      String should have at least 5 characters [type=string_too_short, input_value='12', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Demonstrating timezone_naive Error with Timezone-Aware Datetime\nDESCRIPTION: This example shows how a timezone_naive error is raised when a timezone-aware datetime is provided for a naive datetime field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_26\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime, timezone\n\nfrom pydantic import BaseModel, NaiveDatetime, ValidationError\n\n\nclass Model(BaseModel):\n    x: NaiveDatetime\n\n\ntry:\n    Model(x=datetime.now(tz=timezone.utc))\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'timezone_naive'\n```\n\n----------------------------------------\n\nTITLE: Handling BaseModel Direct Instantiation Error in Python with Pydantic\nDESCRIPTION: Illustrates how Pydantic raises a PydanticUserError when attempting to instantiate BaseModel directly instead of inheriting from it.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n    BaseModel()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'base-model-instantiated'\n```\n\n----------------------------------------\n\nTITLE: Model Validation and Serialization in Python\nDESCRIPTION: Demonstration of model validation and serialization using Pydantic's BaseModel.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#2025-04-22_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass Model(BaseModel):\n    foo: int\n\n\nmodel = Model.model_validate({'foo': 1})  # (1)!\ndumped = model.model_dump()  # (2)!\n```\n\n----------------------------------------\n\nTITLE: Demonstrating string_too_long Error with max_length Constraint\nDESCRIPTION: This example shows how a string_too_long error is raised when a string's length exceeds the max_length constraint of a field.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_17\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, ValidationError\n\n\nclass Model(BaseModel):\n    x: str = Field(max_length=3)\n\n\ntry:\n    Model(x='test')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'string_too_long'\n```\n\n----------------------------------------\n\nTITLE: Valid Field Serializer Signature Examples\nDESCRIPTION: This code snippet demonstrates the various valid signatures for field serializers in Pydantic. It shows both instance methods and static methods in 'plain' and 'wrap' modes, with optional FieldSerializationInfo parameter.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_24\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import FieldSerializationInfo, SerializerFunctionWrapHandler, field_serializer\n\n# an instance method with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\ndef ser_x(self, value: Any, info: FieldSerializationInfo): ...\n\n# a static method or function with the default mode or `mode='plain'`\n@field_serializer('x')  # or @field_serializer('x', mode='plain')\n@staticmethod\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\n\n# equivalent to\ndef ser_x(value: Any, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# an instance method with `mode='wrap'`\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# a static method or function with `mode='wrap'`\n@field_serializer('x', mode='wrap')\n@staticmethod\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\n\n# equivalent to\ndef ser_x(value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo): ...\nserializer('x')(ser_x)\n\n# For all of these, you can also choose to omit the `info` argument, for example:\n@field_serializer('x')\ndef ser_x(self, value: Any): ...\n\n@field_serializer('x', mode='wrap')\ndef ser_x(self, value: Any, handler: SerializerFunctionWrapHandler): ...\n```\n\n----------------------------------------\n\nTITLE: Handling arguments_type Validation Error in Pydantic\nDESCRIPTION: Demonstrates error handling when passing invalid arguments to a NamedTuple field in a Pydantic model\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import NamedTuple\n\nfrom pydantic import BaseModel, ValidationError\n\n\nclass MyNamedTuple(NamedTuple):\n    x: int\n\n\nclass MyModel(BaseModel):\n    field: MyNamedTuple\n\n\ntry:\n    MyModel.model_validate({'field': 'invalid'})\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'arguments_type'\n```\n\n----------------------------------------\n\nTITLE: Demonstrating url_syntax_violation Error in Pydantic URL Validation\nDESCRIPTION: This example shows how the 'url_syntax_violation' error is raised when a URL has syntactical errors. It uses a strict HttpUrl field and provides a URL with incorrect syntax (too many slashes).\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_37\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field, HttpUrl, ValidationError\n\n\nclass Model(BaseModel):\n    x: HttpUrl = Field(strict=True)\n\n\ntry:\n    Model(x='http:////example.com')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'url_syntax_violation'\n```\n\n----------------------------------------\n\nTITLE: Handling Unrecognized Model Serializer Signature Error\nDESCRIPTION: This example shows how Pydantic raises an error when a model_serializer function has an incorrect signature. The error occurs because the serializer has an unexpected signature with three parameters.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_25\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, model_serializer\n\ntry:\n\n    class MyModel(BaseModel):\n        a: int\n\n        @model_serializer\n        def _serialize(self, x, y, z):\n            return self\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'model-serializer-signature'\n```\n\n----------------------------------------\n\nTITLE: Handling Validator with No Fields Error in Python with Pydantic\nDESCRIPTION: Illustrates how Pydantic raises a PydanticUserError when a validator is used without specifying any fields. It also shows the correct usage of validators with fields.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_16\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_validator\n\ntry:\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator\n        def checker(cls, v):\n            return v\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'validator-no-fields'\n```\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, field_validator\n\n\nclass Model(BaseModel):\n    a: str\n\n    @field_validator('a')\n    def checker(cls, v):\n        return v\n```\n\n----------------------------------------\n\nTITLE: Demonstrating uuid_version Error in Pydantic UUID Validation\nDESCRIPTION: This example demonstrates how the 'uuid_version' error is raised when a UUID has a different version than what is required. It attempts to validate a UUID4 when a UUID5 is specified in the model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_42\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import UUID5, BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    u: UUID5\n\n\ntry:\n    Model(u='a6cc5730-2261-11ee-9c43-2eb5a363657c')\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'uuid_version'\n```\n\n----------------------------------------\n\nTITLE: Ignoring Errors in Last Element Python\nDESCRIPTION: Demonstrates how Pydantic ignores errors in the last element of the input data when using `experimental_allow_partial`. It defines a `MyModel` with a required integer field `a` and a required string field `b` with a minimum length of 5. It then validates a JSON string with a truncated last element, showing that the validator still processes the first valid element in the list.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\n\nfrom pydantic import BaseModel, TypeAdapter\n\n\nclass MyModel(BaseModel):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\nta = TypeAdapter(list[MyModel])\nv = ta.validate_json(\n    '[{\"a\": 1, \"b\": \"12345\"}, {\"a\": 1,', \n    experimental_allow_partial=True,\n)\nprint(v)\n#> [MyModel(a=1, b='12345')]\n```\n\n----------------------------------------\n\nTITLE: Demonstrating ValidationError with always=True and validate_default\nDESCRIPTION: Example showing how using always=True with validator can unexpectedly raise ValidationError when validating defaults in Pydantic V2. The code attempts to validate a string field with an integer default value.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, validator\n\n\nclass Model(BaseModel):\n    x: str = 1\n\n    @validator('x', always=True)\n    @classmethod\n    def validate_x(cls, v):\n        return v\n\n\nModel()\n```\n\n----------------------------------------\n\nTITLE: Handling Undefined Annotation Error in Python with Pydantic\nDESCRIPTION: Demonstrates how Pydantic raises a PydanticUndefinedAnnotation error when encountering undefined annotations during CoreSchema generation.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_13\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUndefinedAnnotation\n\n\nclass Model(BaseModel):\n    a: 'B'  # noqa F821\n\n\ntry:\n    Model.model_rebuild()\nexcept PydanticUndefinedAnnotation as exc_info:\n    assert exc_info.code == 'undefined-annotation'\n```\n\n----------------------------------------\n\nTITLE: Handling Config and model_config Conflict Error in Python with Pydantic\nDESCRIPTION: Illustrates how Pydantic raises a PydanticUserError when both class Config and model_config are defined in a model.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ConfigDict, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        model_config = ConfigDict(from_attributes=True)\n\n        a: str\n\n        class Config:\n            from_attributes = True\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'config-both'\n```\n\n----------------------------------------\n\nTITLE: TypeError propagation in field validators in Pydantic V2\nDESCRIPTION: Example demonstrating that TypeError is no longer converted to ValidationError in Pydantic V2 validators, unlike in V1. This shows a validator that incorrectly calls str.lower() on an integer.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nimport pytest\n\nfrom pydantic import BaseModel, field_validator  # or validator\n\n\nclass Model(BaseModel):\n    x: int\n\n    @field_validator('x')\n    def val_x(cls, v: int) -> int:\n        return str.lower(v)  # raises a TypeError\n\n\nwith pytest.raises(TypeError):\n    Model(x=1)\n```\n\n----------------------------------------\n\nTITLE: Importing Experimental Features from Pydantic\nDESCRIPTION: Example showing how to import experimental features from Pydantic's experimental module. This demonstrates the standard import pattern for accessing experimental functionality.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/version-policy.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic.experimental import feature_name\n```\n\n----------------------------------------\n\nTITLE: Installing datamodel-code-generator\nDESCRIPTION: Command to install the datamodel-code-generator package using pip.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/datamodel_code_generator.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install datamodel-code-generator\n```\n\n----------------------------------------\n\nTITLE: Defining a New Test Module for Mypy\nDESCRIPTION: Shows how to create a new test case in the `modules/` directory. This involves defining a Pydantic model and instantiating it with an incorrect argument to trigger a Mypy error.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/tests/mypy/README.md#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# modules/new_test.py\n\nclass Model(BaseModel):\n    a: int\n\n\nmodel = Model(a=1, b=2)\n```\n\n----------------------------------------\n\nTITLE: Backwards Compatibility Inconsistency Example\nDESCRIPTION: Example highlighting inconsistencies in annotation resolution logic for backwards compatibility, where annotations that should fail to resolve (Model and Inner) are incorrectly marked as successfully resolved.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/resolving_annotations.md#2025-04-22_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom dataclasses import dataclass\n\nfrom pydantic import BaseModel\n\n\n@dataclass\nclass Foo:\n    # `a` and `b` shouldn't resolve:\n    a: 'Model'\n    b: 'Inner'\n\n\ndef func():\n    Inner = int\n\n    class Model(BaseModel):\n        foo: Foo\n\n    Model.__pydantic_complete__\n    #> True, should be False.\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid JSON Schema Generation Error in Python with Pydantic\nDESCRIPTION: Shows how Pydantic raises a PydanticUserError when it fails to generate a JSON schema for certain CoreSchema types, such as ImportString.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ImportString, PydanticUserError\n\n\nclass Model(BaseModel):\n    a: ImportString\n\n\ntry:\n    Model.model_json_schema()\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-for-json-schema'\n```\n\n----------------------------------------\n\nTITLE: TypedDict Model Definition Python\nDESCRIPTION: Defines a TypedDict model `Model` with two string fields `a` and `b`.  This model is used in an example to demonstrate the `'trailing-strings'` mode of partial validation, which allows incomplete strings at the end of the JSON input.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import TypedDict\n\n\nclass Model(TypedDict):\n    a: str\n    b: str\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic with conda\nDESCRIPTION: Installs Pydantic using conda package manager from the conda-forge channel.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/install.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\nconda install pydantic -c conda-forge\n```\n\n----------------------------------------\n\nTITLE: Handling Unknown Type Schema Generation Error in Python with Pydantic\nDESCRIPTION: Shows how Pydantic raises a PydanticUserError when it fails to generate a CoreSchema for an unknown type.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_14\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError\n\ntry:\n\n    class Model(BaseModel):\n        x: 43 = 123\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'schema-for-unknown-type'\n```\n\n----------------------------------------\n\nTITLE: Handling Unrecognized Field Serializer Signature Error\nDESCRIPTION: This example demonstrates how Pydantic raises an error when a field_serializer function has an incorrect signature. The error occurs because the serializer function doesn't accept any parameters, but it should at least accept the value being serialized.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_23\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, PydanticUserError, field_serializer\n\ntry:\n\n    class Model(BaseModel):\n        x: int\n\n        @field_serializer('x')\n        def no_args():\n            return 'x'\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'field-serializer-signature'\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic V2 using pip\nDESCRIPTION: Command to install the latest version of Pydantic V2 from PyPI using pip.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install -U pydantic\n```\n\n----------------------------------------\n\nTITLE: UUID Instantiation Through Binary String\nDESCRIPTION: Adds support for UUID instantiation using 16-byte strings to enable compatibility with SQL Alchemy BINARY(16) columns.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/HISTORY.md#2025-04-22_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nb'\\x12\\x34\\x56\\x78' * 4\n```\n\n----------------------------------------\n\nTITLE: Understanding Attribute Copying Behavior in Pydantic\nDESCRIPTION: This example demonstrates how Pydantic copies input attributes during validation, highlighting that objects like lists are not passed by reference to the model instance.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/models.md#2025-04-22_snippet_36\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel\n\n\nclass C1:\n    arr = []\n\n    def __init__(self, in_arr):\n        self.arr = in_arr\n\n\nclass C2(BaseModel):\n    arr: list[int]\n\n\narr_orig = [1, 9, 10, 3]\n\n\nc1 = C1(arr_orig)\nc2 = C2(arr=arr_orig)\nprint(f'{id(c1.arr) == id(c2.arr)=}')\n#> id(c1.arr) == id(c2.arr)=False\n```\n\n----------------------------------------\n\nTITLE: Unsupported Usage of Field-Specific Metadata in Named Type Aliases (Python 3.12+)\nDESCRIPTION: Demonstrates an unsupported usage pattern where field-specific metadata like default values cannot be used inside named type aliases with the new PEP 695 syntax.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/types.md#2025-04-22_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom pydantic import BaseModel, Field\n\ntype MyAlias = Annotated[int, Field(default=1)]\n\n\nclass Model(BaseModel):\n    x: MyAlias  # This is not allowed\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic for AWS Lambda using pip\nDESCRIPTION: Command to install Pydantic for AWS Lambda functions, ensuring compatibility with the Lambda environment. It specifies platform, target directory, Python implementation and version, and uses pre-built binary wheels.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/aws_lambda.md#2025-04-22_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\npip install \\\n    --platform manylinux2014_x86_64 \\\n    --target=<your_package_dir> \\\n    --implementation cp \\\n    --python-version 3.10 \\\n    --only-binary=:all: \\\n    --upgrade pydantic\n```\n\n----------------------------------------\n\nTITLE: Installing Pydantic V1\nDESCRIPTION: Command to install the latest version of Pydantic V1 using pip, if needed for compatibility reasons.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/migration.md#2025-04-22_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\npip install \"pydantic==1.*\"\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx intersphinx for Pydantic Documentation References\nDESCRIPTION: This code snippet shows how to set up the intersphinx_mapping in Sphinx to reference Pydantic's API documentation. It allows linking to either the latest stable documentation or the development version that follows the main branch.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/documentation.md#2025-04-22_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nintersphinx_mapping = {\n    'pydantic': ('https://docs.pydantic.dev/latest', None),  # (1)!\n}\n```\n\n----------------------------------------\n\nTITLE: Complete Mypy Configuration with Pydantic Plugin in mypy.ini\nDESCRIPTION: Comprehensive mypy configuration with the Pydantic plugin enabled and all strictness flags set to true, including Pydantic-specific configuration options for improved type checking of models.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/integrations/mypy.md#2025-04-22_snippet_3\n\nLANGUAGE: ini\nCODE:\n```\n[mypy]\nplugins = pydantic.mypy\n\nfollow_imports = silent\nwarn_redundant_casts = True\nwarn_unused_ignores = True\ndisallow_any_generics = True\nno_implicit_reexport = True\ndisallow_untyped_defs = True\n\n[pydantic-mypy]\ninit_forbid_extra = True\ninit_typed = True\nwarn_required_dynamic_aliases = True\n```\n\n----------------------------------------\n\nTITLE: Demonstrating recursion_loop Error with Cyclic References\nDESCRIPTION: This example shows how a recursion_loop error is raised when a cyclic reference is detected in a model's data structure.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/validation_errors.md#2025-04-22_snippet_12\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, ValidationError\n\n\nclass Model(BaseModel):\n    x: list['Model']\n\n\nd = {'x': []}\nd['x'].append(d)\ntry:\n    Model(**d)\nexcept ValidationError as exc:\n    print(repr(exc.errors()[0]['type']))\n    #> 'recursion_loop'\n```\n\n----------------------------------------\n\nTITLE: Serializing Subclasses of Standard Types in Python\nDESCRIPTION: Shows how subclasses of standard types are automatically dumped like their super-classes in Pydantic.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/serialization.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import date, timedelta\nfrom typing import Any\n\nfrom pydantic_core import core_schema\n\nfrom pydantic import BaseModel, GetCoreSchemaHandler\n\n\nclass DayThisYear(date):\n    \"\"\"\n    Contrived example of a special type of date that\n    takes an int and interprets it as a day in the current year\n    \"\"\"\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: type[Any], handler: GetCoreSchemaHandler\n    ) -> core_schema.CoreSchema:\n        return core_schema.no_info_after_validator_function(\n            cls.validate,\n            core_schema.int_schema(),\n            serialization=core_schema.format_ser_schema('%Y-%m-%d'),\n        )\n\n    @classmethod\n    def validate(cls, v: int):\n        return date(2023, 1, 1) + timedelta(days=v)\n\n\nclass FooModel(BaseModel):\n    date: DayThisYear\n\n\nm = FooModel(date=300)\nprint(m.model_dump_json())\n#> {\"date\":\"2023-10-28\"}\n```\n\n----------------------------------------\n\nTITLE: Handling Invalid Self Type Usage Error in Python\nDESCRIPTION: Shows the error raised when trying to use the Self type annotation in unsupported ways. Currently, Self can only be used to annotate a field of specific class types like BaseModel, NamedTuple, TypedDict, or dataclasses.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/errors/usage_errors.md#2025-04-22_snippet_41\n\nLANGUAGE: python\nCODE:\n```\nfrom typing_extensions import Self\n\nfrom pydantic import PydanticUserError, validate_call\n\ntry:\n\n    @validate_call\n    def func(self: Self):\n        pass\n\nexcept PydanticUserError as exc_info:\n    assert exc_info.code == 'invalid-self-type'\n```\n\n----------------------------------------\n\nTITLE: Accepting Complete But Invalid JSON Python\nDESCRIPTION: Demonstrates that some invalid but complete JSON might be accepted when using `experimental_allow_partial` due to the limitations of the underlying JSON parser.  Specifically demonstrates how complete, but invalid, JSON will behave similarly to incomplete JSON with respect to optional field validation and value omissions.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import MinLen\nfrom typing_extensions import TypedDict\n\nfrom pydantic import TypeAdapter\n\n\nclass Foobar(TypedDict, total=False):\n    a: int\n    b: Annotated[str, MinLen(5)]\n\nta = TypeAdapter(Foobar)\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12', experimental_allow_partial=True  # (1)!\n)\nprint(v)\n#> {'a': 1}\n\nv = ta.validate_json(\n    '{\"a\": 1, \"b\": \"12\"}', experimental_allow_partial=True  # (2)!\n)\nprint(v)\n#> {'a': 1}\n```\n\n----------------------------------------\n\nTITLE: Pydantic: Partial Validation with Error Ignoring (Python)\nDESCRIPTION: This code demonstrates how Pydantic ignores errors in the last element of the input during partial validation. It uses `TypeAdapter` and `validate_python` with `experimental_allow_partial=True`. Dependencies: `typing`, `annotated_types`, `pydantic`.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/experimental.md#_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nfrom typing import Annotated\n\nfrom annotated_types import Ge\n\nfrom pydantic import TypeAdapter\n\nta = TypeAdapter(list[Annotated[int, Ge(10)]])\nv = ta.validate_python([20, 30, 4], experimental_allow_partial=True)  # (1)!\nprint(v)\n#> [20, 30]\n\nta = TypeAdapter(list[int])\n\nv = ta.validate_python([1, 2, 'wrong'], experimental_allow_partial=True)  # (2)!\nprint(v)\n#> [1, 2]\n```\n\n----------------------------------------\n\nTITLE: Pydantic Validation Error Handling\nDESCRIPTION: Demonstrates how Pydantic handles validation errors when invalid data is provided. Shows error handling with try-except block and error message formatting.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/index.md#2025-04-22_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom datetime import datetime\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\n\nclass User(BaseModel):\n    id: int\n    name: str = 'John Doe'\n    signup_ts: datetime | None\n    tastes: dict[str, PositiveInt]\n\n\nexternal_data = {'id': 'not an int', 'tastes': {}}\n\ntry:\n    User(**external_data)\nexcept ValidationError as e:\n    print(e.errors())\n```\n\n----------------------------------------\n\nTITLE: Creating Pydantic Model with Boolean Field\nDESCRIPTION: Example of defining a Pydantic model with a boolean field using Field for additional configuration.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/internals/architecture.md#2025-04-22_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, Field\n\n\nclass Model(BaseModel):\n    foo: bool = Field(strict=True)\n```\n\n----------------------------------------\n\nTITLE: Using InstanceOf Special Type in Pydantic\nDESCRIPTION: Shows how to use the InstanceOf utility to validate that a value is an instance of a given class. This example validates that items in a list are instances of the Fruit class.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/concepts/validators.md#2025-04-22_snippet_18\n\nLANGUAGE: python\nCODE:\n```\nfrom pydantic import BaseModel, InstanceOf, ValidationError\n\n\nclass Fruit:\n    def __repr__(self):\n        return self.__class__.__name__\n\n\nclass Banana(Fruit): ...\n\n\nclass Apple(Fruit): ...\n\n\nclass Basket(BaseModel):\n    fruits: list[InstanceOf[Fruit]]\n\n\nprint(Basket(fruits=[Banana(), Apple()]))\n#> fruits=[Banana, Apple]\ntry:\n    Basket(fruits=[Banana(), 'Apple'])\nexcept ValidationError as e:\n    print(e)\n    \"\"\"\n    1 validation error for Basket\n    fruits.1\n      Input should be an instance of Fruit [type=is_instance_of, input_value='Apple', input_type=str]\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Embedding Pydantic Version Badges in HTML\nDESCRIPTION: This snippet demonstrates how to embed Pydantic version 1 and 2 badges using HTML. It creates clickable image links to the Pydantic website, with appropriate alt text and styling for maximum width.\nSOURCE: https://github.com/pydantic/pydantic/blob/main/docs/contributing.md#2025-04-22_snippet_6\n\nLANGUAGE: html\nCODE:\n```\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v1.json\" alt=\"Pydantic Version 1\" style=\"max-width:100%;\"></a>\n\n<a href=\"https://pydantic.dev\"><img src=\"https://img.shields.io/endpoint?url=https://raw.githubusercontent.com/pydantic/pydantic/main/docs/badge/v2.json\" alt=\"Pydantic Version 2\" style=\"max-width:100%;\"></a>\n```"
  }
]