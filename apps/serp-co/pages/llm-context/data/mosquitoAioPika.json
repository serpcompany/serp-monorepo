[
  {
    "owner": "mosquito",
    "repo": "aio-pika",
    "content": "TITLE: Implementing a Simple RabbitMQ Consumer with aio-pika in Python\nDESCRIPTION: This code demonstrates how to create a simple message consumer using aio-pika. It establishes a robust connection to RabbitMQ, declares a queue, and processes messages asynchronously using an iterator pattern. The consumer automatically acknowledges messages using the context manager approach.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport aio_pika\nimport aio_pika.abc\n\n\nasync def main(loop):\n    # Connecting with the given parameters is also possible.\n    # aio_pika.connect_robust(host=\"host\", login=\"login\", password=\"password\")\n    # You can only choose one option to create a connection, url or kw-based params.\n    connection = await aio_pika.connect_robust(\n        \"amqp://guest:guest@127.0.0.1/\", loop=loop\n    )\n\n    async with connection:\n        queue_name = \"test_queue\"\n\n        # Creating channel\n        channel: aio_pika.abc.AbstractChannel = await connection.channel()\n\n        # Declaring queue\n        queue: aio_pika.abc.AbstractQueue = await channel.declare_queue(\n            queue_name,\n            auto_delete=True\n        )\n\n        async with queue.iterator() as queue_iter:\n            # Cancel consuming after __aexit__\n            async for message in queue_iter:\n                async with message.process():\n                    print(message.body)\n\n                    if queue.name in message.body.decode():\n                        break\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main(loop))\n    loop.close()\n```\n\n----------------------------------------\n\nTITLE: Creating Simple Publisher with aio-pika in Python\nDESCRIPTION: This example shows how to implement a simple publisher using aio-pika. It probably covers establishing a connection, creating a channel, and publishing messages to a queue or exchange.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Worker Task Processing\nDESCRIPTION: Complete worker implementation with durable queue declaration and message processing.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def process_message(message: IncomingMessage):\n    async with message.process():\n        print(\" [x] Received %r\" % message.body)\n        await asyncio.sleep(message.body.count(b'.'))\n        print(\" [x] Done\")\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to RabbitMQ with aio-pika in Python\nDESCRIPTION: This code demonstrates how to create a simple message publisher using aio-pika. It establishes a robust connection to RabbitMQ, creates a channel, and publishes a message to the default exchange with a specified routing key. After publishing, the connection is properly closed.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport aio_pika\nimport aio_pika.abc\n\n\nasync def main(loop):\n    # Explicit type annotation\n    connection: aio_pika.RobustConnection = await aio_pika.connect_robust(\n        \"amqp://guest:guest@127.0.0.1/\", loop=loop\n    )\n\n    routing_key = \"test_queue\"\n\n    channel: aio_pika.abc.AbstractChannel = await connection.channel()\n\n    await channel.default_exchange.publish(\n        aio_pika.Message(\n            body='Hello {}'.format(routing_key).encode()\n        ),\n        routing_key=routing_key\n    )\n\n    await connection.close()\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main(loop))\n    loop.close()\n```\n\n----------------------------------------\n\nTITLE: Complete RPC Client Implementation\nDESCRIPTION: Full implementation of the RPC client that includes correlation ID handling, response matching, and request-response management.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/6-rpc.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# rpc_client.py content here was displayed as a file reference\n```\n\n----------------------------------------\n\nTITLE: Publishing and Consuming Messages with aio-pika in Python\nDESCRIPTION: This example shows how to publish a message to a RabbitMQ queue and then immediately consume it using aio-pika. It demonstrates connection setup, channel creation, queue declaration, message publishing, and message retrieval.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom typing import Optional\n\nimport aiormq\nfrom aiormq.abc import DeliveredMessage\n\nMESSAGE: Optional[DeliveredMessage] = None\n\nasync def main():\n    global MESSAGE\n    body = b'Hello World!'\n\n    # Perform connection\n    connection = await aiormq.connect(\"amqp://guest:guest@localhost//\")\n\n    # Creating a channel\n    channel = await connection.channel()\n    declare_ok = await channel.queue_declare(\"hello\", auto_delete=True)\n\n    # Sending the message\n    await channel.basic_publish(body, routing_key='hello')\n    print(f\" [x] Sent {body}\")\n\n    MESSAGE = await channel.basic_get(declare_ok.queue)\n    print(f\" [x] Received message from {declare_ok.queue!r}\")\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n\nassert MESSAGE is not None\nassert MESSAGE.routing_key == \"hello\"\nassert MESSAGE.body == b'Hello World!'\n```\n\n----------------------------------------\n\nTITLE: Implementing Master Pattern in Python with AIO-PIKA\nDESCRIPTION: Example of implementing the Master component in a Master/Worker pattern using AIO-PIKA. Shows how to create and distribute tasks to workers.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/patterns.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# examples/master.py\n```\n\n----------------------------------------\n\nTITLE: Publishing and Retrieving a Single Message with aio-pika in Python\nDESCRIPTION: This example shows how to publish a message to a RabbitMQ exchange and then retrieve it synchronously from a queue. It demonstrates declaring an exchange, binding a queue, publishing a message with headers, and then retrieving and acknowledging that message. The example finishes by properly cleaning up resources.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom aio_pika import connect_robust, Message\n\n\nasync def main(loop):\n    connection = await connect_robust(\n        \"amqp://guest:guest@127.0.0.1/\",\n        loop=loop\n    )\n\n    queue_name = \"test_queue\"\n    routing_key = \"test_queue\"\n\n    # Creating channel\n    channel = await connection.channel()\n\n    # Declaring exchange\n    exchange = await channel.declare_exchange('direct', auto_delete=True)\n\n    # Declaring queue\n    queue = await channel.declare_queue(queue_name, auto_delete=True)\n\n    # Binding queue\n    await queue.bind(exchange, routing_key)\n\n    await exchange.publish(\n        Message(\n            bytes('Hello', 'utf-8'),\n            content_type='text/plain',\n            headers={'foo': 'bar'}\n        ),\n        routing_key\n    )\n\n    # Receiving message\n    incoming_message = await queue.get(timeout=5)\n\n    # Confirm message\n    await incoming_message.ack()\n\n    await queue.unbind(exchange, routing_key)\n    await queue.delete()\n    await connection.close()\n\n\nif __name__ == \"__main__\":\n    loop = asyncio.get_event_loop()\n    loop.run_until_complete(main(loop))\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC Caller in Python with AIO-PIKA\nDESCRIPTION: Example of implementing the caller component in an RPC pattern using AIO-PIKA. Demonstrates how to create tasks and await their results.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/patterns.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# examples/rpc-caller.py\n```\n\n----------------------------------------\n\nTITLE: Consuming Messages Asynchronously with aio-pika in Python\nDESCRIPTION: This snippet demonstrates how to set up an asynchronous consumer for RabbitMQ using aio-pika. It establishes a connection, declares a queue, and sets up a basic consumer that processes messages with a simulated async I/O operation.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nprint(f\" [x] Received message {message!r}\")\nprint(f\"Message body is: {message.body!r}\")\nprint(\"Before sleep!\")\nawait asyncio.sleep(5)   # Represents async I/O operations\nprint(\"After sleep!\")\n\nasync def main():\n    # Perform connection\n    connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n    # Creating a channel\n    channel = await connection.channel()\n\n    # Declaring queue\n    declare_ok = await channel.queue_declare('helo')\n    consume_ok = await channel.basic_consume(\n        declare_ok.queue, on_message, no_ack=True\n    )\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nloop.run_forever()\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC Callee in Python with AIO-PIKA\nDESCRIPTION: Example of implementing the callee component in an RPC pattern using AIO-PIKA. Shows how to receive and process RPC requests.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/patterns.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# examples/rpc-callee.py\n```\n\n----------------------------------------\n\nTITLE: Implementing Simple Consumer with aio-pika in Python\nDESCRIPTION: This snippet demonstrates how to create a simple consumer using the aio-pika library. It likely includes setting up a connection, declaring a queue, and consuming messages asynchronously.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Emitting Logs with Topic Exchange using aio-pika\nDESCRIPTION: Python script that publishes log messages to a topic exchange with dot-delimited routing keys in the format '<facility>.<severity>'. The routing key and message body are specified as command-line arguments.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/5-topics.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport asyncio\nfrom aio_pika import connect, Message, DeliveryMode, ExchangeType\n\n\nasync def main():\n    # Perform connection\n    connection = await connect(\"amqp://guest:guest@localhost/\")\n\n    # Creating a channel\n    channel = await connection.channel()\n\n    # Declaring exchange\n    exchange = await channel.declare_exchange(\n        'topic_logs', ExchangeType.TOPIC\n    )\n\n    routing_key = sys.argv[1] if len(sys.argv) > 2 else 'anonymous.info'\n    message_body = ' '.join(sys.argv[2:]) or \"Hello World!\"\n\n    message = Message(\n        message_body.encode(),\n        delivery_mode=DeliveryMode.PERSISTENT\n    )\n\n    # Sending the message\n    await exchange.publish(message, routing_key=routing_key)\n\n    print(\"Sent %r:%r\" % (routing_key, message_body))\n\n    await connection.close()\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Complete Send Script for RabbitMQ with aio-pika in Python\nDESCRIPTION: This is the full implementation of the send.py script that connects to RabbitMQ, declares a queue, and sends a 'Hello World!' message.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom aio_pika import connect_robust, Message\n\nasync def main():\n    connection = await connect_robust(\n        \"amqp://guest:guest@localhost/\"\n    )\n\n    async with connection:\n        # Creating channel\n        channel = await connection.channel()\n\n        # Declaring queue\n        queue = await channel.declare_queue('hello')\n\n        await channel.default_exchange.publish(\n            Message(body='Hello World!'.encode()),\n            routing_key='hello'\n        )\n\n        print(\" [x] Sent 'Hello World!'\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Receiving Logs with Topic Filters using aio-pika\nDESCRIPTION: Python script that subscribes to logs from a topic exchange with binding patterns specified as command-line arguments. It demonstrates how to use the special characters '*' (single word) and '#' (multiple words) for pattern matching in topic exchanges.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/5-topics.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport asyncio\nfrom aio_pika import connect, ExchangeType\n\n\nasync def main():\n    # Perform connection\n    connection = await connect(\"amqp://guest:guest@localhost/\")\n\n    # Creating a channel\n    channel = await connection.channel()\n    await channel.set_qos(prefetch_count=1)\n\n    # Declaring exchange\n    exchange = await channel.declare_exchange(\n        'topic_logs', ExchangeType.TOPIC\n    )\n\n    # Declaring queue\n    queue = await channel.declare_queue(exclusive=True)\n\n    # Binding keys from command line arguments\n    binding_keys = sys.argv[1:] or ['anonymous.info']\n\n    for binding_key in binding_keys:\n        await queue.bind(exchange, binding_key)\n\n    print(' [*] Waiting for logs. To exit press CTRL+C')\n\n    async with queue.iterator() as queue_iter:\n        async for message in queue_iter:\n            async with message.process():\n                print(\n                    \" [x] %r:%r\" % (\n                        message.routing_key,\n                        message.body.decode()\n                    )\n                )\n\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Complete Receive Script for RabbitMQ with aio-pika in Python\nDESCRIPTION: This is the full implementation of the receive.py script that connects to RabbitMQ, declares a queue, and sets up a consumer to receive and print messages.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom aio_pika import connect_robust, IncomingMessage\n\nasync def on_message(message: IncomingMessage):\n    async with message.process():\n        print(f\"[x] Received message {message}\")\n        print(f\"Message body is: {message.body!r}\")\n\nasync def main():\n    # Perform connection\n    connection = await connect_robust(\n        \"amqp://guest:guest@localhost/\"\n    )\n\n    async with connection:\n        # Creating a channel\n        channel = await connection.channel()\n\n        # Declaring queue\n        queue = await channel.declare_queue('hello')\n\n        # Start listening the queue with name 'hello'\n        await queue.consume(on_message, no_ack=True)\n\n        print(' [*] Waiting for messages. To exit press CTRL+C')\n        await asyncio.Future()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Complete Log Receiver Script in Python with aio-pika\nDESCRIPTION: This is the full implementation of the log receiver (subscriber) using aio-pika. It sets up a connection, declares a temporary queue, binds it to the 'logs' exchange, and consumes messages.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom aio_pika import connect_robust, ExchangeType\n\n\nasync def main() -> None:\n    # Perform connection\n    connection = await connect_robust(\n        \"amqp://guest:guest@localhost/\",\n    )\n\n    async with connection:\n        # Creating a channel\n        channel = await connection.channel()\n\n        # Declaring exchange\n        logs_exchange = await channel.declare_exchange(\n            'logs', ExchangeType.FANOUT\n        )\n\n        # Declaring queue\n        queue = await channel.declare_queue(exclusive=True)\n\n        # Binding the queue to the exchange\n        await queue.bind(logs_exchange)\n\n        print(' [*] Waiting for logs. To exit press CTRL+C')\n\n        async with queue.iterator() as queue_iter:\n            async for message in queue_iter:\n                async with message.process():\n                    print(f\" [x] {message.body.decode()}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Complete Log Emitter Script in Python with aio-pika\nDESCRIPTION: This is the full implementation of the log emitter (publisher) using aio-pika. It sets up a connection, declares the 'logs' exchange, and publishes messages to it.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport asyncio\nfrom aio_pika import connect_robust, Message, ExchangeType\n\n\nasync def main() -> None:\n    # Perform connection\n    connection = await connect_robust(\n        \"amqp://guest:guest@localhost/\",\n    )\n\n    async with connection:\n        # Creating a channel\n        channel = await connection.channel()\n\n        logs_exchange = await channel.declare_exchange(\n            'logs', ExchangeType.FANOUT\n        )\n\n        message = ' '.join(sys.argv[1:]) or \"info: Hello World!\"\n\n        await logs_exchange.publish(\n            Message(message.encode()),\n            routing_key=''\n        )\n\n        print(f\" [x] Sent {message}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Basic aiormq Publisher Implementation in Python\nDESCRIPTION: This code demonstrates a simple publisher implementation using aiormq. It connects to RabbitMQ, declares a queue, publishes a message, and then retrieves that message from the queue to verify it was successfully published. The example includes assertions to verify the message properties.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom typing import Optional\n\nimport aiormq\nfrom aiormq.abc import DeliveredMessage\n\nMESSAGE: Optional[DeliveredMessage] = None\n\nasync def main():\n    global MESSAGE\n    body = b'Hello World!'\n\n    # Perform connection\n    connection = await aiormq.connect(\"amqp://guest:guest@localhost//\")\n\n    # Creating a channel\n    channel = await connection.channel()\n    declare_ok = await channel.queue_declare(\"hello\", auto_delete=True)\n\n    # Sending the message\n    await channel.basic_publish(body, routing_key='hello')\n    print(f\" [x] Sent {body}\")\n\n    MESSAGE = await channel.basic_get(declare_ok.queue)\n    print(f\" [x] Received message from {declare_ok.queue!r}\")\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n\nassert MESSAGE is not None\nassert MESSAGE.routing_key == \"hello\"\nassert MESSAGE.body == b'Hello World!'\n```\n\n----------------------------------------\n\nTITLE: RabbitMQ Task Producer Implementation with aio-pika in Python\nDESCRIPTION: Complete implementation of a task producer that sends messages to a RabbitMQ queue with message persistence enabled. It creates a durable queue and publishes messages with routing keys.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nimport sys\nimport asyncio\nfrom aio_pika import connect, Message, DeliveryMode\n\n\nasync def main():\n    # Perform connection\n    connection = await connect(\"amqp://guest:guest@localhost/\")\n\n    async with connection:\n        # Creating a channel\n        channel = await connection.channel()\n\n        message_body = \" \".join(sys.argv[1:]) or \"Hello World!\"\n\n        # Declaring queue\n        queue = await channel.declare_queue(\n            \"task_queue\",\n            durable=True\n        )\n\n        await channel.default_exchange.publish(\n            Message(\n                message_body.encode(),\n                delivery_mode=DeliveryMode.PERSISTENT\n            ),\n            routing_key=\"task_queue\",\n        )\n        print(f\" [x] Sent {message_body}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Retrieving a Single Message with aio-pika in Python\nDESCRIPTION: This snippet shows how to fetch a single message from a queue using aio-pika. It likely includes connecting to RabbitMQ, declaring a queue, and using a method to retrieve one message at a time.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: RabbitMQ Worker Implementation with aio-pika in Python\nDESCRIPTION: Complete implementation of a RabbitMQ worker that processes messages from a durable queue with fair dispatch. It sets the prefetch count to 1, processes messages asynchronously, and sends acknowledgments after processing.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport time\nfrom aio_pika import connect\nfrom aio_pika.abc import AbstractIncomingMessage\n\n\ndef process_message(message: AbstractIncomingMessage) -> None:\n    print(f\" [x] Received {message.body.decode()}\")\n    time.sleep(message.body.count(b\".\"))\n    print(\" [x] Done\")\n\n\nasync def main() -> None:\n    # Perform connection\n    connection = await connect(\"amqp://guest:guest@localhost/\")\n\n    async with connection:\n        # Creating a channel\n        channel = await connection.channel()\n\n        # Maximum message count which will be\n        # processing at the same time.\n        await channel.set_qos(\n            prefetch_count=1\n        )\n\n        # Declaring queue\n        queue = await channel.declare_queue(\n            \"task_queue\",\n            durable=True\n        )\n\n        async with queue.iterator() as queue_iter:\n            async for message in queue_iter:\n                async with message.process():\n                    process_message(message)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Implementing Worker Pattern in Python with AIO-PIKA\nDESCRIPTION: Example of implementing the Worker component in a Master/Worker pattern using AIO-PIKA. Shows how workers receive and process tasks from the master.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/patterns.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# examples/worker.py\n```\n\n----------------------------------------\n\nTITLE: Complete RPC Server Implementation\nDESCRIPTION: Full implementation of the RPC server that handles Fibonacci number calculation requests. Includes queue setup, message handling, and result computation.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/6-rpc.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# rpc_server.py content here was displayed as a file reference\n```\n\n----------------------------------------\n\nTITLE: Setting RabbitMQ Prefetch Count with aio-pika in Python\nDESCRIPTION: Sets the prefetch count to 1 in a RabbitMQ consumer, ensuring fair dispatch by telling RabbitMQ not to give more than one message to a worker at a time until the previous message is acknowledged.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nawait channel.set_qos(\n    prefetch_count=1\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Asynchronous Message Processing with aio-pika in Python\nDESCRIPTION: This snippet illustrates how to process messages asynchronously using aio-pika. It likely includes setting up an asynchronous consumer and handling messages concurrently.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Binding a Queue to an Exchange in Python with aio-pika\nDESCRIPTION: This code shows how to bind a queue to the 'logs' exchange using aio-pika. It also demonstrates how to set up a message consumer for the queue.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nawait queue.bind(logs_exchange)\n\nprint(' [*] Waiting for logs. To exit press CTRL+C')\n\nasync with queue.iterator() as queue_iter:\n    async for message in queue_iter:\n        async with message.process():\n            print(f\" [x] {message.body.decode()}\")\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC with patio-rabbitmq Provider in Python\nDESCRIPTION: This code demonstrates how to implement an RPC service provider using patio and patio-rabbitmq. It defines a simple sum function, registers it with the RPC registry, and then sets up a RabbitMQ broker to serve the function. The service uses a ThreadPoolExecutor to handle concurrent requests.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\nfrom patio import Registry, ThreadPoolExecutor\nfrom patio_rabbitmq import RabbitMQBroker\n\nrpc = Registry(project=\"patio-rabbitmq\", auto_naming=False)\n\n@rpc(\"sum\")\ndef sum(*args):\n    return sum(args)\n\nasync def main():\n    async with ThreadPoolExecutor(rpc, max_workers=16) as executor:\n        async with RabbitMQBroker(\n            executor, amqp_url=\"amqp://guest:guest@localhost/\",\n        ) as broker:\n            await broker.join()\n```\n\n----------------------------------------\n\nTITLE: Creating a Fanout Exchange in Python with aio-pika\nDESCRIPTION: This snippet demonstrates how to create a fanout exchange named 'logs' using the aio-pika library. Fanout exchanges broadcast all messages to all bound queues.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nlogs_exchange = await channel.declare_exchange(\n    'logs', ExchangeType.FANOUT\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC with patio-rabbitmq Client in Python\nDESCRIPTION: This code demonstrates how to implement an RPC client using patio and patio-rabbitmq. It sets up a NullExecutor with a registry and creates a RabbitMQ broker to make RPC calls to a remote service. The example shows how to call a remote method concurrently for multiple values.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom patio import NullExecutor, Registry\nfrom patio_rabbitmq import RabbitMQBroker\n\nasync def main():\n    async with NullExecutor(Registry(project=\"patio-rabbitmq\")) as executor:\n        async with RabbitMQBroker(\n            executor, amqp_url=\"amqp://guest:guest@localhost/\",\n        ) as broker:\n            print(await asyncio.gather(\n                *[\n                    broker.call(\"mul\", i, i, timeout=1) for i in range(10)\n                 ]\n            ))\n```\n\n----------------------------------------\n\nTITLE: Declaring Direct Exchange in Python with aio-pika\nDESCRIPTION: Creating a direct exchange for routing messages based on severity levels\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/4-routing.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nfrom aio_pika import ExchangeType\n\nasync def main():\n    ...\n\n    direct_logs_exchange = await channel.declare_exchange(\n        'logs', ExchangeType.DIRECT\n    )\n```\n\n----------------------------------------\n\nTITLE: Calling Remote Procedures with patio and patio-rabbitmq in Python\nDESCRIPTION: This example shows how to call remote procedures implemented with patio and patio-rabbitmq. It sets up a NullExecutor and RabbitMQBroker, then demonstrates calling a remote 'mul' function concurrently for multiple inputs.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom patio import NullExecutor, Registry\nfrom patio_rabbitmq import RabbitMQBroker\n\nasync def main():\n    async with NullExecutor(Registry(project=\"patio-rabbitmq\")) as executor:\n        async with RabbitMQBroker(\n            executor, amqp_url=\"amqp://guest:guest@localhost/\",\n        ) as broker:\n            print(await asyncio.gather(\n                *[\n                    broker.call(\"mul\", i, i, timeout=1) for i in range(10)\n                 ]\n            ))\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Specific Message Severities in Python\nDESCRIPTION: Creating queue bindings for specific message severity levels using routing keys\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/4-routing.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    ...\n\n    # Declaring queue\n    queue = await channel.declare_queue(exclusive=True)\n\n    # Binding the queue to the exchange\n    await queue.bind(direct_logs_exchange,\n                     routing_key=severity)\n\n...\n```\n\n----------------------------------------\n\nTITLE: Implementing Real-time Communication with Socket.IO and aio-pika in Python\nDESCRIPTION: This example shows how to use python-socketio with an aio-pika adapter to implement real-time communication over RabbitMQ. It sets up a Socket.IO server with an AsyncAioPikaManager and defines an event handler for chat messages.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport socketio\nfrom aiohttp import web\n\nsio = socketio.AsyncServer(client_manager=socketio.AsyncAioPikaManager())\napp = web.Application()\nsio.attach(app)\n\n@sio.event\nasync def chat_message(sid, data):\n    print(\"message \", data)\n\nif __name__ == '__main__':\n    web.run_app(app)\n```\n\n----------------------------------------\n\nTITLE: Queue Declaration with Durability\nDESCRIPTION: Declaring a durable queue to ensure messages persist even if RabbitMQ restarts.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqueue = await channel.declare_queue(\"hello\", durable=True)\n```\n\n----------------------------------------\n\nTITLE: Establishing RabbitMQ Connection with aio-pika in Python\nDESCRIPTION: This snippet demonstrates how to establish a connection to a RabbitMQ server using the aio-pika library. It creates a connection and channel for further operations.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nfrom aio_pika import connect_robust\n\nasync def main():\n    connection = await connect_robust(\n        \"amqp://guest:guest@localhost/\"\n    )\n\n    async with connection:\n        # Creating channel\n        channel = await connection.channel()\n```\n\n----------------------------------------\n\nTITLE: Message Acknowledgment Handler\nDESCRIPTION: Message processing with explicit acknowledgment to ensure messages aren't lost if a worker fails.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def on_message(message: IncomingMessage):\n    print(\" [x] Received %r\" % message.body)\n    await asyncio.sleep(message.body.count(b'.'))\n    print(\" [x] Done\")\n    await message.ack()\n```\n\n----------------------------------------\n\nTITLE: Receiving Messages from RabbitMQ Queue with aio-pika in Python\nDESCRIPTION: This code shows how to set up a consumer to receive messages from the 'hello' queue using aio-pika. It defines a callback function to process received messages.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def on_message(message: IncomingMessage):\n    async with message.process():\n        print(f\"[x] Received message {message}\")\n        print(f\"Message body is: {message.body!r}\")\n\nasync def main():\n    # ... connection and channel setup ...\n\n    # Declaring queue\n    queue = await channel.declare_queue('hello')\n\n    # Start listening the queue with name 'hello'\n    await queue.consume(on_message, no_ack=True)\n```\n\n----------------------------------------\n\nTITLE: Simple Worker Message Processing\nDESCRIPTION: Basic message processing function that simulates work by sleeping for a duration based on the number of dots in the message.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/2-work-queues.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def on_message(message: IncomingMessage):\n    print(\" [x] Received %r\" % message.body)\n    await asyncio.sleep(message.body.count(b'.'))\n    print(\" [x] Done\")\n```\n\n----------------------------------------\n\nTITLE: Creating a Queue in RabbitMQ with aio-pika in Python\nDESCRIPTION: This code snippet shows how to declare a queue named 'hello' using aio-pika. It ensures the queue exists before sending messages to it.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\n# Declaring queue\nqueue = await channel.declare_queue('hello')\n```\n\n----------------------------------------\n\nTITLE: Implementing RPC over RabbitMQ with patio and patio-rabbitmq in Python\nDESCRIPTION: This snippet demonstrates how to use patio and patio-rabbitmq to implement RPC (Remote Procedure Call) functionality over RabbitMQ. It sets up a Registry, defines a function to be called remotely, and configures a RabbitMQ broker for execution.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\nfrom patio import Registry, ThreadPoolExecutor\nfrom patio_rabbitmq import RabbitMQBroker\n\nrpc = Registry(project=\"patio-rabbitmq\", auto_naming=False)\n\n@rpc(\"sum\")\ndef sum(*args):\n    return sum(args)\n\nasync def main():\n    async with ThreadPoolExecutor(rpc, max_workers=16) as executor:\n        async with RabbitMQBroker(\n            executor, amqp_url=\"amqp://guest:guest@localhost/\",\n        ) as broker:\n            await broker.join()\n```\n\n----------------------------------------\n\nTITLE: Sending a Message to RabbitMQ Queue with aio-pika in Python\nDESCRIPTION: This snippet demonstrates how to send a 'Hello World!' message to the 'hello' queue using aio-pika. It uses the default exchange for routing.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/1-introduction.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nawait channel.default_exchange.publish(\n    aio_pika.Message(body='Hello World!'.encode()),\n    routing_key='hello'\n)\n\nprint(\" [x] Sent 'Hello World!'\"\n```\n\n----------------------------------------\n\nTITLE: Using taskiq with aio-pika Broker for Distributed Task Queue in Python\nDESCRIPTION: This example demonstrates how to use taskiq with an aio-pika broker to create a distributed task queue. It sets up an AioPikaBroker, defines an asynchronous task, and shows how to start the broker and execute the task.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom taskiq_aio_pika import AioPikaBroker\n\nbroker = AioPikaBroker()\n\n@broker.task\nasync def test() -> None:\n    print(\"nothing\")\n\nasync def main():\n    await broker.startup()\n    await test.kiq()\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages to a Named Exchange in Python with aio-pika\nDESCRIPTION: This code shows how to publish a message to a named exchange ('logs') instead of the default exchange. It includes error handling and connection closing.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nawait logs_exchange.publish(\n    Message(message.encode()),\n    routing_key=''\n)\n\nprint(f\" [x] Sent {message}\")\n\nawait connection.close()\n```\n\n----------------------------------------\n\nTITLE: Using FastStream with RabbitMQ in Python\nDESCRIPTION: This example demonstrates how to use FastStream, a high-level Python library, to interact with RabbitMQ. It creates a RabbitBroker connection and sets up a subscriber function that processes messages from a 'user' queue. The function expects the message payload to be an integer representing a user_id.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n@broker.subscriber(\"user\")\nasync def user_created(user_id: int):\n    assert isinstance(user_id, int)\n```\n\n----------------------------------------\n\nTITLE: Declaring a Temporary Queue in Python with aio-pika\nDESCRIPTION: This snippet demonstrates how to declare a temporary queue with a server-generated name using aio-pika. The queue is set to be exclusive and will be deleted when the connection is closed.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/3-publish-subscribe.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nqueue = await channel.declare_queue(exclusive=True)\n```\n\n----------------------------------------\n\nTITLE: Building Asynchronous Services with FastStream and RabbitMQ in Python\nDESCRIPTION: This snippet demonstrates how to use FastStream with RabbitMQ to build asynchronous services. It sets up a RabbitBroker, defines a subscriber function for handling messages, and includes an after_startup hook for publishing a test message.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nfrom faststream import FastStream\nfrom faststream.rabbit import RabbitBroker\n\nbroker = RabbitBroker(\"amqp://guest:guest@localhost:5672/\")\napp = FastStream(broker)\n\n@broker.subscriber(\"user\")\nasync def user_created(user_id: int):\n    assert isinstance(user_id, int)\n    return f\"user-{user_id}: created\"\n\n@app.after_startup\nasync def pub_smth():\n    assert (\n        await broker.publish(1, \"user\", rpc=True)\n    ) ==  \"user-1: created\"\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages with Routing Key in Python\nDESCRIPTION: Example of publishing messages to a direct exchange with severity-based routing\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/4-routing.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    ...\n\n    await direct_logs_exchange.publish(\n        Message(message_body),\n        routing_key=severity,\n    )\n```\n\n----------------------------------------\n\nTITLE: Queue Iterator Usage with Async With\nDESCRIPTION: Example of Queue usage with async context manager returning QueueIterator. Supports async iteration pattern for message processing.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/CHANGELOG.md#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync with Queue() as queue_iterator:\n    async for message in queue_iterator:\n        # Process message\n        pass\n```\n\n----------------------------------------\n\nTITLE: Binding Queue with Routing Key in Python\nDESCRIPTION: Example of creating a queue binding with a specific routing key for message filtering\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/4-routing.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    ...\n\n    # Binding the queue to the exchange\n    await queue.bind(logs_exchange,\n                     routing_key=\"black\")\n\n...\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Client Implementation - Python\nDESCRIPTION: Example of a Socket.IO client connecting to a server and emitting a chat message event.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport socketio\n\nsio = socketio.AsyncClient()\n\nasync def main():\n    await sio.connect('http://localhost:8080')\n    await sio.emit('chat_message', {'response': 'my response'})\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Publishing and Handling Confirms Function with aio-pika\nDESCRIPTION: This function publishes a message and handles the confirmation asynchronously. It demonstrates how to publish a message, wait for confirmation, and handle timeouts or rejections.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/7-publisher-confirms.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nasync def publish_and_handle_confirm(body, exchange, routing_key):\n    message = aio_pika.Message(body=body.encode())\n    try:\n        confirmation = await channel.publish(\n            message, exchange=exchange, routing_key=routing_key\n        )\n        # Handle other exceptions, like ConnectionError\n    except aio_pika.exceptions.PublishError as e:\n        # Log or handle nack or error\n        print(f'Message was rejected: {e!r}')\n    else:\n        if isinstance(confirmation, aio_pika.abc.DeliveryError):\n            print(f'Message was returned: {confirmation!r}')\n        else:\n            print('Message was confirmed')\n    print(f'Message {body} handled')\n```\n\n----------------------------------------\n\nTITLE: Configuring Logging Level for aio-pika in Python\nDESCRIPTION: This example illustrates how to set the logging level specifically for aio-pika without affecting other loggers. It demonstrates a way to configure debug logs independently for the library.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_5\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Handling Publisher Confirms Asynchronously with aio-pika\nDESCRIPTION: This snippet demonstrates how to handle publisher confirms asynchronously. It creates tasks for publishing messages and handling confirmations, then uses asyncio.gather to wait for all tasks to complete.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/7-publisher-confirms.rst#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\n# List for storing tasks\ntasks = []\n\nfor i in range(1000):\n    task = asyncio.create_task(\n        publish_and_handle_confirm(\n            f'Hello World! {i}',\n            exchange='',\n            routing_key='task_queue'\n        )\n    )\n    tasks.append(task)\n    await asyncio.sleep(0)\n\nawait asyncio.gather(*tasks)\n```\n\n----------------------------------------\n\nTITLE: Documenting aio_pika.patterns.Master Class in Python\nDESCRIPTION: This snippet uses Sphinx autodoc directives to generate documentation for the aio_pika.patterns.Master class and its members.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/apidoc.rst#2025-04-16_snippet_2\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: aio_pika.patterns.Master\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Publishing Messages in Batches with aio-pika\nDESCRIPTION: This code snippet shows how to publish messages in batches and wait for confirmations. It uses a batch size of 100 and creates tasks for sending messages asynchronously.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/7-publisher-confirms.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nbatchsize = 100\ntasks = []\n\nasync def send_batch():\n    batch = []\n    for i in range(batchsize):\n        message = aio_pika.Message(body=f'Hello World! {i}'.encode())\n        batch.append(channel.publish(\n            message, exchange='', routing_key='task_queue'\n        ))\n    await asyncio.gather(*batch)\n\nfor _ in range(10):\n    task = asyncio.create_task(send_batch())\n    tasks.append(task)\n    await asyncio.sleep(0)\n\nawait asyncio.gather(*tasks)\n```\n\n----------------------------------------\n\nTITLE: Connect Robust Coroutine Implementation\nDESCRIPTION: Implementation change where connect_robust is now a direct coroutine instead of a function returning a coroutine. Affects type checking in IDEs like PyCharm.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/CHANGELOG.md#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nawait connect_robust()  # Direct coroutine call\n```\n\n----------------------------------------\n\nTITLE: Enabling Publisher Confirms on a Channel with aio-pika\nDESCRIPTION: This snippet demonstrates how to enable publisher confirms on a channel when creating it. Publisher confirms are enabled by default, but this shows how to explicitly set the parameter.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/7-publisher-confirms.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nchannel = await connection.channel(\n   publisher_confirms=True, # This is the default\n)\n```\n\n----------------------------------------\n\nTITLE: Creating Queue Binding in Python with aio-pika\nDESCRIPTION: Basic example of binding a queue to an exchange without a routing key\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/4-routing.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    ...\n\n    # Binding the queue to the exchange\n    await queue.bind(logs_exchange)\n\n...\n```\n\n----------------------------------------\n\nTITLE: FastStream RPC Message Publishing Example - Python\nDESCRIPTION: Example showing how to use FastStream with aio-pika for RPC message publishing and handling user creation events.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\nreturn f\"user-{user_id}: created\"\n\n@app.after_startup\nasync def pub_smth():\n    assert (\n        await broker.publish(1, \"user\", rpc=True)\n    ) ==  \"user-1: created\"\n```\n\n----------------------------------------\n\nTITLE: Installing aio-pika from Git\nDESCRIPTION: Demonstrates how to install aio-pika directly from the GitHub repository using pip or manual installation.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n# via pip\npip install https://github.com/mosquito/aio-pika/archive/master.zip\n\n# manually\ngit clone https://github.com/mosquito/aio-pika.git\ncd aio-pika\npython setup.py install\n```\n\n----------------------------------------\n\nTITLE: Basic aiormq Consumer Implementation in Python\nDESCRIPTION: This code demonstrates a simple consumer implementation using aiormq, the low-level AMQP client library that powers aio-pika. It shows how to connect to RabbitMQ, declare a queue, and set up a consumer with a callback function that processes messages asynchronously.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport aiormq\n\nasync def on_message(message):\n    \"\"\"\n    on_message doesn't necessarily have to be defined as async.\n    Here it is to show that it's possible.\n    \"\"\"\n    print(f\" [x] Received message {message!r}\")\n    print(f\"Message body is: {message.body!r}\")\n    print(\"Before sleep!\")\n    await asyncio.sleep(5)   # Represents async I/O operations\n    print(\"After sleep!\")\n\nasync def main():\n    # Perform connection\n    connection = await aiormq.connect(\"amqp://guest:guest@localhost/\")\n\n    # Creating a channel\n    channel = await connection.channel()\n\n    # Declaring queue\n    declare_ok = await channel.queue_declare('helo')\n    consume_ok = await channel.basic_consume(\n        declare_ok.queue, on_message, no_ack=True\n    )\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\nloop.run_forever()\n```\n\n----------------------------------------\n\nTITLE: Development Environment Setup - Shell\nDESCRIPTION: Shell commands for setting up the development environment for aio-pika, including cloning the repository and installing dependencies.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/mosquito/aio-pika.git\ncd aio-pika\n```\n\nLANGUAGE: shell\nCODE:\n```\npython3 -m venv env\nsource env/bin/activate\n```\n\nLANGUAGE: shell\nCODE:\n```\npip install -e '.[develop]'\n```\n\n----------------------------------------\n\nTITLE: Implementing Connection Pooling with aio-pika in Python\nDESCRIPTION: This snippet illustrates how to implement connection pooling using aio-pika. It likely includes creating and managing a pool of connections to improve performance and resource utilization.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_8\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Documentation Live Preview - Bash\nDESCRIPTION: Command for running a live preview of the documentation in the browser.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_14\n\nLANGUAGE: bash\nCODE:\n```\nnox -s docs -- serve\n```\n\n----------------------------------------\n\nTITLE: Working with RabbitMQ Transactions using aio-pika in Python\nDESCRIPTION: This example demonstrates how to use transactions with RabbitMQ via aio-pika. It probably covers starting a transaction, publishing messages, and committing or rolling back the transaction.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Configuring Sphinx toctree for RabbitMQ tutorials in restructuredtext\nDESCRIPTION: This restructuredtext snippet defines a table of contents structure for RabbitMQ tutorials that have been adopted for aio-pika. It uses the Sphinx toctree directive with glob pattern matching to include all files matching the '*-*' pattern.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/index.rst#2025-04-16_snippet_0\n\nLANGUAGE: restructuredtext\nCODE:\n```\n.. toctree::\n   :glob:\n   :maxdepth: 3\n   :caption: RabbitMQ tutorial adopted for aio-pika\n\n   *-*\n```\n\n----------------------------------------\n\nTITLE: Integrating aio-pika with Tornado Framework in Python\nDESCRIPTION: This snippet shows how to use aio-pika with the Tornado web framework. It likely includes setting up a Tornado application with aio-pika for handling pub/sub operations.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_6\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Using External Credentials with aio-pika in Python\nDESCRIPTION: This example demonstrates how to use external credentials with aio-pika. It probably covers loading credentials from an external source and using them to establish a connection to RabbitMQ.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/quick-start.rst#2025-04-16_snippet_7\n\nLANGUAGE: python\nCODE:\n```\n# Code not provided in the original text\n```\n\n----------------------------------------\n\nTITLE: Extending Pattern Serialization in Python with AIO-PIKA\nDESCRIPTION: Example of extending the base patterns by customizing serialization behavior through inheritance. Demonstrates how to override serialize and deserialize methods.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/patterns.rst#2025-04-16_snippet_4\n\nLANGUAGE: python\nCODE:\n```\n# examples/extend-patterns.py\n```\n\n----------------------------------------\n\nTITLE: Basic RPC Client Call Example\nDESCRIPTION: Demonstrates the basic usage of the FibonacciRpcClient class to make an RPC call for calculating Fibonacci numbers.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/6-rpc.rst#2025-04-16_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    fibonacci_rpc = FibonacciRpcClient()\n    result = await fibonacci_rpc.call(4)\n    print(\"fib(4) is %r\" % result)\n```\n\n----------------------------------------\n\nTITLE: RPC Client Queue Declaration\nDESCRIPTION: Shows how to set up a callback queue for receiving RPC responses and publishing a request message with reply_to information.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/rabbitmq-tutorial/6-rpc.rst#2025-04-16_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nasync def main():\n    ...\n\n    # Queue for results\n    callback_queue = await channel.declare_queue(exclusive=True)\n\n    await channel.default_exchange.publish(\n        Message(\n            request,\n            reply_to=callback_queue.name\n        ),\n        routing_key='rpc_queue'\n    )\n```\n\n----------------------------------------\n\nTITLE: Socket.IO Server Setup with AioPika - Python\nDESCRIPTION: Implementation of a Socket.IO server using aio-pika adapter for RabbitMQ integration with AIOHTTP web application.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_9\n\nLANGUAGE: python\nCODE:\n```\nimport socketio\nfrom aiohttp import web\n\nsio = socketio.AsyncServer(client_manager=socketio.AsyncAioPikaManager())\napp = web.Application()\nsio.attach(app)\n\n@sio.event\nasync def chat_message(sid, data):\n    print(\"message \", data)\n\nif __name__ == '__main__':\n    web.run_app(app)\n```\n\n----------------------------------------\n\nTITLE: Taskiq AioPika Broker Setup - Python\nDESCRIPTION: Example of setting up a Taskiq task queue with aio-pika broker integration.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_11\n\nLANGUAGE: python\nCODE:\n```\nfrom taskiq_aio_pika import AioPikaBroker\n\nbroker = AioPikaBroker()\n\n@broker.task\nasync def test() -> None:\n    print(\"nothing\")\n\nasync def main():\n    await broker.startup()\n    await test.kiq()\n```\n\n----------------------------------------\n\nTITLE: Connecting to Socket.IO Server with Python Client\nDESCRIPTION: This snippet demonstrates how to connect to a Socket.IO server using a Python client and emit a chat message. It uses the asyncio library for asynchronous execution.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_10\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport socketio\n\nsio = socketio.AsyncClient()\n\nasync def main():\n    await sio.connect('http://localhost:8080')\n    await sio.emit('chat_message', {'response': 'my response'})\n\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n----------------------------------------\n\nTITLE: Installing aio-pika with pip\nDESCRIPTION: Shows how to install aio-pika using pip package manager.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npip install aio-pika\n```\n\n----------------------------------------\n\nTITLE: Simple consumer using aiormq\nDESCRIPTION: Demonstrates a simple message consumer using aiormq, the underlying AMQP client library used by aio-pika.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_3\n\nLANGUAGE: python\nCODE:\n```\nimport asyncio\nimport aiormq\n\nasync def on_message(message):\n    \"\"\"\n    on_message doesn't necessarily have to be defined as async.\n    Here it is to show that it's possible.\n    \"\"\"\n```\n\n----------------------------------------\n\nTITLE: Setting up aio-pika development environment\nDESCRIPTION: Shows the steps to set up a development environment for aio-pika, including cloning the repository, creating a virtual environment, and installing dependencies.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/index.rst#2025-04-16_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\ngit clone https://github.com/mosquito/aio-pika.git\ncd aio-pika\n\nvirtualenv -p python3.5 env\n\nenv/bin/pip install -e '.[develop]'\n```\n\n----------------------------------------\n\nTITLE: Documenting aio_pika.patterns.RPC Class in Python\nDESCRIPTION: This snippet uses Sphinx autodoc directives to generate documentation for the aio_pika.patterns.RPC class and its members.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/apidoc.rst#2025-04-16_snippet_4\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: aio_pika.patterns.RPC\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting aio_pika.patterns.Worker Class in Python\nDESCRIPTION: This snippet uses Sphinx autodoc directives to generate documentation for the aio_pika.patterns.Worker class and its members.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/apidoc.rst#2025-04-16_snippet_3\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: aio_pika.patterns.Worker\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting aio_pika.patterns.base Class in Python\nDESCRIPTION: This snippet uses Sphinx autodoc directives to generate documentation for the aio_pika.patterns.base class and its members.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/apidoc.rst#2025-04-16_snippet_1\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. autoclass:: aio_pika.patterns.base\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Documenting aio_pika Module in Python\nDESCRIPTION: This snippet uses Sphinx autodoc directives to generate documentation for the aio_pika module and its members.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/source/apidoc.rst#2025-04-16_snippet_0\n\nLANGUAGE: reStructuredText\nCODE:\n```\n.. automodule:: aio_pika\n    :members:\n```\n\n----------------------------------------\n\nTITLE: Specifying ReadTheDocs Dependencies for aio-pika Project in Python\nDESCRIPTION: This code snippet lists the Python packages required for building the documentation for the aio-pika project on ReadTheDocs. It includes autodoc for automatic API documentation generation from docstrings and furo for the Sphinx documentation theme.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/docs/requirements.txt#2025-04-16_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# ONLY FOR ReadTheDocs\nautodoc\nfuro\n```\n\n----------------------------------------\n\nTITLE: Connection Close Task Return\nDESCRIPTION: Modified Connection.close method to return an asyncio.Task instead of a coroutine for better async operation handling.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/CHANGELOG.md#2025-04-16_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nclose_task = connection.close()  # Returns asyncio.Task\n```\n\n----------------------------------------\n\nTITLE: Running Tests with Docker - Bash\nDESCRIPTION: Commands for running tests using Docker with RabbitMQ instance.\nSOURCE: https://github.com/mosquito/aio-pika/blob/master/README.rst#2025-04-16_snippet_13\n\nLANGUAGE: bash\nCODE:\n```\nmake rabbitmq\n```\n\nLANGUAGE: bash\nCODE:\n```\nmake test\n```"
  }
]