[
  {
    "owner": "vunit",
    "repo": "vunit",
    "content": "TITLE: Initializing a Minimal VUnit Testbench in VHDL\nDESCRIPTION: Demonstrates the basic structure of a VUnit testbench. It includes the necessary `vunit_lib` library, the `runner_cfg` generic for Python runner (PR) control (with a default for standalone use), and a main `test_runner` process. This process calls `test_runner_setup` with the `runner_cfg` and a global `runner` signal, executes test code (e.g., using `check_equal`), and finishes with `test_runner_cleanup` to end the simulation.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/tb_minimal.html\n-- This snippet illustrates the minimal required structure for a VUnit testbench.\n-- Key elements:\n-- 1. Library and context clauses for vunit_lib.\n-- 2. The 'runner_cfg' generic for external control.\n-- 3. The main 'test_runner' process.\n-- 4. Calls to 'test_runner_setup' and 'test_runner_cleanup'.\n-- 5. Placement of test code between setup and cleanup.\n```\n\n----------------------------------------\n\nTITLE: Special Generics/Parameters in HDL Test Benches\nDESCRIPTION: This section details the special generics or parameters used in HDL test benches with VUnit, including the required `runner_cfg` string, and optional `output_path` and `tb_path` parameters. These are used to pass information, specify output directories, and locate test benches relative to source files, with VUnit initiating these parameters automatically when detected.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/user_guide.rst#_snippet_4\n\nLANGUAGE: Text\nCODE:\n```\n - [**required**] `runner_cfg : string`, used by VUnit to pass private information between Python and the HDL test runner.\n\n - [**optional**] `output_path : string`, path to the output directory of the current test; this is useful to create additional output files that can be checked after simulation by a **post_check** Python function.\n\n - [**optional**] `tb_path : string`, path to the directory containing the test bench; this is useful to read input data with a known location relative to the test bench location.\n```\n\n----------------------------------------\n\nTITLE: Checking for Message Presence - VHDL\nDESCRIPTION: This code snippet shows how to check if an actor has at least one message in its inbox. The `has_message` function returns a boolean value indicating the presence of messages. This allows non-blocking checks for pending messages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_28\n\nLANGUAGE: vhdl\nCODE:\n```\nhas_message(my_actor);\n```\n\n----------------------------------------\n\nTITLE: Adding VUnit Communication Library in Python\nDESCRIPTION: This snippet shows how to set up the VUnit project to include the communication library 'com' by adding it as a VHDL library in the 'vunit_lib' library. It requires importing VUnit and calling 'add_com' after instantiating the project object, thereby enabling communication features in the testbench.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nprj = VUnit.from_argv()\\nprj.add_vhdl_builtins()\\nprj.add_com()\n```\n\n----------------------------------------\n\nTITLE: Using VUnit Communication Contexts in VHDL Testbench\nDESCRIPTION: This snippet demonstrates including the required VUnit libraries and contexts in a VHDL testbench to enable communication. The 'vunit_lib' library is used and two contexts 'vunit_context' and 'com_context' are included to provide access to the basic VUnit and communication library features.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_1\n\nLANGUAGE: vhdl\nCODE:\n```\nlibrary vunit_lib;\\ncontext vunit_lib.vunit_context;\\ncontext vunit_lib.com_context;\n```\n\n----------------------------------------\n\nTITLE: Core Loop Handling Incoming Messages in a Testbench Actor\nDESCRIPTION: Shows the main message processing loop inside an actor 'plain_symbol_driver', decoding messages based on their type, executing actions like encryption, and sending acknowledgments back. Implements a structured, safe, and extensible message handling pattern.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_14\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Core of plain_symbol_driver\nloop\n  receive(net, self, message);\n  case get_msg_type(message.payload.all) is\n    when start_encrypting =>\n      sentence_msg := decode(message.payload.all);\n      encrypt(sentence_msg.sentence);\n      acknowledge(net, message.sender, message.id, true, receipt);\n    when others => null;\n  end case;\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Retrieving Oldest Message - VHDL\nDESCRIPTION: This code snippet shows how to get the oldest message in an actor's inbox. The `get_message` procedure retrieves the message and stores it in the `msg` variable. It assumes there is at least one message present.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_29\n\nLANGUAGE: vhdl\nCODE:\n```\nget_message(net, my_actor, msg);\n```\n\n----------------------------------------\n\nTITLE: Implementing Request-Reply Synchronization with receive_reply\nDESCRIPTION: Demonstrates how to wait for a reply acknowledgment from a process after sending a command, ensuring sequential synchronization. Uses a unique message ID to specifically wait for responses, providing reliable communication in testbenches.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_13\n\nLANGUAGE: VHDL\nCODE:\n```\nreceive_reply(net, self, plain_symbol_driver_receipt.id, sentence_is_encrypted, status);\n```\n\n----------------------------------------\n\nTITLE: Advanced Message Sending and Reply Handling in VHDL\nDESCRIPTION: This snippet extends the message passing pattern by showing interactions with multiple actors and advanced `com` features like sending messages with sender information (`self`) to enable replies and using `publish` (likely for broadcast or a specific delayed mechanism) for configuration updates. The loop includes generating data, sending instructions to multiple drivers, randomizing delays/values, and crucially, using `receive_reply` to block until a specific reply message is received from a driver process, synchronizing actions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\nfor i in 1 to 10 loop\n  sentence := create_random_sentence; -- 1\n\n  send(net, self, plain_symbol_driver, start_encrypting(sentence), plain_symbol_driver_receipt); -- 2\n  send(net, encrypted_symbol_monitor, start_verifying(sentence), receipt);  -- 3\n\n  shift := rv.RandInt(0, 10);  -- 4\n  sentence_length := find(sentence, NUL) - 1; -- 5\n  delay := rv.RandTime(0 ms, sentence_length * clk_period_c);  -- 6\n  publish(net, self, set_shift_after_delay(shift, delay), status);  -- 7\n\n  receive_reply(net, self, plain_symbol_driver_receipt.id, sentence_is_encrypted, status); -- 8\n  wait for rv.RandInt(0, 10) * clk_period_c ; -- 9\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Finding an Actor by Name or Identity in VHDL\nDESCRIPTION: Demonstrates how to obtain an actor handle using the 'find' function by specifying either the actor's name or its identity. This is useful if the actor constant is not globally accessible and needs to be resolved at runtime for sending messages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_4\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant found_receiver : actor_t := find(\"my receiver\");\n```\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant found_receiver : actor_t := find(my_receiver_id);\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Master Verification Component Interface in VHDL\nDESCRIPTION: This VHDL package interface defines the stream master verification component, which models master side behavior in stream-oriented communication protocols for simulation verification. It provides necessary signals, data structures, and control processes for driving and monitoring stream transactions. Dependencies include standard VHDL libraries and possibly other VUnit verification components.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/verification_components/vci.rst#_snippet_1\n\nLANGUAGE: vhdl\nCODE:\n```\nPackage content from ../../vunit/vhdl/verification_components/src/stream_master_pkg.vhd starting at line 7\n```\n\n----------------------------------------\n\nTITLE: Creating an Actor from an Identity in VHDL\nDESCRIPTION: This snippet shows creating an actor directly from an identity of type 'id_t' obtained via the 'get_id' function and using it in 'new_actor'. It allows mapping named identities to actors, supporting named addressing in the communication system.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant my_receiver_id : id_t := get_id(\"my receiver\");\\nconstant my_receiver : actor_t := new_actor(my_receiver_id);\n```\n\n----------------------------------------\n\nTITLE: Waiting for Reply with Timeout - VHDL\nDESCRIPTION: This code snippet demonstrates how to wait for a reply to a request message with a timeout. The `wait_for_reply` procedure blocks until a reply is received or the timeout is reached. The `status` variable indicates success or timeout. Upon success, `get_reply` retrieves the reply.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_30\n\nLANGUAGE: vhdl\nCODE:\n```\nwait_for_reply(net, request_msg, status, timeout => 10 ns);\n  if status = ok then\n    get_reply(net, request_msg, reply_msg);\n  end if;\n```\n\n----------------------------------------\n\nTITLE: Reusable wait-until-idle message handler as VHDL VCI\nDESCRIPTION: Encapsulates the wait-until-idle behavior into a VHDL procedure within a verification component interface (VCI), promoting reuse and modularity. Enables actors to incorporate this synchronization pattern seamlessly into their message processing routines, supporting systematic verification strategies.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_26\n\nLANGUAGE: VHDL\nCODE:\n```\nprocedure handle_wait_until_idle(\n  signal net : inout event_t;\n  variable msg_type : inout msg_type_t;\n  variable request_msg : inout msg_t) is\n  variable reply_msg : msg_t;\nbegin\n  if msg_type = wait_until_idle_msg then\n    handle_message(msg_type);\n    reply_msg := new_msg;\n    reply(net, request_msg, reply_msg);\n  end if;\nend;\n```\n\n----------------------------------------\n\nTITLE: Logging with Custom Logger in VHDL\nDESCRIPTION: Demonstrates logging with a custom logger object. Custom loggers allow for targeted logging to specific channels.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\nlog(my_logger, \"Hello world\");\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Published Messages - VHDL\nDESCRIPTION: This code snippet shows how to subscribe to messages published by an actor. The `subscribe` procedure registers the `slave_channel` to receive messages published by the `monitor` actor.  This is the classic use case for the publisher/subscriber pattern.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_33\n\nLANGUAGE: vhdl\nCODE:\n```\nsubscribe(slave_channel, monitor);\n```\n\n----------------------------------------\n\nTITLE: Replying to a Read Command via Email-like Messaging - VUnit VHDL\nDESCRIPTION: Shows the continuation of a VHDL BFM process handling a read request message. The 'elsif' branch extracts the address, performs a read via a basic BFM procedure, constructs a reply message with the result, and sends it as a reply to the incoming command message. This pattern supports request-response protocols in modular testbenches. Requires VUnit communication and message-passing libraries.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_8\n\nLANGUAGE: vhdl\nCODE:\n```\nelsif msg_type = brain_read_msg then\n  address := pop_integer(command_msg);\n  read(a, number, of, bus, interface, signals, address, data);\n  reply_msg := new_msg;\n  push_std_ulogic_vector(reply_msg, data);\n  reply(net, command_msg, reply_msg);\nend if;\nend process;\n```\n\n----------------------------------------\n\nTITLE: Applying Test Case Attributes in VUnit VHDL Testbenches - VHDL\nDESCRIPTION: Demonstrates how to annotate VUnit test cases in VHDL with user-defined attributes via comments. The comment '-- vunit: .requirement-117' links the test case to a requirement, supporting traceability. No external dependencies are needed beyond VUnit itself. This pattern expects test case logic to call run(\"Test 1\"); attributes must start with a dot and are discoverable by the framework. Attributes set via the Python API will override those in comments.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/ui.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\nif run(\"Test 1\") then\n    -- vunit: .requirement-117\nend if;\n```\n\n----------------------------------------\n\nTITLE: Executing VUnit Tests via Command Line\nDESCRIPTION: Examples of using VUnit's Python-based test runner to execute VHDL tests with various options including running all tests, specific tests, parallel execution, and GUI debugging.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2015_09_24_short_introduction_to_vunit.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n# Incrementally compile and run all testbenches and test cases found.\n# Report pass/fail result for each.\n$ python run.py\ntest case\n\n# Run all test cases in testbench tb_foo\n$ python run.py *tb_foo*\n\n# Speed up the test by running the test cases in 6 parallel threads.\n# Make use of all the CPU cores!\n$ python run.py -p 6 *tb_foo*\n\n# Launch the tb_foo test case \"Test that reset initializes all outputs\" in the simulator GUI such that it can be debugged\n$ python run.py --gui \"*tb_foo.Test that reset initializes all outputs\"\n```\n\n----------------------------------------\n\nTITLE: Adding OSVVM and UVVM Support to a VUnit Project in Python\nDESCRIPTION: This Python code snippet demonstrates how to set up a VUnit project with both OSVVM and UVVM libraries. The script imports VUnit, creates a VUnit project instance from command-line arguments, and uses the add_osvvm() method to conveniently add OSVVM support as a VUnit add-on. For UVVM, it explicitly adds the UVVM utility library and its VHDL source files via add_library and add_source_files, pointing to the 'uvvm_util' directory. The OSVVM method requires only VUnit to be installed, while the UVVM integration relies on specifying the correct path to the UVVM source files. The main input is the path where UVVM has been cloned or stored. The output is a project ready to run simulations with both OSVVM and UVVM components; users must ensure OSVVM and UVVM sources are available as specified.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2022_09_06_vunit_and_other_frameworks.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nfrom vunit import VUnit\n\nprj = VUnit.from_argv()\n\n# OSVVM is a VUnit add-on and has a convenience method used to compile it into the project\nprj.add_osvvm()\n\n# UVVM must be compiled from source\nprj.add_library(\"uvvm_util\").add_source_files(\"path\" / \"to\" / \"uvvm_util\" / \"src\" / \"*.vhd\")\n```\n\n----------------------------------------\n\nTITLE: Synchronizing actors with wait-until-idle message in VHDL\nDESCRIPTION: Implements a handshake to synchronize actors by sending a `wait_until_idle_msg`. The recipient replies when idle, ensuring processing is paused until readiness. Necessary for coordinated, controlled execution in testbenches, with message handling extended in the actor's message processing loop.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_23\n\nLANGUAGE: VHDL\nCODE:\n```\nrequest_msg := new_msg(wait_until_idle_msg);\nrequest(net, actor_to_synchronize, request_msg, reply_msg);\n```\n\n----------------------------------------\n\nTITLE: VUnit Test Bench Detection via Naming and `runner_cfg`\nDESCRIPTION: This snippet explains how VUnit recognizes HDL modules or entities as test benches by matching their names to the `tb_*` or `*_tb` pattern and the presence of a `runner_cfg` generic or parameter. It highlights the importance of these identifiers for automatic test recognition and running capabilities.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/user_guide.rst#_snippet_3\n\nLANGUAGE: Text\nCODE:\n```\nVUnit will recognize a module or entity as a test bench and run it if it has a `runner_cfg` generic or parameter. A SystemVerilog test bench using the `TEST_SUITE` macro will have a `runner_cfg` parameter created by the macro and thus match the criteria.\n```\n\n----------------------------------------\n\nTITLE: Creating an Actor in VHDL with Optional Naming\nDESCRIPTION: This snippet illustrates how to declare a new actor of type 'actor_t' with an explicit name using the 'new_actor' function. If no name is provided, a unique name will be assigned internally. Actors represent the entities which send and receive messages asynchronously within the communication network.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant my_receiver : actor_t := new_actor(\"my receiver\");\n```\n\n----------------------------------------\n\nTITLE: Synchronous message passing and acknowledgment in VHDL\nDESCRIPTION: Introduces mechanisms to synchronize actors through message acknowledgment, using `acknowledge` procedures for positive or negative responses. Important for coordinating transactions where confirmation is required, replacing implicit assumptions with explicit signaling. Depends on `acknowledge` and `receive_reply` procedures.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_21\n\nLANGUAGE: VHDL\nCODE:\n```\nacknowledge(net, request_msg, positive_ack);\n\nreceive_reply(net, msg, positive_ack);\n```\n\n----------------------------------------\n\nTITLE: Using Generated Codecs in VHDL for Message Encoding\nDESCRIPTION: Demonstrates how to utilize the generated encode function to convert a custom message record into a string for transmission, setting message fields, and outputting the encoded message. Enhances message message readability and transmission safety.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_9\n\nLANGUAGE: VHDL\nCODE:\n```\nmy_pkg.msg_type := start_verifying;\nmy_pkg.sentence := create_random_sentence;\nreport \"This is the encoded message string: \" & encode(my_pkg);\n```\n\n----------------------------------------\n\nTITLE: Creating and Sending Typed Messages with Data in VHDL\nDESCRIPTION: Illustrates sending a typed message by creating it with a specific 'msg_type_t' and pushing typed data fields, then sending via an actor in the communication network. This forms a bus functional model style transaction abstraction.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_10\n\nLANGUAGE: vhdl\nCODE:\n```\nmsg := new_msg(memory_bfm_pkg.write_msg);\\npush(msg, my_unsigned_address);\\npush(msg, my_std_logic_vector_data);\\nsend(net, memory_bfm_pkg.actor, msg);\n```\n\n----------------------------------------\n\nTITLE: Sending a Message Asynchronously Over a Network in VHDL\nDESCRIPTION: The snippet shows sending a constructed message asynchronously to a target actor using the 'send' procedure. It transfers ownership of the message to the receiver and triggers an event on the communication network, notifying connected actors that a new message is available.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\nsend(net, my_receiver, msg);\n```\n\n----------------------------------------\n\nTITLE: VUnit Message Passing Example\nDESCRIPTION: This VHDL code demonstrates the use of VUnit's message passing for communication between two processes. The `main` process sends sentences to an `encrypted_symbol_monitor` process.  It uses `send` and `receive` procedures to simplify communication and synchronization, avoiding the complexities and potential pitfalls of low-level signalling in plain VHDL.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_1\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Core of main process                                     -- Core of encrypted_symbol_monitor process\nfor i in 1 to 10                                            loop\n  sentence := create_random_sentence;                         receive(net, self, message);\n  send(net, encrypted_symbol_monitor, sentence, receipt);     verify_encrypted_sentence(message.payload.all);\n  encrypt(sentence);                                        end loop;\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Converting Messages to Strings with VUnit com Library in VHDL\nDESCRIPTION: Uses the 'to_string' function to generate a readable string representation of a message object (such as a reply message) in the VUnit com library. This is useful for debugging and logging, as it extracts sender, receiver, message IDs, and message type from the message. Requires the VUnit 'com' package and a valid message object; input is the reply message variable and output is the resulting string.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_38\n\nLANGUAGE: vhdl\nCODE:\n```\nto_string(reply_msg)\n```\n\n----------------------------------------\n\nTITLE: Creating a Signed Message in VHDL\nDESCRIPTION: This VHDL snippet demonstrates how to create a message with a specified sender (actor) using VUnit. By providing the `test_sequencer` actor when creating the message, all replies from the receiver (`brain`) will be sent to the sender's inbox. This approach emulates the behavior of email communication where messages are signed.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_13\n\nLANGUAGE: vhdl\nCODE:\n```\nmsg := new_msg(brain_write_msg, test_sequencer);\n```\n\n----------------------------------------\n\nTITLE: Including Integer Array Package in VUnit with VHDL\nDESCRIPTION: This snippet includes the integer_array_pkg VHDL package from VUnit, which provides data types and utilities for working with integer arrays in VHDL simulations. The package facilitates array initialization, manipulation, and querying within VUnit testbenches. Usage requires VUnit's VHDL library and reference to the data_types source; inputs and outputs pertain to integer arrays manipulated in user-defined processes.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/integer_array.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\n.. literalinclude:: ../../vunit/vhdl/data_types/src/integer_array_pkg.vhd\n   :language: vhdl\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Using VHDL path_name for VC Identification (VHDL)\nDESCRIPTION: This snippet demonstrates how to use the standard VHDL `path_name` attribute to assign a unique identifier to verification component (VC) instances by passing it to a generic port. This allows the component to reference its location within the VHDL code hierarchy, often used for logging purposes.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\nentity tb_dut is\nend entity;\n\narchitecture rtl of tb_dut is\n  component vc_x is\n    generic (name : string);\n  end component;\n  component vc_y is\n    generic (name : string);\n  end component;\nbegin\n  vc_x_inst : vc_x\n    generic map (name => vc_x_inst'path_name);\n\n  vc_y_inst : vc_y\n    generic map (name => vc_y_inst'path_name);\nend architecture;\n```\n\n----------------------------------------\n\nTITLE: Encoding Messages Based on Enumeration Values for Readability\nDESCRIPTION: Shows how to generate string encodings based on enumeration values directly by calling functions named after the enum literals, simplifying code readability when encoding messages with fixed types.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_10\n\nLANGUAGE: VHDL\nCODE:\n```\nreport \"This is the encoded message string: \" & start_verifying(create_random_sentence);\n```\n\n----------------------------------------\n\nTITLE: Defining Bus Master Verification Component Interface in VHDL\nDESCRIPTION: This snippet defines the VHDL package interface for a bus master verification component. It outlines signals, types, and procedures necessary to emulate bus master behavior during hardware simulation verification. Dependencies include the standard VHDL libraries and potentially other verification support packages. The package facilitates model-driven test stimulus generation and response checking on a bus interface.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/verification_components/vci.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\nPackage content from ../../vunit/vhdl/verification_components/src/bus_master_pkg.vhd starting at line 7\n```\n\n----------------------------------------\n\nTITLE: Retrieving Identity Name, Path, and Parent (VHDL)\nDESCRIPTION: This VHDL snippet demonstrates using core `id_pkg` functions (`name`, `full_name`, `get_parent`) to retrieve information from an existing identity (`id_t`). It shows how to get the local name of the identity component, its complete hierarchical path as a string, and the `id_t` of its immediate parent in the identity tree.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming vc_x_id is already created\n\nconstant vc_x_name : string := name(vc_x_id);\nconstant vc_x_full_name : string := full_name(vc_x_id);\nconstant tb_dut_id : id_t := get_parent(vc_x_id);\n-- Log outputs would show:\n-- name(vc_x_id) = \"vc_x\"\n-- full_name(vc_x_id) = \":tb_dut:vc_x:\"\n```\n\n----------------------------------------\n\nTITLE: Scoreboard Process - VHDL\nDESCRIPTION: This process describes a scoreboard that subscribes to both published messages and inbound traffic to verify adder functionality. It waits for an `add_msg` on the `master_channel` (inbound traffic to the driver) and a corresponding `sum_msg` on the `slave_channel` (published by the monitor). The `do_model_check` procedure performs the actual verification.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_35\n\nLANGUAGE: vhdl\nCODE:\n```\n scoreboard_process : process is\n    variable master_msg, slave_msg : msg_t;\n    variable msg_type         : msg_type_t;\n\n    procedure do_model_check(indata, outdata : msg_t) is\n      variable op_a, op_b, sum : natural;\n    begin\n      op_a := pop(indata);\n      op_b := pop(indata);\n      sum  := pop(outdata);\n      check_equal(sum, op_a + op_b);\n    end;\n  begin\n    subscribe(master_channel, driver, inbound);\n    subscribe(slave_channel, monitor);\n    loop\n      receive(net, master_channel, master_msg);\n      msg_type := message_type(master_msg);\n\n      handle_wait_until_idle(net, msg_type, master_msg);\n\n      if msg_type = add_msg then\n        receive(net, slave_channel, slave_msg);\n\n        if message_type(slave_msg) = sum_msg then\n          do_model_check(master_msg, slave_msg);\n        end if;\n      end if;\n    end loop;\n  end process;\n```\n\n----------------------------------------\n\nTITLE: Handling Unexpected Message Types in VHDL Actor Process\nDESCRIPTION: An example of adding an 'else' branch in the message handler process that calls 'unexpected_msg_type' to report an error if the received message type is unknown, enabling safer and more debuggable actor implementations.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_12\n\nLANGUAGE: vhdl\nCODE:\n```\nelse\\n  unexpected_msg_type(msg_type);\\nend if;\n```\n\n----------------------------------------\n\nTITLE: Implementing a blocking read procedure in VHDL memory BFM\nDESCRIPTION: Defines a VHDL procedure `read` for synchronous memory read operations using message passing. It handles message creation, sending, reply reception, and data retrieval. Requires dependencies such as `push`, `send`, `receive_reply`, `message_type`, and `pop`. The procedure inputs include network signal, address, and an output data vector, with message management integral to operation.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_15\n\nLANGUAGE: VHDL\nCODE:\n```\nprocedure read(\n  signal net : inout event_t;\n  constant address : in unsigned(7 downto 0);\n  variable data : out std_logic_vector(7 downto 0)) is\n  variable request_msg : msg_t := new_msg(read_msg);\n  variable reply_msg : msg_t;\n  variable msg_type : msg_type_t;\nbegin\n  push(request_msg, address);\n  send(net, actor, request_msg);\n  receive_reply(net, request_msg, reply_msg);\n  msg_type := message_type(reply_msg);\n  data := pop(reply_msg);\nend;\n```\n\n----------------------------------------\n\nTITLE: Creating an Actor for Message Passing - VUnit VHDL\nDESCRIPTION: Shows the declaration of an actor, which represents a communication endpoint (similar to an email address) in message-passing-based VHDL testbenches. Uses VUnit's 'new_actor' factory function to instantiate an actor constant named 'brain'. Prerequisite is the inclusion of VUnit actor/message libraries. This enables subsequent communication using the actor's identity.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant brain : actor_t := new_actor(\"The Brain\");\n```\n\n----------------------------------------\n\nTITLE: Adding compare functions for std_logic_vector and natural types in VUnit\nDESCRIPTION: This snippet adds a check_equal function to compare std_logic_vector objects with natural numbers, enabling unsigned comparisons. It enhances assertion capabilities in testbenches for VHDL types, requiring no external dependencies. It facilitates more flexible and accurate test assertions by allowing comparisons between different VHDL types.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\ndef check_equal(std_logic_vector_value, natural_value):\n    # Convert std_logic_vector to integer for comparison\n    int_value = int(str(std_logic_vector_value), 2)\n    return int_value == natural_value\n\n```\n\n----------------------------------------\n\nTITLE: Copying a Message in VHDL to Preserve Contents Before Popping\nDESCRIPTION: This snippet demonstrates how to create a copy of an existing message to retain its contents before popping. Since popping removes data from the message, copying is necessary if multiple consumers or later access is required.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_8\n\nLANGUAGE: vhdl\nCODE:\n```\nmsg_copy := copy(original_msg);\n```\n\n----------------------------------------\n\nTITLE: Creating Identity from Manual String Path (VHDL)\nDESCRIPTION: This VHDL snippet shows how to create an identity (`id_t`) using `id_pkg.get_id` by providing a custom string representing the desired hierarchical path. This method allows testbench developers to define a logical naming structure independently from the physical VHDL code structure, providing greater flexibility.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_3\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n\nconstant vc_x_id : id_t := get_id(\":tb_dut:vc_x:\");\n```\n\n----------------------------------------\n\nTITLE: Defining Synchronization Verification Component Interface in VHDL\nDESCRIPTION: This VHDL package defines the synchronization verification component interface, which enables coordination and timing-based synchronization among various verification components during simulation. It includes types, signals, and synchronization primitives to manage event ordering and signal alignment. Dependencies include standard VHDL libraries and potentially other verification support packages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/verification_components/vci.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\nPackage content from ../../vunit/vhdl/verification_components/src/sync_pkg.vhd starting at line 7\n```\n\n----------------------------------------\n\nTITLE: Deleting Messages to Free Memory After Processing in VHDL\nDESCRIPTION: Shows explicit deletion of a message using the 'delete' procedure to release allocated memory after processing is complete, preventing memory leaks in communication actor implementations.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_13\n\nLANGUAGE: vhdl\nCODE:\n```\ndelete(msg);\n```\n\n----------------------------------------\n\nTITLE: Forcing All Test Cases to Run in One Simulation using VHDL Attribute\nDESCRIPTION: Demonstrates how to override the default VUnit behavior (which runs each test case in a separate simulation) by adding a VUnit attribute comment. Placing `-- vunit: run_all_in_same_sim` immediately before the `test_suite` loop forces all enabled test cases within that testbench to execute sequentially within a single simulation instance. This can reduce overhead but requires test cases to be independent.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/tb_run_all_in_same_sim.html\n-- This snippet shows how to run all test cases in a single simulation.\n-- Key element:\n-- 1. The attribute comment '-- vunit: run_all_in_same_sim' placed just before the 'while test_suite loop'.\n```\n\n----------------------------------------\n\nTITLE: Non-blocking Read Procedure in VHDL\nDESCRIPTION: This VHDL snippet illustrates the use of a non-blocking read procedure (`brain_read`) and a procedure to retrieve the data (`get`) in VUnit. `brain_read` initiates the read operation and returns a promise (`future`) of the data. `get` retrieves the data, blocking if necessary until the data is available. The snippet showcases how to encapsulate VUnit API interactions for cleaner test sequencer code.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_11\n\nLANGUAGE: vhdl\nCODE:\n```\nbrain_read(net, address, future);\n  get(net, future, data);\n```\n\n----------------------------------------\n\nTITLE: Receiving and Handling Message with `com` - VHDL\nDESCRIPTION: This code snippet demonstrates how to receive and handle incoming messages using the `com` library in VHDL. It receives a message, determines its type, and then extracts the data based on the message type. The extracted data is then used to perform an action, such as wiggling pins on a bus interface.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\n  receive(net, bfm, msg);\n  msg_type := message_type(msg);\n\n  if msg_type = write_msg then\n    address := pop_integer(msg);\n    data := pop_std_ulogic_vector(msg);\n    perform_pin_wiggling_on_bus_interface(address, data);\n  elsif msg_type = read_msg then\n    ...\n```\n\n----------------------------------------\n\nTITLE: Replying to Messages in VHDL Actor Communication\nDESCRIPTION: The snippet expands the message handler to support reply messages. Upon receiving a read request, it constructs and populates a reply message and sends it back to the original sender using 'reply', transferring ownership of the reply message asynchronously.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_14\n\nLANGUAGE: vhdl\nCODE:\n```\nmessage_handler: process is\\n  variable request_msg, reply_msg : msg_t;\\n  variable msg_type : msg_type_t;\\n  variable address : unsigned(7 downto 0);\\n  variable data : std_logic_vector(7 downto 0);\\n  variable memory : integer_vector(0 to 255) := (others => 0);\\nbegin\\n  receive(net, actor, request_msg);\\n  msg_type := message_type(request_msg);\\n  if msg_type = write_msg then\\n    address := pop(request_msg);\\n    data := pop(request_msg);\\n    memory(to_integer(address)) := to_integer(data);\\n  elsif msg_type = read_msg then\\n    address := pop(request_msg);\\n    data := to_std_logic_vector(memory(to_integer(address)), 8);\\n    reply_msg := new_msg(read_reply_msg);\\n    push(reply_msg, data);\\n    reply(net, request_msg, reply_msg);\\n  else\\n    unexpected_msg_type(msg_type);\\n  end if;\\nend process;\n```\n\n----------------------------------------\n\nTITLE: Sending Message via `com` library - VHDL\nDESCRIPTION: This code snippet demonstrates how to send a message using the `com` library in VUnit. It creates a new message of type `write_msg`, pushes an integer (address) and a std_ulogic_vector (data) onto the message, and then sends the message to the specified receiver (bfm) via the network (net).\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\n  msg := new_msg(write_msg);\n  push_integer(msg, address);\n  push_std_ulogic_vector(msg, data);\n  send(net, bfm, msg);\n```\n\n----------------------------------------\n\nTITLE: Creating and Sending a BFM Write Message - VUnit VHDL\nDESCRIPTION: Demonstrates construction and transmission of a message in VHDL VUnit. It creates a new message of a given type, attaches address and data fields using type-specific push functions, then dispatches the message to the target actor (brain) via the communication network (net). Requires VUnit comm/message libraries, valid 'address' and 'data', and prior definition of 'brain' and 'net'. Enables modular and type-safe asynchronous transactions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_4\n\nLANGUAGE: vhdl\nCODE:\n```\nwrite_msg := new_msg(brain_write_msg);\npush_integer(write_msg, address);\npush_std_ulogic_vector(write_msg, data);\nsend(net, brain, write_msg);\n```\n\n----------------------------------------\n\nTITLE: Publishing a Message - VHDL\nDESCRIPTION: This code snippet shows how to publish a message using the `publish` procedure. The `monitor` actor publishes the `msg` containing the sum. Subscribers to the `monitor` will receive this message. It relies on `new_msg` and `push` to create and populate the message.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_32\n\nLANGUAGE: vhdl\nCODE:\n```\n monitor_process : process is\n   variable msg : msg_t;\n begin\n   wait until rising_edge(clk) and (dv_out = '1');\n   msg := new_msg(sum_msg);\n   push(msg, to_integer(sum));\n   publish(net, monitor, msg);\n end process;\n```\n\n----------------------------------------\n\nTITLE: Finding Actor and Sending Message in VHDL\nDESCRIPTION: This snippet shows how a sending VHDL process (`main`) discovers a receiver actor by name using `find` and asynchronously sends messages within a loop using `send`. The `send` call, which includes the target actor reference and message payload, places the message in a queue without consuming physical time, enabling high throughput. This pattern allows the sender to continue execution immediately after sending.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_5\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Local declarations of main process\nconstant encrypted_symbol_monitor : actor_t :=  find(\"encrypted symbol monitor\");\n\n-- Core of main process\nfor i in 1 to 10\n  sentence := create_random_sentence;\n  send(net, encrypted_symbol_monitor, sentence, receipt);\n  encrypt(sentence);\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Linking VUnit Configurations to VHDL Configurations in Python\nDESCRIPTION: Demonstrates the Python run script using VUnit to control which VHDL configuration is used for a test. The 'add_config' method now includes the 'vhdl_configuration' argument, specifying the name of the VHDL configuration declaration (e.g., 'rtl_conf', 'behav_conf') to apply.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\n# Python script using VUnit to select VHDL configurations.\n# Uses add_config() with the 'vhdl_configuration' parameter.\n# Maps VUnit configurations to specific VHDL configuration declarations\n# defined in the VHDL code (e.g., 'rtl_conf', 'behav_conf').\n# Combines with generic settings like 'width'.\n# (Actual code resides in img/vhdl_configuration/create_vunit_configuration_for_selecting_dut_with_a_vhdl_configuration.html)\n```\n\n----------------------------------------\n\nTITLE: Implementing Command Line Flag -f/--files to List Files in Compile Order (Python)\nDESCRIPTION: This snippet shows the addition of a command-line flag '-f' or '--files' to list all source files in their compile order, aiding users in understanding the order of compilation steps. It enhances CLI usability by providing transparency into the build process, requiring parsing of command-line arguments and outputting the file list.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.53.0.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n-f/--files\n```\n\n----------------------------------------\n\nTITLE: Waiting for Message with Timeout - VHDL\nDESCRIPTION: This code snippet demonstrates how to wait for a message on a network for a specific actor, with a timeout. The `wait_for_message` procedure blocks until a message is received or the timeout is reached. The `status` variable will indicate whether a message was received (`ok`) or the timeout occurred.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_27\n\nLANGUAGE: vhdl\nCODE:\n```\nwait_for_message(net, my_actor, status, timeout => 10 ns);\n```\n\n----------------------------------------\n\nTITLE: Registering Message Type with `com` - VHDL\nDESCRIPTION: This code snippet demonstrates how to register a message type with the `com` library to obtain a system unique identifier. The registered message type (`write_msg`) is used to identify the type of message being sent, facilitating correct handling by the receiver.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\n  constant write_msg : msg_type_t := new_msg_type(\"write\");\n```\n\n----------------------------------------\n\nTITLE: Test Sequencer Example - VHDL\nDESCRIPTION: This code snippet shows a test sequencer that sends 10 random `add_msg` transactions to the `driver` with random delays, followed by a `wait_until_idle` transaction. The example showcases sending messages and using `wait_for_time`. This is a simplified test sequencer for demonstration purposes.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_36\n\nLANGUAGE: vhdl\nCODE:\n```\n for i in 1 to 10 loop\n          msg := new_msg(add_msg);\n          push(msg, rnd.RandInt(0, 255));\n          push(msg, rnd.RandInt(0, 255));\n          send(net, driver, msg);\n          wait_for_time(net, driver, rnd.RandTime(0 ns, 10 * clk_period));\n        end loop;\n        wait_until_idle(net, master_channel);\n```\n\n----------------------------------------\n\nTITLE: Traversing Identity Tree with num_children/get_child (VHDL)\nDESCRIPTION: This VHDL snippet demonstrates how to programmatically traverse the identity tree downwards from a given identity using `id_pkg.num_children` and `id_pkg.get_child`. `num_children` returns the count of direct children, and `get_child` retrieves a child's `id_t` based on its index (0 to count-1), enabling iteration.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_11\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming parent_id exists and has children\n\nconstant num_children : natural := num_children(parent_id);\n\nfor i in 0 to num_children - 1 loop\n  constant child_id : id_t := get_child(parent_id, i);\n  -- Process child_id (e.g., print its name or recurse)\nend loop;\n-- Log output would show names of children of parent_id\n```\n\n----------------------------------------\n\nTITLE: Controlling NVC Concurrency via Environment Variable\nDESCRIPTION: Details how VUnit now sets the `NVC_CONCURRENT_JOBS` environment variable based on the `--num-threads` argument passed to VUnit. This allows the NVC simulator to automatically adjust its worker thread count to match the concurrency level specified for VUnit.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_6\n\nLANGUAGE: Shell\nCODE:\n```\n# VUnit sets this automatically based on --num-threads\nexport NVC_CONCURRENT_JOBS=<number_of_threads>\n```\n\n----------------------------------------\n\nTITLE: Configuring VUnit testbench with multiple parameters in Python\nDESCRIPTION: This snippet demonstrates creating multiple VUnit test configurations within a loop, varying parameters like plot title, data size, and activation of bugs. Each configuration is added with specific generics and pre/post-check functions, facilitating automated testing with different scenarios. Dependencies include VUnit's API and custom functions like make_pre_config.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nsize_of_data_set = 10\nnum_of_data_sets = 10\n\nfor name, activate_bug in [(\"Passing test\", False), (\"Failing test\", True)]:\n    tb_octave.add_config(name=name,\n                         generics=dict(size_of_data_set=size_of_data_set,\n                                       num_of_data_sets=num_of_data_sets,\n                                       activate_bug=activate_bug),\n                         pre_config=make_pre_config(plot_title=name, num_of_data_sets=num_of_data_sets),\n                         post_check=post_check)\n```\n\n----------------------------------------\n\nTITLE: Creating a Distributed VUnit Testbench in VHDL\nDESCRIPTION: Illustrates a testbench with control logic distributed across multiple processes. It uses the `running_test_case` function to determine the currently active test case name in different processes without redundant `run` calls. The example also showcases VUnit utilities like logging (`info`), event synchronization (`start_stimuli` event, `notify`, `is_active`), and phase locking (`get_entry_key`, `lock`, `unlock`) to manage inter-process dependencies and prevent premature simulation termination.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/tb_running_test_case.html\n-- This snippet shows a more complex testbench with multiple interacting processes.\n-- Key elements:\n-- 1. Use of 'running_test_case' function to query the active test.\n-- 2. VUnit logging ('info').\n-- 3. VUnit event synchronization ('notify', 'is_active' on an event signal).\n-- 4. VUnit phase synchronization ('get_entry_key', 'lock', 'unlock') to coordinate process completion.\n```\n\n----------------------------------------\n\nTITLE: Simplified request procedure for message exchange in VHDL\nDESCRIPTION: Provides an alternative method to perform synchronous message request and reply in VHDL, encapsulating send and receive_reply calls into a single `request` procedure for brevity and clarity in communication sequences. Depends on `send` and `receive_reply` functionalities, streamlining interaction patterns.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_16\n\nLANGUAGE: VHDL\nCODE:\n```\nrequest(net, actor, request_msg, reply_msg);\n```\n\n----------------------------------------\n\nTITLE: Activating and Logging vunit_error Events in VUnit VHDL\nDESCRIPTION: Demonstrates using the vunit_error event to generalize error logging beyond timeouts, allowing both internal and testbench-detected errors to trigger log entries. Also shows how wait statements can be made reactive to this event to improve error tracing. Requires VUnit's event framework; parameters include vunit_error and potential event combinations. Outputs logs when errors are detected and events occur.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_9\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Using vunit_error for wait statements\nwait until vunit_error'event and log_active(vunit_error);\n\n```\n\n----------------------------------------\n\nTITLE: Basic Logging with Default Logger in VHDL\nDESCRIPTION: Shows how to make a log entry using the default logger. This is the simplest way to log messages in VUnit.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\nlog(\"Hello world\");\n```\n\n----------------------------------------\n\nTITLE: Run all tests using VUnit CLI - Python\nDESCRIPTION: This command runs all tests matching the pattern 'lib.tb_example*' using the -v flag for verbose output. The tests are executed sequentially and the output shows the progress and results of each test, including pass/fail status and execution time. The final summary shows the total number of passed and failed tests.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\n> python run.py -v lib.tb_example*\nRunning test: lib.tb_example.all\nRunning test: lib.tb_example_many.test_pass\nRunning test: lib.tb_example_many.test_fail\nRunning 3 tests\n\nrunning lib.tb_example.all\nHello World!\npass( P=1 S=0 F=0 T=3) lib.tb_example.all (0.1 seconds)\n\nrunning lib.tb_example.test_pass\nThis will pass\npass (P=2 S=0 F=0 T=3) lib.tb_example_many.test_pass (0.1 seconds)\n\nrunning lib.tb_example.test_fail\nError: It fails\nfail (P=2 S=0 F=1 T=3) lib.tb_example_many.test_fail (0.1 seconds)\n\n==== Summary =========================================\npass lib.tb_example.all            (0.1 seconds)\npass lib.tb_example_many.test_pass (0.1 seconds)\nfail lib.tb_example_many.test_fail (0.1 seconds)\n======================================================\npass 2 of 3\nfail 1 of 3\n======================================================\nTotal time was 0.3 seconds\nElapsed time was 0.3 seconds\n======================================================\nSome failed!\n```\n\n----------------------------------------\n\nTITLE: Test Runner Process in VHDL\nDESCRIPTION: This snippet represents the `test_runner` process, responsible for generating stimuli input for the device under test (DUT). It involves pushing data to a queue and notifying another process (`dut_checker`) via the `new_data_set` event. The watchdog is also mentioned. \nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\n  .. raw:: html\n      :file: img/vunit_events/test_runner_process.html\n```\n\n----------------------------------------\n\nTITLE: DUT Checker Process in VHDL\nDESCRIPTION: This snippet shows the `dut_checker` process. The process waits for the `new_data_set` event.  When an event is received, it reads sample data from the queue and verifies the DUT output against the expected values. It operates in parallel with the `test_runner` process.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\n  .. raw:: html\n      :file: img/vunit_events/dut_checker.html\n```\n\n----------------------------------------\n\nTITLE: Creating and Populating a New Message in VHDL\nDESCRIPTION: This snippet explains how to create an empty message variable of type 'msg_t' by calling 'new_msg' and then add data to it using 'push' functions. Various data types including strings and integers can be pushed into the message sequentially, preparing it for transmission.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_5\n\nLANGUAGE: vhdl\nCODE:\n```\nmsg := new_msg;\\npush_string(msg, \"10101010\");\\npush(msg, my_integer);\n```\n\n----------------------------------------\n\nTITLE: Enabling setting VHDL standard for external libraries in VUnit\nDESCRIPTION: This code allows users to specify the VHDL standard for external libraries within VUnit, ensuring compatibility and standard compliance during simulation. Dependencies include configuration options in the test environment. It affects how libraries are configured prior to simulation, supporting standards like VHDL-93 or VHDL-2008.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\ndef set_vhdl_standard_on_library(library, vhdl_standard):\n    # Set the VHDL standard for a given external library\n    library.vhdl_standard = vhdl_standard\n\n```\n\n----------------------------------------\n\nTITLE: Example JSON export file - JSON\nDESCRIPTION: This JSON snippet shows the structure of the JSON file generated by the ``--export-json`` option. It contains information about the project files (file name and library name) and the tests (attributes, location in source code, and name). The file names are absolute.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_6\n\nLANGUAGE: json\nCODE:\n```\n{\n    \"export_format_version\": {\n        \"major\": 1,\n        \"minor\": 0,\n        \"patch\": 0\n    },\n    \"files\": [\n        {\n            \"library_name\": \"lib\",\n            \"file_name\": \"tb_example_many.vhd\"\n        },\n        {\n            \"library_name\": \"lib\",\n            \"file_name\": \"tb_example.vhd\"\n        }\n    ],\n    \"tests\": [\n        {\n            \"attributes\": {},\n            \"location\": {\n                \"file_name\": \"tb_example_many.vhd\",\n                \"length\": 9,\n                \"offset\": 556\n            },\n            \"name\": \"lib.tb_example_many.test_pass\"\n        },\n        {\n            \"attributes\": {},\n            \"location\": {\n                \"file_name\": \"tb_example_many.vhd\",\n                \"length\": 9,\n                \"offset\": 624\n            },\n            \"name\": \"lib.tb_example_many.test_fail\"\n        },\n        {\n            \"attributes\": {\n                \".attr\": null\n            },\n            \"location\": {\n                \"file_name\": \"tb_example.vhd\",\n                \"length\": 18,\n```\n\n----------------------------------------\n\nTITLE: Defining and Using Message Types in VHDL\nDESCRIPTION: Shows creating a unique message type identifier using 'new_msg_type' with a string description. This helps differentiate messages semantically even if descriptions are reused, enabling safe handling of multiple message types in the receiver.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_9\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant write_msg : msg_type_t := new_msg_type(\"write\");\n```\n\n----------------------------------------\n\nTITLE: Decoding String to Integer Vector - VHDL\nDESCRIPTION: This VHDL code defines an impure function `decode` that converts a comma-separated string (representing an integer vector) into an `integer_vector`.  It uses the `split` function (from VUnit's `string_ops` package) to separate the string into individual elements, then converts each element to an integer using `integer'value`. This is used inside the testbench to create the `image_resolution` constant.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\nimpure function decode(encoded_integer_vector : string) return integer_vector is\n  variable parts : lines_t := split(encoded_integer_vector, \", \");\n  variable return_value : integer_vector(parts'range);\nbegin\n  for i in parts'range loop\n    return_value(i) := integer'value(parts(i).all);\n  end loop;\n\n  return return_value;\nend;\n\nconstant image_resolution : integer_vector := decode(encoded_image_resolution);\n```\n\n----------------------------------------\n\nTITLE: Logging Active Wait Statements using log_active in VHDL\nDESCRIPTION: Demonstrates the use of VUnit's log_active function to log when a wait statement is blocked due to the runner_timeout event. The log_active function creates a log entry at the wait location without unblocking it, aiding in pinpointing deadlocks and blocking statements. Requires VUnit's logging library; key parameters are the event (such as runner_timeout) and the wait location, with output in the simulation log for later analysis.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Example VHDL code illustrating log_active usage in a wait statement\nwait until runner_timeout'event and log_active(runner_timeout);\n\n```\n\n----------------------------------------\n\nTITLE: Cloning VUnit Repository with Submodules - Console\nDESCRIPTION: This snippet provides the Git command for cloning the VUnit repository including all nested submodules using the '--recursive' flag. It is used when creating a fresh local clone of VUnit to ensure the OSVVM subdirectory is populated. The only dependency is Git, and the command outputs a fully initialized project directory with all submodules checked out to their correct commits.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.67.0.rst#_snippet_1\n\nLANGUAGE: console\nCODE:\n```\ngit clone --recursive https://github.com/VUnit/vunit.git\n```\n\n----------------------------------------\n\nTITLE: Encoding Integer Vector to String - Python\nDESCRIPTION: This Python code snippet encodes an integer vector (list) into a comma-separated string representation. It uses the `map` function to convert each integer element to a string, then joins these strings using a comma and a space as a separator.  The resulting string can then be passed to a VHDL testbench.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimage_resolution = [640, 480]\nencoded_image_resolution = \", \".join(map(str, image_resolution))\n```\n\n----------------------------------------\n\nTITLE: Adding Log Location Information in VHDL-2019\nDESCRIPTION: Shows the log output with file and line location information using VHDL-2019 features.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_21\n\nLANGUAGE: VHDL\nCODE:\n```\n0 fs - INFO - root - hello world (./tb_example.vhd:15)\n```\n\n----------------------------------------\n\nTITLE: Signing messages with actor identity in VHDL message passing\nDESCRIPTION: Shows how to create signed messages in VHDL by specifying the sender actor during message creation, enabling message origin tracking especially useful for publisher/subscriber models. Requires the `new_msg` function with `sender` parameter, supporting communication protocols that need message signing.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_18\n\nLANGUAGE: VHDL\nCODE:\n```\nmsg := new_msg(sender => sending_actor);\n```\n\n----------------------------------------\n\nTITLE: Decoding String to Record - VHDL\nDESCRIPTION: This VHDL code defines an impure function `decode` which parses a comma-separated string (representing a record) into a `tb_cfg_t` record. It uses the `get` function (likely a VUnit utility) to extract values associated with specific keys (e.g., \"image_width\") from the input string. It then converts the retrieved strings to the appropriate data types using type'value and assigns them to the record's fields.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\nimpure function decode(encoded_tb_cfg : string) return tb_cfg_t is\nbegin\n  return (image_width => positive'value(get(encoded_tb_cfg, \"image_width\")),\n          image_height => positive'value(get(encoded_tb_cfg, \"image_height\")),\n          dump_debug_data => boolean'value(get(encoded_tb_cfg, \"dump_debug_data\")));\nend function decode;\n```\n\n----------------------------------------\n\nTITLE: Registering a Unique Message Type - VUnit VHDL\nDESCRIPTION: Shows the creation of a unique message type identifier using 'new_msg_type', here for write transactions. This mechanism avoids ambiguity in publisher/subscriber scenarios involving multiple BFMs. String-based message type names are mapped to strongly-typed identifiers. Prerequisites include the VUnit messaging framework.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_5\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant brain_write_msg : msg_type_t := new_msg_type(\"write\");\n```\n\n----------------------------------------\n\nTITLE: Initializing Actor and Receiving Message in VHDL\nDESCRIPTION: This snippet demonstrates initializing a VHDL process as an actor within the VUnit `com` framework using `create` and receiving messages targeted at this actor using the blocking `receive` procedure. The received message's payload is extracted and passed to a verification routine, illustrating a passive message consumer pattern. This setup relies on the `net` signal and a unique actor name for identification.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_4\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Local declarations of encrypted_symbol_monitor process\nconstant self : actor_t := create(\"encrypted symbol monitor\");\n\n-- Core of encrypted_symbol_monitor process\nreceive(net, self, message);\nverify_encrypted_message(message.payload.all);\n```\n\n----------------------------------------\n\nTITLE: Handling Wait Until Idle - VHDL\nDESCRIPTION: This code demonstrates how to handle a `wait_for_idle` transaction, ensuring that the transaction is intended for the `master_channel` before processing it.  This is important when subscribing to inbound traffic to avoid unintended side effects from other actors.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_37\n\nLANGUAGE: vhdl\nCODE:\n```\n if receiver(master_msg) = master_channel then\n        handle_wait_until_idle(net, msg_type, master_msg);\n      end if;\n```\n\n----------------------------------------\n\nTITLE: Implementing Pre and Post Simulation Hooks for Test Configuration - Python\nDESCRIPTION: Shows an implementation of pre_config and post_check hooks in a VUnit testbench using a Python class. The DataChecker class provides input data to the testbench before simulation and validates output data after simulation. pre_config receives the output directory path and must return True; post_check receives the same and compares actual output to expected results, returning True if validation passes. The pattern enables dynamic data setup and validation per test or per configuration, with hooks assigned using set_pre_config and set_post_check. It requires appropriate utility functions (e.g., write_data, compute_expected, read_data, check_equal) and VUnit instantiated tests. Supports creating multiple configurations programmatically via add_config, parameterized by seed.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/ui.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\nclass DataChecker:\n    \"\"\"\n    Provides input data to test bench and checks its output data\n    \"\"\"\n    def __init__(self, data):\n        self.input_data = data\n\n    def pre_config(self, output_path):\n        write_data(self.input_data, join(output_path, \"input.csv\"))\n        return True\n\n    def post_check(self, output_path):\n        expected = compute_expected(self.input_data)\n        got = read_data(join(output_path, \"output.csv\"))\n        return check_equal(got, expected)\n\n# Just change the original test\nchecker = DataChecker(data=create_random_data(seed=11))\nmy_test.set_pre_config(checker.pre_config)\nmy_test.set_post_check(checker.post_check)\n\n# .. or create many configurations of the test\nfor seed in range(10, 20):\n    checker = DataChecker(data=create_random_data(seed))\n    my_test.add_config(name=\"seed%i\" % seed,\n                       pre_config=checker.pre_config,\n                       post_check=checker.post_check)\n```\n\n----------------------------------------\n\nTITLE: VHDL Testbench Entity with Generic - VHDL\nDESCRIPTION: This VHDL code defines the entity of a testbench (`tb_composite_generics`) that accepts an `encoded_image_resolution` string generic. It also includes a `runner_cfg` string generic. The `encoded_image_resolution` generic receives the string representation of the image resolution from the Python script.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\nlibrary vunit_lib;\ncontext vunit_lib.vunit_context;\n\nentity tb_composite_generics is\n  generic (\n    encoded_image_resolution : string;\n    runner_cfg : string);\nend tb_composite_generics;\n```\n\n----------------------------------------\n\nTITLE: Managing VHDL Configurations for DUT and Test Runner in Python\nDESCRIPTION: Demonstrates the Python run script using VUnit to manage the selection of combined VHDL configurations (which specify both DUT and test runner architectures). It iterates through desired test scenarios and DUT types, mapping each to the corresponding VHDL configuration name via 'add_config'.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_9\n\nLANGUAGE: Python\nCODE:\n```\n# Python script using VUnit to select combined VHDL configurations.\n# Iterates through test names (e.g., 'test_reset') and DUT architectures ('rtl', 'behav').\n# Constructs the VHDL configuration name (e.g., 'test_reset_rtl').\n# Uses add_config() with the 'vhdl_configuration' parameter set to the combined name.\n# Provides a way to programmatically manage the combinatorial explosion\n# of VHDL configurations needed for this approach.\n# (Actual code resides in img/vhdl_configuration/create_vunit_configuration_for_selecting_dut_and_runner_with_a_vhdl_configuration.html)\n```\n\n----------------------------------------\n\nTITLE: Generating Identity Tree from Specific Root (VHDL)\nDESCRIPTION: This VHDL snippet shows how to use the `id_pkg.get_tree` function, passing an `id_t` as an argument. This generates a formatted string representation of the identity tree, starting from the specified identity and including all its descendants. It's useful for visualizing subtrees.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming vc_x_id is created and has children/descendants\n\nconstant tree_string : string := get_tree(vc_x_id);\n-- Log output would show a tree rooted at vc_x_id\n-- :vc_x:\n--   :child1:\n--   :child2:\n```\n\n----------------------------------------\n\nTITLE: Blocking Read Procedure in VHDL\nDESCRIPTION: This VHDL snippet presents a blocking read procedure (`brain_read`) in VHDL using VUnit. Unlike the non-blocking version, this procedure combines the initiation of the read and retrieval of the data into a single blocking call.  The last parameter's type differentiates this procedure from the non-blocking version.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_12\n\nLANGUAGE: vhdl\nCODE:\n```\nbrain_read(net, address, data);\n```\n\n----------------------------------------\n\nTITLE: Continuing Compilation After Failure (CLI)\nDESCRIPTION: Describes the behavior change when using the `--keep-compiling` command-line flag. If set to True, VUnit will now continue the process even after a compilation failure occurs.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\npython run.py --keep-compiling\n```\n\n----------------------------------------\n\nTITLE: Run a specific test using VUnit CLI - Python\nDESCRIPTION: This command executes a specific test case, 'lib.tb_example.all', using the -v flag for verbose output. The output shows the test being executed, its result (pass/fail), and the execution time. A summary is provided at the end.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\n> python run.py -v lib.tb_example.all\nRunning test: lib.tb_example.all\nRunning 1 tests\n\nStarting lib.tb_example.all\nHello world!\npass (P=1 S=0 F=0 T=1) lib.tb_example.all (0.1 seconds)\n\n==== Summary ==========================\npass lib.tb_example.all (0.9 seconds)\n=======================================\npass 1 of 1\n=======================================\nTotal time was 0.9 seconds\nElapsed time was 1.2 seconds\n=======================================\nAll passed!\n```\n\n----------------------------------------\n\nTITLE: Annotating SystemVerilog Test Cases with VUnit Attributes - SystemVerilog\nDESCRIPTION: Shows how to attach a requirement attribute to a SystemVerilog test case using comments in the VUnit test suite. The '// vunit: .requirement-117' comment binds the test to a requirement. The example assumes the VUnit SystemVerilog macros (`TEST_SUITE`, `TEST_CASE`) are in use. All user-defined attributes must begin with a dot for compatibility with the VUnit attribute schema.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/ui.rst#_snippet_1\n\nLANGUAGE: verilog\nCODE:\n```\n`TEST_SUITE begin\n    `TEST_CASE(\"Test 1\") begin\n        // vunit: .requirement-117\n     end\nend\n```\n\n----------------------------------------\n\nTITLE: Defining Test Cases in a VUnit Testbench using VHDL\nDESCRIPTION: Shows how to structure a testbench using a test suite loop (`while test_suite loop ... end loop;`). Individual test cases are defined using `if run(\"Test Case Name\") then ... end if;`. The `run` function, requiring a string literal for the name, returns true once for each enabled test case, executing the code within the branch. Comments indicate standard locations for test suite/case setup and cleanup logic.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/test_runner_with_test_cases.html\n-- This snippet demonstrates organizing tests into named test cases within a test suite.\n-- Key elements:\n-- 1. The 'while test_suite loop ... end loop;' structure.\n-- 2. 'if run(\"Test Case Name\") then ... end if;' blocks for individual tests.\n-- 3. Placeholder comments for setup/cleanup phases (pre/post_test_suite, pre/post_test_case).\n```\n\n----------------------------------------\n\nTITLE: Generating VHDL Codec Functions Using Python for Custom Types\nDESCRIPTION: Shows how to invoke a Python module to automatically generate encode and decode functions for types in 'msg_types_pkg', placing them into 'msg_codecs_pkg'. This enables seamless conversion between data types and strings for message passing in testbenches.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_8\n\nLANGUAGE: Python\nCODE:\n```\npkg = tb_lib.package('msg_types_pkg')\npkg.generate_codecs('msg_codecs_pkg')\n```\n\n----------------------------------------\n\nTITLE: Structuring a VUnit Testbench with Lower-Level Control (Top-Level) in VHDL\nDESCRIPTION: Shows the top-level entity of a testbench where the main test control logic (the `test_runner` process) resides in a lower-level component. The top-level entity includes the mandatory `runner_cfg` generic but passes it down to the lower-level entity using a *different* generic name (e.g., `ctrl_cfg`) during instantiation. This prevents the lower-level entity from being incorrectly identified as a separate top-level testbench by the Python runner.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_3\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/tb_with_lower_level_control.html\n-- This snippet shows the top-level entity when test control is delegated.\n-- Key elements:\n-- 1. Standard 'runner_cfg' generic declaration.\n-- 2. Instantiation of a lower-level control entity.\n-- 3. Passing 'runner_cfg' to the lower level via a differently named generic (e.g., 'ctrl_cfg => runner_cfg').\n```\n\n----------------------------------------\n\nTITLE: Setting Log Format in VHDL\nDESCRIPTION: Example of changing the logging format between raw, level, and csv options.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\nset_format(display_handler, raw);\ninfo(\"hello world\");\nset_format(display_handler, level);\ninfo(\"hello world\");\nset_format(display_handler, csv);\ninfo(\"hello world\");\n```\n\n----------------------------------------\n\nTITLE: VHDL Testbench Skeleton for Hardware Verification\nDESCRIPTION: This VHDL code provides a basic testbench structure for simulating and verifying a hardware module. It declares entity and architecture, including clock generation, reset logic, and a process to stimulate the Device Under Test (DUT). Dependencies include the hardware module being tested and simulation environment setup.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.62.1.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary ieee;\nuse ieee.std_logic_1164.all;\n\n_entity testbench is\nend entity;\n\n_architecture behavior of testbench is\n    signal clk : std_logic := '0';\n    signal reset : std_logic := '1';\n\n-- Instantiate DUT\n    component my_device\n        port (\n            clk : in std_logic;\n            reset : in std_logic\n        );\n    end component;\n\n--- Clock generation process\n    clock_process : process\n    begin\n        while true loop\n            clk <= '0';\n            wait for 10 ns;\n            clk <= '1';\n            wait for 10 ns;\n        end loop;\n    end process;\n\n-- Stimulus process\n    stimulus : process\n    begin\n        wait for 50 ns;\n        reset <= '0';\n        wait; -- wait indefinitely\n    end process;\n\n-- DUT instantiation\n    dut: my_device\n        port map (\n            clk => clk,\n            reset => reset\n        );\nend architecture behavior;\n\n```\n\n----------------------------------------\n\nTITLE: Handling multiple actors in VHDL message reception\nDESCRIPTION: Allows a process to receive messages from multiple actors by passing an array of actors to `receive`, which retrieves the oldest message from the first non-empty inbox. Facilitates multi-actor message handling in complex communication scenarios. Requires `actor_vec_t` type and `receive` procedure supporting arrays.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_19\n\nLANGUAGE: VHDL\nCODE:\n```\nreceive(net, actor_vec_t'(channel_1, channel_2), msg);\n```\n\n----------------------------------------\n\nTITLE: Standard Log Levels in VHDL\nDESCRIPTION: Lists the standard log levels available in VUnit with their associated procedure calls.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_4\n\nLANGUAGE: VHDL\nCODE:\n```\ndebug(\"a debug message\"); -- For detailed debug information\ntrace(\"a trace message\"); -- For tracing code execution\ninfo(\"an info message\");  -- For informative messages\nwarning(\"a warning message\"); -- For warning messages\nerror(\"an error message\"); -- For error messages\nfailure(\"a failure message\"); -- For critical failures\n```\n\n----------------------------------------\n\nTITLE: Sending Control Messages using Record-Based Encodings and Publishing\nDESCRIPTION: Shows sending a control message with shift and delay parameters using a generated record encoding function, and distributing it via publish to all subscribers. This enhances message clarity and coordination among actors.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_12\n\nLANGUAGE: VHDL\nCODE:\n```\npublish(net, self, set_shift_after_delay(shift, delay), status);\n```\n\n----------------------------------------\n\nTITLE: Encoding Record to String - Python\nDESCRIPTION: This Python code snippet encodes a dictionary (representing a record) into a comma-separated string where each element is a key:value pair. It iterates through the dictionary keys, constructs a \"key:value\" string for each entry, and joins them using commas and spaces. The output string is used to configure generics in a VHDL testbench.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_4\n\nLANGUAGE: python\nCODE:\n```\ntb_cfg = dict(image_width=640, image_height=480, dump_debug_data=False)\nencoded_tb_cfg = \", \".join([\"%s:%s\" % (key, str(tb_cfg[key])) for key in tb_cfg])\n```\n\n----------------------------------------\n\nTITLE: Applying VHDL Configurations to Specific Test Cases in Python\nDESCRIPTION: Illustrates how to apply a VHDL configuration to a specific test case within a VUnit testbench, rather than to the entire testbench entity. This allows finer granularity, for example, running only the RTL architecture for a specific test case.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\n# Python script demonstrating applying VHDL configurations at the test case level.\n# Accesses a specific test case (e.g., tb_flip_flop.test_width_32)\n# and calls add_config() on it, specifying the 'vhdl_configuration'\n# (e.g., 'rtl_conf') and any generics ('width': 32).\n# (Actual code resides in img/vhdl_configuration/vhdl_configuration_on_a_test_case.html)\n```\n\n----------------------------------------\n\nTITLE: Verification component with customizable logger\nDESCRIPTION: Defines a verification component entity with a logger generic parameter, allowing React components to log independently based on provided loggers, supporting modular and hierarchical logging.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_4\n\nLANGUAGE: VHDL\nCODE:\n```\nentity verification_component is\n  generic (logger : logger_t := verification_component_logger);\nend entity;\n```\n\n----------------------------------------\n\nTITLE: Hierarchical logger creation in VHDL using get_logger\nDESCRIPTION: Demonstrates how to create hierarchical loggers in a testbench architecture by using path names. Highlights inheritance and parent-child relationships, with basic log level control.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_3\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant main_logger : logger_t := get_logger(main'path_name);\n```\n\n----------------------------------------\n\nTITLE: Enabling Location Preprocessor in VUnit Python Script\nDESCRIPTION: Shows how to enable the location preprocessor in the VUnit run.py script for pre-VHDL-2019 support.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_23\n\nLANGUAGE: Python\nCODE:\n```\nfrom pathlib import Path\nfrom vunit import VUnit\n\nvu = VUnit.from_argv()\nvu.enable_location_preprocessing()\nvu.add_library(\"lib\").add_source_files(Path(\"src\") / \"*.vhd\")\nvu.main()\n```\n\n----------------------------------------\n\nTITLE: Creating VUnit Events in VHDL\nDESCRIPTION: This snippet illustrates the creation of a VUnit event as a signal declaration within a VHDL design. This event is a user-defined event that can be used for synchronization between processes.  It is used for signaling that a data set is available.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\n  .. raw:: html\n      :file: img/vunit_events/event_creation.html\n```\n\n----------------------------------------\n\nTITLE: Defining a Specific Test Architecture within a VHDL Test Runner Entity\nDESCRIPTION: Shows an example architecture (e.g., 'test_reset') for the 'test_runner' entity. In the OSVVM-style approach promoted here, each such architecture corresponds to a single specific test. When using VHDL configurations to select these, each architecture can only contain one test (no 'run' calls).\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL architecture for the 'test_runner' entity, representing a single test.\n-- architecture test_reset of test_runner is\n-- begin\n--   test_runner : process\n--     variable runner : runner_t;\n--   begin\n--     -- Test logic for the 'reset' test case\n--     -- Must contain only one conceptual test when selected by configuration.\n--     test_runner_setup(runner, nested_runner_cfg);\n--     -- ... specific test sequence ...\n--     test_runner_cleanup(runner);\n--     wait;\n--   end process test_runner;\n-- end architecture test_reset;\n-- (Actual code resides in img/vhdl_configuration/test_reset_architecture_of_test_runner.html)\n```\n\n----------------------------------------\n\nTITLE: Initiating Advanced BFM Procedures - VUnit VHDL\nDESCRIPTION: These procedure calls illustrate the advanced BFM approach in VHDL, where 'init', 'put', and 'write' interact with a net-based communication system instead of directly controlling bus signals. The net parameter refers to a messaging/network object. This interface supports concurrent transaction initiation, with blocking and non-blocking behavior determined by procedure type. Requires VUnit's communication library and definitions for 'net' and 'actor' constructs.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_1\n\nLANGUAGE: vhdl\nCODE:\n```\ninit(net, configuration); -- I will explain net later\nput(net, value);\nwrite(net, address, data);\n```\n\n----------------------------------------\n\nTITLE: Utilizing All Logical CPUs (CLI)\nDESCRIPTION: Explains how to configure VUnit to use all available logical CPUs for parallel processing. This is achieved by passing `-p0` or `--num-threads=0` as command-line arguments. The number of CPUs is determined using Python's `multiprocessing.cpu_count`.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_7\n\nLANGUAGE: Shell\nCODE:\n```\npython run.py -p0\n```\n\nLANGUAGE: Shell\nCODE:\n```\npython run.py --num-threads=0\n```\n\n----------------------------------------\n\nTITLE: Custom Logger Usage in VUnit 3.0 with VHDL\nDESCRIPTION: Shows how to log messages using a custom logger in VUnit 3.0. The example uses a scoreboard_logger to differentiate logging in different parts of the system, demonstrating the updated logger implementation that removes previous restrictions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_10_31_vunit_3_0_color_logging.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\ninfo(scoreboard_logger, \"Some message\");\n```\n\n----------------------------------------\n\nTITLE: Using Path Offset for Convenience Procedures in VHDL\nDESCRIPTION: Shows how to use path_offset to report the location of the caller rather than the location of the log call in a convenience procedure.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_24\n\nLANGUAGE: VHDL\nCODE:\n```\nprocedure my_convenience_procedure(msg : string) is\nbegin\n  log(info, msg, path_offset => 1);\nend procedure;\n\n-- Some other file\nmy_convenience_procedure(\"hello world\"); -- Location of this call will be in the log\n```\n\n----------------------------------------\n\nTITLE: Implementing non-blocking memory read and concurrent transactions in VHDL\nDESCRIPTION: Demonstrates non-blocking, asynchronous memory read operations in VHDL by initiating `non_blocking_read` and other non-blocking transactions using futures, allowing concurrent execution. Later retrieval of data is performed via `get`, enabling parallelism and efficient testbench operation. Depends on `non_blocking_read`, `non_blocking_transaction`, and `get` procedures.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_17\n\nLANGUAGE: VHDL\nCODE:\n```\nmemory_bfm_pkg.non_blocking_read(net, address => x\"80\", future => future1);\nsome_other_bfm_pkg.non_blocking_transaction(net, some_input_parameters, future2);\n\n<Do other things>\n\nmemory_bfm_pkg.get(net, future1, data);\nsome_other_bfm_pkg.get(net, future2, requested_information);\n```\n\n----------------------------------------\n\nTITLE: Asynchronous message handling with specialized procedure in VHDL\nDESCRIPTION: Defines a reusable VHDL procedure `handle_wait_until_idle` for processing `wait_until_idle_msg` messages, replying appropriately. It calls a lower-level message handler `handle_message` to update message type, and uses `reply` to respond. Ensures consistent and modular message handling for synchronization actions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_24\n\nLANGUAGE: VHDL\nCODE:\n```\nprocedure handle_wait_until_idle(\n  signal net : inout event_t;\n  variable msg_type : inout msg_type_t;\n  variable request_msg : inout msg_t) is\n  variable reply_msg : msg_t;\nbegin\n  if msg_type = wait_until_idle_msg then\n    handle_message(msg_type);\n    reply_msg := new_msg;\n    reply(net, request_msg, reply_msg);\n  end if;\nend;\n```\n\n----------------------------------------\n\nTITLE: Configuring VUnit Action with Custom Run Script in GitHub Actions YAML\nDESCRIPTION: This snippet extends the VUnit Action invocation by specifying a custom path to the VUnit run script with the \"run_file\" input parameter. This is necessary when the \"run.py\" script is not located in the repository root, allowing the user to direct the VUnit Action to the correct testbench execution script. It requires the same GitHub Actions setup with the VUnit Action container and standard checkout steps.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/script.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- uses: VUnit/vunit_action@v0.1.0\n  with:\n    run_file: path/to/vunit_run_script.py\n```\n\n----------------------------------------\n\nTITLE: Configuring Simulation Stop on Log Levels in VHDL\nDESCRIPTION: Shows how to configure when simulation should stop based on log levels, including setting stop counts.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_14\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Default error level stop counter in root logger is 1\n-- An uncaught error level log will stop simulation\nerror(\"This will stop simulation\");\n\n-- Setting stop counter to 2 for error level in root logger\nset_stop_count(error, 2);\n\n-- These logs will not stop simulation because they're disabled\ndisable_stop(info);\ninfo(\"This won't stop simulation\");\n\n-- Setting stop count to 0 disables stop\nset_stop_count(my_logger, error, 0);\nerror(my_logger, \"This won't stop simulation\");\n```\n\n----------------------------------------\n\nTITLE: VHDL Package for Custom Log Handling in VUnit\nDESCRIPTION: Provides the interface for custom logging by defining 'common_log_pkg'. The package includes a 'write_to_log' procedure that can be overridden for integrating third-party log frameworks. It serves as a flexible way to handle log output in testbenches.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_27\n\nLANGUAGE: vhdl\nCODE:\n```\nThe procedure interface is designed to be generic and suitable for third party logging frameworks as well. If provided,\nthird party log messages can also be redirected to VUnit logging:\n\n.. literalinclude:: ../../vunit/vhdl/logging/src/common_log_pkg.vhd\n   :language: vhdl\n   :lines: 7-69\n```\n\n----------------------------------------\n\nTITLE: Using New Active-HDL TCL Commands\nDESCRIPTION: Lists the new TCL commands added for enhanced integration with the Active-HDL simulator: `vunit_help`, `vunit_load`, `vunit_run`, `vunit_compile`, `vunit_restart`, and `vunit_user_init`. These commands facilitate interaction with VUnit from within the Active-HDL TCL console.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_4\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_help\n```\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_load\n```\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_run\n```\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_compile\n```\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_restart\n```\n\nLANGUAGE: TCL\nCODE:\n```\nvunit_user_init\n```\n\n----------------------------------------\n\nTITLE: Sending messages to multiple recipients in VHDL\nDESCRIPTION: Enables broadcast-style message delivery by calling `send` with an array of receiver actors, ensuring each receiver gets its own copy of the message. Supports multi-target communication in testbenches and complex systems. Uses `actor_vec_t` array type and `send` procedure.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_20\n\nLANGUAGE: VHDL\nCODE:\n```\nsend(net, actor_vec_t'(receiver_1, receiver_2), msg);\n```\n\n----------------------------------------\n\nTITLE: Using Custom Log Level in VHDL\nDESCRIPTION: Shows how to log a message with a previously defined custom log level.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\nlog(custom_level, \"message\");\n```\n\n----------------------------------------\n\nTITLE: Configuring Log Visibility in VHDL\nDESCRIPTION: Shows how to control log visibility for specific log levels and handlers.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_17\n\nLANGUAGE: VHDL\nCODE:\n```\n-- By default all log levels are visible\n\n-- Hide info level logs\nshow(display_handler, info, false);\n\n-- Show again\nshow(display_handler, info, true);\n\n-- Hide all levels below warning for display_handler (debug, trace, info)\nhide_all(display_handler, warning);\n\n-- Show all levels at or above info for my_logger\nshow_all(display_handler, my_logger, info);\n```\n\n----------------------------------------\n\nTITLE: Waiting for a Reply in VHDL\nDESCRIPTION: This VHDL snippet demonstrates how to wait for a reply to a message sent using VUnit's message passing. It uses the `receive_reply` procedure to block until a reply is received and then extracts the data from the reply message. It relies on the `pop_std_ulogic_vector` function to retrieve the data.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_10\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Wait for the reply to the read_msg\n\n  receive_reply(net, read_msg, reply_msg);\n  data := pop_std_ulogic_vector(reply_msg);\n```\n\n----------------------------------------\n\nTITLE: Receiving a Reply in VHDL\nDESCRIPTION: This VHDL snippet shows how to receive a reply to a message using VUnit. It highlights that if the original message was anonymous (no specified sender), the `receive_reply` procedure will look for the reply in the receiver's outbox instead of the sender's inbox. It assumes that the 'read_msg' was sent anonymously.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_14\n\nLANGUAGE: vhdl\nCODE:\n```\nreceive_reply(net, read_msg, reply_msg);\n```\n\n----------------------------------------\n\nTITLE: Adding Custom Messages to log_active in VUnit VHDL\nDESCRIPTION: Illustrates enhancing log entries by passing custom messages to log_active, helping differentiate between multiple wait statements within the same component. This method sacrifices automatic event context but clarifies the location or reason behind the log. Requires VUnit's logging infrastructure, with parameters for the event and a custom message. Outputs messages in the simulation logs.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Using log_active with a custom message\nwait until runner_timeout'event and log_active(runner_timeout, logger, \"Wait for output data\");\n\n```\n\n----------------------------------------\n\nTITLE: Creating Configurations with different tb_cfg - Python\nDESCRIPTION: This Python code defines a helper function 'encode' to convert a dictionary (representing the record) into a comma-separated string representation. It then creates two different configurations, 'VGA' and 'tiny', that configure the same test case in tb_composite_generics with different parameters stored in the tb_cfg record. This allows for easily setting different debugging and image resolution modes.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_8\n\nLANGUAGE: python\nCODE:\n```\ndef encode(tb_cfg):\n    return \", \".join([\"%s:%s\" % (key, str(tb_cfg[key])) for key in tb_cfg])\n\nvga_tb_cfg = dict(image_width=640, image_height=480, dump_debug_data=False)\ntest_1.add_config(name='VGA', generics=dict(encoded_tb_cfg=encode(vga_tb_cfg)))\n\ntiny_tb_cfg = dict(image_width=4, image_height=3, dump_debug_data=True)\ntest_1.add_config(name='tiny', generics=dict(encoded_tb_cfg=encode(tiny_tb_cfg)))\n```\n\n----------------------------------------\n\nTITLE: Receiving and Handling Incoming Messages - VUnit BFM VHDL\nDESCRIPTION: This VHDL snippet outlines the start of a BFM process which blocks on message reception using 'receive', inspects the incoming message type, and branches into specialization (here, handling write transactions). Extracts message content, unpacks address/data, and calls the basic BFM procedure to enact the transaction. Assumes VUnit message library, pre-defined actors, message types, and available bus-driving procedures. Intended as a message-driven BFM control loop.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_7\n\nLANGUAGE: vhdl\nCODE:\n```\nbegin\n  receive(net, brain, command_msg);\n  msg_type := message_type(command_msg);\n\n  if msg_type = brain_write_msg then\n    address := pop_integer(command_msg);\n    data := pop_std_ulogic_vector(command_msg);\n    write(a, number, of, bus, interface, signals, address, data);\n```\n\n----------------------------------------\n\nTITLE: Finding Actor with Deferred Creation Disabled - VHDL\nDESCRIPTION: This code snippet shows how to find an actor using the `find` function, disabling deferred actor creation.  If the actor is not found, the function returns `null_actor`.  This approach requires the actor to be created before the `find` call, potentially using an initial delay.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_31\n\nLANGUAGE: vhdl\nCODE:\n```\nfind(\"actor name\", enable_deferred_creation => false);\n```\n\n----------------------------------------\n\nTITLE: Documenting VUnit Attributes in JSON Export - JSON\nDESCRIPTION: Provides an example of how user attributes are represented in VUnit's JSON export schema. This snippet demonstrates the standard format for describing test attributes, where keys reflect user-defined names (beginning with a dot) and values may be null or a basic type. This export is compatible with tools needing to ingest test metadata from VUnit results.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/ui.rst#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n   \"attributes\": {\n        \".requirement-117\": null\n   }\n}\n```\n\n----------------------------------------\n\nTITLE: Explicitly Compiling HDL Builtins in VUnit (Python)\nDESCRIPTION: Explains the breaking change requiring explicit calls to compile HDL builtins. Users must now call `add_vhdl_builtins()` or `add_verilog_builtins()` on the VUnit UI object in their run script to include these builtins, which were previously compiled by default.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\n# Example usage in a run script\nfrom vunit import VUnit\n\nvu = VUnit.from_argv()\n\n# Explicitly add builtins (now required)\nvu.add_vhdl_builtins() \n# or\n# vu.add_verilog_builtins()\n\n# ... rest of the run script ...\n\nvu.main()\n```\n\nLANGUAGE: Python\nCODE:\n```\nadd_vhdl_builtins() # Method to add VHDL builtins\n```\n\nLANGUAGE: Python\nCODE:\n```\nadd_verilog_builtins() # Method to add Verilog builtins\n```\n\n----------------------------------------\n\nTITLE: Creating VUnit project in Python with run.py script\nDESCRIPTION: This code snippet demonstrates the typical Python script used to initialize a VUnit project, parse command line arguments, add HDL source files, and run tests. It relies on the VUnit Python API for project configuration and test execution.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/user_guide.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nfrom vunit import VUnit\n\n# Create VUnit instance by parsing command line arguments\nvu = VUnit.from_argv()\n\n# Optionally add VUnit's builtin HDL utilities for checking, logging, communication...\n# See http://vunit.github.io/hdl_libraries.html.\nvu.add_vhdl_builtins()\n# or\n# vu.add_verilog_builtins()\n\n# Create library 'lib'\nlib = vu.add_library(\"lib\")\n\n# Add all files ending in .vhd in current working directory to library\nlib.add_source_files(\"*.vhd\")\n\n# Run vunit function\nvu.main()\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Inbound Traffic - VHDL\nDESCRIPTION: This code snippet demonstrates how to subscribe to the inbound traffic of an actor. The `subscribe` procedure is used with the `inbound` keyword to receive all messages sent to the `driver` actor. This allows eavesdropping on messages sent to the actor.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_34\n\nLANGUAGE: vhdl\nCODE:\n```\nsubscribe(master_channel, driver, inbound);\n```\n\n----------------------------------------\n\nTITLE: Running VUnit Simulation Scripts Locally or Inside Container (Bash)\nDESCRIPTION: This Bash script represents the commands executed inside the Docker container (or potentially locally) to run VUnit simulations. It sets the `VUNIT_SIMULATOR` environment variable to `ghdl` and then iterates through all `run.py` files found in the current directory or subdirectories, executing each one using `python3`.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/container.rst#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\nVUNIT_SIMULATOR=ghdl\nfor f in $(find ./ -name 'run.py'); do python3 $f; done\n```\n\n----------------------------------------\n\nTITLE: Simple BFM Wrapper for a Write Transaction - VUnit VHDL\nDESCRIPTION: Abstracts the message construction/sending process into a single procedure call for end-user test sequencers. The 'brain_write' procedure encapsulates address and data packing and message dispatch, minimizing sequencing code and decoupling test from BFM physical interface details. Implementation depends on prior setup of the VUnit message-passing infrastructure.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\nbrain_write(net, address, data);\n```\n\n----------------------------------------\n\nTITLE: Field Subtype Definitions for Register Fields in VHDL\nDESCRIPTION: Presents how to define VHDL integer subtypes that map to hardware register fields, aligning the subtype's range with the number of bits representing the field. This is useful for strongly typing numerical fields when checking or logging hardware state. Requires VHDL type system; key parameters are bit ranges for subtype definition. The subtype can be used directly in field access and value checking.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_10\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Defining a subtype for a register field\nsubtype n_samples_field is integer range 0 to 15;  -- For a 4-bit field\n\n```\n\n----------------------------------------\n\nTITLE: Waiting for 'dut_checker_done' in VHDL\nDESCRIPTION: The snippet demonstrates the `test_runner` waiting for `dut_checker_done` using `is_active_msg` before cleaning up, ensuring the DUT results are fully verified. This is a form of synchronization ensuring correct testbench behavior.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_4\n\nLANGUAGE: VHDL\nCODE:\n```\n  .. raw:: html\n      :file: img/vunit_events/wait_done_event.html\n```\n\n----------------------------------------\n\nTITLE: Declaring 'done_event' in VHDL\nDESCRIPTION: This shows the declaration of a second event, `dut_checker_done`, which is signaled by the `dut_checker` process when it has verified all of its data for the current data set.  It signals to the `test_runner` process that it is safe to continue.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_3\n\nLANGUAGE: VHDL\nCODE:\n```\n  .. raw:: html\n      :file: img/vunit_events/done_event.html\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Logger in VHDL\nDESCRIPTION: Shows how to declare and initialize a custom logger. Custom loggers can be organized in hierarchies.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant my_logger : logger_t := get_logger(\"system0.subsystem1\");\n```\n\n----------------------------------------\n\nTITLE: Instantiating a Test Runner Component in VHDL Testbench\nDESCRIPTION: Illustrates how the main testbench architecture instantiates the 'test_runner' component, replacing the previous inline 'test_runner' process and watchdog.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL code showing the instantiation of the test_runner component\n-- within the main testbench architecture.\n-- component test_runner is ... end component;\n-- ...\n-- architecture structural of tb_flip_flop is\n-- begin\n--   dut_inst : component work.flip_flop ... ;\n--   test_runner_inst : component work.test_runner\n--     generic map ( ... )\n--     port map ( ... );\n-- end architecture structural;\n-- (Actual code resides in img/vhdl_configuration/test_runner_component_instantiation.html)\n```\n\n----------------------------------------\n\nTITLE: Printing to Open File in VHDL\nDESCRIPTION: Demonstrates printing to an already opened file for performance optimization when writing many messages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_16\n\nLANGUAGE: VHDL\nCODE:\n```\nfile_open(my_file, \"myfile.txt\", write_mode);\nprint(\"Hello World\", my_file);\nprint(\"Hello Again\", my_file);\nfile_close(my_file);\n```\n\n----------------------------------------\n\nTITLE: Using Print Function in VHDL\nDESCRIPTION: Shows how to use the print procedure for direct, unformatted output to stdout or a file.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_15\n\nLANGUAGE: VHDL\nCODE:\n```\nprint(\"Hello World\"); -- To stdout\nprint(\"Hello World\", my_file); -- To file\n```\n\n----------------------------------------\n\nTITLE: Core API Package: logger_pkg\nDESCRIPTION: Contains definitions for the 'logger_t' datatype and internal procedures for logging. This package forms the core of VUnit's logging API, managing log message creation and handling.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_29\n\nLANGUAGE: vhdl\nCODE:\n```\nlogger_pkg\n<<<<<<<<<<\nContains ``logger_t`` datatype and logger local procedures.\n\n.. literalinclude:: ../../vunit/vhdl/logging/src/logger_pkg.vhd\n   :language: vhdl\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Configuring DUT Selection Generics using VUnit in Python\nDESCRIPTION: Shows the Python run script counterpart for the generic-based DUT selection. It uses VUnit's 'add_config' method and 'itertools.product' to systematically generate test configurations for all combinations of specified generic values ('dut_arch' and 'width').\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n# Python script using VUnit to configure tests based on generics.\n# Uses add_config() to define configurations.\n# Leverages itertools.product to create tests for all combinations\n# of 'dut_arch' ('rtl', 'behavioral') and 'width' (e.g., 8, 16).\n# (Actual code resides in img/vhdl_configuration/create_vunit_configuration_for_selecting_dut.html)\n```\n\n----------------------------------------\n\nTITLE: VHDL Legacy Logger Initialization Procedure\nDESCRIPTION: Describes the deprecated 'logger_init' procedure allowing legacy testbenches to configure logging behavior. It attempts to map older logging configurations to the current system, ensuring compatibility with pre-VUnit 3.0 testbenches.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_28\n\nLANGUAGE: vhdl\nCODE:\n```\nTo better support testbenches developed before VUnit 3.0 it's still possible to configure a logger using the\n``logger_init`` procedure. The procedure uses best effort to map old behavior to contemporary functionality.\n```\n\n----------------------------------------\n\nTITLE: Creating Child Identity Using Parent ID (VHDL)\nDESCRIPTION: This snippet demonstrates an alternative overload of the `id_pkg.get_id` function where a child identity is created by providing its local name and explicitly referencing its parent's `id_t`. This method offers direct control over attaching a new identity as a child of a specific existing parent identity.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming tb_dut_id is already created\n\nconstant vc_y_id : id_t := get_id(\"vc_y\", tb_dut_id);\n```\n\n----------------------------------------\n\nTITLE: Running the Vivado and VUnit Example - Shell\nDESCRIPTION: This shell script demonstrates the commands needed to execute the Vivado and VUnit example project. It first calls the `generate_vivado_project.py` script, which creates the Vivado project and its IP. After that it calls the `run.py` script which compiles standard and project IP libraries. The user must have Vivado and VUnit installed with appropriate paths set to use this script. The output will be the compiled libraries and project structure within the file system.\nSOURCE: https://github.com/vunit/vunit/blob/master/examples/vhdl/vivado/readme.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npython generate_vivado_project.py\npython run.py\n```\n\n----------------------------------------\n\nTITLE: VHDL Simple Test Bench Example\nDESCRIPTION: This snippet shows a simple VHDL test bench that is compatible with VUnit, including the inclusion of the VUnit context, the addition of a 'runner_cfg' generic, and the structure for wrapping existing test code within VUnit's test runner procedures. It also exemplifies how to define multiple tests within a single test bench.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/user_guide.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\n  -- literalinclude:: ../examples/vhdl/user_guide/tb_example.vhd\n   :caption: Simplest VHDL test bench: `tb_example.vhd`\n   :language: vhdl\n   :lines: 7-\n```\n\nLANGUAGE: VHDL\nCODE:\n```\n  -- literalinclude:: ../examples/vhdl/user_guide/tb_example_many.vhd\n   :caption: VHDL test bench with multiple tests: `tb_example_many.vhd`\n   :language: vhdl\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Configuring NVC Global Flags (Python/Config)\nDESCRIPTION: Introduces the `nvc.global_flags` configuration option. This allows passing arbitrary command-line flags directly to the NVC simulator during simulation and compilation.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_3\n\nLANGUAGE: Python\nCODE:\n```\nvu.set_sim_option(\"nvc.global_flags\", \"--ieee-warnings=off\")\n```\n\n----------------------------------------\n\nTITLE: Generating Full Identity Tree View (VHDL)\nDESCRIPTION: This VHDL snippet demonstrates calling the `id_pkg.get_tree` function without any arguments. This overload generates a formatted string representation of the entire identity tree managed by the package, starting from the predefined `root_id`. It provides a comprehensive overview of all created identities.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_9\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming identities have been created\n\nconstant full_tree_string : string := get_tree();\n-- Log output would show the full tree\n-- (root)\n--   :tb_dut:\n--     :vc_x:\n--     :vc_y:\n```\n\n----------------------------------------\n\nTITLE: Measuring Code Coverage\nDESCRIPTION: Commands for measuring code coverage of VUnit's Python codebase using the 'coverage' tool, generating HTML reports, and analyzing missing coverage areas.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/contributing.rst#_snippet_2\n\nLANGUAGE: console\nCODE:\n```\nvunit/ > coverage run --branch --source vunit/ -m unittest discover tests/\nvunit/ > coverage html --directory=htmlcov\nvunit/ > open htmlcov/index.html\n```\n\n----------------------------------------\n\nTITLE: Sourcing a TCL Script\nDESCRIPTION: This snippet demonstrates the standard way to source a TCL script. The `source` command takes the path to the TCL file as an argument and executes the commands within that file. This is a workaround to source multiple user TCL files.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/opts.rst#_snippet_0\n\nLANGUAGE: TCL\nCODE:\n```\n``source <path/to/script.tcl>``\n```\n\n----------------------------------------\n\nTITLE: Implementing External Logging Framework in VHDL with VUnit\nDESCRIPTION: Details how VUnit provides a 'common_log_pkg' package with a 'write_to_log' procedure that can be customized to redirect log messages to third-party logging frameworks. The example involves referencing a package body implementation to enable this feature, promoting flexible logging strategies.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_26\n\nLANGUAGE: vhdl\nCODE:\n```\nVUnit provides a package ``common_log_pkg`` providing a single procedure ``write_to_log`` that is used to\noutput the string produced by a log entry. The implementation of this procedure can be changed to redirect VUnit log\nmessages to a third party logging framework, thereby aligning the logging styles in a testbench with code using several\nlogging frameworks. The feature is enabled by passing a reference to the file implementing the package body:\n\n .. raw:: html\n    :file: use_external_log.html\n```\n\n----------------------------------------\n\nTITLE: Defining VHDL Record Types for Custom Messages\nDESCRIPTION: Defines record types for message passing in VHDL, including an enumerated message type and a message record containing the message type and a sentence string. These types are stored in a package 'msg_types_pkg' used for code generation and message handling.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant max_sentence_length_c : positive := 128;\n\ntype sentence_msg_type_t is (start_verifying, start_encrypting);\ntype sentence_msg_t is record\n  msg_type : sentence_msg_type_t;\n  sentence : string(1 to max_sentence_length_c);\nend record sentence_msg_t;\n```\n\n----------------------------------------\n\nTITLE: Creating GitHub Actions Workflow for VUnit Tests Using YAML\nDESCRIPTION: This YAML snippet demonstrates how to define a GitHub Actions workflow named \"VUnit Tests\" that triggers on push and pull request events. It configures a job that runs on an Ubuntu VM, checks out the repository code using the standard checkout action, and runs the VUnit Action container to execute the HDL tests defined by VUnit. Dependencies include using the VUnit Action from the GitHub Marketplace. This enables automated execution of VUnit testbenches in a CI/CD pipeline.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/script.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: VUnit Tests\n\non:\n  push:\n  pull_request:\n\njobs:\n\n  test:\n    runs-on: ubuntu-latest\n    steps:\n\n      - uses: actions/checkout@v2\n\n      - uses: VUnit/vunit_action@v0.1.0\n```\n\n----------------------------------------\n\nTITLE: Checking for Identity Existence with has_id (VHDL)\nDESCRIPTION: This VHDL snippet demonstrates using the `id_pkg.has_id` function to check if a specific identity exists within the identity tree. It shows checking by providing the full path string or by providing a local name relative to a known parent identity (`id_t`).\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_10\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming :tb_dut:vc_x: exists and tb_dut_id exists\n\nconstant exists_by_full_name : boolean := has_id(\":tb_dut:vc_x:\");\nconstant exists_by_partial_name : boolean := has_id(\"vc_x\", tb_dut_id);\n-- Log outputs would show TRUE for both if :tb_dut:vc_x: exists\n```\n\n----------------------------------------\n\nTITLE: Making simulator flag argument deterministic in VUnit\nDESCRIPTION: This code snippet alters the ordering of simulator flags within VUnit to ensure deterministic behavior. By sorting the list of flags before processing, it guarantees consistent simulation setups across runs, aiding reproducibility. It relies on standard list processing and affects how flags are added to simulation commands.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\ndef set_deterministic_simulator_flags(flags):\n    # Sort flags to ensure deterministic order\n    return sorted(flags)\n\n# Usage in the simulation setup\nflags = ['-vhdl2008', '-debug', '-s']\nflags = set_deterministic_simulator_flags(flags)\n```\n\n----------------------------------------\n\nTITLE: Finding an Actor by Name - VUnit VHDL\nDESCRIPTION: Illustrates dynamic discovery of an actor using VUnit's 'find' function, assigning the returned actor handle to 'brain'. This simulates a contact lookup in an email client, allowing indirect references to communication endpoints. Requires the actor to be previously registered within the system. Useful for flexible or late-bound BFM connections in tests.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\nbrain := find(\"The Brain\");\n```\n\n----------------------------------------\n\nTITLE: VHDL Testbench Main Loop for Data Generation and Saving CSV Files\nDESCRIPTION: Describes a VHDL process that iteratively generates output samples using get_output_sample, stores them in a dynamically growing integer array, and saves each data set to a CSV file with a unique name, then cleans up before the next iteration. Implements nested loops: outer for data sets, inner for samples.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\n  test_runner: process is\n    variable data_set : integer_array_t;\n  begin\n    test_runner_setup(runner, runner_cfg);\n\n    for set in 1 to num_of_data_sets loop\n      data_set := new_1d;\n\n      for data in 1 to size_of_data_set loop\n        append(data_set, get_output_sample);\n      end loop;\n\n      save_csv(data_set, join(output_path(runner_cfg), \"data_set_\" & to_string(set) & \".csv\"));\n      deallocate(data_set);\n    end loop;\n\n    test_runner_cleanup(runner);\n  end process;\n```\n\n----------------------------------------\n\nTITLE: Implementing Lower-Level Test Control Logic in VHDL for VUnit\nDESCRIPTION: Presents the lower-level entity designed to contain the main test control logic. It receives configuration from the top-level entity via a generic (e.g., `cfg`) which is distinct from `runner_cfg`. This entity encapsulates the `test_runner` process, including the calls to `test_runner_setup`, `test_runner_cleanup`, and the test suite loop structure, operating on the configuration received through its generic.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/run/user_guide.rst#_snippet_4\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Code referenced from: img/test_control.html\n-- This snippet shows the lower-level entity containing the actual test control process.\n-- Key elements:\n-- 1. A generic (e.g., 'cfg') to receive configuration, NOT named 'runner_cfg'.\n-- 2. The main 'test_runner' process using the received 'cfg' generic in the 'test_runner_setup' call.\n-- 3. Contains the 'while test_suite loop ...' structure.\n```\n\n----------------------------------------\n\nTITLE: Partial Analysis and Notification using notify_if_fail in VUnit VHDL\nDESCRIPTION: Shows how to separate analysis and action in check procedures using VUnit's notify_if_fail, which notifies a specified event when a comparison failure occurs before logging. This pattern improves error notification and log clarity, as it simultaneously triggers vunit_error and produces logs for failed checks. Requires VUnit's check libraries and notify_if_fail procedure. Parameters include the analysis result and the event to notify.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_11\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Using notify_if_fail for analysis/action separation\nresult := check_equal_fn(actual, expected, message);\nnotify_if_fail(result, vunit_error);\nlog(result);\n\n```\n\n----------------------------------------\n\nTITLE: Basic Logging in VUnit 3.0 with VHDL\nDESCRIPTION: Demonstrates the simplest form of logging in VUnit 3.0 where a message is passed to the info logging function. This basic syntax remains unchanged from previous versions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_10_31_vunit_3_0_color_logging.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\ninfo(\"Some message\");\n```\n\n----------------------------------------\n\nTITLE: Actor Process Handling Multiple Message Types in VHDL\nDESCRIPTION: Demonstrates a VHDL process that repeatedly receives messages, identifies the message type, and processes data accordingly. It updates internal state such as memory on recognized message types and discards or fails on unexpected types, ensuring type-safe message handling.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_11\n\nLANGUAGE: vhdl\nCODE:\n```\nmessage_handler: process is\\n  variable request_msg : msg_t;\\n  variable msg_type : msg_type_t;\\n  variable address : unsigned(7 downto 0);\\n  variable data : std_logic_vector(7 downto 0);\\n  variable memory : integer_vector(0 to 255) := (others => 0);\\nbegin\\n  receive(net, actor, request_msg);\\n  msg_type := message_type(request_msg);\\n  if msg_type = write_msg then\\n    address := pop(request_msg);\\n    data := pop(request_msg);\\n    memory(to_integer(address)) := to_integer(data);\\n  end if;\\nend process;\n```\n\n----------------------------------------\n\nTITLE: Running VHDL Verification Component Tests\nDESCRIPTION: Example command for running the tests for VUnit's VHDL verification components using the corresponding run.py script.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/contributing.rst#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\npython vunit/vhdl/verification_components/run.py\n```\n\n----------------------------------------\n\nTITLE: Mocking Logger Output - VHDL\nDESCRIPTION: This code snippet showcases how to use mocking within VUnit to verify the interaction of a component with the logging framework. It demonstrates setting up a mock, checking for specific log messages, and then removing the mock.  `check_log` is used to verify if a expected log with given message string has occurred.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_6\n\nLANGUAGE: vhdl\nCODE:\n```\n  if run(\"Test that error x is triggered in scenario y\") then\n    mock(alpha_logger, error);\n\n    <Code creating scenario y which is expected to trigger error x>\n\n    check_log(alpha_logger, \"An error message\", error);\n\n    unmock(alpha_logger);\n  end if;\n```\n\n----------------------------------------\n\nTITLE: Including VHDL Code with reStructuredText literalinclude\nDESCRIPTION: This reStructuredText snippet utilizes the `literalinclude` directive to embed VHDL code from an external file ('../../vunit/vhdl/data_types/src/api/external_integer_vector_pkg.vhd'). It specifies the language syntax highlighting as VHDL and includes only the content starting from line 7.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/ext_integer_vector.rst#_snippet_0\n\nLANGUAGE: rst\nCODE:\n```\n.. literalinclude:: ../../vunit/vhdl/data_types/src/api/external_integer_vector_pkg.vhd\n   :language: vhdl\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Renaming method 'depends_on' to 'add_dependency_on' in VUnit\nDESCRIPTION: This code snippet changes the public method name for adding dependencies from 'depends_on' to 'add_dependency_on' within the VUnit API. The rename enhances clarity and consistency of the method's purpose, improving user understanding and API usability. It requires updating all calls to the method throughout the codebase or user scripts.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_5\n\nLANGUAGE: Python\nCODE:\n```\nclass VUnit:\n    def add_dependency_on(self, dependency):\n        # Logic to add dependency\n        pass\n\n    # Previously named method\n    # def depends_on(self, dependency):\n    #     return self.add_dependency_on(dependency)\n```\n\n----------------------------------------\n\nTITLE: Executing VUnit tests with XML output in console\nDESCRIPTION: This command executes VUnit tests and generates an xUnit-compatible XML output file named `test_output.xml`.  This allows integration with CI tools such as Jenkins. The `--xunit-xml` argument specifies the output file for the test results.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/intro.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\npython run.py --xunit-xml test_output.xml\n```\n\n----------------------------------------\n\nTITLE: Mocking Loggers for Testing in VHDL\nDESCRIPTION: Demonstrates how to mock loggers to verify that libraries produce expected failures and messages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_18\n\nLANGUAGE: VHDL\nCODE:\n```\nmock(get_logger(\"lib\"));\n\n-- Code under test\nlib_func_that_may_log_error;\n\n-- Check that expected log was produced\ncheck_only_log(get_logger(\"lib\"), error, \"Expected error message\");\nunmock(get_logger(\"lib\"));\n```\n\n----------------------------------------\n\nTITLE: Invoking Basic BFM Write Procedure - VUnit VHDL\nDESCRIPTION: This code demonstrates a basic BFM procedure call in VHDL, where the 'write' procedure transfers an address and data word to a bus interface. This offers abstraction over the physical pin manipulations, enhancing readability in test sequences. Dependencies include a compatible BFM library; required parameters are the address and data, and outputs are the relevant control signals for the DUT bus interface. Intended for step-by-step simulation sequences without describing concurrency.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\nwrite(a, number, of, bus, interface, signals, address, data);\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Loggers for Event Logging in VUnit VHDL\nDESCRIPTION: Shows how to set up a custom logger associated with a particular hierarchy (e.g., dut_checker) using either the identity or a name string, and then use it with log_active to produce targeted logs. This provides more contextual logging by tying messages to specific components. Requires VUnit's logging and identity libraries; key parameters are the logger identity and event reference. Outputs log entries associated with the specified logger.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Creating and using a custom logger with log_active\nlogger := get_logger(\"dut_checker\");\nwait until runner_timeout'event and log_active(runner_timeout, logger);\n\n```\n\n----------------------------------------\n\nTITLE: Custom VUnit Run File Configuration in YAML\nDESCRIPTION: A GitHub Actions workflow configuration snippet demonstrating how to specify a custom path to the VUnit run script when the script is not located in the repository root.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2020_08_12_continuous_integration_with_vunit_action_in_10_lines_of_code.rst#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n- uses: VUnit/vunit_action@v0.1.0\n  with:\n    run_file: path/to/vunit_run_script.py\n```\n\n----------------------------------------\n\nTITLE: SystemVerilog Test Bench Example for VUnit\nDESCRIPTION: This snippet provides an example of a SystemVerilog test bench compatible with VUnit, showing the use of the `TEST_CASE()` macro to define individual tests, each executed in separate simulations. It emphasizes sharing a common test environment among multiple test cases.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/user_guide.rst#_snippet_2\n\nLANGUAGE: verilog\nCODE:\n```\n  -- literalinclude:: ../examples/verilog/user_guide/tb_example.sv\n   :caption: SystemVerilog test bench: `tb_example.sv`\n   :language: verilog\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Checking Mock Queue Length in VHDL\nDESCRIPTION: Shows how to use the mock queue length to wait for a log to occur before checking it.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_19\n\nLANGUAGE: VHDL\nCODE:\n```\nmock(get_logger(\"lib\"));\n\n-- Start process that will eventually log\nlib_func_async;\n\n-- Wait for log to occur\nwait until mock_queue_length > 0 for 1 ms;\n\n-- Check that expected log was produced\ncheck_only_log(get_logger(\"lib\"), error, \"Expected error message\");\nunmock(get_logger(\"lib\"));\n```\n\n----------------------------------------\n\nTITLE: Adding 'no_parse' argument to inhibit dependency and test scanning in VUnit's add_source_files\nDESCRIPTION: This snippet introduces a 'no_parse' argument in the add_source_files function to prevent dependency analysis and test scanning for specified source files. It improves control over source inclusion, handling large or external sources that do not need dependency checks. It requires modification of the source addition process within VUnit's configuration.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\ndef add_source_files(files, no_parse=False):\n    for file in files:\n        # Add source file with optional no_parse flag\n        process_source(file, no_parse=no_parse)\n\n```\n\n----------------------------------------\n\nTITLE: Message Writing Procedure Example - VHDL\nDESCRIPTION: This code snippet shows how to wrap the message passing details from the `com` library into a procedure to create a user-friendly interface for bus functional models (BFMs). This simplifies the process of writing data by abstracting the message creation and sending steps.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_1\n\nLANGUAGE: vhdl\nCODE:\n```\n  write(net, address, data);\n```\n\n----------------------------------------\n\nTITLE: Simple Testbench Structure\nDESCRIPTION: This VHDL code represents an ideal, simplified testbench using a single process. The intent is to generate a random sentence, apply it to the encryption device, and then verify the output. The code emphasizes readability and clarity by encapsulating interface details in procedures like `create_random_sentence`, `encrypt`, and `verify_encrypted_sentence`.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Core of main process\nfor i in 1 to 10 loop\n  sentence := create_random_sentence;\n  encrypt(sentence);\n  verify_encrypted_sentence(sentence);\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Getting Mailbox State with get_mailbox_state in VUnit (VHDL)\nDESCRIPTION: Demonstrates how to retrieve the current snapshot of a mailbox's state in the VUnit com system by calling 'get_mailbox_state'. The result is a record suitable for examination in a simulator, not recommended for programmatic decisions. Inputs are the actor and mailbox identifiers; output is the 'mailbox_state' variable holding state info.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_40\n\nLANGUAGE: vhdl\nCODE:\n```\nmailbox_state := get_mailbox_state(memory_bfm_pkg.actor, inbox);\n```\n\n----------------------------------------\n\nTITLE: List all tests using VUnit CLI - Python\nDESCRIPTION: This command lists all available tests in the VUnit project using the -l flag. It's executed using the python interpreter with the run.py script which creates the VUnit object and calls the main method. The output displays the names of the discovered tests.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n> python run.py -l\nlib.tb_example.all\nlib.tb_example_many.test_pass\nlib.tb_example_many.test_fail\nListed 3 tests\n```\n\n----------------------------------------\n\nTITLE: Getting Actor State and Debugging Actor State String in VUnit (VHDL)\nDESCRIPTION: Shows how to fetch both the internal record and a string representation of an actor's state in the VUnit com system by using 'get_actor_state' and 'get_actor_state_string' functions. This is useful to inspect the status of mailboxes, subscriptions, and inbound/outbound traffic. Inputs are the actor reference; outputs are the actor_state variable and debug log string.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_42\n\nLANGUAGE: vhdl\nCODE:\n```\nactor_state := get_actor_state(driver);\ndebug(get_actor_state_string(driver));\n```\n\n----------------------------------------\n\nTITLE: Defining Stream Slave Verification Component Interface in VHDL\nDESCRIPTION: This snippet presents the VHDL package interface for a stream slave verification component. It encapsulates signal definitions and procedures to emulate slave-side behavior in stream communication protocols during simulation verification. It supports listening to and responding on stream channels according to the verification requirements and depends on standard VHDL libraries and related verification packages.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/verification_components/vci.rst#_snippet_2\n\nLANGUAGE: vhdl\nCODE:\n```\nPackage content from ../../vunit/vhdl/verification_components/src/stream_slave_pkg.vhd starting at line 7\n```\n\n----------------------------------------\n\nTITLE: Getting Messenger State and Debugging Messenger State String in VUnit (VHDL)\nDESCRIPTION: Explains how to access the state of the overall messenger (the central manager of actors and communication) in the VUnit com package, and output it as a string for debugging. The calls return structured information about active and deferred actors. No input parameters needed if using context package variables; output is a messenger_state snapshot and a string sent to the debug log.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_43\n\nLANGUAGE: vhdl\nCODE:\n```\nmessenger_state := get_messenger_state;\ndebug(get_messenger_state_string);\n```\n\n----------------------------------------\n\nTITLE: Hierarchical logger management in a VHDL block\nDESCRIPTION: Shows the instantiation of loggers for different verification components with hierarchical relationships, creating parent and child loggers to organize logs effectively.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant vc_logger : logger_t := get_logger(vc'path_name);\n```\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant alpha_logger : logger_t := get_logger(\"alpha\", vc_logger);\n```\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant beta_logger : logger_t := get_logger(\"beta\", vc_logger);\n```\n\n----------------------------------------\n\nTITLE: Enabling Trace Logging with com_logger in VUnit (VHDL)\nDESCRIPTION: Shows how to enable trace-level message logging in the VUnit com library using the 'com_logger' and 'display_handler'. This allows users to observe all message traffic including when messages are inserted into or removed from mailboxes. Dependencies are 'com_logger', 'display_handler', and predefined log levels; expected input is at least the logger, handler, and level, with logged output to the configured log destination.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_39\n\nLANGUAGE: vhdl\nCODE:\n```\nshow(com_logger, display_handler, trace);\n```\n\n----------------------------------------\n\nTITLE: Getting Mailbox State as String with get_mailbox_state_string in VUnit (VHDL)\nDESCRIPTION: Illustrates how to generate a string representation of an actor mailbox state using 'get_mailbox_state_string', aiding in human-readable debugging. Inputs are the actor and mailbox; output is the formatted string describing size and messages in the mailbox. Requires the 'com' library and suitable mailbox context.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_41\n\nLANGUAGE: vhdl\nCODE:\n```\nget_mailbox_state_string(memory_bfm_pkg.actor, inbox)\n```\n\n----------------------------------------\n\nTITLE: Basic VUnit Action Workflow Configuration in YAML\nDESCRIPTION: A minimal GitHub Actions workflow configuration that runs VUnit tests automatically on push and pull request events. It uses ubuntu-latest as the runner environment, checks out the repository code, and executes VUnit Action.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2020_08_12_continuous_integration_with_vunit_action_in_10_lines_of_code.rst#_snippet_0\n\nLANGUAGE: yaml\nCODE:\n```\nname: VUnit Tests\non:\n  push:\n  pull_request:\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: VUnit/vunit_action@v0.1.0\n```\n\n----------------------------------------\n\nTITLE: Python Script to Configure VUnit Testbench and Running Octave Visualization\nDESCRIPTION: Provides a Python code snippet that initializes a VUnit project, adds array utilities, defines output directories, and configures the testbench entity. It sets up multiple configurations with different parameters, including a pre-config function that calls Octave to generate plots before simulation begins.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_1\n\nLANGUAGE: Python\nCODE:\n```\n  prj = VUnit.from_argv()\n  prj.add_array_util()\n\n  root = dirname(__file__)\n  lib = prj.add_library(\"lib\")\n  lib.add_source_files(join(root, \"test\", \"*.vhd\"))\n  tb_octave = lib.entity(\"tb_octave\")\n\n  tb_octave.add_config(name=\"Passing test\",\n                       generics=dict(size_of_data_set=10,\n                                     num_of_data_sets=10,\n                                     activate_bug=False),\n                       pre_config=make_pre_config(\"Passing test\", 10))\n\n  prj.main()\n```\n\n----------------------------------------\n\nTITLE: Configuring and Running VUnit Test Suites in Python\nDESCRIPTION: This Python code snippet sets up a VUnit test environment, loads VHDL testbenches, and executes simulations. It depends on the 'vunit' library and is used to automate the testing process for hardware modules, reporting results upon completion.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.62.1.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nimport vunit\n\n# Create a VUnit instance\nui = vunit.initialize()\n\n# Load VHDL testbenches from a specified source folder\nui.load_test_benches('test_benches')\n\n# Run all loaded testbenches\nui.run()\n\n```\n\n----------------------------------------\n\nTITLE: Adding Test Configuration with Generics - Python\nDESCRIPTION: This Python code configures a VUnit test case with the encoded `image_resolution` as a generic. It retrieves the testbench entity and test case, creates a dictionary of generics (where the key is the generic name in the VHDL and the value is the encoded string), and adds the configuration to the test case. The configuration is named 'VGA'.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_1\n\nLANGUAGE: python\nCODE:\n```\nimage_resolution = [640, 480]\nencoded_image_resolution = \", \".join(map(str, image_resolution))\n\ntestbench = tb_lib.entity(\"tb_composite_generics\")\ntest_1 = testbench.test(\"Test 1\")\n\ngenerics = dict(encoded_image_resolution=encoded_image_resolution)\ntest_1.add_config(name='VGA', generics=generics)\n```\n\n----------------------------------------\n\nTITLE: Log Handler Configuration Package: log_handler_pkg\nDESCRIPTION: Defines 'log_handler_t' datatype and procedures to configure log handlers, enabling customization of log message destinations and formats within VUnit. This package underpins flexible and modular logging setups.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_30\n\nLANGUAGE: vhdl\nCODE:\n```\nlog_handler_pkg\n<<<<<<<<<<<<<<<\nContains ``log_handler_t`` datatype and log handler local configuration\nprocedures.\n\n.. literalinclude:: ../../vunit/vhdl/logging/src/log_handler_pkg.vhd\n   :language: vhdl\n   :lines: 7-89\n```\n\n----------------------------------------\n\nTITLE: Selecting DUT Architecture using Generics in VHDL\nDESCRIPTION: Illustrates a VHDL testbench approach where generics (e.g., 'dut_arch') combined with if-generate statements are used to select between different architectures (e.g., 'rtl', 'behavioral') of a DUT instantiation. This method can lead to code duplication, especially for components with many ports.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL code demonstrating DUT selection via generics.\n-- Uses an if-generate statement controlled by a 'dut_arch' generic\n-- to instantiate either the 'rtl' or 'behavioral' architecture.\n-- Example DUT: simple variable-width flip-flop.\n-- Note: This approach duplicates the instantiation block.\n-- (Actual code resides in img/vhdl_configuration/selecting_dut_with_generics.html)\n```\n\n----------------------------------------\n\nTITLE: Adding Source Files in VUnit using add_source_files method (Python)\nDESCRIPTION: This snippet explains the usage of the add_source_files method in VUnit to include a list of source files in the project. It assists in managing files required for simulation or testing setups. The method accepts a list of filenames, managing dependencies and ensuring they are included during the build process.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.53.0.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\nadd_source_files\n```\n\n----------------------------------------\n\nTITLE: Encapsulating Test Runner Logic within a VHDL Entity\nDESCRIPTION: Shows how to encapsulate test runner logic (typically a process) within a separate VHDL entity. This entity requires generics like 'nested_runner_cfg' (distinct from 'runner_cfg' to avoid VUnit misidentification) and 'width', as well as ports matching the DUT interface.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL entity definition for encapsulating test runner logic.\n-- entity test_runner is\n--   generic (\n--     nested_runner_cfg : string; -- Note: Not 'runner_cfg'\n--     width             : positive\n--   );\n--   port (\n--     -- DUT interface ports (clk, rst, d, q)\n--     -- clk_period constant is assumed available\n--   );\n-- end entity test_runner;\n-- (Actual code resides in img/vhdl_configuration/test_runner_entity.html)\n```\n\n----------------------------------------\n\nTITLE: Accessing protected type methods in VHDL\nDESCRIPTION: Shows how to invoke methods on a protected type logger, illustrating VHDL-2000 encapsulation. Emphasizes the API differences between standard subprogram calls and protected method calls.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\nlogger.info(\"Hello world with a protected type variable\");\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Log Level in VHDL\nDESCRIPTION: Demonstrates how to define a custom log level with optional color settings for the output.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant custom_level : log_level_t := new_log_level(\"custom_level\", fg => lightblue, bg => black, style => bright);\n```\n\n----------------------------------------\n\nTITLE: Running VUnit test cases in parallel with GHDL\nDESCRIPTION: This command executes VUnit test cases in parallel using the specified number of threads. It leverages GHDL as the simulator in the background. The `-p` option specifies the number of parallel threads.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2015_12_15_free_and_open_source_verification_with_vunit_and_ghdl.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\n$ python run.py -p 7\n```\n\n----------------------------------------\n\nTITLE: Component Self-Registration with Instance Number (VHDL)\nDESCRIPTION: This VHDL snippet illustrates a pattern for components receiving an `id_t` generic defaulting to `null_id`. If no ID is provided, the component dynamically generates a unique hierarchical ID based on a convention (e.g., incorporating type and instance number) by searching the identity tree for existing instances of the same type.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_12\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Inside a VC entity with generic id : id_t := null_id\n\narchitecture rtl of vc_x is\n  constant my_id : id_t := calculate_my_id(id);\n  -- ... rest of VC implementation ...\n\n  -- Example calculate_my_id function (simplified concept):\n  function calculate_my_id (provided_id : id_t) return id_t is\n    constant COMPANY_ID : id_t := get_id(\"company\"); -- Assume company ID exists\n    constant VC_TYPE_NAME : string := \"vc_x\";\n    variable instance_count : natural := 0;\n    -- Simplified search logic:\n    -- Iterate through children of COMPANY_ID, check if name = VC_TYPE_NAME\n    -- and if path matches the pattern :company:vc_x:N:\n    -- Increment instance_count for each match.\n    -- Then construct new_name := VC_TYPE_NAME & to_string(instance_count + 1);\n    -- return get_id(new_name, COMPANY_ID);\n  begin\n    if provided_id = null_id then\n      -- ... logic to calculate instance_count by searching ...\n      -- ... construct unique name ...\n      -- return get_id(unique_name, COMPANY_ID);\n      return get_id(\"vc_x:1\", COMPANY_ID); -- Example based on log output\n    else\n      return provided_id;\n    end if;\n  end function;\n\nbegin\n  -- Log output for this instance would show its ID as :company:vc_x:1:\nend architecture;\n```\n\n----------------------------------------\n\nTITLE: VHDL Record Type Definition - VHDL\nDESCRIPTION: This VHDL code defines a record type named `tb_cfg_t` with fields for image width, image height, and a debug flag. This structure mirrors the data represented by the Python dictionary which is being encoded into a string.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_5\n\nLANGUAGE: vhdl\nCODE:\n```\ntype tb_cfg_t is record\n  image_width     : positive;\n  image_height    : positive;\n  dump_debug_data : boolean;\nend record tb_cfg_t;\n```\n\n----------------------------------------\n\nTITLE: Disabling Logs in VHDL\nDESCRIPTION: Shows how to disable specific log levels to ignore irrelevant messages while still counting them.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_20\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Disable all error logs from my_logger\nset_log_level_enabled(my_logger, error, false);\n\n-- This log will be ignored, won't be visible or stop simulation\nerror(my_logger, \"This is ignored\");\n\n-- Re-enable\nset_log_level_enabled(my_logger, error, true);\n```\n\n----------------------------------------\n\nTITLE: Creating Identity from VHDL Attribute path_name (VHDL)\nDESCRIPTION: This snippet demonstrates the basic usage of the `id_pkg.get_id` function to create an identity (`id_t`) from a string obtained from a VHDL name attribute like `path_name`. This establishes the identity for the specified hierarchical path within the `id_pkg`'s internal tree structure.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming vc_x_inst exists in hierarchy\n\nconstant vc_x_id : id_t := get_id(vc_x_inst'path_name);\n```\n\n----------------------------------------\n\nTITLE: Logging API call in VHDL-93 and later\nDESCRIPTION: Illustrates a generalized logging call using a wrapper function, maintaining API consistency across VHDL standards. Highlights backward compatibility.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\ninfo(logger, \"Hello world for VHDL-93 and later\");\n```\n\n----------------------------------------\n\nTITLE: Creating Identity from String Path Without Colons (VHDL)\nDESCRIPTION: This snippet demonstrates that the `id_pkg.get_id` function accepts string path arguments without requiring leading or trailing colons. This provides a slightly more concise syntax for defining hierarchical identities from strings while achieving the same result as using colons.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_4\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n\nconstant vc_x_id : id_t := get_id(\"tb_dut:vc_x\");\n```\n\n----------------------------------------\n\nTITLE: Enabling Debug Options for Log Location in Riviera-PRO/Active-HDL\nDESCRIPTION: Shows how to enable debug options for VHDL-2019 log location in supported simulators.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_22\n\nLANGUAGE: VHDL\nCODE:\n```\nuse std.textio.all;\nuse work.log_pkg.all;\nuse work.logger_pkg.all;\n```\n\n----------------------------------------\n\nTITLE: Including Additional Parameters for VHDL Procedures\nDESCRIPTION: Demonstrates how to extend VHDL procedures with the 'line_num' and 'file_name' parameters, and how to inform the location preprocessor about new procedures using raw HTML directives. This enables better debug information and code traceability.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_25\n\nLANGUAGE: vhdl\nCODE:\n```\nWith earlier VHDL standards you can add the ``line_num`` and ``file_name`` parameters to the **end** of the parameter list for the\nconvenience procedure:\n\n .. raw:: html\n    :file: additional_convenience_procedure.html\n\nThen let the location preprocessor know about the added procedure:\n\n .. raw:: html\n    :file: additional_subprograms.html\n```\n\n----------------------------------------\n\nTITLE: Example Usage of VHDL Logging in VUnit\nDESCRIPTION: References an example testbench demonstrating logging implementation and configuration. Serves as practical guidance for integrating the logging framework into actual test environments.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_31\n\nLANGUAGE: vhdl\nCODE:\n```\nExample\n-------\nA runnable example using logging can be found in :vunit_example:`Logging Example <vhdl/logging/>`.\n```\n\n----------------------------------------\n\nTITLE: Adding support for ActiveHDL custom simulation flags in VUnit\nDESCRIPTION: This snippet introduces logic to incorporate custom simulation flags specific to ActiveHDL into the VUnit setup, enabling simulation customization. Dependencies include the VUnit core and ActiveHDL environment. It processes user-specified flags and passes them to the simulator invocation, facilitating tailored simulation configurations.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/1.0.0.rst#_snippet_0\n\nLANGUAGE: Python\nCODE:\n```\ndef add_activehdl_flags(simulation_flags):\n    activehdl_flags = []\n    # Add custom ActiveHDL flags to the simulation\n    if 'activehdl' in simulation_flags:\n        activehdl_flags.extend(simulation_flags['activehdl'])\n    # Further processing or integration\n    return activehdl_flags\n```\n\n----------------------------------------\n\nTITLE: Conditional Logging in VHDL\nDESCRIPTION: Shows how to use conditional logging where a message is only logged if a condition is true.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_5\n\nLANGUAGE: VHDL\nCODE:\n```\nwarning_if(condition, \"warning message\");\nerror_if(condition, \"error message\");\nfailure_if(condition, \"failure message\");\n```\n\n----------------------------------------\n\nTITLE: Creating Identity Reusing Existing Parent (VHDL)\nDESCRIPTION: This VHDL snippet illustrates that when `id_pkg.get_id` is called with a path containing components that already exist in the identity tree (e.g., `tb_dut`), it efficiently reuses the existing parent identity rather than creating a duplicate. New identities are only generated for the previously unmapped parts of the path.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\nlibrary vunit_lib;\nuse vunit_lib.id_pkg.all;\n-- Assuming vc_x_id = get_id(\"tb_dut:vc_x\") has already been called,\n-- creating identities for :tb_dut: and :tb_dut:vc_x:\n\nconstant vc_y_id : id_t := get_id(vc_y_inst'path_name);\n-- get_id reuses the existing :tb_dut: identity.\n```\n\n----------------------------------------\n\nTITLE: Illustrating path_name Sensitivity to Structure (VHDL)\nDESCRIPTION: This VHDL snippet shows how adding structural elements like a block statement around component instantiations affects the value of the `path_name` attribute. The resulting path includes the block name, demonstrating that `path_name` is tied to the physical code structure rather than necessarily reflecting the logical testbench organization.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/id/user_guide.rst#_snippet_1\n\nLANGUAGE: VHDL\nCODE:\n```\nentity tb_dut is\nend entity;\n\narchitecture rtl of tb_dut is\n  component vc_x is\n    generic (name : string);\n  end component;\n  component vc_y is\n    generic (name : string);\n  end component;\nbegin\n  block_name: block\n  begin\n    vc_x_inst : vc_x\n      generic map (name => vc_x_inst'path_name);\n\n    vc_y_inst : vc_y\n      generic map (name => vc_y_inst'path_name);\n  end block;\nend architecture;\n```\n\n----------------------------------------\n\nTITLE: Controlling logger visibility for display in VHDL\nDESCRIPTION: Adjusts the visibility level of a logger for display handlers to include debug messages, demonstrating dynamic log level control at runtime.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_6\n\nLANGUAGE: VHDL\nCODE:\n```\nshow(main_logger, display_handler, debug);\n```\n\n----------------------------------------\n\nTITLE: Memory Model API in VHDL\nDESCRIPTION: This code snippet showcases the Memory Model API implemented in VHDL using the `memory_pkg.vhd` file within the VUnit framework. It facilitates verification of devices interacting with external memory. The API includes functions for allocating data buffers, setting read/write permissions, writing input data, setting expected output data, and reading output data.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/verification_components/memory_model.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\n.. literalinclude:: ../../vunit/vhdl/verification_components/src/memory_pkg.vhd\n   :caption: Memory model API\n   :language: vhdl\n   :lines: 7-\n```\n\n----------------------------------------\n\nTITLE: Verilog Parser Improvements: Robustness and Error Messages (Python)\nDESCRIPTION: This segment details enhancements made to the Verilog parser to improve its robustness and error messaging capabilities. These changes allow the parser to better handle malformed input, provide clearer diagnostic messages, and improve reliability during syntactic analysis of Verilog code. Dependencies include Verilog parsing libraries and error handling modules.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.53.0.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n// Verilog parser improvements in robustness and error messages.\n```\n\n----------------------------------------\n\nTITLE: Explicitly set path to GHDL executables - Console\nDESCRIPTION: This shows how to explicitly set the path to the GHDL executables using the `VUNIT_GHDL_PATH` environment variable. This is helpful when VUnit can't automatically locate the simulator or when a specific version of the simulator is required.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_5\n\nLANGUAGE: console\nCODE:\n```\nVUNIT_GHDL_PATH=/opt/ghdl/bin\n```\n\n----------------------------------------\n\nTITLE: Setting up Logger Hierarchy - VHDL\nDESCRIPTION: This VHDL code demonstrates how to set up a logging hierarchy in VUnit. It creates loggers based on path names and explicitly defines parent-child relationships.  It showcases how to retrieve loggers using `get_logger` function and how to configure loggers in a hierarchical manner.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_5\n\nLANGUAGE: vhdl\nCODE:\n```\n  architecture a of tb is\n  begin\n    main : process\n      constant main_logger : logger_t := get_logger(main'path_name); -- Hierarchy position based on path name\n    begin\n      test_runner_setup(runner, runner_cfg);\n\n      warning(main_logger, \"A warning message\");\n      info(main_logger, \"An information message\");\n      debug(main_logger, \"A debug message\"); -- By default debug messages are not visible on the display\n\n      show(get_logger(\"tb:vc\"), display_handler, debug);  -- Show debug messages in vc_logger subtree (defined below)\n\n      wait for 15 ns;\n      test_runner_cleanup(runner);\n    end process;\n\n    vc : block is\n      constant vc_logger    : logger_t := get_logger(vc'path_name);\n      constant alpha_logger : logger_t := get_logger(\"alpha\", vc_logger); -- Hierarchy position set as a child to vc_logger\n      constant beta_logger  : logger_t := get_logger(\"beta\", vc_logger);\n    begin\n      alpha : entity work.alpha_component generic map (logger => alpha_logger);\n      beta : entity work.beta_component generic map (logger => beta_logger);\n    end block;\n  end architecture;\n```\n\n----------------------------------------\n\nTITLE: Building and Running Custom Docker Image (Bash)\nDESCRIPTION: This Bash snippet shows the process of building a Docker image from a specified Dockerfile and then running a container using the newly created image. The `docker build` command creates the image tagged with `imageName` from the Dockerfile path, and the subsequent `docker run` command starts a container based on this custom image.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/container.rst#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\ndocker build -t imageName - < path/to/Dockerfile\ndocker run ... imageName ...\n```\n\n----------------------------------------\n\nTITLE: Pre-defined TCL functions for GUI - TCL\nDESCRIPTION: These are TCL functions pre-defined when opening a test case in the simulator GUI using the ``--gui`` flag. They allow for loading, running, compiling, and restarting the simulation directly from the TCL console within the GUI.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_4\n\nLANGUAGE: tcl\nCODE:\n```\n# vunit_help\n#   - Prints this help\n# vunit_load [vsim_extra_args]\n#   - Load design with correct generics for the test\n#   - Optional first argument are passed as extra flags to vsim\n# vunit_user_init\n#   - Re-runs the user defined init file\n# vunit_run\n#   - Run test, must do vunit_load first\n# vunit_compile\n#   - Recompiles the source files\n# vunit_restart\n#   - Recompiles the source files\n#   - and re-runs the simulation if the compile was successful\n```\n\n----------------------------------------\n\nTITLE: Executing VUnit Simulations in Docker Container (Bash)\nDESCRIPTION: This Bash snippet demonstrates how to run VUnit simulations within a Docker container using a pre-built `ghdl/vunit` image. It mounts the current host directory into the container, sets the working directory, and executes a series of commands inside the container via `sh -c` to find and run VUnit simulation scripts.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/container.rst#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\ndocker run --rm \\\n  -v /$(pwd)://work \\\n  -w //work \\\n  ghdl/vunit:llvm-master sh -c ' \\\n    VUNIT_SIMULATOR=ghdl; \\\n    for f in $(find ./ -name 'run.py'); do python3 $f; done \\\n  '\n```\n\n----------------------------------------\n\nTITLE: Cloning Git Repository with Submodules (Console)\nDESCRIPTION: Explains how to clone a Git repository and simultaneously initialize and update all its submodules recursively. This single command is convenient for creating a complete local copy of the repository including all referenced submodules, skipping the need for subsequent submodule commands.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_08_08_making_osvvm_a_submodule.rst#_snippet_1\n\nLANGUAGE: Console\nCODE:\n```\ngit clone --recursive https://github.com/VUnit/vunit.git\n```\n\n----------------------------------------\n\nTITLE: Message Passing Trace Log - Console\nDESCRIPTION: This code snippet illustrates the trace output of the message passing system in VUnit, showing the flow of messages between different components. The logs display the time, source, destination, and type of message being passed, providing valuable debugging information.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2018_02_12_vunit3.rst#_snippet_4\n\nLANGUAGE: console\nCODE:\n```\n      0 ps - vunit_lib:com -   TRACE - [2:- test sequencer -> memory BFM (read)] => memory BFM inbox\n  10000 ps - vunit_lib:com -   TRACE - memory BFM inbox => [2:- test sequencer -> memory BFM (read)]\n  20000 ps - memory BFM    -   DEBUG - Reading x\"21\" from address x\"80\"\n  20000 ps - vunit_lib:com -   TRACE - [3:2 memory BFM -> test sequencer (read reply)] => test sequencer inbox\n  30000 ps - vunit_lib:com -   TRACE - test sequencer inbox => [3:2 memory BFM -> test sequencer (read reply)]\n```\n\n----------------------------------------\n\nTITLE: Configuring actor inbox size and resizing in VHDL\nDESCRIPTION: Provides methods for setting and adjusting actor inbox sizes to control message buffering and flow control. Creation of actors with limited inbox capacity ensures flow regulation, while resizing can dynamically adapt system behavior. Uses `new_actor` with `inbox_size` parameter and `resize` procedures.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_22\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant my_actor : actor_t := new_actor(\"my actor\", inbox_size => 1);\n\nresize(my_actor, new_size => 2);\n```\n\n----------------------------------------\n\nTITLE: Embedding VUnit Test Status Badge in Markdown README\nDESCRIPTION: This Markdown snippet illustrates how to add a dynamic badge to a GitHub README file that displays the latest status of the VUnit Tests workflow. It uses the GitHub Actions badge URL pattern and links it to the workflow's run results page. This provides users and contributors with quick visual feedback on the health of the test suite, enhancing trust and visibility of continuous integration status.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/script.rst#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n[![](https://github.com/<user or organisation name>/<name of your repository>/workflows/VUnit%20Tests/badge.svg)](https://github.com/<user or organisation name>/<name of your repository>/actions)\n```\n\n----------------------------------------\n\nTITLE: Using Record in Testbench - VHDL\nDESCRIPTION: This VHDL code shows the declaration of a constant record `tb_cfg` initialized by calling the `decode` function.  The testbench uses the values stored in the `tb_cfg` record in a conditional `generate` statement that affects the debug data dumping process. The code demonstrates how to conditionally include debug operations based on the `dump_debug_data` record member.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_06_03_enable_your_simulator_to_handle_complex_top_level_generics.rst#_snippet_7\n\nLANGUAGE: vhdl\nCODE:\n```\nconstant tb_cfg : tb_cfg_t := decode(encoded_tb_cfg);\n\ndump_debug_data: if tb_cfg.dump_debug_data generate\n  process is\n  begin\n    for y in 0 to tb_cfg.image_height - 1 loop\n      for x in 0 to tb_cfg.image_width - 1 loop\n        wait until rising_edge(clk) and data_valid = '1';\n        debug(\"Dumping tons of debug data\");\n      end loop;\n    end loop;\n\n    dumping_done <= true;\n    wait;\n  end process;\nend generate dump_debug_data;\n```\n\n----------------------------------------\n\nTITLE: Plain VHDL Concurrent Processes Communication\nDESCRIPTION: This VHDL code illustrates the core of two processes communicating with each other using plain VHDL constructs. The `main` process provides input characters to an encryption device using the `encrypt` procedure, while the `encrypted_symbol_monitor` process verifies the output stream using the `verify_encrypted_sentence` procedure. It highlights the complexity of synchronization with wait statements and signalling.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_0\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Core of main process                  -- Core of encrypted_symbol_monitor process\nfor i in 1 to 10 loop                    loop\n  sentence <= create_random_sentence;      ready_to_verify <= true;\n  wait for 0 ns;                           wait on sentence'transaction;\n  encrypt(sentence);                       ready_to_verify <= false;\n  wait until ready_to_verify;              verify_encrypted_sentence(sentence);\nend loop;                                end loop;\n```\n\n----------------------------------------\n\nTITLE: Message handling in actor with wait-until-idle logic in VHDL\nDESCRIPTION: Extends actor message handling to process `wait_until_idle_msg`, invokes `handle_wait_until_idle`, and updates message type to prevent further processing. Facilitates modular synchronization within actor message loops, helping coordinate system-wide idling behavior.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_25\n\nLANGUAGE: VHDL\nCODE:\n```\nreceive(net, actor, request_msg);\nmsg_type := message_type(request_msg);\n\nhandle_wait_until_idle(net, msg_type, request_msg);\n\nif msg_type = write_msg then\n  ...\nelse\n  unexpected_msg_type(msg_type);\nend if;\n```\n\n----------------------------------------\n\nTITLE: Writing a Wait Statement Preprocessor for VHDL Using Python in VUnit\nDESCRIPTION: Provides a Python-based preprocessor class that scans VHDL source files, locates wait statements, and rewrites them to insert calls to log_active, enabling automatic logging of unprepared wait statements. The preprocessor is integrated into the VUnit test run environment using add_preprocessor. Requires Python, VUnit's preprocessor API, and knowledge of VHDL syntax. The input is VHDL source text; the output is an augmented VHDL file with enhanced wait logging.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_12\n\nLANGUAGE: Python\nCODE:\n```\n# Example Python preprocessor for wait statement instrumentation\nfrom vunit.ui.preprocessor import Preprocessor\nclass WaitStatementPreprocessor(Preprocessor):\n    def run(self, source):\n        # Insert log_active call into each wait statement found\n        # ... implementation ...\n        return source\n\n```\n\n----------------------------------------\n\nTITLE: Encapsulating Core Dump Processes for Error Analysis in VHDL\nDESCRIPTION: Displays a VHDL process for performing a core dump of internal DUT or control block states upon vunit_error activation, facilitating detailed error analysis. The process can be wrapped in pragmas to avoid synthesis, or placed in the testbench if simulator external naming is supported. Requires VHDL process constructs and accessible state signals; the trigger is vunit_error. Output is a set of logged state values at the error instant.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_14\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Example core dump process in VHDL\ncore_dump: process\nbegin\n    wait until vunit_error'event;\n    report \"Core dump: pipeline_state=... control_state=...\";\nend process;\n\n```\n\n----------------------------------------\n\nTITLE: Declaring VHDL Configurations for Specific Test Runner and DUT Architectures\nDESCRIPTION: Illustrates VHDL configuration declarations that bind specific architectures of the 'test_runner' entity (e.g., 'test_reset') and the DUT entity (e.g., 'rtl', 'behavioral') together. Each configuration defines a complete setup for one specific test run combination.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL configuration declarations combining DUT and test runner architectures.\n-- configuration test_reset_rtl of tb_flip_flop is\n--   for structural\n--     for dut_inst : flip_flop\n--       use entity work.flip_flop(rtl);\n--     end for;\n--     for test_runner_inst : test_runner\n--       use entity work.test_runner(test_reset);\n--     end for;\n--   end for;\n-- end configuration test_reset_rtl;\n-- -- Similar configuration for test_reset_behavioral would exist.\n-- (Actual code resides in img/vhdl_configuration/test_reset_configurations.html)\n```\n\n----------------------------------------\n\nTITLE: Setting Test Case Attributes Programmatically using VUnit Python API - Python\nDESCRIPTION: Illustrates how to assign an attribute to a test case in Python using the VUnit API. By calling my_test.set_attribute(\".requirement-117\", None), users can assign or overwrite attributes at runtime. No additional dependencies are required beyond the VUnit Python package. The attribute key must begin with a dot, and the value can be any basic type. Setting attributes through Python supersedes those defined via code comments.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/py/ui.rst#_snippet_2\n\nLANGUAGE: python\nCODE:\n```\nmy_test.set_attribute(\".requirement-117\", None)\n```\n\n----------------------------------------\n\nTITLE: Updating OSVVM Git Submodule in VUnit Project - Console\nDESCRIPTION: This snippet demonstrates how to initialize or update Git submodules recursively in an existing VUnit Git repository using the 'git submodule update --init --recursive' command. It is required when new submodules such as OSVVM are added to the project. No additional dependencies beyond a functional Git installation are required. The command ensures all nested submodules are properly checked out and available in the local repository structure.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/0.67.0.rst#_snippet_0\n\nLANGUAGE: console\nCODE:\n```\ngit submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Implementing Publish-Subscribe Pattern for Message Distribution\nDESCRIPTION: Illustrates the use of subscribe and publish functions to implement a publish-subscribe messaging pattern. The subscriber listens to all messages published by 'main', decodes message types, and processes messages accordingly, enabling flexible message handling.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_11\n\nLANGUAGE: VHDL\nCODE:\n```\nsubscribe(self, find(\"main\"), status);\nloop\n  receive(net, self, message);\n  case get_msg_type(message.payload.all) is\n    when start_verifying =>\n      sentence_msg := decode(message.payload.all);\n      verify_encrypted_sentence(sentence_msg.sentence, shift);\n    when set_shift_after_delay =>\n      shift_msg := decode(message.payload.all);\n      shift := shift_msg.value;\n    when others => null;\n  end case;\nend loop;\n```\n\n----------------------------------------\n\nTITLE: Plain VHDL Concurrent Processes Again\nDESCRIPTION: This VHDL code provides an alternative implementation of concurrent processes for the testbench. The `main` process generates sentences and encrypts them. The `encrypted_symbol_monitor` process waits for the `sentence'transaction` signal, and verifies the encrypted output. This code is another example of a less-readable testbench in VHDL.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_02_21_improving_vhdl_testbench_design_with_message_passing.rst#_snippet_3\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Core of main process                  -- Core of encrypted_symbol_monitor process\nfor i in 1 to 10 loop                    loop\n  sentence <= create_random_sentence;      ready_to_verify <= true;\n  wait for 0 ns;                           wait on sentence'transaction;\n  encrypt(sentence);                       ready_to_verify <= false;\n  wait until ready_to_verify;              verify_encrypted_sentence(sentence);\nend loop;                                end loop;\n```\n\n----------------------------------------\n\nTITLE: Receiving and Processing a Message in VHDL\nDESCRIPTION: Illustrates how a receiver actor waits for incoming messages via the 'receive' procedure which blocks until a message is available. The message content is extracted by popping objects in the same order they were pushed, and checked for correctness with 'check_equal'.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/com/user_guide.rst#_snippet_7\n\nLANGUAGE: vhdl\nCODE:\n```\nreceive(net, my_receiver, msg);\\ncheck_equal(pop_string(msg), \"10101010\");\\nmy_integer := pop(msg);\\ncheck_equal(my_integer, 17);\n```\n\n----------------------------------------\n\nTITLE: Function to check for pass file with timeout in Python\nDESCRIPTION: This code snippet implements a function that waits up to 10 seconds for a pass file to appear; if found within this interval, it returns True, otherwise False. It also considers the outcomes of pre_config and post_check functions to determine overall success or failure. This pattern is useful for synchronizing tests with file system states.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_4\n\nLANGUAGE: Python\nCODE:\n```\nreturn False\n\nsleep(1)\n\nreturn False\n```\n\n----------------------------------------\n\nTITLE: Creating Logger from Identity in VHDL\nDESCRIPTION: Demonstrates creating a logger directly from an identity object rather than a string name.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_3\n\nLANGUAGE: VHDL\nCODE:\n```\nconstant my_id : id_t := get_id(\"my_id\");\nconstant my_logger : logger_t := get_logger(my_id);\n```\n\n----------------------------------------\n\nTITLE: Adding and Prioritizing a Preprocessor in VUnit Python API\nDESCRIPTION: Demonstrates how to register a preprocessor (like WaitStatementPreprocessor) with a VUnit project using the add_preprocessor method. The order argument determines execution precedence relative to other preprocessors, such as the location preprocessor. This ensures log_active is inserted before location tagging. Requires VUnit installed in the Python test environment; parameters are the preprocessor instance and order.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_13\n\nLANGUAGE: Python\nCODE:\n```\n# Adding preprocessor to VUnit project\nvu = VUnit.from_argv()\nvu.add_preprocessor(WaitStatementPreprocessor(), order=90)  # Before location preprocessor\n```\n\n----------------------------------------\n\nTITLE: Selecting DUT Architecture using VHDL Configurations in VHDL\nDESCRIPTION: Presents the VHDL structure required for selecting the DUT architecture using VHDL configurations instead of generics. This involves a component declaration for the DUT, a component instantiation, and separate configuration declarations for each architecture ('rtl', 'behavioral') to be used.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2023_08_26_vhdl_configurations.rst#_snippet_2\n\nLANGUAGE: VHDL\nCODE:\n```\n-- VHDL testbench structure for DUT selection via VHDL configurations.\n-- 1. Component declaration for the DUT (e.g., 'flip_flop').\n-- 2. Component instantiation of the declared DUT.\n-- 3. Configuration declarations (e.g., 'rtl_conf', 'behav_conf') binding\n--    the component instance to specific DUT entities/architectures.\n-- (Actual code resides in img/vhdl_configuration/selecting_dut_with_vhdl_configuration.html)\n```\n\n----------------------------------------\n\nTITLE: Accessing Test Bench Info via TCL Variables\nDESCRIPTION: Explains that the TCL variable `vunit_tb_name` is now defined in Riviera-PRO, ModelSim/Questa, and Active-HDL during the evaluation of simulator init files (`<simulator>.init_file`), holding the top-level design unit name. Additionally, `vunit_tb_path` is defined in Active-HDL during `activehdl.init_file.gui` evaluation.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_5\n\nLANGUAGE: TCL\nCODE:\n```\n# Example access within a simulator init script\nputs \"Running test bench: $vunit_tb_name\"\n```\n\nLANGUAGE: TCL\nCODE:\n```\n# Active-HDL GUI init script specific variable\nputs \"Test bench path: $vunit_tb_path\"\n```\n\n----------------------------------------\n\nTITLE: Customizing GHDL/VUnit Docker Image (Dockerfile)\nDESCRIPTION: This Dockerfile defines a custom Docker image based on an existing `ghdl/vunit` image. The `FROM` instruction specifies the base image, and the `RUN` instruction installs additional Python dependencies like `pytest` and `matplotlib` using `pip`, extending the base image's capabilities.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/ci/container.rst#_snippet_2\n\nLANGUAGE: dockerfile\nCODE:\n```\nFROM ghdl/vunit:llvm-master\n\nRUN pip install pytest matplotlib\n```\n\n----------------------------------------\n\nTITLE: Adding MPL Copyright Header for Python Files\nDESCRIPTION: The standard Mozilla Public License copyright header required at the beginning of each file when contributing to VUnit. Contributors must give copyright to Lars Asplund.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/contributing.rst#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\n# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this file,\n# You can obtain one at http://mozilla.org/MPL/2.0/.\n#\n# Copyright (c) 2014-2024, Lars Asplund lars.anders.asplund@gmail.com\n```\n\n----------------------------------------\n\nTITLE: Decorating Log Messages with Event Information using decorate in VHDL\nDESCRIPTION: Applies the decorate function to combine automated event details with user-provided messages in log entries, preserving both the context of the runner_timeout event and developer-added explanations. Suitable for check procedures and custom logging with VUnit; depends on the decorate/result function from the VUnit logging library. Parameters are the event and the custom message; outputs a decorated message in simulation logs.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/data_types/event_user_guide.rst#_snippet_8\n\nLANGUAGE: VHDL\nCODE:\n```\n-- Decorating a log message with event information\nwait until runner_timeout'event and log_active(runner_timeout, logger, decorate(\"Wait for output data\"));\n\n```\n\n----------------------------------------\n\nTITLE: Initiating a Read Transaction in VHDL\nDESCRIPTION: This VHDL snippet demonstrates initiating a read transaction using VUnit's message passing capabilities. It creates a new message, pushes the address to be read, and sends the message to the target component (brain). It depends on the VUnit library for message creation and sending.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_12_14_vunit_bfms_as_simple_as_emailing.rst#_snippet_9\n\nLANGUAGE: vhdl\nCODE:\n```\n-- Initiate a read transaction\n\n  read_msg := new_msg(brain_read_msg);\n  push_integer(read_msg, address);\n  send(net, brain, read_msg);\n```\n\n----------------------------------------\n\nTITLE: Running Unit Tests with Pytest\nDESCRIPTION: Example command for running VUnit's unit tests using pytest, which is required for running the acceptance tests due to specific features for allowing certain tests to fail.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/contributing.rst#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\npytest tests/unit/\n```\n\n----------------------------------------\n\nTITLE: Adding a VUnit Test Status Badge to README.md\nDESCRIPTION: Markdown code for adding a status badge to a project's README.md file that displays the current status of VUnit tests and links to the GitHub Actions workflow results page.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2020_08_12_continuous_integration_with_vunit_action_in_10_lines_of_code.rst#_snippet_2\n\nLANGUAGE: markdown\nCODE:\n```\n[![](https://github.com/<user or organisation name>/<name of your repository>/workflows/VUnit%20Tests/badge.svg)](https://github.com/<user or organisation name>/<name of your repository>/actions)\n```\n\n----------------------------------------\n\nTITLE: Open test case in GUI - Python\nDESCRIPTION: This command opens the simulator GUI for the specified test case ('my_test_case') using the --gui flag. The test bench is loaded and ready for debugging with features like single stepping, breakpoints, and waveform viewing.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/cli.rst#_snippet_3\n\nLANGUAGE: console\nCODE:\n```\n> python run.py --gui my_test_case &\n```\n\n----------------------------------------\n\nTITLE: Configuring visibility of hierarchical loggers\nDESCRIPTION: Applies visibility settings to a parent logger (`vc_logger`) and propagates them to its descendants (`alpha`, `beta`), enabling centralized log level management in hierarchical logging.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_7\n\nLANGUAGE: VHDL\nCODE:\n```\nshow(vc_logger, display_handler, (debug, trace));\n```\n\n----------------------------------------\n\nTITLE: Configuring GHDL Flags (Python/Config)\nDESCRIPTION: Highlights the replacement of the `ghdl.flags` configuration option. Users should now use `ghdl.a_flags` to specify analysis flags for the GHDL simulator.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/release_notes/5.0.0.dev1.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n# Old (Removed)\n# vu.set_sim_option(\"ghdl.flags\", \"...\")\n\n# New\nvu.set_sim_option(\"ghdl.a_flags\", \"--std=08\")\n```\n\n----------------------------------------\n\nTITLE: Full Time Resolution Logging in VHDL\nDESCRIPTION: Shows how to display simulation time with full resolution in logs.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_12\n\nLANGUAGE: VHDL\nCODE:\n```\n0.123456 us - INFO - root - hello world\n```\n\n----------------------------------------\n\nTITLE: Fixed Decimal Places in Time Display\nDESCRIPTION: Demonstrates logging with a fixed number of decimal places in the time display.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_13\n\nLANGUAGE: VHDL\nCODE:\n```\n123.46 ns - INFO - root - hello world\n```\n\n----------------------------------------\n\nTITLE: Updating and Initializing Git Submodules (Console)\nDESCRIPTION: Explains how to update and initialize Git submodules within an existing repository clone. This command fetches and checks out the correct commit for each submodule, recursively handling nested ones, and is necessary to populate submodule directories after a standard pull operation introduces a new or empty submodule reference.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_08_08_making_osvvm_a_submodule.rst#_snippet_0\n\nLANGUAGE: Console\nCODE:\n```\npath/to/my/vunit/repo> git submodule update --init --recursive\n```\n\n----------------------------------------\n\nTITLE: Python Function to Generate Pre-Configuration for MATLAB Plotting\nDESCRIPTION: Defines a higher-order Python function that creates and returns a pre-configuration function for VUnit, which calls Octave with specific arguments to generate visualizations before running the test. It captures parameters via closure, demonstrating the use of nested functions.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_2\n\nLANGUAGE: Python\nCODE:\n```\n  def make_pre_config(plot_title, num_of_data_sets):\n      def pre_config(output_path):\n          p = run([\"octave\", join(root, \"octave\", \"visualize.m\"), output_path, plot_title, str(num_of_data_sets)])\n\n          return p.returncode == 0\n\n      return pre_config\n```\n\n----------------------------------------\n\nTITLE: MATLAB Script for Data Collection and Monotonicity Verification\nDESCRIPTION: A MATLAB script that reads CSV data files generated by the VUnit testbench, plots the data, and checks whether the data series is monotonically increasing. Creates 'pass' or 'fail' flags based on this verification, which are used for post-test check logic.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_23_vunit_matlab_integration.rst#_snippet_3\n\nLANGUAGE: MATLAB\nCODE:\n```\n  % Parse arguments\n  arg_list = argv;\n  output_path = arg_list{1};\n  plot_title = arg_list{2};\n  num_of_data_sets = arg_list{3};\n\n  % Configure figure\n  fig = figure('Name', 'Testbench Progress');\n  title(plot_title)\n  xlabel(\"x\")\n  ylabel(\"y\")\n  xlim([0 100])\n  ylim([0 100])\n  hold on\n\n  % Wait on data set files and plot\n  data = [];\n  for s = 1:str2num(num_of_data_sets)\n    file_name = fullfile(output_path, strcat(\"data_set_\", int2str(s), \".csv\"));\n    while not(exist(file_name, 'file'))\n      pause(0.1)\n    end\n    data_set = csvread(file_name);\n    data = [data, data_set];\n    x = 0 : length(data) - 1;\n    plot(x, data)\n  end\n\n  % Verify that the data set is monotonically increasing\n  if sum(data(1:length(data)-1) >= data(2:length(data))) == 0\n    f = fopen(fullfile(output_path, \"pass\"), \"w\");\n  else\n    f = fopen(fullfile(output_path, \"fail\"), \"w\");\n    disp(\"ERROR: Output is not monotonically increasing!\")\n  end\n  fclose(f);\n\n  % Quit when figure is closed\n  pause(1)\n  waitfor(fig);\n```\n\n----------------------------------------\n\nTITLE: Verbose Format Log Output Example in VHDL\nDESCRIPTION: Shows the output format of logs using the default verbose formatter.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_10\n\nLANGUAGE: VHDL\nCODE:\n```\n0 fs - INFO - root - hello world\n```\n\n----------------------------------------\n\nTITLE: Time Unit Auto-formatting in Logs\nDESCRIPTION: Demonstrates how auto time unit formatting displays time with appropriate units.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_11\n\nLANGUAGE: VHDL\nCODE:\n```\n123.456 ns - INFO - root - hello world\n```\n\n----------------------------------------\n\nTITLE: Log Output Example with Different Formats in VHDL\nDESCRIPTION: Shows the resulting output when using different log formats with the same message.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/logging/user_guide.rst#_snippet_9\n\nLANGUAGE: VHDL\nCODE:\n```\nhello world\nINFO: hello world\n0 fs,INFO,,,hello world,,\n```\n\n----------------------------------------\n\nTITLE: Using info procedure for logging in VHDL-93\nDESCRIPTION: Demonstrates the basic approach to logging in VHDL-93 using a logger record and a procedure call. Highlights the necessity of shared variables and manual configuration.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2017_11_07_vunit_3_0_while_waiting_for_vhdl_2017.rst#_snippet_0\n\nLANGUAGE: VHDL\nCODE:\n```\ninfo(logger, \"Hello world in VHDL-93\");\n```\n\n----------------------------------------\n\nTITLE: Updating Git Remote URL for VUnit Repository\nDESCRIPTION: Command to update the remote URL for the VUnit repository after its migration to a new GitHub organization account. This ensures your local repository points to the correct remote location.\nSOURCE: https://github.com/vunit/vunit/blob/master/docs/blog/2016_01_26_welcome_to_our_new_website.rst#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\ngit remote set-url origin https://github.com/VUnit/vunit.git\n```"
  }
]