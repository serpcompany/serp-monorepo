[
  {
    "owner": "danielgtaylor",
    "repo": "huma",
    "content": "TITLE: Setting Up Chi Router and Huma API Instance in Golang\nDESCRIPTION: This code sets up an HTTP router using Chi and initializes a Huma API instance with it. Key dependencies include the Chi router library, Huma, and Huma's Chi adapter. It establishes a ready-to-use routing stack where further operations can be registered. The server is started using http.ListenAndServe on localhost port 8888. The snippet also includes the model definition for GreetingOutput for completeness.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router & API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// TODO: Register operations...\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Huma API Using Built-in Go Router\nDESCRIPTION: This snippet initializes the router using Go's standard http.ServeMux instead of Chi and creates a Huma API instance with the 'humago' adapter. It is an alternative setup recommended for Go 1.22+ users preferring the builtin HTTP router. All other elements remain compatible with the Huma API stack.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nrouter := http.NewServeMux()\napi := humago.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n```\n\n----------------------------------------\n\nTITLE: Defining JSON Schema Constraints for API Request/Response Structs - Go\nDESCRIPTION: Demonstrates how Go struct tags are used to annotate fields with JSON Schema-specific constraints and documentation, which are then used for both documentation and validation purposes in an API context. Dependencies include Go and typical struct syntax with use of tags such as json, doc, minLength, and maximum. The snippet requires that fields are tagged to specify minimum and maximum values or lengths, and these affect the corresponding generated JSON Schema. Inputs are struct instances with annotated fields; output is the generated schema and enforced request/response validation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-validation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype Person struct {\n    Name string `json:\"name\" doc:\"Person's name\" minLength:\"1\" maxLength:\"80\"`\n    Age  uint   `json:\"age,omitempty\" doc:\"Person's age\" maximum:\"120\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Security Scheme and Operation in Huma (Go)\nDESCRIPTION: This snippet demonstrates how to set up a bearer token security scheme in the API configuration and apply it to an operation. It shows the process of creating a custom security scheme and adding it to an operation's configuration.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/openapi-generation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t\t\"bearer\": {\n\t\t\tType: \"http\",\n\t\t\tScheme: \"bearer\",\n\t\t\tBearerFormat: \"JWT\",\n\t\t},\n\t}\napi := humachi.New(router, config)\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tSecurity: []map[string][]string{\n\t\t{\"bearer\": {}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Input Validation with Resolver Methods in Huma (Go)\nDESCRIPTION: This Go snippet demonstrates how to implement a custom resolver method on an input struct (`MyInput`) to perform advanced validation logic beyond built-in validators. The `Resolve` method checks for a specific invalid value and returns a slice of errors if validation fails. It also includes an interface assertion to verify compliance with the required resolver interface in Huma. Dependencies include the Huma library, and key input is the struct field to be validated. Output consists of error details, returned when constraints are violated.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/custom-validation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\\n\\tThingID string `path:\"thing-id\"`\\n}\\n\\nfunc (i *MyInput) Resolve(ctx huma.Context) []error {\\n\\tif i.ThingID == \"bad\" {\\n\\t\\treturn []error{&huma.ErrorDetail{\\n\\t\\t\\tLocation: \"path.thing-id\",\\n\\t\\t\\tMessage:  \"Thing ID cannot be 'bad'\",\\n\\t\\t\\tValue:    i.ThingID,\\n\\t\\t}}\\n\\t}\\n\\treturn nil\\n}\\n\\nvar _ huma.Resolver = (*MyInput)(nil)\n```\n\n----------------------------------------\n\nTITLE: Initializing Huma API with CLI and Chi Router in Go\nDESCRIPTION: This snippet shows the complete setup of a Huma API application. It includes CLI configuration, Chi router initialization, and definition of a greeting endpoint. The code demonstrates Huma's integration with CLI options, request parameter handling, and response structuring.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/README.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI. Pass `--port` or set the `SERVICE_PORT` env var.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Add the operation handler to the API.\n\t\thuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Request Input Struct with Various Parameter Types in Go\nDESCRIPTION: Demonstrates how to define a struct for handling different types of request inputs including path, query, header parameters, and both structured and raw body.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n\tID      string `path:\"id\"`\n\tDetail  bool   `query:\"detail\" doc:\"Show full details\"`\n\tAuth    string `header:\"Authorization\"`\n\tBody    MyBody\n\tRawBody []byte\n}\n```\n\n----------------------------------------\n\nTITLE: Implementing Pet Store API Skeleton with Huma in Go\nDESCRIPTION: This Go code demonstrates the implementation of a Pet Store API skeleton using Huma. It defines data models, API operations, and includes a CLI command to generate OpenAPI specifications. The code showcases Huma's approach to combining design-first and code-first methodologies.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/why/what-about-design-first.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/spf13/cobra\"\n)\n\ntype Category struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Category ID\"`\n\tName string `json:\"name\" example:\"Cats\" doc:\"Category name\"`\n}\n\ntype Tag struct {\n\tID   int    `json:\"id\" example:\"1\" doc:\"Tag ID\"`\n\tName string `json:\"name\" example:\"cute\" doc:\"Tag name\"`\n}\n\ntype Pet struct {\n\tID        int       `json:\"id\" example:\"1\" doc:\"Pet ID\"`\n\tCategory  *Category `json:\"category\" doc:\"Category that the pet belongs to\"`\n\tName      string    `json:\"name\" example:\"Fluffy\" doc:\"Pet name\"`\n\tPhotoURLs []string  `json:\"photoUrls\" example:\"https://example.com/fluffy.jpg\" doc:\"Photo URLs for the pet\"`\n\tTags      []Tag     `json:\"tags\" example:\"cute\" doc:\"Tags for the pet\"`\n\tStatus    string    `json:\"status\" example:\"available\" doc:\"Pet status\" enum:\"available,pending,sold\"`\n}\n\ntype PetID struct {\n\tID int `path:\"petId\" example:\"1\" doc:\"Pet ID\"`\n}\n\nfunc main() {\n\tvar api huma.API\n\n\tcli := humacli.New(func(hooks humacli.Hooks, options *struct{}) {\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"Pet Store\", \"1.0.0\"))\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"post-pet\",\n\t\t\tMethod:      \"POST\",\n\t\t\tPath:        \"/pet\",\n\t\t\tSummary:     \"Add a new pet\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tBody Pet\n\t\t}) (*struct{}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-pet\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/{petId}\",\n\t\t\tSummary:     \"Get a pet\",\n\t\t}, func(ctx context.Context, input *PetID) (*struct {\n\t\t\tBody Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"find-pet-by-status\",\n\t\t\tMethod:      \"GET\",\n\t\t\tPath:        \"/pet/findByStatus\",\n\t\t\tSummary:     \"Find a pet by status\",\n\t\t}, func(ctx context.Context, input *struct {\n\t\t\tStatus string `path:\"status\" example:\"available\" doc:\"Status to filter by\" enum:\"available,pending,sold\"`\n\t\t}) (*struct {\n\t\t\tBody []Pet\n\t\t}, error) {\n\t\t\treturn nil, nil\n\t\t})\n\t})\n\n\tcli.Root().AddCommand(&cobra.Command{\n\t\tUse: \"openapi\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\tb, err := api.OpenAPI().MarshalJSON()\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tfmt.Println(string(b))\n\t\t},\n\t})\n\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Field Optionality and Requirement in API Schema - Go\nDESCRIPTION: Shows a Go struct with tagged fields illustrating how optional and required properties are configured for API models via tags such as omitempty, omitzero, and required. No extra dependencies beyond Go struct tags are needed. Each annotation modifies the required/optional status of the field in the generated JSON Schema, affecting inputs that must be validated during API calls. All annotation patterns are exhaustively demonstrated, clarifying the impact of omitempty, omitzero, and explicit required flags on schema validation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-validation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype MyStruct struct {\n    // The following are all required.\n    Required1 string  `json:\"required1\"`\n    Required2 *string `json:\"required2\"`\n    Required3 string  `json:\"required3,omitempty\" required:\"true\"`\n\n    // The following are all optional.\n    Optional1 string  `json:\"optional1,omitempty\"`\n    Optional2 string  `json:\"optional2,omitzero\"`\n    Optional3 *string `json:\"optional3,omitempty\"`\n    Optional4 *string `json:\"optional4,omitempty,omitzero\"`\n    Optional5 string  `json:\"optional5\" required:\"false\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Structured Response Body - Huma - Go\nDESCRIPTION: Shows defining a custom struct to be used as an HTTP response body in Huma, assigning it via the special Body field on the output struct. The response's JSON serialization is customizable via struct tags. Automatically infers Content-Type for serialization. Dependencies: Go, Huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ntype MyBody struct {\n\tName string `json:\"name\"`\n}\n\ntype MyOutput struct {\n\tBody MyBody\n}\n\n```\n\n----------------------------------------\n\nTITLE: Defining Input Structs with Built-in JSON Schema Validators in Go\nDESCRIPTION: This Go code snippet defines a struct (`MyInput`) with fields decorated by struct tags that specify validation rules leveraging Huma's native support for JSON Schema validators. Each field represents a different type of input (path, query) and is constrained using tags such as `maxLength`, `enum`, and `maximum`. This enables automatic enforcement of input validity without manual checks. Prerequisites are the Huma framework and a Go environment; expected inputs are provided via HTTP path and query parameters, and violations will result in validation errors.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/custom-validation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\\n\\tThingID string `path:\"thing-id\" maxLength:\"12\"`\\n\\tTag     string `query:\"tag\" enum:\"foo,bar,baz\"`\\n\\tSales   uint   `query:\"sales\" maximum:\"1000\"`\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Operation with Default Status Code - Huma - Go\nDESCRIPTION: Demonstrates registering an API operation using Huma where the default response status code is set by specifying the DefaultStatus field in the huma.Operation struct. The handler function is designed to accept a context and input, returning a struct pointer or error, although it performs no logic here. Requires the Huma framework, Go context, and an input type called ThingRequest. Useful for customizing default status codes per endpoint.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Register an operation with a default status code of 201.\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"create-thing\",\n\tMethod:       http.MethodPost,\n\tPath:         \"/things\",\n\tSummary:      \"Create a thing\",\n\tDefaultStatus: 201,\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Convenience Method for GET Operation\nDESCRIPTION: Demonstrates using the convenience method huma.Get for registering GET operations with auto-generated operation ID and summary.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/operations.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nhuma.Get(api, \"/things/{thing-id}\", func(ctx context.Context, input *YourInput) (*YourOutput, error) {\n    // ... Implementation goes here ...\n})\n```\n\n----------------------------------------\n\nTITLE: Registering Huma Operation with Extended Metadata for Enhanced OpenAPI Docs in Golang\nDESCRIPTION: This advanced snippet registers the GET /greeting/{name} operation with Huma using the Register function, allowing detailed metadata for OpenAPI documentation, including operation ID, tags, summary, and description. The route handler remains the same, constructing a GreetingOutput response from the provided path parameter. Dependencies are the same as for other Huma operations, but the enhanced metadata allows richer documentation for automated tools.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router & API\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Response Headers with Struct Tags - Huma - Go\nDESCRIPTION: Shows how to attach HTTP response headers to a struct using tags in Go. Demonstrates a response struct with fields for Content-Type, Last-Modified (as time.Time), and a custom integer header, mapping struct fields to header names. Requires the Huma framework and Go's time package. Maintains headers type-safely and allows custom time formats.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Example struct with several headers\ntype MyOutput struct {\n\tContentType  string    `header:\"Content-Type\"`\n\tLastModified time.Time `header:\"Last-Modified\"`\n\tMyHeader     int       `header:\"My-Header\"`\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing CLI Options for Port Configuration in Go API Service\nDESCRIPTION: This Go code demonstrates how to add runtime configuration to a Huma API service by implementing command-line options using the humacli package. It specifically shows how to make the network port configurable while maintaining a RESTful greeting endpoint.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/service-configuration.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tDescription: \"Get a greeting for a person by name.\",\n\t\t\tTags:        []string{\"Greetings\"},\n\t\t}, func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Composable Operation with Struct Embedding - Huma - Go\nDESCRIPTION: This snippet defines two reusable Go structs, AuthParam and PaginationParams, each annotated for HTTP header and query parameter extraction, respectively. These structs are embedded anonymously within the handler input struct, allowing Huma to gather request data automatically when registering a new operation (via huma.Register). The endpoint '/things' is registered as a GET operation, extracting authentication and pagination parameters from the incoming request. Dependencies include the github.com/danielgtaylor/huma/v2 package and standard Go context, HTTP, and fmt libraries. Expected input includes suitable 'Authorization' header and optional query parameters; the handler logs these values and returns an empty result.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_6\n\nLANGUAGE: Go\nCODE:\n```\ntype AuthParam struct {\n\tAuthorization string `header:\"Authorization\"`\n}\n\ntype PaginationParams struct {\n\tCursor string `query:\"cursor\"`\n\tLimit  int    `query:\"limit\"`\n}\n\n// ... Later in the code\nhuma.Register(api, huma.Operation{\n\tOperationID: \"list-things\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/things\",\n\tSummary:     \"Get a filtered list of things\",\n}, func(ctx context.Context, input *struct {\n\t// Embed both structs to compose your input.\n\tAuthParam\n\tPaginationParams\n}) (*struct{}, error) {\n\tfmt.Printf(\"Auth: %s, Cursor: %s, Limit: %d\\n\", input.Authorization, input.Cursor, input.Limit)\n\treturn nil, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering Error-Returning Handlers - Huma - Go\nDESCRIPTION: Demonstrates registering an API handler in Go using the Huma framework that returns an HTTP 404 error via the huma.Error404NotFound utility function. Requires Go, Huma package, an API instance, and a properly defined input struct. The function returns an HTTP error if an entity is not found, and illustrates error handling inside handler functions.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-errors.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-thing\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/things/{thing-id}\",\n\t\tSummary:     \"Get a thing by ID\",\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t\t// Return a 404 Not Found error\n\t\treturn nil, huma.Error404NotFound(\"thing not found\")\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Cookie Input with Custom Type in Go\nDESCRIPTION: Demonstrates how to define a struct field for accessing an entire cookie using the http.Cookie type in Go.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n\tSession http.Cookie `cookie:\"session\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Models with Huma in Go\nDESCRIPTION: This Go snippet demonstrates how to validate a struct representing a model (`MyExample`) against a JSON Schema using the Huma library. The code defines the struct with schema tags, unmarshals example JSON into an interface, and then applies validation via `huma.NewModelValidator()`. Required dependencies include the Go standard library packages `encoding/json`, `reflect`, `fmt`, and the external `huma` package. Key parameters: the struct type provides schema, and validation is run against dynamic JSON input. The function returns errors if schema or value constraints are violated. The validator is not goroutine-safe, and validation must be performed in a single-threaded context unless using more flexible functions.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/model-validation.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyExample struct {\n\tName string `json:\"name\" maxLength:\"5\"`\n\tAge int `json:\"age\" minimum:\"25\"`\n}\n\nvar value any\njson.Unmarshal([]byte(`{\"name\": \"abcdefg\", \"age\": 1}`), &value)\n\nvalidator := huma.NewModelValidator()\nerrs := validator.Validate(reflect.TypeOf(MyExample{}), value)\nif errs != nil {\n\tfmt.Println(\"Validation error\", errs)\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Struct Defaults and Field Validation with Huma in Go\nDESCRIPTION: This snippet shows how to define a Go struct for API input using the Huma framework, specifically demonstrating use of a pointer to a boolean field with a `default` tag. The `Enabled` field is a pointer, allowing the server to distinguish between an absent value (apply the default) and an explicit false (use the client value). Dependencies are Huma and Go's encoding/json. Inputs are parsed JSON bodies; output is a struct with defaulted or user-supplied fields. This pattern prevents zero values from clashing with defaults.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-validation.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n\tBody struct {\n\t\tEnabled *bool `json:\"enabled\" default:\"true\"`\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining CLI Options and Running the CLI - Cobra and humacli in Go\nDESCRIPTION: This Go snippet defines an Options struct with fields for debug, host, and port, using struct tags for documentation and option shortcuts. It demonstrates creating a CLI with humacli, passing option values to a callback function, and running the CLI to parse command-line arguments. Dependencies include the humacli package and Go standard libraries; inputs include CLI arguments or environment variables, and outputs are handled by printing to stdout.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// First, define your input options.\ntype Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n\nfunc main() {\n\t// Then, create the CLI.\n\tcli := humacli.New(func(hooks humacli.Hooks, opts *Options) {\n\t\tfmt.Printf(\"I was run with debug:%v host:%v port%v\\n\",\n\t\t\topts.Debug, opts.Host, opts.Port)\n\t})\n\n\t// Run the thing!\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Group with Middleware and Handler - huma (Go)\nDESCRIPTION: This snippet instantiates a new huma.Group with the specified prefix, applies authentication middleware, and registers a GET operation on '/users'. The function passed as the last argument defines the handler for the '/v1/users' endpoint. Required dependencies are huma, Go's context package, and the referenced middleware and response types. Inputs are the context and an input struct pointer; the output is either a pointer to UsersResponse or an error. The snippet demonstrates chaining group features in huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ngrp := huma.NewGroup(api, \"/v1\")\ngrp.UseMiddleware(authMiddleware)\n\nhuma.Get(grp, \"/users\", func(ctx context.Context, input *struct{}) (*UsersResponse, error) {\n\t// ...\n})\n```\n\n----------------------------------------\n\nTITLE: Setting Cookies in HTTP Response - Huma - Go\nDESCRIPTION: Provides an example for setting a cookie in a HTTP response by defining a struct field of type http.Cookie with a header tag. The Huma operation registers a handler that populates SetCookie, assigning name and value. Dependencies: Go's net/http for http.Cookie, context, and Huma. Supports setting multiple cookies using a slice type.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype MyOutput struct {\n\tSetCookie http.Cookie `header:\"Set-Cookie\"`\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"set-cookie\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/set-cookie\",\n\tSummary:     \"Set a cookie\",\n}, func(ctx context.Context, *struct{}) (*MyOutput, error) {\n\t// Create a response and set the cookie\n\tresp := &MyOutput{\n\t\tSetCookie: http.Cookie{\n\t\t\tName:  \"session\",\n\t\t\tValue: \"123\",\n\t\t},\n\t}\n\treturn resp, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Accessing Context Values in Handlers - Go\nDESCRIPTION: This Go code snippet demonstrates how to access custom context values set by middleware within a Huma operation handler. It shows retrieval and use of the value alongside a response object construction. Dependencies: github.com/danielgtaylor/huma/v2, standard context, fmt. Input is the context and request parameters; output is a greeting response. The operation expects a key set by previous middleware.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\nhuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\\n\\t\\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\\n\\t}) (*GreetingOutput, error) {\\n\\t\\t// \"some-value\"\\n\\t\\tctx.Value(\"some-key\")\\n\\t\\tresp := &GreetingOutput{}\\n\\t\\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\\n\\t\\treturn resp, nil\\n\\t})\n```\n\n----------------------------------------\n\nTITLE: Defining Custom Option Struct with Tags - Go\nDESCRIPTION: This Go code snippet shows how to declare an Options struct for CLI configuration with boolean, string, and integer fields. Struct tags are used to add descriptions, set default values, and specify short argument names for each option. This enables automatic parsing, documentation, and validation of command-line inputs by humacli and Cobra.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype Options struct {\n\tDebug bool   `doc:\"Enable debug logging\"`\n\tHost  string `doc:\"Hostname to listen on.\"`\n\tPort  int    `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Dynamic Status Code via Response Struct Field - Huma - Go\nDESCRIPTION: Illustrates how to dynamically set the HTTP response status code by including a Status field in the response struct. The code registers a GET operation with Huma, and based on the input's ID, sets Status to 200 or 250. This approach is less common but available for scenarios where the status code must change per request. Dependencies: Huma, Go's context package, and a ThingRequest type.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype ThingResponse struct {\n\tStatus int\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"get-thing\",\n\tMethod:       http.MethodGet,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Get a thing by ID\",\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Create a response and set the dynamic status\n\tresp := &ThingResponse{}\n\tif input.ID < 500 {\n\t\tresp.Status = 200\n\t} else {\n\t\t// This is a made-up status code used for newer things.\n\t\tresp.Status = 250\n\t}\n\treturn resp, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Providing Exhaustive Validation via Resolvers and Registering Huma Operations in Go\nDESCRIPTION: This detailed Go example shows how to utilize custom types with resolver logic (`IntNot3`) for advanced input validation across multiple request components (path, query, headers, and JSON body). The `Resolve` method rejects any value that is a nonzero multiple of three, demonstrating how exhaustive validation errors are collected and reported. It illustrates registering a Huma API operation using the Chi router and wiring up CLI entrypoints via `humacli`. Dependencies are Huma, Chi router, and standard Go libraries; inputs come from various HTTP request parts, and validation failures generate structured error responses.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/custom-validation.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// This example shows how to use resolvers to provide additional validation\\n// for params and body fields, and how exhaustive errors are returned.\\n//\\n//\\t# Example call returning seven errors\\n//\\trestish put :8888/count/3?count=15 -H Count:-3 count:9, nested.subCount: 6\\n//\\n//\\t# Example success\\n//\\trestish put :8888/count/1 count:2, nested.subCount: 4\\npackage main\\n\\nimport (\\n\\t\"context\"\\n\\t\"fmt\"\\n\\t\"net/http\"\\n\\n\\t\"github.com/danielgtaylor/huma/v2\"\\n\\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\\n\\t\"github.com/danielgtaylor/huma/v2/humacli\"\\n\\t\"github.com/go-chi/chi/v5\"\\n)\\n\\n// Options for the CLI.\\ntype Options struct {\\n\\tPort int `doc:\"Port to listen on.\" short:\"p\" default:\"8888\"`\\n}\\n\\n// Create a new input type with additional validation attached to it.\\ntype IntNot3 int\\n\\n// Resolve is called by Huma to validate the input. Prefix is the current\\n// path like `path.to[3].field`, e.g. `query.count` or `body.nested.subCount`.\\n// Resolvers can also be attached to structs to provide validation across\\n// multiple field combinations, e.g. \"if foo is set then bar must be a\\n// multiple of foo's value\". Use `prefix.With(\"bar\")` in that scenario.\\nfunc (i IntNot3) Resolve(ctx huma.Context, prefix *huma.PathBuffer) []error {\\n\\tif i != 0 && i%3 == 0 {\\n\\t\\treturn []error{&huma.ErrorDetail{\\n\\t\\t\\tLocation: prefix.String(),\\n\\t\\t\\tMessage:  \"Value cannot be a multiple of three\",\\n\\t\\t\\tValue:    i,\\n\\t\\t}}\\n\\t}\\n\\treturn nil\\n}\\n\\n// Ensure our resolver meets the expected interface.\\nvar _ huma.ResolverWithPath = (*IntNot3)(nil)\\n\\nfunc main() {\\n\\t// Create the CLI, passing a function to be called with your custom options\\n\\t// after they have been parsed.\\n\\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\\n\\t\\trouter := chi.NewMux()\\n\\n\\t\\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\\n\\n\\t\\t// Register the greeting operation.\\n\\t\\thuma.Register(api, huma.Operation{\\n\\t\\t\\tOperationID: \"put-count\",\\n\\t\\t\\tSummary:     \"Put a count of things\",\\n\\t\\t\\tMethod:      http.MethodPut,\\n\\t\\t\\tPath:        \"/count/{count}\",\\n\\t\\t}, func(ctx context.Context, input *struct {\\n\\t\\t\\tPathCount   IntNot3 `path:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\\n\\t\\t\\tQueryCount  IntNot3 `query:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\\n\\t\\t\\tHeaderCount IntNot3 `header:\"Count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\\n\\t\\t\\tBody        struct {\\n\\t\\t\\t\\tCount  IntNot3 `json:\"count\" example:\"2\" minimum:\"1\" maximum:\"10\"`\\n\\t\\t\\t\\tNested *struct {\\n\\t\\t\\t\\t\\tSubCount IntNot3 `json:\"subCount\" example:\"2\" minimum:\"1\" maximum:\"10\"`\\n\\t\\t\\t\\t} `json:\"nested,omitempty\"`\\n\\t\\t\\t}\\n\\t\\t}) (*struct{}, error) {\\n\\t\\t\\tfmt.Printf(\"Got input: %+v\\n\", input)\\n\\t\\t\\treturn nil, nil\\n\\t\\t})\\n\\n\\t\\t// Tell the CLI how to start your router.\\n\\t\\thooks.OnStart(func() {\\n\\t\\t\\t// Start the server\\n\\t\\t\\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\\n\\t\\t})\\n\\t})\\n\\n\\t// Run the CLI. When passed no commands, it starts the server.\\n\\tcli.Run()\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering and Handling GET /greeting/{name} with Huma and Chi in Golang\nDESCRIPTION: This code registers a GET operation at /greeting/{name} using Huma's helper. It defines a handler function which accepts a path parameter 'name', constrains its max length, and responds with a customized message via the GreetingOutput model. Required dependencies include Huma, Chi, and their relevant adapters, as well as 'fmt' for string formatting. Input is the name extracted from the path, and output is a JSON greeting. The server listens on port 8888.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a new router & API.\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t// Register GET /greeting/{name} handler.\n\thuma.Get(api, \"/greeting/{name}\", func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Start the server!\n\thttp.ListenAndServe(\"127.0.0.1:8888\", router)\n}\n```\n\n----------------------------------------\n\nTITLE: Reading and Writing Cookies in Middleware - Go\nDESCRIPTION: This Go snippet shows how to read cookies from the request and set cookies in the response using huma.Context in router-agnostic middleware. It utilizes huma.ReadCookie, huma.ReadCookies, and ctx.AppendHeader to manage cookies, and leverages the standard http.Cookie struct. Suitable for session management and customization. Dependencies: github.com/danielgtaylor/huma/v2, net/http. Inputs: context, cookie names; outputs: cookie values or updated response headers.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_8\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(huma.Context)) {\\n\\t// Read a cookie by name.\\n\\tsessionCookie := huma.ReadCookie(ctx, \"session\")\\n\\tfmt.Println(sessionCookie)\\n\\n\\t// Read all the cookies from the request.\\n\\tcookies := huma.ReadCookies(ctx)\\n\\tfmt.Println(cookies)\\n\\n\\t// Set a cookie in the response. Using `ctx.AppendHeader` won't overwrite\\n\\t// any existing headers, for example if other middleware might also set\\n\\t// headers or if this code were moved after the `next` call and the operation\\n\\t// might set the same header. You can also call `ctx.AppendHeader` multiple\\n\\t// times to write more than one cookie.\\n\\tcookie := http.Cookie{\\n\\t\\tName:  \"session\",\\n\\t\\tValue: \"123\",\\n\\t}\\n\\tctx.AppendHeader(\"Set-Cookie\", cookie.String())\\n\\n\\t// Call the next middleware in the chain. This eventually calls the\\n\\t// operation handler as well.\\n\\tnext(ctx)\\n}\n```\n\n----------------------------------------\n\nTITLE: Appending Multiple Header Values in Response - Huma - Go\nDESCRIPTION: Demonstrates how to configure a response struct so that a HTTP header is appended with multiple values instead of replaced. By using a field of type []string and the header struct tag, repeated headers are easily generated. Requires Go and Huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype MyOutput struct {\n\tMyHeader []string `header:\"My-Header\"`\n}\n\n```\n\n----------------------------------------\n\nTITLE: Allowing Additional Properties in Struct Definitions with Huma in Go\nDESCRIPTION: This code snippet defines a Go struct appropriate for partial (flexible) API input, using the Huma field tag `additionalProperties:\"true\"` to permit arbitrary additional fields in the input JSON. The underscore dummy field is an idiomatic way to enable additionalItems handling (no memory allocation); regular fields are still validated. This pattern is useful when integrating with external systems that may send extra fields. Requires Go, Huma framework, and encoding/json.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-validation.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ntype PartialInput struct {\n\t_      struct{} `json:\"-\" additionalProperties:\"true\"`\n\tField1 string   `json:\"field1\"`\n\tField2 bool     `json:\"field2\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Huma with Chi Router in Go\nDESCRIPTION: This Go snippet demonstrates how to instantiate a Chi router, wrap it with Huma using the humachi adapter, configure the API, and start an HTTP server. It relies on the chi, huma, and humachi packages. Key parameters include the router instance, API configuration with the API title and version, and the address for ListenAndServe. Inputs include registration of operations and router; output is an operational HTTP server. The snippet assumes you have Chi v5 and Huma packages installed.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/bring-your-own-router.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Create your router.\nrouter := chi.NewMux()\n\n// Wrap the router with Huma to create an API instance.\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n// Register your operations with the API.\n// ...\n\n// Start the server!\nhttp.ListenAndServe(\":8888\", r)\n\n```\n\n----------------------------------------\n\nTITLE: Implementing Review Input Endpoint with huma - Go\nDESCRIPTION: Implements a RESTful API server in Go using the huma and chi frameworks, enabling POST /reviews to accept and validate user-submitted review data. Data models are structured for strong validation via struct tags (e.g., maxLength, minimum). Dependencies include huma/v2, chi/v5, and humacli. Key parameters define author (up to 10 chars), rating (1-5), and optional message (up to 100 chars). The endpoint returns 201 Created on success. Inputs are strongly validated; omitting required fields or invalid values triggers automatic error responses. To run, install dependencies and execute the compiled Go binary.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/sending-data.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tDescription: \"Get a greeting for a person by name.\",\n\t\t\tTags:        []string{\"Greetings\"},\n\t\t}, func(ctx context.Context, input *struct{\n\t\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t\t}) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Register POST /reviews\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID:   \"post-review\",\n\t\t\tMethod:        http.MethodPost,\n\t\t\tPath:          \"/reviews\",\n\t\t\tSummary:       \"Post a review\",\n\t\t\tTags:          []string{\"Reviews\"},\n\t\t\tDefaultStatus: http.StatusCreated,\n\t\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t\t// TODO: save review in data store.\n\t\t\treturn nil, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Making Requests with Huma Test API in Go\nDESCRIPTION: This snippet shows how to use the api test object to make GET and PUT requests to endpoints. The api.Get and api.Put functions are used to simulate HTTP requests against the registered routes. The Put call demonstrates sending headers and a JSON request body. Requires the addRoutes function and humatest.New setup; inputs are HTTP method, path, headers, and body; outputs a ResponseRecorder for assertion.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/test-utilities.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n\n\t// Make a GET request\n\tresp := api.Get(\"/some/path?foo=bar\")\n\n\t// Make a PUT request\n\tresp = api.Put(\"/some/path\",\n\t\t\"My-Header: abc123\",\n\t\tmap[string]any{\n\t\t\t\"author\": \"daniel\",\n\t\t\t\"rating\": 5,\n\t\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Defining and Registering Custom Error Models - Huma - Go\nDESCRIPTION: Illustrates defining a custom error model in Go by implementing the huma.StatusError interface and overriding huma.NewError for custom error instantiation. The example walks through creating a MyError struct with JSON serialization tags, methods for error string and status, router and API setup, and registering an error-returning handler. Requires Go, Huma, Chi, and Humachi packages. Allows organizations to enforce consistent, customized error formats for their APIs. The custom struct may carry extra fields like details, and the router serves a demonstration endpoint on :8888.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-errors.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype MyError struct {\n\tstatus  int\n\tMessage string   `json:\"message\"`\n\tDetails []string `json:\"details,omitempty\"`\n}\n\nfunc (e *MyError) Error() string {\n\treturn e.Message\n}\n\nfunc (e *MyError) GetStatus() int {\n\treturn e.status\n}\n\nfunc main() {\n\thuma.NewError = func(status int, message string, errs ...error) huma.StatusError {\n\t\tdetails := make([]string, len(errs))\n\t\tfor i, err := range errs {\n\t\t\tdetails[i] = err.Error()\n\t\t}\n\t\treturn &MyError{\n\t\t\tstatus:  status,\n\t\t\tMessage: message,\n\t\t\tDetails: details,\n\t\t}\n\t}\n\n\trouter := chi.NewMux()\n\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-error\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/error\",\n\t}, func(ctx context.Context, i *struct{}) (*struct{}, error) {\n\t\treturn nil, huma.Error404NotFound(\"not found\", fmt.Errorf(\"some-other-error\"))\n\t})\n\n\thttp.ListenAndServe(\":8888\", router)\n}\n```\n\n----------------------------------------\n\nTITLE: Unwrapping Router-specific Request/Response in Middleware - Go\nDESCRIPTION: This Go snippet shows how to access the underlying router-specific request and response objects from within a Huma-agnostic middleware via Unwrap functions (e.g., humago.Unwrap). This approach allows for interoperability with lower-level HTTP handlers; it is useful during migration or when advanced customization is needed. Dependencies: github.com/danielgtaylor/huma/v2/adapters/humago, net/http. The snippet expects huma.Context, exposes *http.Request and http.ResponseWriter, and supports chaining with other HTTP handlers.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(huma.Context)) {\\n\\t// Unwrap the request and response objects.\\n\\tr, w := humago.Unwrap(ctx)\\n\\n\\t// Do something with the request and response objects.\\n\\totherMiddleware(func (_ http.Handler) {\\n\\t\\t// Note this assumes the request/response are modified in-place.\\n\\t\\tnext(ctx)\\n\\t}).ServeHTTP(w, r)\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Conditional GET Endpoint with Huma in Go\nDESCRIPTION: This Go code snippet demonstrates how to register an HTTP GET operation with a conditional handler using the Huma framework. It imports the 'conditional' package and embeds 'conditional.Params' into the input struct to enable conditional request handling, such as ETag and Last-Modified logic. The 'HasConditionalParams' and 'PreconditionFailed' methods help determine if the request matches the preconditions set by the client (e.g., If-None-Match), returning HTTP 304 Not Modified when appropriate. Inputs include context and input struct; output is the resource or an error. Dependencies: 'github.com/danielgtaylor/huma/v2/conditional', 'net/http', 'context', and 'time'. Key parameters: ETag and last modification timestamp. Limitations: application logic must supply resource meta-info; does not handle DB queries automatically.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/conditional-requests.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-resource\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/resource\",\n\tSummary:     \"Get a resource\",\n}, func(ctx context.Context, input struct {\n\tconditional.Params\n}) (*YourOutput, error) {\n\tif input.HasConditionalParams() {\n\t\t// TODO: Get the ETag and last modified time from the resource.\n\t\tetag := \"\"\n\t\tmodified := time.Time{}\n\n\t\t// If preconditions fail, abort the request processing. Response status\n\t\t// codes are already set for you, but you can optionally provide a body.\n\t\t// Returns an HTTP 304 not modified.\n\t\tif err := input.PreconditionFailed(etag, modified); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Otherwise do the normal request processing here...\n\t\t// ...\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing JWT Authorization Middleware\nDESCRIPTION: Creates middleware for JWT validation including key set management, token parsing, and scope verification for protected endpoints.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/oauth2-jwt.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"github.com/lestrrat-go/jwx/v2/jwk\"\n\t\"github.com/lestrrat-go/jwx/v2/jwt\"\n)\n\n// NewJWKSet creates an auto-refreshing key set to validate JWT signatures.\nfunc NewJWKSet(jwkUrl string) jwk.Set {\n    jwkCache := jwk.NewCache(context.Background())\n\n    // register a minimum refresh interval for this URL.\n    // when not specified, defaults to Cache-Control and similar resp headers\n    err := jwkCache.Register(jwkUrl, jwk.WithMinRefreshInterval(10*time.Minute))\n    if err != nil {\n        panic(\"failed to register jwk location\")\n    }\n\n    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)\n    defer cancel()\n\n    // fetch once on application startup\n    _, err = jwkCache.Refresh(ctx, jwkUrl)\n    if err != nil {\n        panic(\"failed to fetch on startup\")\n    }\n    // create the cached key set\n    return jwk.NewCachedSet(jwkCache, jwkUrl)\n}\n\n// NewAuthMiddleware creates a middleware that will authorize requests based on\n// the required scopes for the operation.\nfunc NewAuthMiddleware(api huma.API, jwksURL string) func(ctx huma.Context, next func(huma.Context)) {\n\tkeySet := NewJWKSet(jwksURL)\n\n\treturn func(ctx huma.Context, next func(huma.Context)) {\n\t\tvar anyOfNeededScopes []string\n\t\tisAuthorizationRequired := false\n\t\tfor _, opScheme := range ctx.Operation().Security {\n\t\t\tvar ok bool\n\t\t\tif anyOfNeededScopes, ok = opScheme[\"myAuth\"]; ok {\n\t\t\t\tisAuthorizationRequired = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif !isAuthorizationRequired {\n\t\t\tnext(ctx)\n\t\t\treturn\n\t\t}\n\n\t\ttoken := strings.TrimPrefix(ctx.Header(\"Authorization\"), \"Bearer \")\n\t\tif len(token) == 0 {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Parse and validate the JWT.\n\t\tparsed, err := jwt.ParseString(token,\n\t\t\tjwt.WithKeySet(keySet),\n\t\t\tjwt.WithValidate(true),\n\t\t\tjwt.WithIssuer(\"my-issuer\"),\n\t\t\tjwt.WithAudience(\"my-audience\"),\n\t\t)\n\t\tif err != nil {\n\t\t\thuma.WriteErr(api, ctx, http.StatusUnauthorized, \"Unauthorized\")\n\t\t\treturn\n\t\t}\n\n\t\t// Ensure the claims required for this operation are present.\n\t\tscopes, _ := parsed.Get(\"scopes\")\n\t\tif scopes, ok := scopes.([]string); ok {\n\t\t\tfor _, scope := range scopes {\n\t\t\t\tif slices.Contains(anyOfNeededScopes, scope) {\n\t\t\t\t\tnext(ctx)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\thuma.WriteErr(api, ctx, http.StatusForbidden, \"Forbidden\")\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Defining a Custom JSON Serialization Format in Huma (Go)\nDESCRIPTION: This Go snippet defines a custom serialization format structure for Huma, specifying marshal and unmarshal functions for JSON. The Marshal function uses 'json.NewEncoder' to serialize any value to an 'io.Writer', and the Unmarshal function uses 'json.Unmarshal' for reading. Dependencies: a 'Format' struct and the Go standard 'encoding/json' package. Inputs are any Go value for marshalling and []byte data for unmarshalling; outputs are marshaled data or deserialized Go objects. Used to extend or override content types in Huma APIs.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-serialization.md#_snippet_1\n\nLANGUAGE: Go\nCODE:\n```\nvar DefaultJSONFormat = Format{\n\tMarshal: func(w io.Writer, v any) error {\n\t\treturn json.NewEncoder(w).Encode(v)\n\t},\n\tUnmarshal: json.Unmarshal,\n}\n```\n\n----------------------------------------\n\nTITLE: Reading Context Values in Middleware - Go\nDESCRIPTION: This Go code demonstrates how to retrieve custom values from the request context within middleware or operation handlers in Huma. Using ctx.Context().Value, developers can access values, such as IDs or user data, which may have been injected by other middleware. Requires huma.Context and standard context package. Input is the key to retrieve; output is the associated value or nil.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nif v, ok := ctx.Context().Value(\"some-key\").(string); ok {\\n\\t// Do something with `v`!\\n}\n```\n\n----------------------------------------\n\nTITLE: Registering Protected API Operation\nDESCRIPTION: Demonstrates how to register an API operation that requires OAuth2.0 authentication with specific scope requirements.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/oauth2-jwt.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tSummary:     \"Get a greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSecurity: []map[string][]string{\n\t\t{\"myAuth\": {\"scope1\"}},\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// TODO: operation implementation goes here\n\treturn nil, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Importing Default and CBOR Serialization Formats in Huma (Go)\nDESCRIPTION: This Go snippet shows how to enable both JSON (default) and CBOR serialization in a Huma-based API by importing the main Huma package and the optional CBOR formats package. Simply importing the CBOR package registers support for 'application/cbor' as a content type. Required dependencies: 'github.com/danielgtaylor/huma/v2' and its '/formats/cbor' subpackage. No function calls are needed; CBOR support is loaded via the blank import. Input and output are handled internally by Huma's content negotiation logic.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-serialization.md#_snippet_0\n\nLANGUAGE: Go\nCODE:\n```\nimport (\n    \"github.com/danielgtaylor/huma/v2\"\n\n    _ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n```\n\n----------------------------------------\n\nTITLE: Returning Structured Error Responses from Middleware - Go\nDESCRIPTION: This Go snippet illustrates how middleware can write a structured error response and halt further processing in Huma APIs. If a specific query parameter is set (error=true), huma.WriteErr is invoked with details and processing stops; otherwise, the request continues. Useful for custom error handling and validation. Dependencies: github.com/danielgtaylor/huma/v2, net/http, fmt. Inputs: middleware context and query string; output: structured HTTP error or continuation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_9\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(ctx huma.Context)) {\\n\\t// If there is a query parameter \"error=true\", then return an error\\n\\tif ctx.Query(\"error\") == \"true\" {\\n\\t\\thuma.WriteErr(api, ctx, http.StatusInternalServerError,\\n\\t\\t\\t\"Some friendly message\", fmt.Errorf(\"error detail\"),\\n\\t\\t)\\n\\t\\treturn\\n\\t}\\n\\n\\t// Otherwise, just continue as normal.\\n\\tnext(ctx)\\n})\n```\n\n----------------------------------------\n\nTITLE: Registering SSE Operations with Huma SSE Package in Go\nDESCRIPTION: This Go code snippet demonstrates how to register a new SSE operation with the Huma framework using the sse package. The example defines several event types and uses a handler function to emit events at one-second intervals, highlighting core SSE features. Dependencies include the Huma framework, its sse submodule, and Go's context, http, and time packages. Key parameters include the API object, operation definition, event type mappings, and a handler receiving a context, input, and a Sender. Inputs are the operation's context and a pointer to input data (empty struct), outputs are events sent to connected clients in real-time. Each event model must be a distinct Go type, but Go's type aliasing allows flexible model reuse.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/server-sent-events-sse.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Register using sse.Register instead of huma.Register\nsse.Register(api, huma.Operation{\n\tOperationID: \"sse\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/sse\",\n\tSummary:     \"Server sent events example\",\n}, map[string]any{\n\t// Mapping of event type name to Go struct for that event.\n\t\"message\":      DefaultMessage{},\n\t\"userCreate\":   UserCreatedEvent{},\n\t\"mailReceived\": MailReceivedEvent{},\n}, func(ctx context.Context, input *struct{}, send sse.Sender) {\n\t// Send an event every second for 10 seconds.\n\tfor x := 0; x < 10; x++ {\n\t\tsend.Data(MailReceivedEvent{UserID: \"abc123\"})\n\t\ttime.Sleep(1 * time.Second)\n\t}\n})\n```\n\n----------------------------------------\n\nTITLE: Streaming HTTP Response with Huma in Go\nDESCRIPTION: This Go snippet defines a handler function that streams responses to a client using the huma.StreamResponse utility. It sets the Content-Type header, writes and flushes data using a context body writer, manages write deadlines when possible, and sends multiple messages with time intervals. Dependencies include the \"huma\" package and standard library packages such as context, time, and net/http. The input parameter is a context and structured input, and the output is a pointer to huma.StreamResponse, which facilitates custom streaming logic for cases like SSE or other long-lived HTTP connections.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-streaming.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nfunc handler(ctx context.Context, input *MyInput) (*huma.StreamResponse, error) {\n\treturn &huma.StreamResponse{\n\t\tBody: func(ctx huma.Context) {\n\t\t\t// Write header info before streaming the body.\n\t\t\tctx.SetHeader(\"Content-Type\", \"text/my-stream\")\n\t\t\twriter := ctx.BodyWriter()\n\n\t\t\t// Update the write deadline to give us extra time.\n\t\t\tif d, ok := writer.(interface{ SetWriteDeadline(time.Time) error }); ok {\n\t\t\t\td.SetWriteDeadline(time.Now().Add(5 * time.Second))\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"warning: unable to set write deadline\")\n\t\t\t}\n\n\t\t\t// Write the first message, then flush and wait.\n\t\t\twriter.Write([]byte(\"Hello, I'm streaming!\"))\n\t\t\tif f, ok := writer.(http.Flusher); ok {\n\t\t\t\tf.Flush()\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"error: unable to flush\")\n\t\t\t}\n\n\t\t\ttime.Sleep(3 * time.Second)\n\n\t\t\t// Write the second message.\n\t\t\twriter.Write([]byte(\"Hello, I'm still streaming!\"))\n\t\t},\n\t}, nil\n}\n\n```\n\n----------------------------------------\n\nTITLE: Registering Start and Stop Handlers in CLI - Cobra and humacli in Go\nDESCRIPTION: This Go snippet configures the CLI to handle server startup and graceful shutdown via humacli lifecycle hooks. It creates an HTTP server with address and router, registers handlers for OnStart and OnStop events, and manages shutdown using context with timeout. This setup requires the humacli package, Cobra, net/http, context, and time packages; options are passed in, and server control is handled through hooks.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ncli := humacli.New(func(hooks humacli.Hooks, opts *Options) {\n\t// Set up the router and API\n\t// ...\n\n\t// Create the HTTP server.\n\tserver := http.Server{\n\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\tHandler: router,\n\t}\n\n\thooks.OnStart(func() {\n\t\t// Start your server here\n\t\tserver.ListenAndServe()\n\t})\n\n\thooks.OnStop(func() {\n\t\t// Gracefully shutdown your server here\n\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\tdefer cancel()\n\t\tserver.Shutdown(ctx)\n\t})\n})\n```\n\n----------------------------------------\n\nTITLE: Using a Generated Go SDK Client to Call the API\nDESCRIPTION: This Go code provides a sample client that imports a generated Go SDK, initializes an API client, and performs a greeting request. It requires that the SDK code (generated via oapi-codegen) is available under the github.com/my-user/my-api/sdk import path. The main parameters include the server URL and the greeting name. Inputs are hardcoded; output is the greeting message printed to console. Errors or non-success statuses will panic the client. Limitations include lack of error handling for client construction and rigid parameter values.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/client-sdks.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/my-user/my-api/sdk\"\n)\n\nfunc main() {\n\tctx := context.Background()\n\n\t// Initialize an SDK client.\n\tclient, _ := sdk.NewClientWithResponses(\"http://localhost:8888\")\n\n\t// Make the greeting request.\n\tgreeting, err := client.GetGreetingWithResponse(ctx, \"world\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\tif greeting.StatusCode() > 200 {\n\t\tpanic(greeting.ApplicationproblemJSONDefault)\n\t}\n\n\t// Everything was successful, so print the message.\n\tfmt.Println(greeting.JSON200.Message)\n}\n\n```\n\n----------------------------------------\n\nTITLE: Initializing Huma Test API in Go\nDESCRIPTION: This snippet shows how to initialize a test API instance using the humatest package in Go. The TestMyAPI function receives a testing.T object and uses humatest.New to create a router and API used for further route registrations and test requests. Dependencies: github.com/danielgtaylor/huma/v2/humatest and Go's testing package. No input parameters are needed beyond the standard testing.T; outputs are router and api variables used for further testing.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/test-utilities.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport (\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n}\n```\n\n----------------------------------------\n\nTITLE: Processing Multipart Form Data in Go\nDESCRIPTION: Demonstrates how to handle multipart form data uploads using the multipart.Form type in the input struct.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"upload-files\",\n    Method:      http.MethodPost,\n    Path:        \"/upload\",\n    Summary:     \"Example to upload a file\",\n}, func(ctx context.Context, input *struct {\n    RawBody multipart.Form\n}) (*struct{}, error) {\n    // Process multipart form here.\n\tfor name, _ := range input.RawBody.File {\n\t    fmt.Printf(\"Obtained file with name '%s'\", name)\n\t}\n\tfor name, val := range input.RawBody.Value {\n\t    fmt.Printf(\"Obtained value with name '%s' and value '%s'\", name, val)\n\t}\n    return nil, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Declaring Conditionally Required Fields in Huma Struct Tags - Go\nDESCRIPTION: This snippet defines a Go struct 'MyInput' where all fields are normally optional, but the presence of 'value' requires that both 'dependent1' and 'dependent2' are also present. The struct uses the 'dependentRequired' tag from Huma, which follows the JSON Schema convention for conditional fields. This approach requires Huma and Go as dependencies; it is designed for scenarios where input validation should enforce such dependencies at runtime.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/conditional-fields.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {\n    Value      string `json:\"value,omitempty\" dependentRequired:\"dependent1,dependent2\"`\n    Dependent1 string `json:\"dependent1,omitempty\"`\n    Dependent2 string `json:\"dependent2,omitempty\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Returning Errors with Custom Headers - Huma - Go\nDESCRIPTION: Shows how to use the huma.ErrorWithHeaders utility to wrap an HTTP error response with custom headers in Go using the Huma framework. Requires setting up error objects and HTTP headers. Multiple headers can be safely concatenated to any existing error response. Useful for advanced response customization via middleware or per-handler logic.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-errors.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nreturn nil, huma.ErrorWithHeaders(\n\thuma.Error404NotFound(\"thing not found\"),\n\thttp.Header{\n\t\t\"Cache-Control\": {\"no-store\"},\n\t},\n)\n```\n\n----------------------------------------\n\nTITLE: Implementing Graceful Shutdown with Huma and humacli (Go)\nDESCRIPTION: This Go snippet creates an HTTP server using Huma and integrates CLI lifecycle hooks to allow for graceful shutdown. The code defines server options, request/response structs for a greeting endpoint, and demonstrates registering operations with the API. Dependencies include the Huma framework, humachi, humacli, chi router, and standard Go HTTP/context libraries. The server stops accepting new requests and shuts down with a 5-second timeout to let in-flight requests finish, making it suitable for containerized environments where readiness/liveness checks are important. Inputs (name parameter, port) are handled via CLI and HTTP path parameters, and outputs are JSON-formatted greeting messages.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/graceful-shutdown.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingInput represents the greeting operation request.\ntype GreetingInput struct {\n\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /greeting/{name}\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-greeting\",\n\t\t\tSummary:     \"Get a greeting\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/greeting/{name}\",\n\t\t}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t\t\tresp := &GreetingOutput{}\n\t\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Create the HTTP server.\n\t\tserver := http.Server{\n\t\t\tAddr:    fmt.Sprintf(\":%d\", options.Port),\n\t\t\tHandler: router,\n\t\t}\n\n\t\t// Tell the CLI how to start your router.\n\t\thooks.OnStart(func() {\n\t\t\tserver.ListenAndServe()\n\t\t})\n\n\t\t// Tell the CLI how to stop your server.\n\t\thooks.OnStop(func() {\n\t\t\t// Give the server 5 seconds to gracefully shut down, then give up.\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\t\t\tdefer cancel()\n\t\t\tserver.Shutdown(ctx)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Implementing a Field-Selecting Response Transformer in Huma (Go)\nDESCRIPTION: Demonstrates a Go function suitable for use as a Huma response transformer. It inspects the 'Fields' HTTP header and, if present, marshals and then unmarshals the response object to dynamically filter fields based on a shorthand query, similar to GraphQL. Dependencies: Go standard JSON library, a 'shorthand' package with a GetPath method, and the Huma type Context. Inputs: context, response status, and response object. Output: the possibly-filtered response object or an error. Limitations: efficiency concerns due to full marshal/unmarshal, and the reliance on a non-standard 'Fields' header.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-transformers.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// FieldSelectTransform is an example of a transform that can use an input\\n// header value to modify the response on the server, providing a GraphQL-like\\n// way to send only the fields that the client wants over the wire.\\nfunc FieldSelectTransform(ctx Context, status string, v any) (any, error) {\\n\\tif fields := ctx.Header(\"Fields\"); fields != \"\" {\\n\\t\\t// Ugh this is inefficient... consider other ways of doing this :-(\\n\\t\\tvar tmp any\\n\\t\\tb, _ := json.Marshal(v)\\n\\t\\tjson.Unmarshal(b, &tmp)\\n\\t\\tresult, _, err := shorthand.GetPath(fields, tmp, shorthand.GetOptions{})\\n\\t\\treturn result, err\\n\\t}\\n\\treturn v, nil\\n}\n```\n\n----------------------------------------\n\nTITLE: Running CLI with Different Options - Go Program in Shell\nDESCRIPTION: These shell commands show how to execute the Go CLI application with various options supplied through command-line arguments. They illustrate default execution, setting options explicitly, and demonstrate environment variable overrides. The Go code from the previous snippet must be compiled or run via 'go run', and Go must be installed.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n// Run with defaults\n$ go run main.go\nI was run with debug:false host: port:8888\n\n// Run with options\n$ go run main.go --debug=true --host=localhost --port=8000\nI was run with debug:true host:localhost port:8000\n```\n\n----------------------------------------\n\nTITLE: Returning Raw Bytes as Response Body - Huma - Go\nDESCRIPTION: Shows how to send a raw byte slice (possibly pre-serialized data) as an HTTP response body using the Body field. This bypasses content serialization and allows direct response of binary or arbitrary content. Dependencies: Go, Huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-outputs.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ntype MyOutput struct {\n\tBody []byte\n}\n\n```\n\n----------------------------------------\n\nTITLE: Designing Review Submission API Request and Response - Go\nDESCRIPTION: Shows the intended API contract for posting a user review, including the HTTP POST method, expected JSON payload fields, and the typical 201 Created response. Use this schema as a reference for clients integrating with the reviews endpoint. Inputs to the endpoint are author (string), rating (int), and message (string). The output is an HTTP 201 response signaling creation. No runtime code—only the API message design is illustrated.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/sending-data.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nRequest:\nPOST /reviews\n{\n\t\"author\": \"Daniel\",\n\t\"rating\": 5,\n\t\"message\": \"Some custom review message\"\n}\n\nResponse: 201 Created\n```\n\n----------------------------------------\n\nTITLE: Sample HTTP Problem+JSON Error Response - HTTP\nDESCRIPTION: Provides a sample HTTP error response conforming to RFC 9457 \"Problem Details\" as returned by the Huma framework. It uses content type application/problem+json, includes schema reference, status, title, detail, and an array of detailed error objects for precise error localization. Intended for implementers validating error responses in their APIs.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-errors.md#_snippet_1\n\nLANGUAGE: http\nCODE:\n```\nHTTP/2.0 422 Unprocessable Entity\nCache-Control: private\nContent-Length: 241\nContent-Type: application/problem+json\nLink: </schemas/ErrorModel.json>; rel=\"describedBy\"\n\n{\n  \"$schema\": \"https://api.rest.sh/schemas/ErrorModel.json\",\n  \"status\": 422,\n  \"title\": \"Unprocessable Entity\",\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"location\": \"body.title\",\n      \"message\": \"expected string\",\n      \"value\": true\n    },\n    {\n      \"location\": \"body.reviews\",\n      \"message\": \"unexpected property\",\n      \"value\": {\n        \"reviews\": 5,\n        \"title\": true\n      }\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Composing OpenAPI Settings in Huma (Go)\nDESCRIPTION: This example shows how to compose OpenAPI settings using helper functions to make the configuration more readable and maintainable. It demonstrates the use of custom functions to apply bearer authentication to the config and operations.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/openapi-generation.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig = withBearerAuthScheme(config)\n\napi := humachi.New(router, config)\n\nhuma.Register(api, withBearerAuth(huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n}), func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n```\n\n----------------------------------------\n\nTITLE: Serving Stoplight Elements API Docs with Huma and Chi in Go\nDESCRIPTION: This Go snippet sets up a Chi router and disables the default Huma docs. It serves a custom HTML page at the /docs endpoint using Stoplight Elements as a web component. The handler returns an HTML response embedding the Stoplight Elements web component that loads the API description from /openapi.yaml and renders it in a stacked layout. Dependencies include the humachi and chi Go packages, and network access to the Stoplight Elements CDN. The /docs route expects no parameters, responds with HTML, and should be served from a Go server; the default documentation is disabled by setting config.DocsPath to an empty string.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/api-docs.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nrouter := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\tw.Write([]byte(`<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"referrer\" content=\"same-origin\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\" />\n    <title>Docs Example reference</title>\n    <!-- Embed elements Elements via Web Component -->\n    <link href=\"https://unpkg.com/@stoplight/elements@8.0.0/styles.min.css\" rel=\"stylesheet\" />\n    <script src=\"https://unpkg.com/@stoplight/elements@8.0.0/web-components.min.js\"\n            integrity=\"sha256-yIhuSFMJJ6mp2XTUAb4SiSYneP3Qav8Uu+7NBhGJW5A=\"\n            crossorigin=\"anonymous\"></script>\n  </head>\n  <body style=\"height: 100vh;\">\n    <elements-api\n      apiDescriptionUrl=\"/openapi.yaml\"\n      router=\"hash\"\n      layout=\"stacked\"\n      tryItCredentialsPolicy=\"same-origin\"\n    />\n  </body>\n</html>`))\n})\n```\n\n----------------------------------------\n\nTITLE: Implementing Image Response API with Huma in Go\nDESCRIPTION: A complete example showing how to create an API endpoint that returns binary image data using Huma framework. The code defines a custom image output type with content type header and byte slice body, then registers a GET endpoint that returns PNG image data with the appropriate content type.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/image-response.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// ImageOutput represents the image operation response.\ntype ImageOutput struct {\n\tContentType string `header:\"Content-Type\"`\n\tBody        []byte\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\t// Register GET /image\n\t\thuma.Register(api, huma.Operation{\n\t\t\tOperationID: \"get-image\",\n\t\t\tSummary:     \"Get an image\",\n\t\t\tMethod:      http.MethodGet,\n\t\t\tPath:        \"/image\",\n\t\t\tResponses: map[string]*huma.Response{\n\t\t\t\t\"200\": {\n\t\t\t\t\tDescription: \"Image response\",\n\t\t\t\t\tContent: map[string]*huma.MediaType{\n\t\t\t\t\t\t\"image/jpeg\": {},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}, func(ctx context.Context, input *struct{}) (*ImageOutput, error) {\n\t\t\tresp := &ImageOutput{}\n\t\t\tresp.ContentType = \"image/png\"\n\t\t\tresp.Body = []byte{ /* ... image bytes here ... */ }\n\t\t\treturn resp, nil\n\t\t})\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Running the Go Huma API Server\nDESCRIPTION: This shell command runs the Golang application by launching the main.go server. Prerequisite: main.go must be implemented as in preceding steps, and Go must be installed. The command should be run from the project directory.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_5\n\nLANGUAGE: bash\nCODE:\n```\n$ go run .\n```\n\n----------------------------------------\n\nTITLE: Registering a Modifier for Operations - huma (Go)\nDESCRIPTION: This registers a custom operation modifier with huma's UseModifier. The function sets a summary and tags on each operation before registration and then invokes the next modifier in the chain. Required are the huma package and operation modification functions. Inputs are the operation pointer and a next callback; output is the modified operation. Useful for group-wide configuration of documentation or tags.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\ngrp.UseModifier(func(op *huma.Operation, next func(*huma.Operation)) {\n\top.Summary = \"A summary for all operations in this group\"\n\top.Tags = []string{\"my-tag\"}\n    next(op)\n})\n```\n\n----------------------------------------\n\nTITLE: Adding Middleware to a Group - huma (Go)\nDESCRIPTION: This demonstrates how to add middleware to a huma.Group with the UseMiddleware method. The middleware function can preprocess the huma.Context before passing it to the next handler. Required dependencies are the huma package and any custom middleware logic. The input is a huma.Context and a 'next' callback, with no direct output, but the middleware can intercept or alter the request pipeline.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ngrp.UseMiddleware(func(ctx huma.Context, next func(huma.Context)) {\n\t// Do something before the operation runs\n\tnext(ctx)\n})\n```\n\n----------------------------------------\n\nTITLE: Writing Tests for Huma API in Go\nDESCRIPTION: This snippet demonstrates how to write tests for a Huma API using the humatest package. It includes examples of testing GET and POST requests, as well as error handling. The tests cover different scenarios and use assertions to verify the expected behavior.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/writing-tests.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"strings\"\n\t\"testing\"\n\n\t\"github.com/danielgtaylor/huma/v2/humatest\"\n)\n\nfunc TestGetGreeting(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Get(\"/greeting/world\")\n\tif !strings.Contains(resp.Body.String(), \"Hello, world!\") {\n\t\tt.Fatalf(\"Unexpected response: %s\", resp.Body.String())\n\t}\n}\n\nfunc TestPutReview(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"author\": \"daniel\",\n\t\t\"rating\": 5,\n\t})\n\n\tif resp.Code != 201 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n\nfunc TestPutReviewError(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\n\tresp := api.Post(\"/reviews\", map[string]any{\n\t\t\"rating\": 10,\n\t})\n\n\tif resp.Code != 422 {\n\t\tt.Fatalf(\"Unexpected status code: %d\", resp.Code)\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Group with Multiple Prefixes - huma (Go)\nDESCRIPTION: This code initializes a huma.Group with multiple prefixes ('/prefix1', '/prefix2'). Any operations registered to this group will inherit these URL prefixes. It requires the huma package and an initialized API instance. Inputs are the API instance and one or more prefix strings; outputs are the initialized group instance. The snippet is a convenience for prefix-based routing within huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ngrp := huma.NewGroup(api, \"/prefix1\", \"/prefix2\", \"...\")\n```\n\n----------------------------------------\n\nTITLE: Setting Up Route Groups with Chi and Huma in Go\nDESCRIPTION: This Go example shows how to use Chi's mux.Route feature to register a group of API routes under a common base path (e.g., /api), instantiate a Huma adapter for the route group, configure the OpenAPI Servers list, and register a demo GET operation. Dependencies are chi, huma, and humachi. Key parameters are the base path, API config with a custom Servers field, and operation registration. The server responds on localhost:8888, and operation handlers receive a huma.Context converted from the router's context.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/bring-your-own-router.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nmux := chi.NewMux()\nmux.Route(\"/api\", func(r chi.Router) {\n\tconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\n\tconfig.Servers = []*huma.Server{\n\t\t{URL: \"https://example.com/api\"},\n\t}\n\tapi = humachi.New(r, config)\n\n\t// Register operations...\n\thuma.Get(api, \"/demo\", func(ctx context.Context, input *struct{}) (*struct{}, error) {\n\t\t// TODO: Implement me!\n\t\treturn nil, nil\n\t})\n})\nhttp.ListenAndServe(\"localhost:8888\", mux)\n\n```\n\n----------------------------------------\n\nTITLE: Modifying Main Application for Testability in Go\nDESCRIPTION: This snippet shows how to modify the main.go file to make the API easier to test by moving operation registration out of the main function. It includes the full application code with route registration separated into an addRoutes function.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/writing-tests.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc addRoutes(api huma.API) {\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Register POST /reviews\n\thuma.Register(api, huma.Operation{\n\t\tOperationID:   \"post-review\",\n\t\tMethod:        http.MethodPost,\n\t\tPath:          \"/reviews\",\n\t\tSummary:       \"Post a review\",\n\t\tTags:          []string{\"Reviews\"},\n\t\tDefaultStatus: http.StatusCreated,\n\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t// TODO: save review in data store.\n\t\treturn nil, nil\n\t})\n}\n\nfunc main() {\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\taddRoutes(api)\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n```\n\n----------------------------------------\n\nTITLE: Handling Raw Body Input for Plain Text in Go\nDESCRIPTION: Illustrates how to bypass normal body parsing and directly access raw body contents for unstructured data like plain text.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"post-plain-text\",\n\tMethod:      http.MethodPost,\n\tPath:        \"/text\",\n\tSummary:     \"Example to post plain text input\",\n}, func(ctx context.Context, input *struct {\n\tRawBody []byte `contentType:\"text/plain\"`\n}) (*struct{}, error) {\n\tfmt.Println(\"Got input:\", input.RawBody)\n\treturn nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Registering a Simple Modifier for Operations - huma (Go)\nDESCRIPTION: This uses UseSimpleModifier for a more concise way to set shared operation behavior within a group. Here, it sets a summary and tag for each operation. Prerequisites include the huma package and an initialized group. The input is the operation pointer; no output is explicitly returned, as modification is performed in-place.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\ngrp.UseSimpleModifier(func(op *huma.Operation) {\n\top.Summary = \"A summary for all operations in this group\"\n\top.Tags = []string{\"my-tag\"}\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring OpenAPI CLI Auto-Configuration Extension in Go\nDESCRIPTION: This snippet demonstrates how to use the Huma Go library to update an OpenAPI 3 specification with a custom OAuth2 security scheme and a corresponding 'x-cli-autoconfig' extension. It sets up the OAuth2 details in the SecuritySchemes map and populates parameters (such as client_id, authorize_url, token_url, and scopes) needed for CLI clients to perform automatic API configuration. Dependencies include the Huma Go library and an instantiated OpenAPI object from the API. Key parameters in the example are set via map assignments. Inputs come from hardcoded string values; the output is the mutation of the OpenAPI definition, readily consumable by CLI tools like Restish.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli-auto-config.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\no := api.OpenAPI()\no.Components.SecuritySchemes[\"my-scheme\"] = &huma.SecurityScheme{\n\tType: \"oauth2\",\n\t// ... security scheme definition ...\n}\no.Extensions[\"x-cli-autoconfig\"] = huma.AutoConfig{\n\tSecurity: \"my-scheme\",\n\tParams: map[string]string{\n\t\t\"client_id\": \"abc123\",\n\t\t\"authorize_url\": \"https://example.tld/authorize\",\n\t\t\"token_url\": \"https://example.tld/token\",\n\t\t\"scopes\": \"read,write\",\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Operation-specific Middleware in Huma - Go\nDESCRIPTION: This Go code demonstrates assigning router-agnostic middleware to a specific Huma operation by setting the Middlewares field in huma.Operation. The middleware is executed after router-specific middleware and before the operation handler. Dependencies: github.com/danielgtaylor/huma/v2, github.com/danielgtaylor/huma/v2/adapters/humachi, net/http. Inputs include the operation definition and middleware; output is the registered operation with custom request processing.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_10\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(huma.Context)) {\\n\\t// Call the next middleware in the chain. This eventually calls the\\n\\t// operation handler as well.\\n\\tnext(ctx)\\n}\\n\\nfunc main() {\\n\\t// ...\\n\\tapi := humachi.New(router, config)\\n\\n\\thuma.Register(api, huma.Operation{\\n\\t\\tOperationID: \"demo\",\\n\\t\\tMethod:      http.MethodGet,\\n\\t\\tPath:        \"/demo\",\\n\\t\\tMiddlewares: huma.Middlewares{MyMiddleware},\\n\\t}, func(ctx context.Context, input *MyInput) (*MyOutput, error) {\\n\\t\\t// TODO: implement handler...\\n\\t\\treturn nil, nil\\n\\t})\\n}\n```\n\n----------------------------------------\n\nTITLE: Serving SwaggerUI API Documentation with Huma and Chi in Go\nDESCRIPTION: This Go snippet customizes API documentation delivery by embedding SwaggerUI in a custom HTML page at the /docs endpoint. It configures a Chi router, disables Huma's built-in docs, and sources SwaggerUI from a CDN. The handler returns HTML that initializes SwaggerUI, loading the OpenAPI spec from /openapi.json. Requires humachi and chi in Go, access to the SwaggerUI CDN, and an OpenAPI JSON file present at the expected location. No parameters are used; output is the traditional SwaggerUI view for the API.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/api-docs.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nrouter := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\tw.Write([]byte(`<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n  <meta name=\"description\" content=\"SwaggerUI\" />\n  <title>SwaggerUI</title>\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui.css\" />\n</head>\n<body>\n<div id=\"swagger-ui\"></div>\n<script src=\"https://unpkg.com/swagger-ui-dist@5.11.0/swagger-ui-bundle.js\" crossorigin></script>\n<script>\n  window.onload = () => {\n    window.ui = SwaggerUIBundle({\n      url: '/openapi.json',\n      dom_id: '#swagger-ui',\n    });\n  };\n</script>\n</body>\n</html>`))\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Chi Router Middleware - Go\nDESCRIPTION: This Go snippet configures middleware for a Huma API instance using the Chi router. It demonstrates how to set up a Chi router, add a JWT authentication middleware using jwtauth.Verifier, and initialize the Huma API with a router and default configuration. Dependencies: github.com/go-chi/chi, github.com/go-chi/jwtauth, github.com/danielgtaylor/huma/v2/adapters/humachi. Key parameters include the router, JWT verifier, and API configuration. Input is an HTTP request; the output is a Huma API instance with configured middleware.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nrouter := chi.NewMux()\\nrouter.Use(jwtauth.Verifier(tokenAuth))\\napi := humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n```\n\n----------------------------------------\n\nTITLE: Registering Routes with Huma Test API in Go\nDESCRIPTION: This snippet demonstrates how to register routes to the test API instance just like with the main API in Go. After initializing the router and API with humatest.New, the addRoutes function is called with the api object to attach HTTP routes for testing. Requires the same dependencies as before and the addRoutes function must be defined elsewhere. No input/output beyond registration within the test context.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/test-utilities.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nfunc TestMyAPI(t *testing.T) {\n\trouter, api := humatest.New(t)\n\n\t// Register routes...\n\taddRoutes(api)\n}\n```\n\n----------------------------------------\n\nTITLE: Viewing CLI Help and Version Output - Go Program in Shell\nDESCRIPTION: This shell snippet shows example outputs for the CLI --help and --version commands after customizing app name and version. It demonstrates user interactions and returned text when running the Go CLI binary with help and version flags. Relies on prior application of customizations via Go code.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\n$ go run ./demo --help\nUsage:\n  appname [flags]\n\nFlags:\n  -h, --help            help for appname\n  -p, --port int         (default 8888)\n  -v, --version         version for appname\n\n$ go run ./demo --version\nappname version 1.0.1\n```\n\n----------------------------------------\n\nTITLE: Querying with Field Selection Using RESTish (Bash CLI)\nDESCRIPTION: Shows how a client could use the response transformer by passing a custom 'Fields' HTTP header in a RESTish CLI invocation. This command requests only specific fields from a REST endpoint, leveraging the field-selection transformer on the server. Requires RESTish CLI and a server implementing the Huma 'FieldSelectTransform'. Inputs: endpoint URL, header specifying fields. Output: the filtered response. No outputs are shown; usage is entirely illustrative.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-transformers.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n$ restish example.com/things/1 -H 'Fields: {id, tag_names: tags[].name}'\n```\n\n----------------------------------------\n\nTITLE: Exporting OpenAPI Spec and Registering API Endpoints with Huma in Go\nDESCRIPTION: This Go code demonstrates how to set up a CLI-enabled API server using the Huma framework, define API routes (GET /greeting/{name} and POST /reviews), and add a CLI command to export the OpenAPI YAML spec. It relies on dependencies like huma, humachi, humacli, chi, and cobra, and uses type definitions for request/response validation. Inputs include command-line arguments and HTTP requests. Outputs are API responses; the OpenAPI spec is printed to stdout upon request. The code must be run in a Go environment with all dependencies installed.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/client-sdks.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/danielgtaylor/huma/v2\"\n\t\"github.com/danielgtaylor/huma/v2/adapters/humachi\"\n\t\"github.com/danielgtaylor/huma/v2/humacli\"\n\t\"github.com/go-chi/chi/v5\"\n\n\t_ \"github.com/danielgtaylor/huma/v2/formats/cbor\"\n)\n\n// Options for the CLI.\ntype Options struct {\n\tPort int `help:\"Port to listen on\" short:\"p\" default:\"8888\"`\n}\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n\n// ReviewInput represents the review operation request.\ntype ReviewInput struct {\n\tBody struct {\n\t\tAuthor  string `json:\"author\" maxLength:\"10\" doc:\"Author of the review\"`\n\t\tRating  int    `json:\"rating\" minimum:\"1\" maximum:\"5\" doc:\"Rating from 1 to 5\"`\n\t\tMessage string `json:\"message,omitempty\" maxLength:\"100\" doc:\"Review message\"`\n\t}\n}\n\nfunc addRoutes(api huma.API) {\n\t// Register GET /greeting/{name}\n\thuma.Register(api, huma.Operation{\n\t\tOperationID: \"get-greeting\",\n\t\tMethod:      http.MethodGet,\n\t\tPath:        \"/greeting/{name}\",\n\t\tSummary:     \"Get a greeting\",\n\t\tDescription: \"Get a greeting for a person by name.\",\n\t\tTags:        []string{\"Greetings\"},\n\t}, func(ctx context.Context, input *struct{\n\t\tName string `path:\"name\" maxLength:\"30\" example:\"world\" doc:\"Name to greet\"`\n\t}) (*GreetingOutput, error) {\n\t\tresp := &GreetingOutput{}\n\t\tresp.Body.Message = fmt.Sprintf(\"Hello, %s!\", input.Name)\n\t\treturn resp, nil\n\t})\n\n\t// Register POST /reviews\n\thuma.Register(api, huma.Operation{\n\t\tOperationID:   \"post-review\",\n\t\tMethod:        http.MethodPost,\n\t\tPath:          \"/reviews\",\n\t\tSummary:       \"Post a review\",\n\t\tTags:          []string{\"Reviews\"},\n\t\tDefaultStatus: http.StatusCreated,\n\t}, func(ctx context.Context, i *ReviewInput) (*struct{}, error) {\n\t\t// TODO: save review in data store.\n\t\treturn nil, nil\n\t})\n}\n\nfunc main() {\n\tvar api huma.API\n\n\t// Create a CLI app which takes a port option.\n\tcli := humacli.New(func(hooks humacli.Hooks, options *Options) {\n\t\t// Create a new router & API\n\t\trouter := chi.NewMux()\n\t\tapi = humachi.New(router, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n\n\t\taddRoutes(api)\n\n\t\t// Tell the CLI how to start your server.\n\t\thooks.OnStart(func() {\n\t\t\tfmt.Printf(\"Starting server on port %d...\\n\", options.Port)\n\t\t\thttp.ListenAndServe(fmt.Sprintf(\":%d\", options.Port), router)\n\t\t})\n\t})\n\n\t// Add a command to print the OpenAPI spec.\n\tcli.Root().AddCommand(&cobra.Command{\n\t\tUse:   \"openapi\",\n\t\tShort: \"Print the OpenAPI spec\",\n\t\tRun: func(cmd *cobra.Command, args []string) {\n\t\t\t// Use downgrade to return OpenAPI 3.0.3 YAML since oapi-codegen doesn't\n\t\t\t// support OpenAPI 3.1 fully yet. Use `.YAML()` instead for 3.1.\n\t\t\tb, _ := api.OpenAPI().DowngradeYAML()\n\t\t\tfmt.Println(string(b))\n\t\t},\n\t})\n\n\t// Run the CLI. When passed no commands, it starts the server.\n\tcli.Run()\n}\n\n```\n\n----------------------------------------\n\nTITLE: Configuring OAuth2.0 Security Schemes in Huma\nDESCRIPTION: Sets up OAuth2.0 security schemes in the API configuration, including Authorization Code flow with custom scopes and an alternative JWT bearer scheme.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/oauth2-jwt.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nrouter := chi.NewMux()\n\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Components.SecuritySchemes = map[string]*huma.SecurityScheme{\n\t// Example Authorization Code flow.\n\t\"myAuth\": {\n\t\tType: \"oauth2\",\n\t\tFlows: &huma.OAuthFlows{\n\t\t\tAuthorizationCode: &huma.OAuthFlow{\n\t\t\t\tAuthorizationURL: \"https://example.com/oauth/authorize\",\n\t\t\t\tTokenURL:         \"https://example.com/oauth/token\",\n\t\t\t\tScopes: map[string]string{\n\t\t\t\t\t\"scope1\": \"Scope 1 description...\",\n\t\t\t\t\t\"scope2\": \"Scope 2 description...\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n\n\t// Example alternative describing the use of JWTs without documenting how\n\t// they are issued or which flows might be supported. This is simpler but\n\t// tells clients less information.\n\t\"anotherAuth\": {\n\t\tType:         \"http\",\n\t\tScheme:       \"bearer\",\n\t\tBearerFormat: \"JWT\",\n\t},\n}\n\napi := humachi.New(router, config)\n```\n\n----------------------------------------\n\nTITLE: Adding Custom OpenAPI Extensions in Huma (Go)\nDESCRIPTION: This snippet illustrates how to add custom extensions to the OpenAPI specification using Huma. It shows the process of adding a custom field to the root of the OpenAPI document.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/openapi-generation.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nconfig := huma.DefaultConfig(\"My API\", \"1.0.0\")\nconfig.Extensions = map[string]any{\n\t\"my-extension\": \"my-value\",\n}\n```\n\n----------------------------------------\n\nTITLE: Setting Read Deadlines with Huma Request Context (Go)\nDESCRIPTION: This snippet illustrates how to use the Huma framework's request context to enforce a read deadline for incoming data, which is crucial when handling large or streaming request bodies. Dependencies include the huma framework and the time package. The Resolve method on a user-defined input struct invokes ctx.SetReadDeadline to specify how long the handler should wait for client input. The approach is limited by the configured deadline and helps prevent slowloris-type attacks.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-limits.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype MyInput struct {}\n\nfunc (m *MyInput) Resolve(ctx huma.Context) []error {\n\tctx.SetReadDeadline(time.Now().Add(5 * time.Second))\n}\n```\n\n----------------------------------------\n\nTITLE: Registering an Operation with Custom Request Body Schema in Go\nDESCRIPTION: This example shows how to register an API operation with a completely custom request body schema, overriding Huma's automatic schema generation. The custom schema includes properties with extensions.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/schema-customization.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\n// Register an operation with a custom input body schema.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"my-operation\",\n\tMethod:      http.MethodPut,\n\tPath:        \"/things/{thing-id}\",\n\tSummary:     \"Update a thing\",\n\tRequestBody: &huma.RequestBody{\n\t\tDescription: \"My custom request schema\",\n\t\tContent: map[string]*huma.MediaType{\n\t\t\t\"application/json\": {\n\t\t\t\tSchema: &huma.Schema{\n\t\t\t\t\tType: \t\t huma.TypeObject,\n\t\t\t\t\tProperties: map[string]*huma.Schema{\n\t\t\t\t\t\t\"foo\": {\n\t\t\t\t\t\t\tType: huma.TypeString,\n\t\t\t\t\t\t\tExtensions: map[string]any{\n\t\t\t\t\t\t\t\t\"x-custom-thing\": \"abc123\",\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t},\n}, func(ctx context.Context, input *MyInput) (*MyOutput, error) {\n\t// Implementation goes here...\n\treturn nil, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Creating and Registering Custom Huma Middleware - Go\nDESCRIPTION: This Go snippet demonstrates creating custom router-agnostic middleware for a Huma API. The MyMiddleware function sets a custom header and then invokes the next middleware or operation handler. The middleware is registered to the API before route handlers. Dependencies: github.com/danielgtaylor/huma/v2, relevant router adapter. Input parameters include the huma.Context and a function to call the next middleware; output is modified context and continued request processing.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(huma.Context)) {\\n\\t// Set a custom header on the response.\\n\\tctx.SetHeader(\"My-Custom-Header\", \"Hello, world!\")\\n\\n\\t// Call the next middleware in the chain. This eventually calls the\\n\\t// operation handler as well.\\n\\tnext(ctx)\\n}\\n\\nfunc NewHumaAPI() huma.API {\\n\\t// ...\\n\\tapi := humachi.New(router, config)\\n\\tapi.UseMiddleware(MyMiddleware)\\n\\n\\t// Register the handler after UseMiddleware() for the middleware to take effect\\n\\thuma.Get(api, \"/greeting/{name}\", handler.GreetingGetHandler)\\n}\n```\n\n----------------------------------------\n\nTITLE: Testing Authenticated Routes with Context in Go\nDESCRIPTION: This snippet shows how to test authenticated routes or routes that require a custom context using the humatest package. It demonstrates using the 'Ctx' suffixed methods to provide a custom context for the test request.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/writing-tests.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc TestGetGreeting(t *testing.T) {\n\t_, api := humatest.New(t)\n\n\taddRoutes(api)\n\t\n\tctx := context.Background() // define your necessary context\n\n\tresp := api.GetCtx(ctx, \"/greeting/world\") // provide it using the 'Ctx' suffixed methods\n\tif !strings.Contains(resp.Body.String(), \"Hello, world!\") {\n\t\tt.Fatalf(\"Unexpected response: %s\", resp.Body.String())\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Error Handling Status Code Logic Flow - Mermaid Diagram\nDESCRIPTION: A mermaid.js flowchart visualizing the decision logic in Huma for selecting HTTP status codes on error. Illustrates the stepwise evaluation of errors, panics, request body size, timeouts, parse and validation failures. Intended to help developers understand the priority and flow of error response status codes. Requires rendering in a markdown/mermaid-compatible viewer.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-errors.md#_snippet_4\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart TD\n\tRequest[Request has errors?] -->|yes| Panic\n\tRequest -->|no| Continue[Continue to handler]\n\tPanic[Panic?] -->|yes| 500\n\tPanic -->|no| RequestBody[Request body too large?]\n\tRequestBody -->|yes| 413\n\tRequestBody -->|no| RequestTimeout[Request took too long to read?]\n\tRequestTimeout -->|yes| 408\n\tRequestTimeout -->|no| ParseFailure[Cannot parse input?]\n\tParseFailure -->|yes| 400\n\tParseFailure -->|no| ValidationFailure[Validation failed?]\n\tValidationFailure -->|yes| 422\n\tValidationFailure -->|no| 400\n```\n\n----------------------------------------\n\nTITLE: Example of Shorthand Merge Patch in YAML\nDESCRIPTION: This snippet demonstrates a Shorthand Merge Patch format, which extends JSON merge patch with support for field paths and arrays. It shows how to append an item to an array, creating it if needed.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/auto-patch.md#_snippet_1\n\nLANGUAGE: yaml\nCODE:\n```\n{\n\tfoo.bar[]: \"baz\",\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Server Timeouts with http.Server in Go\nDESCRIPTION: This snippet demonstrates how to set up a Go http.Server with specific read, write, idle, and header timeouts to manage request processing durations. Dependencies include the net/http and time standard libraries. Key parameters are ReadTimeout, WriteTimeout, IdleTimeout, and ReadHeaderTimeout, each defining different aspects of the HTTP transaction lifecycle. The configuration limits how long the server will spend on each stage of the HTTP connection.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-limits.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nsrv := &http.Server{\n\tReadTimeout:       5 * time.Second,\n\tWriteTimeout:      5 * time.Second,\n\tIdleTimeout:       30 * time.Second,\n\tReadHeaderTimeout: 2 * time.Second,\n\t// ...\n}\n```\n\n----------------------------------------\n\nTITLE: Adding a Response Transformer to a Group - huma (Go)\nDESCRIPTION: This demonstrates using huma's UseTransformer to apply a function to responses after an operation handler runs. The transformer can modify or wrap the output as needed before sending to the client. Dependencies are the huma package and any custom logic. Important parameters are the huma.Context, status string, and the response value 'v'; output is the manipulated value and/or error.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\ngrp.UseTransformer(func(ctx huma.Context, status string, v any) (any, error) {\n\t// Do something with the output\n\treturn output, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Enabling Struct and Field Nullability in JSON Schema - Go\nDESCRIPTION: These Go struct examples illustrate various approaches to making fields or entire structs nullable within the generated JSON Schema, such as using nullable tags or pointer types. The first struct shows how the presence of a field named '_' with nullable:true makes the entire struct nullable, while the second struct demonstrates making scalar fields nullable through pointer types or explicit nullable:true tags. A constraint is that nullability for maps and structs at the field level is not supported (struct-level nullability must be used). These patterns determine whether the generated schema allows 'null' as a value, impacting how validation behaves for absent or null fields in incoming API data.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-validation.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Make an entire struct (not its fields) nullable.\ntype MyStruct1 struct {\n    _ struct{} `nullable:\"true\"`\n    Field1 string `json:\"field1\"`\n    Field2 string `json:\"field2\"`\n}\n\n// Make a specific scalar field nullable. This is *not* supported for\n// maps or structs. Structs *must* use the method above.\ntype MyStruct2 struct {\n    Field1 *string `json:\"field1\"`\n    Field2 string `json:\"field2\" nullable:\"true\"`\n}\n```\n\n----------------------------------------\n\nTITLE: Using OmittableNullable Custom Type in an API Operation in Go\nDESCRIPTION: Example of using the OmittableNullable custom type in an API operation. This demonstrates how to handle different states (omitted, null, value) and how the custom schema generation affects the OpenAPI documentation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/schema-customization.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\ntype MyResponse struct {\n\tBody struct {\n\t\tMessage string `json:\"message\"`\n\t}\n}\n\nhuma.Register(api, huma.Operation{\n\tOperationID: \"omittable\",\n\tMethod:      http.MethodPost,\n\tPath:        \"/omittable\",\n\tSummary:     \"Omittable / nullable example\",\n}, func(ctx context.Context, input *struct {\n\t// Making the body a pointer makes it optional, as it may be `nil`.\n\tBody *struct {\n\t\tName OmittableNullable[string] `json:\"name,omitempty\" maxLength:\"10\"`\n\t}\n}) (*MyResponse, error) {\n\tresp := &MyResponse{}\n\tif input.Body == nil {\n\t\tresp.Body.Message = \"Body was not sent\"\n\t} else if !input.Body.Name.Sent {\n\t\tresp.Body.Message = \"Name was omitted from the request\"\n\t} else if input.Body.Name.Null {\n\t\tresp.Body.Message = \"Name was set to null\"\n\t} else {\n\t\tresp.Body.Message = \"Name was set to: \" + input.Body.Name.Value\n\t}\n\treturn resp, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Restish on Linux\nDESCRIPTION: Commands for installing Restish on Linux systems using either Go package manager or Homebrew for Linux. Requires Go 1.18+ for Go installation method.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/cli-client.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n\n# Homebrew for Linux\n$ brew tap danielgtaylor/restish\n$ brew install restish\n```\n\n----------------------------------------\n\nTITLE: Customizing Documentation for a Group Operation - huma (Go)\nDESCRIPTION: This Go code defines a custom method for huma.Group to override operation documentation. It invokes ModifyOperation and, based on the type of the API field, either delegates to a nested documenter or adds the operation to OpenAPI (unless hidden). Dependencies are huma and its interfaces. Inputs are the operation pointer; the output is the side-effect of documenting or skipping the operation in OpenAPI.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_7\n\nLANGUAGE: go\nCODE:\n```\ntype MyGroup huma.Group\n\nfunc (g *MyGroup) DocumentOperation(op *huma.Operation) {\n\tg.ModifyOperation(op, func(op *huma.Operation) {\n\t\tif documenter, ok := g.API.(huma.OperationDocumenter); ok {\n\t\t\t// Support nested operation documenters (i.e. groups of groups).\n\t\t\tdocumenter.DocumentOperation(op)\n\t\t} else {\n\t\t\t// Default behavior to add operations.\n\t\t\tif op.Hidden {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tg.OpenAPI().AddOperation(op)\n\t\t}\n\t})\n}\n```\n\n----------------------------------------\n\nTITLE: Visualizing Middleware Flow - Mermaid - Diagram\nDESCRIPTION: This mermaid snippet illustrates the request and middleware flow in a Huma API application, showing the sequence from incoming request to router-specific middleware, then Huma middleware, and finally the operation handler. The graph helps developers understand the order in which different types of middleware are invoked. It does not require code execution but offers valuable visual context for middleware hierarchy.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\\n\\tRequest([Request])\\n\\tRouterSpecificMiddleware[Router-Specific Middleware]\\n\\tHumaMiddleware[Huma Middleware]\\n\\tOperationHandler[Operation Handler]\\n\\n\\tRequest --> RouterSpecificMiddleware\\n\\tRouterSpecificMiddleware --> HumaMiddleware\\n\\tsubgraph Huma\\n\\t\\tHumaMiddleware --> OperationHandler\\n\\tend\n```\n\n----------------------------------------\n\nTITLE: Changing Request Body Size Limits in Huma Operations (Go)\nDESCRIPTION: This code configures a Huma HTTP operation to accept larger request bodies by setting MaxBodyBytes in the huma.Operation struct when registering a handler. Required dependencies include the huma framework and net/http for method constants. MaxBodyBytes limits the maximum in-memory size of the parsed request; exceeding it triggers a 413 error. Key inputs are operation metadata and the desired byte limit, here set to 10 MiB, and the approach should be used with caution to avoid excessive memory consumption.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-limits.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID:  \"put-thing\",\n\tMethod:       http.MethodPut,\n\tPath:         \"/things/{thing-id}\",\n\tSummary:      \"Put a thing by ID\",\n\tMaxBodyBytes: 10 * 1024 * 1024, // 10 MiB\n}, func(ctx context.Context, input ThingRequest) (*struct{}, error) {\n\t// Do nothing...\n\treturn nil, nil\n}\n)\n```\n\n----------------------------------------\n\nTITLE: Basic Operation Registration in Huma\nDESCRIPTION: Shows how to register a basic HTTP operation using huma.Register with operation ID, method, path and handler function.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/operations.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"your-operation-name\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/path/to/resource/{id}\",\n\tSummary:     \"A short description of the operation\",\n}, func(ctx context.Context, input *YourInput) (*YourOutput, error) {\n\t// ... Implementation goes here ...\n})\n```\n\n----------------------------------------\n\nTITLE: API Endpoint Response Example - JSON Structure\nDESCRIPTION: This snippet illustrates a sample successful HTTP response from the queried Huma API endpoint. It provides an example JSON body containing a reference to the response schema and the actual message payload. Prerequisites include a working API endpoint that delivers JSON payloads according to a documented schema. The key properties are '$schema', indicating where the response body structure is defined, and 'message', the greeting string. This output is typically consumed by clients or used for documentation/testing, and extra fields may be truncated (as implied by the surrounding context).\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/README.md#_snippet_2\n\nLANGUAGE: json\nCODE:\n```\n{\n\t$schema: \"http://localhost:8888/schemas/GreetingOutputBody.json\",\n\tmessage: \"Hello, world!\"\n}\n```\n\n----------------------------------------\n\nTITLE: Customizing App Name And Version - Cobra and humacli in Go\nDESCRIPTION: This Go snippet demonstrates how to set custom application name and version in a Cobra-powered CLI by modifying the root command's 'Use' and 'Version' fields. These settings affect the CLI help and version output. Prerequisites are an existing humacli.CLI instance and the Cobra framework.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\n// cli := humacli.New(...)\n\ncmd := cli.Root()\ncmd.Use = \"appname\"\ncmd.Version = \"1.0.1\"\n\ncli.Run()\n```\n\n----------------------------------------\n\nTITLE: Visualizing Huma's Approach to API Design and Implementation\nDESCRIPTION: This diagram shows how Huma enables simultaneous design-first and code-first approaches, including skeleton creation, review, and implementation stages.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/why/what-about-design-first.md#_snippet_1\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n\tHumaSkeleton[Huma Skeleton] --> Review\n\tHumaSkeleton --> OpenAPI[OpenAPI Spec]\n\tOpenAPI --> Review\n\tReview --> HumaSkeleton\n\tReview --> HumaImplementation[Huma Implementation]\n\tHumaImplementation --> Review2[Review]\n\tReview2 --> HumaImplementation\n\tReview2 --> Deploy\n```\n\n----------------------------------------\n\nTITLE: Querying HTTP API Endpoint Using Restish - Shell\nDESCRIPTION: This snippet demonstrates how to use the Restish command-line HTTP client to query the '/greeting/world' API endpoint running on localhost at port 8888. It sends an HTTP GET request and expects to receive a response from a Huma server. Restish must be installed and available as a shell command, and the Huma API server must be running and listening on port 8888. The only required parameter is the endpoint URL (here: ':8888/greeting/world'), and the output includes the HTTP response for further processing.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/README.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ restish :8888/greeting/world\n```\n\n----------------------------------------\n\nTITLE: Wrapping Context with Custom Values - Go\nDESCRIPTION: This Go snippet shows how to wrap huma.Context with additional context values using huma.WithValue. Middleware can add data (e.g., IDs, user info) to the context for downstream access. The wrapped context is then passed to next. Dependencies: github.com/danielgtaylor/huma/v2. Inputs: the context, a key, and a value; output: modified context for further processing.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_6\n\nLANGUAGE: go\nCODE:\n```\nfunc MyMiddleware(ctx huma.Context, next func(huma.Context)) {\\n\\t// Wrap the context to add a value.\\n\\tctx = huma.WithValue(ctx, \"some-key\", \"some-value\")\\n\\n\\t// Call the next middleware in the chain. This eventually calls the\\n\\t// operation handler as well.\\n\\tnext(ctx)\\n}\n```\n\n----------------------------------------\n\nTITLE: Making Content Negotiated API Requests Using Restish (sh)\nDESCRIPTION: This shell snippet demonstrates sending data in YAML format and requesting CBOR-formatted responses from an API using the 'restish' CLI. The first command pipes YAML content and sets the 'Content-Type' header to 'application/yaml' for a PUT request; the second command requests a CBOR response by setting the 'Accept' header. The output includes typical HTTP response headers. These examples require the 'restish' CLI tool and are useful for validating that server-side content negotiation and serialization settings are effective.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-serialization.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# Send YAML as input using Restish\n$ echo 'foo: bar' | \\\n\trestish put api.rest.sh -H 'Content-Type:application/yaml'\n\n# Get CBOR output from an API\n$ restish api.rest.sh -H 'Accept:application/cbor'\nHTTP/2.0 200 OK\nContent-Length: 318\nContent-Type: application/cbor\nEtag: O7fTqWETqWI\n...\n```\n\n----------------------------------------\n\nTITLE: Enabling Auto Patch in Go for Huma API\nDESCRIPTION: This snippet shows how to import and use the autopatch package to automatically generate PATCH operations for resources in a Huma API. It should be called after registering operations.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/auto-patch.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\nimport \"github.com/danielgtaylor/huma/autopatch\"\n\n// ...\n\n// Later in the code *after* registering operations...\nautopatch.AutoPatch(api)\n```\n\n----------------------------------------\n\nTITLE: Asserting API Test Responses in Go\nDESCRIPTION: This snippet demonstrates using Go assertions to check status codes and response bodies from ResponseRecorder after test requests. It checks that the HTTP status is as expected and that the response body contains certain text. Dependencies: Go testing and strings libraries. Inputs: resp (ResponseRecorder); outputs: triggers test failure if expectations are not met.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/test-utilities.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\nif resp.Code != http.StatusOK {\n\tt.Fail(\"Unexpected status code\", resp.Code)\n}\n\nif !strings.Contains(resp.Body.String(), \"some text\") {\n\tt.Fail(\"Unexpected response body\", resp.Body.String())\n}\n```\n\n----------------------------------------\n\nTITLE: Passing CLI Options to a Huma API Service\nDESCRIPTION: Examples of different ways to pass configuration options to a Huma API service, including using command-line arguments with both long and short forms, and setting environment variables with the SERVICE_ prefix.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/service-configuration.md#_snippet_1\n\nLANGUAGE: bash\nCODE:\n```\n# Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n```\n\n----------------------------------------\n\nTITLE: Advanced Multipart Form Processing with Struct Decoding in Go\nDESCRIPTION: Shows how to process and validate multipart form data, including file uploads, by decoding into a structured Go type.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_4\n\nLANGUAGE: go\nCODE:\n```\nhuma.Register(api, huma.Operation{\n\tOperationID: \"upload-and-decode-files\"\n\tMethod:      http.MethodPost,\n\tPath:        \"/upload\",\n}, func(ctx context.Context, input *struct {\n\tRawBody huma.MultipartFormFiles[struct {\n\t\tMyFile                    huma.FormFile   `form:\"file\" contentType:\"text/plain\" required:\"true\"`\n\t\tSomeOtherFiles            []huma.FormFile `form:\"other-files\" contentType:\"text/plain\" required:\"true\"`\n\t\tNoTagBindingFile          huma.FormFile   `contentType:\"text/plain\"`\n\t\tMyGreeting                string          `form:\"greeting\", minLength:\"6\"`\n\t\tSomeNumbers               []int           `form:\"numbers\"`\n\t\tNonTaggedValuesAreIgnored string  // ignored\n\t}]\n}) (*struct{}, error) {\n\t// The raw multipart.Form body is again available under input.RawBody.Form.\n\t// E.g. input.RawBody.Form.File(\"file\")\n\t// E.g. input.RawBody.Form.Value(\"greeting\")\n\n\t// The processed input struct is available under input.RawBody.Data().\n\tformData := input.RawBody.Data()\n\n\t// Non-files are available and validated if they have a \"form\" tag\n\tfmt.Println(formData.MyGreeting)\n\tfmt.Println(\"These are your numbers:\")\n\tfor _, n := range formData.SomeNumbers {\n\t\tfmt.Println(n)\n\t}\n\n\t// Non-files without \"form\" tag are not available\n\tif formData.NonTaggedValuesAreIgnored != nil {\n\t\tpanic(\"This should not happen\")\n\t}\n\n\t// Process files here.\n\tb, err := io.ReadAll(formData.MyFile)\n\tfmt.Println(string(b))\n\n\tfor _, f := range formData.SomeOtherFiles {\n\t\tb, err := io.ReadAll(f)\n\t\tfmt.Println(string(b))\n\t}\n\n\t// Flag for checking optional file existence.\n\tif formData.NoTagBindingFile.IsSet {\n\t\tfmt.Println(\"The form contained a file entry with name 'NoTagBinding'!\")\n\t}\n\treturn nil, nil\n})\n```\n\n----------------------------------------\n\nTITLE: Calling the API Endpoint Using Curl\nDESCRIPTION: This shell snippet demonstrates how to invoke the Huma API by issuing an HTTP GET request to /greeting/world with curl. The expected JSON response includes a greeting message for 'world'. The API must be running on localhost:8888 prior to making this request.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n# Get a greeting from the API\n$ curl http://localhost:8888/greeting/world\n```\n\n----------------------------------------\n\nTITLE: SchemaProvider Interface Definition in Go\nDESCRIPTION: The SchemaProvider interface definition that can be implemented by types to provide custom schema generation. This interface allows custom types to override the built-in schema generation process.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/schema-customization.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\n// SchemaProvider is an interface that can be implemented by types to provide\n// a custom schema for themselves, overriding the built-in schema generation.\n// This can be used by custom types with their own special serialization rules.\ntype SchemaProvider interface {\n\tSchema(r huma.Registry) *huma.Schema\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Greeting Response Model with Struct in Golang\nDESCRIPTION: This Golang snippet defines the GreetingOutput struct, representing the API response payload for greeting operations. The nested Body struct contains a Message field with JSON serialization tags and additional annotations for sample data and documentation generation. This model is used to marshal the JSON response for the endpoint. No explicit dependencies are required beyond standard Golang usage of structs and tags.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_0\n\nLANGUAGE: go\nCODE:\n```\npackage main\n\n// GreetingOutput represents the greeting operation response.\ntype GreetingOutput struct {\n\tBody struct {\n\t\tMessage string `json:\"message\" example:\"Hello, world!\" doc:\"Greeting message\"`\n\t}\n}\n```\n\n----------------------------------------\n\nTITLE: Empty Input/Output Operation Handler\nDESCRIPTION: Shows how to handle operations with no input or output using empty structs.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/operations.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\nfunc(ctx context.Context, input *struct{}) (*struct{}, error) {\n    // Successful response example, defaults to HTTP 204 No Content\n    return nil, nil\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Fiber Router Middleware - Go\nDESCRIPTION: This Go snippet demonstrates setting up middleware in a Huma API using the Fiber HTTP router. The example shows the instantiation of the Fiber app, the addition of a logger middleware, and creation of the Huma API instance with Fiber router and default configuration. Dependencies: github.com/gofiber/fiber/v2, github.com/gofiber/logger/v2, github.com/danielgtaylor/huma/v2/adapters/humafiber. The code requires a Fiber app, logger middleware, and appropriate Huma API config as parameters, returning an API instance ready to handle requests.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/middleware.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\napp := fiber.New()\\napp.Use(logger.New())\\napi := humafiber.New(app, huma.DefaultConfig(\"My API\", \"1.0.0\"))\n```\n\n----------------------------------------\n\nTITLE: Registering Auth Middleware\nDESCRIPTION: Shows how to register the JWT authorization middleware with the API instance.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/how-to/oauth2-jwt.md#_snippet_3\n\nLANGUAGE: go\nCODE:\n```\napi.UseMiddleware(NewAuthMiddleware(api, \"https://example.com/.well-known/jwks.json\"))\n```\n\n----------------------------------------\n\nTITLE: HTTP Response Header with Schema Link\nDESCRIPTION: Example of an HTTP response header containing a describedby link relation that references a JSON Schema file.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/json-schema-registry.md#_snippet_0\n\nLANGUAGE: http\nCODE:\n```\nLink: </schemas/Note.json>; rel=\"describedby\"\n```\n\n----------------------------------------\n\nTITLE: Implementing OmittableNullable Type with Custom Schema Generation in Go\nDESCRIPTION: Implementation of a generic OmittableNullable type that tracks whether a field was omitted, null, or has a value. It implements the SchemaProvider interface to customize schema generation for this specialized type.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/schema-customization.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// OmittableNullable is a field which can be omitted from the input,\n// set to `null`, or set to a value. Each state is tracked and can\n// be checked for in handling code.\ntype OmittableNullable[T any] struct {\n\tSent  bool\n\tNull  bool\n\tValue T\n}\n\n// UnmarshalJSON unmarshals this value from JSON input.\nfunc (o *OmittableNullable[T]) UnmarshalJSON(b []byte) error {\n\tif len(b) > 0 {\n\t\to.Sent = true\n\t\tif bytes.Equal(b, []byte(\"null\")) {\n\t\t\to.Null = true\n\t\t\treturn nil\n\t\t}\n\t\treturn json.Unmarshal(b, &o.Value)\n\t}\n\treturn nil\n}\n\n// Schema returns a schema representing this value on the wire.\n// It returns the schema of the contained type.\nfunc (o OmittableNullable[T]) Schema(r huma.Registry) *huma.Schema {\n\treturn r.Schema(reflect.TypeOf(o.Value), true, \"\")\n}\n```\n\n----------------------------------------\n\nTITLE: Group Prefixes via Modifier - huma (Go)\nDESCRIPTION: This snippet manually creates a huma.Group and attaches one or more path prefixes via the PrefixModifier. This technique is equivalent to passing prefixes to huma.NewGroup directly, but offers more explicit modifier usage for custom logic. Dependencies include the huma package and an initialized API instance. Inputs are the API instance and a list of prefixes; outputs are the configured group.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/groups.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\ngrp := huma.NewGroup(api)\ngrp.UseModifier(huma.PrefixModifier(\"/prefix1\", \"/prefix2\", \"...\"))\n```\n\n----------------------------------------\n\nTITLE: Imposing Operation Deadlines with context.Context in Go\nDESCRIPTION: This snippet shows how to create a Go context with a configured timeout, which is then used for downstream operations such as database calls. Dependencies include the context and time packages. context.WithTimeout creates a new context with a 10-second duration, and its cancellation function is deferred. Inputs include the parent context and downstream resource access. The approach ensures that if the deadline is exceeded, resources can be released and error handling can occur appropriately.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-limits.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Create a new context with a 10 second timeout.\nnewCtx, cancel := context.WithTimeout(ctx, 10 * time.Second)\ndefer cancel()\n\n// Use the new context for any dependencies.\nresult, err := myDB.Get(newCtx, /* ... */)\nif err != nil {\n\t// Deadline may have been hit, handle it here!\n}\n```\n\n----------------------------------------\n\nTITLE: Serving Scalar Docs API Documentation with Huma and Chi in Go\nDESCRIPTION: This Go code example shows how to serve a custom HTML documentation page using Scalar Docs at the /docs endpoint. It initializes a Chi router with Huma, ensures the default docs are disabled, and injects Scalar's API reference by referencing the /openapi.json endpoint. Requires humachi and chi packages, Scalar Docs JavaScript CDN, and an accessible OpenAPI JSON file. There are no input parameters; output is an HTML documentation UI for the API.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/api-docs.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\nrouter := chi.NewRouter()\nconfig := huma.DefaultConfig(\"Docs Example\", \"1.0.0\")\nconfig.DocsPath = \"\"\n\napi := humachi.New(router, config)\n\nrouter.Get(\"/docs\", func(w http.ResponseWriter, r *http.Request) {\n\tw.Header().Set(\"Content-Type\", \"text/html\")\n\tw.Write([]byte(`<!doctype html>\n<html>\n  <head>\n    <title>API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      data-url=\"/openapi.json\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"></script>\n  </body>\n</html>`))\n})\n```\n\n----------------------------------------\n\nTITLE: JSON Response with Schema Reference\nDESCRIPTION: Example of a JSON response object that includes a $schema property linking to its schema definition, enabling editor features like code completion and validation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/json-schema-registry.md#_snippet_1\n\nLANGUAGE: json\nCODE:\n```\n{\n\t\"$schema\": \"http://localhost:8888/schemas/Note.json\",\n\t\"title\": \"I am a note title\",\n\t\"contents\": \"Example note contents\",\n\t\"labels\": [\"todo\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Benchmarking Go Web API Frameworks - Shell Script\nDESCRIPTION: This snippet shows microbenchmark results for Huma v1, Huma v2, and raw Chi in Go using standard Go benchmarking output. It demonstrates performance metrics such as operations per second, nanoseconds per operation, bytes per operation, and allocations per operation. No external dependencies are required apart from Go's built-in benchmarking tools, and the results illustrate the improvements between framework versions and against using the raw Chi router without Huma.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/why/benchmarks.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n# Huma v1\\nBenchmarkHumaV1Chi-10         16285  112086 ns/op  852209 B/op  258 allocs/op\\n\\n# Huma v2\\nBenchmarkHumaV2Chi-10        431028    2777 ns/op    1718 B/op   29 allocs/op\\n\\n# Chi without Huma (raw)\\nBenchmarkRawChi-10           552764    2143 ns/op    2370 B/op   29 allocs/op\n```\n\n----------------------------------------\n\nTITLE: Registering Custom OpenAPI Command - Cobra and humacli in Go\nDESCRIPTION: This Go snippet registers a custom subcommand with the Cobra-based CLI to print the OpenAPI spec using a predefined API object. The command adds usage and summary fields and fetches the OpenAPI YAML output, printing it to stdout. It relies on cobra.Command, a huma.API instance, and the humacli/Cobra infrastructure; error handling is included for the spec generation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_5\n\nLANGUAGE: go\nCODE:\n```\nvar api huma.API\n\n// ... set up the CLI, create the API wrapping the router ...\n\ncli.Root().AddCommand(&cobra.Command{\n\tUse:   \"openapi\",\n\tShort: \"Print the OpenAPI spec\",\n\tRun: func(cmd *cobra.Command, args []string) {\n\t\tb, err := api.OpenAPI().YAML()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tfmt.Println(string(b))\n\t},\n})\n```\n\n----------------------------------------\n\nTITLE: Querying Huma API Endpoints Using Shell\nDESCRIPTION: This shell snippet illustrates how to use the restish CLI tool to call a demo API operation and retrieve the OpenAPI specification from a running Huma server. 'restish :8888/api/demo' triggers a GET request to the demo endpoint, while 'restish :8888/api/openapi.yaml' fetches the API definition. The server must be running locally on port 8888 with '/api' routing. Requires restish installed and accessible from the shell.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/bring-your-own-router.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n# Call the demo operation\nrestish :8888/api/demo\n\n# Get the OpenAPI\nrestish :8888/api/openapi.yaml\n\n```\n\n----------------------------------------\n\nTITLE: Go Module Dependency Installation\nDESCRIPTION: This shell command runs 'go mod tidy' to install missing dependencies and update the go.mod/go.sum files as required for the Huma API project. Must be run in the project root directory. Prerequisite: Go SDK installed.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/your-first-api.md#_snippet_4\n\nLANGUAGE: bash\nCODE:\n```\n$ go mod tidy\n```\n\n----------------------------------------\n\nTITLE: Request Flow in Huma Adapter (Mermaid Diagram)\nDESCRIPTION: This Mermaid diagram visualizes the request flow from the client to a Huma operation handler, illustrating how a router-specific context (such as http.Request or fiber.Ctx) is transformed into a router-agnostic huma.Context. It highlights the adapter's role in context conversion between the router and the operation handler. No inputs or outputs beyond the conceptual flow; used for documentation and understanding only.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/bring-your-own-router.md#_snippet_3\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n\tRequest([Request])\n\tOperationHandler[Operation Handler]\n\n\tRequest --> Router\n\tRouter -->|http.Request<br>fiber.Ctx<br>etc| huma.Adapter\n\tsubgraph huma.API\n\t\thuma.Adapter -->|huma.Context| OperationHandler\n\tend\n\n```\n\n----------------------------------------\n\nTITLE: Passing Options via Command-Line and Environment Variables - Go CLI in Bash\nDESCRIPTION: This bash snippet demonstrates how to pass configuration options to the Go CLI service via command-line flags or environment variables. It gives usage for long and short-form arguments, and sets environment variables with the SERVICE_ prefix for option binding. The Go binary must be available, and environment variables take precedence unless overridden by flags.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/cli.md#_snippet_3\n\nLANGUAGE: bash\nCODE:\n```\n# Example passing command-line args\n$ go run main.go --port=8000\n\n# Short arguments are also supported\n$ go run main.go -p 8000\n\n# Example passing by environment variables\n$ SERVICE_PORT=8000 go run main.go\n```\n\n----------------------------------------\n\nTITLE: Installing Restish on Windows\nDESCRIPTION: Command for installing Restish on Windows systems using Go package manager. Requires Go 1.18+.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/cli-client.md#_snippet_2\n\nLANGUAGE: bash\nCODE:\n```\n# Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n```\n\n----------------------------------------\n\nTITLE: Visualizing API Design and Implementation Process with Mermaid\nDESCRIPTION: This diagram illustrates the process of API specification review, code implementation, and deployment using Mermaid graph syntax.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/why/what-about-design-first.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\ngraph LR\n\tAPISpec[API Spec] --> Review\n\tReview --> APISpec\n\tReview --> Code\n\tCode --> Review2[Review]\n\tReview2 --> Code\n\tReview2 --> Deploy\n```\n\n----------------------------------------\n\nTITLE: Displaying Project Directory Structure in Go Project Setup - Markdown\nDESCRIPTION: Shows the expected directory structure after initializing a Go project with Huma. This code snippet informs developers of the standard files (go.mod and go.sum) that should be present before building the API. No dependencies or runtime requirements are needed; it is for descriptive and illustrative purposes.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/installation.md#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n```title=\\\"Directory Structure\\\"\\nmy-api/\\n  |-- go.mod\\n  |-- go.sum\\n```\n```\n\n----------------------------------------\n\nTITLE: Installing Restish on Mac\nDESCRIPTION: Commands for installing Restish on MacOS using either Homebrew or Go package manager. Requires Go 1.18+ for Go installation method.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/tutorial/cli-client.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Homebrew\n$ brew tap danielgtaylor/restish\n$ brew install restish\n\n# Go (requires Go 1.18+)\n$ go install github.com/danielgtaylor/restish@latest\n```\n\n----------------------------------------\n\nTITLE: Disabling Auto Patch for a Specific Resource in Go\nDESCRIPTION: This code snippet shows how to disable the auto patch feature for a specific resource by setting metadata on an operation. It sets the 'autopatch' metadata to false when registering an operation.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/auto-patch.md#_snippet_2\n\nLANGUAGE: go\nCODE:\n```\n// Register an operation that won't get a PATCH generated.\nhuma.Register(api, huma.Operation{\n\tOperationID: \"get-greeting\",\n\tMethod:      http.MethodGet,\n\tPath:        \"/greeting/{name}\",\n\tSummary:     \"Get a greeting\",\n\tMetadata: map[string]interface{}{\n\t\t\"autopatch\": false,\n\t},\n}, func(ctx context.Context, input *GreetingInput) (*GreetingOutput, error) {\n\t// ...\n})\n```\n\n----------------------------------------\n\nTITLE: Visualizing Response Transform Lifecycle with Mermaid (Markdown Diagram)\nDESCRIPTION: Illustrates the lifecycle of an HTTP response within Huma: starting at the request, through middleware, handler, and transformer, ending at the marshaled response. The diagram places emphasis on the Transformer component, showing when in the flow response data can be altered. No dependencies are required to interpret the diagram beyond Mermaid rendering support. Inputs and outputs are the logical data flow elements named in the diagram; this is useful for understanding integration points for response transformers.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/response-transformers.md#_snippet_0\n\nLANGUAGE: mermaid\nCODE:\n```\nflowchart LR\\n\\tRequest --> Middleware\\n\\tMiddleware --> Unmarshal\\n\\tsubgraph Huma\\n\\t\\tUnmarshal --> Handler\\n\\t\\tHandler --> Transformer\\n\\t\\tTransformer --> Marshal\\n\\tend\\n\\tMarshal --> Response\\n\\n\\tstyle Transformer stroke:#f9f,stroke-width:2px,stroke-dasharray: 5 5\n```\n\n----------------------------------------\n\nTITLE: Implementing Custom Wrapper for Optional Parameters in Go\nDESCRIPTION: Shows how to create a custom wrapper type for handling optional query parameters, implementing necessary interfaces for Huma integration.\nSOURCE: https://github.com/danielgtaylor/huma/blob/main/docs/docs/features/request-inputs.md#_snippet_1\n\nLANGUAGE: go\nCODE:\n```\ntype OptionalParam[T any] struct {\n\tValue T\n\tIsSet bool\n}\n\nfunc (o OptionalParam[T]) Schema(r huma.Registry) *huma.Schema {\n\treturn huma.SchemaFromType(r, reflect.TypeOf(o.Value))\n}\n\nfunc (o *OptionalParam[T]) Receiver() reflect.Value {\n\treturn reflect.ValueOf(o).Elem().Field(0)\n}\n\nfunc (o *OptionalParam[T]) OnParamSet(isSet bool, parsed any) {\n\to.IsSet = isSet\n}\n\ntype MyRequestInput struct {\n    MaybeText OptionalParam[string] `query:\"text\"`\n}\n```"
  }
]