[
  {
    "owner": "zce",
    "repo": "velite",
    "content": "TITLE: Declare Collection Types (index.d.ts)\nDESCRIPTION: Declares the TypeScript types for the collections based on the schema defined in the Velite configuration.  It imports the configuration and defines types for each collection, making the data type-safe. Uses type inference to provide accurate type definitions.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport type __vc from '../velite.config.js'\n\ntype Collections = typeof __vc.collections\n\nexport type Post = Collections['posts']['schema']['_output']\nexport declare const posts: Post[]\n\nexport type Other = Collections['others']['schema']['_output']\nexport declare const others: Other[]\n```\n\n----------------------------------------\n\nTITLE: Collection Schema: Name (Velite)\nDESCRIPTION: This snippet shows how to define the `name` option for a Velite collection. The `name` is used to generate the TypeScript type for the collection. The type name is usually a singular noun.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_2\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  name: 'Post'\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Collections with Schemas (Velite)\nDESCRIPTION: This code snippet illustrates how to define content collections with their associated schemas in Velite. It uses `defineCollection` to configure each collection (authors, posts, tags), and exports the configuration using `defineConfig`. The schemas define the structure and validation rules for the content items in each collection.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defineCollection, defineConfig, s } from 'velite'\n\nconst posts = defineCollection({\n  /* collection shema options */\n})\n\nconst authors = defineCollection({\n  /* collection shema options */\n})\n\nconst tags = defineCollection({\n  /* collection shema options */\n})\n\nexport default defineConfig({\n  collections: { authors, posts, tags }\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.metadata() to Parse Document Metadata (TypeScript)\nDESCRIPTION: The `s.metadata()` schema parses markdown content and returns metadata such as reading time and word count. It extracts information from the document body.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nmetadata: s.metadata()\n// document body => { readingTime: 2, wordCount: 100 }\n```\n\n----------------------------------------\n\nTITLE: Import Zod from Velite (JavaScript)\nDESCRIPTION: This snippet shows how to import the Zod library through the 'velite' package.  It re-exports Zod's functionality, making it available for use within Velite projects. `z` can then be used to create schema definitions.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { z } from 'velite'\n\n// `z` is re-export of Zod\n```\n\n----------------------------------------\n\nTITLE: Define a Validation Schema in Velite (TypeScript)\nDESCRIPTION: Defines a validation schema using Velite's `defineSchema` and `s` (extended Zod) for validating a title, email, and a custom validation for checking if a string is equal to 'hello'.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/custom-schema.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineSchema, s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// `s` also includes all members of zod, so you can use `s` as `z`\n\n// for validating title\nexport const title = defineSchema(() => s.string().min(1).max(100))\n\n// for validating email\nexport const email = defineSchema(() => s.string().email({ message: 'Invalid email address' }))\n\n// custom validation logic\nexport const hello = defineSchema(() =>\n  s.string().refine(value => {\n    if (value !== 'hello') {\n      return 'Value must be \"hello\"'\n    }\n    return true\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: Typed Routes example with Velite and Next.js\nDESCRIPTION: This snippet shows how to use the `typedRoutes` experimental feature of Velite to get typed routes in a Next.js application.  It defines a schema for a content collection using Velite and then uses the defined route type to provide type safety for links created with `next/link`.  It includes TypeScript types for the `Route` and `Schema` objects.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { Route } from 'next'\nimport type { Schema } from 'velite'\n\nconst options = defineCollection({\n  // ...\n  schema: s.object({\n    // ...\n    link: z.string() as Schema<Route<'/posts/${string}'>>\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Transformers in velite.config.ts\nDESCRIPTION: This TypeScript code configures Velite to use @shikijs/rehype with transformers for advanced syntax highlighting features. It imports necessary modules and defines a Velite configuration object, specifying transformers for diffs, highlights, focus, and error levels.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport rehypeShiki from '@shikijs/rehype'\nimport { transformerNotationDiff, transformerNotationErrorLevel, transformerNotationFocus, transformerNotationHighlight } from '@shikijs/transformers'\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [\n      [\n        rehypeShiki as any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        {\n          transformers: [\n            transformerNotationDiff({ matchAlgorithm: 'v3' }),\n            transformerNotationHighlight({ matchAlgorithm: 'v3' }),\n            transformerNotationFocus({ matchAlgorithm: 'v3' }),\n            transformerNotationErrorLevel({ matchAlgorithm: 'v3' })\n          ]\n        }\n      ]\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Rendering MDX in a Page (TypeScript)\nDESCRIPTION: This TypeScript code shows how to use the `MDXContent` component in a Next.js page.  It imports the generated `posts` data, a custom `Chart` component, and the `MDXContent` component.  It retrieves a post based on its slug and renders the title and MDX content, passing the necessary components to `MDXContent`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { posts } from '@/.velite'\nimport { Chart } from '@/components/chart' // import your custom components\nimport { MDXContent } from '@/components/mdx-content'\n\nexport default function Post({ params: { slug } }) {\n  const post = posts.find(i => i.slug === slug)\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <MDXContent code={post.code} components={{ Chart }} />\n    </article>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Excerpt Extraction (Velite)\nDESCRIPTION: This snippet shows how to extract an excerpt from the markdown content body using `s.excerpt()` within a Velite collection schema.  The `length` option can be used to control the length of the excerpt.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_12\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s.object({\n    excerpt: s.excerpt({ length: 200 }) // excerpt of the markdown body\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Collection Schema: Extended Schemas (Velite)\nDESCRIPTION: This snippet demonstrates how to use Velite's extended schemas (`s`) to define a schema for a 'posts' collection. It includes validations for slug, date, cover image, optional video file, metadata, excerpt, and content.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_6\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { s } from 'velite'\n\nconst posts = defineCollection({\n  schema: s.object({\n    slug: s.slug('posts'),\n    date: s.isodate(),\n    cover: s.image(),\n    video: s.file().optional(),\n    metadata: s.metadata(),\n    excerpt: s.excerpt(),\n    content: s.markdown()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Velite Configuration with MDX Schema (JavaScript)\nDESCRIPTION: This JavaScript code configures Velite to process MDX files.  It imports the `defineConfig` and `s` functions from the 'velite' package.  It defines a 'posts' collection with a schema that includes a `code` field using `s.mdx()` to compile the MDX content.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post',\n      pattern: 'posts/*.mdx',\n      schema: s.object({\n        title: s.string(),\n        code: s.mdx()\n      })\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Define Collection with Schema\nDESCRIPTION: This snippet demonstrates how to define a collection with a schema using the `defineCollection` function. The schema is defined using `s.object` and specifies the data structure of the collection items, extracting data from frontmatter and markdown body.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s.object({\n    title: s.string(), // from frontmatter\n    description: s.string().optional(), // from frontmatter\n    excerpt: s.string(), // from markdown body,\n    content: s.string() // from markdown body\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.mdx() to Parse MDX Content (TypeScript)\nDESCRIPTION: The `s.mdx(options)` schema parses MDX content and returns the function-body of the component. Options include `gfm`, `removeComments`, and `copyLinkedFiles`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\ncode: s.mdx()\n// => function-body\n```\n\n----------------------------------------\n\nTITLE: Using timestamp schema in collection (TS)\nDESCRIPTION: Demonstrates how to use the `timestamp` schema within a Velite collection definition. It showcases integration into the `schema` property of the `defineCollection` function, assigning it to the `lastModified` field.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/last-modified.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst posts = defineCollection({\n  // ...\n  schema: {\n    // ...\n    lastModified: timestamp()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Velite Collections Configuration\nDESCRIPTION: This JavaScript code defines the Velite configuration file (`velite.config.js`). It imports the necessary functions from 'velite' and defines collections with schemas using Zod. The configuration specifies the collection name, content file pattern, and the schema for each content type, including validation rules and data transformations.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// you can also import re-exported `z` from `velite` if you don't need these extension schemas.\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post', // collection type name\n      pattern: 'posts/**/*.md', // content files glob pattern\n      schema: s\n        .object({\n          title: s.string().max(99), // Zod primitive type\n          slug: s.slug('posts'), // validate format, unique in posts collection\n          // slug: s.path(), // auto generate slug from file path\n          date: s.isodate(), // input Date-like string, output ISO Date string.\n          cover: s.image(), // input image relative path, output image object with blurImage.\n          video: s.file().optional(), // input file relative path, output file public path.\n          metadata: s.metadata(), // extract markdown reading-time, word-count, etc.\n          excerpt: s.excerpt(), // excerpt of markdown content\n          content: s.markdown() // transform markdown to html\n        })\n        // more additional fields (computed fields)\n        .transform(data => ({ ...data, permalink: `/blog/${data.slug}` }))\n    },\n    others: {\n      // other collection schema options\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Typed Velite Configuration with UserConfig type\nDESCRIPTION: This example shows how to use the `UserConfig` type from 'velite' to define the configuration file type.  It provides type checking for the configuration object.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type {import('velite').UserConfig} */\nexport default {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Velite in next.config.ts\nDESCRIPTION: This snippet demonstrates how to start Velite directly within `next.config.ts` using top-level await. It checks if Velite has already started to prevent duplicate builds, especially during development or build processes. The configuration imports and calls the Velite build function conditionally based on whether the `dev` or `build` command is run.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { NextConfig } from 'next'\n\nconst isDev = process.argv.indexOf('dev') !== -1\nconst isBuild = process.argv.indexOf('build') !== -1\nif (!process.env.VELITE_STARTED && (isDev || isBuild)) {\n  process.env.VELITE_STARTED = '1'\n  import('velite').then(m => m.build({ watch: isDev, clean: !isDev }))\n}\n\nconst nextConfig: NextConfig = {\n  /* config options here */\n}\n\nexport default nextConfig\n```\n\n----------------------------------------\n\nTITLE: Data Accessor Functions (content.ts)\nDESCRIPTION: Defines functions to access and filter data from the generated collections. Includes functions for getting a post by slug, posts by category, and authors with filtering, sorting, and pagination. This demonstrates a flexible approach to data retrieval.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { authors, posts } from '../.velite'\n\nimport type { Author, Post } from '../.velite'\n\nexport const getPostBySlug = (slug: string) => {\n  return posts.find(post => post.slug === slug)\n}\n\nexport const getPostsByCategory = (category: string) => {\n  return posts.filter(post => post.category === category)\n}\n\nexport const getAuthors = async <F extends keyof Author>(\n  filter: Filter<Author>,\n  fields?: F[],\n  limit: number = Infinity,\n  offset: number = 0\n): Promise<Pick<Author, F>[]> => {\n  return authors\n    .filter(filter)\n    .sort((a, b) => (a.name > b.name ? -1 : 1))\n    .slice(offset, offset + limit)\n    .map(author => pick(author, fields))\n}\n\nexport const getAuthorsCount = async (filter: Filter<Author> = filters.none): Promise<number> => {\n  return authors.filter(filter).length\n}\n\nexport const getAuthor = async <F extends keyof Author>(filter: Filter<Author>, fields?: F[]): Promise<Pick<Author, F> | undefined> => {\n  const author = authors.find(filter)\n  return author && pick(author, fields)\n}\n\nexport const getAuthorByName = async <F extends keyof Author>(name: string, fields?: F[]): Promise<Pick<Author, F> | undefined> => {\n  return getAuthor(i => i.name === name, fields)\n}\n\nexport const getAuthorBySlug = async <F extends keyof Author>(slug: string, fields?: F[]): Promise<Pick<Author, F> | undefined> => {\n  return getAuthor(i => i.slug === slug, fields)\n}\n```\n\n----------------------------------------\n\nTITLE: Timestamp Schema based on file stat with Velite (TS)\nDESCRIPTION: This snippet defines a custom timestamp schema in Velite that retrieves the last modified time of a file using `fs.promises.stat`. It leverages the `defineSchema` function and incorporates a custom transformation that retrieves the file's last modified time and converts it to an ISO string. The schema also includes a custom validation message.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/last-modified.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stat } from 'fs/promises'\nimport { defineSchema } from 'velite'\n\nconst timestamp = defineSchema(() =>\n  s\n    .custom<string | undefined>(i => i === undefined || typeof i === 'string')\n    .transform<string>(async (value, { meta, addIssue }) => {\n      if (value != null) {\n        addIssue({ fatal: false, code: 'custom', message: '`s.timestamp()` schema will resolve the file modified timestamp' })\n      }\n\n      const stats = await stat(meta.path)\n      return stats.mtime.toISOString()\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Integrating MDX Bundle Schema in Velite Config\nDESCRIPTION: This JavaScript code demonstrates how to integrate the custom MDX bundling schema into a Velite configuration file. It defines a collection named 'posts' that processes MDX files and uses the `mdxBundle` schema to compile the MDX content into JavaScript.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_11\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\nimport { mdxBundle } from './mdx'\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post',\n      pattern: 'posts/*.mdx',\n      schema: s.object({\n        title: s.string(),\n        code: mdxBundle()\n      })\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.markdown() to Parse Markdown Content (TypeScript)\nDESCRIPTION: The `s.markdown(options)` schema parses markdown content and returns the corresponding HTML.  It uses the configured markdown processing options.  Options include `gfm`, `removeComments`, and `copyLinkedFiles`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\ncontent: s.markdown()\n// => html content\n```\n\n----------------------------------------\n\nTITLE: Velite Configuration\nDESCRIPTION: Defines the configuration for Velite collections, including schema definitions using Zod for posts. It specifies the data types, validation rules, and transformation logic for each field in the 'posts' collection.  The configuration options include setting the collection name, file pattern, schema, and transformation functions to generate permalinks.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/posts/1970-01-01-style-guide/index.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// you can also import re-exported `z` from `velite` if you don't need these extension schemas.\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post', // collection type name\n      pattern: 'posts/**/*.md', // content files glob pattern\n      schema: s\n        .object({\n          title: s.string().max(99), // Zod primitive type\n          slug: s.slug('posts'), // validate format, unique in posts collection\n          date: s.isodate(), // input Date-like string, output ISO Date string.\n          cover: s.image().optional(), // input image relpath, output image object with blurImage.\n          video: s.file().optional(), // input file relpath, output file public path.\n          metadata: s.metadata(), // extract markdown reading-time, word-count, etc.\n          excerpt: s.excerpt(), // excerpt of markdown content\n          content: s.markdown() // transform markdown to html\n        })\n        // more additional fields (computed fields)\n        .transform(data => ({ ...data, permalink: `/blog/${data.slug}` }))\n    },\n    others: {\n      // other collection schema options\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Markdown & MDX Processing (Velite)\nDESCRIPTION: This snippet shows how to transform the content body from markdown to HTML using `s.markdown()` within a Velite collection schema. Alternatively, `s.mdx()` can be used for MDX processing.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_10\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s.object({\n    content: s.markdown() // or s.mdx()\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring Velite in next.config.mjs\nDESCRIPTION: This snippet demonstrates how to start Velite directly within `next.config.mjs` using top-level await. It checks if Velite has already started to prevent duplicate builds, especially during development or build processes. The configuration imports and calls the Velite build function conditionally based on whether the `dev` or `build` command is run.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst isDev = process.argv.indexOf('dev') !== -1\nconst isBuild = process.argv.indexOf('build') !== -1\nif (!process.env.VELITE_STARTED && (isDev || isBuild)) {\n  process.env.VELITE_STARTED = '1'\n  const { build } = await import('velite')\n  await build({ watch: isDev, clean: !isDev })\n}\n\n/** @type {import('next').NextConfig} */\nexport default {\n  // next config here...\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Velite Configuration with defineConfig\nDESCRIPTION: This code demonstrates how to use the `defineConfig` function from the 'velite' package to create a typed configuration file. This provides better type safety and auto-completion.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // ...\n})\n```\n\n----------------------------------------\n\nTITLE: Transform Single Field using Zod in TypeScript\nDESCRIPTION: This code snippet demonstrates how to transform a single field within a Zod schema.  The `transform` method is used to convert the value of the `title` field to uppercase. Requires Zod library to be installed.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/introduction.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\ntitle: s.string().transform(value => value.toUpperCase())\n```\n\n----------------------------------------\n\nTITLE: Velite Configuration\nDESCRIPTION: This JavaScript code snippet demonstrates the configuration of a Velite project, defining collections and their schemas using Zod. It shows how to define schemas for different content types, including posts, and how to transform data using the `transform` method.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/content/posts/1970-01-01-style-guide/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// you can also import re-exported `z` from `velite` if you don't need these extension schemas.\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post', // collection type name\n      pattern: 'posts/**/*.md', // content files glob pattern\n      schema: s\n        .object({\n          title: s.string().max(99), // Zod primitive type\n          slug: s.slug('posts'), // validate format, unique in posts collection\n          date: s.isodate(), // input Date-like string, output ISO Date string.\n          cover: s.image().optional(), // input image relpath, output image object with blurImage.\n          video: s.file().optional(), // input file relpath, output file public path.\n          metadata: s.metadata(), // extract markdown reading-time, word-count, etc.\n          excerpt: s.excerpt(), // excerpt of markdown content\n          content: s.markdown() // transform markdown to html\n        })\n        // more additional fields (computed fields)\n        .transform(data => ({ ...data, permalink: `/blog/${data.slug}` }))\n    },\n    others: {\n      // other collection schema options\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Example\nDESCRIPTION: This example demonstrates the recommended directory structure for organizing content collections within a Velite project. Each top-level directory represents a separate collection, containing content files like YAML and Markdown files.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_0\n\nLANGUAGE: Diff\nCODE:\n```\ncontent\n‚îú‚îÄ‚îÄ authors # => authors collection\n‚îÇ   ‚îú‚îÄ‚îÄ zce.yml\n‚îÇ   ‚îî‚îÄ‚îÄ jane.yml\n‚îú‚îÄ‚îÄ posts # => posts collection\n‚îÇ   ‚îú‚îÄ‚îÄ hello-world.md\n‚îÇ   ‚îî‚îÄ‚îÄ another-post.md\n‚îî‚îÄ‚îÄ tags # => tags collection\n    ‚îî‚îÄ‚îÄ all-in-one.yml\n```\n\n----------------------------------------\n\nTITLE: Using s.slug() to Validate Unique Slug Values (TypeScript)\nDESCRIPTION: The `s.slug(by, reserved)` schema validates a slug, ensuring it is unique within a collection (`by`), not a reserved value, and conforms to a slug format. It combines uniqueness checks with format validation. It can return 'Slug already exists', 'Slug is reserved', or 'Invalid slug' issues.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nslug: s.slug('taxonomies', ['admin', 'login'])\n// case 1. unique slug value\n// 'hello-world' => 'hello-world'\n\n// case 2. non-unique value (in all unique by 'taxonomies')\n// 'hello-world' => issue 'Slug already exists'\n\n// case 3. reserved slug value\n// 'admin' => issue 'Slug is reserved'\n\n// case 4. invalid slug value\n// 'Hello World' => issue 'Invalid slug'\n```\n\n----------------------------------------\n\nTITLE: Content Body Access (Velite)\nDESCRIPTION: This snippet illustrates how to access the raw content body and plain text body directly from `meta.content` and `meta.plain` using a custom schema and the `.transform()` method. This allows you to incorporate the content directly into the collection's schema.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_9\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s.object({\n    content: s.custom().transform((data, { meta }) => meta.content),\n    plain: s.custom().transform((data, { meta }) => meta.plain)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.file() to Handle File Paths (TypeScript)\nDESCRIPTION: The `s.file(options)` schema handles file paths relative to the current file. It copies the file to the configured assets directory and returns the public URL. It handles relative, absolute, and full URLs based on the options and existence of the file. Returns 'File not exists' if the file does not exist.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\navatar: s.file()\n// case 1. relative path\n// 'avatar.png' => '/static/avatar-34kjfdsi.png'\n\n// case 2. non-exists file\n// 'not-exists.png' => issue 'File not exists'\n\n// case 3. absolute path or full url (if allowed)\n// '/icon.png' => '/icon.png'\n// 'https://zce.me/logo.png' => 'https://zce.me/logo.png'\n```\n\n----------------------------------------\n\nTITLE: Configuring @shikijs/rehype in velite.config.js\nDESCRIPTION: This JavaScript code configures Velite to use @shikijs/rehype for syntax highlighting with the 'nord' theme. It imports the necessary modules and defines a Velite configuration object with rehypePlugins specified.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_18\n\nLANGUAGE: javascript\nCODE:\n```\nimport rehypeShiki from '@shikijs/rehype'\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [[rehypeShiki, { theme: 'nord' }]]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Custom TOML Loader Definition in Velite\nDESCRIPTION: This code snippet defines a custom loader for TOML files using the `defineLoader` function from Velite. It uses the `toml` library to parse the TOML content of a file and returns a JavaScript object with the parsed data. The loader is configured to handle files with the `.toml` extension.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/custom-loader.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport toml from 'toml'\nimport { defineConfig, defineLoader } from 'velite'\n\nconst tomlLoader = defineLoader({\n  test: /\\.toml$/,\n  load: vfile => {\n    return { data: toml.parse(vfile.toString()) }\n  }\n})\n\nexport default defineConfig({\n  // ...\n  loaders: [tomlLoader]\n})\n```\n\n----------------------------------------\n\nTITLE: Velite npm scripts for Next.js\nDESCRIPTION: This JSON snippet defines npm scripts in `package.json` for running Velite and Next.js concurrently using `npm-run-all`.  The `dev` script starts both the Velite watcher and the Next.js development server. The `build` script cleans Velite and builds the Next.js application sequentially.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"scripts\": {\n    \"dev:content\": \"velite --watch\",\n    \"build:content\": \"velite --clean\",\n    \"dev:next\": \"next dev\",\n    \"build:next\": \"next build\",\n    \"dev\": \"run-p dev:*\",\n    \"build\": \"run-s build:*\",\n    \"start\": \"next start\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom MDX Compilation Schema\nDESCRIPTION: This TypeScript code defines a custom schema for compiling MDX files using esbuild.  It utilizes plugins for virtual sources, MDX compilation, and global externals to bundle the MDX content into a JavaScript function. It returns a promise that resolves with the compiled MDX code.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { dirname, join } from 'node:path'\nimport { globalExternals } from '@fal-works/esbuild-plugin-global-externals'\nimport mdxPlugin from '@mdx-js/esbuild'\nimport { build } from 'esbuild'\n\nimport type { Plugin } from 'esbuild'\n\nconst compileMdx = async (source: string, path: string, options: CompileOptions): Promise<string> => {\n  const virtualSourse: Plugin = {\n    name: 'virtual-source',\n    setup: build => {\n      build.onResolve({ filter: /^__faker_entry/ }, args => {\n        return {\n          path: join(args.resolveDir, args.path),\n          pluginData: { contents: source } // for mdxPlugin\n        }\n      })\n    }\n  }\n\n  const bundled = await build({\n    entryPoints: [`__faker_entry.mdx`],\n    absWorkingDir: dirname(path),\n    write: false,\n    bundle: true,\n    target: 'node18',\n    platform: 'neutral',\n    format: 'esm',\n    globalName: 'VELITE_MDX_COMPONENT',\n    treeShaking: true,\n    jsx: 'automatic',\n    minify: true,\n    plugins: [\n      virtualSourse,\n      mdxPlugin({}),\n      globalExternals({\n        react: {\n          varName: 'React',\n          type: 'cjs'\n        },\n        'react-dom': {\n          varName: 'ReactDOM',\n          type: 'cjs'\n        },\n        'react/jsx-runtime': {\n          varName: '_jsx_runtime',\n          type: 'cjs'\n        }\n      })\n    ]\n  })\n\n  return bundled.outputFiles[0].text.replace('var VELITE_MDX_COMPONENT=', 'return ')\n}\n\nexport const mdxBundle = (options: MdxOptions = {}) =>\n  custom<string>().transform<string>(async (value, { meta: { path, content, config }, addIssue }) => {\n    value = value ?? content\n    if (value == null) {\n      addIssue({ fatal: true, code: 'custom', message: 'The content is empty' })\n      return null as never\n    }\n\n    const enableGfm = options.gfm ?? config.mdx?.gfm ?? true\n    const enableMinify = options.minify ?? config.mdx?.minify ?? true\n    const removeComments = options.removeComments ?? config.mdx?.removeComments ?? true\n    const copyLinkedFiles = options.copyLinkedFiles ?? config.mdx?.copyLinkedFiles ?? true\n    const outputFormat = options.outputFormat ?? config.mdx?.outputFormat ?? 'function-body'\n\n    const remarkPlugins = [] as PluggableList\n    const rehypePlugins = [] as PluggableList\n\n    if (enableGfm) remarkPlugins.push(remarkGfm) // support gfm (autolink literals, footnotes, strikethrough, tables, tasklists).\n    if (removeComments) remarkPlugins.push(remarkRemoveComments) // remove html comments\n    if (copyLinkedFiles) remarkPlugins.push([remarkCopyLinkedFiles, config.output]) // copy linked files to public path and replace their urls with public urls\n    if (options.remarkPlugins != null) remarkPlugins.push(...options.remarkPlugins) // apply remark plugins\n    if (options.rehypePlugins != null) rehypePlugins.push(...options.rehypePlugins) // apply rehype plugins\n    if (config.mdx?.remarkPlugins != null) remarkPlugins.push(...config.mdx.remarkPlugins) // apply global remark plugins\n    if (config.mdx?.rehypePlugins != null) rehypePlugins.push(...config.mdx.rehypePlugins) // apply global rehype plugins\n\n    const compilerOptions = { ...config.mdx, ...options, outputFormat, remarkPlugins, rehypePlugins }\n\n    try {\n      return await compileMdx(value, path, compilerOptions)\n    } catch (err: any) {\n      addIssue({ fatal: true, code: 'custom', message: err.message })\n      return null as never\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: MDX Example Content\nDESCRIPTION: This snippet demonstrates the content of an MDX file.  It includes frontmatter (title), a JavaScript export, and Markdown content with a custom React component.  The example shows how to embed dynamic data and React components within the MDX content.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_1\n\nLANGUAGE: mdx\nCODE:\n```\n---\ntitle: Hello world\n---\n\nexport const year = 2023\n\n# Last year‚Äôs snowfall\n\nIn {year}, the snowfall was above average.\nIt was followed by a warm spring which caused\nflood conditions in many of the nearby rivers.\n\n<Chart year={year} color=\"#fcb32c\" />\n```\n\n----------------------------------------\n\nTITLE: Collection Schema: Single (Velite)\nDESCRIPTION: This snippet shows how to define the `single` option for a Velite collection. The `single` option specifies whether the collection should be treated as a single item, which is useful for collections that only have one content item.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_4\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst site = defineCollection({\n  pattern: 'site/index.yml',\n  single: true\n})\n```\n\n----------------------------------------\n\nTITLE: Homepage YAML Configuration\nDESCRIPTION: This YAML snippet configures the hero section and features of the Velite homepage. It defines the title, tagline, image, and action buttons for the hero section. It also lists key features with icons, titles, and descriptions.\nSOURCE: https://github.com/zce/velite/blob/main/docs/index.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n---\nlayout: home\n\ntitle: Velite\ntitleTemplate: Make Creative Contents Easy\n\nhero:\n  name: Velite\n  text: Make Creative Contents Easy\n  tagline: New Choices for Content-first Apps\n  image:\n    src: /assets/icon.svg\n    alt: Velite Logo\n  actions:\n    - theme: brand\n      text: Get Started\n      link: ./guide/quick-start.md\n    - theme: alt\n      text: View on GitHub\n      link: https://github.com/zce/velite\n\nfeatures:\n  - icon: ü§©\n    title: Out of the Box\n    details: Turns your Markdown / MDX, YAML, JSON, or other files into application data layer.\n  - icon: üí™\n    title: Type-Safe Contents\n    details: Content Fields validation based on Zod schema, and auto-generated TypeScript types.\n  - icon: üöÄ\n    title: Light & Efficient\n    details: Light-weight & High efficiency & Still powerful, faster startup, and better performance.\n  - icon: üóÇÔ∏è\n    title: Assets Processing\n    details: Built-in Assets Processing, such as relative path resolving, image optimization, etc.\n---\n```\n\n----------------------------------------\n\nTITLE: Define Collection with Name\nDESCRIPTION: This code snippet demonstrates how to define a collection named 'Post' using the `defineCollection` function. This defines the type name for the collection.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nconst posts = defineCollection({\n  name: 'Post'\n})\n```\n\n----------------------------------------\n\nTITLE: Options interface in Velite\nDESCRIPTION: Defines the `Options` interface, which is used to configure the `build` function. It includes options for specifying the config file path, cleaning output directories, watching files for changes, and setting the log level.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Options {\n  /**\n   * Specify config file path\n   * @default 'velite.config.{js,ts,mjs,mts,cjs,cts}'\n   */\n  config?: string\n  /**\n   * Clean output directories before build\n   * @default false\n   */\n  clean?: boolean\n  /**\n   * Watch files and rebuild on changes\n   * @default false\n   */\n  watch?: boolean\n  /**\n   * Log level\n   * @default 'info'\n   */\n  logLevel?: LogLevel\n}\n```\n\n----------------------------------------\n\nTITLE: MDX Bundle with ESBuild - TSX\nDESCRIPTION: This snippet shows how to bundle MDX content using ESBuild. It defines a `compileMdx` function that takes MDX source code as input and returns the bundled code. It uses the `@mdx-js/esbuild` plugin for MDX processing and `esbuild` for bundling. The code also uses `globalExternals` to handle external dependencies like `react` and `react/jsx-runtime`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { join, resolve } from 'node:path'\nimport { globalExternals } from '@fal-works/esbuild-plugin-global-externals'\nimport mdxPlugin from '@mdx-js/esbuild'\nimport { build } from 'esbuild'\n\nimport type { Plugin } from 'esbuild'\n\nconst compileMdx = async (source: string): Promise<string> => {\n  const virtualSourse: Plugin = {\n    name: 'virtual-source',\n    setup: build => {\n      build.onResolve({ filter: /^__faker_entry/ }, args => {\n        return {\n          path: join(args.resolveDir, args.path),\n          pluginData: { contents: source } // for mdxPlugin\n        }\n      })\n    }\n  }\n\n  const bundled = await build({\n    entryPoints: [`__faker_entry.mdx`],\n    absWorkingDir: resolve('content'),\n    write: false,\n    bundle: true,\n    target: 'node18',\n    platform: 'neutral',\n    format: 'esm',\n    globalName: 'VELITE_MDX_COMPONENT',\n    treeShaking: true,\n    jsx: 'automatic',\n    // minify: true,\n    plugins: [\n      virtualSourse,\n      mdxPlugin({}),\n      globalExternals({\n        react: {\n          varName: 'React',\n          type: 'cjs'\n        },\n        'react-dom': {\n          varName: 'ReactDOM',\n          type: 'cjs'\n        },\n        'react/jsx-runtime': {\n          varName: '_jsx_runtime',\n          type: 'cjs'\n        }\n      })\n    ]\n  })\n\n  return bundled.outputFiles[0].text.replace('var VELITE_MDX_COMPONENT=', 'return ')\n}\n```\n\n----------------------------------------\n\nTITLE: Define a Transformation Schema in Velite (TypeScript)\nDESCRIPTION: Defines a transformation schema using Velite's `defineSchema` and `s` (extended Zod) for transforming a title string to uppercase.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/custom-schema.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineSchema, s } from 'velite'\n\n// for transforming title\nexport const title = defineSchema(() => s.string().transform(value => value.toUpperCase()))\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Timestamp Schema based on git timestamp with Velite (TS)\nDESCRIPTION: Defines a custom timestamp schema in Velite that retrieves the last commit timestamp for a file using `git log`. It uses `child_process.exec` and `util.promisify` to execute the Git command asynchronously. The transformation function executes the `git log` command, extracts the timestamp, and converts it to an ISO string. The schema also includes a custom validation message.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/last-modified.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { exec } from 'child_process'\nimport { promisify } from 'util'\nimport { defineSchema } from 'velite'\n\nconst execAsync = promisify(exec)\n\nconst timestamp = defineSchema(() =>\n  s\n    .custom<string | undefined>(i => i === undefined || typeof i === 'string')\n    .transform<string>(async (value, { meta, addIssue }) => {\n      if (value != null) {\n        addIssue({ fatal: false, code: 'custom', message: '`s.timestamp()` schema will resolve the value from `git log -1 --format=%cd`' })\n      }\n      const { stdout } = await execAsync(`git log -1 --format=%cd ${meta.path}`)\n      return new Date(stdout || Date.now()).toISOString()\n    })\n)\n```\n\n----------------------------------------\n\nTITLE: Running Velite in watch mode with bun\nDESCRIPTION: This command runs Velite in development mode with watch functionality using bun. Velite monitors the content files for changes and automatically rebuilds the project whenever a change is detected. The `dev` flag likely signifies a development environment configuration.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_15\n\nLANGUAGE: shell\nCODE:\n```\n$ bun velite dev\n```\n\n----------------------------------------\n\nTITLE: Configuring Velite Plugin in Vite (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to integrate Velite with Vite using the @velite/plugin-vite plugin. It imports the velite plugin and the defineConfig function from vite.  It then exports a default configuration object that includes the velite plugin in the plugins array. This enables Velite to be used within the Vite build process.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/readme.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport velite from '@velite/plugin-vite'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [velite()]\n})\n```\n\n----------------------------------------\n\nTITLE: Build function signature in Velite\nDESCRIPTION: Defines the signature of the `build` function. It accepts an optional `Options` object and returns a `Promise` that resolves to a `Result` object. The `Options` object configures the build process.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst build: (options?: Options) => Promise<Result>\n```\n\n----------------------------------------\n\nTITLE: Adding Copy Button Transformer in velite.config.ts\nDESCRIPTION: This TypeScript code defines a custom Shiki transformer to add a copy button to code blocks and integrates it into Velite configuration. It creates a button element and adds it to the code block's parent node, implementing a copy-to-clipboard functionality.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport rehypeShiki from '@shikijs/rehype'\nimport { defineConfig } from 'velite'\n\nconst transformerCopyButton = (): ShikiTransformer => ({\n  name: 'copy-button',\n  pre(node) {\n    node.children.push({\n      type: 'element',\n      tagName: 'button',\n      properties: {\n        type: 'button',\n        className: 'copy',\n        title: 'Copy to clipboard',\n        onclick: `\n          navigator.clipboard.writeText(this.previousSibling.textContent),\n          this.className='copied',\n          this.title='Copied!',\n          setTimeout(()=>this.className='copy',5000)`.replace(/\\s+/g, '')\n      },\n      children: [\n        {\n          type: 'element',\n          tagName: 'svg',\n          properties: {\n            viewBox: '0 0 24 24',\n            fill: 'none',\n            stroke: 'currentColor',\n            strokeWidth: '1.5',\n            strokeLinecap: 'round',\n            strokeLinejoin: 'round'\n          },\n          children: [\n            {\n              type: 'element',\n              tagName: 'rect',\n              properties: {\n                width: '8',\n                height: '4',\n                x: '8',\n                y: '2',\n                rx: '1',\n                ry: '1'\n              },\n              children: []\n            },\n            {\n              type: 'element',\n              tagName: 'path',\n              properties: {\n                d: 'M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2'\n              },\n              children: []\n            },\n            {\n              type: 'element',\n              tagName: 'path',\n              properties: {\n                class: 'check',\n                d: 'm9 14 2 2 4-4'\n              },\n              children: []\n            }\n          ]\n        }\n      ]\n    })\n  }\n})\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [\n      [\n        rehypeShiki as any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        {\n          transformers: [transformerCopyButton()]\n        }\n      ]\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring rehype-highlight in velite.config.js\nDESCRIPTION: This JavaScript code configures Velite to use rehype-highlight for syntax highlighting. It imports the necessary modules and defines a Velite configuration object with rehypePlugins specified.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_23\n\nLANGUAGE: javascript\nCODE:\n```\nimport rehypeHighlight from 'rehype-highlight'\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [rehypeHighlight]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Next.js Post Page Component (page.tsx)\nDESCRIPTION: A Next.js page component that fetches and displays a post based on its slug.  Uses the generated `posts` data and `notFound` from Next.js for error handling. Demonstrates how to integrate Velite's output with Next.js.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { notFound } from 'next/navigation'\n\nimport { posts } from './.velite'\n\ninterface PostProps {\n  params: {\n    slug: string\n  }\n}\n\nfunction getPostBySlug(slug: string) {\n  return posts.find(post => post.slug === slug)\n}\n\nexport default function PostPage({ params }: PostProps) {\n  const post = getPostBySlug(params.slug)\n  if (post == null) notFound()\n  return (\n    <article className=\"prose dark:prose-invert py-6\">\n      <h1 className=\"mb-2\">{post.title}</h1>\n      {post.description && <p className=\"mt-0 text-xl text-slate-700 dark:text-slate-200\">{post.description}</p>}\n      <hr className=\"my-4\" />\n      <div className=\"prose\" dangerouslySetInnerHTML={{ __html: post.content }}></div>\n    </article>\n  )\n}\n\nexport function generateMetadata({ params }: PostProps) {\n  const post = getPostBySlug(params.slug)\n  if (post == null) return {}\n  return { title: post.title, description: post.description }\n}\n\nexport function generateStaticParams() {\n  return posts.map(({ slug }) => ({ slug }))\n}\n```\n\n----------------------------------------\n\nTITLE: Ignoring .velite directory in Git\nDESCRIPTION: This command adds the `.velite` directory to the `.gitignore` file. This ensures that the generated files in the `.velite` directory are not tracked by Git, as they are typically build artifacts.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_10\n\nLANGUAGE: shell\nCODE:\n```\necho '\\n.velite' >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: JSX Component: Image Embedding\nDESCRIPTION: This JSX snippet embeds an image using the `<Image>` component. It specifies the source file (`cover.webp`) and sets the width and height attributes to 800 and 500 respectively. This showcases how to include images within a React component.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/pages/about/index.mdx#_snippet_1\n\nLANGUAGE: JSX\nCODE:\n```\n<Image src=\"cover.webp\" width={800} height={500} />\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/transformers with npm\nDESCRIPTION: This command installs the @shikijs/transformers package using npm, which is used to customize the output of syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install @shikijs/transformers\n```\n\n----------------------------------------\n\nTITLE: Schema Transform: Computed Fields (Velite)\nDESCRIPTION: This code shows how to add computed fields to content items using Zod's `.transform()` method within a Velite collection schema. It creates a permalink field based on the slug.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_7\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s\n    .object({\n      slug: s.slug('posts')\n    })\n    .transform(data => ({\n      ...data,\n      // computed fields\n      permalink: `/blog/${data.slug}`\n    }))\n})\n```\n\n----------------------------------------\n\nTITLE: Using Zod Primitive Types (TypeScript)\nDESCRIPTION: This demonstrates the use of standard Zod primitive types within Velite schemas. These types, such as `string`, `boolean`, and `optional`, can be combined with Velite's custom schemas.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\ntitle: s.string().mix(3).max(100)\ndescription: s.string().optional()\nfeatured: s.boolean().default(false)\n```\n\n----------------------------------------\n\nTITLE: Import Extended Schemas from Velite (JavaScript)\nDESCRIPTION: This snippet demonstrates how to import the extended schema utilities from the 'velite' package. `s` contains custom schemas and also includes all members of Zod. It provides additional features useful for building content models.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// `s` also includes all members of zod, so you can use `s` as `z`\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/transformers with pnpm\nDESCRIPTION: This command installs the @shikijs/transformers package using pnpm, which is used to customize the output of syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm add @shikijs/transformers\n```\n\n----------------------------------------\n\nTITLE: Schema Transform: Context Metadata (Velite)\nDESCRIPTION: This code snippet demonstrates how to use the context object within a schema transformation to access metadata and add a computed field. It shows how to access the `meta.path` to create a path field.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_8\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s\n    .object({\n      // fields\n    })\n    .transform((data, { meta }) => ({\n      ...data,\n      // computed fields\n      path: meta.path // or parse to filename based slug\n    }))\n})\n```\n\n----------------------------------------\n\nTITLE: Styling Code Blocks with CSS\nDESCRIPTION: This CSS code styles code blocks highlighted by Shiki, including setting maximum height, layout, and styles for lines and the copy button. It uses Tailwind CSS utility classes for styling.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_9\n\nLANGUAGE: css\nCODE:\n```\npre.shiki {\n  @apply max-h-(--max-height,80svh) relative flex flex-col overflow-hidden p-0;\n\n  code {\n    @apply grid overflow-auto py-5;\n  }\n\n  .line {\n    @apply relative px-5;\n  }\n\n  button {\n    @apply hover:opacity-100! absolute right-3 top-3 flex cursor-pointer select-none items-center justify-center rounded-md bg-slate-600 text-sm font-medium text-white opacity-0 shadow outline-0 transition;\n\n    svg {\n      @apply m-2 size-5;\n    }\n\n    .check {\n      @apply opacity-0 transition-opacity;\n    }\n\n    &.copied {\n      @apply opacity-100!;\n\n      &::before {\n        @apply border-r border-[#0002] p-2 px-2.5 content-['Copied!'];\n      }\n\n      .check {\n        @apply opacity-100;\n      }\n    }\n  }\n\n  &:hover {\n    button {\n      @apply opacity-80;\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Last Modified Schema (File Stat) - TypeScript\nDESCRIPTION: Defines a Velite schema to extract the last modified timestamp from a file's stats using `fs.promises.stat`. It transforms an optional string input into the file's last modification time in ISO string format.  It requires the `fs.promises` module for file system operations and `velite` for schema definition.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { stat } from 'fs/promises'\nimport { defineSchema } from 'velite'\n\nconst timestamp = defineSchema(() =>\n  s\n    .custom<string | undefined>(i => i === undefined || typeof i === 'string')\n    .transform<string>(async (value, { meta, addIssue }) => {\n      if (value != null) {\n        addIssue({ fatal: false, code: 'custom', message: '`s.timestamp()` schema will resolve the file modified timestamp' })\n      }\n\n      const stats = await stat(meta.path)\n      return stats.mtime.toISOString()\n    })\n)\n\n// use it in your schema\nconst posts = defineCollection({\n  // ...\n  schema: {\n    // ...\n    lastModified: timestamp()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Transform All Collections with defineConfig in TypeScript\nDESCRIPTION: This code snippet demonstrates how to transform all collections using the `defineConfig` function. It adds new `posts` and `tags` data.  This assumes `defineConfig` is a Velite specific function. Requires Velite's configuration setup.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/introduction.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndefineConfig({\n    prepare: async ({ posts, tags }) => {\n      posts.push({\n        title: 'Hello World',\n        slug: 'hello-world',\n        tags: ['hello', 'world']\n      })\n      tags.push({\n        name: 'Hello',\n        slug: 'hello'\n      })\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Ignoring public/static directory in Git\nDESCRIPTION: This command adds the `public/static` directory to the `.gitignore` file. This ensures that static files outputted to `public/static` directory are not tracked by Git, as they are typically build artifacts.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_11\n\nLANGUAGE: shell\nCODE:\n```\necho '\\npublic/static' >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Import with Path Alias (page.tsx)\nDESCRIPTION: Demonstrates importing the generated `posts` data using the defined path alias. This simplifies the import statement and makes the code more readable. Relies on the `tsconfig.json` being properly configured with the path alias.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_8\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { posts } from '#site/content'\n\n// ...\n```\n\n----------------------------------------\n\nTITLE: Image Component\nDESCRIPTION: This snippet uses an `<Image>` component, likely from Next.js or a similar framework, to display an image. It sets the source to \"cover.webp\" and specifies the width and height.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/pages/about/index.mdx#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\n<Image src=\"cover.webp\" width={800} height={500} />\n```\n\n----------------------------------------\n\nTITLE: Using Typed Routes in Next.js Component\nDESCRIPTION: This snippet illustrates using the typed route defined earlier within a Next.js component.  It imports the options object and utilizes the `link` property for a Link component, ensuring type safety when creating links based on the Velite schema.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_6\n\nLANGUAGE: typescriptreact\nCODE:\n```\nimport Link from 'next/link'\n\nimport { options } from '@/.velite'\n\nconst Post = async () => {\n  return (\n    <div>\n      {/* typed route */}\n      <Link href={options.link}>Read more</Link>\n    </div>\n  )\n}\n```\n\n----------------------------------------\n\nTITLE: Importing Velite Output in JavaScript\nDESCRIPTION: This JavaScript code demonstrates how to import the output generated by Velite. The `posts` variable will contain the data from the 'posts' collection, which can then be used within your application.  It assumes the output format is JavaScript modules.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_16\n\nLANGUAGE: javascript\nCODE:\n```\nimport { posts } from './.velite'\n\nconsole.log(posts) // => [{ title: 'Hello world', slug: 'hello-world', ... }, ...]\n```\n\n----------------------------------------\n\nTITLE: Configuring @shikijs/rehype in velite.config.ts\nDESCRIPTION: This TypeScript code configures Velite to use @shikijs/rehype for syntax highlighting with the 'one-dark-pro' theme. It imports the necessary modules and defines a Velite configuration object with rehypePlugins specified.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport rehypeShiki from '@shikijs/rehype'\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [\n      [\n        rehypeShiki as any, // eslint-disable-line @typescript-eslint/no-explicit-any\n        { theme: 'one-dark-pro' }\n      ]\n    ]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Styled Block Quote\nDESCRIPTION: This snippet defines a block quote element within a `div` with the class name \"note\".  The block quote contains a text string.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/pages/about/index.mdx#_snippet_2\n\nLANGUAGE: HTML\nCODE:\n```\n<div className=\"note\">\n\n> Some notable things in a block quote!\n\n</div>\n```\n\n----------------------------------------\n\nTITLE: Rendering MDX with Global Component (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to render MDX content with a global `Callout` component. It includes modifications to the main `MDXContent` component and related code to inject the global component.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Callout } from '@/components/callout'\nimport { MDXContent } from '@/components/mdx-content'\n\nexport default function Post({ params: { slug } }) {\n  const post = posts.find(i => i.slug === slug)\n  return (\n    <article>\n      <h1>{post.title}</h1>\n      <MDXContent code={post.code} components={{ Callout }} />\n    </article>\n  )\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as runtime from 'react/jsx-runtime'\n\nimport { Callout } from '@/components/callout'\n\nconst sharedComponents = {\n  // Add your global components here\n  Callout\n}\n\nconst useMDXComponent = (code: string) => {\n  const fn = new Function(code)\n  return fn({ ...runtime }).default\n}\n\ninterface MDXProps {\n  code: string\n  components?: Record<string, React.ComponentType>\n}\n\nexport const MDXContent = ({ code, components }: MDXProps) => {\n  const Component = useMDXComponent(code)\n  return <Component components={{ ...sharedComponents, ...components }} />\n}\n```\n\n----------------------------------------\n\nTITLE: CSS Banner Styling\nDESCRIPTION: Defines CSS rules for styling a banner element, including its width, height, and image dimensions. This CSS code snippet ensures consistent banner display across the Velite theme.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/posts/1970-01-01-style-guide/index.md#_snippet_0\n\nLANGUAGE: css\nCODE:\n```\n.banner {\n  width: 750px;\n  height: 420px;\n}\n\n.banner image {\n  width: 100%;\n  height: 100%;\n}\n```\n\n----------------------------------------\n\nTITLE: Metadata Extraction (Velite)\nDESCRIPTION: This snippet demonstrates how to automatically extract metadata (reading time, word count, etc.) from content files using `s.metadata()` within a Velite collection schema.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_11\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  schema: s.object({\n    metadata: s.metadata() // extract markdown reading-time, word-count, etc.\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: JSX Component: Block Quote with Styling\nDESCRIPTION: This JSX snippet renders a block quote within a `div` element. The `className` attribute is set to \"note\", which allows for custom styling of the block quote. This showcases the use of styled elements in JSX.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/pages/about/index.mdx#_snippet_2\n\nLANGUAGE: JSX\nCODE:\n```\n<div className=\"note\">\n\n> Some notable things in a block quote!\n\n</div>\n```\n\n----------------------------------------\n\nTITLE: Accessing Schema Context in Velite (TypeScript)\nDESCRIPTION: Demonstrates how to access the schema context in Velite using `ctx.meta` to retrieve file metadata such as the file path. This example converts a nonexistent field to the file path if it exists in the context.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/custom-schema.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineSchema, s } from 'velite'\n\n// convert a nonexistent field\nexport const path = defineSchema(() =>\n  s.custom<string>().transform((value, ctx) => {\n    if (ctx.meta.path) {\n      return ctx.meta.path\n    }\n    return value\n  })\n)\n```\n\n----------------------------------------\n\nTITLE: React Callout Component (TypeScript)\nDESCRIPTION: This is a simple React component example, `Callout`, used for demonstration in the MDX documentation. It defines a basic styled div that renders its children.  This showcases a component used within MDX examples.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nexport const Callout = ({ children }: { children: React.ReactNode }) => {\n  // your common component\n  return <div style={{ border: '1px solid #ddd', padding: '1rem' }}>{children}</div>\n}\n```\n\n----------------------------------------\n\nTITLE: Remote Image with BlurDataURL Schema (TypeScript)\nDESCRIPTION: Defines a schema for handling remote images, fetching image metadata, and adding issues if metadata retrieval fails. Uses `getImageMetadata` to extract metadata from the image buffer.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/custom-schema.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getImageMetadata, s } from 'velite'\n\nimport type { Image } from 'velite'\n\n/**\n * Remote Image with metadata schema\n */\nexport const remoteImage = () =>\n  s.string().transform<Image>(async (value, { addIssue }) => {\n    try {\n      const response = await fetch(value)\n      const blob = await response.blob()\n      const buffer = await blob.arrayBuffer()\n      const metadata = await getImageMetadata(Buffer.from(buffer))\n      if (metadata == null) throw new Error(`Failed to get image metadata: ${value}`)\n      return { src: value, ...metadata }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err)\n      addIssue({ fatal: true, code: 'custom', message })\n      return null as never\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Using s.image() to Handle Image Paths (TypeScript)\nDESCRIPTION: The `s.image(options)` schema processes image paths, similar to `s.file()`, but returns an `Image` object containing metadata like width, height, and a blurDataURL. It copies the image to the configured assets directory. It handles relative, absolute, and full URLs.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\navatar: s.image()\n// case 1. relative path\n// 'avatar.png' => {\n//   src: '/static/avatar-34kjfdsi.png',\n//   width: 100,\n//   height: 100,\n//   blurDataURL: 'data:image/png;base64,xxx',\n//   blurWidth: 8,\n//   blurHeight: 8\n// }\n\n// case 2. non-exists file\n// 'not-exists.png' => issue 'File not exists'\n\n// case 3. absolute path or full url (if allowed)\n// '/icon.png' => { src: '/icon.png', width: 0, height: 0, blurDataURL: '', blurWidth: 0, blurHeight: 0 }\n// 'https://zce.me/logo.png' => { src: 'https://zce.me/logo.png', width: 0, height: 0, blurDataURL: '', blurWidth: 0, blurHeight: 0 }\n```\n\n----------------------------------------\n\nTITLE: Run Development Mode (npm)\nDESCRIPTION: This command starts the Velite example project in development mode with watch enabled. Changes to the code will trigger a rebuild.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/readme.md#_snippet_1\n\nLANGUAGE: Shell\nCODE:\n```\n$ npm run dev # run build with watch mode\n```\n\n----------------------------------------\n\nTITLE: Using git timestamp schema in collection (TS)\nDESCRIPTION: Illustrates how to use the Git-based `timestamp` schema within a Velite collection. Similar to the file stat example, this snippet shows integration with the `schema` property of the `defineCollection` function and assigns the timestamp schema to the `lastModified` field.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/last-modified.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst posts = defineCollection({\n  // ...\n  schema: {\n    // ...\n    lastModified: timestamp()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Styling rehype-pretty-code with CSS\nDESCRIPTION: This CSS code provides styles for code blocks formatted by rehype-pretty-code, including text size, line numbers, and highlighted lines/characters. It uses Tailwind CSS utility classes.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_14\n\nLANGUAGE: css\nCODE:\n```\n[data-rehype-pretty-code-figure] pre {\n  @apply px-0;\n}\n\n[data-rehype-pretty-code-figure] code {\n  @apply text-sm !leading-loose md:text-base;\n}\n\n[data-rehype-pretty-code-figure] code[data-line-numbers] {\n  counter-reset: line;\n}\n\n[data-rehype-pretty-code-figure] code[data-line-numbers] > [data-line]::before {\n  counter-increment: line;\n  content: counter(line);\n  @apply mr-4 inline-block w-4 text-right text-gray-500;\n}\n\n[data-rehype-pretty-code-figure] [data-line] {\n  @apply border-l-2 border-l-transparent px-3;\n}\n\n[data-rehype-pretty-code-figure] [data-highlighted-line] {\n  background: rgba(200, 200, 255, 0.1);\n  @apply border-l-blue-400;\n}\n\n[data-rehype-pretty-code-figure] [data-highlighted-chars] {\n  @apply rounded bg-zinc-600/50;\n  box-shadow: 0 0 0 4px rgb(82 82 91 / 0.5);\n}\n\n[data-rehype-pretty-code-figure] [data-chars-id] {\n  @apply border-b-2 p-1 shadow-none;\n}\n```\n\n----------------------------------------\n\nTITLE: Using s.toc() to Generate Table of Contents (TypeScript)\nDESCRIPTION: The `s.toc(options)` schema parses markdown content and returns the table of contents. The returned value can be either a list of `TocEntry` or a `TocTree`. Options control how the table of contents is generated and formatted.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\ntoc: s.toc()\n// document body => table of contents\n```\n\n----------------------------------------\n\nTITLE: Define Single Collection\nDESCRIPTION: This example shows how to define a single collection using the `defineCollection` function with the `single` option set to `true`.  The `pattern` specifies the path to the single file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nconst site = defineCollection({\n  pattern: 'site/index.yml',\n  single: true\n})\n```\n\n----------------------------------------\n\nTITLE: Configuring rehype-pretty-code in velite.config.js\nDESCRIPTION: This JavaScript code configures Velite to use rehype-pretty-code for formatting code blocks. It imports the necessary modules and defines a Velite configuration object with rehypePlugins specified.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_13\n\nLANGUAGE: javascript\nCODE:\n```\nimport rehypePrettyCode from 'rehype-pretty-code'\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  // `mdx` if you use mdx\n  markdown: {\n    rehypePlugins: [rehypePrettyCode]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.unique() to Validate Unique Values (TypeScript)\nDESCRIPTION: The `s.unique(by)` schema validates that a value is unique within a collection, identified by the `by` parameter. It checks against existing values in the specified scope. It returns an issue 'Already exists' if the value is not unique.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nname: s.unique('taxonomies')\n// case 1. unique value\n// 'foo' => 'foo'\n\n// case 2. non-unique value (in all unique by 'taxonomies')\n// 'foo' => issue 'Already exists'\n```\n\n----------------------------------------\n\nTITLE: MDX Schema Result Render - TSX\nDESCRIPTION: Demonstrates how to render Velite-generated MDX code as a React component. It defines a `useMDXComponent` hook that takes the MDX code string and returns a React component function. The `MDXContent` component then uses this hook to render the MDX content, allowing for the injection of shared and component-specific components.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport * as runtime from 'react/jsx-runtime'\n\nconst sharedComponents = {\n  // Add your global components here\n}\n\n// parse the Velite generated MDX code into a React component function\nconst useMDXComponent = (code: string) => {\n  const fn = new Function(code)\n  return fn({ ...runtime }).default\n}\n\ninterface MDXProps {\n  code: string\n  components?: Record<string, React.ComponentType>\n}\n\n// MDXContent component\nexport const MDXContent = ({ code, components }: MDXProps) => {\n  const Component = useMDXComponent(code)\n  return <Component components={{ ...sharedComponents, ...components }} />\n}\n```\n\n----------------------------------------\n\nTITLE: MDX Usage with Callout Component\nDESCRIPTION: These MDX examples show how to use the `Callout` component within MDX files.  No explicit imports are required in the MDX because Velite compiles MDX content into function-body strings.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_7\n\nLANGUAGE: mdx\nCODE:\n```\n---\ntitle: Foo\n---\n\n# Foo\n\n<Callout>This is foo callout.</Callout>\n```\n\nLANGUAGE: mdx\nCODE:\n```\n---\ntitle: Bar\n---\n\n# Bar\n\n<Callout>This is bar callout.</Callout>\n```\n\n----------------------------------------\n\nTITLE: Configuring Asset Uploading in Velite (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to configure asset uploading using Velite's defineConfig function.  It shows how to set the base URL for assets and includes a placeholder for uploading images on the 'complete' hook.  Dependencies include the 'velite' package. The `output.base` option configures the base URL where static assets will be served from.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/asset-handling.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { defineConfig } from 'velite'\n\nexport default defineConfig({\n  output: {\n    base: 'https://oss.your.com/static/'\n  },\n  complete: async () => {\n    // TODO: upload images\n    // static => https://oss.your.com/static/\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Using s.raw() to Get Raw Document Body (TypeScript)\nDESCRIPTION: The `s.raw()` schema simply returns the raw document body as a string. It performs no parsing or modification.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\ncode: s.raw()\n// => raw document body\n```\n\n----------------------------------------\n\nTITLE: Defining Image Interface in TypeScript\nDESCRIPTION: Defines the `Image` interface with properties for the image URL (`src`), dimensions (`width`, `height`), blur data URL (`blurDataURL`), and blur image dimensions (`blurWidth`, `blurHeight`). This interface is used to represent image objects with associated metadata and blur image data.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/types.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Image object with metadata & blur image\n */\ninterface Image {\n  /**\n   * public url of the image\n   */\n  src: string\n  /**\n   * image width\n   */\n  width: number\n  /**\n   * image height\n   */\n  height: number\n  /**\n   * blurDataURL of the image\n   */\n  blurDataURL: string\n  /**\n   * blur image width\n   */\n  blurWidth: number\n  /**\n   * blur image height\n   */\n  blurHeight: number\n}\n```\n\n----------------------------------------\n\nTITLE: Next.js Integration (CommonJS) - JavaScript\nDESCRIPTION: This snippet demonstrates how to integrate Velite into a Next.js project using a Webpack plugin. The `VeliteWebpackPlugin` is responsible for triggering the Velite build process within the Next.js build pipeline. It ensures that the build is only started once, even though the plugin's `apply` method may be executed multiple times. It supports setting the `watch` and `clean` options based on the Next.js environment (development or production).\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type {import('next').NextConfig} */\nmodule.exports = {\n  // othor next config here...\n  webpack: config => {\n    config.plugins.push(new VeliteWebpackPlugin())\n    return config\n  }\n}\n\nclass VeliteWebpackPlugin {\n  static started = false\n  constructor(/** @type {import('velite').Options} */ options = {}) {\n    this.options = options\n  }\n  apply(/** @type {import('webpack').Compiler} */ compiler) {\n    // executed three times in nextjs !!!\n    // twice for the server (nodejs / edge runtime) and once for the client\n    compiler.hooks.beforeCompile.tapPromise('VeliteWebpackPlugin', async () => {\n      if (VeliteWebpackPlugin.started) return\n      VeliteWebpackPlugin.started = true\n      const dev = compiler.options.mode === 'development'\n      this.options.watch = this.options.watch ?? dev\n      this.options.clean = this.options.clean ?? !dev\n      const { build } = await import('velite')\n      await build(this.options) // start velite\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring @shikijs/rehype in velite.config.ts (with type casting)\nDESCRIPTION: This TypeScript code demonstrates how to configure Velite to use `@shikijs/rehype` for syntax highlighting with the 'nord' theme, including a type assertion to handle potential type incompatibility issues. It imports the necessary modules and defines a Velite configuration object.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_19\n\nLANGUAGE: javascript\nCODE:\n```\nimport rehypeShiki from '@shikijs/rehype'\nimport { defineConfig } from 'velite'\n\n  markdown: {// `mdx` if you use mdx\nexport default defineConfig({\n    rehypePlugins: [[rehypeShiki as any, { theme: 'nord' }]]\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Build Content (npm)\nDESCRIPTION: This command builds the content using Velite.  It generates the final output of the project.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/readme.md#_snippet_2\n\nLANGUAGE: Shell\nCODE:\n```\n$ npm run build # build content by velite\n```\n\n----------------------------------------\n\nTITLE: Import build function in Velite\nDESCRIPTION: Imports the `build` function from the 'velite' package. This function is used to build the project.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { build } from 'velite'\n```\n\n----------------------------------------\n\nTITLE: Building Velite project with npm\nDESCRIPTION: This command executes the Velite build process using npm. It instructs npm to run the 'velite' command, which processes the content files based on the configuration defined in `velite.config.js`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_6\n\nLANGUAGE: shell\nCODE:\n```\n$ npx velite\n```\n\n----------------------------------------\n\nTITLE: Using s.excerpt() to Extract Text Excerpt (TypeScript)\nDESCRIPTION: The `s.excerpt(options)` schema parses markdown content and returns an excerpt of the text. It is designed to generate short summaries. Options control the length of the excerpt.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nexcerpt: s.excerpt()\n// document body => excerpt text\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with npm\nDESCRIPTION: This command installs the @shikijs/rehype and shiki packages using npm, which are necessary for syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install @shikijs/rehype shiki\n```\n\n----------------------------------------\n\nTITLE: Result interface in Velite\nDESCRIPTION: Defines the `Result` interface, which represents the result of the build process. It contains a dictionary of entries, where each entry can be a single `Entry` object or an array of `Entry` objects.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ninterface Entry {\n  [key: string]: any\n}\n\n/**\n * build result, may be one or more entries in a document file\n */\ninterface Result {\n  [name: string]: Entry | Entry[]\n}\n```\n\n----------------------------------------\n\nTITLE: CSS Styling Example\nDESCRIPTION: This CSS code snippet demonstrates styling for a banner element, setting its width and height, and ensuring the image within the banner fills the entire space. It showcases basic CSS rules for controlling the appearance of elements.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/content/posts/1970-01-01-style-guide/index.md#_snippet_0\n\nLANGUAGE: CSS\nCODE:\n```\n.banner {\n  width: 750px;\n  height: 420px;\n}\n\n.banner image {\n  width: 100%;\n  height: 100%;\n}\n```\n\n----------------------------------------\n\nTITLE: React MDX Content Component (TypeScript)\nDESCRIPTION: This TypeScript component, `MDXContent`, renders the compiled MDX code.  It uses `react/jsx-runtime` and creates a function from the code string. It takes MDX code and a components object as props.  It merges shared components and dynamically imported components to provide available components for MDX rendering.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as runtime from 'react/jsx-runtime'\n\nconst sharedComponents = {\n  // Add your global components here\n}\n\n// parse the Velite generated MDX code into a React component function\nconst useMDXComponent = (code: string) => {\n  const fn = new Function(code)\n  return fn({ ...runtime }).default\n}\n\ninterface MDXProps {\n  code: string\n  components?: Record<string, React.ComponentType>\n}\n\n// MDXContent component\nexport const MDXContent = ({ code, components }: MDXProps) => {\n  const Component = useMDXComponent(code)\n  return <Component components={{ ...sharedComponents, ...components }} />\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Velite via bun\nDESCRIPTION: This command installs Velite as a development dependency using bun. The `-D` flag ensures that Velite is added to the `devDependencies` section of your `package.json` file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_3\n\nLANGUAGE: shell\nCODE:\n```\n$ bun add velite -D\n```\n\n----------------------------------------\n\nTITLE: Velite Integration with Next.js Webpack Plugin (CommonJS)\nDESCRIPTION: This code shows how to integrate Velite using a custom Webpack plugin in Next.js. The `VeliteWebpackPlugin` ensures that Velite is started only once during the Next.js build process. The `apply` method hooks into the `beforeCompile` event to trigger the Velite build, passing in `watch` and `clean` options based on the development mode.  This utilizes CommonJS module syntax.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\n/** @type {import('next').NextConfig} */\nmodule.exports = {\n  // othor next config here...\n  webpack: config => {\n    config.plugins.push(new VeliteWebpackPlugin())\n    return config\n  }\n}\n\nclass VeliteWebpackPlugin {\n  static started = false\n  apply(/** @type {import('webpack').Compiler} */ compiler) {\n    // executed three times in nextjs\n    // twice for the server (nodejs / edge runtime) and once for the client\n    compiler.hooks.beforeCompile.tapPromise('VeliteWebpackPlugin', async () => {\n      if (VeliteWebpackPlugin.started) return\n      VeliteWebpackPlugin.started = true\n      const dev = compiler.options.mode === 'development'\n      const { build } = await import('velite')\n      await build({ watch: dev, clean: !dev })\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Collection Schema: Pattern (Velite)\nDESCRIPTION: This snippet shows how to define the `pattern` option for a Velite collection. The `pattern` option specifies the glob pattern used to find content files for the collection. Velite uses `fast-glob` to find content files.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_3\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst posts = defineCollection({\n  pattern: 'posts/**/*.md'\n  // or pattern: ['posts/**/*.md', '!posts/private/**']\n})\n```\n\n----------------------------------------\n\nTITLE: Installing Velite Vite Plugin\nDESCRIPTION: This command installs the Velite Vite plugin and Velite itself as development dependencies using npm. The `-D` flag ensures they are added to the `devDependencies` section of the `package.json` file.\nSOURCE: https://github.com/zce/velite/blob/main/packages/vite/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\nnpm install -D velite @velite/plugin-vite\n```\n\n----------------------------------------\n\nTITLE: Remote Image with BlurDataURL Schema - TypeScript\nDESCRIPTION: Creates a Velite schema that fetches a remote image, extracts metadata (dimensions, blurDataURL), and returns an `Image` object. It uses `getImageMetadata` from Velite and the native `fetch` API. The schema transforms a string (image URL) into an `Image` object containing the source URL and metadata. Requires `velite` dependency for schema definition and image metadata extraction.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { getImageMetadata, s } from 'velite'\n\nimport type { Image } from 'velite'\n\n/**\n * Remote Image with metadata schema\n */\nexport const remoteImage = () =>\n  s.string().transform<Image>(async (value, { addIssue }) => {\n    try {\n      const response = await fetch(value)\n      const blob = await response.blob()\n      const buffer = await blob.arrayBuffer()\n      const metadata = await getImageMetadata(Buffer.from(buffer))\n      if (metadata == null) throw new Error(`Failed to get image metadata: ${value}`)\n      return { src: value, ...metadata }\n    } catch (err) {\n      const message = err instanceof Error ? err.message : String(err)\n      addIssue({ fatal: true, code: 'custom', message })\n      return null as never\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Velite Integration with Next.js Webpack Plugin (ESM)\nDESCRIPTION: This code shows how to integrate Velite using a custom Webpack plugin in Next.js. The `VeliteWebpackPlugin` ensures that Velite is started only once during the Next.js build process. The `apply` method hooks into the `beforeCompile` event to trigger the Velite build, passing in `watch` and `clean` options based on the development mode. This utilizes ESM module syntax.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/with-nextjs.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { build } from 'velite'\n\n/** @type {import('next').NextConfig} */\nexport default {\n  // othor next config here...\n  webpack: config => {\n    config.plugins.push(new VeliteWebpackPlugin())\n    return config\n  }\n}\n\nclass VeliteWebpackPlugin {\n  static started = false\n  apply(/** @type {import('webpack').Compiler} */ compiler) {\n    // executed three times in nextjs\n    // twice for the server (nodejs / edge runtime) and once for the client\n    compiler.hooks.beforeCompile.tapPromise('VeliteWebpackPlugin', async () => {\n      if (VeliteWebpackPlugin.started) return\n      VeliteWebpackPlugin.started = true\n      const dev = compiler.options.mode === 'development'\n      await build({ watch: dev, clean: !dev })\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Export Collections Index (index.js)\nDESCRIPTION: Exports the default exports from the generated JSON files for each collection, allowing them to be imported in your application.  This requires the generated JSON files to exist in the same directory. Used to expose the collections data.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nexport { default as posts } from './posts.json'\nexport { default as others } from './others.json'\n```\n\n----------------------------------------\n\nTITLE: Configuring Velite npm Scripts\nDESCRIPTION: This snippet demonstrates how to configure Velite commands within the `package.json` file to automate content processing during development and build processes. It includes scripts for watching content changes, cleaning the Velite output, and integrating these with Next.js development and build processes. It relies on `npm-run-all` for parallel and sequential script execution.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/readme.md#_snippet_0\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"scripts\": {\n    \"dev:content\": \"velite --watch\",\n    \"build:content\": \"velite --clean\",\n    \"dev:next\": \"next dev\",\n    \"build:next\": \"next build\",\n    \"dev\": \"run-p dev:*\",\n    \"build\": \"run-s build:*\",\n    \"start\": \"next start\"\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Ignore .velite Directory (.gitignore)\nDESCRIPTION: Adds the `.velite` directory to the `.gitignore` file.  Prevents the generated files from being tracked in version control.  This is generally recommended as the .velite folder contains generated files.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_4\n\nLANGUAGE: Shell\nCODE:\n```\necho '\\n.velite' >> .gitignore\n```\n\n----------------------------------------\n\nTITLE: Defining MarkdownOptions Interface in TypeScript\nDESCRIPTION: Defines the `MarkdownOptions` interface for configuring Markdown processing. It includes optional properties for enabling GitHub Flavored Markdown (`gfm`), removing HTML comments (`removeComments`), copying linked files (`copyLinkedFiles`), and specifying Remark and Rehype plugins (`remarkPlugins`, `rehypePlugins`). This interface allows customization of the Markdown parsing and transformation process.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/types.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * Markdown options\n */\ninterface MarkdownOptions {\n  /**\n   * Enable GitHub Flavored Markdown (GFM).\n   * @default true\n   */\n  gfm?: boolean\n  /**\n   * Remove html comments.\n   * @default true\n   */\n  removeComments?: boolean\n  /**\n   * Copy linked files to public path and replace their urls with public urls.\n   * @default true\n   */\n  copyLinkedFiles?: boolean\n  /**\n   * Remark plugins.\n   */\n  remarkPlugins?: PluggableList\n  /**\n   * Rehype plugins.\n   */\n  rehypePlugins?: PluggableList\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-highlight with pnpm\nDESCRIPTION: This command installs the rehype-highlight package using pnpm.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_21\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm add rehype-highlight\n```\n\n----------------------------------------\n\nTITLE: outputFile function signature in Velite\nDESCRIPTION: Defines the signature for the `outputFile` function, which asynchronously outputs a file. It takes a reference `ref` (string or undefined) and a file path `fromPath` as input, and returns a Promise that resolves to the same type as `ref`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst outputFile: async <T extends string | undefined>(ref: T, fromPath: string) => Promise<T>\n```\n\n----------------------------------------\n\nTITLE: Data Prepare Hook Example\nDESCRIPTION: This example shows how to use the `prepare` hook in the Velite configuration. The `prepare` hook allows you to modify the data before it is written to a file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nexport default defineConfig({\n  collections: { posts, tags },\n  prepare: (data, context) => {\n    // modify data\n    data.posts.push({ ... })\n    data.tags.push({ ... })\n\n    // context\n    const { config } = context\n    // config is resolved from `velite.config.js` with default values\n\n    // return false to prevent the default output to a file\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with npm\nDESCRIPTION: This command installs the @shikijs/rehype package using npm.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_15\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install @shikijs/rehype\n```\n\n----------------------------------------\n\nTITLE: outputImage function signature in Velite\nDESCRIPTION: Defines the signature for the `outputImage` function, which asynchronously outputs an image. It takes a reference `ref` (string or undefined) and a file path `fromPath` as input. The function returns a Promise that resolves to either an `Image` object or the original type of the `ref` parameter.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/api.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconst outputImage: async <T extends string | undefined>(ref: T, fromPath: string) => Promise<Image | T>\n```\n\n----------------------------------------\n\nTITLE: Building Velite project with yarn\nDESCRIPTION: This command executes the Velite build process using Yarn. It processes the content files based on the configuration defined in `velite.config.js`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_8\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn velite\n```\n\n----------------------------------------\n\nTITLE: Example Content File (Markdown)\nDESCRIPTION: This markdown snippet showcases a simple content file structure within a Velite project. It contains frontmatter defining the title, slug, date, cover image, and video file, followed by the actual content using Markdown syntax. This represents the structure that Velite parses and transforms based on your configuration.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_5\n\nLANGUAGE: markdown\nCODE:\n```\n---\ntitle: Hello world\nslug: hello-world\ndate: 1992-02-25 13:22\ncover: cover.jpg\nvideo: video.mp4\n---\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse\n\n![some image](img.png)\n\n[link to file](plain.txt)\n```\n\n----------------------------------------\n\nTITLE: Velite Configuration with JavaScript\nDESCRIPTION: This JavaScript code snippet demonstrates the configuration of Velite using the `defineConfig` function. It defines the schema for collections like 'posts', specifying data types and validation rules using Zod schemas.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/posts/1970-01-01-style-guide/index.md#_snippet_1\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { defineConfig, s } from 'velite'\n\n// `s` is extended from Zod with some custom schemas,\n// you can also import re-exported `z` from `velite` if you don't need these extension schemas.\n\nexport default defineConfig({\n  collections: {\n    posts: {\n      name: 'Post', // collection type name\n      pattern: 'posts/**/*.md', // content files glob pattern\n      schema: s\n        .object({\n          title: s.string().max(99), // Zod primitive type\n          slug: s.slug('posts'), // validate format, unique in posts collection\n          date: s.isodate(), // input Date-like string, output ISO Date string.\n          cover: s.image().optional(), // input image relpath, output image object with blurImage.\n          video: s.file().optional(), // input file relpath, output file public path.\n          metadata: s.metadata(), // extract markdown reading-time, word-count, etc.\n          excerpt: s.excerpt(), // excerpt of markdown content\n          content: s.markdown() // transform markdown to html\n        })\n        // more additional fields (computed fields)\n        .transform(data => ({ ...data, permalink: `/blog/${data.slug}` }))\n    },\n    others: {\n      // other collection schema options\n    }\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Executing JavaScript code\nDESCRIPTION: This JavaScript snippet executes a function named `some.code()`. It demonstrates how to embed and execute JavaScript code within a markdown document.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/pages/contact/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nsome.code()\n```\n\n----------------------------------------\n\nTITLE: Next.js Integration (ESM) - JavaScript\nDESCRIPTION: This snippet demonstrates how to integrate Velite into a Next.js project using a Webpack plugin with ES Modules. The `VeliteWebpackPlugin` is responsible for triggering the Velite build process within the Next.js build pipeline. It ensures that the build is only started once, even though the plugin's `apply` method may be executed multiple times. It supports setting the `watch` and `clean` options based on the Next.js environment (development or production).\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nimport { build } from 'velite'\n\n/** @type {import('next').NextConfig} */\nexport default {\n  // othor next config here...\n  webpack: config => {\n    config.plugins.push(new VeliteWebpackPlugin())\n    return config\n  }\n}\n\nclass VeliteWebpackPlugin {\n  static started = false\n  constructor(/** @type {import('velite').Options} */ options = {}) {\n    this.options = options\n  }\n  apply(/** @type {import('webpack').Compiler} */ compiler) {\n    // executed three times in nextjs !!!\n    // twice for the server (nodejs / edge runtime) and once for the client\n    compiler.hooks.beforeCompile.tapPromise('VeliteWebpackPlugin', async () => {\n      if (VeliteWebpackPlugin.started) return\n      VeliteWebpackPlugin.started = true\n      const dev = compiler.options.mode === 'development'\n      this.options.watch = this.options.watch ?? dev\n      this.options.clean = this.options.clean ?? !dev\n      await build(this.options) // start velite\n    })\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Others Collection (others.json)\nDESCRIPTION: Placeholder for the 'others' collection JSON output.  This would be a similar structure to posts.json, containing other content types managed by Velite. Demonstrates the structure that can be used for collections in addition to the posts collection.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_3\n\nLANGUAGE: JSON\nCODE:\n```\n[\n  ...\n]\n```\n\n----------------------------------------\n\nTITLE: Markdown Content with JSX Component\nDESCRIPTION: This snippet shows the overall structure of the markdown file, including the frontmatter and the main content. The content demonstrates the use of a JSX-like component `<Image>` with properties.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/content/pages/about/index.mdx#_snippet_0\n\nLANGUAGE: Markdown\nCODE:\n```\n---\ntitle: About Me\nslug: about\n---\n\n# Hello {props.name.toUpperCase()}\n\n<Image src=\"cover.webp\" width={800} height={500} />\n\n<div className=\"note\">\n\n> Some notable things in a block quote!\n\n</div>\n\n{/* This is a comment */}\n```\n\n----------------------------------------\n\nTITLE: Defining MdxOptions Interface in TypeScript\nDESCRIPTION: Defines the `MdxOptions` interface for configuring MDX compilation, extending `CompileOptions` and adding MD-specific options such as GFM support, HTML comment removal, linked file copying, and output format. This allows fine-grained control over how MDX files are processed and transformed into executable code.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/types.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * MDX compiler options\n */\nexport interface MdxOptions extends Omit<CompileOptions, 'outputFormat'> {\n  /**\n   * Enable GitHub Flavored Markdown (GFM).\n   * @default true\n   */\n  gfm?: boolean\n  /**\n   * Remove html comments.\n   * @default true\n   */\n  removeComments?: boolean\n  /**\n   * Copy linked files to public path and replace their urls with public urls.\n   * @default true\n   */\n  copyLinkedFiles?: boolean\n  /**\n   * Output format to generate.\n   * @default 'function-body'\n   */\n  outputFormat?: CompileOptions['outputFormat']\n}\n```\n\n----------------------------------------\n\nTITLE: Typed Velite Configuration with UserConfig type in Typescript\nDESCRIPTION: This TypeScript example shows how to use the `UserConfig` type from 'velite' to define the configuration file type. It provides type checking for the configuration object.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport type { UserConfig } from 'velite'\n\nconst config: UserConfig = {\n  // ...\n}\n\nexport default config\n```\n\n----------------------------------------\n\nTITLE: Embedding JavaScript Code Snippet\nDESCRIPTION: This snippet demonstrates how to embed JavaScript code within a markdown document. The code is enclosed in triple backticks with the `js` identifier, allowing for syntax highlighting and proper rendering.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/pages/contact/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nsome.code()\n```\n\n----------------------------------------\n\nTITLE: Markdown Comment\nDESCRIPTION: This snippet contains an HTML style comment. It would be treated as a comment in Markdown.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/pages/about/index.mdx#_snippet_3\n\nLANGUAGE: Markdown\nCODE:\n```\n{/* This is a comment */}\n```\n\n----------------------------------------\n\nTITLE: Velite Build Usage\nDESCRIPTION: Executes the `velite build` command, which builds the project using the default configuration file or a specified config file. The build command has options to clean the output directory, watch for changes, and adjust verbosity.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\n$ velite build [options]\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with pnpm\nDESCRIPTION: This command installs the @shikijs/rehype package using pnpm.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_16\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm add @shikijs/rehype\n```\n\n----------------------------------------\n\nTITLE: Defining VeliteFile Class in TypeScript\nDESCRIPTION: Defines the `VeliteFile` class, which extends the `VFile` class and provides methods for accessing parsed records, file content, mdast/hast objects, plain text, and meta objects. It also includes static methods for retrieving and creating `VeliteFile` instances. This class is used to represent and manage files within the Velite project.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/types.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ninterface ZodMeta extends VeliteFile {}\n\nclass VeliteFile extends VFile {\n  /**\n   * Get parsed records from file\n   */\n  get records(): unknown\n\n  /**\n   * Get content of file\n   */\n  get content(): string | undefined\n\n  /**\n   * Get mdast object from cache\n   */\n  get mdast(): Root | undefined\n\n  /**\n   * Get hast object from cache\n   */\n  get hast(): Nodes | undefined\n\n  /**\n   * Get plain text of content from cache\n   */\n  get plain(): string | undefined\n\n  /**\n   * Get meta object from cache\n   * @param path file path\n   * @returns resolved meta object if exists\n   */\n  static get(path: string): VeliteFile | undefined\n\n  /**\n   * Create meta object from file path\n   * @param options meta options\n   * @returns resolved meta object\n   */\n  static async create({ path, config }: { path: string; config: Config }): Promise<VeliteFile>\n}\n```\n\n----------------------------------------\n\nTITLE: Using s.path() to Get Flattened Path (TypeScript)\nDESCRIPTION: The `s.path(options)` schema returns a flattened path based on the file path. Options control how the path is flattened and whether index files are removed.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\npath: s.path()\n// => flattened path, e.g. 'posts/2021-01-01-hello-world'\n```\n\n----------------------------------------\n\nTITLE: Velite: Project Structure\nDESCRIPTION: This code snippet shows the typical directory structure of a Velite project. It includes directories for content such as categories, options, pages, posts, and tags, as well as configuration and dependency management files.  Understanding the project structure is crucial for organizing content and configuring Velite.\nSOURCE: https://github.com/zce/velite/blob/main/docs/examples/basic.md#_snippet_0\n\nLANGUAGE: text\nCODE:\n```\nbasic\n‚îú‚îÄ‚îÄ content                  # content directory\n‚îÇ   ‚îú‚îÄ‚îÄ categories\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ journal.jpg\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ journal.yml\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ etc...\n‚îÇ   ‚îú‚îÄ‚îÄ options\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.yml\n‚îÇ   ‚îú‚îÄ‚îÄ pages\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ about\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.mdx\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ contact\n|   |       ‚îú‚îÄ‚îÄ img.png and more...\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.mdx\n‚îÇ   ‚îú‚îÄ‚îÄ posts\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 1970-01-01-style-guide\n‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cover.jpg and more...\n‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.md\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 1992-02-25-hello-world\n‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ cover.jpg and more...\n‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.md\n‚îÇ   ‚îî‚îÄ‚îÄ tags\n‚îÇ       ‚îî‚îÄ‚îÄ index.yml\n‚îú‚îÄ‚îÄ .gitignore\n‚îú‚îÄ‚îÄ package.json\n‚îú‚îÄ‚îÄ README.md\n‚îî‚îÄ‚îÄ velite.config.js         # Velite config file\n```\n\n----------------------------------------\n\nTITLE: Configuring Velite Vite Plugin\nDESCRIPTION: This example demonstrates how to configure the Velite Vite plugin within a `vite.config.ts` file. It imports the `velite` plugin and the `defineConfig` function from Vite, and then uses `defineConfig` to configure the Vite build process, including adding the Velite plugin to the `plugins` array. The `config` option specifies the path to the Velite configuration file.\nSOURCE: https://github.com/zce/velite/blob/main/packages/vite/readme.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.ts\nimport velite from '@velite/plugin-vite'\nimport { defineConfig } from 'vite'\n\nexport default defineConfig({\n  plugins: [\n    velite({\n      // Path to velite config file\n      config: 'velite.config.ts'\n    })\n  ]\n})\n```\n\n----------------------------------------\n\nTITLE: Running Velite in watch mode with pnpm\nDESCRIPTION: This command runs Velite in development mode with watch functionality using pnpm. Velite monitors the content files for changes and automatically rebuilds the project whenever a change is detected. The `dev` flag likely signifies a development environment configuration.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_13\n\nLANGUAGE: shell\nCODE:\n```\n$ pnpm velite dev\n```\n\n----------------------------------------\n\nTITLE: Client-side Code Highlighting with shikiji\nDESCRIPTION: This JavaScript code snippet demonstrates how to perform client-side code highlighting using shikiji. It finds all code blocks with language classes and replaces them with highlighted HTML generated by shikiji.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_24\n\nLANGUAGE: javascript\nCODE:\n```\nimport { codeToHtml } from 'https://esm.sh/shikiji'\n\nArray.from(document.querySelectorAll('pre code[class*=\"language-\"]')).map(async block => {\n  block.parentElement.outerHTML = await codeToHtml(block.textContent, { lang: block.className.slice(9), theme: 'nord' })\n})\n```\n\n----------------------------------------\n\nTITLE: Define Collection with Pattern\nDESCRIPTION: This code shows how to define a collection with a specific file pattern using the `defineCollection` function. The `pattern` property specifies the glob pattern for the collection files.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nconst posts = defineCollection({\n  pattern: 'posts/*.md'\n})\n```\n\n----------------------------------------\n\nTITLE: Velite: Usage Commands\nDESCRIPTION: This code snippet demonstrates the basic commands to use Velite.  It includes commands for installing dependencies using npm, running the build process in watch mode for development, and building the content for production.  Executing these commands is essential for developing and deploying Velite-based projects.\nSOURCE: https://github.com/zce/velite/blob/main/docs/examples/basic.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ npm install # install dependencies\n$ npm run dev # run build in watch mode\n$ npm run build # build content by velite\n```\n\n----------------------------------------\n\nTITLE: Using s.isodate() to Format Date Strings (TypeScript)\nDESCRIPTION: The `s.isodate()` schema formats a date string to an ISO date string. It handles various date and datetime string formats.  It returns an issue 'Invalid date string' if the input is an invalid date string.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/velite-schemas.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ndate: s.isodate()\n// case 1. valid date string\n// '2017-01-01' => '2017-01-01T00:00:00.000Z'\n\n// case 2. valid datetime string\n// '2017-01-01 10:10:10' => '2017-01-01T10:10:10.000Z'\n\n// case 3. invalid date string\n// 'foo bar invalid' => issue 'Invalid date string'\n```\n\n----------------------------------------\n\nTITLE: Collection Schema: Zod (Velite)\nDESCRIPTION: This snippet shows how to define the `schema` option for a Velite collection using Zod.  The `schema` option is used to define the Zod schema used to validate the content items in the collection. It defines a simple schema with a string type and max length validation for the title.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/define-collections.md#_snippet_5\n\nLANGUAGE: JavaScript\nCODE:\n```\nimport { z } from 'velite'\n\nconst posts = defineCollection({\n  schema: z.object({\n    title: z.string().max(99)\n  })\n})\n```\n\n----------------------------------------\n\nTITLE: Defining Loader Interface in TypeScript\nDESCRIPTION: Defines the `Loader` interface for file loaders. It specifies properties for the loader's name (`name`), a regular expression to test file types (`test`), and a `load` function that takes a VFile object and returns an entry or an array of entries. This interface is used to create custom file loaders within the Velite project.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/types.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\n/**\n * File loader\n */\ninterface Loader {\n  /**\n   * Loader name\n   * @description\n   * The same name will overwrite the built-in loader,\n   * built-in loaders: 'json', 'yaml', 'matter'\n   */\n  name: string\n  /**\n   * File test regexp\n   * @example\n   * /\\.md$/\n   */\n  test: RegExp\n  /**\n   * Load file content\n   * @param file vfile\n   * @returns entry or entries\n   */\n  load: (file: VFile) => Promisable<Entry | Entry[]>\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-pretty-code with npm\nDESCRIPTION: This command installs the rehype-pretty-code and shiki packages using npm, which are necessary for formatting code blocks.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_10\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install rehype-pretty-code shiki\n```\n\n----------------------------------------\n\nTITLE: Transform Entire Collection Schema in TypeScript\nDESCRIPTION: This code snippet showcases how to transform an entire collection schema using Zod. It adds a `url` property based on the `slug` property. Requires Zod library and assumes `s` is a Zod schema builder instance.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/introduction.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nschema: s.object({\n    title: s.string(),\n    slug: s.string()\n  }).transform(value => ({\n    ...value,\n    url: `/blog/${value.slug}`\n  }))\n```\n\n----------------------------------------\n\nTITLE: Velite Dev Usage\nDESCRIPTION: Executes the `velite dev` command, which builds the project in watch mode, automatically rebuilding on file changes. The dev command options include config file specification, cleaning the output directory, and verbosity control.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\n$ velite dev [options]\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-pretty-code with yarn\nDESCRIPTION: This command installs the rehype-pretty-code and shiki packages using yarn, which are necessary for formatting code blocks.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_12\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn add rehype-pretty-code shiki\n```\n\n----------------------------------------\n\nTITLE: TypeScript Path Aliases (tsconfig.json)\nDESCRIPTION: Defines a path alias in `tsconfig.json` to simplify importing the generated content.  Allows importing files from the `.velite` directory using a shorter, more readable path.  This is a common practice for improving code maintainability.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_7\n\nLANGUAGE: JSON\nCODE:\n```\n{\n  \"compilerOptions\": {\n    \"baseUrl\": \".\",\n    \"paths\": {\n      \"#site/content\": [\"./.velite\"]\n    }\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Example Posts Collection (posts.json)\nDESCRIPTION: A JSON array representing the posts collection. Each object in the array represents a post, including metadata, content, and related assets. Demonstrates the expected output format from Velite.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-collections.md#_snippet_2\n\nLANGUAGE: JSON\nCODE:\n```\n[\n  {\n    \"title\": \"Hello world\",\n    \"slug\": \"hello-world\",\n    \"date\": \"1992-02-25T13:22:00.000Z\",\n    \"cover\": {\n      \"src\": \"/static/cover-2a4138dh.jpg\",\n      \"height\": 1100,\n      \"width\": 1650,\n      \"blurDataURL\": \"data:image/webp;base64,UklGRjwAAABXRUJQVlA4IDAAAACwAQCdASoIAAUADMDOJbACdADWaUXAAMltC0BZxTv24bHUX8EibgVs/sPiTqq6QAA=\",\n      \"blurWidth\": 8,\n      \"blurHeight\": 5\n    },\n    \"video\": \"/static/video-72hhd9f.mp4\",\n    \"metadata\": {\n      \"readingTime\": 1,\n      \"wordCount\": 1\n    },\n    \"excerpt\": \"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse\",\n    \"content\": \"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Sed non risus. Suspendisse</p>\\n<p><img src=\\\"/static/img-2hd8f3sd.jpg\\\" alt=\\\"some image\\\" /></p>\\n<p><a href=\\\"/static/plain-37d62h1s.txt\\\">link to file</a></p>\\n\",\n    \"permalink\": \"/blog/hello-world\"\n  }\n]\n```\n\n----------------------------------------\n\nTITLE: Building Velite project with pnpm\nDESCRIPTION: This command executes the Velite build process using pnpm. It processes the content files based on the configuration defined in `velite.config.js`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_7\n\nLANGUAGE: shell\nCODE:\n```\n$ pnpm velite\n```\n\n----------------------------------------\n\nTITLE: Building Content with Velite in Next.js\nDESCRIPTION: These commands are used to set up and build a Next.js project that utilizes Velite. They involve installing dependencies, running the development server in watch mode, and building the content using Velite.\nSOURCE: https://github.com/zce/velite/blob/main/docs/examples/nextjs.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm install # install dependencies\n$ npm run dev # run build in watch mode\n$ npm run build # build content by velite\n```\n\n----------------------------------------\n\nTITLE: Installing Velite via npm\nDESCRIPTION: This command installs Velite as a development dependency using npm. The `-D` flag ensures that Velite is added to the `devDependencies` section of your `package.json` file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\n$ npm install velite -D\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with pnpm\nDESCRIPTION: This command installs the @shikijs/rehype and shiki packages using pnpm, which are necessary for syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm add @shikijs/rehype shiki\n```\n\n----------------------------------------\n\nTITLE: Directory Structure Diff\nDESCRIPTION: This diff shows the directory structure for a project using Velite with MDX. It highlights the location of content files, public assets, the package.json, and the velite configuration file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_0\n\nLANGUAGE: diff\nCODE:\n```\nproject-root\n‚îú‚îÄ‚îÄ content\n‚îÇ   ‚îî‚îÄ‚îÄ posts\n‚îÇ       ‚îî‚îÄ‚îÄ hello-world.mdx\n‚îú‚îÄ‚îÄ public\n‚îú‚îÄ‚îÄ package.json\n‚îî‚îÄ‚îÄ velite.config.js\n```\n\n----------------------------------------\n\nTITLE: Installing esbuild MDX Dependencies\nDESCRIPTION: This command installs the necessary dependencies for bundling MDX files with esbuild. These dependencies include esbuild itself, a plugin for global externals, and the esbuild plugin for MDX.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_9\n\nLANGUAGE: bash\nCODE:\n```\nnpm i esbuild @fal-works/esbuild-plugin-global-externals @mdx-js/esbuild --save-dev\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-highlight with npm\nDESCRIPTION: This command installs the rehype-highlight package using npm.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_20\n\nLANGUAGE: sh\nCODE:\n```\n$ npm install rehype-highlight\n```\n\n----------------------------------------\n\nTITLE: JSX Component: Hello with Name\nDESCRIPTION: This JSX snippet displays a greeting using the `props.name` value. The name is converted to uppercase using the `toUpperCase()` method. This demonstrates dynamic content rendering within a React component.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/pages/about/index.mdx#_snippet_0\n\nLANGUAGE: JSX\nCODE:\n```\n# Hello {props.name.toUpperCase()}\n```\n\n----------------------------------------\n\nTITLE: Velite CLI Usage (npm)\nDESCRIPTION: Executes the Velite CLI using npm. This command invokes the Velite CLI with specified commands and options.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\n$ npx velite <command> [options]\n```\n\n----------------------------------------\n\nTITLE: Building Velite project with bun\nDESCRIPTION: This command executes the Velite build process using bun. It processes the content files based on the configuration defined in `velite.config.js`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_9\n\nLANGUAGE: shell\nCODE:\n```\n$ bun velite\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with yarn\nDESCRIPTION: This command installs the @shikijs/rehype and shiki packages using yarn, which are necessary for syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn add @shikijs/rehype shiki\n```\n\n----------------------------------------\n\nTITLE: Executing JavaScript Code\nDESCRIPTION: This snippet demonstrates how to include and execute JavaScript code within a markdown document. It represents a call to a hypothetical function named `some.code()`. No specific dependencies are required as it is a simple function call. The output would depend on what `some.code()` does.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/content/pages/contact/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\nsome.code()\n```\n\n----------------------------------------\n\nTITLE: Velite CLI Usage (bun)\nDESCRIPTION: Executes the Velite CLI using Bun. This commands makes use of the bun package manager to allow users to interface with the velite CLI.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\n$ bun velite <command> [options]\n```\n\n----------------------------------------\n\nTITLE: Running Velite in watch mode with npm\nDESCRIPTION: This command runs Velite in development mode with watch functionality using npm. Velite monitors the content files for changes and automatically rebuilds the project whenever a change is detected. The `dev` flag likely signifies a development environment configuration.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_12\n\nLANGUAGE: shell\nCODE:\n```\n$ npx velite dev\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/transformers with yarn\nDESCRIPTION: This command installs the @shikijs/transformers package using yarn, which is used to customize the output of syntax highlighting.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn add @shikijs/transformers\n```\n\n----------------------------------------\n\nTITLE: Running Velite in watch mode with yarn\nDESCRIPTION: This command runs Velite in development mode with watch functionality using yarn. Velite monitors the content files for changes and automatically rebuilds the project whenever a change is detected. The `dev` flag likely signifies a development environment configuration.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_14\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn velite dev\n```\n\n----------------------------------------\n\nTITLE: HTML Excerpt - TypeScript\nDESCRIPTION: Creates a Velite schema that generates an HTML excerpt from a given content string. It uses `hast-util-excerpt` to extract the excerpt based on a separator comment, or `hast-util-truncate` to truncate the content to a specified length. It also utilizes `rehypeCopyLinkedFiles` to handle linked files in the excerpt. The schema transforms a string into an HTML excerpt.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { excerpt as hastExcerpt } from 'hast-util-excerpt'\nimport { raw } from 'hast-util-raw'\nimport { toHtml } from 'hast-util-to-html'\nimport { truncate } from 'hast-util-truncate'\nimport { fromMarkdown } from 'mdast-util-from-markdown'\nimport { toHast } from 'mdast-util-to-hast'\n\nimport { extractHastLinkedFiles } from '../assets'\nimport { custom } from './zod'\n\nexport interface ExcerptOptions {\n  /**\n   * Excerpt separator.\n   * @default 'more'\n   * @example\n   * s.excerpt({ separator: 'preview' }) // split excerpt by `<!-- preview -->`\n   */\n  separator?: string\n  /**\n   * Excerpt length.\n   * @default 300\n   */\n  length?: number\n}\n\nexport const excerpt = ({ separator = 'more', length = 300 }: ExcerptOptions = {})\n  => custom<string>().transform(async (value, { meta: { path, content, config } }) => {\n    if (value == null && content != null) {\n      value = content\n    }\n    try {\n      const mdast = fromMarkdown(value)\n      const hast = raw(toHast(mdast, { allowDangerousHtml: true }))\n      const exHast = hastExcerpt(hast, { comment: separator, maxSearchSize: 1024 })\n      const output = exHast ?? truncate(hast, { size: length, ellipsis: '‚Ä¶' })\n      await rehypeCopyLinkedFiles(config.output)(output, { path })\n      return toHtml(output)\n    } catch (err: any) {\n      ctx.addIssue({ fatal: true, code: 'custom', message: err.message })\n      return value\n    }\n  })\n```\n\n----------------------------------------\n\nTITLE: Basic Velite Configuration\nDESCRIPTION: This is a basic Velite configuration file written in JavaScript. It exports a default object that will be used to configure Velite.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/config.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\n// velite.config.js\nexport default {\n  // ...\n}\n```\n\n----------------------------------------\n\nTITLE: Velite CLI Usage (pnpm)\nDESCRIPTION: Executes the Velite CLI using pnpm. This command allows the user to interact with the velite command and pass in other relevant options. It assumes pnpm is installed.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm velite <command> [options]\n```\n\n----------------------------------------\n\nTITLE: React Dynamic Title\nDESCRIPTION: This snippet renders a heading with the name passed as a prop, converting it to uppercase. It's likely used within a React component to display a personalized title.\nSOURCE: https://github.com/zce/velite/blob/main/examples/nextjs/content/pages/about/index.mdx#_snippet_0\n\nLANGUAGE: JavaScript\nCODE:\n```\n# Hello {props.name.toUpperCase()}\n```\n\n----------------------------------------\n\nTITLE: Velite CLI Usage (yarn)\nDESCRIPTION: Executes the Velite CLI using Yarn.  This command enables users to interact with the Velite tooling through yarn and specific options.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn velite <command> [options]\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-pretty-code with pnpm\nDESCRIPTION: This command installs the rehype-pretty-code and shiki packages using pnpm, which are necessary for formatting code blocks.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_11\n\nLANGUAGE: sh\nCODE:\n```\n$ pnpm add rehype-pretty-code shiki\n```\n\n----------------------------------------\n\nTITLE: Last Modified Schema (Git Timestamp) - TypeScript\nDESCRIPTION: Defines a Velite schema to extract the last modified timestamp from git history using `git log`. It transforms an optional string input into the git last modified time in ISO string format. It uses `child_process.exec` to execute git commands and `util.promisify` to use promises with it. The velite schema definition is done through `defineSchema`.\nSOURCE: https://github.com/zce/velite/blob/main/docs/other/snippets.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { exec } from 'child_process'\nimport { promisify } from 'util'\nimport { defineSchema } from 'velite'\n\nconst execAsync = promisify(exec)\n\nconst timestamp = defineSchema(() =>\n  s\n    .custom<string | undefined>(i => i === undefined || typeof i === 'string')\n    .transform<string>(async (value, { meta, addIssue }) => {\n      if (value != null) {\n        addIssue({ fatal: false, code: 'custom', message: '`s.timestamp()` schema will resolve the value from `git log -1 --format=%cd`' })\n      }\n      const { stdout } = await execAsync(`git log -1 --format=%cd ${meta.path}`)\n      return new Date(stdout || Date.now()).toISOString()\n    })\n)\n\n// use it in your schema\nconst posts = defineCollection({\n  // ...\n  schema: {\n    // ...\n    lastModified: timestamp()\n  }\n})\n```\n\n----------------------------------------\n\nTITLE: Installing @shikijs/rehype with yarn\nDESCRIPTION: This command installs the @shikijs/rehype package using yarn.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_17\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn add @shikijs/rehype\n```\n\n----------------------------------------\n\nTITLE: Velite Output Data Structure (JSON)\nDESCRIPTION: This JSON snippet shows the data structure generated by Velite after building with the configuration above. The `code` field contains the compiled MDX content as a function-body string.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/using-mdx.md#_snippet_3\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"posts\": [\n    {\n      \"title\": \"Hello world\",\n      \"code\": \"const{Fragment:n,jsx:e,jsxs:t}=arguments[0],o=2023;function _createMdxContent(r){const a={h1:\\\"h1\\\",p:\\\"p\\\",...r.components},{Chart:c}=a;return c||function(n,e){throw new Error(\\\"Expected \\\"+(e?\\\"component\\\":\\\"object\\\")+\\\" `\\\"+n+\\\"` to be defined: you likely forgot to import, pass, or provide it.\\\")}(\\\"Chart\\\",!0),t(n,{children:[e(a.h1,{children:\\\"Last year‚Äôs snowfall\\\"}),\\\"\\\\n\\\",t(a.p,{children:[\\\"In \\\",o,\\\", the snowfall was above average.\\\\nIt was followed by a warm spring which caused\\\\nflood conditions in many of the nearby rivers.\\\"]}),\\\"\\\\n\\\",e(c,{year:o,color:\\\"#fcb32c\\\"})]})}return{year:o,default:function(n={}){const{wrapper:t}=n.components||{};return t?e(t,{...n,children:e(_createMdxContent,{...n})}):_createMdxContent(n)}};\"\n    }\n  ]\n}\n```\n\n----------------------------------------\n\nTITLE: Velite Init Usage\nDESCRIPTION: Executes the `velite init` command, which is intended to create a default configuration file in the current directory. The actual implementation is marked as a TODO.\nSOURCE: https://github.com/zce/velite/blob/main/docs/reference/cli.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\n$ velite init [options]\n```\n\n----------------------------------------\n\nTITLE: Styling Banner Elements with CSS\nDESCRIPTION: This CSS snippet defines the styles for a banner element, setting its width and height. It also ensures that the image within the banner fills the entire container.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/posts/1970-01-01-style-guide/index.md#_snippet_0\n\nLANGUAGE: CSS\nCODE:\n```\n.banner {\n  width: 750px;\n  height: 420px;\n}\n\n.banner image {\n  width: 100%;\n  height: 100%;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing rehype-highlight with yarn\nDESCRIPTION: This command installs the rehype-highlight package using yarn.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/code-highlighting.md#_snippet_22\n\nLANGUAGE: sh\nCODE:\n```\n$ yarn add rehype-highlight\n```\n\n----------------------------------------\n\nTITLE: Homepage CSS Styling\nDESCRIPTION: This CSS snippet defines custom styles for the Velite homepage, primarily affecting the appearance of the hero section. It sets the colors, background gradients, and blur effects to create a visually appealing design. The animation adds a subtle movement to the logo.\nSOURCE: https://github.com/zce/velite/blob/main/docs/index.md#_snippet_1\n\nLANGUAGE: CSS\nCODE:\n```\n<style>\n:root {\n  --vp-home-hero-name-color: transparent;\n  --vp-home-hero-name-background: -webkit-linear-gradient(45deg, #11E49D 30%, #13AAAA);\n  --vp-home-hero-image-background-image: linear-gradient(-45deg, #08A77199 50%, #04D0D099 50%);\n  --vp-home-hero-image-filter: blur(44px);\n}\n\n@media (min-width: 640px) {\n  :root {\n    --vp-home-hero-image-filter: blur(56px);\n  }\n}\n\n@media (min-width: 960px) {\n  :root {\n    --vp-home-hero-image-filter: blur(68px);\n  }\n}\n\n.image-src {\n  width: 100%;\n  height: 100%;\n  animation: logo 2s infinite alternate;\n}\n\n@keyframes logo {\n  75%, 100% {\n    transform: translate(-50%, -50%) scale(1.02) translateY(-6px);\n    opacity: 0.9;\n  }\n}\n</style>\n```\n\n----------------------------------------\n\nTITLE: CSS Styling for Homepage Hero Section\nDESCRIPTION: This CSS code styles the hero section of the Velite homepage. It customizes the text color and background, as well as adds a blur filter and animation to the hero image. Media queries adjust the blur filter based on screen size.\nSOURCE: https://github.com/zce/velite/blob/main/docs/zh-CN/index.md#_snippet_1\n\nLANGUAGE: CSS\nCODE:\n```\n<style>\n:root {\n  --vp-home-hero-name-color: transparent;\n  --vp-home-hero-name-background: -webkit-linear-gradient(45deg, #11E49D 30%, #13AAAA);\n  --vp-home-hero-image-background-image: linear-gradient(-45deg, #08A77199 50%, #04D0D099 50%);\n  --vp-home-hero-image-filter: blur(44px);\n}\n\n@media (min-width: 640px) {\n  :root {\n    --vp-home-hero-image-filter: blur(56px);\n  }\n}\n\n@media (min-width: 960px) {\n  :root {\n    --vp-home-hero-image-filter: blur(68px);\n  }\n}\n\n.image-src {\n  width: 100%;\n  height: 100%;\n  animation: logo 2s infinite alternate;\n}\n\n@keyframes logo {\n  75%, 100% {\n    transform: translate(-50%, -50%) scale(1.02) translateY(-6px);\n    opacity: 0.9;\n  }\n}\n</style>\n```\n\n----------------------------------------\n\nTITLE: JSX Component: HTML Comment\nDESCRIPTION: This is an HTML-style comment embedded within JSX code. It is used for adding notes and explanations within the component's markup, but it will not be rendered in the final output.\nSOURCE: https://github.com/zce/velite/blob/main/examples/vite/content/pages/about/index.mdx#_snippet_3\n\nLANGUAGE: JSX\nCODE:\n```\n{/* This is a comment */}\n```\n\n----------------------------------------\n\nTITLE: YAML Frontmatter Configuration\nDESCRIPTION: This YAML frontmatter configures the homepage's title, hero section, and features. It defines the text, image, and actions displayed in the hero section, and lists features with icons, titles, and descriptions.\nSOURCE: https://github.com/zce/velite/blob/main/docs/zh-CN/index.md#_snippet_0\n\nLANGUAGE: YAML\nCODE:\n```\n---\nlayout: home\n\ntitle: Velite\ntitleTemplate: ËÆ©ÂàõÈÄ†ÊÄßÂÜÖÂÆπÊõ¥ÁÆÄÂçï\n\nhero:\n  name: Velite\n  text: ËÆ©ÂàõÈÄ†ÊÄßÂÜÖÂÆπÊõ¥ÁÆÄÂçï\n  tagline: ÂÜÖÂÆπ‰ºòÂÖàÂ∫îÁî®ÁöÑÊñ∞ÈÄâÊã©\n  image:\n    src: /assets/icon.svg\n    alt: Velite Logo\n  actions:\n    - theme: brand\n      text: Âø´ÈÄü‰∏äÊâã\n      link: ./guide/quick-start.md\n    - theme: alt\n      text: Âú® GitHub ‰∏äÊü•Áúã\n      link: https://github.com/zce/velite\n\nfeatures:\n  - icon: ü§©\n    title: ÂºÄÁÆ±Âç≥Áî®\n    details: Â∞Ü Markdown / MDX„ÄÅYAML„ÄÅJSON ÊàñÂÖ∂‰ªñÊñá‰ª∂ËΩ¨Êç¢‰∏∫Â∫îÁî®Êï∞ÊçÆÂ±Ç„ÄÇ\n  - icon: üí™\n    title: Á±ªÂûãÂÆâÂÖ®\n    details: Âü∫‰∫é Zod Ê®°ÂºèÁöÑÂÜÖÂÆπÂ≠óÊÆµÈ™åËØÅÔºåÂêåÊó∂Ëá™Âä®ÁîüÊàêÁöÑ TypeScript Á±ªÂûã„ÄÇ\n  - icon: üöÄ\n    title: ËΩªÈáèÈ´òÊïà\n    details: ËΩªÈáèÈ´òÊïàÔºå‰ªçÁÑ∂Âº∫Â§ßÔºåÂêØÂä®Êõ¥Âø´ÔºåÊÄßËÉΩÊõ¥Â•Ω„ÄÇ\n  - icon: üóÇÔ∏è\n    title: ËµÑÊ∫êÂ§ÑÁêÜ\n    details: ÂÜÖÁΩÆËµÑÊ∫êÂ§ÑÁêÜÔºå‰æãÂ¶ÇÁõ∏ÂØπË∑ØÂæÑÊñá‰ª∂Ëß£Êûê„ÄÅÂõæÂÉè‰ºòÂåñÁ≠â„ÄÇ\n---\n\n```\n\n----------------------------------------\n\nTITLE: Install Dependencies (npm)\nDESCRIPTION: This command installs the dependencies required for the Velite example project. It uses the npm package manager.\nSOURCE: https://github.com/zce/velite/blob/main/examples/basic/readme.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\n$ npm install # install dependencies\n```\n\n----------------------------------------\n\nTITLE: Installing Velite via pnpm\nDESCRIPTION: This command installs Velite as a development dependency using pnpm. The `-D` flag ensures that Velite is added to the `devDependencies` section of your `package.json` file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\n$ pnpm add velite -D\n```\n\n----------------------------------------\n\nTITLE: Installing Velite via yarn\nDESCRIPTION: This command installs Velite as a development dependency using yarn. The `-D` flag ensures that Velite is added to the `devDependencies` section of your `package.json` file.\nSOURCE: https://github.com/zce/velite/blob/main/docs/guide/quick-start.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\n$ yarn add velite -D\n```"
  }
]