[
  {
    "owner": "igorkamyshev",
    "repo": "farfetched",
    "content": "TITLE: Creating a JSON API Query with createJsonQuery (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a JSON API query using the `createJsonQuery` factory from `@farfetched/core`. It includes the declaration of parameters using `declareParams`, the request configuration with method and URL, and the response handling with a contract. It is a basic example of how to fetch data from a REST API that returns JSON.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_query_factories.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\n\nconst characterQuery = createJsonQuery({\n  params: declareParams<{ id: number }>(),\n  request: {\n    method: 'GET',\n    url: ({ id }) => `https://rickandmortyapi.com/api/character/${id}`,\n  },\n  response: {\n    contract: Character,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Request Configuration in createJsonMutation (TypeScript)\nDESCRIPTION: This code snippet highlights the `request` configuration within `createJsonMutation`. Specifically, it showcases how to define the HTTP method (`POST`), URL, and request body based on the input parameters. The `body` is defined as a function that transforms the `login` and `password` parameters into a `credentials` object within the request body.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_mutation_factories.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMutation = createJsonMutation({\n  params: declareParams<{ login: string; password: string }>(),\n  request: {\n    method: 'POST',\n    url: 'https://api.salo.com/login',\n    body: ({ login, password }) => ({ credentials: { login, password } }),\n  },\n  response: {\n    contract: unknownContract,\n    status: { expected: 204 },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutation with createJsonMutation in Farfetched\nDESCRIPTION: This snippet demonstrates how to create a mutation using `createJsonMutation` in Farfetched. The mutation adds a new user to a remote API endpoint. It depends on `@farfetched/core` and `userContract` for response validation. The mutation uses a POST method to send data to the specified URL.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonMutation } from '@farfetched/core';\n\nconst addUserMutation = createJsonMutation({\n  request: {\n    url: 'https://api.salo.com/users',\n    method: 'POST',\n  },\n  response: { contract: userContract },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Mutation with Handler (TypeScript)\nDESCRIPTION: Creates a Mutation using a handler function that performs an asynchronous operation (login). It sends a POST request to an API endpoint and returns the JSON response. The handler function receives the login and password as parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_mutation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMutation = createMutation({\n  handler: async ({ login, password }) => {\n    const response = await fetch('https://api.salo.com/login.json', {\n      method: 'POST',\n      body: JSON.stringify({ login, password }),\n    });\n\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using Base URL in createJsonQuery (TypeScript)\nDESCRIPTION: This example demonstrates how to use the `baseUrl` function within a `createJsonQuery` configuration to define the API request URL. It imports `createJsonQuery` from `@farfetched/core` and uses the baseUrl function to construct the full URL for the '/users' endpoint, setting the HTTP method to 'GET'.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/base_url.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\n\nconst usersQuery = createJsonQuery({\n  request: {\n    url: baseUrl('/users'),\n    method: 'GET',\n  },\n  /* ... */\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Feature Flag Instance\nDESCRIPTION: This snippet demonstrates how to create a feature flag instance using a `createFlag` function.  The returned object contains a `$value` field, which holds the current value of the feature flag. This example prepares for extension by returning a potential object with additional fields such as loading state.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst { $value: $dynamicFaviconEnabled } = createFlag({\n  /* ... */\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Query with createJsonQuery in Farfetched\nDESCRIPTION: This snippet shows how to create a query using `createJsonQuery` in Farfetched. It defines a query that fetches a list of users from a remote API endpoint. It relies on `@farfetched/core` and `userListContract` for type safety. The query uses a GET method to retrieve data from the specified URL.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\n\nconst usersListQuery = createJsonQuery({\n  request: { url: 'https://api.salo.com/users', method: 'GET' },\n  response: { contract: userListContract },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Query with Axios in Farfetched (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a Farfetched Query that uses Axios instead of the Fetch API for making HTTP requests. It imports `createQuery` from `@farfetched/core` and `axios` from 'axios', then defines a handler function that uses `axios.get` to fetch data from the '/users' endpoint and returns the response data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/no_fetch.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery } from '@farfetched/core';\nimport axios from 'axios';\n\nconst usersQuery = createQuery({\n  async handler() {\n    const response = await axios.get('/users');\n\n    return response.data;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Starting a Query with Parameters in Typescript\nDESCRIPTION: This code snippet shows how to start a Farfetched Query with specific parameters.  The `start` method is called on the query instance, passing an object containing the necessary parameters (in this case, an `id` of 1). This triggers the handler function to execute with the provided parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncharacterQuery.start({ id: 1 });\n```\n\n----------------------------------------\n\nTITLE: Injecting Redis Adapter with Fork API\nDESCRIPTION: This code demonstrates how to inject the Redis adapter into the Farfetched query during SSR using Effector's `fork` API. It overrides the default `inMemoryCache` with the `redisCache` adapter, ensuring that the server-side rendering utilizes Redis for caching.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nfunction handleHttp(req, res) {\n  const scope = fork({\n    values: [\n      // NOTE: let's use Redis adapter on server for charactersCache\n      [\n        charactersCache.__.$adapter,\n        redisCache({\n          maxAge: 60 * 60 * 1000, // 1 hour\n        }),\n      ],\n    ],\n  });\n\n  // ... run calculations\n\n  // ... render html\n\n  // ... send response\n}\n```\n\n----------------------------------------\n\nTITLE: Creating io-ts Contract with ioTsContract\nDESCRIPTION: This code snippet demonstrates how to create a Farfetched `Contract` using `ioTsContract` from `@farfetched/io-ts`.  It defines an io-ts type `Asteroid` and then uses `ioTsContract` to create a contract that validates data against the `Asteroid` type. The `ioTsContract` function takes an io-ts `Type` as input and returns a Farfetched `Contract`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/io-ts.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as t from 'io-ts';\nimport { ioTsContract } from '@farfetched/io-ts';\n\nconst Asteroid = t.type({\n  type: t.literal('asteroid'),\n  mass: t.number,\n});\n\nconst asteroidContract = ioTsContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Applying the Barrier to a Query (TS)\nDESCRIPTION: This snippet demonstrates how to apply the created barrier to a Farfetched query. The `applyBarrier` operator connects the query to the barrier, ensuring that the barrier's logic (token validation and refreshing) is executed before the query is executed or resumed.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/auth_token.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery, applyBarrier } from '@farfetched/core';\n\nconst someQuery = createQuery({ /* ... */ });\n\napplyBarrier(someQuery, { barrier: authBarrier });\n```\n\n----------------------------------------\n\nTITLE: Setting up retries for a query\nDESCRIPTION: This snippet demonstrates how to use the `retry` operator in Farfetched to automatically retry a query after a failure. It specifies the number of retries and the delay between each attempt. The `characterQuery` will be retried up to 5 times with a 500ms delay between attempts.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { retry } from '@farfetched/core';\n\n// let's retry our characterQuery\nretry(characterQuery, {\n  // up to 5 times\n  times: 5,\n  // with 500ms delay between attempts\n  delay: 500,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a JSON Mutation with createJsonMutation (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a JSON mutation using `createJsonMutation` from `@farfetched/core`. It defines the parameters using `declareParams`, specifies the request method, URL, and body, and sets the expected response status to 204. The `unknownContract` is used as a placeholder for the response contract.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_mutation_factories.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonMutation, declareParams } from '@farfetched/core';\n\nconst loginMutation = createJsonMutation({\n  params: declareParams<{ login: string; password: string }>(),\n  request: {\n    method: 'POST',\n    url: 'https://api.salo.com/login',\n    body: ({ login, password }) => ({ credentials: { login, password } }),\n  },\n  response: {\n    contract: unknownContract,\n    status: { expected: 204 },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating FormData Upload with Farfetched Mutation\nDESCRIPTION: This code snippet integrates the `uploadFile` function with Farfetched's `createMutation` to create a mutation for uploading files. It imports `createMutation` from `@farfetched/core` and defines `uploadFileMutation` using the `uploadFile` function as the handler.  This allows using the mutation across the application.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMutation } from '@farfetched/core';\n\nconst uploadFileMutation = createMutation({ handler: uploadFile });\n```\n\n----------------------------------------\n\nTITLE: Subscribing to Farfetched Query with useUnit in React\nDESCRIPTION: This example demonstrates how to subscribe to a Farfetched Query using `useUnit` from `effector-react`. It retrieves the query's data and pending state. The component renders a loader while the query is pending, and displays user information once the data is available. The `userQuery` is assumed to be a Farfetched Query defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/react/index.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUnit } from 'effector-react';\n\nfunction UserProfile() {\n  const { data: user, pending } = useUnit(userQuery);\n\n  if (pending) {\n    return <Loader />;\n  }\n\n  return (\n    <section>\n      <p>{user.name}</p>\n      <p>{user.email}</p>\n      //...\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Binding Abort Function to Query with onAbort in Typescript\nDESCRIPTION: This code snippet demonstrates how to use `onAbort` within a Farfetched `createQuery` handler to abort a fetch request.  It initializes an `AbortController`, binds the `abort()` method to `onAbort`, and passes the controller's signal to the `fetch` request. This ensures the request is aborted when the query is aborted.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/on_abort.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onAbort, createQuery } from '@farfetched/core';\n\nconst myQuery = createQuery({\n  async handler() {\n    const abortController = new AbortController();\n\n    onAbort(() => {\n      abortController.abort();\n    });\n\n    const response = await fetch('https://example.com', {\n      signal: abortController.signal,\n    });\n\n    return response.text();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Cache Query Usage\nDESCRIPTION: Illustrates how to use the `cache` function from `@farfetched/core` to cache a query's result.  The `query` argument is expected to be a Farfetched Query object.  `config` allows customization of the caching behavior, including the storage adapter to use.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/cache.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache } from '@farfetched/core';\n\ncache(query, config);\n```\n\n----------------------------------------\n\nTITLE: Using localStorageCache with maxAge option\nDESCRIPTION: This snippet demonstrates using `localStorageCache` with the `maxAge` option to set the maximum age of cached entries. Entries older than the specified time will be automatically deleted. Dependencies include `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { cache, localStorageCache } from '@farfetched/core';\n\ncache(characterQuery, {\n  adapter: localStorageCache({ maxAge: '1h30min' }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding Token Refreshing to the Barrier (TS)\nDESCRIPTION: This snippet extends the barrier by adding a mutation that is executed when the barrier is activated. In this case, `renewTokenMutation` is a Farfetched mutation that handles refreshing the authentication token. When the barrier is active (token invalid), this mutation will be triggered.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/auth_token.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier, createMutation } from '@farfetched/core';\n\nconst renewTokenMutation = createMutation(/* ... */);\n\nconst authBarrier = createBarrier({\n  /* ... */\n  perform: [renewTokenMutation],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Contract with jsonSchemaContract in Farfetched\nDESCRIPTION: Creates a Farfetched contract using a provided JSON Schema, leveraging the `jsonSchemaContract` function from the `@farfetched/json-schema` package. The contract validates data against the schema.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/json-schema.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { jsonSchemaContract } from '@farfetched/json-schema';\n\nconst contract = jsonSchemaContract({\n  type: 'object',\n  additionalProperties: false,\n  required: ['type', 'mass'],\n  properties: {\n    type: { type: 'string', enum: ['asteroid'] },\n    mass: { type: 'number' },\n  },\n});\n\n/* typeof contract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Initializing Auth Barrier in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a basic Farfetched Barrier that is activated when a 401 HTTP error code is encountered. The barrier is configured to perform the `renewTokenMutation` when activated. The `isHttpErrorCode` function from `@farfetched/core` is used to check for the 401 error code.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/barrier_circuit_breaker.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier, isHttpErrorCode } from '@farfetched/core';\n\nconst authBarrier = createBarrier({\n  activateOn: {\n    failure: isHttpErrorCode(401),\n  },\n  perform: [renewTokenMutation],\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Number Contract in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a custom Contract in Farfetched to validate if the input data is a number. It defines the `isData` function to check the data type and the `getErrorMessages` function to return an array of error messages if the validation fails. This contract can then be used in factories like `createQuery`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/contracts.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { type Contract } from '@farfetched/core';\n\nconst numberContract: Contract<\n  unknown, // it takes some unknown data\n  number // and returns number if it is valid\n> = {\n  // it is valid if data is a number\n  isData: (data): data is number => typeof data === 'number',\n  // if data is not a number,\n  // we return an array with description of reasons why data is invalid\n  getErrorMessages: (data) => {\n    return [`Expected number, got ${typeof data}`];\n  },\n};\n\n```\n\n----------------------------------------\n\nTITLE: Creating Query with Handler (createQuery)\nDESCRIPTION: Creates a Farfetched Query using a handler function to fetch data from an API endpoint. The handler function is an asynchronous function that makes a request to the specified URL and returns the JSON response. The `languagesQuery` is created to manage the state and lifecycle of this data fetching operation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_query.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst languagesQuery = createQuery({\n  handler: async () => {\n    const response = await fetch('https://api.salo.com/languages.json');\n\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using keepFresh with Query in Typescript\nDESCRIPTION: This code snippet demonstrates how to use the `keepFresh` operator from `@farfetched/core` to automatically refresh a query when certain events occur.  It imports the `keepFresh` function and then calls it with a query object and a configuration object that specifies automatic refreshing and a trigger event.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/keep_fresh.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { keepFresh } from '@farfetched/core';\n\nkeepFresh(query, { automatically: true, triggers: [someExternalEvent] });\n```\n\n----------------------------------------\n\nTITLE: Manual Query Refresh with Effector Sample - TypeScript\nDESCRIPTION: This code snippet demonstrates how to manually refresh a Farfetched query using Effector's `sample` function. It triggers the `someQuery.refresh` event whenever the `appStarted` event occurs, effectively refreshing the query's data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { sample } from 'effector';\nimport { createJsonQuery } from '@farfetched/core';\n\nconst someQuery = createJsonQuery({\n  /* ... */\n});\n\nsample({ clock: appStarted, target: someQuery.refresh });\n```\n\n----------------------------------------\n\nTITLE: Adding Cancellation Support to Axios Query (TypeScript)\nDESCRIPTION: This snippet demonstrates how to add cancellation support to an Axios-based Farfetched Query using `AbortController` and `onAbort`. It imports `createQuery` and `onAbort` from `@farfetched/core` and `axios` from 'axios'.  An `AbortController` is created, and `onAbort` is used to abort the Axios request when the query is aborted. The `signal` from the `AbortController` is passed to `axios.get` to enable cancellation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/no_fetch.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery, onAbort } from '@farfetched/core';\nimport axios from 'axios';\n\nconst usersQuery = createQuery({\n  async handler() {\n    const controller = new AbortController(); // [!code ++]\n    onAbort(() => controller.abort()); // [!code ++]\n\n    const response = await axios.get('/users', {\n      signal: controller.signal, // [!code ++]\n    });\n\n    return response.data;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Basic FormData Mutation Example\nDESCRIPTION: This is the final example that combines the basic file upload function with Farfetched's createMutation, providing a simple yet functional file upload mutation. The `uploadFile` function is defined inline, demonstrating the core components needed for FormData-based file uploads.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_10\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMutation } from '@farfetched/core';\n\nconst uploadFileMutation = createMutation({ handler: uploadFile });\n\nasync function uploadFile(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  return fetch('/upload', {\n    method: 'POST',\n    body: formData,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Mutation with Effect (TypeScript)\nDESCRIPTION: Creates a Mutation using an Effect, allowing for static typing of potential errors.  The Effect encapsulates the asynchronous login operation, fetching data from an API.  A LoginError is thrown if the response is not successful, demonstrating error handling within the Effect.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_mutation.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMutation = createMutation({\n  effect: createEffect<{ login: string; password: string }, { email: string }, LoginError>(async ({ login, password }) => {\n    const response = await fetch('https://api.salo.com/login.json', {\n      method: 'POST',\n      body: JSON.stringify({ login, password }),\n    });\n\n    if (!response.ok) {\n      throw new LoginError();\n    }\n\n    return response.json();\n  }),\n});\n\n// typeof loginMutation.finished.failure === Event<{\n//   error: LoginError,\n//   params: { login: string, password: string }\n// }>\n```\n\n----------------------------------------\n\nTITLE: Connecting Queries with Parameters (TypeScript)\nDESCRIPTION: Illustrates connecting two source Queries (`languagesQuery` and `blocksQuery`) to a target Query (`contentQuery`), passing parameters derived from the source Queries' results and parameters.  The `fn` function transforms the combined results and parameters of `languagesQuery` and `blocksQuery` into the desired parameter structure for `contentQuery`, specifically creating a `lang` and `ids` property within the `params` object.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/connect_query.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst blocksQuery: Query<unknown, string, unknown>;\nconst blocksQuery: Query<unknown, string[], unknown>;\n\nconst contentQuery: Query<{ language: string; ids: string[] }, unknown, unknown>;\n\nconnectQuery({\n  source: { language: languagesQuery, blocks: blocksQuery },\n  fn({ language, blocks }) {\n    // language.params contains parameters of the `languagesQuery`\n    // language.result contains result of the `languagesQuery`\n\n    // blocks.params contains parameters of the `blocksQuery`\n    // blocks.result contains result of the `blocksQuery`\n\n    return { params: { lang: language.result, ids: blocks.result } };\n  },\n  target: contentQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Mocking Query Fetcher Function in Tests (TypeScript)\nDESCRIPTION: This snippet demonstrates how to mock the fetcher function of a `createQuery` using Effector's `fork` API within a test.  It creates a new scope and overrides the `locationQuery.__.executeFx` handler with a mock implementation that returns 'Mocked'.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/testing.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst locationQuery = createQuery({ handler: /* some fetcher function */ })\n\ntest('let us mock function', async () => {\n    const scope = fork({ handlers: [\n        [locationQuery.__.executeFx, () => 'Mocked'],\n    ]})\n\n    // in returned scope locationQuery will be using provided function as a handler\n})\n```\n\n----------------------------------------\n\nTITLE: Connecting Queries with connectQuery\nDESCRIPTION: This snippet shows how to connect two queries using `connectQuery`. The `characterQuery` acts as the source, and its result is used to determine the parameters for the `originQuery`. The `fn` extracts the `originUrl` from the character data and returns it as a parameter for the `originQuery`. Requires `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/dependent_queries.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { connectQuery } from '@farfetched/core';\n\nconnectQuery({\n  source: characterQuery,\n  fn({ result: character }) {\n    return { params: { originUrl: character.origin.url } };\n  },\n  target: originQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Cache with Custom Serialization\nDESCRIPTION: Demonstrates how to customize serialization and deserialization of cached data using the `serialize` option within a cache adapter. `read` is used to deserialize data from storage, and `write` serializes data before storing it. This allows for adapting data to different storage formats or applying custom transformations.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/cache.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache, localStorageCache } from '@farfetched/core';\n\ncache(query, {\n  adapter: localStorageCache({\n    serialize: {\n      read: (data) => {\n        // Do your custom deserialization here\n\n        return parsedData;\n      },\n      write: (data) => {\n        // Do your custom serialization here\n\n        return serializedData;\n      },\n    },\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Cache Adapter Replacement via Fork API\nDESCRIPTION: This example demonstrates how to replace a cache adapter using Effector's Fork API, specifically replacing `localStorageCache` with `inMemoryCache` during testing.  It shows how to access the `.__.$instance` property of the adapter and replace its value within a test scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/cache.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\n// app.ts\nimport { localStorageCache } from '@farfetched/core';\n\n// Create some adapter to use in the appliaction\nconst applicationCacheAdapter = localStorageCache();\n\ncache(query, { adapter: applicationCacheAdapter });\n\n// app.test.ts\nimport { inMemoryCache } from '@farfetched/core';\n\ntest('app', async () => {\n  const scope = fork({\n    values: [\n      // Replace its implementation during fork\n      [applicationCacheAdapter.__.$instance, inMemoryCache()],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Apply Barrier to Operation - TypeScript\nDESCRIPTION: Applies a barrier to a single Farfetched Query or Mutation. The operation's execution will be postponed if the barrier is active and resumed when deactivated. Requires importing `applyBarrier` from `@farfetched/core`.  Takes the operation and a configuration object containing the barrier as arguments.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/apply_barrier.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyBarrier } from '@farfetched/core';\n\napplyBarrier(operation, { barrier });\n```\n\n----------------------------------------\n\nTITLE: Applying Contract to Mutation Response\nDESCRIPTION: This snippet demonstrates how to apply a contract (`UploadFileResponseContract`) to the parsed JSON response within a Farfetched mutation. The `contract` option in `createMutation` is used to validate and transform the response data.  Tutorial articles about contracts should be consulted for better understanding.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMutation, preparationError } from '@farfetched/core';\n\nconst uploadFileMutation = createMutation({\n  effect: createEffect(async (file) => {\n    const response = await uploadFile(file);\n\n    try {\n      const parsedJson = await response.json();\n      return parsedJson;\n    } catch (e) {\n      throw preparationError({ reason: 'Response is not JSON' });\n    }\n  }),\n  contract: UploadFileResponseContract, // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Query with mapParams in Typescript\nDESCRIPTION: Creates a new Query by attaching to an existing one and transforming its parameters using the `mapParams` function. This example demonstrates how to modify the input parameters of the original Query before they are passed to its handler.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation, createQuery } from '@farfetched/core';\n\nconst originalQuery = createQuery({\n  handler: async (params: string) => 'some data',\n});\n\nconst attachedQuery = attachOperation(originalQuery, {\n  mapParams: (params: number) => params.toString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Redis Instance to Effect - Typescript\nDESCRIPTION: Demonstrates using Effector's `attach` function to pass the Redis instance to an Effector Effect. This allows the Effect to interact with Redis for caching operations.  The source is the `$redis` store, and the effect is a function that deletes a key from Redis.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attach } from 'effector';\n\nfunction redisCache({ maxAge }) {\n  return createCacheAdapter({\n    get,\n    set,\n    unset: attach({\n      source: $redis,\n      effect: (redis, { key }) => redis.del(key),\n    }),\n    purge,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Applying a Number Contract to a Query in Farfetched (TypeScript)\nDESCRIPTION: This code snippet illustrates how to apply a previously defined `numberContract` to a `createQuery` in Farfetched. This ensures that the data returned by the query is validated against the contract before being used by the application. It highlights the usage of the `contract` property in the `createQuery` configuration.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/contracts.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst someQuery = createQuery({\n  // ...\n  contract: numberContract,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Mutation with Effector\nDESCRIPTION: This code snippet demonstrates the creation of a custom mutation using Effector's `createEvent` and `createEffect` to interact with asynchronous storage. It defines a function `createAsyncStorageMutation` that takes a `storageKey` and sets an item in `asyncLocalStorage` when the `start` event is triggered. It requires Effector.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/custom_mutation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createAsyncStorageMutation({ storageKey }) {\n  const start = createEvent();\n\n  const executeFx = createEffect((value) => asyncLocalStorage.setItem(storageKey, value));\n\n  sample({ clock: start, target: executeFx });\n\n  return { start, ... };\n}\n```\n\n----------------------------------------\n\nTITLE: Updating a Query on Mutation Success in Farfetched\nDESCRIPTION: This snippet illustrates how to update a query after a successful mutation using the `update` operator in Farfetched. It appends the result of the `addUserMutation` to the existing `usersListQuery` result.  It imports `update` from `@farfetched/core`. It uses the `success` field to handle successful mutation outcomes.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n\nupdate(usersListQuery, {\n  on: addUserMutation,\n  by: {\n    success: ({ mutation, query }) => ({\n      result: [...query.result, mutation.result],\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Declaring Query Parameters with declareParams (TypeScript)\nDESCRIPTION: This code snippet shows how to declare parameters for a query using the `declareParams` helper from `@farfetched/core`. It's used to define the type of parameters that the query accepts, enabling correct type inference in TypeScript projects. The `declareParams` helper takes a generic type argument, specifying the structure of the parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_query_factories.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { declareParams } from '@farfetched/core';\n\nconst characterQuery = createJsonQuery({\n  params: declareParams<{ id: number }>(),\n  request: {\n    method: 'GET',\n    url: ({ id }) => `https://rickandmortyapi.com/api/character/${id}`,\n  },\n  response: {\n    contract: Character,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Response Contract in createJsonQuery (TypeScript)\nDESCRIPTION: This code snippet shows how to define the response contract using the `response` configuration within `createJsonQuery`.  The `contract` field is used to specify a Farfetched `Contract` object which validates the shape of the response data from the API. This ensures data consistency and type safety.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_query_factories.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst characterQuery = createJsonQuery({\n  params: declareParams<{ id: number }>(),\n  request: {\n    method: 'GET',\n    url: ({ id }) => `https://rickandmortyapi.com/api/character/${id}`,\n  },\n  response: {\n    contract: Character,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Skipping fetch if data is fresh with staleAfter\nDESCRIPTION: This snippet shows how to use the `staleAfter` option with the `cache` operator to prevent fetching fresh data from the server if the cached data is not older than the specified time. If data is considered fresh, the request is skipped. Dependency is `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { cache } from '@farfetched/core';\n\ncache(characterQuery, { staleAfter: '10min' });\n```\n\n----------------------------------------\n\nTITLE: Data Validation with Sourced Validator in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use a sourced validator within a Farfetched query to validate the response against a session token stored in a store. It creates a store for the session and then defines a query that validates the result's userId against the session's userId using a custom function.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/data_flow.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst $session = createStore<{ userId: string } | null>(null);\n\nconst userQuery = createJsonQuery({\n  //...\n  response: {\n    validate: {\n      source: $session,\n      fn: (result, _params, sessionToken) => result.userId !== session.userId,\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Mutation with Effect and Contract (TypeScript)\nDESCRIPTION: Creates a Mutation using an Effect and a Contract for response validation. The Contract's `isData` function determines if the response is valid based on its content.  The `getErrorMessages` function provides descriptions of validation failures. This allows differentiating between API errors and invalid data responses.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_mutation.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMutation = createMutation({\n  effect: loginFx,\n  contract: {\n    // Our API can return empty object, we consider it as a failed mutation\n    isData: (response) => !response.email,\n    // Array with description of reasons why data is invalid\n    getErrorMessages: (response) => ['Expected object with email, but got empty object'],\n  },\n});\n\n// typeof loginMutation.finished.failure === Event<{\n//   error:\n//     | InvalidDataError ðŸ‘ˆ validation failed\n//     | ErrorFromEffect[] ðŸ‘ˆ API request failed,\n//   params: { login: string, password: string }\n// }>\n```\n\n----------------------------------------\n\nTITLE: Cancelling in-flight operations in Farfetched\nDESCRIPTION: This code snippet shows how to cancel all in-flight operations using the `abortAll` option with the `concurrency` operator in Farfetched. It uses an Effector event to trigger the cancellation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'effector';\nimport { concurrency, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  /* ... */\n});\n\nconst somethingHappened = createEvent();\n\n// Anytime you call `somethingHappened`,\n// all in-flight operations will be cancelled immediately\nconcurrency(query, { abortAll: somethingHappened });\n```\n\n----------------------------------------\n\nTITLE: Automatic Query Refresh with keepFresh - TypeScript\nDESCRIPTION: This example demonstrates how to automatically refresh a Farfetched query using the `keepFresh` operator. The query's request URL changes based on the `$language` store. The query refreshes automatically and also manually when `appStarted` event is triggered.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nimport { keepFresh, createJsonQuery } from '@farfetched/core';\n\nconst $language = createStore('en');\n\nconst someQuery = createJsonQuery({\n  request: {\n    url: { source: $language, fn: (_, language) => `/api/${language}` },\n  },\n});\n\nkeepFresh(someQuery, {\n  automatically: true,\n});\n\nsample({ clock: appStarted, target: someQuery.refresh });\n```\n\n----------------------------------------\n\nTITLE: Registering and Fetching Feature Flag Keys\nDESCRIPTION: This snippet implements the logic to register new feature flag keys, store them in an Effector store, and trigger a Farfetched query to fetch the values for those keys. It uses `createEvent` to register keys and trigger the request, and `createStore` to maintain the list of registered keys. A `sample` is used to connect registration, storage, and query execution.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createStore } from 'effector';\n\n// We will use this event in `createFlag` function to register new keys\nconst registerNewKey = createEvent<string>();\n\n// Let's store all registered keys for the application\nconst $requiredKeys = createStore<string[]>([])\n  .on(registerNewKey, (keys, key) => [...keys, key]);\n\n// We will trigger it in `createFlag` function to start fetching of the feature flag\nconst performRequest = createEvent();\n\n// Connect all together\nsample({\n  // every time when performRequest is triggered\n  clock: performRequest,\n  // take all $requiredKeys\n  source: $requiredKeys,\n  // transform them into an object with a single `flagKeys` field\n  fn: (flagKeys) => ({ flagKeys }),\n  // and start featureFlagsQuery with it\n  target: featureFlagsQuery.start,\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing a Feature Flag with createFlag Function\nDESCRIPTION: This code snippet demonstrates how to initialize a feature flag using the `createFlag` function.  It takes a key, default value, a contract for validation, and an event to trigger fetching. The `bool` contract from `@withease/contracts` is used to ensure the fetched value is a boolean. `applicationInitialized` is the event that triggers the initial data fetch.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nconst { $value: $dynamicFaviconEnabled } = createFlag({\n  key: 'exp-dynamic-favicon',\n  defaultValue: false,\n  contract: bool,\n  fetchOn: applicationInitialized,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Query with createHeadlessQuery (TypeScript)\nDESCRIPTION: This snippet demonstrates creating a custom Query using Farfetched's `createHeadlessQuery` helper. It simplifies the process by handling contracts and errors internally.  The `fetchFx` effect, responsible for fetching data using `asyncLocalStorage.getItem`, is connected to the `__.executeFx` property of the headless query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/custom_query.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHeadlessQuery } from '@farfetched/core';\n\nfunction createAsyncStorageQuery({ storageKey }) {\n  const fetchFx = createEffect(() => asyncLocalStorage.getItem(storageKey));\n\n  const headlessQuery = createHeadlessQuery(/*...*/);\n  headlessQuery.__.executeFx.use(fetchFx);\n\n  return headlessQuery;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Default Value to createFlag Function\nDESCRIPTION: This code snippet extends the `createFlag` function to include a `defaultValue`. The `defaultValue` is used if the feature flag is not found in the fetched data, preventing the store from containing null.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createFlag({ key, requestOn, defaultValue }) {\n  // ...\n\n  const $value = featureFlagsQuery.$data.map(\n    (data) =>\n      // Use defaultValue if the feature flag is not found\n      data.find((flag) => flag.flagKey === key) ?? defaultValue\n  );\n\n  return { $value };\n}\n```\n\n----------------------------------------\n\nTITLE: Update Query function signature\nDESCRIPTION: Demonstrates how to use the `update` function with arguments for query, on (mutation to subscribe) and by (success and failure handlers). The `update` function updates the provided `query` based on the outcome (success or failure) of the `mutation` it is subscribed to.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/update.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nupdate(query, { on, by: { success, failure } });\n```\n\n----------------------------------------\n\nTITLE: Wrapping Generated Code with Farfetched (TypeScript)\nDESCRIPTION: This TypeScript code imports a generated Effector Effect and wraps it with Farfetched's createQuery to create a Query. This allows using the generated code within Farfetched's data fetching primitives.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_8\n\nLANGUAGE: ts\nCODE:\n```\nimport { createQuery } from '@farfetched/core';\n\nimport { petsGet } from './swagger-petstore';\n\nexport const petsQuery = createQuery({ effect: petsGet });\n```\n\n----------------------------------------\n\nTITLE: Dynamically Configuring Redis with Fork - Typescript\nDESCRIPTION: Illustrates how to use Effector's `fork` API to dynamically inject the Redis connection string based on the environment. This allows you to use different Redis connections in different environments (e.g., development, production). The `values` property within `fork` is used to override the `$redisConnection` store with the value from the `REDIS_CONNECTION` environment variable.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_12\n\nLANGUAGE: typescript\nCODE:\n```\nfunction handleHttp(req, res) {\n  const scope = fork({\n    values: [\n      // NOTE: let's use Redis connection from environment variable\n      [$redisConnection, process.env.REDIS_CONNECTION],\n    ],\n  });\n\n  // ... run calculations\n\n  // ... render html\n\n  // ... send response\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Query with Effect (createQuery)\nDESCRIPTION: Creates a Farfetched Query using an Effector Effect to fetch data from an API endpoint. Includes error handling for scenarios where the API response does not contain expected data using custom error types. The `languagesQuery` is created using `createEffect` and handles possible `EmptyLanguagesError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_query.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst languagesQuery = createQuery({\n  effect: createEffect<Response, void, EmptyLanguagesError>(async () => {\n    const response = await fetch('https://api.salo.com/languages.json');\n\n    const data = await response.json();\n\n    if (!data.languages) {\n      throw new EmptyLanguagesError();\n    }\n\n    return data.languages;\n  }),\n});\n\n// typeof languagesQuery.$error === Store<EmptyLanguagesError | null>\n```\n\n----------------------------------------\n\nTITLE: Handling Mutation Results with Events - TS\nDESCRIPTION: This snippet demonstrates how to subscribe to the `finished.success` and `finished.failure` events of a mutation to handle the results. It uses `watch` to listen for these events and display notifications based on the outcome of the mutation.  It showcases how to extract `params` and `result` from the success event and `params` and `error` from the failure event.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_mutation.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncreateEntityMutation.finished.success.watch(({ params, result }) => {\n  showNotification({\n    message: `Entity ${params.id} was created!`,\n    type: 'info',\n  });\n});\n\ncreateEntityMutation.finished.failure.watch(({ params, error }) => {\n  showNotification({\n    message: `Entity ${params.id} was not created!`,\n    type: 'error',\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Basic File Upload with FormData and Fetch API\nDESCRIPTION: This JavaScript function uploads a file using the FormData object and the fetch API. It creates a FormData instance, appends the file to it, and sends a POST request to the /upload endpoint with the FormData as the request body. This function handles the basic file upload logic.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nasync function uploadFile(file) {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  return fetch('/upload', {\n    method: 'POST',\n    body: formData,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Aborting Concurrent Requests with Event in Typescript\nDESCRIPTION: This code snippet shows how to abort all in-flight requests of a Farfetched Query or Mutation using an Effector Event and the `concurrency` operator. It creates an event using `createEvent` from Effector and passes it to the `abortAll` property in the concurrency configuration. When the event is triggered, all pending requests associated with the operation are aborted.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/concurrency.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'effector';\nimport { concurrency } from '@farfetched/core';\n\nconst abortAll = createEvent();\n\nconcurrency(operation, { abortAll });\n```\n\n----------------------------------------\n\nTITLE: Create Custom Cache Adapter\nDESCRIPTION: This code initializes a custom cache adapter for Farfetched using Redis.  It utilizes `createCacheAdapter` from `@farfetched/core` to define the `get`, `set`, `unset`, and `purge` methods, each wrapped in an Effector effect. Currently, the methods are placeholders and require full implementation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEffect } from 'effector';\nimport { createCacheAdapter } from '@farfetched/core';\n\nfunction redisCache({ maxAge }: { maxAge: number }) {\n  return createCacheAdapter({\n    get: createEffect((_: { key: string }): { value: unknown; cachedAt: number } | null => {\n      // TODO: implement\n      return null;\n    }),\n    set: createEffect((_: { key: string; value: unknown }) => {\n      // TODO: implement\n      return;\n    }),\n    unset: createEffect((_: { key: string }) => {\n      // TODO: implement\n      return;\n    }),\n    purge: createEffect(() => {\n      // TODO: implement\n      return;\n    }),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Attaching Mutation with mapParams in Typescript\nDESCRIPTION: Creates a new Mutation by attaching to an existing one and transforming its parameters using `mapParams`. This modifies the input parameters of the original Mutation before they are passed to its handler.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation, createMutation } from '@farfetched/core';\n\nconst originaMutation = createMutation({\n  handler: async (params: string) => 'some data',\n});\n\nconst attachedMutation = attachOperation(originaMutation, {\n  mapParams: (params: number) => params.toString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a New Entity Mutation - TS\nDESCRIPTION: This snippet shows how to create a mutation to create a new entity using a `fetch` request. It defines `createEntityMutation` which sends a POST request to an API endpoint with the entity's name and ID. The handler parses the JSON response from the API.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_mutation.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst createEntityMutation = createMutation({\n  handler: async ({ name, id }) => {\n    const response = await fetch(`https://api.salo.com/api/`, {\n      method: 'POST',\n      body: JSON.stringify({ name, id }),\n    });\n\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rule Result type definition\nDESCRIPTION: Defines the structure of the `RuleResult` type. It represents the outcome of an update rule, which can either update the result or the error of the query, and optionally trigger a refresh of the query with the same or new parameters. The refresh parameter controls whether the query should be refetched after the update.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/update.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\ntype RuleResult =\n  | {\n      result: QueryResult;\n      refresh: boolean | { params: QueryParams };\n    }\n  | {\n      error: QueryError;\n      refresh: boolean | { params: QueryParams };\n    };\n```\n\n----------------------------------------\n\nTITLE: Implementing linear backoff for retries\nDESCRIPTION: This snippet demonstrates how to implement a linear backoff strategy for retries, where the delay between retries increases linearly with each attempt. The `delay` option is set to a function that multiplies the attempt number by a base delay (50ms in this case).\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nretry(characterQuery, {\n  times: 5,\n  // linear back off\n  delay: ({ attempt }) => attempt * 50,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Contract with superstructContract\nDESCRIPTION: This example demonstrates how to create a Farfetched Contract using `superstructContract` based on a Superstruct schema. The `superstructContract` function takes a Superstruct `Struct` as input and returns a Farfetched Contract that validates data against the schema. The resulting contract accepts an unknown input and validates if it matches the asteroid type.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/superstruct.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport * as s from 'superstruct';\nimport { superstructContract } from '@farfetched/superstruct';\n\nconst Asteroid = s.type({\n  type: s.literal('asteroid'),\n  mass: s.number(),\n});\n\nconst asteroidContract = superstructContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Set Effect\nDESCRIPTION: This effect sets a value in the Redis cache with the provided key.  It stringifies an object containing the `value` and the current timestamp (`cachedAt`) before storing it in Redis. The `EX` option sets an expiration time for the key, defined by `maxAge`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport Redis from 'ioreis';\n\nfunction redisCache({ maxAge }) {\n  const redis = new Redis();\n\n  return createCacheAdapter({\n    get,\n    set: createEffect(\n      async ({ key, value }) => {\n        await redis.set(\n          key,\n          JSON.stringify({ value, cachedAt: Date.now() }),\n          'EX',\n          maxAge\n        );\n      }\n    ),\n    unset,\n    purge,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutation Factory Function\nDESCRIPTION: This code creates a factory function `createUploadFileMutation` that returns a new file upload mutation. This allows creating multiple mutation instances for different file upload scenarios.  The Mutation creation is encapsulated within the function.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_6\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createUploadFileMutation() {\n  return createMutation({\n    /* ... */\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Query with Effect, Contract, and mapData with Source (createQuery)\nDESCRIPTION: Creates a Farfetched Query using an Effector Effect, a Contract, and a `mapData` function with a source store. The `mapData` function transforms the validated data into a new structure, using the current value of an external store (`$minimalLanguagesCount`) as input. `fetchLanguagesFx` is assumed to be defined elsewhere and returns data conforming to `languagesContract`. The returned store type is also described in the comment.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_query.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconst $minimalLanguagesCount = createStore(1);\n\nconst languagesQuery = createQuery({\n  effect: fetchLanguagesFx,\n  contract: languagesContract,\n  mapData: {\n    // Current value of $minimalLanguagesCount will be passed to `fn` as a third argument\n    source: $minimalLanguagesCount,\n    fn({ result: languages, params }, minimalLanguagesCount) {\n      return {\n        availableLanguages: languages,\n        languageCanBeSelected: languages.length > minimalLanguagesCount,\n      };\n    },\n  },\n});\n\n/* typeof languagesQuery.$data === Store<{\n *   availableLanguages: string[],\n *   languageCanBeSelected: boolean,\n * }>\n */\n```\n\n----------------------------------------\n\nTITLE: Query URL definition with stores and combine\nDESCRIPTION: This example shows how to define the `url` field of a query using `combine` and external stores (`$language`, `$region`). The `fn` transforms the combined values into a final URL based on the region.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/cache.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nconst locationQuery = createJsonQuery({\n  request: {\n    url: {\n      source: combine({ language: $language, region: $region }),\n      fn: (_params, { language, region }) => (region === 'us' ? `https://us-west.salo.com/${language}/location` : `https://eu-cent.salo.com/${language}/location`),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Re-executing a Query After Update in Farfetched\nDESCRIPTION: This snippet shows how to re-execute a query after an update using the `refetch` option in Farfetched. The `usersListQuery` will be marked as stale and re-executed after the successful `addUserMutation`. It depends on `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n\nupdate(usersListQuery, {\n  on: addUserMutation,\n  by: {\n    success: ({ mutation, query }) => ({\n      result: [...query.result, mutation.result],\n      refetch: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating similar Queries\nDESCRIPTION: This code snippet demonstrates creating three similar Queries: `characterQuery`, `originQuery`, and `currentLocationQuery`. The `originQuery` and `currentLocationQuery` are very similar and fetch data based on a URL. This motivates the need for copying queries to avoid code duplication.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/operation_copying.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst characterQuery = createQuery(/* ... */);\n\nconst originQuery = createQuery({\n  handler: async ({ originUrl }) => {\n    const response = await fetch(originUrl);\n    return response.json();\n  },\n});\n\nconst currentLocationQuery = createQuery({\n  handler: async ({ currentLocationUrl }) => {\n    const response = await fetch(currentLocationUrl);\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Mutation with source and mapParams in Typescript\nDESCRIPTION: Creates a new Mutation, attached to an existing one, transforming parameters using `mapParams` with an external source store. This incorporates data from an Effector store into the parameter mapping process, providing additional context for the transformation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'effector';\nimport { attachOperation, createMutation } from '@farfetched/core';\n\nconst $externalStore = createStore(12);\n\nconst originalMutation = createMutation({\n  handler: async (params: string) => 'some data',\n});\n\nconst attachedMutation = attachOperation(originalMutation, {\n  source: $externalStore,\n  mapParams: (params: number, externalSource) => (params + externalSource).toString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Contract with valibotContract\nDESCRIPTION: Demonstrates how to create a Farfetched Contract using valibotContract with a Valibot schema. The example defines an Asteroid schema and creates a contract to validate data against it. This validates an unknown input to ensure that it matches the asteroid schema.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/valibot.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { object, literal, number } from 'valibot';\nimport { valibotContract } from '@farfetched/valibot';\n\nconst Asteroid = object({\n  type: literal('asteroid'),\n  mass: number(),\n});\n\nconst asteroidContract = valibotContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Creating a Barrier with Explicit Token Validation (TS)\nDESCRIPTION: This snippet demonstrates creating a barrier that checks the validity of an authentication token stored in an Effector store. The `isTokenInvalid` function (not shown) is responsible for determining if the token is invalid, for example, by decoding a JWT and checking its expiration date. The barrier activates when the token is invalid.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/auth_token.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier } from '@farfetched/core';\n\nconst $authToken = createStore(/* ... */);\n\nconst authBarrier = createBarrier({\n  active: combine($authToken, (token) => isTokenInvalid(token)),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Query Resource Solid\nDESCRIPTION: Creating a Solid.js resource from a Farfetched query using createQueryResource. This allows using Suspense to handle loading states when fetching data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/suspense.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createQueryResource } from '@farfetched/solid';\n\nfunction UserProfile() {\n  const [user] = createQueryResource(userQuery);\n\n  return (\n    <Suspense fallback={<Loading />}>\n      <section>\n        <p>{user().name}</p>\n        <p>{user().email}</p>\n      </section>\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Concurrency with Mutation in Farfetched\nDESCRIPTION: This code snippet shows an example of using the concurrency operator on mutation. It is possible to use concurrency with Mutations but it is not recommended, so be sure about idempotent mutations on backend side. \nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency } from '@farfetched/core';\n\nconcurrency(postCommentMutation, { strategy: 'TAKE_LATEST' });\n```\n\n----------------------------------------\n\nTITLE: Verifying Query Data in Mocked Scope (TypeScript)\nDESCRIPTION: This snippet demonstrates how to verify the data within a mocked scope after all computations have settled. It uses `scope.getState` to retrieve the value of `locationQuery.$data` and compares it with the expected value ('Mocked').\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/testing.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst locationQuery = createQuery({ handler: /* some fetcher function */ })\n\ntest('let us mock function', async () => {\n    const scope = fork({ handlers: [\n        [locationQuery.__.executeFx, () => 'Mocked'],\n    ]})\n\n    await allSettled(locationQuery.refresh, { scope })\n\n    expect(scope.getState(locationQuery.$data)).toBe('Mocked')\n})\n```\n\n----------------------------------------\n\nTITLE: Creating Flagr Request Body\nDESCRIPTION: This snippet defines a function to create the request body for a Flagr feature flags service. It takes the list of flag keys and the application context as input and formats them into the expected structure for the Flagr API, including entities with user ID and context.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createFlagrRequestBody(flagKeys, context) {\n  return {\n    entities: [\n      {\n        entityID: context.userId,\n        entityContext: context,\n      },\n    ],\n    flagKeys,\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Using useUnit with React\nDESCRIPTION: This example demonstrates how to use the `useUnit` hook from `effector-react` to subscribe to a Farfetched Query's data in a React component. This hook simplifies accessing and using the query's data within the component's logic.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_5\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUnit } from 'effector-react';\n\nconst Character = () => {\n  const { data: character } = useUnit(characterQuery);\n\n  if (!character) {\n    return <div>Loading...</div>;\n  }\n\n  return (\n    <div>\n      <h1>{character.name}</h1>\n      <img src={character.image} />\n    </div>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Using onAbort with Axios in Farfetched\nDESCRIPTION: This code snippet demonstrates how to use `onAbort` with the Axios library for cancelling requests. It binds an AbortController to Axios's request configuration, allowing Farfetched's concurrency mechanism to cancel ongoing Axios requests when the Farfetched operation is aborted.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport axios from 'axios';\nimport { onAbort, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  async handler() {\n    const abortController = new AbortController();\n\n    onAbort(() => {\n      abortController.abort();\n    });\n\n    return axios.get('https://example.com', {\n      signal: controller.signal,\n    });\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Query to Fetch Rick and Morty Character in Typescript\nDESCRIPTION: This snippet demonstrates how to create a Farfetched Query that fetches a single character from the Rick and Morty API based on the character ID. The handler function makes an API call using fetch, retrieves the JSON response, and returns it as the query's data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst characterQuery = createQuery({\n  handler: async ({ id }) => {\n    const response = await fetch(`https://rickandmortyapi.com/api/character/${id}`);\n\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Cache with Auto-Deletion Config\nDESCRIPTION: Shows how to configure auto-deletion of cached results using `maxAge` and `maxEntries`. `maxAge` specifies the maximum age of a cached result, and `maxEntries` limits the number of entries in the cache. `someAdapter` is a placeholder for an actual adapter instance.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/cache.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache } from '@farfetched/core';\nimport { createEvent } from 'effector';\n\ncache(query, {\n  adapter: someAdapter({ maxAge: '15m', maxEntries: 300 }),\n});\n```\n\n----------------------------------------\n\nTITLE: Response Configuration in createJsonMutation (TypeScript)\nDESCRIPTION: This code snippet focuses on the `response` configuration within `createJsonMutation`. It shows how to define the expected response contract using `unknownContract` and specifies the expected HTTP status code as 204. This section is crucial for handling the API response and validating its success.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_mutation_factories.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst loginMutation = createJsonMutation({\n  params: declareParams<{ login: string; password: string }>(),\n  request: {\n    method: 'POST',\n    url: 'https://api.salo.com/login',\n    body: ({ login, password }) => ({ credentials: { login, password } }),\n  },\n  response: {\n    contract: unknownContract,\n    status: { expected: 204 },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Farfetched Query for Feature Flags\nDESCRIPTION: This snippet demonstrates how to create a Farfetched query to fetch feature flags from a remote source. It defines the request method, URL, and response contract. The `declareParams` function specifies that the query expects an object with a `flagKeys` field as input.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery, declareParams } from '@farfetched/core';\n\nconst featureFlagsQuery = createJsonQuery({\n  params: declareParams<{ flagKeys: string[] }>(),\n  request: {\n    method: 'POST',\n    url: 'https://flagr.salo.com/',\n    body: /* TODO: formulate request's body */,\n  },\n  response: {\n    contract: flagrResponseContract,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Simplified connectQuery form\nDESCRIPTION: This snippet demonstrates the simplified form of `connectQuery` when the child query does not require any parameters derived from the parent query's result. This directly connects `characterQuery` to `originQuery`, triggering `originQuery` after `characterQuery` completes.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/dependent_queries.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nconnectQuery({\n  source: characterQuery,\n  target: originQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Custom Mutation with createHeadlessMutation\nDESCRIPTION: This code snippet shows how to create a custom mutation using Farfetched's `createHeadlessMutation` helper.  It defines a function `createAsyncStorageMutation` that takes a `storageKey`, creates an effect `executeFx` to set an item in `asyncLocalStorage`, and then uses `createHeadlessMutation` to simplify the mutation creation.  It requires `@farfetched/core` and Effector.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/custom_mutation.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createHeadlessMutation } from '@farfetched/core';\n\nfunction createAsyncStorageMutation({ storageKey }) {\n  const executeFx = createEffect((value) => asyncLocalStorage.setItem(storageKey, value));\n\n  const headlessQuery = createHeadlessMutation(/*...*/);\n  headlessQuery.__.executeFx.use(executeFx);\n\n  return headlessQuery;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding Name Option for SSR, Cache, and DevTools\nDESCRIPTION: This code demonstrates how to add a `name` option to the `createUploadFileMutation` factory for better support of SSR, caching, and DevTools features. This requires a unique name for each mutation. The `name` option is passed to the `createMutation` function.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_8\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createUploadFileMutation({ name }) {\n  return createMutation({\n    name, // [!code ++]\n    /* ... */\n  });\n}\n\nconst uploadAvatarMutation = createUploadFileMutation({\n  name: 'uploadAvatar', // [!code ++]\n});\nconst uploadPhotoMutation = createUploadFileMutation({\n  name: 'uploadPhoto', // [!code ++]\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Feature Flags with Application Logic\nDESCRIPTION: This code snippet demonstrates how to integrate the feature flag service into the application logic. It imports necessary Effector functions and creates an event (`applicationInitialized`) to trigger the initial fetching of feature flags. It also shows how to use the feature flag value to conditionally execute an effect (`changeFaviconFx`). The `bool` contract from `@withease/contracts` is used for type safety. The `sample` is filtering `somethingHappened` events based on the `$dynamicFaviconEnabled` store.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_14\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createEffect, sample } from 'effector';\nimport { bool } from '@withease/contracts';\n\n// Do not forget to call it after application initialization\nconst applicationInitialized = createEvent();\n\nconst { $value: $dynamicFaviconEnabled } = createFlag({\n  key: 'exp-dynamic-favicon',\n  defaultValue: false,\n  contract: bool,\n  fetchOn: applicationInitialized,\n});\n\nconst somethingHappened = createEvent();\n\nconst changeFaviconFx = createEffect(() => {\n  const fav = document.querySelector('[rel=\"icon\"][type=\"image/svg+xml\"]');\n  fav.href = 'other-favicon.svg';\n});\n\nsample({\n  clock: somethingHappened,\n  filter: $dynamicFaviconEnabled,\n  target: changeFaviconFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Validator Function\nDESCRIPTION: Defines a validator as a simple function that accepts an object containing the result and parameters. The function returns a ValidationResult indicating whether the data is valid. The ValidationResult can be a boolean or an array of error strings.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/primitives/validator.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst validator = ({ result, params }): ValidationResult => result[params.id] !== null;\n```\n\n----------------------------------------\n\nTITLE: Using localStorageCache with maxAge and maxEntries options\nDESCRIPTION: This snippet showcases how to combine `maxAge` and `maxEntries` options with `localStorageCache` to automatically delete cache entries based on either age or count limits. This helps to manage storage and avoid running out of space. Dependencies include `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { cache, localStorageCache } from '@farfetched/core';\n\ncache(characterQuery, {\n  adapter: localStorageCache({ maxAge: '1h30min', maxEntries: 100 }),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Custom Query with Effector Primitives (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a custom Query using Effector primitives like `createStore`, `createEvent`, `createEffect`, and `sample`. It initializes stores for data and error, an event to trigger the fetch effect, and sets up subscriptions to update the stores based on the effect's completion.  The `asyncLocalStorage.getItem` method is used to fetch data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/custom_query.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createAsyncStorageQuery({ storageKey }) {\n  const $data = createStore(null);\n  const $error = createStore(null);\n\n  const start = createEvent();\n\n  const fetchFx = createEffect(() => asyncLocalStorage.getItem(storageKey));\n\n  sample({ clock: start, target: fetchFx });\n  sample({ clock: fetchFx.doneData, target: $data });\n  sample({ clock: fetchFx.failData, target: $error });\n\n  return { start, $data, $error, ... };\n}\n```\n\n----------------------------------------\n\nTITLE: Query Refresh with External Triggers via keepFresh - TypeScript\nDESCRIPTION: This code shows how to refresh a Farfetched query automatically based on an external trigger, such as user login. The `keepFresh` operator is used with the `triggers` option to specify the `userLoggedIn` event as a trigger.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { keepFresh, createJsonQuery } from '@farfetched/core';\n\nconst $language = createStore('en');\n\nconst someQuery = createJsonQuery(/* ... */);\n\nkeepFresh(someQuery, { triggers: [userLoggedIn] });\n\nsample({ clock: appStarted, target: someQuery.refresh });\n```\n\n----------------------------------------\n\nTITLE: Caching a Query with cache operator\nDESCRIPTION: This snippet demonstrates how to use the `cache` operator from `@farfetched/core` to cache a query.  It assumes that `characterQuery` is a previously defined Farfetched Query. The `cache` operator automatically handles caching based on the configuration and selected adapter.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_0\n\nLANGUAGE: ts\nCODE:\n```\nimport { cache } from '@farfetched/core';\n\ncache(characterQuery);\n```\n\n----------------------------------------\n\nTITLE: Update Query import statement\nDESCRIPTION: Imports the `update` function from the `@farfetched/core` library. This function is used to update a Farfetched Query based on the result of a Mutation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/update.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n```\n\n----------------------------------------\n\nTITLE: Applying Circuit Breaker to Auth Barrier (TypeScript)\nDESCRIPTION: This code snippet shows how to apply the `barrierCircuitBreaker` function to the `authBarrier`, limiting the number of token renewal attempts to 3. After 3 failed attempts, the barrier will be forcibly deactivated, preventing further token renewals.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/barrier_circuit_breaker.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nbarrierCircuitBreaker(authBarrier, { maxAttempts: 3 });\n```\n\n----------------------------------------\n\nTITLE: Mixing Automatic and Manual Refresh - TypeScript\nDESCRIPTION: This snippet demonstrates how to configure a query for both automatic refreshing and manual refreshing based on specific triggers. The `keepFresh` operator is used with `automatically: true` and a `triggers` array for manual triggers.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_11\n\nLANGUAGE: ts\nCODE:\n```\nkeepFresh(someQuery, {\n  automatically: true,\n  triggers: [userLoggedIn],\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Query with source and mapParams in Typescript\nDESCRIPTION: Creates a new Query, attached to an existing one, transforming parameters using `mapParams` with an external source store. This example shows how to incorporate data from an Effector store into the parameter mapping process, providing additional context for the transformation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'effector';\nimport { attachOperation, createQuery } from '@farfetched/core';\n\nconst $externalStore = createStore(12);\n\nconst originalQuery = createQuery({\n  handler: async (params: string) => 'some data',\n});\n\nconst attachedQuery = attachOperation(originalQuery, {\n  source: $externalStore,\n  mapParams: (params: number, externalSource) => (params + externalSource).toString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Items with Farfetched (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to fetch a list of items from a server using the Farfetched library. It imports the necessary functions from `@farfetched/core`: `createJsonQuery`, `isNetworkError`, and `retry`. It creates a query using `createJsonQuery` with the URL and HTTP method, and specifies a response contract. It uses `retry` to automatically retry the request up to 3 times with a 1-second delay if a network error occurs. The code then subscribes to the `finished.success` and `finished.error` events of the query to handle successful and failed requests, respectively. Finally, it calls `itemsQuery.refresh()` to initiate the data fetching process.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/index.md#_snippet_1\n\nLANGUAGE: js\nCODE:\n```\nimport { createJsonQuery, isNetworkError, retry } from '@farfetched/core';\n\nconst itemsQuery = createJsonQuery({\n  request: { url: '/api/items', method: 'GET' },\n  response: { contract: ItemsResponseContract },\n});\n\nretry(itemsQuery, {\n  times: 3,\n  delay: 1000,\n  filter: isNetworkError,\n});\n\nitemsQuery.finished.success.watch((items) => {\n  console.log('YEAH', items);\n});\nitemsQuery.finished.error.watch((error) => {\n  console.error('OH NO', error);\n});\n\nitemsQuery.refresh();\n```\n\n----------------------------------------\n\nTITLE: TAKE_LATEST concurrency strategy in Farfetched\nDESCRIPTION: This code snippet demonstrates the `TAKE_LATEST` concurrency strategy, where only the latest operation is executed.  Any existing in-flight operations are cancelled immediately when a new operation is triggered.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  /* ... */\n});\n\nconcurrency(query, { strategy: 'TAKE_LATEST' });\n```\n\n----------------------------------------\n\nTITLE: Registering a New Feature Key with createFlag Function\nDESCRIPTION: This code snippet shows how to register a new feature key within the `createFlag` function. The `sample` function from Effector is used to trigger the `registerNewKey` event whenever `requestOn` is triggered, passing the `key` as data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_9\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from 'effector';\n\nfunction createFlag({ key, requestOn }) {\n  sample({\n    // every time when requestOn is triggered\n    clock: requestOn,\n    // take a key\n    fn: () => key,\n    // and register it\n    target: registerNewKey,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Filtering HttpError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `isHttpError` error guard from `@farfetched/core` to filter for `HttpError` instances within a reactive stream of query failures.  It employs Effector's `sample` function to isolate failures that are classified as `HttpError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isHttpError } from '@farfetched/core';\n\nconst httpError = sample({\n  clock: query.finished.failure,\n  filter: isHttpError,\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Farfetched Barrier with Atomic Router using barrierChain (TypeScript)\nDESCRIPTION: This code snippet illustrates how to integrate a Farfetched Barrier with an Atomic Router route using `barrierChain`. The route will only open after the `authBarrier` is deactivated. It imports necessary modules from '@farfetched/core', '@farfetched/atomic-router', and 'atmoic-router'.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { createBarrier } from '@farfetched/core';\nimport { barrierChain } from '@farfetched/atomic-router';\nimport { chainRoute, createRoute } from 'atmoic-router';\n\nconst anyRoute = createRoute();\n\nconst authBarrier = createBarrier({\n  /* ... */\n});\n\nconst authOnlyRoute = chainRoute({\n  route: anyRoute,\n  ...barrierChain(authBarrier),\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Request Body for GraphQL Query - JavaScript\nDESCRIPTION: This snippet defines how the `request.body` is constructed for the GraphQL query. It utilizes a function that accepts parameters and constructs the body with `query` and `variables` fields based on the `request.graphQL.query` string and `request.graphQL.variables` function respectively.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/graphql_query.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createGraphQLQuery(config) {\n  const query = createJsonQuery({\n    ...config,\n    request: {\n      ...config.request,\n      method: 'POST',\n      query: {},\n      body: (params) => ({\n        query: request.graphQL.query,\n        variables: request.graphQL.variables(params))\n      }),\n    },\n  });\n\n  return query;\n}\n```\n\n----------------------------------------\n\nTITLE: Returning a Store with createFlag Function\nDESCRIPTION: This code snippet demonstrates how to return a store (`$value`) containing the feature flag value within the `createFlag` function. It uses the `featureFlagsQuery` to retrieve the flag data and maps the result to find the flag with the matching `key`. If no flag is found it defaults to null. The `featureFlagsQuery` is assumed to be a Farfetched query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_11\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createFlag({ key, requestOn }) {\n  // ...\n\n  // find particular flag\n  const $value = featureFlagsQuery.$data.map((data) => data.find((flag) => flag.flagKey === key) ?? null);\n\n  return { $value };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing atomic-router and @farfetched/atomic-router via pnpm\nDESCRIPTION: This command installs the atomic-router and @farfetched/atomic-router packages using pnpm. These packages are required for integrating Farfetched with Atomic Router.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install atomic-router @farfetched/atomic-router\n```\n\n----------------------------------------\n\nTITLE: Throwing PreparationError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw a `preparationError` in a Farfetched query test. It imports the `preparationError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `reason` and `response` parameters provide details about the preparation failure. The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { preparationError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw preparationError({ reason: 'Weird JSON', response: '{lolkek' });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Altering parameters before retry\nDESCRIPTION: This snippet illustrates how to modify the parameters of a request before each retry using the `mapParams` option. In this example, an `attempt` parameter is added to the request, indicating the current retry attempt number. It assumes `characterQuery` is created via `createQuery` and expects an `id` and `attempt` parameter.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nconst characterQuery = createQuery({\n  handler: async ({ id, attempt }) => {\n    const response = await fetch(`https://rickandmortyapi.com/api/character/${id}?attempt=${attempt}`);\n\n    return response.json();\n  },\n});\n\nretry(characterQuery, {\n  times: 5,\n  delay: 500,\n  mapParams: ({ params, error }, { attempt }) => ({\n    ...params,\n    attempt: attempt,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Reacting to cancellation with the .aborted event in Farfetched\nDESCRIPTION: This code snippet shows how to use the `.aborted` event of a Farfetched query to react to cancellation. The `.aborted` event is triggered when the operation is cancelled.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  /* ... */\n});\n\nquery.aborted // will be called when the operation is cancelled\n```\n\n----------------------------------------\n\nTITLE: Updating Validator function signature\nDESCRIPTION: This code snippet demonstrates the change in Validator signature. The validator function now accepts an object `{ result, params }` instead of separate `result` and `params` arguments to maintain consistency with `.finished.*` Events.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nfunction validator(\n  result, // [!code --]\n  params, // [!code --]\n  { result, params } // [!code ++]\n) {\n  // ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst validator = {\n  source: $externalStore,\n  fn(\n    result, // [!code --]\n    params, // [!code --]\n    { result, params }, // [!code ++]\n    externalSource\n  ) {\n    // ...\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Using linear and exponential delay helpers\nDESCRIPTION: This snippet shows how to use the `linearDelay` and `exponentialDelay` helpers from `@farfetched/core` to implement linear and exponential backoff strategies for retries.  `linearDelay(50)` creates a linear backoff with a base delay of 50ms, while `exponentialDelay(50)` creates an exponential backoff with a base delay of 50ms.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { linearDelay, exponentialDelay } from '@farfetched/core';\n\nretry(characterQuery, {\n  times: 5,\n  delay: linearDelay(50),\n});\n\nretry(loginMutation, {\n  times: 5,\n  delay: exponentialDelay(50),\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Farfetched JsonQuery\nDESCRIPTION: This code snippet demonstrates how to create a Farfetched JsonQuery for fetching a list of characters from the Rick and Morty API. It defines the request URL, method, and response contract using `createJsonQuery`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\n\nexport const characterListQuery = createJsonQuery({\n  params: declareParams<{ ids: TId[] }>(),\n  request: {\n    url: 'https://rickandmortyapi.com/api/character',\n    method: 'GET',\n  },\n  response: { contract: charactersListContract },\n});\n```\n\n----------------------------------------\n\nTITLE: Mutation State type definition\nDESCRIPTION: Defines the structure of the `MutationState` type. It can be a successful result with data and params, or an error state with error details and params. The `MutationResult` and `MutationParams` types are assumed to be defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/update.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ntype MutationState =\n  | {\n      result: MutationResult;\n      params: MutationParams;\n    }\n  | {\n      error: MutationError;\n      params: MutationParams;\n    };\n```\n\n----------------------------------------\n\nTITLE: Query Refresh with Web API Triggers - TypeScript\nDESCRIPTION: This example shows how to use triggers from `@withease/web-api` with Farfetched to refresh a query based on page visibility and network status. The `keepFresh` operator is configured to use `trackPageVisibility` and `trackNetworkStatus` as triggers.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_6\n\nLANGUAGE: ts\nCODE:\n```\nimport { trackPageVisibility, trackNetworkStatus } from '@withease/web-api';\nimport { keepFresh } from '@farfetched/core';\n\nkeepFresh(someQuery, {\n  triggers: [trackPageVisibility, trackNetworkStatus],\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing Queries with createQuery\nDESCRIPTION: This snippet demonstrates how to initialize two queries using `createQuery`. The `characterQuery` fetches character data from an API, and the `originQuery` fetches origin data based on the character's origin URL. The `characterQuery` takes an `id` parameter, and `originQuery` expects an `originUrl` parameter.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/dependent_queries.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// Our Query from the previous section\nconst characterQuery = createQuery({\n  handler: async ({ id }) => {\n    const response = await fetch(`https://rickandmortyapi.com/api/character/${id}`);\n\n    return response.json();\n  },\n});\n\n// Let's create a Query that extracts data about character's origin,\n// originUrl is a part of response of characterQuery\nconst originQuery = createQuery({\n  handler: async ({ originUrl }) => {\n    const response = await fetch(originUrl);\n\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Updating mapper signature in connectQuery\nDESCRIPTION: This snippet shows how to update the mapper function signature within `connectQuery`.  It now expects `{ result }` instead of just `result` for single-parent queries and `{ parentName: { result } }` for multi-parent queries to allow for future expansions without introducing breaking changes.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nconnectQuery({\n  source: languagesQuery,\n  fn(language) {\n    return { params: { lang: language } }; // [!code --]\n    return { params: { lang: language.result } }; // [!code ++]\n  },\n  target: contentQuery,\n});\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconnectQuery({\n  source: { language: languagesQuery, blocks: blocksQuery },\n  fn({ language, blocks }) {\n    return { params: { lang: language, ids: blocks } }; // [!code --]\n    return { params: { lang: language.result, ids: blocks.result } }; // [!code ++]\n  },\n  target: contentQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Caching a Farfetched Query\nDESCRIPTION: This snippet shows how to cache the response of a Farfetched query using the `cache` operator. By default, it stores the response in memory, which is suitable for client-side caching but has limitations on the server.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache } from '@farfetched/core';\n\ncache(characterListQuery);\n```\n\n----------------------------------------\n\nTITLE: Replacing attachOperation with function - mapParams\nDESCRIPTION: This snippet illustrates how to replace `attachOperation` when it's used with the `mapParams` option to alter the parameters of the original Query. It demonstrates how to achieve the same functionality using a plain JavaScript function with parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/attach_operation_deprecation.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\n/* [!code ++:8] */ function createOriginalQuery({ mapParams } = {}) {\n  return createQuery({\n    effect(rawParams) {\n      const params = mapParams ? mapParams(rawParams) : rawParams;\n      return fetch(/*...*/);\n    },\n  });\n}\n\n/* [!code --:5] */ const originalQuery = createQuery({\n  effect(params) {\n    return fetch(/*...*/);\n  },\n});\nconst originalQuery = createOriginalQuery(); // [!code ++]\n\n/* [!code --:3] */ const copiedQuery = attachOperation(originalQuery, {\n  mapParams: p + 1,\n});\n\nconst copiedQuery = createOriginalQuery({ mapParams: (p) => p + 1 }); // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Using createQueryResource with SolidJS\nDESCRIPTION: This snippet demonstrates how to use `createQueryResource` in Solid to subscribe to a Query's data. It creates a resource that will subscribe to the Query and provide its data to the component. `Suspense` is used to handle the loading state.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createQueryResource } from '@farfetched/solid';\n\nconst Character = () => {\n  const [character] = createQueryResource(characterQuery);\n\n  return (\n    <Suspense fallback=\"Loading...\">\n      <h1>{character()?.name}</h1>\n      <img src={character()?.image} />\n    </Suspense>\n  );\n};\n```\n\n----------------------------------------\n\nTITLE: Passing Application Context to Feature Flags Query\nDESCRIPTION: This snippet demonstrates how to pass application context, such as user ID and language, to the feature flags server. It uses Effector's `combine` function to merge multiple stores into a single context object. This context is then included in the request body of the Farfetched query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combine } from 'effector';\n\n// External stores that we want to pass to the feature flags server\n// it have to be filled outside of the feature flags service\nconst $userId = createStore<string | null>(null);\nconst $language = createStore<string | null>(null);\n\n// Let's combine all external stores into a request context\nconst $ctx = combine({ userId: $userId, language: $language });\n\n// And use it in the request body\nconst featureFlagsQuery = createJsonQuery({\n  params: declareParams<{ flagKeys: string[] }>(),\n  request: {\n    method: 'POST',\n    url: 'https://flagr.salo.com/',\n    body: {\n      source: $ctx,\n      fn: ({ flagsKeys }, ctx) => createFlagrRequestBody(flagsKeys, ctx),\n    },\n  },\n  response: {\n    contract: flagrResponseContract,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering HttpError with multiple codes in Farfetched (TypeScript)\nDESCRIPTION: This code demonstrates how to use `isHttpErrorCode` to filter for HTTP errors with specific status codes (404 or 403 in this case) using Effector's `sample`.  The `isHttpErrorCode` function accepts an array of status codes to check against.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_5\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isHttpErrorCode } from '@farfetched/core';\n\nconst notFoundOrForbidden = sample({\n  clock: query.finished.failure,\n  filter: isHttpErrorCode([404, 403]),\n});\n```\n\n----------------------------------------\n\nTITLE: Passing AbortSignal to Fetch API\nDESCRIPTION: This code snippet modifies the `uploadFile` function to accept an AbortSignal as an option and pass it to the fetch API. This allows the fetch request to be aborted using the AbortController.  The AbortSignal enables request cancellation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_5\n\nLANGUAGE: javascript\nCODE:\n```\nasync function uploadFile(file, { signal }) {\n  const formData = new FormData();\n  formData.append('file', file);\n\n  return fetch('/upload', {\n    method: 'POST',\n    body: formData,\n    signal, // [!code ++]\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Applying Concurrency Settings\nDESCRIPTION: This code snippet demonstrates how to import the `concurrency` function from `@farfetched/core` and apply it to an operation (either a Query or a Mutation) with a specific configuration. The configuration allows defining a concurrency strategy and an event to abort all requests.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/concurrency.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency } from '@farfetched/core';\n\nconcurrency(operation, config);\n```\n\n----------------------------------------\n\nTITLE: Throwing AbortError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw an `abortError` in a Farfetched query test. It imports the `abortError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `abortError` indicates that the query was aborted.  The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { abortError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw abortError();\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Updating a Query on Mutation Failure in Farfetched\nDESCRIPTION: This snippet shows how to handle query updates after a mutation failure in Farfetched. The `usersListQuery` is not updated with new data, but it is marked as stale and re-executed. It uses the `failure` field to manage failed mutation outcomes. It depends on `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n\nupdate(usersListQuery, {\n  on: addUserMutation,\n  by: {\n    failure: ({ mutation, query }) => ({\n      result: query.result,\n      refetch: true,\n    }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using @withease/factories for Custom Factories\nDESCRIPTION: This code uses the `@withease/factories` package to mark the custom factory for compatibility with code transformations. The `createFactory` function is used to wrap the factory function, and `invoke` is used to instantiate the mutations.  This enables advanced features for custom factories.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_9\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createFactory, invoke } from '@withease/factories';\n\n/* [!code ++:1] */ const createUploadFileMutation = createFactory(() => {\n  return createMutation({\n    /* ... */\n  });\n});\n\nconst uploadAvatarMutation = createUploadFileMutation(); // [!code --]\nconst uploadAvatarMutation = invoke(createUploadFileMutation); // [!code ++]\n\nconst uploadPhotoMutation = createUploadFileMutation(); // [!code --]\nconst uploadPhotoMutation = invoke(createUploadFileMutation); // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Creating a Barrier based on HTTP Error Code (TS)\nDESCRIPTION: This snippet creates a barrier that activates based on the HTTP status code of a failed request. Specifically, it activates when a request returns a 401 Unauthorized error. This is useful when the client doesn't have direct access to the token and relies on the server to indicate token validity.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/auth_token.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier, isHttpErrorCode } from '@farfetched/core';\n\nconst authBarrier = createBarrier({\n  activateOn: {\n    failure: isHttpErrorCode(401),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Query with Effect, Contract, and mapData (createQuery)\nDESCRIPTION: Creates a Farfetched Query using an Effector Effect, a Contract, and a `mapData` function to transform the response data. The `mapData` function transforms the validated data into a new structure. `fetchLanguagesFx` is assumed to be defined elsewhere and returns a `Response` object that conforms to the `languagesContract`. The `languagesQuery` uses the transformed data structure.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_query.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconst languagesQuery = createQuery({\n  effect: fetchLanguagesFx,\n  contract: languagesContract,\n  mapData({ result: languages, params }) {\n    return {\n      availableLanguages: languages,\n      languageCanBeSelected: languages.length > 1,\n    };\n  },\n});\n\n/* typeof languagesQuery.$data === Store<{\n *   availableLanguages: string[],\n *   languageCanBeSelected: boolean,\n * }>\n */\n```\n\n----------------------------------------\n\nTITLE: Starting a Mutation - TS\nDESCRIPTION: This snippet demonstrates how to start a mutation with specific parameters. It calls the `start` method on the `createEntityMutation` with an `id` and a `name`. This triggers the execution of the mutation's handler with the provided parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_mutation.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ncreateEntityMutation.start({ id: 1, name: 'Some new name' });\n```\n\n----------------------------------------\n\nTITLE: Parsing JSON Response in Farfetched Mutation\nDESCRIPTION: This code demonstrates how to parse the response from the `uploadFile` function as JSON within a Farfetched mutation. It uses `createEffect` to handle the asynchronous operation, attempts to parse the response as JSON, and throws a `preparationError` if parsing fails.  Unified error handling is achieved using error guards.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMutation, preparationError } from '@farfetched/core';\n\nconst uploadFileMutation = createMutation({\n  handler: uploadFile, // [!code --]\n  effect: createEffect(async (file) => {\n    const response = await uploadFile(file);\n\n    try {\n      const parsedJson = await response.json();\n      return parsedJson;\n    } catch (e) {\n      throw preparationError({ reason: 'Response is not JSON' });\n    }\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Feature Flag with Contract and Fetch\nDESCRIPTION: This snippet showcases how to configure a feature flag with a key, default value, contract for validation, and an event to trigger fetching the flag's value. The example uses `@withease/contracts` for data validation, ensuring the fetched value conforms to the expected boolean type.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { bool } from '@withease/contracts';\n\nconst { $value: $dynamicFaviconEnabled } = createFlag({\n  key: 'exp-dynamic-favicon',\n  defaultValue: false,\n  contract: bool,\n  fetchOn: applicationInitialized,\n});\n```\n\n----------------------------------------\n\nTITLE: Extracting a base Query\nDESCRIPTION: This code snippet extracts the common logic into a base Query called `locationQuery`. This Query accepts a `locationUrl` parameter and fetches data from that URL. This is the base query that will be copied and adapted for different purposes.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/operation_copying.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst locationQuery = createQuery({\n  handler: async ({ locationUrl }) => {\n    const response = await fetch(locationUrl);\n    return response.json();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering recipes sections using Vue loops\nDESCRIPTION: This Vue.js snippet iterates through the imported `sections` data.  Each section displays a heading and an unordered list. Each list item contains a link to a recipe, with the link and text dynamically populated from the recipe data. v-for is used to loop through the items and create the HTML structure.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<div v-for=\"section in sections\">\n  <h2>{{ section.text }}</h2>\n  <ul>\n    <li v-for=\"recipe in section.items\">\n        <a :href=\"recipe.link\">{{ recipe.text }}</a>\n    </li>\n  </ul>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Query Refresh with Interval Trigger - TypeScript\nDESCRIPTION: This example demonstrates how to use Patronum's `interval` method to refresh a Farfetched query every 5 seconds. The `keepFresh` operator is configured with the `interval` as a trigger.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_10\n\nLANGUAGE: ts\nCODE:\n```\nimport { keepFresh } from '@farfetched/core';\nimport { interval } from 'patronum';\n\nkeepFresh(someQuery, {\n  // ðŸ‘‡ someQuery will be refreshed every 5 seconds\n  triggers: [interval({ timeout: 5000 })],\n});\n```\n\n----------------------------------------\n\nTITLE: Subscribing to a Query with useUnit in Solid\nDESCRIPTION: This code snippet demonstrates how to subscribe to a Farfetched query using the `useUnit` hook from `effector-solid` within a Solid.js component. It extracts the data and pending state from the query and uses Solid's `Show` component to conditionally render a loader while the data is being fetched and the user profile when the data is available. It depends on `effector-solid` and the `userQuery` (presumably a Farfetched query).\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/index.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from 'effector-solid';\n\nfunction UserProfile() {\n  const { data: user, pending } = useUnit(userQuery);\n\n  return (\n    <>\n      <Show when={pending()}>\n        <Loader />\n      </Show>\n      <Show when={!pending()}>\n        <section>\n          <p>{user().name}</p>\n          <p>{user().email}</p>\n          //...\n        </section>\n      </Show>\n    </>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Base URL Creator Function (TypeScript)\nDESCRIPTION: This function creates a base URL by concatenating a given path to a fixed base URL. It takes a path as input and returns the full URL string. This is a simple example of creating a reusable base URL function for Farfetched API requests.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/base_url.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nfunction baseUrl(path) {\n  return `https://api.salo.com${path}`;\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Buggy Query with Barrier in Farfetched (TypeScript)\nDESCRIPTION: This code shows how to create a buggy query that can lead to an infinite loop when used with the auth barrier. The issue is a typo in the 'Authorisation' header, causing the barrier to be activated on every request. `createJsonQuery` from `@farfetched/core` creates the query, and `applyBarrier` associates it with the `authBarrier`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/barrier_circuit_breaker.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery, applyBarrier } from '@farfetched/core';\n\nconst buggyQuery = createJsonQuery({\n  request: {\n    method: 'GET',\n    url: 'https://api.salo.com/protected',\n    headers: combine($authToken, (token) => ({\n      // ðŸ‘‡ typo in header name\n      Authorisation: `Bearer ${token}`,\n    })),\n  },\n  // ...\n});\n\napplyBarrier(buggyQuery, { barrier: authBarrier });\n```\n\n----------------------------------------\n\nTITLE: Creating a Basic Query with createQuery in Typescript\nDESCRIPTION: This code snippet demonstrates how to create a basic Farfetched Query using the createQuery factory function. The handler function is an asynchronous function that accepts parameters and returns data. This example returns null as a placeholder and needs to be replaced with an actual implementation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQuery } from '@farfetched/core';\n\nconst myFirstQuery = createQuery({\n  handler: async (params) => {\n    // TODO: write handler here\n    return null;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Query with Effect and Contract (createQuery)\nDESCRIPTION: Creates a Farfetched Query using an Effector Effect and a Contract to validate the response.  The contract defines rules for validating the response and provides error messages when the validation fails. `fetchLanguagesFx` is assumed to be defined elsewhere and returns a `Response` object. The `languagesQuery` will manage the state based on the contract's validation results.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_query.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst languagesQuery = createQuery({\n  effect: fetchLanguagesFx,\n  contract: {\n    // Our API can return empty array of languages, we consider it as an invalid data\n    isData: (response) => response.languages?.length > 0,\n    // Array with description of reasons why data is invalid\n    getErrorMessages: (response) => ['Expected array with at least one language, but got empty array'],\n  },\n});\n\n/* typeof languagesQuery.$error === Store<\n *   | InvalidDataError ðŸ‘ˆ validation failed, languages list is empty\n *   | string[] ðŸ‘ˆ API errors from response.errors\n *   | null ðŸ‘ˆ no errors\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Filtering HttpError with specific code in Farfetched (TypeScript)\nDESCRIPTION: This code snippet shows how to use `isHttpErrorCode` to filter for HTTP errors with a specific status code (404 in this case) using Effector's `sample`. It imports `isHttpErrorCode` from `@farfetched/core` and creates a filter for query failures.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_4\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isHttpErrorCode } from '@farfetched/core';\n\nconst notFound = sample({\n  clock: query.finished.failure,\n  filter: isHttpErrorCode(404),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Patronum - pnpm\nDESCRIPTION: This command shows how to install `patronum` using pnpm. This library provides utilities for Effector, including an `interval` method for creating triggers based on time intervals.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\npnpm install patronum\n```\n\n----------------------------------------\n\nTITLE: Creating a Contract with Runtype\nDESCRIPTION: This code defines a Runtype for an Asteroid object and then uses the `runtypeContract` function from `@farfetched/runtypes` to create a contract. The contract can be used to validate data against the Asteroid Runtype.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/runtypes.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { Record, Literal, Number, Vector } from 'runtypes';\nimport { runtypeContract } from '@farfetched/runtypes';\n\nconst Asteroid = Record({\n  type: Literal('asteroid'),\n  mass: Number,\n});\n\nconst asteroidContract = runtypeContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Installing Effector-Solid with npm\nDESCRIPTION: This command installs the `effector-solid` package using the npm package manager. `effector-solid` provides bindings for using Effector with Solid.js, enabling reactive state management within Solid components.  It is a necessary dependency for integrating Farfetched with Solid.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/index.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install effector-solid\n```\n\n----------------------------------------\n\nTITLE: Applying the Barrier to Queries/Mutations\nDESCRIPTION: This code snippet shows how to apply the created barrier to `sensitiveQuery` and `sensitiveMutation` using the `applyBarrier` function from `@farfetched/core`. This ensures that these operations are suspended until the barrier is deactivated.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/terms_of_use.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyBarrier } from '@farfetched/core';\n\napplyBarrier([sensitiveQuery, sensitiveMutation], {\n  barrier: termsOfUseBarrier,\n});\n```\n\n----------------------------------------\n\nTITLE: Applying Concurrency with Operator in Typescript\nDESCRIPTION: This code snippet demonstrates how to apply concurrency settings to a Farfetched Query or Mutation using the `concurrency` operator. It imports the operator from `@farfetched/core` and specifies a strategy like `TAKE_LATEST` to manage concurrent requests. The operation parameter refers to either a Query or a Mutation object defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/concurrency.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency } from '@farfetched/core';\n\nconcurrency(operation, { strategy: 'TAKE_LATEST' });\n```\n\n----------------------------------------\n\nTITLE: Enabling Feature with Effector Sample\nDESCRIPTION: This snippet uses Effector's `createEvent`, `createEffect`, and `sample` to conditionally change the favicon when an event occurs, based on the value of the `$dynamicFaviconEnabled` store. The `changeFaviconFx` effect is triggered only when `$dynamicFaviconEnabled` is `true` upon the `somethingHappened` event.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent, createEffect, sample } from 'effector';\n\nconst somethingHappened = createEvent();\n\nconst changeFaviconFx = createEffect(() => {\n  const fav = document.querySelector('[rel=\"icon\"][type=\"image/svg+xml\"]');\n  fav.href = 'other-favicon.svg';\n});\n\nsample({\n  clock: somethingHappened,\n  filter: $dynamicFaviconEnabled,\n  target: changeFaviconFx,\n});\n```\n\n----------------------------------------\n\nTITLE: Cache Adapter Structure\nDESCRIPTION: This example shows the general structure of an adapter object within Farfetched. It includes `get`, `set`, and `purge` effects for interacting with the underlying cache store.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/cache.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nconst someAdapter = {\n  get: createEffect(({ key }) => /* ... */),\n  set: createEffect(({ key, value }) => /* ... */),\n  purge: createEffect(() => /* ... */),\n};\n```\n\n----------------------------------------\n\nTITLE: Filtering InvalidDataError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `isInvalidDataError` error guard from `@farfetched/core` to filter for `InvalidDataError` instances within a reactive stream of query failures. It utilizes Effector's `sample` function to extract only those failures that are classified as `InvalidDataError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isInvalidDataError } from '@farfetched/core';\n\nconst invalidDataInQuery = sample({\n  clock: query.finished.failure,\n  filter: isInvalidDataError,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Effector-Solid with pnpm\nDESCRIPTION: This command installs the `effector-solid` package using the pnpm package manager. `effector-solid` provides bindings for using Effector with Solid.js, enabling reactive state management within Solid components.  It is a necessary dependency for integrating Farfetched with Solid.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/index.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install effector-solid\n```\n\n----------------------------------------\n\nTITLE: Cache Adapter with Observability Events\nDESCRIPTION: Demonstrates how to integrate observability features into a Farfetched cache adapter. Events such as `hit`, `miss`, `expired`, and `evicted` are used to track cache interactions. These events are triggered based on the adapter's internal logic and provide insights into cache behavior.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/cache.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache } from '@farfetched/core';\nimport { createEvent } from 'effector';\n\nconst hit = createEvent(); // result is **found** and restored\nconst miss = createEvent(); // result is **not found**\nconst expired = createEvent(); // cache entry is **expired** and deleted\nconst evicted = createEvent(); // cache entry is **evicted** and deleted\n\ncache(query, {\n  adapter: someAdapter({ observability: { hit, miss, expired, evicted } }),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/json-schema with pnpm\nDESCRIPTION: Installs the @farfetched/json-schema package and its dependencies using the pnpm package manager. This package is required for integrating Farfetched with JSON Schema.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/json-schema.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install @farfetched/json-schema\n```\n\n----------------------------------------\n\nTITLE: Cancelling Mutation Requests with AbortController\nDESCRIPTION: This code demonstrates how to enable cancellation of the file upload mutation using the AbortController API. An AbortController is created, its signal is passed to the fetch function, and `onAbort` is used to abort the controller when the mutation is cancelled.  This allows Farfetched to cancel the mutation request.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_4\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createMutation, preparationError, onAbort } from '@farfetched/core';\n\nconst uploadFileMutation = createMutation({\n  effect: createEffect(async (file) => {\n    const abortController = new AbortController(); // [!code ++]\n    onAbort(() => abortController.abort()); // [!code ++]\n\n    const response = await uploadFile(file, {\n      signal: abortController.signal, // [!code ++]\n    });\n\n    try {\n      const parsedJson = await response.json();\n      return parsedJson;\n    } catch (e) {\n      throw preparationError({ reason: 'Response is not JSON' });\n    }\n  }),\n  contract: UploadFileResponseContract,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Farfetched Contract with Zod\nDESCRIPTION: Creates a Farfetched Contract using the `zodContract` function. The contract validates data against a provided Zod schema, ensuring type safety and data integrity. It uses the `zod` library to define the schema and `@farfetched/zod` for the contract creation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/zod.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { z as zod } from 'zod';\nimport { zodContract } from '@farfetched/zod';\n\nconst Asteroid = zod.object({\n  type: zod.literal('asteroid'),\n  mass: zod.number(),\n});\n\nconst asteroidContract = zodContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Mutation with declareParams in Farfetched\nDESCRIPTION: This code snippet shows how to define a simple mutation using `createJsonMutation` and `declareParams` from `@farfetched/core`. The mutation posts a new comment to the server.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonMutation, declareParams } from '@farfetched/core';\n\nconst postCommentMutation = createJsonMutation({\n  params: declareParams<{ text: string }>(),\n  request: {\n    url: '/comments',\n    method: 'POST',\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Fetching Items without Farfetched (JavaScript)\nDESCRIPTION: This code snippet demonstrates how to fetch a list of items from a server without using the Farfetched library. It includes error handling, response validation, and retry logic. The code defines an asynchronous function `fetchItems` to make the API call and another asynchronous function `start` to handle retries. The `start` function calls `fetchItems`, handles potential errors by checking if the error is due to a network failure and if the number of attempts is less than 3. If both are true, it waits for 1 second before retrying; otherwise, it throws the error.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/index.md#_snippet_0\n\nLANGUAGE: js\nCODE:\n```\nasync function fetchItems() {\n  const response = await fetch('/api/items', {\n    method: 'GET',\n  });\n  if (!reponse.ok) {\n    throw new Error('Failed to fetch');\n  }\n  const parsed = await response.json(); // Can be failed\n  const valid = validateAgainsContract(parsed, ItemsResponseContract);\n  if (!valid) {\n    throw new Error('Invalid response');\n  }\n  return parsed;\n}\n\nlet attempt = 0;\n\nasync function start(ids) {\n  try {\n    const items = await fetchItemsByIds(ids);\n    return items;\n  } catch (error) {\n    if (attemptForItems < 3 && error.message === 'Failed to fetch') {\n      attemptForItems += 1;\n      await new Promise((resolve) => setTimeout(resolve, 1000));\n      return start(ids);\n    } else {\n      throw error;\n    }\n  }\n}\n\nstart()\n  .then((items) => {\n    console.log('YEAH', items);\n  })\n  .catch((error) => {\n    console.error('OH NO', error);\n  });\n```\n\n----------------------------------------\n\nTITLE: Using Custom GraphQL Query Factory - JavaScript\nDESCRIPTION: This snippet showcases how to use the custom GraphQL query factory (`createGraphQLQuery`) alongside the built-in `createJsonQuery` factory. It demonstrates creating queries for both a simple API endpoint and a GraphQL endpoint, then connecting them using `connectQuery`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/graphql_query.md#_snippet_3\n\nLANGUAGE: javascript\nCODE:\n```\n// Query is created by built-in factory\nconst languageQuery = createJsonQuery({\n  request: {\n    url: '/api/language',\n    method: 'GET',\n  },\n  response: { mapData: ({ result }) => result.language.code },\n});\n\n// Query is created by custom factory\nconst countriesQuery = createGraphQLQuery({\n  request: {\n    url: '/api/graphql',\n    graphQL: {\n      query: `\n        query Countries($language: String!) {\n            countries {\n                iata\n            translations(filter: { locales: [$language] })\n          }\n        }`,\n      variables: (params) => ({\n        language: params.language,\n      }),\n    },\n  },\n  response: { mapData: ({ result }) => result.countries },\n});\n\n// They can be used together\nconnectQuery({\n  source: languageQuery,\n  fn({ result: language }) {\n    return { params: { language } };\n  },\n  target: countriesQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Creating Effector Events for Terms of Use\nDESCRIPTION: This code snippet creates two Effector events: `termsOfUseShowed` and `userAcceptedTermsOfUse`. The `termsOfUseShowed` event is triggered when the terms of use are displayed, and the `userAcceptedTermsOfUse` event is triggered when the user accepts the terms. These events are used to control the barrier.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/terms_of_use.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n// terms_of_use.model.ts\nimport { createEvent } from 'effector';\n\nexport const termsOfUseShowed = createEvent();\nexport const userAcceptedTermsOfUse = createEvent();\n```\n\n----------------------------------------\n\nTITLE: Filtering retries based on route activation\nDESCRIPTION: This snippet demonstrates how to use a reactive store (`characterRoute.$isOpened`) to conditionally enable retries based on whether a specific route is active. This allows retries to be enabled or disabled depending on the current page or state of the application.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nretry(characterQuery, {\n  times: 5,\n  delay: 500,\n  filter: characterRoute.$isOpened,\n});\n```\n\n----------------------------------------\n\nTITLE: Example of Retry Logic Implementation in Typescript\nDESCRIPTION: This code demonstrates a simplified example of how the `retry` operator could be implemented using Effector primitives like `createEvent`, `createStore`, and `sample`. It's not a complete implementation but illustrates the concept of using Effector's core functionalities to build operators.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/concurrency.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst nextRetry = createEvent();\nconst $retriesNotExceededLimit = createStore(false);\n\nsample({\n  clock: query.finished.failed,\n  filter: $retriesNotExceededLimit,\n  target: [query.start, nextRetry],\n});\n\nsample({\n  clock: nextRetry,\n  source: $retryNumber,\n  fn: (retryNumber) => retryNumber <= 12,\n  target: $retriesNotExceededLimit,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched with npm\nDESCRIPTION: This snippet demonstrates how to install Farfetched and its peer dependency, Effector, using the npm package manager. It ensures that the core functionality of Farfetched is available for use.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/install.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @farfetched/core effector\n```\n\n----------------------------------------\n\nTITLE: Implementing Barrier Circuit Breaker (TypeScript)\nDESCRIPTION: This code implements a circuit breaker function for a Farfetched Barrier. The function takes a barrier and options (including `maxAttempts`) as input. It creates a store to track the number of attempts, and uses `sample` to force deactivate the barrier and reset the attempt counter when the maximum number of attempts is exceeded. It uses effector's `createStore`, `sample` and `reinit` API.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/barrier_circuit_breaker.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nfunction barrierCircuitBreaker(barrier, { maxAttempts }) {\n  const $currentAttempt = createStore(0).on(\n    // every time after the Barrier is performed\n    barrier.performed,\n    // increment the current attempt\n    (attempt) => attempt + 1\n  );\n\n  sample({\n    // If the number of attempts exceeds the limit,\n    clock: $currentAttempt,\n    filter: (currentAttempt) => currentAttempt >= maxAttempts,\n    target: [\n      // force the Barrier to deactivate\n      barrier.forceDeactivate,\n      // and reset the current attempt counter\n      $currentAttempt.reinit,\n    ],\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Validating Query Result with Validator in Farfetched\nDESCRIPTION: This code snippet demonstrates how to use a Validator in Farfetched's createQuery to validate the result of an effect against the input parameters. It defines a blockQuery that fetches data based on an ID and then validates that the ID in the result matches the requested ID. The Validator function receives the result and parameters, and returns a boolean indicating whether the validation passed.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/validators.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst blockQuery = createQuery({\n  effect: createEffect(async ({ id }) => {\n    const response = await fetch(`https://api.salo.com/blocks/${id}.json`);\n\n    return response.json();\n  }),\n  validate: ({ result, params }) => result.id === params.id,\n});\n```\n\n----------------------------------------\n\nTITLE: Switching Base URLs in createJsonQuery (JavaScript)\nDESCRIPTION: This code snippet showcases how to switch between different base URLs within a `createJsonQuery` configuration using JavaScript. It shows how `otherBaseUrl` can be used instead of `baseUrl` to construct the API request URL for the '/users' endpoint. This demonstrates flexibility in choosing base URLs.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/base_url.md#_snippet_2\n\nLANGUAGE: javascript\nCODE:\n```\nconst usersQuery = createJsonQuery({\n  request: {\n    url: baseUrl('/users'), // [!code --]\n    url: otherBaseUrl('/users'), // [!code ++]\n    method: 'GET',\n  },\n  /* ... */\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering PreparationError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `isPreparationError` error guard from `@farfetched/core` to filter for `PreparationError` instances within a reactive stream of query failures. It utilizes Effector's `sample` function to process only failures categorized as `PreparationError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isPreparationError } from '@farfetched/core';\n\nconst preparationFailed = sample({\n  clock: query.finished.failure,\n  filter: isPreparationError,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing ioredis package\nDESCRIPTION: These commands demonstrate how to install the `ioredis` package using different package managers (pnpm, yarn, npm). `ioredis` is a Node.js Redis client that will be used to interact with the Redis database.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\npnpm install ioredis\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add ioredis\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm install ioredis\n```\n\n----------------------------------------\n\nTITLE: Vue.js Script Setup for ADR Display\nDESCRIPTION: This script imports the ADR data from `./adr.data` and makes it available to the Vue.js template. It uses the `data` property to import the records, which are then used in the template to generate the list of ADRs.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/index.md#_snippet_0\n\nLANGUAGE: Vue.js\nCODE:\n```\n<script setup>\n    import { data as docsByVersion } from './adr.data'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Combining error code and route activation filters\nDESCRIPTION: This snippet combines the previous two examples to retry only 500 errors when a particular route is active. It uses a sourced filter, where both the route activation status and the error code are considered. `characterRoute.$isOpened` store is used along with an `isHttpErrorCode(500)` check within the filter function.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nretry(characterQuery, {\n  times: 5,\n  delay: 500,\n  filter: {\n    source: characterRoute.$isOpened,\n    fn: ({ error, params }, isCharacterRouteOpened) => isCharacterRouteOpened && isHttpErrorCode(500)({ error }),\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Configuring Request Details in createJsonQuery (TypeScript)\nDESCRIPTION: This code snippet illustrates the `request` configuration within `createJsonQuery`, focusing on defining the HTTP method and URL for the API request. The `method` specifies the HTTP verb (e.g., GET, POST), while the `url` determines the endpoint. The URL can be a static string or a function that dynamically constructs the URL based on the query parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/built_in_query_factories.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst characterQuery = createJsonQuery({\n  params: declareParams<{ id: number }>(),\n  request: {\n    method: 'GET',\n    url: ({ id }) => `https://rickandmortyapi.com/api/character/${id}`,\n  },\n  response: {\n    contract: Character,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing createBarrier with activateOn failure and perform\nDESCRIPTION: Creates a barrier that activates based on a failure condition and performs actions.  The `isHttpErrorCode(401)` callback determines if the barrier should activate based on an HTTP 401 error. `renewTokenMutationFx` is executed when the barrier is active.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_barrier.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier, isHttpErrorCode } from '@farfetched/core';\nimport { combine } from 'effector';\n\nconst authBarrier = createBarrier({\n  activateOn: {\n    failure: isHttpErrorCode(401),\n  },\n  perform: [renewTokenMutationFx],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing typed-contracts and @farfetched/typed-contracts\nDESCRIPTION: This snippet demonstrates how to install `typed-contracts` and `@farfetched/typed-contracts` using pnpm, yarn, and npm package managers. It ensures that the necessary dependencies are available for using the `typedContract` function.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/typed-contracts.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\npnpm install typed-contracts @farfetched/typed-contracts\n```\n\nLANGUAGE: Shell\nCODE:\n```\nyarn add typed-contracts @farfetched/typed-contracts\n```\n\nLANGUAGE: Shell\nCODE:\n```\nnpm install typed-contracts @farfetched/typed-contracts\n```\n\n----------------------------------------\n\nTITLE: Filtering NetworkError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates using the `isNetworkError` error guard from `@farfetched/core` to filter for `NetworkError` instances within a reactive stream of query failures, leveraging Effector's `sample` function to extract and process only those failures categorized as `NetworkError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_6\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isNetworkError } from '@farfetched/core';\n\nconst networkProblems = sample({\n  clock: query.finished.failure,\n  filter: isNetworkError,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering retries based on HTTP error code\nDESCRIPTION: This snippet shows how to filter retries based on a specific HTTP error code (500 in this case). The `isHttpErrorCode` function from `@farfetched/core` is used to check if the error is an HTTP error with the specified code. Retries will only occur for 500 errors.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { isHttpErrorCode } from '@farfetched/core';\n\nretry(characterQuery, {\n  times: 5,\n  delay: 500,\n  // retry only 500 errors\n  filter: isHttpErrorCode(500),\n});\n```\n\n----------------------------------------\n\nTITLE: Attaching Farfetched DevTools with Effector Scope\nDESCRIPTION: This TypeScript code snippet demonstrates how to attach Farfetched DevTools when using Effector's Fork API. It creates a scope using `fork` from effector, and then passes it to `attachFarfetchedDevTools`. The DevTools will then monitor queries within that scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/devtools.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\nimport { fork } from 'effector';\n\nconst scope = fork();\n\nif (process.env.NODE_ENV === 'development') {\n  const { attachFarfetchedDevTools } = await import('@farfetched/dev-tools');\n\n  attachFarfetchedDevTools({ scope }); // [!code focus]\n}\n```\n\n----------------------------------------\n\nTITLE: Creating Farfetched Contract from Typed Contract\nDESCRIPTION: This snippet demonstrates how to create a Farfetched `Contract` using the `typedContract` function from `@farfetched/typed-contracts`. It defines a schema using `typed-contracts` and then converts it into a Farfetched contract for data validation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/typed-contracts.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { literal, object, number } from 'typed-contracts';\nimport { typedContract } from '@farfetched/typed-contracts';\n\nconst Asteroid = object({\n  type: literal('asteroid'),\n  mass: number,\n});\n\nconst asteroidContract = typedContract(Asteroid);\n\n/* typeof asteroidContract === Contract<\n *   unknown, ðŸ‘ˆ it accepts something unknown\n *   { type: 'asteriod', mass: number }, ðŸ‘ˆ and validates if it is an asteroid\n * >\n */\n```\n\n----------------------------------------\n\nTITLE: Install Zod and Farfetched Zod\nDESCRIPTION: Installs the `zod` and `@farfetched/zod` packages using either pnpm, yarn or npm.  These packages are required for integrating Farfetched with Zod for data validation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/zod.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install zod @farfetched/zod\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add zod @farfetched/zod\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm install zod @farfetched/zod\n```\n\n----------------------------------------\n\nTITLE: Filtering ConfigurationError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet shows how to use the `inConfigurationError` error guard from `@farfetched/core` to filter for `ConfigurationError` instances within a reactive stream of query failures. Effector's `sample` function is used to isolate and process only those failures classified as `ConfigurationError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_7\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { inConfigurationError } from '@farfetched/core';\n\nconst configurationProblems = sample({\n  clock: query.finished.failure,\n  filter: inConfigurationError,\n});\n```\n\n----------------------------------------\n\nTITLE: Using inMemoryCache Adapter\nDESCRIPTION: This code snippet shows how to configure the cache adapter with `inMemoryCache` from Farfetched. It initializes the `charactersCache` variable with the default adapter and applies it to the `characterListQuery` using the `cache` operator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_8\n\nLANGUAGE: typescript\nCODE:\n```\nimport { inMemoryCache } from '@farfetched/core';\n\n// NOTE: we use inMemoryCache as a default adapter\nconst charactersCache = imMemoryCache();\n\ncache(characterListQuery, { adapter: charactersCache });\n```\n\n----------------------------------------\n\nTITLE: Attaching Mutation with attachOperation in Typescript\nDESCRIPTION: Creates a new Mutation on top of an existing one using `attachOperation`. This demonstrates the basic usage of `attachOperation` with a simple Mutation created using `createMutation`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation, createMutation } from '@farfetched/core';\n\nconst originalMutation = createMutation({ handler: async () => 'some data' });\nconst attachedMutation = attachOperation(originalMutation);\n```\n\n----------------------------------------\n\nTITLE: Initializing a Mutation with createMutation - TS\nDESCRIPTION: This snippet demonstrates the basic usage of `createMutation` from `@farfetched/core`. It defines a mutation `myFirstMutation` with an asynchronous handler that accepts parameters and returns null. The handler represents the operation performed on the remote source.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_mutation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMutation } from '@farfetched/core';\n\nconst myFirstMutation = createMutation({\n  handler: async (params) => {\n    // TODO: write handler here\n    return null;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Complex Object Contract with @withease/contracts (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to create a more complex contract for an object using the `@withease/contracts` library. It defines a `characterContract` that validates the structure and types of properties within a character object, including nested objects and specific string values for the `status` property. This showcases the flexibility of `@withease/contracts` for validating complex data structures.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/contracts.md#_snippet_3\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { obj, str, num, or, val } from '`@withease/contracts`';\n\nconst characterContract = obj({\n  id: num,\n  name: str,\n  status: or(val('Alive'), val('Dead'), val('unknown')),\n  species: str,\n  type: str,\n  origin: obj({ name: str, url: str }),\n  location: obj({ name: str, url: str }),\n});\n\n```\n\n----------------------------------------\n\nTITLE: Migrating from @farfetched/react to effector-react\nDESCRIPTION: This code shows how to migrate from `@farfetched/react` to `effector-react` by replacing `useQuery` and `useMutation` with `useUnit`. The `@farfetched/react` package is deprecated and this example provides the correct usage for retrieving and updating the application state with the new approach. The import statements change and the calls to the hooks are modified to align with the new paradigm.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-5.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useQuery, useMutation } from '@farfetched/react'; // [!code --]\nimport { useUnit } from 'effector-react'; // [!code ++]\n\nfunction User() {\n  const { data: user } = useQuery(userQuery); // [!code --]\n  const { data: user } = useUnit(userQuery); // [!code ++]\n\n  const { start: deleteAccount } = useMutation(deleteAccountMutation); // [!code --]\n  const { start: deleteAccount } = useUnit(deleteAccountMutation); // [!code ++]\n\n  return (\n    <div>\n      <p>Name: {user.name}</p>\n      <button onClick={deleteAccount}>Delete my account</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Configuring Babel plugin for Effector\nDESCRIPTION: This snippet shows how to configure the Babel plugin for Effector by adding it to the \"plugins\" array in the Babel configuration file. It requires Babel to be installed. It modifies the Babel configuration to enable the Effector plugin.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/shared/sids_plugins.md#_snippet_0\n\nLANGUAGE: json\nCODE:\n```\n{\n  \"plugins\": [\"effector/babel-plugin\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Install OpenAPI Generator and Effector Preset (yarn)\nDESCRIPTION: This command installs the OpenAPI Generator, the Effector preset, and typed-contracts using yarn. These are required for generating Effector code from OpenAPI specifications.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add --dev openapi@^1.0.0 openapi-preset-effector typed-contracts\n```\n\n----------------------------------------\n\nTITLE: Using createQueryResource with SolidJS\nDESCRIPTION: This code demonstrates the usage of `createQueryResource` from `@farfetched/solid` in a SolidJS component.  It fetches user data using a Farfetched query (`userQuery`) and renders the user's name and email, handling loading and error states using `Suspense` and `ErrorBoundary` respectively. `createQueryResource` creates a SolidJS resource from a Farfetched query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/ui/solid.md#_snippet_3\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createQueryResource } from '@farfetched/solid';\n\nfunction UserProfile() {\n  const [user] = createQueryResource(userQuery);\n\n  return (\n    <Suspense fallback={<p>Loading...</p>}>\n      <ErrorBoundary fallback={<p>User could not be shown</p>}>\n        <section>\n          <p>{user()?.name}</p>\n          <p>{user()?.email}</p>\n        </section>\n      </ErrorBoundary>\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using @withease/contracts for data validation (TypeScript)\nDESCRIPTION: This code snippet showcases the usage of the `@withease/contracts` library for data validation in Farfetched. It imports the `num` contract from the library and applies it to a `createQuery`. This demonstrates a more convenient approach to data validation using pre-built contracts from a third-party library.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/contracts.md#_snippet_2\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { num } from '@withease/contracts';\n\nconst someQuery = createQuery({\n  // ...\n  contract: num,\n});\n\n```\n\n----------------------------------------\n\nTITLE: Fetching Logic with createFlag Function\nDESCRIPTION: This snippet adds the fetching logic to the `createFlag` function using Effector's `sample`. When `requestOn` is triggered, `performRequest` is called, presumably to fetch the feature flag value from a remote source.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport { sample } from 'effector';\n\nfunction createFlag({ key, requestOn }) {\n  // ...\n\n  sample({\n    // every time when requestOn is triggered\n    clock: requestOn,\n    // perform fetching\n    target: performRequest,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Triggering Farfetched Mutation with useUnit in React\nDESCRIPTION: This example demonstrates how to trigger a Farfetched Mutation using `useUnit` from `effector-react`. It retrieves the `start` function (to trigger the mutation) and the `pending` state from the mutation. The button's disabled state is bound to `deletionInProgress` to prevent multiple clicks while the mutation is running. `deleteAccountMutation` is assumed to be a Farfetched Mutation defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/react/index.md#_snippet_4\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUnit } from 'effector-react';\n\nfunction UserProfile() {\n  const { start: deleteAccount, pending: deletionInProgress } = useUnit(deleteAccountMutation);\n\n  return (\n    <section>\n      //...\n      <button disabled={deletionInProgress} onClick={deleteAccount}>\n        Delete my account\n      </button>\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Rendering App with Effector and Farfetched for SSR (Typescript)\nDESCRIPTION: This code snippet demonstrates how to render an application using Effector's `fork` API for server-side rendering. It creates a scope, awaits the completion of the `appStarted` event within that scope, renders the UI based on the scope's state, and returns the resulting HTML.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/ssr.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nasync function renderApp() {\n  const scope = fork();\n\n  await allSettled(appStarted, { scope });\n\n  const html = renderUI(scope);\n\n  return html;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/json-schema with npm\nDESCRIPTION: Installs the @farfetched/json-schema package and its dependencies using the npm package manager. This package is required for integrating Farfetched with JSON Schema.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/json-schema.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @farfetched/json-schema\n```\n\n----------------------------------------\n\nTITLE: Creating a Mutation with Axios in Farfetched (TypeScript)\nDESCRIPTION: This snippet shows how to create a Farfetched Mutation that uses Axios to make HTTP requests. It imports `createMutation` from `@farfetched/core` and `axios` from 'axios'. The handler function uses `axios.post` to send a POST request to the '/login' endpoint with login and password data, and then returns the response data.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/no_fetch.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createMutation } from '@farfetched/core';\nimport axios from 'axios';\n\nconst loginMutation = createMutation({\n  async handler({ login, password }) {\n    const response = await axios.post('/login', { login, password });\n\n    return response.data;\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Dynamic Base URL with Effector Store (TypeScript)\nDESCRIPTION: This example demonstrates creating a dynamic base URL using an Effector store for the language. It combines the `$langauge` store with a function that constructs the URL based on the current language. It uses Effector's `combine` function to react to changes in the `$langauge` store and update the URL dynamically. The function takes both language and path as implicit dependencies via closure over combined store and arguments respectively. Requires Effector.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/base_url.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { combine } from 'effector';\n\nfunction baseUrl(path) {\n  return `https://api.salo.com${path}`; // [!code --]\n\n  /* [!code ++:4] */ return combine($langauge, (language) => `https://api.salo.com/${language}${path}`);\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Effector-Solid with yarn\nDESCRIPTION: This command installs the `effector-solid` package using the yarn package manager. `effector-solid` provides bindings for using Effector with Solid.js, enabling reactive state management within Solid components.  It is a necessary dependency for integrating Farfetched with Solid.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/index.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add effector-solid\n```\n\n----------------------------------------\n\nTITLE: Data Mapping with Sourced Mapper in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use a sourced data mapper within a Farfetched query to transform the response by adding a translated name based on the current language stored in a store. It creates a store for the language and then defines a query that maps the result, adding a translated name from the result's translations using the current language.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/data_flow.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst $language = createStore<string>('EN');\n\nconst userQuery = createJsonQuery({\n  //...\n  response: {\n    mapData: {\n      source: $language,\n      fn: ({ result }, language) => ({\n        ...result,\n        name: result.name.translations[language],\n      }),\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from @farfetched/react (TSX)\nDESCRIPTION: Illustrates how to migrate from `@farfetched/react` to `effector-react` by replacing `useQuery` and `useMutation` with `useUnit`.  This migration leverages the `@@unitShape` protocol supported by Farfetched since v0.5, allowing direct subscription to queries and mutations using `useUnit`.  This snippet uses React and assumes `userQuery` and `deleteAccountMutation` are defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-6.md#_snippet_1\n\nLANGUAGE: tsx\nCODE:\n```\nimport { useUnit } from 'effector-react'; // [!code ++]\n\nfunction User() {\n  const { data: user } = useUnit(userQuery); // [!code ++]\n\n  const { start: deleteAccount } = useUnit(deleteAccountMutation); // [!code ++]\n\n  return (\n    <div>\n      <p>Name: {user.name}</p>\n      <button onClick={deleteAccount}>Delete my account</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Purging cache using an Effector Event\nDESCRIPTION: This snippet demonstrates how to purge the cache using an Effector Event. When the `logout` event is triggered, all data from the cache is deleted. This requires `effector` for event creation and `@farfetched/core` for caching functionality.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_5\n\nLANGUAGE: ts\nCODE:\n```\nimport { createEvent } from 'effector';\nimport { cache } from '@farfetched/core';\n\nconst logout = createEvent();\n\ncache(characterQuery, { purge: logout });\n\ndocument.getElementById('logout').addEventListener('click', () => {\n  logout();\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Runtypes and Farfetched\nDESCRIPTION: Install Runtypes and @farfetched/runtypes using pnpm, yarn, or npm. This package enables integration between Farfetched and Runtypes for data validation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/runtypes.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add runtypes @farfetched/runtypes\n```\n\n----------------------------------------\n\nTITLE: Suppressing intermediate errors\nDESCRIPTION: This snippet shows how to disable the suppression of intermediate errors during retries by setting `supressIntermediateErrors` to `false`. By default, `retry` will not throw errors until all retry attempts have failed. Setting this option to `false` will cause each error to be thrown immediately.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/retries.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nretry(characterQuery, {\n  times: 5,\n  delay: 500,\n  supressIntermediateErrors: false,\n});\n```\n\n----------------------------------------\n\nTITLE: Throwing TimeoutError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw a `timeoutError` in a Farfetched query test. It imports the `timeoutError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `timeout` parameter specifies the timeout duration in milliseconds. The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { timeoutError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw timeoutError({\n            timeout: 10,\n          });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Validating Feature Flag Value with createFlag Function\nDESCRIPTION: This code snippet shows how to validate the fetched feature flag value using a contract within the `createFlag` function. The `contract.isData` method is used to check if the fetched value conforms to the defined contract. If the value is invalid, the `defaultValue` is returned.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_13\n\nLANGUAGE: typescript\nCODE:\n```\nfunction createFlag({ key, requestOn, defaultValue, contract }) {\n  // ...\n\n  const $value = featureFlagsQuery.$data\n    .map((data) => data.find((flag) => flag.flagKey === key) ?? defaultValue)\n    .map((value) => {\n      // Check if the value is valid\n      if (contract.isData(value)) {\n        // if it's valid, return it\n        return value;\n      } else {\n        // otherwise, return a default value\n        return defaultValue;\n      }\n    });\n\n  return { $value };\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched with yarn\nDESCRIPTION: This snippet demonstrates how to install Farfetched and its peer dependency, Effector, using the yarn package manager. It ensures that the core functionality of Farfetched is available for use.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/install.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @farfetched/core effector\n```\n\n----------------------------------------\n\nTITLE: Initializing createBarrier with active store and perform\nDESCRIPTION: Creates a barrier that is active based on the given store and performs actions when active. The barrier's active state depends on the combined `$token` and `$now` stores, and it triggers `renewTokenMutationFx` when active.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_barrier.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier } from '@farfetched/core';\nimport { combine } from 'effector';\n\nconst authBarrier = createBarrier({\n  active: combine({ token: $token, now: $now }, ({ token, now }) => parseToken(token.exp) > now),\n  perform: [renewTokenMutationFx],\n});\n```\n\n----------------------------------------\n\nTITLE: Integrating Farfetched Query with Atomic Router using freshChain (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to integrate a Farfetched Query with an Atomic Router route using `freshChain`. When the `postRoute` is opened, the `postQuery` will only be executed if it's already stale. It imports necessary modules from '@farfetched/core', '@farfetched/atomic-router', and 'atomic-router'.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\nimport { freshChain } from '@farfetched/atomic-router';\nimport { chainRoute, createRoute } from 'atomic-router';\n\nconst postRoute = createRoute<{ postId: string }>();\n\nconst postQuery = createJsonQuery({\n  /* ... */\n});\n\nconst postLoadedRoute = chainRoute({\n  route: postRoute,\n  ...freshChain(postQuery),\n});\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/solid\nDESCRIPTION: Installation of the @farfetched/solid package using pnpm, yarn, and npm. This package provides integration between Farfetched and Solid.js.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/suspense.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install @farfetched/solid\n```\n\n----------------------------------------\n\nTITLE: Creating a Barrier with Farfetched\nDESCRIPTION: This code snippet demonstrates how to create a barrier using the `createBarrier` function from `@farfetched/core`. The barrier is activated when the `showTermsOfUse` event is triggered and deactivated when the `userAcceptedTermsOfUse` event is triggered. Requires `showTermsOfUse` and `userAcceptedTermsOfUse` events to be defined.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/terms_of_use.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier } from '@farfetched/core';\n\nconst termsOfUseBarrier = createBarrier({\n  // activate barrier when termsOfUseShowed\n  activateOn: showTermsOfUse,\n  // and deactivate it when userAcceptedTermsOfUse\n  deactivateOn: userAcceptedTermsOfUse,\n});\n```\n\n----------------------------------------\n\nTITLE: Throwing ConfigurationError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw a `configurationError` in a Farfetched query test. It imports the `configurationError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `validationErrors` parameter lists the configuration issues. The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport { configurationError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw configurationError({\n            validationErrors: ['\"LOL KEK\" is not valid URL'],\n          });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Installing @withease/web-api - yarn\nDESCRIPTION: This command shows how to install `@withease/web-api` using yarn. This library provides web API-based triggers for refreshing data in Farfetched queries.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_4\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @withease/web-api\n```\n\n----------------------------------------\n\nTITLE: Waiting for Query Computations to Settle (TypeScript)\nDESCRIPTION: This snippet demonstrates how to use `allSettled` to wait for all computations related to a Query to complete within a given scope. This is crucial for verifying the results of mocked fetcher functions in tests.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/testing.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconst locationQuery = createQuery({ handler: /* some fetcher function */ })\n\ntest('let us mock function', async () => {\n    const scope = fork({ handlers: [\n        [locationQuery.__.executeFx, () => 'Mocked'],\n    ]})\n\n    await allSettled(locationQuery.refresh, { scope })\n\n    // all computations are settled\n})\n```\n\n----------------------------------------\n\nTITLE: Altering Query Parameters During Update in Farfetched\nDESCRIPTION: This snippet demonstrates how to alter query parameters during an update operation in Farfetched. It allows specifying new parameters for re-execution caused by the update. It uses the `refetch` field with a `params` property to define the new parameters. It depends on `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/update_query.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n\nupdate(usersListQuery, {\n  on: addUserMutation,\n  by: {\n    success({ mutation, query }) {\n      /* formulate new params there */\n      const newParams = null;\n\n      return {\n        result: [...query.result, mutation.result],\n        refetch: { params: newParams },\n      };\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing @withease/web-api - npm\nDESCRIPTION: This command shows how to install `@withease/web-api` using npm. This library provides web API-based triggers for refreshing data in Farfetched queries.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @withease/web-api\n```\n\n----------------------------------------\n\nTITLE: Triggering a Mutation with useUnit in Solid\nDESCRIPTION: This code snippet demonstrates how to trigger a Farfetched mutation using the `useUnit` hook from `effector-solid` within a Solid.js component. It extracts the `start` function and `pending` state from the mutation. The start function is attached to a button's onClick handler, which triggers the mutation. The button is disabled while the mutation is in progress. This relies on `effector-solid` and `deleteAccountMutation` (presumably a Farfetched mutation).\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/index.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { useUnit } from 'effector-solid';\n\nfunction UserProfile() {\n  const { start: deleteAccount, pending: deletionInProgress } = useUnit(deleteAccountMutation);\n\n  return (\n    <section>\n      //...\n      <button disabled={deletionInProgress()} onClick={deleteAccount}>\n        Delete my account\n      </button>\n    </section>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Defining Request and Answer Interfaces in TypeScript\nDESCRIPTION: This code defines the Request and Answer interfaces and an Effector Effect that are used to define the request handler to be used within generated client code.  The Request interface specifies the structure of the request, and the Answer interface specifies the structure of the response.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_3\n\nLANGUAGE: ts\nCODE:\n```\nexport interface Request {\n  path: string;\n  method: string;\n  body?: object | null | void;\n  query?: Record<string, string>;\n  headers?: Record<string, string>;\n  cookies?: string;\n}\n\nexport interface Answer {\n  ok: boolean;\n  body: unknown;\n  status: number;\n  headers: Record<string, string>;\n}\n\nexport const requestFx = createEffect<Request, Answer, Answer>({\n  handler: async (request) => {\n    // ...\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched SolidJS Integration\nDESCRIPTION: These commands install the `@farfetched/solid` package and its peer dependency `effector-solid` using different package managers (pnpm, yarn, npm).  This integration provides utilities to use Farfetched queries within SolidJS components.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/ui/solid.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install @farfetched/solid effector-solid\n```\n\n----------------------------------------\n\nTITLE: Integrating Farfetched Query with Atomic Router using startChain (TypeScript)\nDESCRIPTION: This code snippet shows how to integrate a Farfetched Query with an Atomic Router route using `startChain`. When the `postRoute` is opened, the `postQuery` will be executed unconditionally. It imports necessary modules from '@farfetched/core', '@farfetched/atomic-router', and 'atomic-router'.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_4\n\nLANGUAGE: ts\nCODE:\n```\nimport { createJsonQuery } from '@farfetched/core';\nimport { startChain } from '@farfetched/atomic-router';\nimport { chainRoute, createRoute } from 'atomic-router';\n\nconst postRoute = createRoute<{ postId: string }>();\n\nconst postQuery = createJsonQuery({\n  /* ... */\n});\n\nconst postLoadedRoute = chainRoute({\n  route: postRoute,\n  ...startChain(postQuery),\n});\n```\n\n----------------------------------------\n\nTITLE: Apply Barrier to Operations Array - TypeScript\nDESCRIPTION: Applies a barrier to an array of Farfetched Queries or Mutations. The operations' execution will be postponed if the barrier is active and resumed when deactivated. Requires importing `applyBarrier` from `@farfetched/core`.  Takes an array of operations and a configuration object containing the barrier as arguments.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/apply_barrier.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { applyBarrier } from '@farfetched/core';\n\napplyBarrier([operation1, operation2], { barrier });\n```\n\n----------------------------------------\n\nTITLE: Updating mapper signature in mapParams\nDESCRIPTION: This snippet illustrates the change in the `mapParams` function's mapper signature. Previously, it accepted two separate arguments: `result` and `params`. Now, it accepts a single object `{ result, params }` to ensure consistency with `.finished.*` Events and Validator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nfunction mapper(\n  result, // [!code --]\n  params, // [!code --]\n  { result, params } // [!code ++]\n) {\n  // ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mapper = {\n  source: $externalStore,\n  fn(\n    result, // [!code --]\n    params, // [!code --]\n    { result, params }, // [!code ++]\n    externalSource\n  ) {\n    // ...\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating from @farfetched/solid (TSX)\nDESCRIPTION: Shows how to migrate from `@farfetched/solid` to `effector-solid` by replacing `useMutation` with `useUnit`. This migration leverages the `@@unitShape` protocol and provides a SolidJS example.  It requires `effector-solid` and assumes `userQuery` and `deleteAccountMutation` are defined elsewhere. Note that `createQueryResource` is still used for Suspense support.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-6.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createQueryResource,\n} from '@farfetched/solid';\nimport { useUnit } from 'effector-react'; // [!code ++]\n\nfunction User() {\n  const [user] = createQueryResource(userQuery);\n\n  const { start: deleteAccount } = useUnit(deleteAccountMutation); // [!code ++]\n\n  return (\n    <Suspense fallback={<p>Loading...</p>}>\n      <div>\n        <p>Name: {user().name}</p>\n        <button onClick={deleteAccount}>Delete my account</button>\n      </div>\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Using onAbort with Fetch API in Farfetched\nDESCRIPTION: This code snippet shows how to use the `onAbort` function with the Fetch API to bind an AbortController to Farfetched's concurrency mechanism. This allows cancelling ongoing fetch requests when the Farfetched operation is cancelled. The `onAbort` function is called before any asynchronous operation is started.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { onAbort, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  async handler() {\n    const abortController = new AbortController();\n\n    onAbort(() => {\n      abortController.abort();\n    });\n\n    const response = await fetch('https://example.com', {\n      signal: abortController.signal,\n    });\n\n    return response.text();\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Creating a Query with a Unique Name\nDESCRIPTION: This snippet shows how to create a Farfetched Query with a unique name. The `name` property is used as a key for identifying the query in the cache. The comment `// ...` indicates that the rest of the query configuration is omitted for brevity.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\nconst characterQuery = createQuery({\n  name: 'character',\n  // ...\n});\n```\n\n----------------------------------------\n\nTITLE: Defining Farfetched Contract\nDESCRIPTION: Defines a contract in TypeScript using Farfetched's `Contract` type. This contract specifies a rule to validate received data, transforming `unknown` input into a specific `Data` type. It exposes methods for checking data type (`isData`) and retrieving error messages (`getErrorMessages`).\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/primitives/contract.md#_snippet_0\n\nLANGUAGE: TypeScript\nCODE:\n```\nconst contract: Contract<unknown, Data>;\n\n// Guards\ncontract.isData; // (raw: unknown) => raw is Data\n\n// Validators\ncontract.getErrorMessages; // (raw: unknown) => string[]\n```\n\n----------------------------------------\n\nTITLE: Copying Queries with attachOperation\nDESCRIPTION: This code snippet uses the `attachOperation` function from `@farfetched/core` to copy the `locationQuery` and create `originQuery` and `currentLocationQuery`.  The `mapParams` function is used to map the original parameters to the `locationUrl` parameter of the base query. This allows reusing the same query logic with different parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/operation_copying.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation } from '@farfetched/core'\n\nconst originQuery = attachOperation(locationQuery, {\n  mapParams: ({ originUrl }) => ({\n    locationUrl: originUrl\n  }),\n});\n\nconst currentLocationQuery = attachOperation(locationQuery, {\n  mapParams: ({ currentLocationUrl }) => ({\n    locationUrl: currentLocationUrl\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting Multiple Parents to Query\nDESCRIPTION: This snippet shows how to connect multiple source queries to a single target query. The `characterQuery` and `languageQuery` are combined, and their results are used to determine the parameters for the `originQuery`. The `fn` receives the results of both parent queries and returns the parameters for the child query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/dependent_queries.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nconnectQuery({\n  source: { character: characterQuery, language: languageQuery },\n  fn({ character, language }) {\n    return {\n      params: {\n        originUrl: character.result.origin.url,\n        language: language.result,\n      },\n    };\n  },\n  target: originQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Using createFactory for SSR\nDESCRIPTION: This snippet shows how to use `@withease/factories` to create a factory function for SSR when replacing `attachOperation`. It emphasizes the benefit of using factories in server-side rendering scenarios.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/attach_operation_deprecation.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createFactory } from '@withease/factories'; // [!code ++]\n\nconst createOriginalQuery = createFactory(() => { // [!code ++]\nfunction createOriginalQuery() { // [!code --]\n  return createQuery(/*...*/);\n});\n```\n\n----------------------------------------\n\nTITLE: Updating Query with Mutation result\nDESCRIPTION: This code snippet demonstrates how to use the `update` operator to update a Query's state based on the result of a Mutation. It imports the `update` function from `@farfetched/core` and defines an update configuration object. The configuration specifies which mutation should trigger the update and how the new state should be derived from the old state and mutation parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-5.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { update } from '@farfetched/core';\n\nupdate(postQuery, {\n  on: editPostTitleMutation,\n  by: {\n    success(state) {\n      const oldPost = state.query.result;\n      const editions = state.mutation.params;\n\n      return {\n        result: { ...oldPost, title: editions.title },\n        refetch: true,\n      };\n    },\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Make Adapter Replaceable Function\nDESCRIPTION: This snippet shows the `makeAdapterRepalcable` function which adds a `.__.$instance` property to an adapter, making it replacable via Effector's Fork API. It wraps the adapter in a store, allowing it to be replaced during testing or SSR.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/cache.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\n// internal function in Farfetched's sources\nfunction makeAdapterRepalcable(adapter) {\n  return {\n    ...adapter,\n    __: {\n      $instance: createStore(adapter),\n    },\n  };\n}\n```\n\n----------------------------------------\n\nTITLE: Disabling HMR in vite.config.ts\nDESCRIPTION: Disables Hot Module Replacement (HMR) in the Vite configuration. This is done to prevent unexpected behavior due to Effector's lack of HMR support.  The `hmr` option is set to `false` in the `server` configuration.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.ts\nexport default defineConfig({\n  server: {\n    hmr: false,\n  },\n});\n```\n\n----------------------------------------\n\nTITLE: Using the Farfetched Query (TypeScript)\nDESCRIPTION: This TypeScript code demonstrates how to use the Farfetched Query created from the generated code. It shows how to apply operators like retry to the query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_9\n\nLANGUAGE: ts\nCODE:\n```\nimport { retry } from '@farfetched/core';\n\nimport { petsQuery } from './api/shared';\n\nretry(petsQuery, {\n  times: 3,\n  delay: 1000,\n});\n```\n\n----------------------------------------\n\nTITLE: Filtering TimeoutError in Farfetched (TypeScript)\nDESCRIPTION: This code snippet demonstrates how to use the `isTimeoutError` error guard from `@farfetched/core` to filter for `TimeoutError` instances within a reactive stream of query failures.  It leverages Effector's `sample` function, extracting only those failures classified as `TimeoutError`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_guards.md#_snippet_1\n\nLANGUAGE: TypeScript\nCODE:\n```\nimport { isTimeoutError } from '@farfetched/core';\n\nconst timedOut = sample({\n  clock: query.finished.failure,\n  filter: isTimeoutError,\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Patronum - npm\nDESCRIPTION: This command shows how to install `patronum` using npm. This library provides utilities for Effector, including an `interval` method for creating triggers based on time intervals.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_9\n\nLANGUAGE: sh\nCODE:\n```\nnpm install patronum\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/solid\nDESCRIPTION: Installation of the @farfetched/solid package using pnpm, yarn, and npm. This package provides integration between Farfetched and Solid.js.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/suspense.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @farfetched/solid\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Unset Effect\nDESCRIPTION: This effect removes a value from the Redis cache based on the provided key.  It uses the `redis.del(key)` method to delete the key-value pair associated with the given key.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_6\n\nLANGUAGE: typescript\nCODE:\n```\nimport Redis from 'ioredis';\n\nfunction redisCache({ maxAge }) {\n  const redis = new Redis();\n\n  return createCacheAdapter({\n    get,\n    set,\n    unset: createEffect(async ({ key }) => {\n      await redis.del(key);\n    }),\n    purge,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Feature Flag Store with Effector\nDESCRIPTION: This snippet initializes an Effector store for a dynamic favicon feature flag, setting the default value to `false`. This indicates that the feature is initially disabled. The `$dynamicFaviconEnabled` store will hold the current state of the feature flag.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/feature_flags.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'effector';\n\nconst $dynamicFaviconEnabled = createStore(false);\n```\n\n----------------------------------------\n\nTITLE: Attaching Operation with External Store (TypeScript)\nDESCRIPTION: Demonstrates how to use `attachOperation` to create a new query based on an existing query and an external store.  The `mapParams` function transforms the external store's value and the original query's parameters into a new parameter for the attached query.  This example requires `effector` and `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-6.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'effector';\nimport { attachOperation, createQuery } from '@farfetched/core';\n\nconst $externalStore = createStore(12);\n\nconst originalQuery = createQuery({\n  handler: async (params: string) => 'some data',\n});\n\nconst attachedQuery = attachOperation(originalQuery, {\n  source: $externalStore,\n  mapParams: (params: number, externalSource) => (params + externalSource).toString(),\n});\n```\n\n----------------------------------------\n\nTITLE: Caching a Query with Farfetched in TypeScript\nDESCRIPTION: This code snippet demonstrates how to use the `cache` operator from `@farfetched/core` to cache a Query. The `languageQuery` fetches data from an API endpoint and the `cache(languageQuery)` line enables caching for that Query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-3.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { cache, createQuery } from '@farfetched/core';\n\nconst languageQuery = createQuery({\n  handler: async () => {\n    const res = await fetch('/api/language');\n\n    return res.json();\n  },\n});\n\ncache(languageQuery);\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/solid\nDESCRIPTION: Installation of the @farfetched/solid package using pnpm, yarn, and npm. This package provides integration between Farfetched and Solid.js.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/solid/suspense.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @farfetched/solid\n```\n\n----------------------------------------\n\nTITLE: Attaching Cache Observability\nDESCRIPTION: Illustrates how to use `attachObservability` to enhance a custom cache adapter with observability events. `attachObservability` connects adapter events (`itemEvicted`, `itemExpired`) to user-defined events (`hit`, `miss`, `expired`, `evicted`), enabling custom monitoring and logging of cache interactions.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/cache.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createEvent } from 'effector';\nimport { attachObservability } from '@farfetched/core';\n\nfunction myCustomAdapter({\n  observability,\n}: {\n  observability: {\n    hit?: Event<{ key: string }>;\n    miss?: Event<{ key: string }>;\n    expired?: Event<{ key: string }>;\n    evicted?: Event<{ key: string }>;\n  };\n}) {\n  const adapter = createCacheAdapter({\n    // ...\n  });\n\n  const itemEvicted = createEvent<{ key: string }>();\n  const itemExpired = createEvent<{ key: string }>();\n\n  attachCacheObservability({\n    adapter,\n    options: observability,\n    events: { itemEvicted, itemExpired },\n  });\n\n  return adapter;\n}\n```\n\n----------------------------------------\n\nTITLE: Installing Effector React Bindings with pnpm\nDESCRIPTION: This command installs the `effector-react` package, which provides React bindings for Effector, enabling the use of Effector stores and effects in React components. This is a prerequisite for integrating Farfetched with React. The package manager used is pnpm.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/react/index.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install effector-react\n```\n\n----------------------------------------\n\nTITLE: Using localStorageCache with maxEntries option\nDESCRIPTION: This snippet shows how to use `localStorageCache` with the `maxEntries` option to limit the number of entries in the cache. When the cache reaches the maximum number of entries, the oldest entry is deleted. Dependencies include `@farfetched/core`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/caching.md#_snippet_2\n\nLANGUAGE: ts\nCODE:\n```\nimport { cache, localStorageCache } from '@farfetched/core';\n\ncache(characterQuery, {\n  adapter: localStorageCache({ maxEntries: 100 }),\n});\n```\n\n----------------------------------------\n\nTITLE: Adding parameters from external source\nDESCRIPTION: This snippet shows how to include parameters from an external Effector store when copying a query using `attachOperation`. The `source` field is used to specify the store, and the `mapParams` function receives the value of the store as a second argument, allowing it to be used in constructing the parameters for the copied query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/operation_copying.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createStore } from 'effector';\nimport { attachOperation } from '@farfetched/core';\n\nconst $someExtarnalSource = createStore({});\n\nconst currentLocationQuery = attachOperation(locationQuery, {\n  source: $someExtarnalSource,\n  mapParams: ({ currentLocationUrl }, valueOfExternalSource) => ({\n    locationUrl: currentLocationUrl,\n  }),\n});\n```\n\n----------------------------------------\n\nTITLE: Removing `refetch` from `@farfetched/solid`\nDESCRIPTION: This code snippet illustrates the removal of the `refetch` method and the introduction of the `start` method in `@farfetched/solid` when using `createQueryResource`. The `refetch` method is being deprecated in favor of `start` for triggering query execution.  The purpose is to align with the intended API usage within the Farfetched library. This change requires updating existing code to use `start` instead of `refetch` to initiate a query.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-7.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createQueryResource } from '@farfetched/solid';\n\nfunction User() {\n  const [\n    user,\n    {\n      refetch, // [!code --]\n      start, // [!code ++]\n    },\n  ] = createQueryResource(userQuery);\n\n  return (\n    <div>\n      <button onClick={refetch}>Start query</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Watching Query Data with a Store in Typescript\nDESCRIPTION: This example demonstrates how to subscribe to the data store of a Farfetched Query using the `watch` method. This allows you to reactively update the UI or perform other actions whenever the query's data changes. Note that this is a basic example, and Farfetched provides better integrations.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/basic_query.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\ncharacterQuery.$data.watch((data) => {\n  // render some UI based on data\n});\n```\n\n----------------------------------------\n\nTITLE: Initializing createBarrier with activateOn and deactivateOn events\nDESCRIPTION: Creates a barrier that activates and deactivates based on specified events. The barrier activates when `userOpenedModal` is triggered and deactivates when `userClosedModal` is triggered. No explicit performer defined in this case.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/factories/create_barrier.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createBarrier } from '@farfetched/core';\n\nconst authBarrier = createBarrier({\n  activateOn: userOpenedModal,\n  deactivateOn: userClosedModal,\n});\n```\n\n----------------------------------------\n\nTITLE: Connecting Queries without Parameters (TypeScript)\nDESCRIPTION: Demonstrates connecting two source Queries (`languagesQuery` and `blocksQuery`) to a target Query (`contentQuery`) without passing any parameters.  The `connectQuery` function establishes a static connection, triggering `contentQuery` upon successful completion of both `languagesQuery` and `blocksQuery`. No data is passed directly; the target Query is started without parameters.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/connect_query.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nconst languagesQuery: Query<unknown, unknown, unknown>;\nconst blocksQuery: Query<unknown, unknown, unknown>;\n\nconst contentQuery: Query<void, unknown, unknown>;\n\nconnectQuery({\n  source: { language: languagesQuery, blocks: blocksQuery },\n  target: contentQuery,\n});\n```\n\n----------------------------------------\n\nTITLE: Migrate from `refetch` to `start` in @farfetched/solid\nDESCRIPTION: This snippet demonstrates how to replace the deprecated `refetch` function with the `start` function in `@farfetched/solid` when using `createQueryResource`. This change is necessary to align with the updates in v0.8 and maintain compatibility. The code shows the original use of `refetch` and the corrected use of `start`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-8.md#_snippet_0\n\nLANGUAGE: tsx\nCODE:\n```\nimport { createQueryResource } from '@farfetched/solid';\n\nfunction User() {\n  const [\n    user,\n    {\n      refetch, // [!code --]\n      start, // [!code ++]\n    },\n  ] = createQueryResource(userQuery);\n\n  return (\n    <div>\n      <button onClick={refetch}>Start query</button>\n    </div>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Migrating from Configuration to Operator: Abort Event in Typescript\nDESCRIPTION: This code demonstrates how to migrate the `abort` event configuration from the `createJsonQuery` factory to the `concurrency` operator, renaming `abort` to `abortAll`. It shows the deprecated method of passing the abort event within the factory and the updated method using the `concurrency` operator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/concurrency.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery, concurrency } from '@farfetched/core';\nimport { createEvent } from 'effector';\n\nconst abortQuery = createEvent();\n\nconst query = createJsonQuery({\n  concurrency: { abort: abortQuery }, // [!code --]\n});\n\nconcurrency(query, { abortAll: abortQuery }); // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Creating a New Effector Scope (TypeScript)\nDESCRIPTION: This snippet demonstrates how to create a new isolated Effector scope using the `fork` function. Scopes are used for SSR and testing purposes to isolate application state.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/testing.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst scope = fork();\n```\n\n----------------------------------------\n\nTITLE: Setting up effector/babel-plugin in .babelrc\nDESCRIPTION: Configures Babel to use the `effector/babel-plugin`. This plugin is necessary for using advanced Farfetched features with Effector. It is added to the plugins array in the Babel configuration.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_4\n\nLANGUAGE: json\nCODE:\n```\n// .babelrc\n{\n  \"plugins\": [\"effector/babel-plugin\"]\n}\n```\n\n----------------------------------------\n\nTITLE: Initializing Redis Connection Store - Typescript\nDESCRIPTION: Creates an Effector store to hold the Redis connection string.  It then maps this store to a Redis client instance using `ioredis`. The store allows dynamic updates to the Redis connection at runtime. The Redis client is initialized with the connection string from the store.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_10\n\nLANGUAGE: typescript\nCODE:\n```\nimport Redis from 'ioreis';\nimport { attach } from 'effector';\n\nconst $redisConnection = createStore<string | null>(null);\nconst $redis = $redisConnection.map((connection) => new Redis(connection));\n```\n\n----------------------------------------\n\nTITLE: Attaching Query with attachOperation in Typescript\nDESCRIPTION: Creates a new Query on top of an existing one using `attachOperation`. This example showcases the basic usage of `attachOperation` with a simple Query created using `createQuery`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/attach_operation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation, createQuery } from '@farfetched/core';\n\nconst originalQuery = createQuery({ handler: async () => 'some data' });\nconst attachedQuery = attachOperation(originalQuery);\n```\n\n----------------------------------------\n\nTITLE: Initializing GraphQL Query Factory - JavaScript\nDESCRIPTION: This snippet initializes a function that will serve as the factory for creating GraphQL queries. It uses `createJsonQuery` internally and returns a query object. The function currently lacks implementation details, which are filled in subsequent steps.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/graphql_query.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createGraphQLQuery(config) {\n  const query = createJsonQuery({\n    // ???\n  });\n\n  return query;\n}\n```\n\n----------------------------------------\n\nTITLE: Instantiating Mutations from the Factory\nDESCRIPTION: This code demonstrates how to instantiate multiple file upload mutations using the `createUploadFileMutation` factory function. Each mutation instance is specific to a particular file upload scenario (e.g., avatar or photo).  Each instance can be used independently.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/form_data.md#_snippet_7\n\nLANGUAGE: javascript\nCODE:\n```\nconst uploadAvatarMutation = createUploadFileMutation();\nconst uploadPhotoMutation = createUploadFileMutation();\n/* ... */\n```\n\n----------------------------------------\n\nTITLE: Using attachOperation with Mutations\nDESCRIPTION: This code snippet demonstrates how to use `attachOperation` with Mutations. A base mutation is created, and then a new mutation is created by attaching it to the base mutation.  This allows for creating variations of a mutation with different configurations.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/operation_copying.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { attachOperation } from '@farfetched/core';\n\nconst baseMutation = createMutation(/* ... */);\nconst newMutation = attachOperation(baseMutation);\n```\n\n----------------------------------------\n\nTITLE: TAKE_EVERY concurrency strategy in Farfetched\nDESCRIPTION: This code snippet demonstrates the `TAKE_EVERY` concurrency strategy, where every operation call is executed immediately, regardless of existing in-flight operations. This is the default strategy in Farfetched.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  /* ... */\n});\n\nconcurrency(query, { strategy: 'TAKE_EVERY' });\n```\n\n----------------------------------------\n\nTITLE: Transforming Configuration for GraphQL Query - JavaScript\nDESCRIPTION: This snippet demonstrates how to transform the configuration object for a GraphQL query factory. It focuses on overriding the `request` object to include the `method` as 'POST', clearing the `query` field, and preparing the `body` field for further customization.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/graphql_query.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nfunction createGraphQLQuery(config) {\n  const query = createJsonQuery({\n    ...config,\n    request: {\n      ...config.request,\n      method: 'POST',\n      query: {},\n      body: /* ??? */,\n    },\n  });\n\n  return query;\n}\n```\n\n----------------------------------------\n\nTITLE: Adding vite-plugin-babel to vite.config.ts\nDESCRIPTION: Configures Vite to use `vite-plugin-babel`. It imports the necessary modules and adds the babel plugin to the plugins array in the Vite configuration. This allows Babel to process the code.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.ts\nimport { defineConfig } from 'vite';\nimport babel from 'vite-plugin-babel';\n\nexport default defineConfig({\n  plugins: [\n    // Babel will try to pick up Babel config files (.babelrc or .babelrc.json)\n    babel(),\n    // ...\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Migrating from Configuration to Operator: Strategy in Typescript\nDESCRIPTION: This code snippet illustrates how to migrate concurrency strategy configuration from the `createJsonQuery` factory to the `concurrency` operator.  It shows the deprecated way of setting the strategy within the factory's `concurrency` field and the new recommended way using the `concurrency` operator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/concurrency.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { createJsonQuery, concurrency } from '@farfetched/core';\n\nconst query = createJsonQuery({\n  concurrency: { strategy: 'TAKE_LATEST' }, // [!code --]\n});\n\nconcurrency(query, { strategy: 'TAKE_LATEST' }); // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: OpenAPI Configuration File in JavaScript\nDESCRIPTION: This JavaScript code defines the configuration for the OpenAPI Generator. It specifies the OpenAPI specification file, output directory, and the Effector preset to use for code generation.  The configuration points to a petstore example OpenAPI specification and places the generated code within the ./src/api/shared directory.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_4\n\nLANGUAGE: js\nCODE:\n```\nmodule.exports = {\n  file: 'https://raw.githubusercontent.com/OAI/OpenAPI-Specification/main/examples/v2.0/json/petstore-minimal.json',\n  outputDir: './src/api/shared',\n  presets: [\n    [\n      'openapi-preset-effector',\n      {\n        effectorImport: 'effector',\n        requestName: 'fetchFx',\n        requestPath: './request',\n      },\n    ],\n  ],\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Runtypes and Farfetched\nDESCRIPTION: Install Runtypes and @farfetched/runtypes using pnpm, yarn, or npm. This package enables integration between Farfetched and Runtypes for data validation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/runtypes.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install runtypes @farfetched/runtypes\n```\n\n----------------------------------------\n\nTITLE: Configuring @vitejs/plugin-react with effector/babel-plugin\nDESCRIPTION: Configures `@vitejs/plugin-react` to use the `effector/babel-plugin`. This config is an alternative to adding `vite-plugin-babel` when using `@vitejs/plugin-react`, which bundles babel already. The plugin is added to the `babel.plugins` array within the React plugin configuration.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\n// vite.config.js\nimport { defineConfig } from 'vite';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [\n    react({\n      babel: {\n        plugins: ['effector/babel-plugin'],\n      },\n    }),\n  ],\n});\n```\n\n----------------------------------------\n\nTITLE: Rendering Sections and Subsections in Vue.js\nDESCRIPTION: This code snippet uses Vue.js directives to iterate through a data structure named 'sections' and dynamically renders sections, subsections, and links.  It uses v-for to loop through sections and subsections, and v-if to conditionally render subsections based on the result of the hasSubsections function. It also provides links to API documentation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/index.md#_snippet_1\n\nLANGUAGE: vue\nCODE:\n```\n<div v-for=\"section in sections\">\n    <h2>{{section.text}}</h2>\n    <div v-if=\"hasSubsections(section)\">\n        <div v-for=\"subsection in section.items\">\n            <h3>{{subsection.text}}</h3>\n            <ul>\n                <li v-for=\"item in subsection.items\">\n                    <a v-if=\"item.link\" :href=\"item.link\">{{item.text}}</a>\n                </li>\n            </ul>\n        </div>\n    </div>\n    <ul v-else>\n        <li v-for=\"item in section.items\">\n            <a :href=\"item.link\">{{item.text}}</a>\n        </li>\n    </ul>\n\n</div>\n```\n\n----------------------------------------\n\nTITLE: Connecting Query to Multiple Children\nDESCRIPTION: This snippet demonstrates how to connect a single source query to multiple target queries using an array.  Both `originQuery` and `originDetailsQuery` will be executed after `characterQuery` completes successfully, using the same parameters derived from `characterQuery`'s result.  The parameters for the children must be the same.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/dependent_queries.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nconnectQuery({\n  source: characterQuery,\n  fn({ result: character }) {\n    return { params: { originUrl: character.origin.url } };\n  },\n  target: [originQuery, originDetailsQuery],\n});\n```\n\n----------------------------------------\n\nTITLE: Installing Valibot and Farfetched/Valibot\nDESCRIPTION: Installation instructions for Valibot and the @farfetched/valibot integration package using pnpm, yarn, and npm. This allows the usage of Valibot schemas for data validation within Farfetched.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/valibot.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install valibot @farfetched/valibot\n```\n\n----------------------------------------\n\nTITLE: Updating mapData function signature\nDESCRIPTION: This code snippet illustrates the change in the `mapData` function's signature. Previously, it accepted two separate arguments: `result` and `params`. Now, it accepts a single object `{ result, params }` to ensure consistency with `.finished.*` Events and Validator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nfunction mapper(\n  {\n    error,\n    params,\n    meta, // [!code ++]\n  },\n  meta // [!code --]\n) {\n  // ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mapper = {\n  source: $externalStore,\n  fn(\n    {\n      error,\n      params,\n      meta, // [!code ++]\n    },\n    meta, // [!code --]\n    externalSource\n  ) {\n    // ...\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Migrating from @farfetched/solid useMutation to effector-solid useUnit\nDESCRIPTION: This code shows how to migrate from `@farfetched/solid`'s `useMutation` to `effector-solid`'s `useUnit`. The `useMutation` function from `@farfetched/solid` is deprecated. This example showcases the required changes in import statements and function calls to align with the new approach using `useUnit` from `effector-solid`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-5.md#_snippet_2\n\nLANGUAGE: tsx\nCODE:\n```\nimport {\n  createQueryResource,\n  useMutation, // [!code --]\n} from '@farfetched/solid';\nimport { useUnit } from 'effector-react'; // [!code ++]\n\nfunction User() {\n  const [user] = createQueryResource(userQuery);\n\n  const { start: deleteAccount } = useMutation(deleteAccountMutation); // [!code --]\n  const { start: deleteAccount } = useUnit(deleteAccountMutation); // [!code ++]\n\n  return (\n    <Suspense fallback={<p>Loading...</p>}>\n      <div>\n        <p>Name: {user().name}</p>\n        <button onClick={deleteAccount}>Delete my account</button>\n      </div>\n    </Suspense>\n  );\n}\n```\n\n----------------------------------------\n\nTITLE: Updating .finished.success payload\nDESCRIPTION: This snippet showcases the change in the `.finished.success` event's payload structure. The payload now contains `{ result: Data, params: Params }` instead of `{ data: Data, params: Params }`, aligning it with the structure of `.done` in Effector's Effect.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\nquery.finished.success.watch(\n  ({\n    data, // [!code --]\n    result, // [!code ++]\n  }) => {\n    // ...\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Valibot and Farfetched/Valibot\nDESCRIPTION: Installation instructions for Valibot and the @farfetched/valibot integration package using pnpm, yarn, and npm. This allows the usage of Valibot schemas for data validation within Farfetched.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/valibot.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add valibot @farfetched/valibot\n```\n\n----------------------------------------\n\nTITLE: Installing vite-plugin-babel with yarn\nDESCRIPTION: Installs the `vite-plugin-babel` package as a development dependency using yarn. This plugin is required for using Babel to transform code within a Vite project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add --dev vite-plugin-babel\n```\n\n----------------------------------------\n\nTITLE: Installing Valibot and Farfetched/Valibot\nDESCRIPTION: Installation instructions for Valibot and the @farfetched/valibot integration package using pnpm, yarn, and npm. This allows the usage of Valibot schemas for data validation within Farfetched.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/valibot.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install valibot @farfetched/valibot\n```\n\n----------------------------------------\n\nTITLE: Vue.js Template for ADR Rendering\nDESCRIPTION: This Vue.js template iterates through the `docsByVersion` data, which is assumed to be an array of key-value pairs where the key is the release version and the value is an array of ADR items. It renders a heading for each release and a list of links to each ADR. The template uses `v-for` directives to generate the list items and dynamically sets the `href` attribute of the links based on the `item.url` property.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/index.md#_snippet_1\n\nLANGUAGE: Vue.js\nCODE:\n```\n<div v-for=\"[release, items] in docsByVersion\">\n  <a v-if=\"release.link\" :href=\"release.link\"><h2>{{ release.text }}</h2></a>\n  <h2 v-else>{{ release.text }}</h2>\n  <ul>\n    <li v-for=\"item in items\">\n        <a :href=\"item.url\">{{ item.frontmatter.title }}</a>\n    </li>\n  </ul>\n</div>\n```\n\n----------------------------------------\n\nTITLE: Install OpenAPI Generator and Effector Preset (npm)\nDESCRIPTION: This command installs the OpenAPI Generator, the Effector preset, and typed-contracts using npm. These are required for generating Effector code from OpenAPI specifications.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --dev openapi@^1.0.0 openapi-preset-effector typed-contracts\n```\n\n----------------------------------------\n\nTITLE: Installing @withease/web-api - pnpm\nDESCRIPTION: This command shows how to install `@withease/web-api` using pnpm. This library provides web API-based triggers for refreshing data in Farfetched queries.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_3\n\nLANGUAGE: sh\nCODE:\n```\npnpm install @withease/web-api\n```\n\n----------------------------------------\n\nTITLE: Installing vite-plugin-babel with npm\nDESCRIPTION: Installs the `vite-plugin-babel` package as a development dependency using npm. This plugin is required for using Babel to transform code within a Vite project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install --dev vite-plugin-babel\n```\n\n----------------------------------------\n\nTITLE: Importing Data and Defining a Helper Function in Vue\nDESCRIPTION: This code snippet imports a data object named 'sections' from './apis.data' and defines a function 'hasSubsections' that checks if all items in a section do not have a link. This function is used to determine how the data will be rendered in the template.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n    import { data as sections } from './apis.data'\n\n    function hasSubsections(section) {\n        return section.items.every(item => !item.link)\n    }\n```\n\n----------------------------------------\n\nTITLE: Query State type definition\nDESCRIPTION: Defines the structure of the `QueryState` type. It can be null, a successful result with data and params, or an error state with error details and params. The `QueryResult` and `QueryParams` types are assumed to be defined elsewhere.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/operators/update.md#_snippet_2\n\nLANGUAGE: typescript\nCODE:\n```\ntype QueryState =\n  | null\n  | {\n      result: QueryResult;\n      params: QueryParams;\n    }\n  | {\n      error: QueryError;\n      params: QueryParams;\n    };\n```\n\n----------------------------------------\n\nTITLE: Updating mapper signature in mapData\nDESCRIPTION: This code snippet illustrates the change in the `mapData` function's mapper signature. Previously, it accepted two separate arguments: `result` and `params`. Now, it accepts a single object `{ result, params }` to ensure consistency with `.finished.*` Events and Validator.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nfunction mapper(\n  result, // [!code --]\n  params, // [!code --]\n  { result, params } // [!code ++]\n) {\n  // ...\n}\n```\n\nLANGUAGE: typescript\nCODE:\n```\nconst mapper = {\n  source: $externalStore,\n  fn(\n    result, // [!code --]\n    params, // [!code --]\n    { result, params }, // [!code ++]\n    externalSource\n  ) {\n    // ...\n  },\n};\n```\n\n----------------------------------------\n\nTITLE: Installing atomic-router and @farfetched/atomic-router via npm\nDESCRIPTION: This command installs the atomic-router and @farfetched/atomic-router packages using npm. These packages are required for integrating Farfetched with Atomic Router.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install atomic-router @farfetched/atomic-router\n```\n\n----------------------------------------\n\nTITLE: Installing Patronum - yarn\nDESCRIPTION: This command shows how to install `patronum` using yarn. This library provides utilities for Effector, including an `interval` method for creating triggers based on time intervals.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/trigger_api.md#_snippet_8\n\nLANGUAGE: sh\nCODE:\n```\nyarn add patronum\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Get Effect\nDESCRIPTION: This effect retrieves a value from the Redis cache based on the provided key. It fetches the stringified object from Redis, parses it, and returns an object containing the `value` and `cachedAt` properties. If the key doesn't exist, it returns `null`.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport Redis from 'ioreis';\n\nfunction redisCache({ maxAge }) {\n  const redis = new Redis();\n\n  return createCacheAdapter({\n    get: createEffect(async ({ key }) => {\n      // NOTE: we store stringified object with {value, cachedAt} in the Redis\n      const valueFromCache = await redis.get(key);\n      if (!valueFromCache) {\n        return null;\n      }\n      return JSON.parse(valueFromCache);\n    }),\n    set,\n    unset,\n    purge,\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Updating retry function signature\nDESCRIPTION: This snippet demonstrates how to update the `retry` function call from the old `retry(config)` signature to the new `retry(operation, config)` signature to support retrying both Queries and Mutations. The old signature is being deprecated.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-4.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nretry(\n  someQuery, // [!code ++]\n  {\n    query: someQuery, // [!code --]\n    times: 3,\n    delay: 1000,\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Redis Cache Purge Effect\nDESCRIPTION: This effect removes all values from the Redis cache. It uses the `redis.flushall()` method to clear the entire Redis database.  Note: In a production environment, consider the impact of `flushall` on other applications using the same Redis instance.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/server_cache.md#_snippet_7\n\nLANGUAGE: typescript\nCODE:\n```\nimport Redis from 'ioredis';\n\nfunction redisCache({ maxAge }) {\n  const redis = new Redis();\n\n  return createCacheAdapter({\n    get,\n    set,\n    unset,\n    purge: createEffect(async () => {\n      await redis.flushall()\n    }),\n  });\n}\n```\n\n----------------------------------------\n\nTITLE: Installing atomic-router and @farfetched/atomic-router via yarn\nDESCRIPTION: This command installs the atomic-router and @farfetched/atomic-router packages using yarn. These packages are required for integrating Farfetched with Atomic Router.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/routers/atomic-router.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add atomic-router @farfetched/atomic-router\n```\n\n----------------------------------------\n\nTITLE: Replacing attachOperation with function - no params\nDESCRIPTION: This snippet demonstrates how to replace `attachOperation` with a plain JavaScript function when creating a copy of a Query without any modifications. It highlights the increased clarity and explicitness of the plain JS approach.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/adr/attach_operation_deprecation.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\n/* [!code ++:3] */ function createOriginalQuery() {\n  return createQuery(/*...*/);\n}\n\nconst originalQuery = createQuery(/*...*/); // [!code --]\nconst originalQuery = createOriginalQuery(); // [!code ++]\n\nconst copiedQuery = attachOperation(originalQuery); // [!code --]\nconst copiedQuery = createOriginalQuery(); // [!code ++]\n```\n\n----------------------------------------\n\nTITLE: Attaching Farfetched DevTools\nDESCRIPTION: This TypeScript code snippet conditionally imports and attaches Farfetched DevTools when the application is running in a development environment.  It dynamically imports `attachFarfetchedDevTools` and then executes it to enable the DevTools.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/devtools.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\n// main.ts\n\nif (process.env.NODE_ENV === 'development') {\n  const { attachFarfetchedDevTools } = await import('@farfetched/dev-tools');\n\n  attachFarfetchedDevTools();\n}\n```\n\n----------------------------------------\n\nTITLE: Normalized Sourced Implementation\nDESCRIPTION: This code demonstrates the internal `normalizedSourced` function used by Farfetched to transform sourced fields into simple stores. It utilizes `createStore` and `sample` from Effector to derive a new store from an existing store with a given transformation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/cache.md#_snippet_1\n\nLANGUAGE: ts\nCODE:\n```\n// internal function in Farfetched's sources\nfunction normalizedSourced($store, start, transform) {\n  const $result = createStore(null);\n  sample({\n    clock: start,\n    source: $store,\n    fn: (store, params) => transform(params, store),\n    target: $result,\n  });\n  return $result;\n}\n\n// this transformation applied to the field `url` to get the final value\nconst $url = normalizedSourced(combine({ language: $language, region: $region }), query.start, (_params, { language, region }) => (region === 'us' ? `https://us-west.salo.com/${language}/location` : `https://eu-cent.salo.com/${language}/location`));\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched SolidJS Integration\nDESCRIPTION: These commands install the `@farfetched/solid` package and its peer dependency `effector-solid` using different package managers (pnpm, yarn, npm). This integration provides utilities to use Farfetched queries within SolidJS components.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/ui/solid.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install @farfetched/solid effector-solid\n```\n\n----------------------------------------\n\nTITLE: Throwing InvalidDataError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw an `invalidDataError` in a Farfetched query test.  It imports the `invalidDataError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `validationErrors` and `response` parameters are used to create the error object. The test then asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_0\n\nLANGUAGE: typescript\nCODE:\n```\nimport { invalidDataError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw invalidDataError({\n            validationErrors: ['Test error'],\n            response: {},\n          });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Vue Component Setup\nDESCRIPTION: This snippet imports necessary components from 'vitepress/theme' and contributor data from './contributors.data' for use in a Vue component. It sets up a team page with a title and displays the contributors.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\nimport {\n  VPTeamPage,\n  VPTeamPageTitle,\n  VPTeamMembers,\n  VPTeamPageSection\n} from 'vitepress/theme'\n\nimport { data as contributors} from './contributors.data';\n</script>\n\n<VPTeamPage>\n  <VPTeamPageTitle>\n    <template #title>Contributors</template>\n  </VPTeamPageTitle>\n  <VPTeamMembers size=\"small\" :members=\"contributors\" />\n</VPTeamPage>\n```\n\n----------------------------------------\n\nTITLE: Validator Function with External Source\nDESCRIPTION: Defines a validator as an object with a `source` field (an Effector Store) and an `fn` field (a function). The function accepts an object containing the result, parameters, and the value of the external source. It returns a ValidationResult, validating data based on both the result and the external source's value.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/primitives/validator.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nconst validator = {\n  source: $externalStore,\n  fn: ({ result, params }, externalSource): ValidationResult => result[params.id] !== null && result[externalSource.id] !== null,\n};\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched SolidJS Integration\nDESCRIPTION: These commands install the `@farfetched/solid` package and its peer dependency `effector-solid` using different package managers (pnpm, yarn, npm). This integration provides utilities to use Farfetched queries within SolidJS components.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/ui/solid.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @farfetched/solid effector-solid\n```\n\n----------------------------------------\n\nTITLE: Running OpenAPI Code Generation (pnpm)\nDESCRIPTION: This command runs the OpenAPI Generator using pnpm to generate code based on the configuration file.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_5\n\nLANGUAGE: sh\nCODE:\n```\npnpm openapi\n```\n\n----------------------------------------\n\nTITLE: Installing vite-plugin-babel with pnpm\nDESCRIPTION: Installs the `vite-plugin-babel` package as a development dependency using pnpm. This plugin is required for using Babel to transform code within a Vite project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/vite.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add --save-dev vite-plugin-babel\n```\n\n----------------------------------------\n\nTITLE: Running OpenAPI Code Generation (yarn)\nDESCRIPTION: This command runs the OpenAPI Generator using yarn to generate code based on the configuration file.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_6\n\nLANGUAGE: sh\nCODE:\n```\nyarn openapi\n```\n\n----------------------------------------\n\nTITLE: Installing Superstruct and Farfetched Integration\nDESCRIPTION: These commands install the `superstruct` and `@farfetched/superstruct` packages using different package managers. The commands showcase installation using pnpm, yarn, and npm.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/superstruct.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install superstruct @farfetched/superstruct\n```\n\nLANGUAGE: shell\nCODE:\n```\nyarn add superstruct @farfetched/superstruct\n```\n\nLANGUAGE: shell\nCODE:\n```\nnpm install superstruct @farfetched/superstruct\n```\n\n----------------------------------------\n\nTITLE: Installing @farfetched/json-schema with Yarn\nDESCRIPTION: Installs the @farfetched/json-schema package and its dependencies using the Yarn package manager.  This package is required for integrating Farfetched with JSON Schema.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/json-schema.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add @farfetched/json-schema\n```\n\n----------------------------------------\n\nTITLE: Importing data for recipes in Vue\nDESCRIPTION: This code snippet imports a JSON data file containing recipes information within a Vue component. The `data` object, aliased as `sections`, holds the structured data to be rendered in the template.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\nimport { data as sections } from './recipes.data'\n```\n\n----------------------------------------\n\nTITLE: Throwing HttpError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw an `httpError` in a Farfetched query test. It imports the `httpError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `status`, `statusText`, and `response` parameters represent the HTTP status code, status text, and response body, respectively. The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_4\n\nLANGUAGE: typescript\nCODE:\n```\nimport { httpError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw httpError({\n            status: 429,\n            statusText: 'I am teapot',\n            response: null,\n          });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: Installing io-ts Farfetched Integration\nDESCRIPTION: These commands install the `io-ts`, `fp-ts`, and `@farfetched/io-ts` packages using different package managers (pnpm, yarn, npm).  These are peer dependencies required for using io-ts with Farfetched for data validation. Each command uses the corresponding package manager's `install` or `add` command.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/io-ts.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install io-ts fp-ts @farfetched/io-ts\n```\n\nLANGUAGE: sh\nCODE:\n```\nyarn add io-ts fp-ts @farfetched/io-ts\n```\n\nLANGUAGE: sh\nCODE:\n```\nnpm install io-ts fp-ts @farfetched/io-ts\n```\n\n----------------------------------------\n\nTITLE: Install OpenAPI Generator and Effector Preset (pnpm)\nDESCRIPTION: This command installs the OpenAPI Generator, the Effector preset, and typed-contracts using pnpm. These are required for generating Effector code from OpenAPI specifications.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm add --save-dev openapi@^1.0.0 openapi-preset-effector typed-contracts\n```\n\n----------------------------------------\n\nTITLE: Throwing NetworkError in Farfetched\nDESCRIPTION: This code snippet demonstrates how to throw a `networkError` in a Farfetched query test. It imports the `networkError` function from `@farfetched/core` and uses it within a mocked handler for `query.__.executeFx`. The `reason` parameter describes the network problem. The test asserts the error within the scope.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/utils/error_creators.md#_snippet_5\n\nLANGUAGE: typescript\nCODE:\n```\nimport { networkError } from '@farfetched/core';\n\ntest('on error', async () => {\n  const scope = fork({\n    handlers: [\n      [\n        query.__.executeFx,\n        vi.fn(() => {\n          throw networkError({\n            reason: 'Can not',\n          });\n        }),\n      ],\n    ],\n  });\n});\n```\n\n----------------------------------------\n\nTITLE: TAKE_FIRST concurrency strategy in Farfetched\nDESCRIPTION: This code snippet demonstrates the `TAKE_FIRST` concurrency strategy, where only the first operation is executed. Subsequent operation calls are skipped if there are any in-flight operations.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/concurrency.md#_snippet_3\n\nLANGUAGE: typescript\nCODE:\n```\nimport { concurrency, createQuery } from '@farfetched/core';\n\nconst query = createQuery({\n  /* ... */\n});\n\nconcurrency(query, { strategy: 'TAKE_FIRST' });\n```\n\n----------------------------------------\n\nTITLE: Installing Runtypes and Farfetched\nDESCRIPTION: Install Runtypes and @farfetched/runtypes using pnpm, yarn, or npm. This package enables integration between Farfetched and Runtypes for data validation.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/api/contracts/runtypes.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install runtypes @farfetched/runtypes\n```\n\n----------------------------------------\n\nTITLE: Installing Effector React Bindings with yarn\nDESCRIPTION: This command installs the `effector-react` package, which provides React bindings for Effector, enabling the use of Effector stores and effects in React components. This is a prerequisite for integrating Farfetched with React. The package manager used is yarn.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/react/index.md#_snippet_1\n\nLANGUAGE: sh\nCODE:\n```\nyarn add effector-react\n```\n\n----------------------------------------\n\nTITLE: Vue.js: Importing and Iterating over Releases\nDESCRIPTION: This snippet imports release data from `./releases.data` and then iterates through the `releases` array using `v-for` to create a list of links.  Each link's `href` and text are bound to properties of the `release` object in the array. The `sidebar: false` frontmatter disables the sidebar.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/index.md#_snippet_0\n\nLANGUAGE: vue.js\nCODE:\n```\n<script setup>\n    import { data as releases } from './releases.data'\n</script>\n\n<ul>\n    <li v-for=\"release in releases\">\n        <a :href=\"release.link\">{{release.text}}</a>\n    </li>\n</ul>\n```\n\n----------------------------------------\n\nTITLE: Running OpenAPI Code Generation (npm)\nDESCRIPTION: This command runs the OpenAPI Generator using npm to generate code based on the configuration file.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/recipes/open_api.md#_snippet_7\n\nLANGUAGE: sh\nCODE:\n```\nnpm openapi\n```\n\n----------------------------------------\n\nTITLE: Installing Effector React Bindings with npm\nDESCRIPTION: This command installs the `effector-react` package, which provides React bindings for Effector, enabling the use of Effector stores and effects in React components. This is a prerequisite for integrating Farfetched with React. The package manager used is npm.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/react/index.md#_snippet_2\n\nLANGUAGE: sh\nCODE:\n```\nnpm install effector-react\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched with pnpm\nDESCRIPTION: This snippet demonstrates how to install Farfetched and its peer dependency, Effector, using the pnpm package manager. It ensures that the core functionality of Farfetched is available for use.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/install.md#_snippet_0\n\nLANGUAGE: sh\nCODE:\n```\npnpm install @farfetched/core effector\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched Dev Tools with yarn\nDESCRIPTION: This command installs the `@farfetched/dev-tools` package using yarn. It adds the package as a dependency to the project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/devtools.md#_snippet_1\n\nLANGUAGE: shell\nCODE:\n```\nyarn add @farfetched/dev-tools\n```\n\n----------------------------------------\n\nTITLE: Importing Statements Data in Vue\nDESCRIPTION: This snippet imports the `statements.data` file containing the statements for the Farfetched library's development principles. It uses Vue's `<script setup>` syntax for concise component setup.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/statements/index.md#_snippet_0\n\nLANGUAGE: vue\nCODE:\n```\n<script setup>\n    import { data as statements } from './statements.data'\n</script>\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched Dev Tools with pnpm\nDESCRIPTION: This command installs the `@farfetched/dev-tools` package using pnpm. It adds the package as a dependency to the project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/devtools.md#_snippet_0\n\nLANGUAGE: shell\nCODE:\n```\npnpm install @farfetched/dev-tools\n```\n\n----------------------------------------\n\nTITLE: Migrating retry operator in Farfetched with TypeScript\nDESCRIPTION: This code snippet illustrates the migration from the deprecated `retry(config)` overload to `retry(operation, config)`. The code shows the old and new ways to use the `retry` operator with a Query, highlighting the change in parameter order.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/releases/0-3.md#_snippet_1\n\nLANGUAGE: typescript\nCODE:\n```\nretry(\n  someQuery, // [!code ++]\n  {\n    query: someQuery, // [!code --]\n    times: 3,\n    delay: 1000,\n  }\n);\n```\n\n----------------------------------------\n\nTITLE: Installing Farfetched Dev Tools with npm\nDESCRIPTION: This command installs the `@farfetched/dev-tools` package using npm. It adds the package as a dependency to the project.\nSOURCE: https://github.com/igorkamyshev/farfetched/blob/master/apps/website/docs/tutorial/devtools.md#_snippet_2\n\nLANGUAGE: shell\nCODE:\n```\nnpm install @farfetched/dev-tools\n```"
  }
]