[
  {
    "owner": "jdrouet",
    "repo": "mrml",
    "content": "TITLE: Using MRML in Rust: Synchronous Parsing and Rendering with HTTP Include Loader\nDESCRIPTION: This code demonstrates how to parse an MJML template and render it to HTML synchronously using the `mrml` crate with HTTP include support. It sets up parser options with an HTTP loader, parses a template string, and then renders the resulting MJML structure, handling errors appropriately. Dependencies include `mrml`, `serde`, and `std::collections::HashSet`. This snippet showcases the core workflow for processing MJML templates in a Rust application.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/readme.md#_snippet_0\n\nLANGUAGE: rust\nCODE:\n```\nuse mrml::prelude::parser::http_loader::{HttpIncludeLoader, BlockingReqwestFetcher};\nuse mrml::prelude::parser::ParserOptions;\nuse mrml::prelude::render::RenderOptions;\nuse std::collections::HashSet;\n\n\nfn main() {\n  let resolver = HttpIncludeLoader::<BlockingReqwestFetcher>::new_allow(HashSet::from([\"http://localhost\".to_string()]));\n  let parser_options = ParserOptions {\n      include_loader: Box::new(resolver),\n  };\n  let render_options = RenderOptions::default();\n  let template = r#\"<mjml>\n  <mj-body>\n    <mj-include path=\"http://localhost/partials/mj-body.mjml\" />\n  </mj-body>\n</mjml>\"#;\n  match mrml::parse_with_options(template, &parser_options) {\n      Ok(mjml) => match mjml.render(&render_options) {\n        Ok(html) => println!(\"{html}\"),\n        Err(err) => eprintln!(\"Couldn't render template: {err:?}\"),\n      },\n      Err(err) => eprintln!(\"Couldn't parse template: {err:?}\"),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Using MRML in Rust: Asynchronous Parsing and Rendering with Multi-Source Include Loader\nDESCRIPTION: This code shows how to perform asynchronous parsing and rendering of an MJML template with complex include sources using the `mrml` crate. It configures a multi-source include loader (local files, HTTP), wraps it in an async parser options structure, and processes the template string asynchronously, with result handling. It requires dependencies like `mrml`, `tokio`, and `std::sync::Arc`. It demonstrates non-blocking processing suitable for async Rust applications.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/readme.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mrml::mj_include::body::MjIncludeBodyKind;\nuse mrml::prelude::parser::http_loader::{AsyncReqwestFetcher, HttpIncludeLoader};\nuse mrml::prelude::parser::local_loader::LocalIncludeLoader;\nuse mrml::prelude::parser::memory_loader::MemoryIncludeLoader;\nuse mrml::prelude::parser::multi_loader::{MultiIncludeLoader, MultiIncludeLoaderItem, MultiIncludeLoaderFilter};\nuse mrml::prelude::parser::noop_loader::NoopIncludeLoader;\nuse mrml::prelude::parser::loader::AsyncIncludeLoader;\nuse mrml::prelude::parser::AsyncParserOptions;\nuse mrml::prelude::render::RenderOptions;\n\n#[tokio::main]\nasync fn main() {\n  let resolver = MultiIncludeLoader::<Box<dyn AsyncIncludeLoader + Send + Sync + 'static>>::new()\n      .with_starts_with(\"file://\", Box::new(LocalIncludeLoader::new(PathBuf::default().join(\"resources\").join(\"compare\").join(\"success\"))))\n      .with_starts_with(\"https://\", Box::new(HttpIncludeLoader::<AsyncReqwestFetcher>::allow_all()))\n      .with_any(Box::<NoopIncludeLoader>::default());\n  let parser_options = AsyncParserOptions {\n      include_loader: Box::new(resolver),\n  };\n  let render_options = RenderOptions::default();\n  let json = r#\"<mjml>\n  <mj-body>\n    <mj-include path=\"file://basic.mjml\" />\n  </mj-body>\n</mjml>\"#;\n  match mrml::async_parse_with_options(json, std::sync::Arc::new(parser_options)).await {\n      Ok(mjml) => match mjml.render(&render_options) {\n        Ok(html) => println!(\"{html}\"),\n        Err(err) => eprintln!(\"Couldn't render template: {err:?}\"),\n      },\n      Err(err) => eprintln!(\"Couldn't parse template: {err:?}\"),\n  }\n}\n```\n\n----------------------------------------\n\nTITLE: Parsing and Rendering MJML Templates - MRML - Rust\nDESCRIPTION: This Rust snippet demonstrates parsing and rendering an MJML template using the MRML crate. The example initializes an MJML root node from a string, sets default rendering options, and attempts to render the template, handling errors gracefully. Dependencies include 'mrml' (imported as a crate) and the Rust standard library. The expected input is a string containing valid MJML markup, and the output is printed HTML content; errors during parsing or rendering are caught and logged. Requires prior inclusion of mrml in Cargo.toml.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-core/readme.md#_snippet_1\n\nLANGUAGE: rust\nCODE:\n```\nuse mrml;\n\nfn main() {\n    let root = mrml::parse(\"<mjml><mj-body></mj-body></mjml>\").expect(\"parse template\");\n    let opts = mrml::prelude::render::Options::default();\n    match root.render(&opts) {\n        Ok(content) => println!(\"{}\", content),\n        Err(_) => println!(\"couldn't render mjml template\"),\n    };\n}\n\n```\n\n----------------------------------------\n\nTITLE: CLI usage commands for MRML in Rust\nDESCRIPTION: This snippet details the command-line instructions to install and use the MRML CLI tool, including validation, rendering, formatting, and help commands. It explains dependencies ('cargo'), input files ('path/to/template.mjml' or 'path/to/template.json'), and options like '--pretty' for pretty-print formatting.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-cli/readme.md#_snippet_0\n\nLANGUAGE: Shell\nCODE:\n```\ncargo install --locked mrml-cli\nmrml-cli path/to/template.mjml validate\nmrml-cli path/to/template.mjml render\nmrml-cli path/to/template.mjml format-json --pretty\nmrml-cli path/to/template.json format-mjml --pretty\nmrml-cli --help\n```\n\n----------------------------------------\n\nTITLE: Converting MJML to HTML with mrml-python\nDESCRIPTION: This code snippet demonstrates how to use the `mrml` library to convert MJML markup into HTML. It showcases usage with and without custom parser options. The example uses `mrml.memory_loader` to include a mjml file.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-python/readme.md#_snippet_0\n\nLANGUAGE: python\nCODE:\n```\nimport mrml\n\n# without options\nresult = mrml.to_html(\"<mjml></mjml>\")\nassert result.content.startswith(\"<!doctype html>\")\n\n# with options\nparser_options = mrml.ParserOptions(include_loader = mrml.memory_loader({\n    'hello-world.mjml': '<mj-text>Hello World!</mj-text>',\n}))\nresult = mrml.to_html(\"<mjml><mj-body><mj-include path=\\\"hello-world.mjml\\\" /></mj-body></mjml>\", parser_options = parser_options)\nassert result.content.startswith(\"<!doctype html>\")\n```\n\n----------------------------------------\n\nTITLE: Performance comparison between Node.js and Rust implementations\nDESCRIPTION: This snippet compares the startup and stress-test RAM usage, request handling capacity, and rendering speed of MJML processors in Node.js versus Rust. It emphasizes the efficiency and scalability benefits of using the Rust implementation, with specific benchmark times and resource consumption metrics.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-cli/readme.md#_snippet_1\n\nLANGUAGE: Markdown\nCODE:\n```\n- Node: 606.59ms\n- Rust: 3.48ms\n```\n\n----------------------------------------\n\nTITLE: Using MRML Engine in Browser JavaScript\nDESCRIPTION: Example code showing how to import and use the MRML engine in a browser environment. Creates an engine instance and converts simple MJML markup to HTML.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-wasm/README.md#_snippet_0\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Engine } from \"mrml\";\n\nconst engine = new Engine();\nconst result = engine.toHtml(\"<mjml><mj-body>Hello World</mj-body></mjml>\");\n```\n\n----------------------------------------\n\nTITLE: Using MRML Engine in Node.js\nDESCRIPTION: Example code showing how to require and use the MRML engine in a Node.js environment. Creates an engine instance and converts simple MJML markup to HTML.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-wasm/README.md#_snippet_1\n\nLANGUAGE: javascript\nCODE:\n```\nconst { Engine } = require(\"mrml/node/mrml\");\n\nconst engine = new Engine();\nconst result = engine.toHtml(\"<mjml><mj-body>Hello World</mj-body></mjml>\");\n```\n\n----------------------------------------\n\nTITLE: Adding MRML and Serde Dependencies - Cargo.toml - TOML\nDESCRIPTION: This snippet demonstrates how to declare MRML and Serde dependencies in the Cargo.toml manifest for a Rust project. The 'mrml' crate provides the MJML processing capabilities, while 'serde' is included for serialization/deserialization, with the 'derive' feature enabled. Add this section under '[dependencies]' in your Cargo.toml file to enable MRML functionality. No additional parameters are needed; ensure Rust and Cargo are installed.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/packages/mrml-core/readme.md#_snippet_0\n\nLANGUAGE: toml\nCODE:\n```\n[dependencies]\nmrml = \"2\"\nserde = { version = \"1.0\", features = [\"derive\"] }\n\n```\n\n----------------------------------------\n\nTITLE: Building and Running MRML Benchmarks with Docker\nDESCRIPTION: Commands to build a Docker image for benchmarking MRML and running the benchmark against different MJML templates.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/benchmarks/readme.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# Building docker image\ndocker build -f benchmarks/Dockerfile -t mrml-bench .\n# Running benchmark\ndocker run --rm mrml-bench /air-astana.mjml\ndocker run --rm mrml-bench /amario.mjml\n```\n\n----------------------------------------\n\nTITLE: Building and Linking mrml-wasm Package (Bash)\nDESCRIPTION: This script outlines the steps to build the mrml-wasm package, navigate into the package directory, create a local yarn link for the package, return to the demo example directory, and finally link the locally built mrml package into the demo project. This is typically done for local development and testing.\nSOURCE: https://github.com/jdrouet/mrml/blob/main/examples/demo/README.md#_snippet_0\n\nLANGUAGE: bash\nCODE:\n```\n# go to packages/mrml-wasm\nbash build.sh\ncd pkg\nyarn link\n# go back to examples/demo\nyarn link mrml\n```"
  }
]